#! /bin/sh /usr/share/dpatch/dpatch-run
## sync to 483 ojp svn.dpatch by  <root@debian>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: No description.

@DPATCH@

diff -urN -xdebian -x.svn ./ChangeLog /usr/src/openjpeg/trunk/ChangeLog
--- ./ChangeLog	2007-12-01 19:18:15.000000000 +0000
+++ /usr/src/openjpeg/trunk/ChangeLog	2007-12-01 18:40:47.000000000 +0000
@@ -5,6 +5,206 @@
 ! : changed
 + : added
 
+November 29, 2007
+! [GB] Added index.h and index.c in VC6 projects; wrapped index.h in the C++ preprocessor; modified OPJViewer project and some files.
+
+November 14, 2007
++ [FOD] Created the file index.c in the codec directory. This file handles the creation of index files, 
+		at encoding and decoding. 
+* [FOD] Fixed bugs during the creation of the index (PCRL progression order)
+* [FOD] Fixed the maximum number of resolutions a user can discard while decoding.
+		Added an error state in J2K_STATE (j2k.c)
+
+November 14, 2007
+! [FOD] - First Patch by Callum Lerwick. Instead of reinventing realloc, j2k_read_sod now just uses opj_realloc in j2k.c
+		- Second Patch by Callum Lerwick. This patch rearranges the largest memory allocations so they're allocated as 
+		late as possible, and freed as soon as possible. This cuts memory usage by about half on two large test images.
+		- Third Patch by Callum Lerwick. The opj_tcd_cblk array is one of the largest allocations, because it
+		contains a bunch of static buffers. This also makes it a major source of cache thrashing. This patch allocates 
+		the buffers from the heap, and dynamically sizes them in the decoder. I have not yet managed to dynamically size 
+		them in the encoder, getting the decoder to do it was tricky enough... I also split opj_tcd_cblk_t into separate 
+		encode and decode versions. A lot of fields were not used by both, so this cuts its size even further.
+
+* [FOD] Avoided ABI breakage
+
+November 13, 2007
+! [FOD] Patch by Dzonatas and Callum Lerwick.
+        Fp/vectorization patch which basically converts most of the irreversible decode codepath to floating point,
+        eliminating a few rounds of int/fp conversion, resulting in a vast performance improvement,
+	and an increase in accuracy.
+
+November 8, 2007
+! [FOD] In t1.c, small change to avoid calling twice t1_getwmsedec()
+        Patches from Callum Lewick:
+		- Basic gcc optimization flags in cmake and makefile match.
+		- Fixed some spelling errors in dwt.c.
+
+November 5, 2007
+*+ [GB] Fixed a bug which prevented JPWL from working on multi-tiled images; added some more fields in the interface info structures 
+(keep a list of markers, save start packet number for each tile)
+
+October 23, 2007
+* [GB] Improved success for the linux build; OPJViewer shows all the COM contents
+ 
+October 18, 2007
+* [FOD] Changed the ROI parameter in the image_to_j2k codec to make it correspond to the documentation (i.e. -ROI c=0,U=25)
+* [FOD] Patch from Callum Lewick. Memset patch. 
+		The main idea of the patch is that currently opj_malloc clears all allocations, which unnecessarily
+		dirties up the cache and eats bandwidth. This patch makes it no longer do so, and I've painstakingly determined which allocations actually need
+		to be cleared and changed them to use opj_calloc() instead. I previously tried to just get rid of the opj_*alloc wrappers but that
+		idea was nixed, so this time I'm trying it with macros. I also put in a gcc pragma that helps enforce their use. Which got messy.  :)  It caught a
+		few places they weren't used but it also revealed that the mj2 tools are not very cleanly separated from the library. It includes all the
+		internal headers, but it wasn't using the malloc wrappers. I figured the binaries should be "external" and have minimal knowledge of the
+		internals of the library. I patched them to not include opj_includes.h, and include only the internal headers they actually need. However,
+		they're using the opj_clock() function, which is in with the malloc wrappers. So I decided to move the malloc wrappers to their own header. 
+		But mj2.c seems to want to be "internal", so I patched it to use the wrappers. Note that this patch changes the semantics of opj_malloc, it no longer
+		clears the memory it allocates. If you need it to be cleared, you must use opj_calloc instead, or memset it yourself. It is also somewhat
+		invasive, please test it extensively. I've been pounding on it all summer with my test suite, Second Life, and valgrind, and it checks out clean.
+
+October 12, 2007
+* [FOD] Changed the way the image structure is allocated when the decoding parameters include some resolutions to discard. 
+        This should have a significant impact for the decoding of huge images when some resolutions are discarder (-r parameter)
+        Warning: The output image size is now reduced when discarding resolutions !
+
+October 10, 2007
+* [FOD] Patch from Callum Lewick. Clean up of j2klib.h for the aligned malloc stuff. 
+        It makes it work right with mingw, as _mm_malloc() isn't a macro, attempts to pave the way to using cmake 
+        to check for this stuff and combines a patch from Dana Fagerstrom at Sun that makes it use memalign() on Solaris
+        convert.c: Changed some error comments for TIFF images
+
+September 27, 2007
+* [FOD] Patch from Callum Lewick. Fixed dwt.c where an alignment in buffer was problematic under x86_64.
+
+September 25, 2007
+* [Mathieu Malaterre] BUG: Fix previous patch from Callum Lerwick. I have no
+    clue what CMAKE_INSTALL_LIBDIR refers too. Bump up cmake 2.2 restriction to
+    cmake 2.4 because of previous patch (not backward compatible). Properly set the SOVERSION in a cross plateform way (yes WIN32 is a platform)
+
+September 19, 2007
+* [Parvatha] Fixed issues with generation of SOP marker. 
+
+September 18, 2007
+* [Parvatha] Fixed issues with Reading and Writing TIF images in convert.c to avoid segmentation fault. 
+* [Parvatha] Fixed issues relating to using user specified rates for CINEMA option for multiple images.
+
+September 17, 2007
+* [FOD] Fixed issues with cstr_info when codestream has components with different number of resolutions. 
+! [FOD] OpenJPEG library interface modified to retain compatibility with version 1.2 
+
+September 12, 2007
+* [FOD] Patch from Callum Lerwick.
+		Fixed the library linking so it links with the soversion properly set. 
+		Fixes up the install targets so that it interacts properly with RPM. 
+		Install target for MJ2. Sets some necessary and useful CFLAGS if gcc is in use.		
+* [FOD] Updated the MJ2 codec to be compatible with the recent changes in the OpenJPEG library
+
+September 11, 2007
+* [GB] JPWL encoding is finalized correctly into the JP2 file format; added an additional structure in opj_codestream_info, to keep a record of the written markers
+
+September 8, 2007
+* [GB] Adapted the JPWL and OPJViewer code to new interface; fixed a samll bug in JPWL which created large EPBs even when null protection was specified
+
+September 7, 2007
++ [FOD] Indexes can now be generated when decoding J2K codestreams.
+* [Mathieu Malaterre] Upon failure, properly return error code (!=0).
+* [Mathieu Malaterre] CMake: Add cmake code to do testing if user has properly setup a testimages directory
+
+September 6, 2007
++ [Mathieu Malaterre] CMake: start compiling mj2, jpwl and jp3d
++ [Mathieu Malaterre] CMake: output all executable/libs into one single directory
++ [Mathieu Malaterre] CMake: start compiling index_create
++ [Mathieu Malaterre] OpenJPEG.rc update copyright year
++ [Mathieu Malaterre] CMake: add Java j2kviewer but do not compile it using cmake since cmake has too poor support for Java. Should create a custom command running ant instead.
++ [Mathieu Malaterre] CMake: Add doxygen output
++ [GB] One more field in the codestream_info struct for recording the number of packets per tile part; JPWL now distributes the EPBs in all the tile part headers
++ [Mathieu Malaterre] CMake: Add very simple tests (simply run command line with no option)
+* [Mathieu Malaterre] Fix unitialized read in img_fol (we may need a smarter initialize than memset)
+
+September 4, 2007
++ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. 
+		Changed also the write_index function in the codec, to reflect the presence of this new information.
+
+September 3, 2007
++ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: 
+		no real security function at this stage. Deprecated USE_JPSEC will be removed next
+
+August 31, 2007
+* [GB] Fixed save capabilities in OPJViewer due to recent code upgrade
+
+August 30, 2007
+* [FOD] Changed the OpenJPEG library interface to enable users to access information regarding the codestream (also called codestream index).
+		This index is usefull for all applications requiring to have a scalable acces to the codestream (like JPIP applications, ...)
+        Currently, this information is only available when encoding an image.       
++ [FOD] Added the information regarding the end of packet position in the index        
+
+August 28, 2007
+* [FOD] Fixed wrong destructors called in openjpeg.c
+* [FOD] Fixed bug in j2k_decode_jpt_stream
+
+August 24, 2007
+* [Parvatha] The end of main header is calculated after TLM and POC marker for Dcinema.
+
+August 21, 2007
++ [FOD] Added support for Visual Studio 2005
+* [FOD] Robustified MJ2 codecs
+* [Parvatha] Solved problems with codec reading from image file directory when filename had more than one "." in name
+* [Callum Lerwick] Minor cleanup patch, that gets rid of a bunch of "old style declaration" warnings from Intel's compiler
+* [Callum Lerwick] Aligned malloc using Intel's _mm_malloc(). Cleanup on the t1 memory allocation, getting rid of some leftover debug code
+* [Callum Lerwick] Memory leaks fixed
+* [Callum Lerwick] Reworks of t1_updateflags to get rid of the shift operation
+* [Callum Lerwick] mqc_setcurctx moved to the header to allow it to be inlined into the t1.
+* [Callum Lerwick] Consolidated some calls to mqc_setcurctx.
+* [Callum Lerwick] Cleaned up t1_generate_luts to output the proper types.
+* [Callum Lerwick] Replaced the large ctxno_mag lookup table with a small bit of inline-able branchless code
+* [Callum Lerwick] Moved the orient flipping into the ctxno_zc table.
+
+August 20, 2007
++ [FOD] Added support for the TGA file format in the codec
+
+August 08, 2007
+* [Parvatha] Fixed the DCinema filesize allocation. It now includes the SOT marker size
+
+August 02, 2007
++ [GB] Added a basic saving capability to OPJViewer
+
+July 18, 2007
+! [FOD] Updated libtiff library version to 3.8.2 (for WIN32)
+* [FOD] Updated BMP and PxM truncation when decoding J2K files with more than 8 bits
+
+July 17, 2007
+* [FOD] Fixed raw option for images with more than three components
+
+July 17, 2007
++ [FOD] Added support for RAW images. This module has been developped by the University of Perugia team. Thanks to them ! [image_to_j2k.c j2k_to_image.c convert.c convert.h]
+
+July 13, 2007
+! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, 
+		leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
+! [FOD] Modified old comments about the ability to decode mega-images and comments about the disk size necessary to do this. [image_to_j2k.c and frames_to_mj2.c]
+* [FOD] Added 2000 bytes for the memory allocation in cio.c for the minimum size of headers (useful in case of very small images) [cio.c]
+
+July 12, 2007
+* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, 
+		even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension 
+		is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
+
+July 8, 2007
+* [ANTONIN] fixed the size of the memory allocation in cio.c (confusion between bits and bytes)
+
+June 21, 2007
+* [FOD] Output image color space set when decoding a JP2 file in jp2.c
++ [GB] Previous, home, and next frame buttons for exploring MJ2 files in OPJViewer
+
+June 18, 2007
+* [GB] Reload image doesn't crash in OPJViewer; more settings saved to registry
+ 
+June 16, 2007
++ [GB] Possibility to disable parsing in OPJViewer; also, saves common settings to the registry
+
+June 15, 2007
+* [FOD] Fixed the generation of index files 
+
+
 ----------------------
 MAY 4, 2007
 VERSION 1.2.0 RELEASED
@@ -21,13 +221,16 @@
 * [FOD] Fixed the parameters used for cinema compression (9-7 transform used instead of 5-3). Modified "image_to_j2k.c"
 
 May 24, 2007
-* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker the value of numlayers and numresolution.
+* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker 
+		the value of numlayers and numresolution.
 
 May 23, 2007
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This makes the t1 data arrays dynamic, which greatly reduces cache thrashing. Also, some minor cleanup to prevent unnecessary casts"
 
 May 22, 2007
-! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, 
+		so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix 
+		increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This changes the flag code in t1 to use a flag_t type, which can then be changed to reduce RAM usage. It is now typedef to a short."
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This patch makes the t1 LUTs static. I actually intend this as a prelude to possibly eliminating some or all of the LUTs entirely."
 
@@ -76,14 +279,17 @@
 * [Parvatha] Equation to check multiple tile precincts. Modification pi.c
 ! [Parvatha] array size generation of pi->include in pi_initialise_encode().Modification in pi.c
 * [Parvatha] modification in pi_create_encode for tile part generation.Modification in pi.c
-+ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
++ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. 
+			 This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
 
 March 28, 2007
 * [FOD] Fixed an historical bug in t1.c that leaded to the inclusion of useless 0xFF in the codestream. Thanks to Sylvain, Pascal and Parvatha !
 
 March 27, 2007
-+ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
-* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
++ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; 
+		can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
+* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, 
+		have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
 + [GB] Added linking to TIFF library in the JPWL VC6 workspaces
 
 March 23, 2007
@@ -129,7 +335,8 @@
 ----------------------
 
 February 23, 2007
-* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
+* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. 
+		As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
 + [GB] Linux makefile for the JPWL module; newlines at end of JPWL files
 
 February 22, 2007
diff -urN -xdebian -x.svn ./CMakeLists.txt /usr/src/openjpeg/trunk/CMakeLists.txt
--- ./CMakeLists.txt	2007-12-01 19:18:15.000000000 +0000
+++ /usr/src/openjpeg/trunk/CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
@@ -7,8 +7,7 @@
 # For this purpose you can define a CMake var: OPENJPEG_NAMESPACE to whatever you like
 # e.g.:
 # SET(OPENJPEG_NAMESPACE "GDCMOPENJPEG")
-PROJECT(OPENJPEG C)
-CMAKE_MINIMUM_REQUIRED(VERSION 2.2)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
 
 IF(NOT OPENJPEG_NAMESPACE)
   SET(OPENJPEG_NAMESPACE "OPENJPEG")
@@ -17,24 +16,38 @@
 # In all cases:
 STRING(TOLOWER ${OPENJPEG_NAMESPACE} OPENJPEG_LIBRARY_NAME)
 
-PROJECT(${JPEG_NAMESPACE} C)
+PROJECT(${OPENJPEG_NAMESPACE} C)
 
 # Do full dependency headers.
 INCLUDE_REGULAR_EXPRESSION("^.*$")
 
 #-----------------------------------------------------------------------------
-# OPENJPEG version number, usefull for packaging and doxygen doc:
-SET(OPENJPEG_MAJOR_VERSION 1)
-SET(OPENJPEG_MINOR_VERSION 0)
-SET(OPENJPEG_BUILD_VERSION 0)
+# OPENJPEG version number, useful for packaging and doxygen doc:
+SET(OPENJPEG_VERSION_MAJOR 1)
+SET(OPENJPEG_VERSION_MINOR 2)
+SET(OPENJPEG_VERSION_BUILD 0)
 SET(OPENJPEG_VERSION
-  "${OPENJPEG_MAJOR_VERSION}.${OPENJPEG_MINOR_VERSION}.${OPENJPEG_BUILD_VERSION}")
+  "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}")
+
+# This setting of SOVERSION assumes that any API change
+# will increment either the minor or major version number of openjpeg
+SET(OPENJPEG_LIBRARY_PROPERTIES
+  VERSION   "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}"
+  SOVERSION "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}"
+)
+
 
 #-----------------------------------------------------------------------------
 # OpenJPEG build configuration options.
 OPTION(BUILD_SHARED_LIBS "Build OpenJPEG with shared libraries." OFF)
 
 #-----------------------------------------------------------------------------
+SET (EXECUTABLE_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all executables.")
+SET (LIBRARY_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all libraries.")
+MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH)
+
+
+#-----------------------------------------------------------------------------
 # For the codec...
 OPTION(BUILD_EXAMPLES "Build the Examples (codec...)." OFF)
 
@@ -53,7 +66,19 @@
 INCLUDE_DIRECTORIES(BEFORE ${CMAKE_CURRENT_BINARY_DIR})
 SUBDIRS(
   libopenjpeg
+  mj2
+  # cmake 2.4.5 has poor java support
+  #j2kviewer/src
   )
+
+IF(NOT UNIX)
+SUBDIRS(
+  jpwl
+  jp3d
+  indexer_JPIP
+  )
+ENDIF(NOT UNIX)
+
 #-----------------------------------------------------------------------------
 # Build example only if requested
 IF(BUILD_EXAMPLES)
@@ -61,8 +86,15 @@
 ENDIF(BUILD_EXAMPLES)
 
 #-----------------------------------------------------------------------------
+# For the documentation
+OPTION(BUILD_DOCUMENTATION "Build the doxygen documentation" OFF)
+IF(BUILD_DOCUMENTATION)
+  SUBDIRS(doc)
+ENDIF(BUILD_DOCUMENTATION)
+
+#-----------------------------------------------------------------------------
 # For openjpeg team if they ever want Dart+CMake
-IF(OPJ_STANDALONE)
+IF(OPENJPEG_STANDALONE)
   INCLUDE(Dart)
   MARK_AS_ADVANCED(BUILD_TESTING DART_ROOT TCL_TCLSH)
   IF(BUILD_TESTING)
@@ -70,8 +102,25 @@
     SET(BUILDNAME "OpenJPEG-${CMAKE_SYSTEM}-${CMAKE_C_COMPILER}" CACHE STRING "Name of build on the dashboard")
     MARK_AS_ADVANCED(BUILDNAME)
   ENDIF(BUILD_TESTING)
-ENDIF(OPJ_STANDALONE)
+ENDIF(OPENJPEG_STANDALONE)
 
-# TODO, technically we should add tests, e.g:
+# Adding test with dataset from:
 # http://www.crc.ricoh.com/~gormish/jpeg2000conformance/
+# http://www.jpeg.org/jpeg2000guide/testimages/testimages.html
+
+#-----------------------------------------------------------------------------
+# Adding JPEG2000_CONFORMANCE_DATA_ROOT
+FIND_PATH(JPEG2000_CONFORMANCE_DATA_ROOT testimages.html
+  ${OPENJPEG_SOURCE_DIR}/../jpeg2000testimages
+  $ENV{JPEG2000_CONFORMANCE_DATA_ROOT}
+)
+
+#-----------------------------------------------------------------------------
+# Compiler specific flags:
+IF(CMAKE_COMPILER_IS_GNUCC)
+  # For all builds, make sure openjpeg is std99 compliant:
+  SET(CMAKE_C_FLAGS "-Wall -std=c99 ${CMAKE_C_FLAGS}")
+  # Do not use ffast-math for all build, it would produce incorrect results, only set for release:
+  SET(CMAKE_C_FLAGS_RELEASE "-ffast-math ${CMAKE_C_FLAGS_RELEASE}")
+ENDIF(CMAKE_COMPILER_IS_GNUCC)
 
diff -urN -xdebian -x.svn ./codec/CMakeLists.txt /usr/src/openjpeg/trunk/codec/CMakeLists.txt
--- ./codec/CMakeLists.txt	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
@@ -3,7 +3,9 @@
 # First thing define the common source:
 SET(common_SRCS
   convert.c
-  )
+  index.c
+)
+
 # Then check if getopt is present:
 INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
 SET(DONT_HAVE_GETOPT 1)
@@ -24,7 +26,6 @@
   )
 ENDIF(DONT_HAVE_GETOPT)
 
-
 # Headers file are located here:
 INCLUDE_DIRECTORIES(
   ${OPENJPEG_SOURCE_DIR}/libopenjpeg
@@ -42,12 +43,26 @@
 FOREACH(exe j2k_to_image image_to_j2k)
   ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
   TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjpeg ${TIFF_LIBRARIES})
+  ADD_TEST(${exe} ${EXECUTABLE_OUTPUT_PATH}/${exe})
+  # calling those exe without option will make them fail always:
+  SET_TESTS_PROPERTIES(${exe} PROPERTIES WILL_FAIL TRUE)
   # On unix you need to link to the math library:
   IF(UNIX)
-    TARGET_LINK_LIBRARIES(${exe} -lm)
+    TARGET_LINK_LIBRARIES(${exe} m)
   ENDIF(UNIX)
   # Install exe
   INSTALL_TARGETS(/bin/ ${exe})
 ENDFOREACH(exe)
 
+# Do testing here, once we know the examples are being built:
+FILE(GLOB_RECURSE OPENJPEG_DATA_IMAGES_GLOB
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2k"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2c"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.jp2"
+  )
+
+FOREACH(filename ${OPENJPEG_DATA_IMAGES_GLOB})
+  GET_FILENAME_COMPONENT(filename_temp ${filename} NAME)
+  ADD_TEST(j2i-${filename_temp} ${EXECUTABLE_OUTPUT_PATH}/j2k_to_image -i ${filename} -o ${filename_temp}.tif)
+ENDFOREACH(filename)
 
diff -urN -xdebian -x.svn ./codec/compat/getopt.c /usr/src/openjpeg/trunk/codec/compat/getopt.c
--- ./codec/compat/getopt.c	2007-11-29 18:27:38.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/compat/getopt.c	2007-09-28 11:33:51.000000000 +0100
@@ -251,7 +251,7 @@
 		
 		}// end of single character
 	}//end '-'
-	fprintf(stderr,"Invalid option %s\n");
+	fprintf(stderr,"Invalid option\n");
 	++optind;
 	return (BADCH);;
 }//end function
diff -urN -xdebian -x.svn ./codec/convert.c /usr/src/openjpeg/trunk/codec/convert.c
--- ./codec/convert.c	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/convert.c	2007-11-27 22:39:51.000000000 +0000
@@ -34,6 +34,7 @@
 #include <string.h>
 #include "openjpeg.h"
 #include "../libs/libtiff/tiffio.h"
+#include "convert.h"
 
 /*
  * Get logarithm of an integer and round downwards.
@@ -66,6 +67,300 @@
 	return (a + b - 1) / b;
 }
 
+
+/* -->> -->> -->> -->>
+
+  TGA IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+// TGA header definition.
+#pragma pack(push,1) // Pack structure byte aligned
+typedef struct tga_header
+{                           
+    uint8   id_length;              /* Image id field length    */
+    uint8   colour_map_type;        /* Colour map type          */
+    uint8   image_type;             /* Image type               */
+    /*
+    ** Colour map specification
+    */
+    uint16  colour_map_index;       /* First entry index        */
+    uint16  colour_map_length;      /* Colour map length        */
+    uint8   colour_map_entry_size;  /* Colour map entry size    */
+    /*
+    ** Image specification
+    */
+    uint16  x_origin;               /* x origin of image        */
+    uint16  y_origin;               /* u origin of image        */
+    uint16  image_width;            /* Image width              */
+    uint16  image_height;           /* Image height             */
+    uint8   pixel_depth;            /* Pixel depth              */
+    uint8   image_desc;             /* Image descriptor         */
+} tga_header;
+#pragma pack(pop) // Return to normal structure packing alignment.
+
+int tga_readheader(FILE *fp, int *bits_per_pixel, int *width, int *height, int *flip_image)
+{
+	int palette_size;
+	tga_header tga ;
+
+	if (!bits_per_pixel || !width || !height || !flip_image)
+		return 0;
+	
+	// Read TGA header
+	fread((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	*bits_per_pixel = tga.pixel_depth;
+	
+	*width  = tga.image_width;
+	*height = tga.image_height ;
+
+	// Ignore tga identifier, if present ...
+	if (tga.id_length)
+	{
+		uint8 *id = (uint8 *) malloc(tga.id_length);
+		fread(id, tga.id_length, 1, fp);
+		free(id);  
+	}
+
+	// Test for compressed formats ... not yet supported ...
+	// Note :-  9 - RLE encoded palettized.
+	//	  	   10 - RLE encoded RGB.
+	if (tga.image_type > 8)
+	{
+		fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
+		return 0 ;
+	}
+
+	*flip_image = !(tga.image_desc & 32);
+
+	// Palettized formats are not yet supported, skip over the palette, if present ... 
+	palette_size = tga.colour_map_length * (tga.colour_map_entry_size/8);
+	
+	if (palette_size>0)
+	{
+		fprintf(stderr, "File contains a palette - not yet supported.");
+		fseek(fp, palette_size, SEEK_CUR);
+	}
+	return 1;
+}
+
+int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height, bool flip_image)
+{
+	tga_header tga;
+
+	if (!bits_per_pixel || !width || !height)
+		return 0;
+
+	memset(&tga, 0, sizeof(tga_header));
+
+	tga.pixel_depth = bits_per_pixel;
+	tga.image_width  = width;
+	tga.image_height = height;
+	tga.image_type = 2; // Uncompressed.
+	tga.image_desc = 8; // 8 bits per component.
+
+	if (flip_image)
+		tga.image_desc |= 32;
+
+	// Write TGA header
+	fwrite((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	return 1;
+}
+
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters) {
+	FILE *f;
+	opj_image_t *image;
+	uint32 image_width, image_height, pixel_bit_depth;
+	uint32 x, y;
+	int flip_image=0;
+	opj_image_cmptparm_t cmptparm[4];	/* maximum 4 components */
+	int numcomps;
+	OPJ_COLOR_SPACE color_space;
+	bool mono ;
+	bool save_alpha;
+	int subsampling_dx, subsampling_dy;
+	int i;	
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+
+	if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height, &flip_image))
+		return NULL;
+
+	// We currently only support 24 & 32 bit tga's ...
+	if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32)))
+		return NULL;
+
+	/* initialize image components */   
+	memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));
+
+	mono = (pixel_bit_depth == 8) || (pixel_bit_depth == 16);  // Mono with & without alpha.
+	save_alpha = (pixel_bit_depth == 16) || (pixel_bit_depth == 32); // Mono with alpha, or RGB with alpha
+
+	if (mono) {
+		color_space = CLRSPC_GRAY;
+		numcomps = save_alpha ? 2 : 1;
+	}	
+	else {
+		numcomps = save_alpha ? 4 : 3;
+		color_space = CLRSPC_SRGB;
+	}
+
+	subsampling_dx = parameters->subsampling_dx;
+	subsampling_dy = parameters->subsampling_dy;
+
+	for (i = 0; i < numcomps; i++) {
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = 0;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = image_width;
+		cmptparm[i].h = image_height;
+	}
+
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+
+	if (!image)
+		return NULL;
+
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 =	!image->x0 ? (image_width - 1) * subsampling_dx + 1 : image->x0 + (image_width - 1) * subsampling_dx + 1;
+	image->y1 =	!image->y0 ? (image_height - 1) * subsampling_dy + 1 : image->y0 + (image_height - 1) * subsampling_dy + 1;
+
+	/* set image data */
+	for (y=0; y < image_height; y++) 
+	{
+		int index;
+
+		if (flip_image)
+			index = (image_height-y-1)*image_width;
+		else
+			index = y*image_width;
+
+		if (numcomps==3)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				index++;
+			}
+		}
+		else if (numcomps==4)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b,a;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+				fread(&a, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				image->comps[3].data[index]=a;
+				index++;
+			}
+		}
+		else {
+			fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
+		}
+	}	
+	return image;
+}
+
+int imagetotga(opj_image_t * image, const char *outfile) {
+	int width, height, bpp, x, y;
+	bool write_alpha;
+	int i;
+	uint32 alpha_channel;
+	float r,g,b,a;
+	uint8 value;
+	float scale;
+	FILE *fdest;
+
+	fdest = fopen(outfile, "wb");
+	if (!fdest) {
+		fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+		return 1;
+	}
+
+	for (i = 0; i < image->numcomps-1; i++)	{
+		if ((image->comps[0].dx != image->comps[i+1].dx) 
+			||(image->comps[0].dy != image->comps[i+1].dy) 
+			||(image->comps[0].prec != image->comps[i+1].prec))	{
+      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
+      return 1;
+   }
+	}
+
+	width = image->comps[0].w;
+	height = image->comps[0].h; 
+
+	// Mono with alpha, or RGB with alpha.
+	write_alpha = (image->numcomps==2) || (image->numcomps==4);   
+
+	// Write TGA header 
+	bpp = write_alpha ? 32 : 24;
+	if (!tga_writeheader(fdest, bpp, width , height, true))
+		return 1;
+
+	alpha_channel = image->numcomps-1; 
+
+	scale = 255.0f / (float)((1<<image->comps[0].prec)-1);
+
+	for (y=0; y < height; y++) {
+		uint32 index=y*width;
+
+		for (x=0; x < width; x++, index++)	{
+			r = (float)(image->comps[0].data[index]);
+
+			if (image->numcomps>2) {
+				g = (float)(image->comps[1].data[index]);
+				b = (float)(image->comps[2].data[index]);
+			}
+			else  {// Greyscale ...
+				g = r;
+				b = r;
+			}
+
+			// TGA format writes BGR ...
+			value = (uint8)(b*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(g*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(r*scale);
+			fwrite(&value,1,1,fdest);
+
+			if (write_alpha) {
+				a = (float)(image->comps[alpha_channel].data[index]);
+				value = (uint8)(a*scale);
+				fwrite(&value,1,1,fdest);
+			}
+		}
+	}
+
+	return 0;
+}
+
 /* -->> -->> -->> -->>
 
   BMP IMAGE FORMAT
@@ -469,9 +764,10 @@
 }
 
 int imagetobmp(opj_image_t * image, const char *outfile) {
-	int w, wr, h, hr;
+	int w, h;
 	int i, pad;
 	FILE *fdest = NULL;
+	int adjustR, adjustG, adjustB;
 
 	if (image->numcomps == 3 && image->comps[0].dx == image->comps[1].dx
 		&& image->comps[1].dx == image->comps[2].dx
@@ -490,64 +786,81 @@
 			return 1;
 		}
 	    
-		/* w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), image->comps[0].dx); */
-		w = image->comps[0].w;
-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
+		w = image->comps[0].w;	    
 		h = image->comps[0].h;
-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		fprintf(fdest, "BM");
 	    
 		/* FILE HEADER */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c",
-			(unsigned char) (hr * wr * 3 + 3 * hr * (wr % 2) + 54) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 8) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 16) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 24) & 0xff);
+			(unsigned char) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
 	    
 		/* INFO HEADER   */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
-			(unsigned char) ((wr) >> 8) & 0xff,
-			(unsigned char) ((wr) >> 16) & 0xff,
-			(unsigned char) ((wr) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
-			(unsigned char) ((hr) >> 8) & 0xff,
-			(unsigned char) ((hr) >> 16) & 0xff,
-			(unsigned char) ((hr) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
 		fprintf(fdest, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * hr * wr + 3 * hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 8) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 16) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * h * w + 3 * h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 	    
-		for (i = 0; i < wr * hr; i++) {
-			unsigned char R, G, B;
-			/* a modifier */
-			/* R = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			R = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			/* G = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			G = image->comps[1].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			/* B = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			B = image->comps[2].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			fprintf(fdest, "%c%c%c", B, G, R);
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc, gc, bc;
+			int r, g, b;
+							
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+			b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+
+			fprintf(fdest, "%c%c%c", bc, gc, rc);
 			
-			if ((i + 1) % wr == 0) {
-				for (pad = (3 * wr) % 4 ? 4 - (3 * wr) % 4 : 0; pad > 0; pad--)	/* ADD */
+			if ((i + 1) % w == 0) {
+				for (pad = (3 * w) % 4 ? 4 - (3 * w) % 4 : 0; pad > 0; pad--)	/* ADD */
 					fprintf(fdest, "%c", 0);
 			}
 		}
@@ -559,24 +872,17 @@
 		<<-- <<-- <<-- <<-- */
 
 		fdest = fopen(outfile, "wb");
-		/* w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), image->comps[0].dx); */
-		w = image->comps[0].w;
-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
+		w = image->comps[0].w;	    
 		h = image->comps[0].h;
-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		fprintf(fdest, "BM");
 	    
 		/* FILE HEADER */
 		/* ------------- */
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + 54 + 1024 + hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 8) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 16) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + wr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, 
 			((54 + 1024) >> 16) & 0xff,
@@ -585,38 +891,47 @@
 		/* INFO HEADER */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
-			(unsigned char) ((wr) >> 8) & 0xff,
-			(unsigned char) ((wr) >> 16) & 0xff,
-			(unsigned char) ((wr) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
-			(unsigned char) ((hr) >> 8) & 0xff,
-			(unsigned char) ((hr) >> 16) & 0xff,
-			(unsigned char) ((hr) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
 		fprintf(fdest, "%c%c", (8) & 0xff, ((8) >> 8) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 8) &	0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 16) &	0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 8) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 16) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
 
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+
 		for (i = 0; i < 256; i++) {
 			fprintf(fdest, "%c%c%c%c", i, i, i, 0);
 		}
 
-		for (i = 0; i < wr * hr; i++) {
-			/* a modifier !! */
-			/* fprintf(fdest, "%c", image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]); */
-			fprintf(fdest, "%c", image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)]);
-			/*if (((i + 1) % w == 0 && w % 2))
-			fprintf(fdest, "%c", 0); */
-			if ((i + 1) % wr == 0) {
-				for (pad = wr % 4 ? 4 - wr % 4 : 0; pad > 0; pad--)	/* ADD */
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc;
+			int r;
+			
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			
+			fprintf(fdest, "%c", rc);
+
+			if ((i + 1) % w == 0) {
+				for (pad = w % 4 ? 4 - w % 4 : 0; pad > 0; pad--)	/* ADD */
 					fprintf(fdest, "%c", 0);
 			}
 		}
@@ -777,7 +1092,7 @@
 }
 
 int imagetopgx(opj_image_t * image, const char *outfile) {
-	int w, wr, h, hr;
+	int w, h;
 	int i, j, compno;
 	FILE *fdest = NULL;
 
@@ -812,17 +1127,11 @@
     if( total > 256 ) {
       free(name);
       }
-		/* w = int_ceildiv(image->x1 - image->x0, comp->dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), comp->dx); */
+
 		w = image->comps[compno].w;
-		wr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, comp->dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), comp->dy); */
 		h = image->comps[compno].h;
-		hr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
 	    
-		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, wr, hr);
+		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, w, h);
 		if (comp->prec <= 8) {
 			nbytes = 1;
 		} else if (comp->prec <= 16) {
@@ -830,8 +1139,8 @@
 		} else {
 			nbytes = 4;
 		}
-		for (i = 0; i < wr * hr; i++) {
-			int v = image->comps[compno].data[i / wr * w + i % wr];
+		for (i = 0; i < w * h; i++) {
+			int v = image->comps[compno].data[i];
 			for (j = nbytes - 1; j >= 0; j--) {
 				char byte = (char) (v >> (j * 8));
 				fwrite(&byte, 1, 1, fdest);
@@ -949,9 +1258,9 @@
 }
 
 int imagetopnm(opj_image_t * image, const char *outfile) {
-	int w, wr, wrr, h, hr, hrr, max;
+	int w, wr, h, hr, max;
 	int i, compno;
-	int adjust;
+	int adjustR, adjustG, adjustB, adjustX;
 	FILE *fdest = NULL;
 	char S2;
 	const char *tmp = outfile;
@@ -978,43 +1287,60 @@
 		}
 
 		w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor),image->comps[0].dx); */
 		wr = image->comps[0].w;
-		wrr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
         
 		h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
 		hr = image->comps[0].h;
-		hrr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		max = image->comps[0].prec > 8 ? 255 : (1 << image->comps[0].prec) - 1;
 	    
 		image->comps[0].x0 = int_ceildivpow2(image->comps[0].x0 - int_ceildiv(image->x0, image->comps[0].dx), image->comps[0].factor);
 		image->comps[0].y0 = int_ceildivpow2(image->comps[0].y0 -	int_ceildiv(image->y0, image->comps[0].dy), image->comps[0].factor);
 
-		fprintf(fdest, "P6\n%d %d\n%d\n", wrr, hrr, max);
-		adjust = image->comps[0].prec > 8 ? image->comps[0].prec - 8 : 0;
-		for (i = 0; i < wrr * hrr; i++) {
+		fprintf(fdest, "P6\n%d %d\n%d\n", wr, hr, max);
+
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("PNM CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("PNM CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("PNM CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+
+		for (i = 0; i < wr * hr; i++) {
 			int r, g, b;
 			unsigned char rc,gc,bc;
-			r = image->comps[0].data[i / wrr * wr + i % wrr];
+			r = image->comps[0].data[i];
 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
-			rc = (unsigned char) ((r >> adjust)+((r >> (adjust-1))%2));
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
 
-			g = image->comps[1].data[i / wrr * wr + i % wrr];
+			g = image->comps[1].data[i];
 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
-			gc = (unsigned char) ((g >> adjust)+((g >> (adjust-1))%2));
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
 			
-			b = image->comps[2].data[i / wrr * wr + i % wrr];
+			b = image->comps[2].data[i];
 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
-			bc = (unsigned char) ((b >> adjust)+((b >> (adjust-1))%2));
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
 			
 			fprintf(fdest, "%c%c%c", rc, gc, bc);
 		}
 		fclose(fdest);
+
 	} else {
 		int ncomp=(S2=='g' || S2=='G')?1:image->numcomps;
-		if (image->numcomps>ncomp) {
+		if (image->numcomps > ncomp) {
 			fprintf(stderr,"WARNING -> [PGM files] Only the first component\n");
 			fprintf(stderr,"           is written to the file\n");
 		}
@@ -1033,29 +1359,31 @@
 			}
             
 			w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
-			/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor),image->comps[compno].dx); */
 			wr = image->comps[compno].w;
-			wrr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
 			
 			h = int_ceildiv(image->y1 - image->y0, image->comps[compno].dy);
-			/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[compno].dy); */
 			hr = image->comps[compno].h;
-			hrr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
 			
 			max = image->comps[compno].prec > 8 ? 255 : (1 << image->comps[compno].prec) - 1;
 			
 			image->comps[compno].x0 = int_ceildivpow2(image->comps[compno].x0 - int_ceildiv(image->x0, image->comps[compno].dx), image->comps[compno].factor);
 			image->comps[compno].y0 = int_ceildivpow2(image->comps[compno].y0 - int_ceildiv(image->y0, image->comps[compno].dy), image->comps[compno].factor);
 			
-			fprintf(fdest, "P5\n%d %d\n%d\n", wrr, hrr, max);
-			adjust = image->comps[compno].prec > 8 ? image->comps[compno].prec - 8 : 0;
-
-			for (i = 0; i < wrr * hrr; i++) {
+			fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
+			
+			if (image->comps[compno].prec > 8) {
+				adjustX = image->comps[0].prec - 8;
+				printf("PNM CONVERSION: Truncating component %d from %d bits to 8 bits\n",compno, image->comps[compno].prec);
+			}
+			else 
+				adjustX = 0;
+			
+			for (i = 0; i < wr * hr; i++) {
 				int l;
 				unsigned char lc;
-				l = image->comps[compno].data[i / wrr * wr + i % wrr];
+				l = image->comps[compno].data[i];
 				l += (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);
-				lc = (unsigned char) ((l >> adjust)+((l >> (adjust-1))%2));
+				lc = (unsigned char) ((l >> adjustX)+((l >> (adjustX-1))%2));
 				fprintf(fdest, "%c", lc);
 			}
 			fclose(fdest);
@@ -1082,8 +1410,9 @@
 }tiff_infoheader_t;
 
 int imagetotif(opj_image_t * image, const char *outfile) {
-	int width, height;
-	int bps,index;
+	int width, height, imgsize;
+	int bps,index,adjust = 0;
+	int last_i=0;
 	TIFF *tif;
 	tdata_t buf;
 	tstrip_t strip;
@@ -1107,7 +1436,8 @@
 			}
 
 			width	= image->comps[0].w;
-			height= image->comps[0].h;
+			height	= image->comps[0].h;
+			imgsize = width * height ;
 			bps		= image->comps[0].prec;
 			/* Set tags */
 			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
@@ -1120,43 +1450,166 @@
 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
 
 			/* Get a buffer for the data */
-			buf = _TIFFmalloc(TIFFStripSize(tif));
-			index=0;
-			strip_size=0;
 			strip_size=TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index=0;		
+			adjust = image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0;
 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 				unsigned char *dat8;
-				int i;
+				int i, ssize;
+				ssize = TIFFStripSize(tif);
 				dat8 = buf;
 				if (image->comps[0].prec == 8){
-					for (i=0; i<TIFFStripSize(tif); i+=3) {	// 8 bits per pixel 
-						dat8[i+0] = image->comps[0].data[index] ;	// R 
-						dat8[i+1] = image->comps[1].data[index] ;	// G 
-						dat8[i+2] = image->comps[2].data[index] ;	// B 
-						index++;
+					for (i=0; i<ssize-2; i+=3) {	// 8 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){			
+								r += adjust;
+								g += adjust;
+								b += adjust;
+							}
+							dat8[i+0] = r ;	// R 
+							dat8[i+1] = g ;	// G 
+							dat8[i+2] = b ;	// B 
+							index++;
+							last_i = i+3;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i=last_i; i<ssize; i+=3) {	// 8 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){			
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] = r ;	// R 
+								if(i+1 <ssize) dat8[i+1] = g ;	else break;// G 
+								if(i+2 <ssize) dat8[i+2] = b ;	else break;// B 
+								index++;
+							}else
+								break;
+						}
 					}
 				}else if (image->comps[0].prec == 12){
-					for (i=0; i<TIFFStripSize(tif); i+=9) {	// 12 bits per pixel 
-						dat8[i+0] = (image->comps[0].data[index]>>8)<<4 | (image->comps[0].data[index]>>4);
-						dat8[i+1] = (image->comps[0].data[index]<<4)|((image->comps[1].data[index]>>8)& 0x0f);
-						dat8[i+2] = (image->comps[1].data[index]);
-						dat8[i+3] = (image->comps[2].data[index]>>8)<<4 | (image->comps[2].data[index]>>4);
-						dat8[i+4] = (image->comps[2].data[index]<<4)|((image->comps[1].data[index+1]>>8)& 0x0f);
-						dat8[i+5] = (image->comps[0].data[index+1]);
-						dat8[i+6] = (image->comps[1].data[index+1]>>8)<<4 | (image->comps[1].data[index+1]>>4);
-						dat8[i+7] = (image->comps[1].data[index+1]<<4)|((image->comps[2].data[index+1]>>8)& 0x0f);
-						dat8[i+8] = (image->comps[2].data[index+1]);
-						index+=2;
+					for (i=0; i<ssize-8; i+=9) {	// 12 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						int r1 = 0,g1 = 0,b1 = 0;
+						if((index < imgsize)&(index+1 < imgsize)){
+							r  = image->comps[0].data[index];
+							g  = image->comps[1].data[index];
+							b  = image->comps[2].data[index];
+							r1 = image->comps[0].data[index+1];
+							g1 = image->comps[1].data[index+1];
+							b1 = image->comps[2].data[index+1];
+							if (image->comps[0].sgnd){														
+								r  += adjust;
+								g  += adjust;
+								b  += adjust;
+								r1 += adjust;
+								g1 += adjust;
+								b1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f);
+							dat8[i+2] = g ;		
+							dat8[i+3] = (b >> 4);
+							dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+5] = r1;		
+							dat8[i+6] = (g1 >> 4);
+							dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);
+							dat8[i+8] = b1;
+							index+=2;
+							last_i = i+9;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i= last_i; i<ssize; i+=9) {	// 12 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							int r1 = 0,g1 = 0,b1 = 0;
+							if((index < imgsize)&(index+1 < imgsize)){
+								r  = image->comps[0].data[index];
+								g  = image->comps[1].data[index];
+								b  = image->comps[2].data[index];
+								r1 = image->comps[0].data[index+1];
+								g1 = image->comps[1].data[index+1];
+								b1 = image->comps[2].data[index+1];
+								if (image->comps[0].sgnd){														
+									r  += adjust;
+									g  += adjust;
+									b  += adjust;
+									r1 += adjust;
+									g1 += adjust;
+									b1 += adjust;
+								}
+								dat8[i+0] = (r >> 4);
+								if(i+1 <ssize) dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f); else break;
+								if(i+2 <ssize) dat8[i+2] = g ;			else break;
+								if(i+3 <ssize) dat8[i+3] = (b >> 4);	else break;
+								if(i+4 <ssize) dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);else break;
+								if(i+5 <ssize) dat8[i+5] = r1;			else break;
+								if(i+6 <ssize) dat8[i+6] = (g1 >> 4);	else break;
+								if(i+7 <ssize) dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);else break;
+								if(i+8 <ssize) dat8[i+8] = b1;			else break;
+								index+=2;
+							}else
+								break;
+						}
 					}
 				}else if (image->comps[0].prec == 16){
-					for (i=0; i<TIFFStripSize(tif); i+=6) {	// 16 bits per pixel 
-						dat8[i+0] =  image->comps[0].data[index];//LSB
-						dat8[i+1] = (image->comps[0].data[index]>> 8);//MSB	 
-						dat8[i+2] =  image->comps[1].data[index]; 
-						dat8[i+3] = (image->comps[1].data[index]>> 8);	
-						dat8[i+4] =  image->comps[2].data[index];	 
-						dat8[i+5] = (image->comps[2].data[index]>> 8); 
-						index++;
+					for (i=0 ; i<ssize-5 ; i+=6) {	// 16 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){
+							r += adjust;
+							g += adjust;
+							b += adjust;
+							}
+							dat8[i+0] =  r;//LSB
+							dat8[i+1] = (r >> 8);//MSB	 
+							dat8[i+2] =  g;		
+							dat8[i+3] = (g >> 8);
+							dat8[i+4] =  b;	
+							dat8[i+5] = (b >> 8);
+							index++;
+							last_i = i+6;
+						}else
+							break; 
+					}
+					if(last_i < ssize){
+						for (i=0 ; i<ssize ; i+=6) {	// 16 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] =  r;//LSB
+								if(i+1 <ssize) dat8[i+1] = (r >> 8);else break;//MSB	 
+								if(i+2 <ssize) dat8[i+2] =  g;		else break;
+								if(i+3 <ssize) dat8[i+3] = (g >> 8);else break;
+								if(i+4 <ssize) dat8[i+4] =  b;		else break;
+								if(i+5 <ssize) dat8[i+5] = (b >> 8);else break;
+								index++;
+							}else
+								break; 
+						}						
 					}
 				}else{
 					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
@@ -1179,7 +1632,8 @@
 			}
 
 			width	= image->comps[0].w;
-			height= image->comps[0].h;
+			height	= image->comps[0].h;
+			imgsize = width * height;
 			bps		= image->comps[0].prec;
 
 			/* Set tags */
@@ -1193,34 +1647,59 @@
 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
 
 			/* Get a buffer for the data */
-			buf = _TIFFmalloc(TIFFStripSize(tif));
-			index = 0;
-			strip_size = 0;
 			strip_size = TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index = 0;			
 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 				unsigned char *dat8;
 				int i;
 				dat8 = buf;
 				if (image->comps[0].prec == 8){
 					for (i=0; i<TIFFStripSize(tif); i+=1) {	// 8 bits per pixel 
-						dat8[i+0] = image->comps[0].data[index] ;
-						index++;
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							index++;
+						}else
+							break; 
 					}
 				}else if (image->comps[0].prec == 12){
 					for (i = 0; i<TIFFStripSize(tif); i+=3) {	// 12 bits per pixel 
-						dat8[i+0] = (image->comps[0].data[index]>>8)<<4 | (image->comps[0].data[index]>>4);
-						dat8[i+1] = (image->comps[0].data[index]<<4)|((image->comps[0].data[index+1]>>8)& 0x0f);
-						dat8[i+2] = (image->comps[0].data[index+1]);
-						index+=2;
+						if(index < imgsize){
+							int r = 0, r1 = 0;
+							r  = image->comps[0].data[index];
+							r1 = image->comps[0].data[index+1];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+								r1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+2] = r1 ;
+							index+=2;
+						}else
+							break; 
 					}
 				}else if (image->comps[0].prec == 16){
 					for (i=0; i<TIFFStripSize(tif); i+=2) {	// 16 bits per pixel 
-						dat8[i+0] =  image->comps[0].data[index];
-						dat8[i+1] = (image->comps[0].data[index]>> 8);
-						index++;
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							dat8[i+1] = r >> 8;
+							index++;
+						}else
+							break; 
 					}
 				}else{
-					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+					fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
 					fprintf(stderr,"Aborting\n");
 					return 1;
 				}
@@ -1229,14 +1708,14 @@
 			_TIFFfree(buf);
 			TIFFClose(tif);
 		}else{
-			fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+			fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
 			fprintf(stderr,"Aborting\n");
 			return 1;
 		}
 		return 0;
 }
 
-opj_image_t* tiftoimage(char *filename, opj_cparameters_t *parameters)
+opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters)
 {
 	int subsampling_dx = parameters->subsampling_dx;
 	int subsampling_dy = parameters->subsampling_dy;
@@ -1249,6 +1728,7 @@
 	OPJ_COLOR_SPACE color_space;
 	opj_image_cmptparm_t cmptparm[3];
 	opj_image_t * image = NULL;
+	int imgsize = 0;
 
 	tif = TIFFOpen(filename, "r");
 
@@ -1308,6 +1788,7 @@
 		strip_size=0;
 		strip_size=TIFFStripSize(tif);
 		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
 		/* Read the Image components*/
 		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 			unsigned char *dat8;
@@ -1317,43 +1798,52 @@
 
 			if (Info.tiBps==12){
 				for (i=0; i<ssize; i+=9) {	/*12 bits per pixel*/
-					image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4);
-					image->comps[1].data[index]   = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
-					image->comps[2].data[index]   = ( dat8[i+3]<<4)			|(dat8[i+4]>>4);
-					image->comps[0].data[index+1] = ((dat8[i+4]& 0x0f)<< 8)	| dat8[i+5];
-					image->comps[1].data[index+1] = ( dat8[i+6] <<4)		|(dat8[i+7]>>4);
-					image->comps[2].data[index+1] = ((dat8[i+7]& 0x0f)<< 8)	| dat8[i+8];
-					index+=2;
+					if((index < imgsize)&(index+1 < imgsize)){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4);
+						image->comps[1].data[index]   = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						image->comps[2].data[index]   = ( dat8[i+3]<<4)			|(dat8[i+4]>>4);
+						image->comps[0].data[index+1] = ((dat8[i+4]& 0x0f)<< 8)	| dat8[i+5];
+						image->comps[1].data[index+1] = ( dat8[i+6] <<4)		|(dat8[i+7]>>4);
+						image->comps[2].data[index+1] = ((dat8[i+7]& 0x0f)<< 8)	| dat8[i+8];
+						index+=2;
+					}else
+						break;
 				}
 			}
 			else if( Info.tiBps==16){
 				for (i=0; i<ssize; i+=6) {	/* 16 bits per pixel */
-					image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];	// R 
-					image->comps[1].data[index] = ( dat8[i+3] << 8 ) | dat8[i+2];	// G 
-					image->comps[2].data[index] = ( dat8[i+5] << 8 ) | dat8[i+4];	// B 
-					if(parameters->cp_cinema){/* Rounding to 12 bits*/
-						image->comps[0].data[index] = (image->comps[0].data[index] + 0x08) >> 4 ;
-						image->comps[1].data[index] = (image->comps[1].data[index] + 0x08) >> 4 ;
-						image->comps[2].data[index] = (image->comps[2].data[index] + 0x08) >> 4 ;
-					}
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0]; // R 
+						image->comps[1].data[index] = ( dat8[i+3] << 8 ) | dat8[i+2]; // G 
+						image->comps[2].data[index] = ( dat8[i+5] << 8 ) | dat8[i+4]; // B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = (image->comps[0].data[index] + 0x08) >> 4 ;
+							image->comps[1].data[index] = (image->comps[1].data[index] + 0x08) >> 4 ;
+							image->comps[2].data[index] = (image->comps[2].data[index] + 0x08) >> 4 ;
+						}
+						index++;
+					}else
+						break;
 				}
 			}
 			else if ( Info.tiBps==8){
 				for (i=0; i<ssize; i+=3) {	/* 8 bits per pixel */
-					image->comps[0].data[index] = dat8[i+0];	// R 
-					image->comps[1].data[index] = dat8[i+1];	// G 
-					image->comps[2].data[index] = dat8[i+2];	// B 
-					if(parameters->cp_cinema){/* Rounding to 12 bits*/
-						image->comps[0].data[index] = image->comps[0].data[index] << 4 ;
-						image->comps[1].data[index] = image->comps[1].data[index] << 4 ;
-						image->comps[2].data[index] = image->comps[2].data[index] << 4 ;
-					}
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];// R 
+						image->comps[1].data[index] = dat8[i+1];// G 
+						image->comps[2].data[index] = dat8[i+2];// B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = image->comps[0].data[index] << 4 ;
+							image->comps[1].data[index] = image->comps[1].data[index] << 4 ;
+							image->comps[2].data[index] = image->comps[2].data[index] << 4 ;
+						}
+						index++;
+					}else
+						break;
 				}
 			}
 			else{
-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
 				fprintf(stderr,"Aborting\n");
 				return NULL;
 			}
@@ -1394,6 +1884,7 @@
 		strip_size = 0;
 		strip_size = TIFFStripSize(tif);
 		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
 		/* Read the Image components*/
 		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 			unsigned char *dat8;
@@ -1403,25 +1894,34 @@
 
 			if (Info.tiBps==12){
 				for (i=0; i<ssize; i+=3) {	/* 12 bits per pixel*/
-					image->comps[0].data[index] = ( dat8[i+0]<<4 )				|(dat8[i+1]>>4) ;
-					image->comps[0].data[index] = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
-					index+=2;
+					if(index < imgsize){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4) ;
+						image->comps[0].data[index+1] = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						index+=2;
+					}else
+						break;
 				}
 			}
 			else if( Info.tiBps==16){
 				for (i=0; i<ssize; i+=2) {	/* 16 bits per pixel */
-					image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];
+						index++;
+					}else
+						break;
 				}
 			}
 			else if ( Info.tiBps==8){
 				for (i=0; i<ssize; i+=1) {	/* 8 bits per pixel */
-					image->comps[0].data[index] = dat8[i+0];
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];
+						index++;
+					}else
+						break;
 				}
 			}
 			else{
-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
 				fprintf(stderr,"Aborting\n");
 				return NULL;
 			}
@@ -1430,9 +1930,209 @@
 		_TIFFfree(buf);
 		TIFFClose(tif);
 	}else{
-		fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+		fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+	return image;
+}
+
+/* -->> -->> -->> -->>
+
+	RAW IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	FILE *f = NULL;
+	int i, compno, numcomps, w, h;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_image_t * image = NULL;
+	unsigned short ch;
+	
+	if((! (raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp & raw_cp->rawBitDepth)) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		fprintf(stderr,"Please use the Format option -F:\n");
+		fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+		fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
 		fprintf(stderr,"Aborting\n");
 		return NULL;
 	}
+	numcomps = raw_cp->rawComp;
+	color_space = CLRSPC_SRGB;
+	w = raw_cp->rawWidth;
+	h = raw_cp->rawHeight;
+	cmptparm = (opj_image_cmptparm_t*) malloc(numcomps * sizeof(opj_image_cmptparm_t));
+	
+	/* initialize image components */	
+	memset(&cmptparm[0], 0, numcomps * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < numcomps; i++) {		
+		cmptparm[i].prec = raw_cp->rawBitDepth;
+		cmptparm[i].bpp = raw_cp->rawBitDepth;
+		cmptparm[i].sgnd = raw_cp->rawSigned;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = w;
+		cmptparm[i].h = h;
+	}
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+	if(!image) {
+		fclose(f);
+		return NULL;
+	}
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 = parameters->image_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	image->y1 = parameters->image_offset_y0 + (h - 1) *	subsampling_dy + 1;
+
+	if(raw_cp->rawBitDepth <= 8)
+	{
+		unsigned char value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 1, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(char)value:value;
+			}
+		}
+	}
+	else
+	{
+		unsigned short value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 2, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(short)value:value;
+			}
+		}
+	}
+
+	if (fread(&ch, 1, 1, f)) {
+		fprintf(stderr,"Warning. End of raw file not reached... processing anyway\n");
+	}
+	fclose(f);
+
 	return image;
 }
+
+int imagetoraw(opj_image_t * image, const char *outfile)
+{
+	FILE *rawFile = NULL;
+	int compno;
+	int w, h;
+	int line, row;
+	int *ptr;
+
+	if((image->numcomps * image->x1 * image->y1) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		return 1;
+	}
+
+	rawFile = fopen(outfile, "wb");
+	if (!rawFile) {
+		fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
+		return 1;
+	}
+
+	fprintf(stdout,"Raw image characteristics: %d components\n", image->numcomps);
+
+	for(compno = 0; compno < image->numcomps; compno++)
+	{
+		fprintf(stdout,"Component %d characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
+			image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
+
+		w = image->comps[compno].w;
+		h = image->comps[compno].h;
+
+		if(image->comps[compno].prec <= 8)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (signed char) (*ptr & mask);
+						fwrite(&curr, sizeof(signed char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{	
+						curr = (unsigned char) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if(image->comps[compno].prec <= 16)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{					
+						curr = (signed short int) (*ptr & mask);
+						fwrite(&curr, sizeof(signed short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (unsigned short int) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if (image->comps[compno].prec <= 32)
+		{
+			fprintf(stderr,"More than 16 bits per component no handled yet\n");
+			return 1;
+		}
+		else
+		{
+			fprintf(stderr,"Error: invalid precision: %d\n", image->comps[compno].prec);
+			return 1;
+		}
+	}
+	fclose(rawFile);
+	return 0;
+}
diff -urN -xdebian -x.svn ./codec/convert.h /usr/src/openjpeg/trunk/codec/convert.h
--- ./codec/convert.h	2007-11-29 18:27:40.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/convert.h	2007-09-28 11:33:52.000000000 +0100
@@ -31,8 +31,28 @@
 #ifndef __J2K_CONVERT_H
 #define __J2K_CONVERT_H
 
-opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters);
+/**@name RAW image encoding parameters */
+/*@{*/
+typedef struct raw_cparameters {
+	/** width of the raw image */
+	int rawWidth;
+	/** height of the raw image */
+	int rawHeight;
+	/** components of the raw image */
+	int rawComp;
+	/** bit depth of the raw image */
+	int rawBitDepth;
+	/** signed/unsigned raw image */
+	bool rawSigned;
+	/*@}*/
+} raw_cparameters_t;
+
+/* TGA conversion */
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetotga(opj_image_t * image, const char *outfile);
 
+/* BMP conversion */
+opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters);
 int imagetobmp(opj_image_t *image, const char *outfile);
 
 /* TIFF to image conversion*/
@@ -45,12 +65,14 @@
 @return Returns a greyscale image if successful, returns NULL otherwise
 */
 opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters);
-
 int imagetopgx(opj_image_t *image, const char *outfile);
 
 opj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters);
-
 int imagetopnm(opj_image_t *image, const char *outfile);
 
+/* RAW conversion */
+int imagetoraw(opj_image_t * image, const char *outfile);
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp);
+
 #endif /* __J2K_CONVERT_H */
 
diff -urN -xdebian -x.svn ./codec/image_to_j2k.c /usr/src/openjpeg/trunk/codec/image_to_j2k.c
--- ./codec/image_to_j2k.c	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/image_to_j2k.c	2007-11-27 22:39:51.000000000 +0000
@@ -32,11 +32,13 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <math.h>
 
 #include "openjpeg.h"
 #include "compat/getopt.h"
 #include "convert.h"
 #include "dirent.h"
+#include "index.h"
 
 #ifndef WIN32
 #define stricmp strcasecmp
@@ -54,6 +56,8 @@
 #define BMP_DFMT 12
 #define YUV_DFMT 13
 #define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
 
 /* ----------------------------------------------------------------------- */
 #define CINEMA_24_CS 1302083	/*Codestream length for 24fps*/
@@ -77,7 +81,8 @@
 	char set_imgdir;
 	/** Enable Cod Format for output*/
 	char set_out_format;
-
+	/** User specified rate stored in case of cinema option*/
+	float *rates;
 }img_fol_t;
 
 void encode_help_display() {
@@ -98,10 +103,6 @@
 	fprintf(stdout,"The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
 	fprintf(stdout,"COD and QCD never appear in the tile_header.\n");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"- This coder can encode a mega image, a test was made on a 24000x24000 pixels \n");
-	fprintf(stdout,"color image.  You need enough disk space memory (twice the original) to encode \n");
-	fprintf(stdout,"the image,i.e. for a 1.5 GB image you need a minimum of 3GB of disk memory)\n");
-	fprintf(stdout,"\n");
 	fprintf(stdout,"By default:\n");
 	fprintf(stdout,"------------\n");
 	fprintf(stdout,"\n");
@@ -138,9 +139,9 @@
 	fprintf(stdout,"-OutFor \n");
 	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
 	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
-	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP format\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-i           : source file  (-i source.pnm also *.pgm, *.ppm) \n");
+	fprintf(stdout,"-i           : source file  (-i source.pnm also *.pgm, *.ppm, *.bmp, *.tif, *.raw, *.tga) \n");
 	fprintf(stdout,"    When using this option -o must be used\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-o           : destination file (-o dest.j2k or .jp2) \n");
@@ -149,10 +150,10 @@
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-h           : display the help information \n ");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-cinema2k    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
+	fprintf(stdout,"-cinema2K    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
   fprintf(stdout,"	  Need to specify the frames per second for a 2K resolution. Only 24 or 48 fps is allowed\n"); 
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-cinema4k    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
+	fprintf(stdout,"-cinema4K    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
 	fprintf(stdout,"	  Frames per second not required. Default value is 24fps\n"); 
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-r           : different compression ratios for successive layers (-r 20,10,5)\n ");
@@ -199,7 +200,7 @@
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
 	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
-	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
+	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
 	fprintf(stdout,"\n");
@@ -211,31 +212,31 @@
 #ifdef USE_JPWL
 	fprintf(stdout,"-W           : adoption of JPWL (Part 11) capabilities (-W params)\n");
 	fprintf(stdout,"               The parameters can be written and repeated in any order:\n");
-	fprintf(stdout,"               [h<tile><=type>,s<tile><=method>,a=<addr>,z=<size>,g=<range>,...\n");
-	fprintf(stdout,"                ...,p<tile:pack><=type>]\n");
+	fprintf(stdout,"               [h<tilepart><=type>,s<tilepart><=method>,a=<addr>,...\n");
+	fprintf(stdout,"                ...,z=<size>,g=<range>,p<tilepart:pack><=type>]\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 h selects the header error protection (EPB): 'type' can be\n");
 	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
-	fprintf(stdout,"                   if 'tile' is absent, it applies to main and tile headers\n");
-	fprintf(stdout,"                   if 'tile' is present, it applies from that tile\n");
-	fprintf(stdout,"                     onwards, up to the next h<tile> spec, or to the last tile\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main and tile headers\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next h<> spec, or to the last tilepart\n");
 	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 p selects the packet error protection (EEP/UEP with EPBs)\n");
 	fprintf(stdout,"                  to be applied to raw data: 'type' can be\n");
 	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
-	fprintf(stdout,"                   if 'tile:pack' is absent, it starts from tile 0, packet 0\n");
-	fprintf(stdout,"                   if 'tile:pack' is present, it applies from that tile\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is absent, it is from tile 0, packet 0\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is present, it applies from that tile\n");
 	fprintf(stdout,"                     and that packet onwards, up to the next packet spec\n");
-	fprintf(stdout,"                     or to the last packet in the last tile in the codestream\n");
+	fprintf(stdout,"                     or to the last packet in the last tilepart in the stream\n");
 	fprintf(stdout,"                     (max. %d specs)\n", JPWL_MAX_NO_PACKSPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 s enables sensitivity data insertion (ESD): 'method' can be\n");
 	fprintf(stdout,"                   [-1=NO ESD 0=RELATIVE ERROR 1=MSE 2=MSE REDUCTION 3=PSNR\n");
 	fprintf(stdout,"                    4=PSNR INCREMENT 5=MAXERR 6=TSE 7=RESERVED]\n");
-	fprintf(stdout,"                   if 'tile' is absent, it applies to main header only\n");
-	fprintf(stdout,"                   if 'tile' is present, it applies from that tile\n");
-	fprintf(stdout,"                     onwards, up to the next s<tile> spec, or to the last tile\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main header only\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next s<> spec, or to the last tilepart\n");
 	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 g determines the addressing mode: <range> can be\n");
@@ -248,15 +249,16 @@
 	fprintf(stdout,"                   1/2 bytes, for the transformed pseudo-floating point value\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 ex.:\n");
-	fprintf(stdout," h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,s0=6,s3=-1,a=0,g=1,z=1\n");
+	fprintf(stdout,"                   h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,\n");
+	fprintf(stdout,"                     s0=6,s3=-1,a=0,g=1,z=1\n");
 	fprintf(stdout,"                 means\n");
 	fprintf(stdout,"                   predefined EPB in MH, rs(64,32) from TPH 0 to TPH 2,\n");
 	fprintf(stdout,"                   CRC-16 in TPH 3 and TPH 4, CRC-32 in remaining TPHs,\n");
 	fprintf(stdout,"                   UEP rs(78,32) for packets 0 to 23 of tile 0,\n");
-	fprintf(stdout,"                   UEP rs(56,32) for packets 24 to the last of tile 0,\n");
-	fprintf(stdout,"                   UEP rs default for packets of tile 1,\n");
-	fprintf(stdout,"                   no UEP for packets 0 to 19 of tile 3,\n");
-	fprintf(stdout,"                   UEP CRC-32 for packets 20 of tile 3 to last tile,\n");
+	fprintf(stdout,"                   UEP rs(56,32) for packs. 24 to the last of tilepart 0,\n");
+	fprintf(stdout,"                   UEP rs default for packets of tilepart 1,\n");
+	fprintf(stdout,"                   no UEP for packets 0 to 19 of tilepart 3,\n");
+	fprintf(stdout,"                   UEP CRC-32 for packs. 20 of tilepart 3 to last tilepart,\n");
 	fprintf(stdout,"                   relative sensitivity ESD for MH,\n");
 	fprintf(stdout,"                   TSE ESD from TPH 0 to TPH 2, byte range with automatic\n");
 	fprintf(stdout,"                   size of addresses and 1 byte for each sensitivity value\n");
@@ -282,20 +284,28 @@
 	fprintf(stdout,"Image_height Image_width\n");
 	fprintf(stdout,"progression order\n");
 	fprintf(stdout,"Tiles_size_X Tiles_size_Y\n");
-/* UniPG>> */
 	fprintf(stdout,"Tiles_nb_X Tiles_nb_Y\n");
-/* <<UniPG */
 	fprintf(stdout,"Components_nb\n");
 	fprintf(stdout,"Layers_nb\n");
 	fprintf(stdout,"decomposition_levels\n");
 	fprintf(stdout,"[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
 	fprintf(stdout,"   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
+	fprintf(stdout,"Main_header_start_position\n");
 	fprintf(stdout,"Main_header_end_position\n");
 	fprintf(stdout,"Codestream_size\n");
-	fprintf(stdout,"Tile_0 start_pos end_Theader end_pos TotalDisto NumPix MaxMSE\n");
-	fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"INFO ON TILES\n");
+	fprintf(stdout,"tileno start_pos end_hd end_tile nbparts disto nbpix disto/nbpix\n");
+	fprintf(stdout,"Tile_0 start_pos end_Theader end_pos NumParts TotalDisto NumPix MaxMSE\n");
+	fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''      ''\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''     ''\n");
 	fprintf(stdout,"...\n");
-	fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''\n");
+	fprintf(stdout,"TILE 0 DETAILS\n");
+	fprintf(stdout,"part_nb tileno num_packs start_pos end_tph_pos end_pos\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Progression_string\n");
+	fprintf(stdout,"pack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
 	fprintf(stdout,"Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
 	fprintf(stdout,"...\n");
 	fprintf(stdout,"Tpacket_Np ''   ''    ''   ''    ''       ''       ''     ''\n");
@@ -375,10 +385,10 @@
 int get_file_format(char *filename) {
 	unsigned int i;
 	static const char *extension[] = {
-    "pgx", "pnm", "pgm", "ppm", "bmp","tif", "j2k", "jp2", "j2c"
+    "pgx", "pnm", "pgm", "ppm", "bmp", "tif", "raw", "tga", "j2k", "jp2", "j2c"
     };
 	static const int format[] = {
-    PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT,TIF_DFMT, J2K_CFMT, JP2_CFMT, J2K_CFMT
+    PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, J2K_CFMT
     };
 	char * ext = strrchr(filename, '.');
 	if (ext == NULL)
@@ -389,7 +399,6 @@
 			return format[i];
 		}
 	}
-
 	return -1;
 }
 
@@ -402,6 +411,7 @@
 
 char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_cparameters_t *parameters){
 	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+  char *temp_p, temp1[OPJ_PATH_LEN]="";
 
 	strcpy(image_filename,dirptr->filename[imageno]);
 	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
@@ -413,6 +423,10 @@
 
 	//Set output file
 	strcpy(temp_ofname,get_file_name(image_filename));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
 	if(img_fol->set_out_format==1){
 		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
 		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
@@ -471,7 +485,7 @@
 
 }
 
-void cinema_setup_encoder(opj_cparameters_t *parameters,opj_image_t *image){
+void cinema_setup_encoder(opj_cparameters_t *parameters,opj_image_t *image, img_fol_t *img_fol){
 	int i;
 	float temp_rate;
 	opj_poc_t *POC = NULL;
@@ -483,7 +497,9 @@
 			parameters->numresolution = 6;
 		}
 		if (!((image->comps[0].w == 2048) | (image->comps[0].h == 1080))){
-			fprintf(stdout,"Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 (2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",image->comps[0].w,image->comps[0].h);
+			fprintf(stdout,"Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 "
+				"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
+				image->comps[0].w,image->comps[0].h);
 			parameters->cp_rsiz = STD_RSIZ;
 		}
 	break;
@@ -495,7 +511,9 @@
 				parameters->numresolution = 7;
 			}
 		if (!((image->comps[0].w == 4096) | (image->comps[0].h == 2160))){
-			fprintf(stdout,"Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4 (4K profile) compliance requires that atleast one of coordinates match 4096 x 2160\n",image->comps[0].w,image->comps[0].h);
+			fprintf(stdout,"Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4" 
+				"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
+				image->comps[0].w,image->comps[0].h);
 			parameters->cp_rsiz = STD_RSIZ;
 		}
 		parameters->numpocs = initialise_4K_poc(parameters->POC,parameters->numresolution);
@@ -505,17 +523,19 @@
 	switch (parameters->cp_cinema){
 		case CINEMA2K_24:
 		case CINEMA4K_24:
-			for(i=0;i<parameters->tcp_numlayers;i++){
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
 				temp_rate = 0 ;
-				if (parameters->tcp_rates[i]== 0){
+				if (img_fol->rates[i]== 0){
 					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
 					(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
 				}else{
 					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-						(parameters->tcp_rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
 					if (temp_rate > CINEMA_24_CS ){
 						parameters->tcp_rates[i]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-																				(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+						(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
 					}
 				}
 			}
@@ -523,17 +543,19 @@
 			break;
 		
 		case CINEMA2K_48:
-     	for(i=0;i<parameters->tcp_numlayers;i++){
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
 				temp_rate = 0 ;
-				if (parameters->tcp_rates[i]== 0){
+				if (img_fol->rates[i]== 0){
 					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
 					(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
 				}else{
 					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-						(parameters->tcp_rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
 					if (temp_rate > CINEMA_48_CS ){
 						parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-																				(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+						(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
 					}
 				}
 			}
@@ -545,7 +567,8 @@
 
 /* ------------------------------------------------------------------------------------ */
 
-int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,img_fol_t *img_fol) {
+int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,
+													img_fol_t *img_fol, raw_cparameters_t *raw_cp, char *indexfilename) {
 	int i, j,totlen;
 	option_t long_option[]={
 		{"cinema2K",REQ_ARG, NULL ,'w'},
@@ -556,11 +579,11 @@
 		{"EPH",NO_ARG, NULL ,'E'},
 		{"OutFor",REQ_ARG, NULL ,'O'},
 		{"POC",REQ_ARG, NULL ,'P'},
+		{"ROI",REQ_ARG, NULL ,'R'},
 	};
 
 	/* parse the command line */
-/* UniPG>> */
-	const char optlist[] = "i:o:hr:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:"
+	const char optlist[] = "i:o:hr:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:F:"
 #ifdef USE_JPWL
 		"W:"
 #endif /* USE_JPWL */
@@ -568,10 +591,10 @@
 
 	totlen=sizeof(long_option);
 	img_fol->set_out_format=0;
+	raw_cp->rawWidth = 0;
 
 	while (1) {
     int c = getopt_long(argc, argv, optlist,long_option,totlen);
-/* <<UniPG */
 		if (c == -1)
 			break;
 		switch (c) {
@@ -584,11 +607,13 @@
 					case PXM_DFMT:
 					case BMP_DFMT:
 					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
 						break;
 					default:
 						fprintf(stderr,
 							"!! Unrecognized format for infile : %s "
-              "[accept only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp or *.tif] !!\n\n", 
+              "[accept only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga] !!\n\n", 
 							infile);
 						return 1;
 				}
@@ -607,7 +632,7 @@
 					case JP2_CFMT:
 						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.j2k, *.jp2]!! \n", outfile);
+						fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n", outfile);
 						return 1;
 				}
 				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
@@ -628,7 +653,7 @@
 							img_fol->out_format = optarg;
 							break;
 						default:
-							fprintf(stderr, "Unknown output format image [only j2k, jp2]!! \n");
+							fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
 							return 1;
 					}
 				}
@@ -656,6 +681,41 @@
 
 				/* ----------------------------------------------------- */
 
+			
+			case 'F':			/* Raw image format parameters */
+			{
+				char signo;
+				char *s = optarg;
+				if (sscanf(s, "%d,%d,%d,%d,%c", &raw_cp->rawWidth, &raw_cp->rawHeight, &raw_cp->rawComp, &raw_cp->rawBitDepth, &signo) == 5) {
+					if (signo == 's') {
+						raw_cp->rawSigned = true;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Signed\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else if (signo == 'u') {
+						raw_cp->rawSigned = false;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Unsigned\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else {
+						fprintf(stderr,"\nError: invalid raw image parameters: Unknown sign of raw file\n");
+						fprintf(stderr,"Please use the Format option -F:\n");
+						fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+						fprintf(stderr,"Aborting\n");
+					}					
+				}
+				else {
+					fprintf(stderr,"\nError: invalid raw image parameters\n");
+					fprintf(stderr,"Please use the Format option -F:\n");
+					fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+					fprintf(stderr,"Aborting\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
 			case 'q':			/* add fixed_quality */
 			{
 				char *s = optarg;
@@ -780,8 +840,7 @@
 			case 'x':			/* creation of index file */
 			{
 				char *index = optarg;
-				strncpy(parameters->index, index, sizeof(parameters->index)-1);
-				parameters->index_on = 1;
+				strncpy(indexfilename, index, OPJ_PATH_LEN);
 			}
 			break;
 
@@ -895,9 +954,9 @@
 
 			case 'R':			/* ROI */
 			{
-				if (sscanf(optarg, "OI:c=%d,U=%d", &parameters->roi_compno,
+				if (sscanf(optarg, "c=%d,U=%d", &parameters->roi_compno,
                                            &parameters->roi_shift) != 2) {
-					fprintf(stderr, "ROI error !! [-ROI:c='compno',U='shift']\n");
+					fprintf(stderr, "ROI error !! [-ROI c='compno',U='shift']\n");
 					return 1;
 				}
 			}
@@ -995,9 +1054,8 @@
 				int hprot, pprot, sens, addr, size, range;
 
 				/* we need to enable indexing */
-				if (!parameters->index_on) {
-					strncpy(parameters->index, JPWL_PRIVATEINDEX_NAME, sizeof(parameters->index)-1);
-					parameters->index_on = 1;
+				if (!indexfilename) {
+					strncpy(indexfilename, JPWL_PRIVATEINDEX_NAME, OPJ_PATH_LEN);
 				}
 
 				/* search for different protection methods */
@@ -1026,11 +1084,11 @@
 							/* Tile part header, specified */
 							if (!((hprot == 0) || (hprot == 1) || (hprot == 16) || (hprot == 32) ||
 								((hprot >= 37) && (hprot <= 128)))) {
-								fprintf(stderr, "ERROR -> invalid tile header protection method h = %d\n", hprot);
+								fprintf(stderr, "ERROR -> invalid tile part header protection method h = %d\n", hprot);
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1041,7 +1099,7 @@
 						} else if(sscanf(token, "h%d", &tile) == 1) {
 							/* Tile part header, unspecified */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1087,7 +1145,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (packspec < JPWL_MAX_NO_PACKSPECS) {
@@ -1104,7 +1162,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (pack < 0) {
@@ -1125,7 +1183,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (pack < 0) {
@@ -1141,7 +1199,7 @@
 						} else if (sscanf(token, "p%d", &tile) == 1) {
 							/* default from a tile on */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (packspec < JPWL_MAX_NO_PACKSPECS) {
@@ -1182,11 +1240,11 @@
 						} else if(sscanf(token, "s%d=%d", &tile, &sens) == 2) {
 							/* Tile part header, specified */
 							if ((sens < -1) || (sens > 7)) {
-								fprintf(stderr, "ERROR -> invalid tile header sensitivity method s = %d\n", sens);
+								fprintf(stderr, "ERROR -> invalid tile part header sensitivity method s = %d\n", sens);
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on sensitivity method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1197,7 +1255,7 @@
 						} else if(sscanf(token, "s%d", &tile) == 1) {
 							/* Tile part header, unspecified */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on sensitivity method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1348,6 +1406,15 @@
 		}
 	}
 
+	if (parameters->decod_format == RAW_DFMT && raw_cp->rawWidth == 0) {
+			fprintf(stderr,"\nError: invalid raw image parameters\n");
+			fprintf(stderr,"Please use the Format option -F:\n");
+			fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+			fprintf(stderr,"Aborting\n");
+			return 1;
+	}
+
 	if ((parameters->cp_disto_alloc || parameters->cp_fixed_alloc || parameters->cp_fixed_quality)
 		&& (!(parameters->cp_disto_alloc ^ parameters->cp_fixed_alloc ^ parameters->cp_fixed_quality))) {
 		fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
@@ -1414,6 +1481,9 @@
 	int i,num_images;
 	int imageno;
 	dircnt_t *dirptr;
+	raw_cparameters_t raw_cp;
+	opj_codestream_info_t cstr_info;		/* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
 
 	/*
 	configure the event callbacks (not required)
@@ -1427,15 +1497,22 @@
 	/* set encoding parameters to default values */
 	opj_set_default_encoder_parameters(&parameters);
 
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
+
 	/* parse input and get user encoding parameters */
-	if(parse_cmdline_encoder(argc, argv, &parameters,&img_fol) == 1) {
-		return 0;
+	if(parse_cmdline_encoder(argc, argv, &parameters,&img_fol, &raw_cp, indexfilename) == 1) {
+		return 1;
 	}
 	
 	if (parameters.cp_cinema){
+		img_fol.rates = (float*)malloc(parameters.tcp_numlayers * sizeof(float));
+		for(i=0; i< parameters.tcp_numlayers; i++){
+			img_fol.rates[i] = parameters.tcp_rates[i];
+		}
 		cinema_parameters(&parameters);
-	}
-				
+	}				
 
 	/* Create comment for codestream */
 	if(parameters.cp_comment == NULL) {
@@ -1451,19 +1528,15 @@
 		sprintf(parameters.cp_comment,"%s%s", comment, version);
 #endif
 /* <<UniPG */
-
 	}
 
 	/* Read directory if necessary */
-
 	if(img_fol.set_imgdir==1){
 		num_images=get_num_images(img_fol.imgdirpath);
-
 		dirptr=(dircnt_t*)malloc(sizeof(dircnt_t));
 		if(dirptr){
 			dirptr->filename_buf = (char*)malloc(num_images*OPJ_PATH_LEN*sizeof(char));	// Stores at max 10 image file names
 			dirptr->filename = (char**) malloc(num_images*sizeof(char*));
-
 			if(!dirptr->filename_buf){
 				return 0;
 			}
@@ -1482,13 +1555,10 @@
 		num_images=1;
 	}
 	/*Encoding image one by one*/
-	for(imageno=0;imageno<num_images;imageno++)
-	{
-
+	for(imageno=0;imageno<num_images;imageno++)	{
 		image = NULL;
 		fprintf(stderr,"\n");
 		
-
 		if(img_fol.set_imgdir==1){
 			if (get_next_file(imageno, dirptr,&img_fol, &parameters)) {
 				fprintf(stderr,"skipping file...\n");
@@ -1504,7 +1574,10 @@
 				break;
 			case TIF_DFMT:
 				break;
-		
+			case RAW_DFMT:
+				break;
+			case TGA_DFMT:
+				break;
 			default:
 				fprintf(stderr,"skipping file...\n");
 				continue;			
@@ -1545,12 +1618,28 @@
 						return 1;
 					}
 				break;
+
+				case RAW_DFMT:
+					image = rawtoimage(parameters.infile, &parameters, &raw_cp);
+					if (!image) {
+						fprintf(stderr, "Unable to load raw file\n");
+						return 1;
+					}
+				break;
+
+				case TGA_DFMT:
+					image = tgatoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load tga file\n");
+						return 1;
+					}
+				break;
 		}
 			/* Decide if MCT should be used */
 			parameters.tcp_mct = image->numcomps == 3 ? 1 : 0;
 
 			if(parameters.cp_cinema){
-				cinema_setup_encoder(&parameters,image);
+				cinema_setup_encoder(&parameters,image,&img_fol);
 			}
 
 			/* encode the destination image */
@@ -1575,7 +1664,10 @@
 				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, image, parameters.index);
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -1596,9 +1688,18 @@
 				/* close and free the byte stream */
 				opj_cio_close(cio);
 
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
+
 				/* free remaining compression structures */
 				opj_destroy_compress(cinfo);
-
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
 			} else {			/* JP2 format output */
 				int codestream_length;
 				opj_cio_t *cio = NULL;
@@ -1618,7 +1719,10 @@
 				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, image, parameters.index);
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -1637,10 +1741,19 @@
 				fprintf(stderr,"Generated outfile %s\n",parameters.outfile);
 				/* close and free the byte stream */
 				opj_cio_close(cio);
+				
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
 
 				/* free remaining compression structures */
 				opj_destroy_compress(cinfo);
-
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
 			}
 	
 			/* free image data */
@@ -1653,4 +1766,3 @@
 
 	return 0;
 }
-
diff -urN -xdebian -x.svn ./codec/image_to_j2k.dsp /usr/src/openjpeg/trunk/codec/image_to_j2k.dsp
--- ./codec/image_to_j2k.dsp	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/image_to_j2k.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -51,7 +51,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libc"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"LIBC"
 # SUBTRACT LINK32 /pdb:none
 
 !ELSEIF  "$(CFG)" == "image_to_j2k - Win32 Debug"
@@ -77,7 +77,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"LIBC" /nodefaultlib:"LIBCMT" /pdbtype:sept
 # SUBTRACT LINK32 /pdb:none
 
 !ENDIF 
@@ -106,5 +106,13 @@
 
 SOURCE=.\image_to_j2k.c
 # End Source File
+# Begin Source File
+
+SOURCE=.\index.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\index.h
+# End Source File
 # End Target
 # End Project
Binary files ./codec/image_to_j2k.sln and /usr/src/openjpeg/trunk/codec/image_to_j2k.sln differ
diff -urN -xdebian -x.svn ./codec/image_to_j2k.vcproj /usr/src/openjpeg/trunk/codec/image_to_j2k.vcproj
--- ./codec/image_to_j2k.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/codec/image_to_j2k.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,292 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="image_to_j2k"
+	ProjectGUID="{81FBE6CF-1DFB-413F-8215-0851F8E2D252}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/image_to_j2k.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/image_to_j2k.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/image_to_j2k.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/image_to_j2k.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath="image_to_j2k.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./codec/j2k_to_image.c /usr/src/openjpeg/trunk/codec/j2k_to_image.c
--- ./codec/j2k_to_image.c	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/j2k_to_image.c	2007-11-27 22:39:51.000000000 +0000
@@ -32,11 +32,13 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <math.h>
 
 #include "openjpeg.h"
 #include "compat/getopt.h"
 #include "convert.h"
 #include "dirent.h"
+#include "index.h"
 
 #ifndef WIN32
 #define stricmp strcasecmp
@@ -54,6 +56,8 @@
 #define BMP_DFMT 12
 #define YUV_DFMT 13
 #define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
 
 /* ----------------------------------------------------------------------- */
 
@@ -95,15 +99,15 @@
 	fprintf(stdout,"  -OutFor \n");
 	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
 	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
-	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP format\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
 	fprintf(stdout,"  -i <compressed file>\n");
 	fprintf(stdout,"    REQUIRED only if an Input image directory not specified\n");
 	fprintf(stdout,"    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n");
 	fprintf(stdout,"    is identified based on its suffix.\n");
 	fprintf(stdout,"  -o <decompressed file>\n");
 	fprintf(stdout,"    REQUIRED\n");
-	fprintf(stdout,"    Currently accepts PGM-files, PPM-files, PNM-files, PGX-files and\n");
-	fprintf(stdout,"    BMP-files. Binary data is written to the file (not ascii). If a PGX\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA files\n");
+	fprintf(stdout,"    Binary data is written to the file (not ascii). If a PGX\n");
 	fprintf(stdout,"    filename is given, there will be as many output files as there are\n");
 	fprintf(stdout,"    components: an indice starting from 0 will then be appended to the\n");
 	fprintf(stdout,"    output filename, just before the \"pgx\" extension. If a PGM filename\n");
@@ -118,6 +122,9 @@
 	fprintf(stdout,"    Set the maximum number of quality layers to decode. If there are\n");
 	fprintf(stdout,"    less quality layers than the specified number, all the quality layers\n");
 	fprintf(stdout,"    are decoded.\n");
+	fprintf(stdout,"  -x  \n"); 
+	fprintf(stdout,"    Create an index file *.Idx (-x index_name.Idx) \n");
+	fprintf(stdout,"\n");
 /* UniPG>> */
 #ifdef USE_JPWL
 	fprintf(stdout,"  -W <options>\n");
@@ -181,8 +188,8 @@
 
 int get_file_format(char *filename) {
 	unsigned int i;
-	static const char *extension[] = {"pgx", "pnm", "pgm", "ppm", "bmp","tif", "j2k", "jp2", "jpt", "j2c" };
-	static const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT };
+	static const char *extension[] = {"pgx", "pnm", "pgm", "ppm", "bmp","tif", "raw", "tga", "j2k", "jp2", "jpt", "j2c" };
+	static const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT };
 	char * ext = strrchr(filename, '.');
 	if (ext == NULL)
 		return -1;
@@ -200,6 +207,7 @@
 
 char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_dparameters_t *parameters){
 	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+	char *temp_p, temp1[OPJ_PATH_LEN]="";
 
 	strcpy(image_filename,dirptr->filename[imageno]);
 	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
@@ -211,6 +219,10 @@
 
 	//Set output file
 	strcpy(temp_ofname,strtok(image_filename,"."));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
 	if(img_fol->set_out_format==1){
 		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
 		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
@@ -218,10 +230,8 @@
 	return 0;
 }
 
-
 /* -------------------------------------------------------------------------- */
-
-int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol) {
+int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol, char *indexfilename) {
 	/* parse the command line */
 	int totlen;
 	option_t long_option[]={
@@ -229,14 +239,14 @@
 		{"OutFor",REQ_ARG, NULL ,'O'},
 	};
 
-/* UniPG>> */
-	const char optlist[] = "i:o:r:l:h"
+	const char optlist[] = "i:o:r:l:hx:"
 
+/* UniPG>> */
 #ifdef USE_JPWL
 					"W:"
 #endif /* USE_JPWL */
-					;
 /* <<UniPG */
+					;
 	totlen=sizeof(long_option);
 	img_fol->set_out_format = 0;
 	while (1) {
@@ -274,9 +284,11 @@
 					case PXM_DFMT:
 					case BMP_DFMT:
 					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
 						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx or *.bmp]!! \n", outfile);
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outfile);
 						return 1;
 				}
 				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
@@ -305,8 +317,14 @@
 					case TIF_DFMT:
 						img_fol->out_format = "tif";
 						break;
+					case RAW_DFMT:
+						img_fol->out_format = "raw";
+						break;
+					case TGA_DFMT:
+						img_fol->out_format = "raw";
+						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx or *.bmp]!! \n");
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outformat);
 						return 1;
 						break;
 				}
@@ -346,8 +364,15 @@
 					img_fol->set_imgdir=1;
 				}
 				break;
+				/* ----------------------------------------------------- */								
+			case 'x':			/* Creation of index file */
+				{
+					char *index = optarg;
+					strncpy(indexfilename, index, OPJ_PATH_LEN);
+				}
+				break;
 				/* ----------------------------------------------------- */
-/* UniPG>> */
+				/* UniPG>> */
 #ifdef USE_JPWL
 			
 			case 'W': 			/* activate JPWL correction */
@@ -434,7 +459,7 @@
 		}
 		if(img_fol->set_out_format == 0){
 			fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
-			fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX,BMP!!\n");
+			fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
 			return 1;
 		}
 		if(!((parameters->outfile[0] == 0))){
@@ -443,9 +468,9 @@
 		}
 	}else{
 		if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
-			fprintf(stderr, "Error: One of option; -i or -ImgDir must be specified\n");
-			fprintf(stderr, "Error: When using -i; -o must be used\n");
-			fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2 -o *.pgm/ppm/pnm/pgx/bmp(+ options)\n");
+			fprintf(stderr, "Error: One of the options -i or -ImgDir must be specified\n");
+			fprintf(stderr, "Error: When using -i, -o must be used\n");
+			fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2/j2c -o *.pgm/ppm/pnm/pgx/bmp/tif/raw/tga(+ options)\n");
 			return 1;
 		}
 	}
@@ -492,6 +517,8 @@
 	dircnt_t *dirptr;
 	opj_dinfo_t* dinfo = NULL;	/* handle to a decompressor */
 	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
 
 	/* configure the event callbacks (not required) */
 	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
@@ -502,12 +529,16 @@
 	/* set decoding parameters to default values */
 	opj_set_default_decoder_parameters(&parameters);
 
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
 
 	/* parse input and get user encoding parameters */
-	if(parse_cmdline_decoder(argc, argv, &parameters,&img_fol) == 1) {
-		return 0;
+	if(parse_cmdline_decoder(argc, argv, &parameters,&img_fol, indexfilename) == 1) {
+		return 1;
 	}
 
+	/* Initialize reading of directory */
 	if(img_fol.set_imgdir==1){	
 		num_images=get_num_images(img_fol.imgdirpath);
 
@@ -535,9 +566,7 @@
 	}
 
 	/*Encoding image one by one*/
-	for(imageno = 0; imageno < num_images ; imageno++)
-	{
-
+	for(imageno = 0; imageno < num_images ; imageno++)	{
 		image = NULL;
 		fprintf(stderr,"\n");
 
@@ -546,10 +575,8 @@
 				fprintf(stderr,"skipping file...\n");
 				continue;
 			}
-
 		}
 
-
 		/* read the input file and put it in memory */
 		/* ---------------------------------------- */
 		fsrc = fopen(parameters.infile, "rb");
@@ -564,8 +591,6 @@
 		fread(src, 1, file_length, fsrc);
 		fclose(fsrc);
 
-
-
 		/* decode the code-stream */
 		/* ---------------------- */
 
@@ -587,7 +612,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -597,6 +625,15 @@
 
 			/* close the byte stream */
 			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -617,7 +654,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);			
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -628,6 +668,14 @@
 			/* close the byte stream */
 			opj_cio_close(cio);
 
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -648,7 +696,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -658,6 +709,15 @@
 
 			/* close the byte stream */
 			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -708,12 +768,33 @@
 				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
 			}
 			break;
+
+		case RAW_DFMT:			/* RAW */
+			if(imagetoraw(image, parameters.outfile)){
+				fprintf(stdout,"Error generating raw file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case TGA_DFMT:			/* TGA */
+			if(imagetotga(image, parameters.outfile)){
+				fprintf(stdout,"Error generating tga file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
 		}
 
 		/* free remaining structures */
 		if(dinfo) {
 			opj_destroy_decompress(dinfo);
 		}
+		/* free codestream information structure */
+		if (*indexfilename)	
+			opj_destroy_cstr_info(&cstr_info);
 		/* free image data structure */
 		opj_image_destroy(image);
 
@@ -722,3 +803,6 @@
 }
 //end main
 
+
+
+
diff -urN -xdebian -x.svn ./codec/j2k_to_image.dsp /usr/src/openjpeg/trunk/codec/j2k_to_image.dsp
--- ./codec/j2k_to_image.dsp	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/j2k_to_image.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -76,7 +76,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /nodefaultlib:"libcmt" /pdbtype:sept
 # SUBTRACT LINK32 /pdb:none
 
 !ENDIF 
@@ -103,6 +103,14 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\index.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\index.h
+# End Source File
+# Begin Source File
+
 SOURCE=.\j2k_to_image.c
 # End Source File
 # End Target
Binary files ./codec/j2k_to_image.sln and /usr/src/openjpeg/trunk/codec/j2k_to_image.sln differ
diff -urN -xdebian -x.svn ./codec/j2k_to_image.vcproj /usr/src/openjpeg/trunk/codec/j2k_to_image.vcproj
--- ./codec/j2k_to_image.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/codec/j2k_to_image.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,291 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="j2k_to_image"
+	ProjectGUID="{28931669-81A2-4B90-8981-CD707C4E76E6}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/j2k_to_image.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/j2k_to_image.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc,libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/j2k_to_image.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/j2k_to_image.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+		<File
+			RelativePath="j2k_to_image.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./codec/Makefile /usr/src/openjpeg/trunk/codec/Makefile
--- ./codec/Makefile	2007-12-01 19:18:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/codec/Makefile	2007-11-27 22:39:51.000000000 +0000
@@ -5,10 +5,10 @@
 all: j2k_to_image image_to_j2k
 
 j2k_to_image: j2k_to_image.c ../libopenjpeg.a
-	gcc $(CFLAGS) compat/getopt.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
 
 image_to_j2k: image_to_j2k.c ../libopenjpeg.a
-	gcc $(CFLAGS) compat/getopt.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
 
 clean:
 	rm -f j2k_to_image image_to_j2k
diff -urN -xdebian -x.svn ./diff.483 /usr/src/openjpeg/trunk/diff.483
--- ./diff.483	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/diff.483	2007-12-01 19:14:36.000000000 +0000
@@ -0,0 +1,14437 @@
+diff -urN -x.svn ../trunk.orig/ChangeLog ./ChangeLog
+--- ../trunk.orig/ChangeLog	2007-09-28 11:36:31.000000000 +0100
++++ ./ChangeLog	2007-12-01 18:40:47.000000000 +0000
+@@ -5,6 +5,73 @@
+ ! : changed
+ + : added
+ 
++November 29, 2007
++! [GB] Added index.h and index.c in VC6 projects; wrapped index.h in the C++ preprocessor; modified OPJViewer project and some files.
++
++November 14, 2007
+++ [FOD] Created the file index.c in the codec directory. This file handles the creation of index files, 
++		at encoding and decoding. 
++* [FOD] Fixed bugs during the creation of the index (PCRL progression order)
++* [FOD] Fixed the maximum number of resolutions a user can discard while decoding.
++		Added an error state in J2K_STATE (j2k.c)
++
++November 14, 2007
++! [FOD] - First Patch by Callum Lerwick. Instead of reinventing realloc, j2k_read_sod now just uses opj_realloc in j2k.c
++		- Second Patch by Callum Lerwick. This patch rearranges the largest memory allocations so they're allocated as 
++		late as possible, and freed as soon as possible. This cuts memory usage by about half on two large test images.
++		- Third Patch by Callum Lerwick. The opj_tcd_cblk array is one of the largest allocations, because it
++		contains a bunch of static buffers. This also makes it a major source of cache thrashing. This patch allocates 
++		the buffers from the heap, and dynamically sizes them in the decoder. I have not yet managed to dynamically size 
++		them in the encoder, getting the decoder to do it was tricky enough... I also split opj_tcd_cblk_t into separate 
++		encode and decode versions. A lot of fields were not used by both, so this cuts its size even further.
++
++* [FOD] Avoided ABI breakage
++
++November 13, 2007
++! [FOD] Patch by Dzonatas and Callum Lerwick.
++        Fp/vectorization patch which basically converts most of the irreversible decode codepath to floating point,
++        eliminating a few rounds of int/fp conversion, resulting in a vast performance improvement,
++	and an increase in accuracy.
++
++November 8, 2007
++! [FOD] In t1.c, small change to avoid calling twice t1_getwmsedec()
++        Patches from Callum Lewick:
++		- Basic gcc optimization flags in cmake and makefile match.
++		- Fixed some spelling errors in dwt.c.
++
++November 5, 2007
++*+ [GB] Fixed a bug which prevented JPWL from working on multi-tiled images; added some more fields in the interface info structures 
++(keep a list of markers, save start packet number for each tile)
++
++October 23, 2007
++* [GB] Improved success for the linux build; OPJViewer shows all the COM contents
++ 
++October 18, 2007
++* [FOD] Changed the ROI parameter in the image_to_j2k codec to make it correspond to the documentation (i.e. -ROI c=0,U=25)
++* [FOD] Patch from Callum Lewick. Memset patch. 
++		The main idea of the patch is that currently opj_malloc clears all allocations, which unnecessarily
++		dirties up the cache and eats bandwidth. This patch makes it no longer do so, and I've painstakingly determined which allocations actually need
++		to be cleared and changed them to use opj_calloc() instead. I previously tried to just get rid of the opj_*alloc wrappers but that
++		idea was nixed, so this time I'm trying it with macros. I also put in a gcc pragma that helps enforce their use. Which got messy.  :)  It caught a
++		few places they weren't used but it also revealed that the mj2 tools are not very cleanly separated from the library. It includes all the
++		internal headers, but it wasn't using the malloc wrappers. I figured the binaries should be "external" and have minimal knowledge of the
++		internals of the library. I patched them to not include opj_includes.h, and include only the internal headers they actually need. However,
++		they're using the opj_clock() function, which is in with the malloc wrappers. So I decided to move the malloc wrappers to their own header. 
++		But mj2.c seems to want to be "internal", so I patched it to use the wrappers. Note that this patch changes the semantics of opj_malloc, it no longer
++		clears the memory it allocates. If you need it to be cleared, you must use opj_calloc instead, or memset it yourself. It is also somewhat
++		invasive, please test it extensively. I've been pounding on it all summer with my test suite, Second Life, and valgrind, and it checks out clean.
++
++October 12, 2007
++* [FOD] Changed the way the image structure is allocated when the decoding parameters include some resolutions to discard. 
++        This should have a significant impact for the decoding of huge images when some resolutions are discarder (-r parameter)
++        Warning: The output image size is now reduced when discarding resolutions !
++
++October 10, 2007
++* [FOD] Patch from Callum Lewick. Clean up of j2klib.h for the aligned malloc stuff. 
++        It makes it work right with mingw, as _mm_malloc() isn't a macro, attempts to pave the way to using cmake 
++        to check for this stuff and combines a patch from Dana Fagerstrom at Sun that makes it use memalign() on Solaris
++        convert.c: Changed some error comments for TIFF images
++
+ September 27, 2007
+ * [FOD] Patch from Callum Lewick. Fixed dwt.c where an alignment in buffer was problematic under x86_64.
+ 
+@@ -54,10 +121,12 @@
+ * [Mathieu Malaterre] Fix unitialized read in img_fol (we may need a smarter initialize than memset)
+ 
+ September 4, 2007
+-+ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. Changed also the write_index function in the codec, to reflect the presence of this new information.
+++ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. 
++		Changed also the write_index function in the codec, to reflect the presence of this new information.
+ 
+ September 3, 2007
+-+ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: no real security function at this stage. Deprecated USE_JPSEC will be removed next
+++ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: 
++		no real security function at this stage. Deprecated USE_JPSEC will be removed next
+ 
+ August 31, 2007
+ * [GB] Fixed save capabilities in OPJViewer due to recent code upgrade
+@@ -109,12 +178,15 @@
+ + [FOD] Added support for RAW images. This module has been developped by the University of Perugia team. Thanks to them ! [image_to_j2k.c j2k_to_image.c convert.c convert.h]
+ 
+ July 13, 2007
+-! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
++! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, 
++		leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
+ ! [FOD] Modified old comments about the ability to decode mega-images and comments about the disk size necessary to do this. [image_to_j2k.c and frames_to_mj2.c]
+ * [FOD] Added 2000 bytes for the memory allocation in cio.c for the minimum size of headers (useful in case of very small images) [cio.c]
+ 
+ July 12, 2007
+-* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
++* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, 
++		even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension 
++		is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
+ 
+ July 8, 2007
+ * [ANTONIN] fixed the size of the memory allocation in cio.c (confusion between bits and bytes)
+@@ -149,13 +221,16 @@
+ * [FOD] Fixed the parameters used for cinema compression (9-7 transform used instead of 5-3). Modified "image_to_j2k.c"
+ 
+ May 24, 2007
+-* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker the value of numlayers and numresolution.
++* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker 
++		the value of numlayers and numresolution.
+ 
+ May 23, 2007
+ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This makes the t1 data arrays dynamic, which greatly reduces cache thrashing. Also, some minor cleanup to prevent unnecessary casts"
+ 
+ May 22, 2007
+-! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
++! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, 
++		so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix 
++		increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
+ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This changes the flag code in t1 to use a flag_t type, which can then be changed to reduce RAM usage. It is now typedef to a short."
+ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This patch makes the t1 LUTs static. I actually intend this as a prelude to possibly eliminating some or all of the LUTs entirely."
+ 
+@@ -204,14 +279,17 @@
+ * [Parvatha] Equation to check multiple tile precincts. Modification pi.c
+ ! [Parvatha] array size generation of pi->include in pi_initialise_encode().Modification in pi.c
+ * [Parvatha] modification in pi_create_encode for tile part generation.Modification in pi.c
+-+ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
+++ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. 
++			 This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
+ 
+ March 28, 2007
+ * [FOD] Fixed an historical bug in t1.c that leaded to the inclusion of useless 0xFF in the codestream. Thanks to Sylvain, Pascal and Parvatha !
+ 
+ March 27, 2007
+-+ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
+-* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
+++ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; 
++		can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
++* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, 
++		have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
+ + [GB] Added linking to TIFF library in the JPWL VC6 workspaces
+ 
+ March 23, 2007
+@@ -257,7 +335,8 @@
+ ----------------------
+ 
+ February 23, 2007
+-* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
++* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. 
++		As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
+ + [GB] Linux makefile for the JPWL module; newlines at end of JPWL files
+ 
+ February 22, 2007
+diff -urN -x.svn ../trunk.orig/CMakeLists.txt ./CMakeLists.txt
+--- ../trunk.orig/CMakeLists.txt	2007-09-28 11:36:31.000000000 +0100
++++ ./CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
+@@ -7,7 +7,6 @@
+ # For this purpose you can define a CMake var: OPENJPEG_NAMESPACE to whatever you like
+ # e.g.:
+ # SET(OPENJPEG_NAMESPACE "GDCMOPENJPEG")
+-PROJECT(OPENJPEG C)
+ CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
+ 
+ IF(NOT OPENJPEG_NAMESPACE)
+@@ -17,7 +16,7 @@
+ # In all cases:
+ STRING(TOLOWER ${OPENJPEG_NAMESPACE} OPENJPEG_LIBRARY_NAME)
+ 
+-PROJECT(${JPEG_NAMESPACE} C)
++PROJECT(${OPENJPEG_NAMESPACE} C)
+ 
+ # Do full dependency headers.
+ INCLUDE_REGULAR_EXPRESSION("^.*$")
+@@ -116,3 +115,12 @@
+   $ENV{JPEG2000_CONFORMANCE_DATA_ROOT}
+ )
+ 
++#-----------------------------------------------------------------------------
++# Compiler specific flags:
++IF(CMAKE_COMPILER_IS_GNUCC)
++  # For all builds, make sure openjpeg is std99 compliant:
++  SET(CMAKE_C_FLAGS "-Wall -std=c99 ${CMAKE_C_FLAGS}")
++  # Do not use ffast-math for all build, it would produce incorrect results, only set for release:
++  SET(CMAKE_C_FLAGS_RELEASE "-ffast-math ${CMAKE_C_FLAGS_RELEASE}")
++ENDIF(CMAKE_COMPILER_IS_GNUCC)
++
+diff -urN -x.svn ../trunk.orig/codec/CMakeLists.txt ./codec/CMakeLists.txt
+--- ../trunk.orig/codec/CMakeLists.txt	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
+@@ -3,7 +3,9 @@
+ # First thing define the common source:
+ SET(common_SRCS
+   convert.c
+-  )
++  index.c
++)
++
+ # Then check if getopt is present:
+ INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
+ SET(DONT_HAVE_GETOPT 1)
+@@ -24,7 +26,6 @@
+   )
+ ENDIF(DONT_HAVE_GETOPT)
+ 
+-
+ # Headers file are located here:
+ INCLUDE_DIRECTORIES(
+   ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+diff -urN -x.svn ../trunk.orig/codec/convert.c ./codec/convert.c
+--- ../trunk.orig/codec/convert.c	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/convert.c	2007-11-27 22:39:51.000000000 +0000
+@@ -310,15 +310,15 @@
+    }
+ 	}
+ 
+-	width  = int_ceildiv(image->x1-image->x0, image->comps[0].dx);
+-	height = int_ceildiv(image->y1-image->y0, image->comps[0].dy);
++	width = image->comps[0].w;
++	height = image->comps[0].h; 
+ 
+ 	// Mono with alpha, or RGB with alpha.
+ 	write_alpha = (image->numcomps==2) || (image->numcomps==4);   
+ 
+ 	// Write TGA header 
+ 	bpp = write_alpha ? 32 : 24;
+-	if (!tga_writeheader(fdest, bpp, width, height, true))
++	if (!tga_writeheader(fdest, bpp, width , height, true))
+ 		return 1;
+ 
+ 	alpha_channel = image->numcomps-1; 
+@@ -764,7 +764,7 @@
+ }
+ 
+ int imagetobmp(opj_image_t * image, const char *outfile) {
+-	int w, wr, h, hr;
++	int w, h;
+ 	int i, pad;
+ 	FILE *fdest = NULL;
+ 	int adjustR, adjustG, adjustB;
+@@ -786,42 +786,39 @@
+ 			return 1;
+ 		}
+ 	    
+-		w = image->comps[0].w;
+-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
+-	    
++		w = image->comps[0].w;	    
+ 		h = image->comps[0].h;
+-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
+ 	    
+ 		fprintf(fdest, "BM");
+ 	    
+ 		/* FILE HEADER */
+ 		/* ------------- */
+ 		fprintf(fdest, "%c%c%c%c",
+-			(unsigned char) (hr * wr * 3 + 3 * hr * (wr % 2) + 54) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 8) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 16) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 24) & 0xff);
++			(unsigned char) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 8) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 16) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
+ 	    
+ 		/* INFO HEADER   */
+ 		/* ------------- */
+ 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
+-			(unsigned char) ((wr) >> 8) & 0xff,
+-			(unsigned char) ((wr) >> 16) & 0xff,
+-			(unsigned char) ((wr) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
+-			(unsigned char) ((hr) >> 8) & 0xff,
+-			(unsigned char) ((hr) >> 16) & 0xff,
+-			(unsigned char) ((hr) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
++			(unsigned char) ((w) >> 8) & 0xff,
++			(unsigned char) ((w) >> 16) & 0xff,
++			(unsigned char) ((w) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
++			(unsigned char) ((h) >> 8) & 0xff,
++			(unsigned char) ((h) >> 16) & 0xff,
++			(unsigned char) ((h) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
+ 		fprintf(fdest, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * hr * wr + 3 * hr * (wr % 2)) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 8) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 16) & 0xff,
+-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * h * w + 3 * h * (w % 2)) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,
++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+@@ -846,24 +843,24 @@
+ 		else 
+ 			adjustB = 0;
+ 
+-		for (i = 0; i < wr * hr; i++) {
++		for (i = 0; i < w * h; i++) {
+ 			unsigned char rc, gc, bc;
+ 			int r, g, b;
+ 							
+-			r = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
++			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+-			g = image->comps[1].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
++			g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+ 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+ 			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+-			b = image->comps[2].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
++			b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+ 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+ 			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+ 
+ 			fprintf(fdest, "%c%c%c", bc, gc, rc);
+ 			
+-			if ((i + 1) % wr == 0) {
+-				for (pad = (3 * wr) % 4 ? 4 - (3 * wr) % 4 : 0; pad > 0; pad--)	/* ADD */
++			if ((i + 1) % w == 0) {
++				for (pad = (3 * w) % 4 ? 4 - (3 * w) % 4 : 0; pad > 0; pad--)	/* ADD */
+ 					fprintf(fdest, "%c", 0);
+ 			}
+ 		}
+@@ -875,20 +872,17 @@
+ 		<<-- <<-- <<-- <<-- */
+ 
+ 		fdest = fopen(outfile, "wb");
+-		w = image->comps[0].w;
+-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
+-	    
++		w = image->comps[0].w;	    
+ 		h = image->comps[0].h;
+-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
+ 	    
+ 		fprintf(fdest, "BM");
+ 	    
+ 		/* FILE HEADER */
+ 		/* ------------- */
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + 54 + 1024 + hr * (wr % 2)) & 0xff,
+-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 8) & 0xff,
+-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 16) & 0xff,
+-			(unsigned char) ((hr * wr + 54 + 1024 + wr * (wr % 2)) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,
++			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,
++			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,
++			(unsigned char) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, 
+ 			((54 + 1024) >> 16) & 0xff,
+@@ -897,21 +891,21 @@
+ 		/* INFO HEADER */
+ 		/* ------------- */
+ 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
+-			(unsigned char) ((wr) >> 8) & 0xff,
+-			(unsigned char) ((wr) >> 16) & 0xff,
+-			(unsigned char) ((wr) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
+-			(unsigned char) ((hr) >> 8) & 0xff,
+-			(unsigned char) ((hr) >> 16) & 0xff,
+-			(unsigned char) ((hr) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
++			(unsigned char) ((w) >> 8) & 0xff,
++			(unsigned char) ((w) >> 16) & 0xff,
++			(unsigned char) ((w) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
++			(unsigned char) ((h) >> 8) & 0xff,
++			(unsigned char) ((h) >> 16) & 0xff,
++			(unsigned char) ((h) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
+ 		fprintf(fdest, "%c%c", (8) & 0xff, ((8) >> 8) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + hr * (wr % 2)) & 0xff,
+-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 8) &	0xff,
+-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 16) &	0xff,
+-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 24) & 0xff);
++		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + h * (w % 2)) & 0xff,
++			(unsigned char) ((h * w + h * (w % 2)) >> 8) &	0xff,
++			(unsigned char) ((h * w + h * (w % 2)) >> 16) &	0xff,
++			(unsigned char) ((h * w + h * (w % 2)) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+ 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
+@@ -926,18 +920,18 @@
+ 			fprintf(fdest, "%c%c%c%c", i, i, i, 0);
+ 		}
+ 
+-		for (i = 0; i < wr * hr; i++) {
++		for (i = 0; i < w * h; i++) {
+ 			unsigned char rc;
+ 			int r;
+ 			
+-			r = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
++			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+ 			
+ 			fprintf(fdest, "%c", rc);
+ 
+-			if ((i + 1) % wr == 0) {
+-				for (pad = wr % 4 ? 4 - wr % 4 : 0; pad > 0; pad--)	/* ADD */
++			if ((i + 1) % w == 0) {
++				for (pad = w % 4 ? 4 - w % 4 : 0; pad > 0; pad--)	/* ADD */
+ 					fprintf(fdest, "%c", 0);
+ 			}
+ 		}
+@@ -1098,7 +1092,7 @@
+ }
+ 
+ int imagetopgx(opj_image_t * image, const char *outfile) {
+-	int w, wr, h, hr;
++	int w, h;
+ 	int i, j, compno;
+ 	FILE *fdest = NULL;
+ 
+@@ -1135,12 +1129,9 @@
+       }
+ 
+ 		w = image->comps[compno].w;
+-		wr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
+-	    
+ 		h = image->comps[compno].h;
+-		hr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
+ 	    
+-		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, wr, hr);
++		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, w, h);
+ 		if (comp->prec <= 8) {
+ 			nbytes = 1;
+ 		} else if (comp->prec <= 16) {
+@@ -1148,8 +1139,8 @@
+ 		} else {
+ 			nbytes = 4;
+ 		}
+-		for (i = 0; i < wr * hr; i++) {
+-			int v = image->comps[compno].data[i / wr * w + i % wr];
++		for (i = 0; i < w * h; i++) {
++			int v = image->comps[compno].data[i];
+ 			for (j = nbytes - 1; j >= 0; j--) {
+ 				char byte = (char) (v >> (j * 8));
+ 				fwrite(&byte, 1, 1, fdest);
+@@ -1267,7 +1258,7 @@
+ }
+ 
+ int imagetopnm(opj_image_t * image, const char *outfile) {
+-	int w, wr, wrr, h, hr, hrr, max;
++	int w, wr, h, hr, max;
+ 	int i, compno;
+ 	int adjustR, adjustG, adjustB, adjustX;
+ 	FILE *fdest = NULL;
+@@ -1297,18 +1288,16 @@
+ 
+ 		w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
+ 		wr = image->comps[0].w;
+-		wrr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
+         
+ 		h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
+ 		hr = image->comps[0].h;
+-		hrr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
+ 	    
+ 		max = image->comps[0].prec > 8 ? 255 : (1 << image->comps[0].prec) - 1;
+ 	    
+ 		image->comps[0].x0 = int_ceildivpow2(image->comps[0].x0 - int_ceildiv(image->x0, image->comps[0].dx), image->comps[0].factor);
+ 		image->comps[0].y0 = int_ceildivpow2(image->comps[0].y0 -	int_ceildiv(image->y0, image->comps[0].dy), image->comps[0].factor);
+ 
+-		fprintf(fdest, "P6\n%d %d\n%d\n", wrr, hrr, max);
++		fprintf(fdest, "P6\n%d %d\n%d\n", wr, hr, max);
+ 
+ 		if (image->comps[0].prec > 8) {
+ 			adjustR = image->comps[0].prec - 8;
+@@ -1330,18 +1319,18 @@
+ 			adjustB = 0;
+ 
+ 
+-		for (i = 0; i < wrr * hrr; i++) {
++		for (i = 0; i < wr * hr; i++) {
+ 			int r, g, b;
+ 			unsigned char rc,gc,bc;
+-			r = image->comps[0].data[i / wrr * wr + i % wrr];
++			r = image->comps[0].data[i];
+ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+ 
+-			g = image->comps[1].data[i / wrr * wr + i % wrr];
++			g = image->comps[1].data[i];
+ 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+ 			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+ 			
+-			b = image->comps[2].data[i / wrr * wr + i % wrr];
++			b = image->comps[2].data[i];
+ 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+ 			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+ 			
+@@ -1371,18 +1360,16 @@
+             
+ 			w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
+ 			wr = image->comps[compno].w;
+-			wrr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
+ 			
+ 			h = int_ceildiv(image->y1 - image->y0, image->comps[compno].dy);
+ 			hr = image->comps[compno].h;
+-			hrr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
+ 			
+ 			max = image->comps[compno].prec > 8 ? 255 : (1 << image->comps[compno].prec) - 1;
+ 			
+ 			image->comps[compno].x0 = int_ceildivpow2(image->comps[compno].x0 - int_ceildiv(image->x0, image->comps[compno].dx), image->comps[compno].factor);
+ 			image->comps[compno].y0 = int_ceildivpow2(image->comps[compno].y0 - int_ceildiv(image->y0, image->comps[compno].dy), image->comps[compno].factor);
+ 			
+-			fprintf(fdest, "P5\n%d %d\n%d\n", wrr, hrr, max);
++			fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
+ 			
+ 			if (image->comps[compno].prec > 8) {
+ 				adjustX = image->comps[0].prec - 8;
+@@ -1391,10 +1378,10 @@
+ 			else 
+ 				adjustX = 0;
+ 			
+-			for (i = 0; i < wrr * hrr; i++) {
++			for (i = 0; i < wr * hr; i++) {
+ 				int l;
+ 				unsigned char lc;
+-				l = image->comps[compno].data[i / wrr * wr + i % wrr];
++				l = image->comps[compno].data[i];
+ 				l += (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);
+ 				lc = (unsigned char) ((l >> adjustX)+((l >> (adjustX-1))%2));
+ 				fprintf(fdest, "%c", lc);
+@@ -1423,7 +1410,7 @@
+ }tiff_infoheader_t;
+ 
+ int imagetotif(opj_image_t * image, const char *outfile) {
+-	int width, height, imgsize ;
++	int width, height, imgsize;
+ 	int bps,index,adjust = 0;
+ 	int last_i=0;
+ 	TIFF *tif;
+@@ -1450,7 +1437,7 @@
+ 
+ 			width	= image->comps[0].w;
+ 			height	= image->comps[0].h;
+-			imgsize = image->comps[0].w * image->comps[0].h ;
++			imgsize = width * height ;
+ 			bps		= image->comps[0].prec;
+ 			/* Set tags */
+ 			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
+@@ -1463,10 +1450,9 @@
+ 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
+ 
+ 			/* Get a buffer for the data */
+-			buf = _TIFFmalloc(TIFFStripSize(tif));
+-			index=0;
+-			strip_size=0;
+ 			strip_size=TIFFStripSize(tif);
++			buf = _TIFFmalloc(strip_size);
++			index=0;		
+ 			adjust = image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0;
+ 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+ 				unsigned char *dat8;
+@@ -1647,7 +1633,7 @@
+ 
+ 			width	= image->comps[0].w;
+ 			height	= image->comps[0].h;
+-			imgsize = image->comps[0].w * image->comps[0].h ;
++			imgsize = width * height;
+ 			bps		= image->comps[0].prec;
+ 
+ 			/* Set tags */
+@@ -1661,10 +1647,9 @@
+ 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
+ 
+ 			/* Get a buffer for the data */
+-			buf = _TIFFmalloc(TIFFStripSize(tif));
+-			index = 0;
+-			strip_size = 0;
+ 			strip_size = TIFFStripSize(tif);
++			buf = _TIFFmalloc(strip_size);
++			index = 0;			
+ 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+ 				unsigned char *dat8;
+ 				int i;
+@@ -1714,7 +1699,7 @@
+ 							break; 
+ 					}
+ 				}else{
+-					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
++					fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+ 					fprintf(stderr,"Aborting\n");
+ 					return 1;
+ 				}
+@@ -1723,7 +1708,7 @@
+ 			_TIFFfree(buf);
+ 			TIFFClose(tif);
+ 		}else{
+-			fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
++			fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+ 			fprintf(stderr,"Aborting\n");
+ 			return 1;
+ 		}
+@@ -1858,7 +1843,7 @@
+ 				}
+ 			}
+ 			else{
+-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
++				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+ 				fprintf(stderr,"Aborting\n");
+ 				return NULL;
+ 			}
+@@ -1936,7 +1921,7 @@
+ 				}
+ 			}
+ 			else{
+-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
++				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+ 				fprintf(stderr,"Aborting\n");
+ 				return NULL;
+ 			}
+@@ -1945,7 +1930,7 @@
+ 		_TIFFfree(buf);
+ 		TIFFClose(tif);
+ 	}else{
+-		fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
++		fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+ 		fprintf(stderr,"Aborting\n");
+ 		return NULL;
+ 	}
+@@ -2052,7 +2037,10 @@
+ int imagetoraw(opj_image_t * image, const char *outfile)
+ {
+ 	FILE *rawFile = NULL;
+-	int compno, pixelsToWrite, offset, cont;
++	int compno;
++	int w, h;
++	int line, row;
++	int *ptr;
+ 
+ 	if((image->numcomps * image->x1 * image->y1) == 0)
+ 	{
+@@ -2073,8 +2061,8 @@
+ 		fprintf(stdout,"Component %d characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
+ 			image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
+ 
+-		pixelsToWrite = image->comps[compno].w * image->comps[compno].h;
+-		offset = 0;
++		w = image->comps[compno].w;
++		h = image->comps[compno].h;
+ 
+ 		if(image->comps[compno].prec <= 8)
+ 		{
+@@ -2082,20 +2070,26 @@
+ 			{
+ 				signed char curr;
+ 				int mask = (1 << image->comps[compno].prec) - 1;
+-				for(cont = 0; cont < pixelsToWrite; cont++)
+-				{				
+-					curr = (signed char) (image->comps[compno].data[cont] & mask);
+-					fwrite(&curr, sizeof(signed char), 1, rawFile);
++				ptr = image->comps[compno].data;
++				for (line = 0; line < h; line++) {
++					for(row = 0; row < w; row++)	{				
++						curr = (signed char) (*ptr & mask);
++						fwrite(&curr, sizeof(signed char), 1, rawFile);
++						ptr++;
++					}
+ 				}
+ 			}
+ 			else if(image->comps[compno].sgnd == 0)
+ 			{
+ 				unsigned char curr;
+ 				int mask = (1 << image->comps[compno].prec) - 1;
+-				for(cont = 0; cont < pixelsToWrite; cont++)
+-				{				
+-					curr = (unsigned char) (image->comps[compno].data[cont] & mask);
+-					fwrite(&curr, sizeof(unsigned char), 1, rawFile);
++				ptr = image->comps[compno].data;
++				for (line = 0; line < h; line++) {
++					for(row = 0; row < w; row++)	{	
++						curr = (unsigned char) (*ptr & mask);
++						fwrite(&curr, sizeof(unsigned char), 1, rawFile);
++						ptr++;
++					}
+ 				}
+ 			}
+ 		}
+@@ -2105,31 +2099,37 @@
+ 			{
+ 				signed short int curr;
+ 				int mask = (1 << image->comps[compno].prec) - 1;
+-				for(cont = 0; cont < pixelsToWrite; cont++)
+-				{				
+-					curr = (signed short int) (image->comps[compno].data[cont] & mask);
+-					fwrite(&curr, sizeof(signed short int), 1, rawFile);
++				ptr = image->comps[compno].data;
++				for (line = 0; line < h; line++) {
++					for(row = 0; row < w; row++)	{					
++						curr = (signed short int) (*ptr & mask);
++						fwrite(&curr, sizeof(signed short int), 1, rawFile);
++						ptr++;
++					}
+ 				}
+ 			}
+ 			else if(image->comps[compno].sgnd == 0)
+ 			{
+ 				unsigned short int curr;
+ 				int mask = (1 << image->comps[compno].prec) - 1;
+-				for(cont = 0; cont < pixelsToWrite; cont++)
+-				{				
+-					curr = (unsigned short int) (image->comps[compno].data[cont] & mask);
+-					fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
++				ptr = image->comps[compno].data;
++				for (line = 0; line < h; line++) {
++					for(row = 0; row < w; row++)	{				
++						curr = (unsigned short int) (*ptr & mask);
++						fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
++						ptr++;
++					}
+ 				}
+ 			}
+ 		}
+ 		else if (image->comps[compno].prec <= 32)
+ 		{
+-
+-
++			fprintf(stderr,"More than 16 bits per component no handled yet\n");
++			return 1;
+ 		}
+ 		else
+ 		{
+-			fprintf(stderr,"\nError: invalid precision\n");
++			fprintf(stderr,"Error: invalid precision: %d\n", image->comps[compno].prec);
+ 			return 1;
+ 		}
+ 	}
+diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.c ./codec/image_to_j2k.c
+--- ../trunk.orig/codec/image_to_j2k.c	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/image_to_j2k.c	2007-11-27 22:39:51.000000000 +0000
+@@ -38,6 +38,7 @@
+ #include "compat/getopt.h"
+ #include "convert.h"
+ #include "dirent.h"
++#include "index.h"
+ 
+ #ifndef WIN32
+ #define stricmp strcasecmp
+@@ -199,7 +200,7 @@
+ 	fprintf(stdout,"\n");
+ 	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
+ 	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
+-	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
++	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
+ 	fprintf(stdout,"\n");
+ 	fprintf(stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
+ 	fprintf(stdout,"\n");
+@@ -566,273 +567,6 @@
+ 
+ /* ------------------------------------------------------------------------------------ */
+ 
+-/**
+-Create an index and write it to a file
+-@param cstr_info Codestream information 
+-@param index Index filename
+-@return Returns 0 if successful, returns 1 otherwise
+-*/
+-int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+-	FILE *stream = NULL;
+-	double total_disto = 0;
+-/* UniPG>> */
+-	int tilepartno;
+-
+-#ifdef USE_JPWL
+-	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+-		return 0;
+-#endif /* USE_JPWL */
+-/* <<UniPG */
+-
+-	if (!cstr_info)		
+-		return 1;
+-
+-	stream = fopen(index, "w");
+-	if (!stream) {
+-		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+-		return 1;
+-	}
+-	
+-	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+-	fprintf(stream, "%d\n", cstr_info->prog);
+-	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+-	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+-	fprintf(stream, "%d\n", cstr_info->numcomps);
+-	fprintf(stream, "%d\n", cstr_info->numlayers);
+-	fprintf(stream, "%d\n", cstr_info->numdecompos);
+-
+-	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+-		fprintf(stream, "[%d,%d] ", 
+-			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+-	}
+-
+-	fprintf(stream, "\n");
+-/* UniPG>> */
+-	fprintf(stream, "%d\n", cstr_info->main_head_start);
+-/* <<UniPG */
+-	fprintf(stream, "%d\n", cstr_info->main_head_end);
+-	fprintf(stream, "%d\n", cstr_info->codestream_size);
+-	
+-	fprintf(stream, "\nINFO ON TILES\n");
+-	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts         disto     nbpix   disto/nbpix\n");
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		fprintf(stream, "%4d %9d %9d %9d %9d %9e %9d %9e\n",
+-			cstr_info->tile[tileno].tileno,
+-			cstr_info->tile[tileno].start_pos,
+-			cstr_info->tile[tileno].end_header,
+-			cstr_info->tile[tileno].end_pos,
+-			cstr_info->tile[tileno].num_tps,
+-			cstr_info->tile[tileno].distotile, cstr_info->tile[tileno].numpix,
+-			cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+-	}
+-		
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		int start_pos, end_ph_pos, end_pos;
+-		double disto = 0;
+-		int max_numdecompos = 0;
+-		pack_nb = 0;
+-
+-		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-			if (max_numdecompos < cstr_info->numdecompos[compno])
+-				max_numdecompos = cstr_info->numdecompos[compno];
+-		}	
+-
+-		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+-		fprintf(stream, "part_nb tileno  num_packs  start_pos end_tph_pos   end_pos\n");
+-		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+-			fprintf(stream, "%4d %9d  %9d  %9d %11d %9d\n",
+-				tilepartno, tileno,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+-				);
+-		if (cstr_info->prog == LRCP) {	/* LRCP */
+-			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
+-
+-			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max;
+-						if (resno > cstr_info->numdecompos[compno])
+-							break;
+-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+-							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d %8e\n",
+-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+-							total_disto += disto;
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* LRCP */
+-		else if (cstr_info->prog == RLCP) {	/* RLCP */
+-
+-			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos disto\n");
+-
+-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max; 
+-						if (resno > cstr_info->numdecompos[compno])
+-							break;
+-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d %8e\n",
+-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+-							total_disto += disto;
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* RLCP */
+-		else if (cstr_info->prog == RPCL) {	/* RPCL */
+-
+-			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos disto\n"); 
+-
+-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					if (resno > cstr_info->numdecompos[compno])
+-							break;
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d %8e\n",
+-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos, disto); 
+-											total_disto += disto;
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* compno */
+-			} /* resno */
+-		} /* RPCL */
+-		else if (cstr_info->prog == PCRL) {	/* PCRL */
+-			/* I suppose components have same XRsiz, YRsiz */
+-			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-			int x1 = x0 + cstr_info->tile_x;
+-			int y1 = y0 + cstr_info->tile_y;
+-
+-			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos disto\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+-											total_disto += disto;
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* PCRL */
+-		else {	/* CPRL */
+-
+-			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos disto\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				
+-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+-											total_disto += disto;
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							}
+-						} /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* CPRL */   
+-	} /* tileno */
+-	
+-	fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */
+-	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+-	fclose(stream);
+-
+-	fprintf(stderr,"Generated index file %s\n", index);
+-
+-	return 0;
+-}
+-
+-/* ------------------------------------------------------------------------------------ */
+-
+ int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,
+ 													img_fol_t *img_fol, raw_cparameters_t *raw_cp, char *indexfilename) {
+ 	int i, j,totlen;
+@@ -845,6 +579,7 @@
+ 		{"EPH",NO_ARG, NULL ,'E'},
+ 		{"OutFor",REQ_ARG, NULL ,'O'},
+ 		{"POC",REQ_ARG, NULL ,'P'},
++		{"ROI",REQ_ARG, NULL ,'R'},
+ 	};
+ 
+ 	/* parse the command line */
+@@ -1219,9 +954,9 @@
+ 
+ 			case 'R':			/* ROI */
+ 			{
+-				if (sscanf(optarg, "OI:c=%d,U=%d", &parameters->roi_compno,
++				if (sscanf(optarg, "c=%d,U=%d", &parameters->roi_compno,
+                                            &parameters->roi_shift) != 2) {
+-					fprintf(stderr, "ROI error !! [-ROI:c='compno',U='shift']\n");
++					fprintf(stderr, "ROI error !! [-ROI c='compno',U='shift']\n");
+ 					return 1;
+ 				}
+ 			}
+diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.dsp ./codec/image_to_j2k.dsp
+--- ../trunk.orig/codec/image_to_j2k.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/image_to_j2k.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -106,5 +106,13 @@
+ 
+ SOURCE=.\image_to_j2k.c
+ # End Source File
++# Begin Source File
++
++SOURCE=.\index.c
++# End Source File
++# Begin Source File
++
++SOURCE=.\index.h
++# End Source File
+ # End Target
+ # End Project
+Binary files ../trunk.orig/codec/image_to_j2k.sln and ./codec/image_to_j2k.sln differ
+diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.vcproj ./codec/image_to_j2k.vcproj
+--- ../trunk.orig/codec/image_to_j2k.vcproj	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/image_to_j2k.vcproj	2007-11-27 22:39:51.000000000 +0000
+@@ -278,6 +278,14 @@
+ 				/>
+ 			</FileConfiguration>
+ 		</File>
++		<File
++			RelativePath=".\index.c"
++			>
++		</File>
++		<File
++			RelativePath=".\index.h"
++			>
++		</File>
+ 	</Files>
+ 	<Globals>
+ 	</Globals>
+diff -urN -x.svn ../trunk.orig/codec/index.c ./codec/index.c
+--- ../trunk.orig/codec/index.c	1970-01-01 01:00:00.000000000 +0100
++++ ./codec/index.c	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,391 @@
++/*
++ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
++ * Copyright (c) 2002-2007, Professor Benoit Macq
++ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++
++#include <stdio.h>
++#include <math.h>
++#include <string.h>
++#include "openjpeg.h"
++#include "index.h"
++
++/* ------------------------------------------------------------------------------------ */
++
++/**
++Write a structured index to a file
++@param cstr_info Codestream information 
++@param index Index filename
++@return Returns 0 if successful, returns 1 otherwise
++*/
++int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
++	int tileno, compno, layno, resno, precno, pack_nb, x, y;
++	FILE *stream = NULL;
++	double total_disto = 0;
++/* UniPG>> */
++	int tilepartno;
++	char disto_on, numpix_on;
++
++#ifdef USE_JPWL
++	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
++		return 0;
++#endif /* USE_JPWL */
++/* <<UniPG */
++
++	if (!cstr_info)		
++		return 1;
++
++	stream = fopen(index, "w");
++	if (!stream) {
++		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
++		return 1;
++	}
++	
++	if (cstr_info->tile[0].distotile)
++		disto_on = 1;
++	else 
++		disto_on = 0;
++
++	if (cstr_info->tile[0].numpix)
++		numpix_on = 1;
++	else 
++		numpix_on = 0;
++
++	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
++	fprintf(stream, "%d\n", cstr_info->prog);
++	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
++	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
++	fprintf(stream, "%d\n", cstr_info->numcomps);
++	fprintf(stream, "%d\n", cstr_info->numlayers);
++	fprintf(stream, "%d\n", cstr_info->numdecompos);
++
++	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
++		fprintf(stream, "[%d,%d] ", 
++			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
++	}
++
++	fprintf(stream, "\n");
++/* UniPG>> */
++	fprintf(stream, "%d\n", cstr_info->main_head_start);
++/* <<UniPG */
++	fprintf(stream, "%d\n", cstr_info->main_head_end);
++	fprintf(stream, "%d\n", cstr_info->codestream_size);
++	
++	fprintf(stream, "\nINFO ON TILES\n");
++	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
++	if (disto_on)
++		fprintf(stream,"         disto");
++	if (numpix_on)
++		fprintf(stream,"     nbpix");
++	if (disto_on && numpix_on)
++		fprintf(stream,"  disto/nbpix");
++	fprintf(stream, "\n");
++
++	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++		fprintf(stream, "%4d %9d %9d %9d %9d", 
++			cstr_info->tile[tileno].tileno,
++			cstr_info->tile[tileno].start_pos,
++			cstr_info->tile[tileno].end_header,
++			cstr_info->tile[tileno].end_pos,
++			cstr_info->tile[tileno].num_tps);
++		if (disto_on)
++			fprintf(stream," %9e", cstr_info->tile[tileno].distotile);
++		if (numpix_on)
++			fprintf(stream," %9d", cstr_info->tile[tileno].numpix);
++		if (disto_on && numpix_on)
++			fprintf(stream," %9e", cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
++		fprintf(stream, "\n");
++	}
++		
++	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++		int start_pos, end_ph_pos, end_pos;
++		double disto = 0;
++		int max_numdecompos = 0;
++		pack_nb = 0;
++
++		for (compno = 0; compno < cstr_info->numcomps; compno++) {
++			if (max_numdecompos < cstr_info->numdecompos[compno])
++				max_numdecompos = cstr_info->numdecompos[compno];
++		}	
++
++		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
++		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
++		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
++			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
++				tilepartno, tileno,
++				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
++				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
++				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
++				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
++				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
++				);
++
++		if (cstr_info->prog == LRCP) {	/* LRCP */
++			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
++			if (disto_on)
++				fprintf(stream, " disto");
++			fprintf(stream,"\n");
++
++			for (layno = 0; layno < cstr_info->numlayers; layno++) {
++				for (resno = 0; resno < max_numdecompos + 1; resno++) {
++					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++						int prec_max;
++						if (resno > cstr_info->numdecompos[compno])
++							break;
++						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++						for (precno = 0; precno < prec_max; precno++) {
++							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d",
++								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
++							if (disto_on)
++								fprintf(stream, " %8e", disto);
++							fprintf(stream, "\n");
++							total_disto += disto;
++							pack_nb++;
++						}
++					}
++				}
++			}
++		} /* LRCP */
++
++		else if (cstr_info->prog == RLCP) {	/* RLCP */			
++			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
++			if (disto_on)
++				fprintf(stream, " disto");
++			fprintf(stream,"\n");
++
++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++				for (layno = 0; layno < cstr_info->numlayers; layno++) {
++					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++						int prec_max; 
++						if (resno > cstr_info->numdecompos[compno])
++							break;
++						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++						for (precno = 0; precno < prec_max; precno++) {
++							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d",
++								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
++							if (disto_on)
++								fprintf(stream, " %8e", disto);
++							fprintf(stream, "\n");
++							total_disto += disto;
++							pack_nb++;
++						}
++					}
++				}
++			}
++		} /* RLCP */
++
++		else if (cstr_info->prog == RPCL) {	/* RPCL */
++
++			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos"); 
++			if (disto_on)
++				fprintf(stream, " disto");
++			fprintf(stream,"\n");
++
++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++				for (precno = 0; precno < numprec; precno++) {								
++					/* I suppose components have same XRsiz, YRsiz */
++					int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++					int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++					int x1 = x0 + cstr_info->tile_x;
++					int y1 = y0 + cstr_info->tile_y;
++					for (compno = 0; compno < cstr_info->numcomps; compno++) {					
++						int pcnx = cstr_info->tile[tileno].pw[resno];
++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++						int precno_y = (int) floor( (float)precno/(float)pcnx );
++						if (resno > cstr_info->numdecompos[compno])
++							break;
++						for(y = y0; y < y1; y++) {							
++							if (precno_y*pcy == y ) {
++								for (x = x0; x < x1; x++) {									
++									if (precno_x*pcx == x ) {
++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d",
++												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
++											if (disto_on)
++												fprintf(stream, " %8e", disto);
++											fprintf(stream, "\n");
++											total_disto += disto;
++											pack_nb++; 
++										}
++									}
++								}/* x = x0..x1 */
++							} 
++						}  /* y = y0..y1 */
++					} /* precno */
++				} /* compno */
++			} /* resno */
++		} /* RPCL */
++
++		else if (cstr_info->prog == PCRL) {	/* PCRL */
++			/* I suppose components have same XRsiz, YRsiz */
++			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++			int x1 = x0 + cstr_info->tile_x;
++			int y1 = y0 + cstr_info->tile_y;
++
++			// Count the maximum number of precincts 
++			int max_numprec = 0;
++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++				if (numprec > max_numprec)
++					max_numprec = numprec;
++			}
++
++			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos"); 
++			if (disto_on)
++				fprintf(stream, " disto");
++			fprintf(stream,"\n");
++
++			for (precno = 0; precno < max_numprec; precno++) {
++				for (compno = 0; compno < cstr_info->numcomps; compno++) {
++					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++						int pcnx = cstr_info->tile[tileno].pw[resno];
++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++						int precno_y = (int) floor( (float)precno/(float)pcnx );
++						if (precno >= numprec)
++							continue;
++						for(y = y0; y < y1; y++) {							
++							if (precno_y*pcy == y ) {
++								for (x = x0; x < x1; x++) {									
++									if (precno_x*pcx == x ) {
++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
++												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
++											if (disto_on)
++												fprintf(stream, " %8e", disto);
++											fprintf(stream, "\n");
++											total_disto += disto;
++											pack_nb++; 
++										}
++									}
++								}/* x = x0..x1 */
++							} 
++						}  /* y = y0..y1 */
++					} /* resno */
++				} /* compno */
++			} /* precno */
++		} /* PCRL */
++
++		else {	/* CPRL */
++			// Count the maximum number of precincts 
++			int max_numprec = 0;
++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++				if (numprec > max_numprec)
++					max_numprec = numprec;
++			}
++
++			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos"); 
++			if (disto_on)
++				fprintf(stream, " disto");
++			fprintf(stream,"\n");
++
++			for (compno = 0; compno < cstr_info->numcomps; compno++) {
++				/* I suppose components have same XRsiz, YRsiz */
++				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++				int x1 = x0 + cstr_info->tile_x;
++				int y1 = y0 + cstr_info->tile_y;
++
++				for (precno = 0; precno < max_numprec; precno++) {
++					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++						int pcnx = cstr_info->tile[tileno].pw[resno];
++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++						int precno_y = (int) floor( (float)precno/(float)pcnx );
++						if (precno >= numprec)
++							continue;
++
++						for(y = y0; y < y1; y++) {
++							if (precno_y*pcy == y ) {
++								for (x = x0; x < x1; x++) {
++									if (precno_x*pcx == x ) {
++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
++												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
++											if (disto_on)
++												fprintf(stream, " %8e", disto);
++											fprintf(stream, "\n");
++											total_disto += disto;
++											pack_nb++; 
++										}
++									}
++								}/* x = x0..x1 */
++							}
++						} /* y = y0..y1 */
++					} /* resno */
++				} /* precno */
++			} /* compno */
++		} /* CPRL */   
++	} /* tileno */
++	
++	if (disto_on) {
++		fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */	
++		fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
++	}
++/* UniPG>> */
++	/* print the markers' list */
++	if (cstr_info->marknum) {
++		fprintf(stream, "\nMARKER LIST\n");
++		fprintf(stream, "%d\n", cstr_info->marknum);
++		fprintf(stream, "type\tstart_pos    length\n");
++		for (x = 0; x < cstr_info->marknum; x++)
++			fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
++	}
++/* <<UniPG */
++	fclose(stream);
++
++	fprintf(stderr,"Generated index file %s\n", index);
++
++	return 0;
++}
+diff -urN -x.svn ../trunk.orig/codec/index.h ./codec/index.h
+--- ../trunk.orig/codec/index.h	1970-01-01 01:00:00.000000000 +0100
++++ ./codec/index.h	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,49 @@
++/*
++ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
++ * Copyright (c) 2002-2007, Professor Benoit Macq
++ * Copyright (c) 2003-2007, Francois-Olivier Devaux
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++
++#ifndef __J2K_INDEX_H
++#define __J2K_INDEX_H
++
++#ifdef __cplusplus
++extern "C" {
++#endif
++
++/**
++Write a structured index to a file
++@param cstr_info Codestream information 
++@param index Index filename
++@return Returns 0 if successful, returns 1 otherwise
++*/
++int write_index_file(opj_codestream_info_t *cstr_info, char *index);
++
++#ifdef __cplusplus
++}
++#endif
++
++#endif /* __J2K_INDEX_H */
++
+diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.c ./codec/j2k_to_image.c
+--- ../trunk.orig/codec/j2k_to_image.c	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/j2k_to_image.c	2007-11-27 22:39:51.000000000 +0000
+@@ -38,6 +38,7 @@
+ #include "compat/getopt.h"
+ #include "convert.h"
+ #include "dirent.h"
++#include "index.h"
+ 
+ #ifndef WIN32
+ #define stricmp strcasecmp
+@@ -229,250 +230,6 @@
+ 	return 0;
+ }
+ 
+-/* ------------------------------------------------------------------------------------ */
+-
+-/**
+-Create an index and write it to a file
+-@param cstr_info Codestream information 
+-@param index Index filename
+-@return Returns 0 if successful, returns 1 otherwise
+-*/
+-int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+-	FILE *stream = NULL;
+-	int tilepartno;
+-
+-	if (!cstr_info)		
+-		return 1;
+-
+-	stream = fopen(index, "w");
+-	if (!stream) {
+-		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+-		return 1;
+-	}
+-	
+-	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+-	fprintf(stream, "%d\n", cstr_info->prog);
+-	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+-	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+-	fprintf(stream, "%d\n", cstr_info->numcomps);
+-	fprintf(stream, "%d\n", cstr_info->numlayers);
+-	fprintf(stream, "%d\n", cstr_info->numdecompos);
+-	
+-	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+-		fprintf(stream, "[%d,%d] ", 
+-			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0*/
+-	}
+-	fprintf(stream, "\n");
+-	fprintf(stream, "%d\n", cstr_info->main_head_start);
+-	fprintf(stream, "%d\n", cstr_info->main_head_end);
+-	fprintf(stream, "%d\n", cstr_info->codestream_size);
+-	
+-	fprintf(stream, "\nINFO ON TILES\n");
+-	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts\n");
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		fprintf(stream, "%4d %9d %9d %9d %9d\n",
+-			cstr_info->tile[tileno].tileno,
+-			cstr_info->tile[tileno].start_pos,
+-			cstr_info->tile[tileno].end_header,
+-			cstr_info->tile[tileno].end_pos,
+-			cstr_info->tile[tileno].num_tps);
+-	}
+-		
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		int start_pos, end_ph_pos, end_pos;
+-		int max_numdecompos = 0;
+-		pack_nb = 0;	
+-
+-		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-			if (max_numdecompos < cstr_info->numdecompos[compno])
+-				max_numdecompos = cstr_info->numdecompos[compno];
+-		}
+-
+-		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+-		fprintf(stream, "part_nb tileno  num_packs  start_pos end_tph_pos   end_pos\n");
+-		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+-			fprintf(stream, "%4d %9d  %9d  %9d %11d %9d\n",
+-				tilepartno, tileno,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+-				);
+-		if (cstr_info->prog == LRCP) {	/* LRCP */
+-			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos\n");
+-
+-			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max;
+-						if (resno > cstr_info->numdecompos[compno])
+-							break;
+-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d\n",
+-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* LRCP */
+-		else if (cstr_info->prog == RLCP) {	/* RLCP */
+-
+-			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
+-
+-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max;
+-						if (resno > cstr_info->numdecompos[compno])
+-							break;
+-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d\n",
+-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* RLCP */
+-		else if (cstr_info->prog == RPCL) {	/* RPCL */
+-
+-			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-					int prec_max;
+-					if (resno > cstr_info->numdecompos[compno])
+-							break;
+-					prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* compno */
+-			} /* resno */
+-		} /* RPCL */
+-		else if (cstr_info->prog == PCRL) {	/* PCRL */
+-			/* I suppose components have same XRsiz, YRsiz */
+-			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-			int x1 = x0 + cstr_info->tile_x;
+-			int y1 = y0 + cstr_info->tile_y;
+-
+-			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* PCRL */
+-		else {	/* CPRL */
+-
+-			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				
+-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							}
+-						} /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* CPRL */   
+-	} /* tileno */
+-	
+-	fclose(stream);
+-
+-	fprintf(stderr,"Generated index file %s\n", index);
+-
+-	return 0;
+-}
+-
+-/* ------------------------------------------------------------------------------------ */
+-
+ /* -------------------------------------------------------------------------- */
+ int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol, char *indexfilename) {
+ 	/* parse the command line */
+diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.dsp ./codec/j2k_to_image.dsp
+--- ../trunk.orig/codec/j2k_to_image.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/j2k_to_image.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -103,6 +103,14 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=.\index.c
++# End Source File
++# Begin Source File
++
++SOURCE=.\index.h
++# End Source File
++# Begin Source File
++
+ SOURCE=.\j2k_to_image.c
+ # End Source File
+ # End Target
+diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.vcproj ./codec/j2k_to_image.vcproj
+--- ../trunk.orig/codec/j2k_to_image.vcproj	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/j2k_to_image.vcproj	2007-11-27 22:39:51.000000000 +0000
+@@ -256,6 +256,14 @@
+ 			>
+ 		</File>
+ 		<File
++			RelativePath=".\index.c"
++			>
++		</File>
++		<File
++			RelativePath=".\index.h"
++			>
++		</File>
++		<File
+ 			RelativePath="j2k_to_image.c"
+ 			>
+ 			<FileConfiguration
+diff -urN -x.svn ../trunk.orig/codec/Makefile ./codec/Makefile
+--- ../trunk.orig/codec/Makefile	2007-09-28 11:36:31.000000000 +0100
++++ ./codec/Makefile	2007-11-27 22:39:51.000000000 +0000
+@@ -5,10 +5,10 @@
+ all: j2k_to_image image_to_j2k
+ 
+ j2k_to_image: j2k_to_image.c ../libopenjpeg.a
+-	gcc $(CFLAGS) compat/getopt.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
++	gcc $(CFLAGS) compat/getopt.c index.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+ 
+ image_to_j2k: image_to_j2k.c ../libopenjpeg.a
+-	gcc $(CFLAGS) compat/getopt.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
++	gcc $(CFLAGS) compat/getopt.c index.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+ 
+ clean:
+ 	rm -f j2k_to_image image_to_j2k
+diff -urN -x.svn ../trunk.orig/diff.483 ./diff.483
+--- ../trunk.orig/diff.483	1970-01-01 01:00:00.000000000 +0100
++++ ./diff.483	2007-12-01 19:14:35.000000000 +0000
+@@ -0,0 +1,1856 @@
++diff -urN -x.svn ../trunk.orig/ChangeLog ./ChangeLog
++--- ../trunk.orig/ChangeLog	2007-09-28 11:36:31.000000000 +0100
+++++ ./ChangeLog	2007-12-01 18:40:47.000000000 +0000
++@@ -5,6 +5,73 @@
++ ! : changed
++ + : added
++ 
+++November 29, 2007
+++! [GB] Added index.h and index.c in VC6 projects; wrapped index.h in the C++ preprocessor; modified OPJViewer project and some files.
+++
+++November 14, 2007
++++ [FOD] Created the file index.c in the codec directory. This file handles the creation of index files, 
+++		at encoding and decoding. 
+++* [FOD] Fixed bugs during the creation of the index (PCRL progression order)
+++* [FOD] Fixed the maximum number of resolutions a user can discard while decoding.
+++		Added an error state in J2K_STATE (j2k.c)
+++
+++November 14, 2007
+++! [FOD] - First Patch by Callum Lerwick. Instead of reinventing realloc, j2k_read_sod now just uses opj_realloc in j2k.c
+++		- Second Patch by Callum Lerwick. This patch rearranges the largest memory allocations so they're allocated as 
+++		late as possible, and freed as soon as possible. This cuts memory usage by about half on two large test images.
+++		- Third Patch by Callum Lerwick. The opj_tcd_cblk array is one of the largest allocations, because it
+++		contains a bunch of static buffers. This also makes it a major source of cache thrashing. This patch allocates 
+++		the buffers from the heap, and dynamically sizes them in the decoder. I have not yet managed to dynamically size 
+++		them in the encoder, getting the decoder to do it was tricky enough... I also split opj_tcd_cblk_t into separate 
+++		encode and decode versions. A lot of fields were not used by both, so this cuts its size even further.
+++
+++* [FOD] Avoided ABI breakage
+++
+++November 13, 2007
+++! [FOD] Patch by Dzonatas and Callum Lerwick.
+++        Fp/vectorization patch which basically converts most of the irreversible decode codepath to floating point,
+++        eliminating a few rounds of int/fp conversion, resulting in a vast performance improvement,
+++	and an increase in accuracy.
+++
+++November 8, 2007
+++! [FOD] In t1.c, small change to avoid calling twice t1_getwmsedec()
+++        Patches from Callum Lewick:
+++		- Basic gcc optimization flags in cmake and makefile match.
+++		- Fixed some spelling errors in dwt.c.
+++
+++November 5, 2007
+++*+ [GB] Fixed a bug which prevented JPWL from working on multi-tiled images; added some more fields in the interface info structures 
+++(keep a list of markers, save start packet number for each tile)
+++
+++October 23, 2007
+++* [GB] Improved success for the linux build; OPJViewer shows all the COM contents
+++ 
+++October 18, 2007
+++* [FOD] Changed the ROI parameter in the image_to_j2k codec to make it correspond to the documentation (i.e. -ROI c=0,U=25)
+++* [FOD] Patch from Callum Lewick. Memset patch. 
+++		The main idea of the patch is that currently opj_malloc clears all allocations, which unnecessarily
+++		dirties up the cache and eats bandwidth. This patch makes it no longer do so, and I've painstakingly determined which allocations actually need
+++		to be cleared and changed them to use opj_calloc() instead. I previously tried to just get rid of the opj_*alloc wrappers but that
+++		idea was nixed, so this time I'm trying it with macros. I also put in a gcc pragma that helps enforce their use. Which got messy.  :)  It caught a
+++		few places they weren't used but it also revealed that the mj2 tools are not very cleanly separated from the library. It includes all the
+++		internal headers, but it wasn't using the malloc wrappers. I figured the binaries should be "external" and have minimal knowledge of the
+++		internals of the library. I patched them to not include opj_includes.h, and include only the internal headers they actually need. However,
+++		they're using the opj_clock() function, which is in with the malloc wrappers. So I decided to move the malloc wrappers to their own header. 
+++		But mj2.c seems to want to be "internal", so I patched it to use the wrappers. Note that this patch changes the semantics of opj_malloc, it no longer
+++		clears the memory it allocates. If you need it to be cleared, you must use opj_calloc instead, or memset it yourself. It is also somewhat
+++		invasive, please test it extensively. I've been pounding on it all summer with my test suite, Second Life, and valgrind, and it checks out clean.
+++
+++October 12, 2007
+++* [FOD] Changed the way the image structure is allocated when the decoding parameters include some resolutions to discard. 
+++        This should have a significant impact for the decoding of huge images when some resolutions are discarder (-r parameter)
+++        Warning: The output image size is now reduced when discarding resolutions !
+++
+++October 10, 2007
+++* [FOD] Patch from Callum Lewick. Clean up of j2klib.h for the aligned malloc stuff. 
+++        It makes it work right with mingw, as _mm_malloc() isn't a macro, attempts to pave the way to using cmake 
+++        to check for this stuff and combines a patch from Dana Fagerstrom at Sun that makes it use memalign() on Solaris
+++        convert.c: Changed some error comments for TIFF images
+++
++ September 27, 2007
++ * [FOD] Patch from Callum Lewick. Fixed dwt.c where an alignment in buffer was problematic under x86_64.
++ 
++@@ -54,10 +121,12 @@
++ * [Mathieu Malaterre] Fix unitialized read in img_fol (we may need a smarter initialize than memset)
++ 
++ September 4, 2007
++-+ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. Changed also the write_index function in the codec, to reflect the presence of this new information.
++++ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. 
+++		Changed also the write_index function in the codec, to reflect the presence of this new information.
++ 
++ September 3, 2007
++-+ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: no real security function at this stage. Deprecated USE_JPSEC will be removed next
++++ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: 
+++		no real security function at this stage. Deprecated USE_JPSEC will be removed next
++ 
++ August 31, 2007
++ * [GB] Fixed save capabilities in OPJViewer due to recent code upgrade
++@@ -109,12 +178,15 @@
++ + [FOD] Added support for RAW images. This module has been developped by the University of Perugia team. Thanks to them ! [image_to_j2k.c j2k_to_image.c convert.c convert.h]
++ 
++ July 13, 2007
++-! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
+++! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, 
+++		leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
++ ! [FOD] Modified old comments about the ability to decode mega-images and comments about the disk size necessary to do this. [image_to_j2k.c and frames_to_mj2.c]
++ * [FOD] Added 2000 bytes for the memory allocation in cio.c for the minimum size of headers (useful in case of very small images) [cio.c]
++ 
++ July 12, 2007
++-* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
+++* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, 
+++		even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension 
+++		is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
++ 
++ July 8, 2007
++ * [ANTONIN] fixed the size of the memory allocation in cio.c (confusion between bits and bytes)
++@@ -149,13 +221,16 @@
++ * [FOD] Fixed the parameters used for cinema compression (9-7 transform used instead of 5-3). Modified "image_to_j2k.c"
++ 
++ May 24, 2007
++-* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker the value of numlayers and numresolution.
+++* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker 
+++		the value of numlayers and numresolution.
++ 
++ May 23, 2007
++ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This makes the t1 data arrays dynamic, which greatly reduces cache thrashing. Also, some minor cleanup to prevent unnecessary casts"
++ 
++ May 22, 2007
++-! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
+++! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, 
+++		so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix 
+++		increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
++ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This changes the flag code in t1 to use a flag_t type, which can then be changed to reduce RAM usage. It is now typedef to a short."
++ ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This patch makes the t1 LUTs static. I actually intend this as a prelude to possibly eliminating some or all of the LUTs entirely."
++ 
++@@ -204,14 +279,17 @@
++ * [Parvatha] Equation to check multiple tile precincts. Modification pi.c
++ ! [Parvatha] array size generation of pi->include in pi_initialise_encode().Modification in pi.c
++ * [Parvatha] modification in pi_create_encode for tile part generation.Modification in pi.c
++-+ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
++++ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. 
+++			 This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
++ 
++ March 28, 2007
++ * [FOD] Fixed an historical bug in t1.c that leaded to the inclusion of useless 0xFF in the codestream. Thanks to Sylvain, Pascal and Parvatha !
++ 
++ March 27, 2007
++-+ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
++-* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
++++ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; 
+++		can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
+++* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, 
+++		have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
++ + [GB] Added linking to TIFF library in the JPWL VC6 workspaces
++ 
++ March 23, 2007
++@@ -257,7 +335,8 @@
++ ----------------------
++ 
++ February 23, 2007
++-* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
+++* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. 
+++		As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
++ + [GB] Linux makefile for the JPWL module; newlines at end of JPWL files
++ 
++ February 22, 2007
++diff -urN -x.svn ../trunk.orig/CMakeLists.txt ./CMakeLists.txt
++--- ../trunk.orig/CMakeLists.txt	2007-09-28 11:36:31.000000000 +0100
+++++ ./CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
++@@ -7,7 +7,6 @@
++ # For this purpose you can define a CMake var: OPENJPEG_NAMESPACE to whatever you like
++ # e.g.:
++ # SET(OPENJPEG_NAMESPACE "GDCMOPENJPEG")
++-PROJECT(OPENJPEG C)
++ CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
++ 
++ IF(NOT OPENJPEG_NAMESPACE)
++@@ -17,7 +16,7 @@
++ # In all cases:
++ STRING(TOLOWER ${OPENJPEG_NAMESPACE} OPENJPEG_LIBRARY_NAME)
++ 
++-PROJECT(${JPEG_NAMESPACE} C)
+++PROJECT(${OPENJPEG_NAMESPACE} C)
++ 
++ # Do full dependency headers.
++ INCLUDE_REGULAR_EXPRESSION("^.*$")
++@@ -116,3 +115,12 @@
++   $ENV{JPEG2000_CONFORMANCE_DATA_ROOT}
++ )
++ 
+++#-----------------------------------------------------------------------------
+++# Compiler specific flags:
+++IF(CMAKE_COMPILER_IS_GNUCC)
+++  # For all builds, make sure openjpeg is std99 compliant:
+++  SET(CMAKE_C_FLAGS "-Wall -std=c99 ${CMAKE_C_FLAGS}")
+++  # Do not use ffast-math for all build, it would produce incorrect results, only set for release:
+++  SET(CMAKE_C_FLAGS_RELEASE "-ffast-math ${CMAKE_C_FLAGS_RELEASE}")
+++ENDIF(CMAKE_COMPILER_IS_GNUCC)
+++
++diff -urN -x.svn ../trunk.orig/codec/CMakeLists.txt ./codec/CMakeLists.txt
++--- ../trunk.orig/codec/CMakeLists.txt	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
++@@ -3,7 +3,9 @@
++ # First thing define the common source:
++ SET(common_SRCS
++   convert.c
++-  )
+++  index.c
+++)
+++
++ # Then check if getopt is present:
++ INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
++ SET(DONT_HAVE_GETOPT 1)
++@@ -24,7 +26,6 @@
++   )
++ ENDIF(DONT_HAVE_GETOPT)
++ 
++-
++ # Headers file are located here:
++ INCLUDE_DIRECTORIES(
++   ${OPENJPEG_SOURCE_DIR}/libopenjpeg
++diff -urN -x.svn ../trunk.orig/codec/convert.c ./codec/convert.c
++--- ../trunk.orig/codec/convert.c	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/convert.c	2007-11-27 22:39:51.000000000 +0000
++@@ -310,15 +310,15 @@
++    }
++ 	}
++ 
++-	width  = int_ceildiv(image->x1-image->x0, image->comps[0].dx);
++-	height = int_ceildiv(image->y1-image->y0, image->comps[0].dy);
+++	width = image->comps[0].w;
+++	height = image->comps[0].h; 
++ 
++ 	// Mono with alpha, or RGB with alpha.
++ 	write_alpha = (image->numcomps==2) || (image->numcomps==4);   
++ 
++ 	// Write TGA header 
++ 	bpp = write_alpha ? 32 : 24;
++-	if (!tga_writeheader(fdest, bpp, width, height, true))
+++	if (!tga_writeheader(fdest, bpp, width , height, true))
++ 		return 1;
++ 
++ 	alpha_channel = image->numcomps-1; 
++@@ -764,7 +764,7 @@
++ }
++ 
++ int imagetobmp(opj_image_t * image, const char *outfile) {
++-	int w, wr, h, hr;
+++	int w, h;
++ 	int i, pad;
++ 	FILE *fdest = NULL;
++ 	int adjustR, adjustG, adjustB;
++@@ -786,42 +786,39 @@
++ 			return 1;
++ 		}
++ 	    
++-		w = image->comps[0].w;
++-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
++-	    
+++		w = image->comps[0].w;	    
++ 		h = image->comps[0].h;
++-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
++ 	    
++ 		fprintf(fdest, "BM");
++ 	    
++ 		/* FILE HEADER */
++ 		/* ------------- */
++ 		fprintf(fdest, "%c%c%c%c",
++-			(unsigned char) (hr * wr * 3 + 3 * hr * (wr % 2) + 54) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 8) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 16) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 24) & 0xff);
+++			(unsigned char) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 8) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 16) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
++ 	    
++ 		/* INFO HEADER   */
++ 		/* ------------- */
++ 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
++-			(unsigned char) ((wr) >> 8) & 0xff,
++-			(unsigned char) ((wr) >> 16) & 0xff,
++-			(unsigned char) ((wr) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
++-			(unsigned char) ((hr) >> 8) & 0xff,
++-			(unsigned char) ((hr) >> 16) & 0xff,
++-			(unsigned char) ((hr) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+++			(unsigned char) ((w) >> 8) & 0xff,
+++			(unsigned char) ((w) >> 16) & 0xff,
+++			(unsigned char) ((w) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+++			(unsigned char) ((h) >> 8) & 0xff,
+++			(unsigned char) ((h) >> 16) & 0xff,
+++			(unsigned char) ((h) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
++ 		fprintf(fdest, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * hr * wr + 3 * hr * (wr % 2)) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 8) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 16) & 0xff,
++-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * h * w + 3 * h * (w % 2)) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,
+++			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
++@@ -846,24 +843,24 @@
++ 		else 
++ 			adjustB = 0;
++ 
++-		for (i = 0; i < wr * hr; i++) {
+++		for (i = 0; i < w * h; i++) {
++ 			unsigned char rc, gc, bc;
++ 			int r, g, b;
++ 							
++-			r = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+++			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
++ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
++ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
++-			g = image->comps[1].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+++			g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
++ 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
++ 			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
++-			b = image->comps[2].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+++			b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
++ 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
++ 			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
++ 
++ 			fprintf(fdest, "%c%c%c", bc, gc, rc);
++ 			
++-			if ((i + 1) % wr == 0) {
++-				for (pad = (3 * wr) % 4 ? 4 - (3 * wr) % 4 : 0; pad > 0; pad--)	/* ADD */
+++			if ((i + 1) % w == 0) {
+++				for (pad = (3 * w) % 4 ? 4 - (3 * w) % 4 : 0; pad > 0; pad--)	/* ADD */
++ 					fprintf(fdest, "%c", 0);
++ 			}
++ 		}
++@@ -875,20 +872,17 @@
++ 		<<-- <<-- <<-- <<-- */
++ 
++ 		fdest = fopen(outfile, "wb");
++-		w = image->comps[0].w;
++-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
++-	    
+++		w = image->comps[0].w;	    
++ 		h = image->comps[0].h;
++-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
++ 	    
++ 		fprintf(fdest, "BM");
++ 	    
++ 		/* FILE HEADER */
++ 		/* ------------- */
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + 54 + 1024 + hr * (wr % 2)) & 0xff,
++-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 8) & 0xff,
++-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 16) & 0xff,
++-			(unsigned char) ((hr * wr + 54 + 1024 + wr * (wr % 2)) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,
+++			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,
+++			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,
+++			(unsigned char) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, 
++ 			((54 + 1024) >> 16) & 0xff,
++@@ -897,21 +891,21 @@
++ 		/* INFO HEADER */
++ 		/* ------------- */
++ 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
++-			(unsigned char) ((wr) >> 8) & 0xff,
++-			(unsigned char) ((wr) >> 16) & 0xff,
++-			(unsigned char) ((wr) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
++-			(unsigned char) ((hr) >> 8) & 0xff,
++-			(unsigned char) ((hr) >> 16) & 0xff,
++-			(unsigned char) ((hr) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+++			(unsigned char) ((w) >> 8) & 0xff,
+++			(unsigned char) ((w) >> 16) & 0xff,
+++			(unsigned char) ((w) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+++			(unsigned char) ((h) >> 8) & 0xff,
+++			(unsigned char) ((h) >> 16) & 0xff,
+++			(unsigned char) ((h) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
++ 		fprintf(fdest, "%c%c", (8) & 0xff, ((8) >> 8) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
++-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + hr * (wr % 2)) & 0xff,
++-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 8) &	0xff,
++-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 16) &	0xff,
++-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 24) & 0xff);
+++		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + h * (w % 2)) & 0xff,
+++			(unsigned char) ((h * w + h * (w % 2)) >> 8) &	0xff,
+++			(unsigned char) ((h * w + h * (w % 2)) >> 16) &	0xff,
+++			(unsigned char) ((h * w + h * (w % 2)) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
++ 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
++@@ -926,18 +920,18 @@
++ 			fprintf(fdest, "%c%c%c%c", i, i, i, 0);
++ 		}
++ 
++-		for (i = 0; i < wr * hr; i++) {
+++		for (i = 0; i < w * h; i++) {
++ 			unsigned char rc;
++ 			int r;
++ 			
++-			r = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+++			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
++ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
++ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
++ 			
++ 			fprintf(fdest, "%c", rc);
++ 
++-			if ((i + 1) % wr == 0) {
++-				for (pad = wr % 4 ? 4 - wr % 4 : 0; pad > 0; pad--)	/* ADD */
+++			if ((i + 1) % w == 0) {
+++				for (pad = w % 4 ? 4 - w % 4 : 0; pad > 0; pad--)	/* ADD */
++ 					fprintf(fdest, "%c", 0);
++ 			}
++ 		}
++@@ -1098,7 +1092,7 @@
++ }
++ 
++ int imagetopgx(opj_image_t * image, const char *outfile) {
++-	int w, wr, h, hr;
+++	int w, h;
++ 	int i, j, compno;
++ 	FILE *fdest = NULL;
++ 
++@@ -1135,12 +1129,9 @@
++       }
++ 
++ 		w = image->comps[compno].w;
++-		wr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
++-	    
++ 		h = image->comps[compno].h;
++-		hr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
++ 	    
++-		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, wr, hr);
+++		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, w, h);
++ 		if (comp->prec <= 8) {
++ 			nbytes = 1;
++ 		} else if (comp->prec <= 16) {
++@@ -1148,8 +1139,8 @@
++ 		} else {
++ 			nbytes = 4;
++ 		}
++-		for (i = 0; i < wr * hr; i++) {
++-			int v = image->comps[compno].data[i / wr * w + i % wr];
+++		for (i = 0; i < w * h; i++) {
+++			int v = image->comps[compno].data[i];
++ 			for (j = nbytes - 1; j >= 0; j--) {
++ 				char byte = (char) (v >> (j * 8));
++ 				fwrite(&byte, 1, 1, fdest);
++@@ -1267,7 +1258,7 @@
++ }
++ 
++ int imagetopnm(opj_image_t * image, const char *outfile) {
++-	int w, wr, wrr, h, hr, hrr, max;
+++	int w, wr, h, hr, max;
++ 	int i, compno;
++ 	int adjustR, adjustG, adjustB, adjustX;
++ 	FILE *fdest = NULL;
++@@ -1297,18 +1288,16 @@
++ 
++ 		w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
++ 		wr = image->comps[0].w;
++-		wrr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
++         
++ 		h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
++ 		hr = image->comps[0].h;
++-		hrr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
++ 	    
++ 		max = image->comps[0].prec > 8 ? 255 : (1 << image->comps[0].prec) - 1;
++ 	    
++ 		image->comps[0].x0 = int_ceildivpow2(image->comps[0].x0 - int_ceildiv(image->x0, image->comps[0].dx), image->comps[0].factor);
++ 		image->comps[0].y0 = int_ceildivpow2(image->comps[0].y0 -	int_ceildiv(image->y0, image->comps[0].dy), image->comps[0].factor);
++ 
++-		fprintf(fdest, "P6\n%d %d\n%d\n", wrr, hrr, max);
+++		fprintf(fdest, "P6\n%d %d\n%d\n", wr, hr, max);
++ 
++ 		if (image->comps[0].prec > 8) {
++ 			adjustR = image->comps[0].prec - 8;
++@@ -1330,18 +1319,18 @@
++ 			adjustB = 0;
++ 
++ 
++-		for (i = 0; i < wrr * hrr; i++) {
+++		for (i = 0; i < wr * hr; i++) {
++ 			int r, g, b;
++ 			unsigned char rc,gc,bc;
++-			r = image->comps[0].data[i / wrr * wr + i % wrr];
+++			r = image->comps[0].data[i];
++ 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
++ 			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
++ 
++-			g = image->comps[1].data[i / wrr * wr + i % wrr];
+++			g = image->comps[1].data[i];
++ 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
++ 			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
++ 			
++-			b = image->comps[2].data[i / wrr * wr + i % wrr];
+++			b = image->comps[2].data[i];
++ 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
++ 			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
++ 			
++@@ -1371,18 +1360,16 @@
++             
++ 			w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
++ 			wr = image->comps[compno].w;
++-			wrr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
++ 			
++ 			h = int_ceildiv(image->y1 - image->y0, image->comps[compno].dy);
++ 			hr = image->comps[compno].h;
++-			hrr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
++ 			
++ 			max = image->comps[compno].prec > 8 ? 255 : (1 << image->comps[compno].prec) - 1;
++ 			
++ 			image->comps[compno].x0 = int_ceildivpow2(image->comps[compno].x0 - int_ceildiv(image->x0, image->comps[compno].dx), image->comps[compno].factor);
++ 			image->comps[compno].y0 = int_ceildivpow2(image->comps[compno].y0 - int_ceildiv(image->y0, image->comps[compno].dy), image->comps[compno].factor);
++ 			
++-			fprintf(fdest, "P5\n%d %d\n%d\n", wrr, hrr, max);
+++			fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
++ 			
++ 			if (image->comps[compno].prec > 8) {
++ 				adjustX = image->comps[0].prec - 8;
++@@ -1391,10 +1378,10 @@
++ 			else 
++ 				adjustX = 0;
++ 			
++-			for (i = 0; i < wrr * hrr; i++) {
+++			for (i = 0; i < wr * hr; i++) {
++ 				int l;
++ 				unsigned char lc;
++-				l = image->comps[compno].data[i / wrr * wr + i % wrr];
+++				l = image->comps[compno].data[i];
++ 				l += (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);
++ 				lc = (unsigned char) ((l >> adjustX)+((l >> (adjustX-1))%2));
++ 				fprintf(fdest, "%c", lc);
++@@ -1423,7 +1410,7 @@
++ }tiff_infoheader_t;
++ 
++ int imagetotif(opj_image_t * image, const char *outfile) {
++-	int width, height, imgsize ;
+++	int width, height, imgsize;
++ 	int bps,index,adjust = 0;
++ 	int last_i=0;
++ 	TIFF *tif;
++@@ -1450,7 +1437,7 @@
++ 
++ 			width	= image->comps[0].w;
++ 			height	= image->comps[0].h;
++-			imgsize = image->comps[0].w * image->comps[0].h ;
+++			imgsize = width * height ;
++ 			bps		= image->comps[0].prec;
++ 			/* Set tags */
++ 			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
++@@ -1463,10 +1450,9 @@
++ 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
++ 
++ 			/* Get a buffer for the data */
++-			buf = _TIFFmalloc(TIFFStripSize(tif));
++-			index=0;
++-			strip_size=0;
++ 			strip_size=TIFFStripSize(tif);
+++			buf = _TIFFmalloc(strip_size);
+++			index=0;		
++ 			adjust = image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0;
++ 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
++ 				unsigned char *dat8;
++@@ -1647,7 +1633,7 @@
++ 
++ 			width	= image->comps[0].w;
++ 			height	= image->comps[0].h;
++-			imgsize = image->comps[0].w * image->comps[0].h ;
+++			imgsize = width * height;
++ 			bps		= image->comps[0].prec;
++ 
++ 			/* Set tags */
++@@ -1661,10 +1647,9 @@
++ 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
++ 
++ 			/* Get a buffer for the data */
++-			buf = _TIFFmalloc(TIFFStripSize(tif));
++-			index = 0;
++-			strip_size = 0;
++ 			strip_size = TIFFStripSize(tif);
+++			buf = _TIFFmalloc(strip_size);
+++			index = 0;			
++ 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
++ 				unsigned char *dat8;
++ 				int i;
++@@ -1714,7 +1699,7 @@
++ 							break; 
++ 					}
++ 				}else{
++-					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+++					fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
++ 					fprintf(stderr,"Aborting\n");
++ 					return 1;
++ 				}
++@@ -1723,7 +1708,7 @@
++ 			_TIFFfree(buf);
++ 			TIFFClose(tif);
++ 		}else{
++-			fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+++			fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
++ 			fprintf(stderr,"Aborting\n");
++ 			return 1;
++ 		}
++@@ -1858,7 +1843,7 @@
++ 				}
++ 			}
++ 			else{
++-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+++				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
++ 				fprintf(stderr,"Aborting\n");
++ 				return NULL;
++ 			}
++@@ -1936,7 +1921,7 @@
++ 				}
++ 			}
++ 			else{
++-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+++				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
++ 				fprintf(stderr,"Aborting\n");
++ 				return NULL;
++ 			}
++@@ -1945,7 +1930,7 @@
++ 		_TIFFfree(buf);
++ 		TIFFClose(tif);
++ 	}else{
++-		fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+++		fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
++ 		fprintf(stderr,"Aborting\n");
++ 		return NULL;
++ 	}
++@@ -2052,7 +2037,10 @@
++ int imagetoraw(opj_image_t * image, const char *outfile)
++ {
++ 	FILE *rawFile = NULL;
++-	int compno, pixelsToWrite, offset, cont;
+++	int compno;
+++	int w, h;
+++	int line, row;
+++	int *ptr;
++ 
++ 	if((image->numcomps * image->x1 * image->y1) == 0)
++ 	{
++@@ -2073,8 +2061,8 @@
++ 		fprintf(stdout,"Component %d characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
++ 			image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
++ 
++-		pixelsToWrite = image->comps[compno].w * image->comps[compno].h;
++-		offset = 0;
+++		w = image->comps[compno].w;
+++		h = image->comps[compno].h;
++ 
++ 		if(image->comps[compno].prec <= 8)
++ 		{
++@@ -2082,20 +2070,26 @@
++ 			{
++ 				signed char curr;
++ 				int mask = (1 << image->comps[compno].prec) - 1;
++-				for(cont = 0; cont < pixelsToWrite; cont++)
++-				{				
++-					curr = (signed char) (image->comps[compno].data[cont] & mask);
++-					fwrite(&curr, sizeof(signed char), 1, rawFile);
+++				ptr = image->comps[compno].data;
+++				for (line = 0; line < h; line++) {
+++					for(row = 0; row < w; row++)	{				
+++						curr = (signed char) (*ptr & mask);
+++						fwrite(&curr, sizeof(signed char), 1, rawFile);
+++						ptr++;
+++					}
++ 				}
++ 			}
++ 			else if(image->comps[compno].sgnd == 0)
++ 			{
++ 				unsigned char curr;
++ 				int mask = (1 << image->comps[compno].prec) - 1;
++-				for(cont = 0; cont < pixelsToWrite; cont++)
++-				{				
++-					curr = (unsigned char) (image->comps[compno].data[cont] & mask);
++-					fwrite(&curr, sizeof(unsigned char), 1, rawFile);
+++				ptr = image->comps[compno].data;
+++				for (line = 0; line < h; line++) {
+++					for(row = 0; row < w; row++)	{	
+++						curr = (unsigned char) (*ptr & mask);
+++						fwrite(&curr, sizeof(unsigned char), 1, rawFile);
+++						ptr++;
+++					}
++ 				}
++ 			}
++ 		}
++@@ -2105,31 +2099,37 @@
++ 			{
++ 				signed short int curr;
++ 				int mask = (1 << image->comps[compno].prec) - 1;
++-				for(cont = 0; cont < pixelsToWrite; cont++)
++-				{				
++-					curr = (signed short int) (image->comps[compno].data[cont] & mask);
++-					fwrite(&curr, sizeof(signed short int), 1, rawFile);
+++				ptr = image->comps[compno].data;
+++				for (line = 0; line < h; line++) {
+++					for(row = 0; row < w; row++)	{					
+++						curr = (signed short int) (*ptr & mask);
+++						fwrite(&curr, sizeof(signed short int), 1, rawFile);
+++						ptr++;
+++					}
++ 				}
++ 			}
++ 			else if(image->comps[compno].sgnd == 0)
++ 			{
++ 				unsigned short int curr;
++ 				int mask = (1 << image->comps[compno].prec) - 1;
++-				for(cont = 0; cont < pixelsToWrite; cont++)
++-				{				
++-					curr = (unsigned short int) (image->comps[compno].data[cont] & mask);
++-					fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
+++				ptr = image->comps[compno].data;
+++				for (line = 0; line < h; line++) {
+++					for(row = 0; row < w; row++)	{				
+++						curr = (unsigned short int) (*ptr & mask);
+++						fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
+++						ptr++;
+++					}
++ 				}
++ 			}
++ 		}
++ 		else if (image->comps[compno].prec <= 32)
++ 		{
++-
++-
+++			fprintf(stderr,"More than 16 bits per component no handled yet\n");
+++			return 1;
++ 		}
++ 		else
++ 		{
++-			fprintf(stderr,"\nError: invalid precision\n");
+++			fprintf(stderr,"Error: invalid precision: %d\n", image->comps[compno].prec);
++ 			return 1;
++ 		}
++ 	}
++diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.c ./codec/image_to_j2k.c
++--- ../trunk.orig/codec/image_to_j2k.c	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/image_to_j2k.c	2007-11-27 22:39:51.000000000 +0000
++@@ -38,6 +38,7 @@
++ #include "compat/getopt.h"
++ #include "convert.h"
++ #include "dirent.h"
+++#include "index.h"
++ 
++ #ifndef WIN32
++ #define stricmp strcasecmp
++@@ -199,7 +200,7 @@
++ 	fprintf(stdout,"\n");
++ 	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
++ 	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
++-	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
+++	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
++ 	fprintf(stdout,"\n");
++ 	fprintf(stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
++ 	fprintf(stdout,"\n");
++@@ -566,273 +567,6 @@
++ 
++ /* ------------------------------------------------------------------------------------ */
++ 
++-/**
++-Create an index and write it to a file
++-@param cstr_info Codestream information 
++-@param index Index filename
++-@return Returns 0 if successful, returns 1 otherwise
++-*/
++-int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
++-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
++-	FILE *stream = NULL;
++-	double total_disto = 0;
++-/* UniPG>> */
++-	int tilepartno;
++-
++-#ifdef USE_JPWL
++-	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
++-		return 0;
++-#endif /* USE_JPWL */
++-/* <<UniPG */
++-
++-	if (!cstr_info)		
++-		return 1;
++-
++-	stream = fopen(index, "w");
++-	if (!stream) {
++-		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
++-		return 1;
++-	}
++-	
++-	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
++-	fprintf(stream, "%d\n", cstr_info->prog);
++-	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
++-	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
++-	fprintf(stream, "%d\n", cstr_info->numcomps);
++-	fprintf(stream, "%d\n", cstr_info->numlayers);
++-	fprintf(stream, "%d\n", cstr_info->numdecompos);
++-
++-	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
++-		fprintf(stream, "[%d,%d] ", 
++-			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
++-	}
++-
++-	fprintf(stream, "\n");
++-/* UniPG>> */
++-	fprintf(stream, "%d\n", cstr_info->main_head_start);
++-/* <<UniPG */
++-	fprintf(stream, "%d\n", cstr_info->main_head_end);
++-	fprintf(stream, "%d\n", cstr_info->codestream_size);
++-	
++-	fprintf(stream, "\nINFO ON TILES\n");
++-	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts         disto     nbpix   disto/nbpix\n");
++-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++-		fprintf(stream, "%4d %9d %9d %9d %9d %9e %9d %9e\n",
++-			cstr_info->tile[tileno].tileno,
++-			cstr_info->tile[tileno].start_pos,
++-			cstr_info->tile[tileno].end_header,
++-			cstr_info->tile[tileno].end_pos,
++-			cstr_info->tile[tileno].num_tps,
++-			cstr_info->tile[tileno].distotile, cstr_info->tile[tileno].numpix,
++-			cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
++-	}
++-		
++-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++-		int start_pos, end_ph_pos, end_pos;
++-		double disto = 0;
++-		int max_numdecompos = 0;
++-		pack_nb = 0;
++-
++-		for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-			if (max_numdecompos < cstr_info->numdecompos[compno])
++-				max_numdecompos = cstr_info->numdecompos[compno];
++-		}	
++-
++-		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
++-		fprintf(stream, "part_nb tileno  num_packs  start_pos end_tph_pos   end_pos\n");
++-		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
++-			fprintf(stream, "%4d %9d  %9d  %9d %11d %9d\n",
++-				tilepartno, tileno,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
++-				);
++-		if (cstr_info->prog == LRCP) {	/* LRCP */
++-			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
++-
++-			for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-				for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-						int prec_max;
++-						if (resno > cstr_info->numdecompos[compno])
++-							break;
++-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-						for (precno = 0; precno < prec_max; precno++) {
++-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++-							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d %8e\n",
++-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
++-							total_disto += disto;
++-							pack_nb++;
++-						}
++-					}
++-				}
++-			}
++-		} /* LRCP */
++-		else if (cstr_info->prog == RLCP) {	/* RLCP */
++-
++-			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos disto\n");
++-
++-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-				for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-						int prec_max; 
++-						if (resno > cstr_info->numdecompos[compno])
++-							break;
++-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-						for (precno = 0; precno < prec_max; precno++) {
++-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d %8e\n",
++-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
++-							total_disto += disto;
++-							pack_nb++;
++-						}
++-					}
++-				}
++-			}
++-		} /* RLCP */
++-		else if (cstr_info->prog == RPCL) {	/* RPCL */
++-
++-			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos disto\n"); 
++-
++-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-				/* I suppose components have same XRsiz, YRsiz */
++-				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-				int x1 = x0 + cstr_info->tile_x;
++-				int y1 = y0 + cstr_info->tile_y;
++-				for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					if (resno > cstr_info->numdecompos[compno])
++-							break;
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {							
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {									
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d %8e\n",
++-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos, disto); 
++-											total_disto += disto;
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							} 
++-						}  /* y = y0..y1 */
++-					} /* precno */
++-				} /* compno */
++-			} /* resno */
++-		} /* RPCL */
++-		else if (cstr_info->prog == PCRL) {	/* PCRL */
++-			/* I suppose components have same XRsiz, YRsiz */
++-			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-			int x1 = x0 + cstr_info->tile_x;
++-			int y1 = y0 + cstr_info->tile_y;
++-
++-			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos disto\n"); 
++-
++-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {							
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {									
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
++-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
++-											total_disto += disto;
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							} 
++-						}  /* y = y0..y1 */
++-					} /* precno */
++-				} /* resno */
++-			} /* compno */
++-		} /* PCRL */
++-		else {	/* CPRL */
++-
++-			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos disto\n"); 
++-
++-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-				/* I suppose components have same XRsiz, YRsiz */
++-				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-				int x1 = x0 + cstr_info->tile_x;
++-				int y1 = y0 + cstr_info->tile_y;
++-				
++-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
++-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
++-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
++-											total_disto += disto;
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							}
++-						} /* y = y0..y1 */
++-					} /* precno */
++-				} /* resno */
++-			} /* compno */
++-		} /* CPRL */   
++-	} /* tileno */
++-	
++-	fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */
++-	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
++-	fclose(stream);
++-
++-	fprintf(stderr,"Generated index file %s\n", index);
++-
++-	return 0;
++-}
++-
++-/* ------------------------------------------------------------------------------------ */
++-
++ int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,
++ 													img_fol_t *img_fol, raw_cparameters_t *raw_cp, char *indexfilename) {
++ 	int i, j,totlen;
++@@ -845,6 +579,7 @@
++ 		{"EPH",NO_ARG, NULL ,'E'},
++ 		{"OutFor",REQ_ARG, NULL ,'O'},
++ 		{"POC",REQ_ARG, NULL ,'P'},
+++		{"ROI",REQ_ARG, NULL ,'R'},
++ 	};
++ 
++ 	/* parse the command line */
++@@ -1219,9 +954,9 @@
++ 
++ 			case 'R':			/* ROI */
++ 			{
++-				if (sscanf(optarg, "OI:c=%d,U=%d", &parameters->roi_compno,
+++				if (sscanf(optarg, "c=%d,U=%d", &parameters->roi_compno,
++                                            &parameters->roi_shift) != 2) {
++-					fprintf(stderr, "ROI error !! [-ROI:c='compno',U='shift']\n");
+++					fprintf(stderr, "ROI error !! [-ROI c='compno',U='shift']\n");
++ 					return 1;
++ 				}
++ 			}
++diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.dsp ./codec/image_to_j2k.dsp
++--- ../trunk.orig/codec/image_to_j2k.dsp	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/image_to_j2k.dsp	2007-12-01 18:40:47.000000000 +0000
++@@ -106,5 +106,13 @@
++ 
++ SOURCE=.\image_to_j2k.c
++ # End Source File
+++# Begin Source File
+++
+++SOURCE=.\index.c
+++# End Source File
+++# Begin Source File
+++
+++SOURCE=.\index.h
+++# End Source File
++ # End Target
++ # End Project
++Binary files ../trunk.orig/codec/image_to_j2k.sln and ./codec/image_to_j2k.sln differ
++diff -urN -x.svn ../trunk.orig/codec/image_to_j2k.vcproj ./codec/image_to_j2k.vcproj
++--- ../trunk.orig/codec/image_to_j2k.vcproj	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/image_to_j2k.vcproj	2007-11-27 22:39:51.000000000 +0000
++@@ -278,6 +278,14 @@
++ 				/>
++ 			</FileConfiguration>
++ 		</File>
+++		<File
+++			RelativePath=".\index.c"
+++			>
+++		</File>
+++		<File
+++			RelativePath=".\index.h"
+++			>
+++		</File>
++ 	</Files>
++ 	<Globals>
++ 	</Globals>
++diff -urN -x.svn ../trunk.orig/codec/index.c ./codec/index.c
++--- ../trunk.orig/codec/index.c	1970-01-01 01:00:00.000000000 +0100
+++++ ./codec/index.c	2007-12-01 18:40:47.000000000 +0000
++@@ -0,0 +1,391 @@
+++/*
+++ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+++ * Copyright (c) 2002-2007, Professor Benoit Macq
+++ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+++ * POSSIBILITY OF SUCH DAMAGE.
+++ */
+++
+++#include <stdio.h>
+++#include <math.h>
+++#include <string.h>
+++#include "openjpeg.h"
+++#include "index.h"
+++
+++/* ------------------------------------------------------------------------------------ */
+++
+++/**
+++Write a structured index to a file
+++@param cstr_info Codestream information 
+++@param index Index filename
+++@return Returns 0 if successful, returns 1 otherwise
+++*/
+++int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+++	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+++	FILE *stream = NULL;
+++	double total_disto = 0;
+++/* UniPG>> */
+++	int tilepartno;
+++	char disto_on, numpix_on;
+++
+++#ifdef USE_JPWL
+++	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+++		return 0;
+++#endif /* USE_JPWL */
+++/* <<UniPG */
+++
+++	if (!cstr_info)		
+++		return 1;
+++
+++	stream = fopen(index, "w");
+++	if (!stream) {
+++		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+++		return 1;
+++	}
+++	
+++	if (cstr_info->tile[0].distotile)
+++		disto_on = 1;
+++	else 
+++		disto_on = 0;
+++
+++	if (cstr_info->tile[0].numpix)
+++		numpix_on = 1;
+++	else 
+++		numpix_on = 0;
+++
+++	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+++	fprintf(stream, "%d\n", cstr_info->prog);
+++	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+++	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+++	fprintf(stream, "%d\n", cstr_info->numcomps);
+++	fprintf(stream, "%d\n", cstr_info->numlayers);
+++	fprintf(stream, "%d\n", cstr_info->numdecompos);
+++
+++	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+++		fprintf(stream, "[%d,%d] ", 
+++			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+++	}
+++
+++	fprintf(stream, "\n");
+++/* UniPG>> */
+++	fprintf(stream, "%d\n", cstr_info->main_head_start);
+++/* <<UniPG */
+++	fprintf(stream, "%d\n", cstr_info->main_head_end);
+++	fprintf(stream, "%d\n", cstr_info->codestream_size);
+++	
+++	fprintf(stream, "\nINFO ON TILES\n");
+++	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
+++	if (disto_on)
+++		fprintf(stream,"         disto");
+++	if (numpix_on)
+++		fprintf(stream,"     nbpix");
+++	if (disto_on && numpix_on)
+++		fprintf(stream,"  disto/nbpix");
+++	fprintf(stream, "\n");
+++
+++	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+++		fprintf(stream, "%4d %9d %9d %9d %9d", 
+++			cstr_info->tile[tileno].tileno,
+++			cstr_info->tile[tileno].start_pos,
+++			cstr_info->tile[tileno].end_header,
+++			cstr_info->tile[tileno].end_pos,
+++			cstr_info->tile[tileno].num_tps);
+++		if (disto_on)
+++			fprintf(stream," %9e", cstr_info->tile[tileno].distotile);
+++		if (numpix_on)
+++			fprintf(stream," %9d", cstr_info->tile[tileno].numpix);
+++		if (disto_on && numpix_on)
+++			fprintf(stream," %9e", cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+++		fprintf(stream, "\n");
+++	}
+++		
+++	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+++		int start_pos, end_ph_pos, end_pos;
+++		double disto = 0;
+++		int max_numdecompos = 0;
+++		pack_nb = 0;
+++
+++		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+++			if (max_numdecompos < cstr_info->numdecompos[compno])
+++				max_numdecompos = cstr_info->numdecompos[compno];
+++		}	
+++
+++		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+++		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
+++		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+++			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
+++				tilepartno, tileno,
+++				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
+++				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+++				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+++				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+++				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+++				);
+++
+++		if (cstr_info->prog == LRCP) {	/* LRCP */
+++			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
+++			if (disto_on)
+++				fprintf(stream, " disto");
+++			fprintf(stream,"\n");
+++
+++			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+++				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+++					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+++						int prec_max;
+++						if (resno > cstr_info->numdecompos[compno])
+++							break;
+++						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++						for (precno = 0; precno < prec_max; precno++) {
+++							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+++							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+++							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+++							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+++							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d",
+++								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
+++							if (disto_on)
+++								fprintf(stream, " %8e", disto);
+++							fprintf(stream, "\n");
+++							total_disto += disto;
+++							pack_nb++;
+++						}
+++					}
+++				}
+++			}
+++		} /* LRCP */
+++
+++		else if (cstr_info->prog == RLCP) {	/* RLCP */			
+++			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
+++			if (disto_on)
+++				fprintf(stream, " disto");
+++			fprintf(stream,"\n");
+++
+++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+++				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+++					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+++						int prec_max; 
+++						if (resno > cstr_info->numdecompos[compno])
+++							break;
+++						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++						for (precno = 0; precno < prec_max; precno++) {
+++							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+++							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+++							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+++							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+++							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d",
+++								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
+++							if (disto_on)
+++								fprintf(stream, " %8e", disto);
+++							fprintf(stream, "\n");
+++							total_disto += disto;
+++							pack_nb++;
+++						}
+++					}
+++				}
+++			}
+++		} /* RLCP */
+++
+++		else if (cstr_info->prog == RPCL) {	/* RPCL */
+++
+++			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos"); 
+++			if (disto_on)
+++				fprintf(stream, " disto");
+++			fprintf(stream,"\n");
+++
+++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++				for (precno = 0; precno < numprec; precno++) {								
+++					/* I suppose components have same XRsiz, YRsiz */
+++					int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+++					int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+++					int x1 = x0 + cstr_info->tile_x;
+++					int y1 = y0 + cstr_info->tile_y;
+++					for (compno = 0; compno < cstr_info->numcomps; compno++) {					
+++						int pcnx = cstr_info->tile[tileno].pw[resno];
+++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+++						int precno_y = (int) floor( (float)precno/(float)pcnx );
+++						if (resno > cstr_info->numdecompos[compno])
+++							break;
+++						for(y = y0; y < y1; y++) {							
+++							if (precno_y*pcy == y ) {
+++								for (x = x0; x < x1; x++) {									
+++									if (precno_x*pcx == x ) {
+++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+++											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d",
+++												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
+++											if (disto_on)
+++												fprintf(stream, " %8e", disto);
+++											fprintf(stream, "\n");
+++											total_disto += disto;
+++											pack_nb++; 
+++										}
+++									}
+++								}/* x = x0..x1 */
+++							} 
+++						}  /* y = y0..y1 */
+++					} /* precno */
+++				} /* compno */
+++			} /* resno */
+++		} /* RPCL */
+++
+++		else if (cstr_info->prog == PCRL) {	/* PCRL */
+++			/* I suppose components have same XRsiz, YRsiz */
+++			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+++			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+++			int x1 = x0 + cstr_info->tile_x;
+++			int y1 = y0 + cstr_info->tile_y;
+++
+++			// Count the maximum number of precincts 
+++			int max_numprec = 0;
+++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++				if (numprec > max_numprec)
+++					max_numprec = numprec;
+++			}
+++
+++			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos"); 
+++			if (disto_on)
+++				fprintf(stream, " disto");
+++			fprintf(stream,"\n");
+++
+++			for (precno = 0; precno < max_numprec; precno++) {
+++				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+++					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+++						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++						int pcnx = cstr_info->tile[tileno].pw[resno];
+++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+++						int precno_y = (int) floor( (float)precno/(float)pcnx );
+++						if (precno >= numprec)
+++							continue;
+++						for(y = y0; y < y1; y++) {							
+++							if (precno_y*pcy == y ) {
+++								for (x = x0; x < x1; x++) {									
+++									if (precno_x*pcx == x ) {
+++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+++											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+++												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
+++											if (disto_on)
+++												fprintf(stream, " %8e", disto);
+++											fprintf(stream, "\n");
+++											total_disto += disto;
+++											pack_nb++; 
+++										}
+++									}
+++								}/* x = x0..x1 */
+++							} 
+++						}  /* y = y0..y1 */
+++					} /* resno */
+++				} /* compno */
+++			} /* precno */
+++		} /* PCRL */
+++
+++		else {	/* CPRL */
+++			// Count the maximum number of precincts 
+++			int max_numprec = 0;
+++			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+++				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++				if (numprec > max_numprec)
+++					max_numprec = numprec;
+++			}
+++
+++			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos"); 
+++			if (disto_on)
+++				fprintf(stream, " disto");
+++			fprintf(stream,"\n");
+++
+++			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+++				/* I suppose components have same XRsiz, YRsiz */
+++				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+++				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+++				int x1 = x0 + cstr_info->tile_x;
+++				int y1 = y0 + cstr_info->tile_y;
+++
+++				for (precno = 0; precno < max_numprec; precno++) {
+++					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+++						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+++						int pcnx = cstr_info->tile[tileno].pw[resno];
+++						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+++						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+++						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+++						int precno_y = (int) floor( (float)precno/(float)pcnx );
+++						if (precno >= numprec)
+++							continue;
+++
+++						for(y = y0; y < y1; y++) {
+++							if (precno_y*pcy == y ) {
+++								for (x = x0; x < x1; x++) {
+++									if (precno_x*pcx == x ) {
+++										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+++											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+++											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+++											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+++											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+++											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+++												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
+++											if (disto_on)
+++												fprintf(stream, " %8e", disto);
+++											fprintf(stream, "\n");
+++											total_disto += disto;
+++											pack_nb++; 
+++										}
+++									}
+++								}/* x = x0..x1 */
+++							}
+++						} /* y = y0..y1 */
+++					} /* resno */
+++				} /* precno */
+++			} /* compno */
+++		} /* CPRL */   
+++	} /* tileno */
+++	
+++	if (disto_on) {
+++		fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */	
+++		fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+++	}
+++/* UniPG>> */
+++	/* print the markers' list */
+++	if (cstr_info->marknum) {
+++		fprintf(stream, "\nMARKER LIST\n");
+++		fprintf(stream, "%d\n", cstr_info->marknum);
+++		fprintf(stream, "type\tstart_pos    length\n");
+++		for (x = 0; x < cstr_info->marknum; x++)
+++			fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
+++	}
+++/* <<UniPG */
+++	fclose(stream);
+++
+++	fprintf(stderr,"Generated index file %s\n", index);
+++
+++	return 0;
+++}
++diff -urN -x.svn ../trunk.orig/codec/index.h ./codec/index.h
++--- ../trunk.orig/codec/index.h	1970-01-01 01:00:00.000000000 +0100
+++++ ./codec/index.h	2007-12-01 18:40:47.000000000 +0000
++@@ -0,0 +1,49 @@
+++/*
+++ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+++ * Copyright (c) 2002-2007, Professor Benoit Macq
+++ * Copyright (c) 2003-2007, Francois-Olivier Devaux
+++ * All rights reserved.
+++ *
+++ * Redistribution and use in source and binary forms, with or without
+++ * modification, are permitted provided that the following conditions
+++ * are met:
+++ * 1. Redistributions of source code must retain the above copyright
+++ *    notice, this list of conditions and the following disclaimer.
+++ * 2. Redistributions in binary form must reproduce the above copyright
+++ *    notice, this list of conditions and the following disclaimer in the
+++ *    documentation and/or other materials provided with the distribution.
+++ *
+++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+++ * POSSIBILITY OF SUCH DAMAGE.
+++ */
+++
+++#ifndef __J2K_INDEX_H
+++#define __J2K_INDEX_H
+++
+++#ifdef __cplusplus
+++extern "C" {
+++#endif
+++
+++/**
+++Write a structured index to a file
+++@param cstr_info Codestream information 
+++@param index Index filename
+++@return Returns 0 if successful, returns 1 otherwise
+++*/
+++int write_index_file(opj_codestream_info_t *cstr_info, char *index);
+++
+++#ifdef __cplusplus
+++}
+++#endif
+++
+++#endif /* __J2K_INDEX_H */
+++
++diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.c ./codec/j2k_to_image.c
++--- ../trunk.orig/codec/j2k_to_image.c	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/j2k_to_image.c	2007-11-27 22:39:51.000000000 +0000
++@@ -38,6 +38,7 @@
++ #include "compat/getopt.h"
++ #include "convert.h"
++ #include "dirent.h"
+++#include "index.h"
++ 
++ #ifndef WIN32
++ #define stricmp strcasecmp
++@@ -229,250 +230,6 @@
++ 	return 0;
++ }
++ 
++-/* ------------------------------------------------------------------------------------ */
++-
++-/**
++-Create an index and write it to a file
++-@param cstr_info Codestream information 
++-@param index Index filename
++-@return Returns 0 if successful, returns 1 otherwise
++-*/
++-int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
++-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
++-	FILE *stream = NULL;
++-	int tilepartno;
++-
++-	if (!cstr_info)		
++-		return 1;
++-
++-	stream = fopen(index, "w");
++-	if (!stream) {
++-		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
++-		return 1;
++-	}
++-	
++-	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
++-	fprintf(stream, "%d\n", cstr_info->prog);
++-	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
++-	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
++-	fprintf(stream, "%d\n", cstr_info->numcomps);
++-	fprintf(stream, "%d\n", cstr_info->numlayers);
++-	fprintf(stream, "%d\n", cstr_info->numdecompos);
++-	
++-	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
++-		fprintf(stream, "[%d,%d] ", 
++-			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0*/
++-	}
++-	fprintf(stream, "\n");
++-	fprintf(stream, "%d\n", cstr_info->main_head_start);
++-	fprintf(stream, "%d\n", cstr_info->main_head_end);
++-	fprintf(stream, "%d\n", cstr_info->codestream_size);
++-	
++-	fprintf(stream, "\nINFO ON TILES\n");
++-	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts\n");
++-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++-		fprintf(stream, "%4d %9d %9d %9d %9d\n",
++-			cstr_info->tile[tileno].tileno,
++-			cstr_info->tile[tileno].start_pos,
++-			cstr_info->tile[tileno].end_header,
++-			cstr_info->tile[tileno].end_pos,
++-			cstr_info->tile[tileno].num_tps);
++-	}
++-		
++-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
++-		int start_pos, end_ph_pos, end_pos;
++-		int max_numdecompos = 0;
++-		pack_nb = 0;	
++-
++-		for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-			if (max_numdecompos < cstr_info->numdecompos[compno])
++-				max_numdecompos = cstr_info->numdecompos[compno];
++-		}
++-
++-		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
++-		fprintf(stream, "part_nb tileno  num_packs  start_pos end_tph_pos   end_pos\n");
++-		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
++-			fprintf(stream, "%4d %9d  %9d  %9d %11d %9d\n",
++-				tilepartno, tileno,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
++-				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
++-				);
++-		if (cstr_info->prog == LRCP) {	/* LRCP */
++-			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos\n");
++-
++-			for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-				for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-						int prec_max;
++-						if (resno > cstr_info->numdecompos[compno])
++-							break;
++-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-						for (precno = 0; precno < prec_max; precno++) {
++-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d\n",
++-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
++-							pack_nb++;
++-						}
++-					}
++-				}
++-			}
++-		} /* LRCP */
++-		else if (cstr_info->prog == RLCP) {	/* RLCP */
++-
++-			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
++-
++-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-				for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-						int prec_max;
++-						if (resno > cstr_info->numdecompos[compno])
++-							break;
++-						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-						for (precno = 0; precno < prec_max; precno++) {
++-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d\n",
++-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
++-							pack_nb++;
++-						}
++-					}
++-				}
++-			}
++-		} /* RLCP */
++-		else if (cstr_info->prog == RPCL) {	/* RPCL */
++-
++-			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos\n"); 
++-
++-			for (resno = 0; resno < max_numdecompos + 1; resno++) {
++-				/* I suppose components have same XRsiz, YRsiz */
++-				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-				int x1 = x0 + cstr_info->tile_x;
++-				int y1 = y0 + cstr_info->tile_y;
++-				for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-					int prec_max;
++-					if (resno > cstr_info->numdecompos[compno])
++-							break;
++-					prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {							
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {									
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d\n",
++-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							} 
++-						}  /* y = y0..y1 */
++-					} /* precno */
++-				} /* compno */
++-			} /* resno */
++-		} /* RPCL */
++-		else if (cstr_info->prog == PCRL) {	/* PCRL */
++-			/* I suppose components have same XRsiz, YRsiz */
++-			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-			int x1 = x0 + cstr_info->tile_x;
++-			int y1 = y0 + cstr_info->tile_y;
++-
++-			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos\n"); 
++-
++-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {							
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {									
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
++-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							} 
++-						}  /* y = y0..y1 */
++-					} /* precno */
++-				} /* resno */
++-			} /* compno */
++-		} /* PCRL */
++-		else {	/* CPRL */
++-
++-			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos\n"); 
++-
++-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
++-				/* I suppose components have same XRsiz, YRsiz */
++-				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
++-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
++-				int x1 = x0 + cstr_info->tile_x;
++-				int y1 = y0 + cstr_info->tile_y;
++-				
++-				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
++-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
++-					for (precno = 0; precno < prec_max; precno++) {
++-						int pcnx = cstr_info->tile[tileno].pw[resno];
++-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
++-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
++-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
++-						int precno_y = (int) floor( (float)precno/(float)pcnx );
++-						for(y = y0; y < y1; y++) {
++-							if (precno_y*pcy == y ) {
++-								for (x = x0; x < x1; x++) {
++-									if (precno_x*pcx == x ) {
++-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
++-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
++-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
++-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
++-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
++-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
++-											pack_nb++; 
++-										}
++-									}
++-								}/* x = x0..x1 */
++-							}
++-						} /* y = y0..y1 */
++-					} /* precno */
++-				} /* resno */
++-			} /* compno */
++-		} /* CPRL */   
++-	} /* tileno */
++-	
++-	fclose(stream);
++-
++-	fprintf(stderr,"Generated index file %s\n", index);
++-
++-	return 0;
++-}
++-
++-/* ------------------------------------------------------------------------------------ */
++-
++ /* -------------------------------------------------------------------------- */
++ int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol, char *indexfilename) {
++ 	/* parse the command line */
++diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.dsp ./codec/j2k_to_image.dsp
++--- ../trunk.orig/codec/j2k_to_image.dsp	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/j2k_to_image.dsp	2007-12-01 18:40:47.000000000 +0000
++@@ -103,6 +103,14 @@
++ # End Source File
++ # Begin Source File
++ 
+++SOURCE=.\index.c
+++# End Source File
+++# Begin Source File
+++
+++SOURCE=.\index.h
+++# End Source File
+++# Begin Source File
+++
++ SOURCE=.\j2k_to_image.c
++ # End Source File
++ # End Target
++diff -urN -x.svn ../trunk.orig/codec/j2k_to_image.vcproj ./codec/j2k_to_image.vcproj
++--- ../trunk.orig/codec/j2k_to_image.vcproj	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/j2k_to_image.vcproj	2007-11-27 22:39:51.000000000 +0000
++@@ -256,6 +256,14 @@
++ 			>
++ 		</File>
++ 		<File
+++			RelativePath=".\index.c"
+++			>
+++		</File>
+++		<File
+++			RelativePath=".\index.h"
+++			>
+++		</File>
+++		<File
++ 			RelativePath="j2k_to_image.c"
++ 			>
++ 			<FileConfiguration
++diff -urN -x.svn ../trunk.orig/codec/Makefile ./codec/Makefile
++--- ../trunk.orig/codec/Makefile	2007-09-28 11:36:31.000000000 +0100
+++++ ./codec/Makefile	2007-11-27 22:39:51.000000000 +0000
++@@ -5,10 +5,10 @@
++ all: j2k_to_image image_to_j2k
++ 
++ j2k_to_image: j2k_to_image.c ../libopenjpeg.a
++-	gcc $(CFLAGS) compat/getopt.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+++	gcc $(CFLAGS) compat/getopt.c index.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
++ 
++ image_to_j2k: image_to_j2k.c ../libopenjpeg.a
++-	gcc $(CFLAGS) compat/getopt.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+++	gcc $(CFLAGS) compat/getopt.c index.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
++ 
++ clean:
++ 	rm -f j2k_to_image image_to_j2k
+diff -urN -x.svn ../trunk.orig/jpwl/jpwl.c ./jpwl/jpwl.c
+--- ../trunk.orig/jpwl/jpwl.c	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/jpwl.c	2007-12-01 18:40:47.000000000 +0000
+@@ -88,22 +88,25 @@
+ int jpwl_markcomp(const void *arg1, const void *arg2);
+ 
+ /** write an EPB MS to a buffer
++@param j2k J2K compressor handle
+ @param epbmark pointer to the EPB MS
+ @param buf pointer to the memory buffer
+ */
+-void jpwl_epb_write(jpwl_epb_ms_t *epbmark, unsigned char *buf);
++void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf);
+ 
+ /** write an EPC MS to a buffer
++@param j2k J2K compressor handle
+ @param epcmark pointer to the EPC MS
+ @param buf pointer to the memory buffer
+ */
+-void jpwl_epc_write(jpwl_epc_ms_t *epcmark, unsigned char *buf);
++void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epcmark, unsigned char *buf);
+ 
+ /** write an ESD MS to a buffer
++@param j2k J2K compressor handle
+ @param esdmark pointer to the ESD MS
+ @param buf pointer to the memory buffer
+ */
+-void jpwl_esd_write(jpwl_esd_ms_t *esdmark, unsigned char *buf);
++void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esdmark, unsigned char *buf);
+ 
+ /*-----------------------------------------------------------------*/
+ 
+@@ -157,6 +160,24 @@
+ 
+ }
+ 
++void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
++
++	if (!cstr_info)
++		return;
++
++	/* expand the list? */
++	if ((cstr_info->marknum + 1) > cstr_info->maxmarknum) {
++		cstr_info->maxmarknum = 100 + (int) ((float) cstr_info->maxmarknum * 1.0F);
++		cstr_info->marker = opj_realloc(cstr_info->marker, cstr_info->maxmarknum);
++	}
++
++	/* add the marker */
++	cstr_info->marker[cstr_info->marknum].type = type;
++	cstr_info->marker[cstr_info->marknum].pos = pos;
++	cstr_info->marker[cstr_info->marknum].len = len;
++	cstr_info->marknum++;
++
++}
+ 
+ void jpwl_prepare_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+ 
+@@ -170,7 +191,7 @@
+ 	jpwl_epc_ms_t *epc_mark;
+ 	jpwl_esd_ms_t *esd_mark;
+ 
+-	/* find SOC + SIZ length */
++	/* find (SOC + SIZ) length */
+ 	/* I assume SIZ is always the first marker after SOC */
+ 	cio_seek(cio, soc_pos + 4);
+ 	socsiz_len = (unsigned short int) cio_read(cio, 2) + 4; /* add the 2 marks length itself */
+@@ -544,7 +565,8 @@
+ 			startpack = 0;
+ 			/* EPB MSs for UEP packet data protection in Tile Parts */
+ 			/****** for (packno = 0; packno < j2k->cstr_info->num; packno++) { */
+-			first_tp_pack = (tpno > 0) ? (first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno - 1].tp_numpacks) : 0;
++			/*first_tp_pack = (tpno > 0) ? (first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno - 1].tp_numpacks) : 0;*/
++			first_tp_pack = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pack;
+ 			last_tp_pack = first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks - 1;
+ 			for (packno = 0; packno < j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks; packno++) {
+ 
+@@ -706,7 +728,7 @@
+ 	}
+ 
+ 	/* allocate a new buffer of proper size */
+-	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) new_size * sizeof (unsigned char)))) {
++	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) (new_size + soc_pos) * sizeof(unsigned char)))) {
+ 		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL codestream buffer\n");
+ 		exit(1);
+ 	};
+@@ -736,15 +758,15 @@
+ 		switch (jwmarker[mm].id) {
+ 
+ 		case J2K_MS_EPB:
+-			jpwl_epb_write(jwmarker[mm].epbmark, jpwl_buf);
++			jpwl_epb_write(j2k, jwmarker[mm].epbmark, jpwl_buf);
+ 			break;
+ 
+ 		case J2K_MS_EPC:
+-			jpwl_epc_write(jwmarker[mm].epcmark, jpwl_buf);
++			jpwl_epc_write(j2k, jwmarker[mm].epcmark, jpwl_buf);
+ 			break;
+ 
+ 		case J2K_MS_ESD:
+-			jpwl_esd_write(jwmarker[mm].esdmark, jpwl_buf);
++			jpwl_esd_write(j2k, jwmarker[mm].esdmark, jpwl_buf);
+ 			break;
+ 
+ 		case J2K_MS_RED:
+@@ -755,6 +777,10 @@
+ 			break;
+ 		};
+ 
++		/* we update the markers struct */
++		if (j2k->cstr_info)
++			j2k->cstr_info->marker[j2k->cstr_info->marknum - 1].pos = (jpwl_buf - orig_buf);
++		
+ 		/* we set the marker dpos to the new position in the JPWL codestream */
+ 		jwmarker[mm].dpos = (double) (jpwl_buf - orig_buf);
+ 
+@@ -863,14 +889,13 @@
+ 
+ 	/* free original cio buffer and set it to the JPWL one */
+ 	opj_free(cio->buffer);
+-	/*cio->cinfo;*/ /* no change */
+-	/*cio->openmode;*/ /* no change */
+-	/*cio->buffer = jpwl_buf - new_size - soc_pos;*/
++	cio->cinfo = cio->cinfo; /* no change */
++	cio->openmode = cio->openmode; /* no change */
+ 	cio->buffer = orig_buf;
+ 	cio->length = new_size + soc_pos;
+-	cio->start = jpwl_buf - new_size - soc_pos;
+-	cio->end = jpwl_buf - 1;
+-	cio->bp = jpwl_buf - new_size - soc_pos;
++	cio->start = cio->buffer;
++	cio->end = cio->buffer + cio->length;
++	cio->bp = cio->buffer;
+ 	cio_seek(cio, soc_pos + new_size);
+ 
+ }
+@@ -982,6 +1007,10 @@
+ 		cio_write(cio, Pcrc, 2);
+ 
+ 	cio_seek(cio, Lepcp + Lepc);
++
++	/* marker struct update */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, Lepcp - 2, Lepc + 2);
++
+ }
+ 
+ void j2k_read_epb(opj_j2k_t *j2k) {
+@@ -1130,6 +1159,9 @@
+ 	cio_write(cio, Lepb, 2);		/* Lepb */
+ 
+ 	cio_seek(cio, Lepbp + Lepb);
++
++	/* marker struct update */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, Lepbp - 2, Lepb + 2);
+ }
+ 
+ void j2k_read_esd(opj_j2k_t *j2k) {
+@@ -1187,6 +1219,7 @@
+ 
+ bool jpwl_check_tile(opj_j2k_t *j2k, opj_tcd_t *tcd, int tileno) {
+ 
++#ifdef oerhgierhgvhreit4u
+ 	/*
+ 	   we navigate through the tile and find possible invalid parameters:
+        this saves a lot of crashes!!!!!
+@@ -1248,6 +1281,8 @@
+ 		}
+ 	}
+ 
++#endif
++
+ 	return true;
+ }
+ 
+diff -urN -x.svn ../trunk.orig/jpwl/jpwl.h ./jpwl/jpwl.h
+--- ../trunk.orig/jpwl/jpwl.h	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/jpwl.h	2007-11-27 22:39:51.000000000 +0000
+@@ -334,6 +334,8 @@
+ 
+ bool jpwl_epb_fill(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf, unsigned char *post_buf);
+ 
++void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
++
+ /** corrects the data in the JPWL codestream
+ @param j2k J2K compressor handle
+ @return true if correction is performed correctly
+diff -urN -x.svn ../trunk.orig/jpwl/JPWL_image_to_j2k.dsp ./jpwl/JPWL_image_to_j2k.dsp
+--- ../trunk.orig/jpwl/JPWL_image_to_j2k.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/JPWL_image_to_j2k.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -98,6 +98,10 @@
+ 
+ SOURCE=..\codec\image_to_j2k.c
+ # End Source File
++# Begin Source File
++
++SOURCE=..\codec\index.c
++# End Source File
+ # End Group
+ # Begin Group "Header Files"
+ 
+@@ -112,6 +116,10 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=..\codec\index.h
++# End Source File
++# Begin Source File
++
+ SOURCE=..\libopenjpeg\openjpeg.h
+ # End Source File
+ # End Group
+diff -urN -x.svn ../trunk.orig/jpwl/JPWL_j2k_to_image.dsp ./jpwl/JPWL_j2k_to_image.dsp
+--- ../trunk.orig/jpwl/JPWL_j2k_to_image.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/JPWL_j2k_to_image.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -95,6 +95,10 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=..\codec\index.c
++# End Source File
++# Begin Source File
++
+ SOURCE=..\codec\j2k_to_image.c
+ # End Source File
+ # End Group
+@@ -115,6 +119,10 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=..\codec\index.h
++# End Source File
++# Begin Source File
++
+ SOURCE=.\jpwl.h
+ # End Source File
+ # Begin Source File
+diff -urN -x.svn ../trunk.orig/jpwl/jpwl_lib.c ./jpwl/jpwl_lib.c
+--- ../trunk.orig/jpwl/jpwl_lib.c	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/jpwl_lib.c	2007-12-01 18:40:47.000000000 +0000
+@@ -295,7 +295,7 @@
+ 	return epb;
+ }
+ 
+-void jpwl_epb_write(jpwl_epb_ms_t *epb, unsigned char *buf) {
++void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epb, unsigned char *buf) {
+ 
+ 	/* Marker */
+ 	*(buf++) = (unsigned char) (J2K_MS_EPB >> 8); 
+@@ -323,6 +323,10 @@
+ 	/* Data */
+ 	/*memcpy(buf, epb->data, (size_t) epb->Lepb - 11);*/
+ 	memset(buf, 0, (size_t) epb->Lepb - 11);
++
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, -1, epb->Lepb + 2);
++
+ };
+ 
+ 
+@@ -657,7 +661,7 @@
+ 	j2k->state = J2K_STATE_MHSOC;
+ 
+ 	/* cycle all over the markers */
+-	while ((unsigned int) cio_tell(cio) < cio->length) {
++	while (cio_tell(cio) < cio->length) {
+ 
+ 		/* read the marker */
+ 		mark_pos = cio_tell(cio);
+@@ -1145,7 +1149,7 @@
+ 	return true;
+ }
+ 
+-void jpwl_epc_write(jpwl_epc_ms_t *epc, unsigned char *buf) {
++void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epc, unsigned char *buf) {
+ 
+ 	/* Marker */
+ 	*(buf++) = (unsigned char) (J2K_MS_EPC >> 8); 
+@@ -1171,6 +1175,10 @@
+ 	/* Data */
+ 	/*memcpy(buf, epc->data, (size_t) epc->Lepc - 9);*/
+ 	memset(buf, 0, (size_t) epc->Lepc - 9);
++
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, -1, epc->Lepc + 2);
++
+ };
+ 
+ int jpwl_esds_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
+@@ -1561,7 +1569,7 @@
+ 	return true;
+ }
+ 
+-void jpwl_esd_write(jpwl_esd_ms_t *esd, unsigned char *buf) {
++void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esd, unsigned char *buf) {
+ 
+ 	/* Marker */
+ 	*(buf++) = (unsigned char) (J2K_MS_ESD >> 8); 
+@@ -1586,6 +1594,10 @@
+ 	else
+ 		memset(buf, 0xAA, (size_t) esd->Lesd - 5);
+ 		/*memcpy(buf, esd->data, (size_t) esd->Lesd - 5);*/
++
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_ESD, -1, esd->Lesd + 2);
++
+ }
+ 
+ unsigned short int jpwl_double_to_pfp(double V, int bytes) {
+@@ -1703,10 +1715,10 @@
+ 
+ 		/* end_pos: increment with markers before the end of this tile */
+ 		/* code is disabled, since according to JPWL no markers can be beyond TPH */
+-		/*addlen = 0;
++		addlen = 0;
+ 		for (mm = 0; mm < jwmarker_num; mm++)
+ 			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].end_pos)
+-				addlen += jwmarker[mm].len + 2;*/
++				addlen += jwmarker[mm].len + 2;
+ 		info->tile[tileno].end_pos += addlen;
+ 
+ 		/* navigate through all the tile parts */
+@@ -1740,11 +1752,19 @@
+ 			
+ 			/* start_pos: increment with markers before the packet */
+ 			/* disabled for the same reason as before */
++			addlen = 0;
++			for (mm = 0; mm < jwmarker_num; mm++)
++				if (jwmarker[mm].pos <= (unsigned long int) info->tile[tileno].packet[packno].start_pos)
++					addlen += jwmarker[mm].len + 2;
++			info->tile[tileno].packet[packno].start_pos += addlen;
++
++			/* end_ph_pos: increment with markers before the packet */
++			/* disabled for the same reason as before */
+ 			/*addlen = 0;
+ 			for (mm = 0; mm < jwmarker_num; mm++)
+-				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].start_pos)
++				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].end_ph_pos)
+ 					addlen += jwmarker[mm].len + 2;*/
+-			info->tile[tileno].packet[packno].start_pos += addlen;
++			info->tile[tileno].packet[packno].end_ph_pos += addlen;
+ 
+ 			/* end_pos: increment if marker is before the end of packet */
+ 			/* disabled for the same reason as before */
+@@ -1757,6 +1777,8 @@
+ 		}
+ 	}
+ 
++	/* reorder the markers list */
++
+ 	return true;
+ }
+ 
+diff -urN -x.svn ../trunk.orig/jpwl/LibOpenJPEG_JPWL.dsp ./jpwl/LibOpenJPEG_JPWL.dsp
+--- ../trunk.orig/jpwl/LibOpenJPEG_JPWL.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/LibOpenJPEG_JPWL.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -41,7 +41,7 @@
+ # PROP Intermediate_Dir "Release"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+-# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
++# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
+ # ADD BASE RSC /l 0x80c /d "NDEBUG"
+ # ADD RSC /l 0x80c /d "NDEBUG"
+ BSC32=bscmake.exe
+@@ -64,7 +64,7 @@
+ # PROP Intermediate_Dir "Debug"
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
++# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
+ # ADD BASE RSC /l 0x80c /d "_DEBUG"
+ # ADD RSC /l 0x80c /d "_DEBUG"
+ BSC32=bscmake.exe
+@@ -245,6 +245,10 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=..\libopenjpeg\opj_malloc.h
++# End Source File
++# Begin Source File
++
+ SOURCE=..\libopenjpeg\pi.h
+ # End Source File
+ # Begin Source File
+diff -urN -x.svn ../trunk.orig/jpwl/Makefile ./jpwl/Makefile
+--- ../trunk.orig/jpwl/Makefile	2007-09-28 11:36:31.000000000 +0100
++++ ./jpwl/Makefile	2007-11-27 22:39:51.000000000 +0000
+@@ -1,33 +1,83 @@
+-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
+-
+-# General configuration variables:
+-CC = gcc
+-AR = ar
+-
+-CFLAGS = -O3 -DUSE_JPWL # -g -p -pg -DUSE_JPWL
+-
+-OPJ_SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c
+-JPWL_SRCS = crc.c jpwl.c jpwl_lib.c rs.c
+-
+-TARGET  = openjpeg_JPWL
+-STATICLIB = lib$(TARGET).a
+-
+-MODULES = $(OPJ_SRCS:.c=.o) $(JPWL_SRCS:.c=.o)
+-
+-all: JPWL_image_to_j2k JPWL_j2k_to_image
+-
+-.c.o:
+-	$(CC) $(CFLAGS) -c $< -o $@
+-
+-$(STATICLIB): $(MODULES)
+-	$(AR) r $@ $(MODULES)
+-
+-JPWL_j2k_to_image: ../codec/j2k_to_image.c $(STATICLIB)
+-	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
+-
+-JPWL_image_to_j2k: ../codec/image_to_j2k.c $(STATICLIB)
+-	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
+-
+-clean:
+-	rm -f JPWL_j2k_to_image JPWL_image_to_j2k *.o *.a
+-	cd ../libopenjpeg; rm -f *.o
++# Linux makefile for OpenJPEG + JPWL
++
++VER_MAJOR = 2
++VER_MINOR = 1.2.0
++
++JPWL_SRCS = ./crc.c ./jpwl.c ./jpwl_lib.c ./rs.c
++SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c $(JPWL_SRCS)
++INCLS = ../libopenjpeg/bio.h ../libopenjpeg/cio.h ../libopenjpeg/dwt.h ../libopenjpeg/event.h ../libopenjpeg/fix.h ../libopenjpeg/image.h ../libopenjpeg/int.h ../libopenjpeg/j2k.h ../libopenjpeg/j2k_lib.h ../libopenjpeg/jp2.h ../libopenjpeg/jpt.h ../libopenjpeg/mct.h ../libopenjpeg/mqc.h ../libopenjpeg/openjpeg.h ../libopenjpeg/pi.h ../libopenjpeg/raw.h ../libopenjpeg/t1.h ../libopenjpeg/t2.h ../libopenjpeg/tcd.h ../libopenjpeg/tgt.h ../libopenjpeg/opj_malloc.h ../libopenjpeg/opj_includes.h
++INCLUDE = -Ilibopenjpeg_JPWL
++
++# General configuration variables:
++CC = gcc
++AR = ar
++
++PREFIX = /usr
++INSTALL_LIBDIR = $(PREFIX)/lib
++INSTALL_INCLUDE = $(PREFIX)/include
++
++# Converts cr/lf to just lf
++DOS2UNIX = dos2unix
++
++COMPILERFLAGS = -O3 -fPIC
++LIBRARIES = -lstdc++
++
++MODULES = $(SRCS:.c=.o)
++CFLAGS = $(COMPILERFLAGS) $(INCLUDE) -DUSE_JPWL
++
++TARGET  = openjpeg_JPWL
++STATICLIB = lib$(TARGET).a
++SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
++LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
++
++
++
++default: all
++
++all: OpenJPEG_JPWL JPWL_image_to_j2k JPWL_j2k_to_image
++
++dist: OpenJPEG_JPWL
++	install -d dist
++	install -m 644 $(STATICLIB) dist
++	install -m 755 $(SHAREDLIB) dist
++	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
++	install libopenjpeg/openjpeg.h dist
++
++dos2unix:
++	@$(DOS2UNIX) $(SRCS) $(INCLS)
++
++OpenJPEG_JPWL: $(STATICLIB) $(SHAREDLIB)
++
++JPWL_codec: JPWL_j2k_to_image JPWL_image_to_j2k $(STATICLIB)
++
++.c.o:
++	$(CC) $(CFLAGS) -c $< -o $@
++
++$(STATICLIB): $(MODULES)
++	$(AR) r $@ $(MODULES)
++
++$(SHAREDLIB): $(MODULES)
++	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
++
++JPWL_j2k_to_image: ../codec/j2k_to_image.c
++	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
++
++JPWL_image_to_j2k: ../codec/image_to_j2k.c
++	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
++
++install: OpenJPEG
++	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
++	install -m 644 -o root -g root $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
++	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
++	install -m 755 -o root -g root $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
++	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
++	install -m 644 -o root -g root libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
++	-ldconfig
++
++cleanlib:
++	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
++
++cleancodec:
++	rm -f JPWL_j2k_to_image JPWL_image_to_j2k JPWL_j2k_to_image.o JPWL_image_to_j2k.o
++
++clean: cleanlib cleancodec
+\ No newline at end of file
+diff -urN -x.svn ../trunk.orig/libopenjpeg/dwt.c ./libopenjpeg/dwt.c
+--- ../trunk.orig/libopenjpeg/dwt.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/dwt.c	2007-11-27 22:39:50.000000000 +0000
+@@ -5,6 +5,8 @@
+  * Copyright (c) 2002-2003, Yannick Verschueren
+  * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+  * Copyright (c) 2005, Herve Drolon, FreeImage Team
++ * Copyright (c) 2007, Jonathan Ballard <dzonatas@dzonux.net>
++ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+@@ -29,6 +31,9 @@
+  * POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
++#ifdef __SSE__
++#include <xmmintrin.h>
++#endif
+ 
+ #include "opj_includes.h"
+ 
+@@ -41,12 +46,32 @@
+ /** @name Local data structures */
+ /*@{*/
+ 
+-typedef struct dwt_local{
+-	int *	mem ;
++typedef struct dwt_local {
++	int* mem;
++	int dn;
++	int sn;
++	int cas;
++} dwt_t;
++
++typedef union {
++	float	f[4];
++} v4;
++
++typedef struct v4dwt_local {
++	v4*	wavelet ;
+ 	int		dn ;
+ 	int		sn ;
+ 	int		cas ;
+-	} dwt_t ; 
++} v4dwt_t ;
++
++static const float alpha =  1.586134342f; //  12994
++static const float beta  =  0.052980118f; //    434
++static const float gamma = -0.882911075f; //  -7233
++static const float delta = -0.443506852f; //  -3633
++
++static const float K      = 1.230174105f; //  10078
++/* FIXME: What is this constant? */
++static const float c13318 = 1.625732422f;
+ 
+ /*@}*/
+ 
+@@ -75,11 +100,11 @@
+ */
+ static void dwt_interleave_v(dwt_t* v, int *a, int x);
+ /**
+-Forward 5-3 wavelet tranform in 1-D
++Forward 5-3 wavelet transform in 1-D
+ */
+ static void dwt_encode_1(int *a, int dn, int sn, int cas);
+ /**
+-Inverse 5-3 wavelet tranform in 1-D
++Inverse 5-3 wavelet transform in 1-D
+ */
+ static void dwt_decode_1(dwt_t *v);
+ /**
+@@ -87,17 +112,13 @@
+ */
+ static void dwt_encode_1_real(int *a, int dn, int sn, int cas);
+ /**
+-Inverse 9-7 wavelet transform in 1-D
+-*/
+-static void dwt_decode_1_real(dwt_t *v);
+-/**
+-FIXME : comment ???
++Explicit calculation of the Quantization Stepsizes 
+ */
+ static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
+ /**
+-Inverse wavelet tranform in 2-D.
++Inverse wavelet transform in 2-D.
+ */
+-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop , DWT1DFN fn);
++static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
+ 
+ /*@}*/
+ 
+@@ -199,7 +220,7 @@
+ 
+ 
+ /* <summary>                            */
+-/* Forward 5-3 wavelet tranform in 1-D. */
++/* Forward 5-3 wavelet transform in 1-D. */
+ /* </summary>                           */
+ static void dwt_encode_1(int *a, int dn, int sn, int cas) {
+ 	int i;
+@@ -220,7 +241,7 @@
+ }
+ 
+ /* <summary>                            */
+-/* Inverse 5-3 wavelet tranform in 1-D. */
++/* Inverse 5-3 wavelet transform in 1-D. */
+ /* </summary>                           */ 
+ static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
+ 	int i;
+@@ -241,7 +262,7 @@
+ }
+ 
+ /* <summary>                            */
+-/* Inverse 5-3 wavelet tranform in 1-D. */
++/* Inverse 5-3 wavelet transform in 1-D. */
+ /* </summary>                           */ 
+ static void dwt_decode_1(dwt_t *v) {
+ 	dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
+@@ -285,102 +306,6 @@
+ 	}
+ }
+ 
+-static void dwt_decode_sm(dwt_t* v, int k, int n, int x) {
+-	int m = k > n ? n : k;
+-	int l = v->mem[1];			//D(0);
+-	int j;
+-	int i;
+-	for (i = 0; i < m; i++) {
+-		j = l;
+-		WS(i) -= fix_mul( ( l = WD(i) ) + j , x);
+-	}
+-	if( i < k ) {
+-		l = fix_mul( l + l , x );
+-		for (; i < k; i++)
+-			WS(i) -= l;
+-	}
+-}
+-
+-static void dwt_decode_sp(dwt_t* v, int k, int n, int x) {
+-	int m = k > n ? n : k;
+-	int l = v->mem[1];			//D(0);
+-	int j;
+-	int i;
+-	for (i = 0; i < m; i++) {
+-		j = l;
+-		WS(i) += fix_mul( ( l = WD(i) ) + j , x);
+-	}
+-	if( i < k ) {
+-		l = fix_mul( l + l , x );
+-		for (; i < k; i++)
+-			WS(i) += l;
+-	}
+-}
+-
+-static void dwt_decode_dm(dwt_t* v, int k, int n, int x) {
+-	int m = k >= n ? n-1 : k;
+-	int l = v->mem[0];				//S(0);
+-	int i;
+-	int j;
+-	for (i = 0; i < m; i++) {
+-		j = l;
+-		WD(i) -=  fix_mul( ( l = WS(i+1) ) + j , x);
+-	}
+-	if( i < k ) {
+-		l = fix_mul( l + l , x );
+-		for (; i < k; i++)
+-			WD(i) -= l;
+-	}
+-}
+-
+-static void dwt_decode_dp(dwt_t* v, int k, int n, int x) {
+-	int m = k >= n ? n-1 : k;
+-	int l = v->mem[0];				//S(0);
+-	int i;
+-	int j;
+-	for (i = 0; i < m; i++) {
+-		j = l;
+-		WD(i) +=  fix_mul( ( l = WS(i+1) ) + j , x);
+-	}
+-
+-	if( i < k ) {
+-		l = fix_mul( l + l , x );
+-		for (; i < k; i++)
+-			WD(i) += l;
+-	}
+-}
+-
+-
+-/* <summary>                             */
+-/* Inverse 9-7 wavelet transform in 1-D. */
+-/* </summary>                            */
+-static void dwt_decode_1_real(dwt_t* v) {
+-	int i;
+-	if (!v->cas) {
+-		if ((v->dn > 0) || (v->sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+-			for (i = 0; i < v->sn; i++)
+-				WS(i) = fix_mul(WS(i), 10078);	/* 10076 */
+-			for (i = 0; i < v->dn; i++)
+-				WD(i) = fix_mul(WD(i), 13318);	/* 13320 */
+-			dwt_decode_sm(v, v->sn, v->dn, 3633);
+-			dwt_decode_dm(v, v->dn, v->sn, 7233);
+-			dwt_decode_sp(v, v->sn, v->dn, 434);
+-			dwt_decode_dp(v, v->dn, v->sn, 12994);
+-		}
+-	} else {
+-		if ((v->sn > 0) || (v->dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+-			for (i = 0; i < v->sn; i++)
+-				WD(i) = fix_mul(WD(i), 10078);	/* 10076 */
+-			for (i = 0; i < v->dn; i++)
+-				WS(i) = fix_mul(WS(i), 13318);	/* 13320 */
+-			dwt_decode_dm(v, v->sn, v->dn, 3633);
+-			dwt_decode_sm(v, v->dn, v->sn, 7233);
+-			dwt_decode_dp(v, v->sn, v->dn, 434);
+-			dwt_decode_sp(v, v->dn, v->sn, 12994);
+-		}
+-	}
+-}
+-
+ static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
+ 	int p, n;
+ 	p = int_floorlog2(stepsize) - 13;
+@@ -396,7 +321,7 @@
+ */
+ 
+ /* <summary>                            */
+-/* Forward 5-3 wavelet tranform in 2-D. */
++/* Forward 5-3 wavelet transform in 2-D. */
+ /* </summary>                           */
+ void dwt_encode(opj_tcd_tilecomp_t * tilec) {
+ 	int i, j, k;
+@@ -411,7 +336,7 @@
+ 	
+ 	for (i = 0; i < l; i++) {
+ 		int rw;			/* width of the resolution level computed                                                           */
+-		int rh;			/* heigth of the resolution level computed                                                          */
++		int rh;			/* height of the resolution level computed                                                          */
+ 		int rw1;		/* width of the resolution level once lower than computed one                                       */
+ 		int rh1;		/* height of the resolution level once lower than computed one                                      */
+ 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+@@ -452,10 +377,10 @@
+ 
+ 
+ /* <summary>                            */
+-/* Inverse 5-3 wavelet tranform in 2-D. */
++/* Inverse 5-3 wavelet transform in 2-D. */
+ /* </summary>                           */
+-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop) {
+-	dwt_decode_tile(tilec, stop, &dwt_decode_1);
++void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
++	dwt_decode_tile(tilec, numres, &dwt_decode_1);
+ }
+ 
+ 
+@@ -494,7 +419,7 @@
+ 	
+ 	for (i = 0; i < l; i++) {
+ 		int rw;			/* width of the resolution level computed                                                     */
+-		int rh;			/* heigth of the resolution level computed                                                    */
++		int rh;			/* height of the resolution level computed                                                    */
+ 		int rw1;		/* width of the resolution level once lower than computed one                                 */
+ 		int rh1;		/* height of the resolution level once lower than computed one                                */
+ 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+@@ -534,14 +459,6 @@
+ }
+ 
+ 
+-/* <summary>                             */
+-/* Inverse 9-7 wavelet transform in 2-D. */
+-/* </summary>                            */
+-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop) {
+-	dwt_decode_tile(tilec, stop, dwt_decode_1_real);
+-}
+-
+-
+ /* <summary>                          */
+ /* Get gain of 9-7 wavelet transform. */
+ /* </summary>                         */
+@@ -582,7 +499,7 @@
+ /* <summary>                             */
+ /* Determine maximum computed resolution level for inverse wavelet transform */
+ /* </summary>                            */
+-static int dwt_decode_max_resolution(opj_tcd_resolution_t* r, int i) {
++static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
+ 	int mr	= 1;
+ 	int w;
+ 	while( --i ) {
+@@ -597,64 +514,312 @@
+ 
+ 
+ /* <summary>                            */
+-/* Inverse wavelet tranform in 2-D.     */
++/* Inverse wavelet transform in 2-D.     */
+ /* </summary>                           */
+-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop, DWT1DFN dwt_1D) {
+-	opj_tcd_resolution_t* tr;
+-	int i, j, k;
+-	int *a = NULL;
+-	int *aj = NULL;
+-	int w; //, l;
+-	int rw;			/* width of the resolution level computed  */
+-	int rh;			/* heigth of the resolution level computed  */
++static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
+ 	dwt_t h;
+ 	dwt_t v;
+-	
+-	if( 1 > ( i = tilec->numresolutions - stop ) )
+-		return ;
+ 
+-	tr = tilec->resolutions;
++	opj_tcd_resolution_t* tr = tilec->resolutions;
+ 
+-	w = tilec->x1-tilec->x0;
+-	a = tilec->data;
++	int rw = tr->x1 - tr->x0;	/* width of the resolution level computed */
++	int rh = tr->y1 - tr->y0;	/* height of the resolution level computed */
++
++	int w = tilec->x1 - tilec->x0;
+ 
+-	h.mem = (int*) opj_aligned_malloc(dwt_decode_max_resolution(tr, i) * sizeof(int));
++	h.mem = opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
+ 	v.mem = h.mem;
+ 
+-	rw = tr->x1 - tr->x0;
+-	rh = tr->y1 - tr->y0;
++	while( --numres) {
++		int * restrict tiledp = tilec->data;
++		int j;
+ 
+-	while( --i ) {
+-		tr++;
++		++tr;
+ 		h.sn = rw;
+ 		v.sn = rh;
+-		h.dn = ( rw = tr->x1 - tr->x0 ) - h.sn;
+-		v.dn = ( rh = tr->y1 - tr->y0 ) - v.sn;
+-				
++
++		rw = tr->x1 - tr->x0;
++		rh = tr->y1 - tr->y0;
++
++		h.dn = rw - h.sn;
+ 		h.cas = tr->x0 % 2;
+-		v.cas = tr->y0 % 2;
+ 
+-		aj = a;
+-		j = rh;
+-		while( j-- ) {		
+-			dwt_interleave_h(&h, aj);
++		for(j = 0; j < rh; ++j) {
++			dwt_interleave_h(&h, &tiledp[j*w]);
+ 			(dwt_1D)(&h);
+-			k = rw;
+-			while( k-- )
+-				aj[k] = h.mem[k];
+-			aj += w;
++			memcpy(&tiledp[j*w], h.mem, rw * sizeof(int));
+ 		}
+ 
+-		aj = a;
+-		j = rw;
+-		while( j-- ) {
+-			dwt_interleave_v(&v, aj, w);
++		v.dn = rh - v.sn;
++		v.cas = tr->y0 % 2;
++
++		for(j = 0; j < rw; ++j){
++			int k;
++			dwt_interleave_v(&v, &tiledp[j], w);
+ 			(dwt_1D)(&v);
+-			k = rh;
+-			while( k-- )
+-				aj[k * w] = v.mem[k];
+-			aj++;
++			for(k = 0; k < rh; ++k) {
++				tiledp[k * w + j] = v.mem[k];
++			}
+ 		}
+ 	}
+ 	opj_aligned_free(h.mem);
+ }
++
++static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
++	float* restrict bi = (float*) (w->wavelet + w->cas);
++	int count = w->sn;
++	int i, k;
++	for(k = 0; k < 2; ++k){
++		for(i = 0; i < count; ++i){
++			int j = i;
++			bi[i*8    ] = a[j];
++			j += x;
++			if(j > size) continue;
++			bi[i*8 + 1] = a[j];
++			j += x;
++			if(j > size) continue;
++			bi[i*8 + 2] = a[j];
++			j += x;
++			if(j > size) continue;
++			bi[i*8 + 3] = a[j];
++		}
++		bi = (float*) (w->wavelet + 1 - w->cas);
++		a += w->sn;
++		size -= w->sn;
++		count = w->dn;
++	}
++}
++
++static void v4dwt_interleave_v(v4dwt_t* restrict v , float* restrict a , int x){
++	v4* restrict bi = v->wavelet + v->cas;
++	int i;
++	for(i = 0; i < v->sn; ++i){
++		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
++	}
++	a += v->sn * x;
++	bi = v->wavelet + 1 - v->cas;
++	for(i = 0; i < v->dn; ++i){
++		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
++	}
++}
++
++#ifdef __SSE__
++
++static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
++	__m128* restrict vw = (__m128*) w;
++	int i;
++	for(i = 0; i < count; ++i){
++		__m128 tmp = vw[i*2];
++		vw[i*2] = tmp * c;
++	}
++}
++
++static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
++	__m128* restrict vl = (__m128*) l;
++	__m128* restrict vw = (__m128*) w;
++	int i;
++	for(i = 0; i < m; ++i){
++		__m128 tmp1 = vl[ 0];
++		__m128 tmp2 = vw[-1];
++		__m128 tmp3 = vw[ 0];
++		vw[-1] = tmp2 + ((tmp1 + tmp3) * c);
++		vl = vw;
++		vw += 2;
++	}
++	if(m >= k){
++		return;
++	}
++	c += c;
++	c *= vl[0];
++	for(; m < k; ++m){
++		__m128 tmp = vw[-1];
++		vw[-1] = tmp + c;
++		vw += 2;
++	}
++}
++
++#else
++
++static void v4dwt_decode_step1(v4* w, int count, const float c){
++	float* restrict fw = (float*) w;
++	int i;
++	for(i = 0; i < count; ++i){
++		float tmp1 = fw[i*8    ];
++		float tmp2 = fw[i*8 + 1];
++		float tmp3 = fw[i*8 + 2];
++		float tmp4 = fw[i*8 + 3];
++		fw[i*8    ] = tmp1 * c;
++		fw[i*8 + 1] = tmp2 * c;
++		fw[i*8 + 2] = tmp3 * c;
++		fw[i*8 + 3] = tmp4 * c;
++	}
++}
++
++static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
++	float* restrict fl = (float*) l;
++	float* restrict fw = (float*) w;
++	int i;
++	for(i = 0; i < m; ++i){
++		float tmp1_1 = fl[0];
++		float tmp1_2 = fl[1];
++		float tmp1_3 = fl[2];
++		float tmp1_4 = fl[3];
++		float tmp2_1 = fw[-4];
++		float tmp2_2 = fw[-3];
++		float tmp2_3 = fw[-2];
++		float tmp2_4 = fw[-1];
++		float tmp3_1 = fw[0];
++		float tmp3_2 = fw[1];
++		float tmp3_3 = fw[2];
++		float tmp3_4 = fw[3];
++		fw[-4] = tmp2_1 + ((tmp1_1 + tmp3_1) * c);
++		fw[-3] = tmp2_2 + ((tmp1_2 + tmp3_2) * c);
++		fw[-2] = tmp2_3 + ((tmp1_3 + tmp3_3) * c);
++		fw[-1] = tmp2_4 + ((tmp1_4 + tmp3_4) * c);
++		fl = fw;
++		fw += 8;
++	}
++	if(m < k){
++		float c1;
++		float c2;
++		float c3;
++		float c4;
++		c += c;
++		c1 = fl[0] * c;
++		c2 = fl[1] * c;
++		c3 = fl[2] * c;
++		c4 = fl[3] * c;
++		for(; m < k; ++m){
++			float tmp1 = fw[-4];
++			float tmp2 = fw[-3];
++			float tmp3 = fw[-2];
++			float tmp4 = fw[-1];
++			fw[-4] = tmp1 + c1;
++			fw[-3] = tmp2 + c2;
++			fw[-2] = tmp3 + c3;
++			fw[-1] = tmp4 + c4;
++			fw += 8;
++		}
++	}
++}
++
++#endif
++
++/* <summary>                             */
++/* Inverse 9-7 wavelet transform in 1-D. */
++/* </summary>                            */
++static void v4dwt_decode(v4dwt_t* restrict dwt){
++	int a, b;
++	if(dwt->cas == 0) {
++		if(!((dwt->dn > 0) || (dwt->sn > 1))){
++			return;
++		}
++		a = 0;
++		b = 1;
++	}else{
++		if(!((dwt->sn > 0) || (dwt->dn > 1))) {
++			return;
++		}
++		a = 1;
++		b = 0;
++	}
++#ifdef __SSE__
++	v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(K));
++	v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(c13318));
++	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(delta));
++	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(gamma));
++	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(beta));
++	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(alpha));
++#else
++	v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, K);
++	v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, c13318);
++	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), delta);
++	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), gamma);
++	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), beta);
++	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), alpha);
++#endif
++}
++
++/* <summary>                             */
++/* Inverse 9-7 wavelet transform in 2-D. */
++/* </summary>                            */
++void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
++	v4dwt_t h;
++	v4dwt_t v;
++
++	opj_tcd_resolution_t* res = tilec->resolutions;
++
++	int rw = res->x1 - res->x0;	/* width of the resolution level computed */
++	int rh = res->y1 - res->y0;	/* height of the resolution level computed */
++
++	int w = tilec->x1 - tilec->x0;
++
++	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
++	v.wavelet = h.wavelet;
++
++	while( --numres) {
++		float * restrict aj = (float*) tilec->data;
++		int bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
++		int j;
++
++		h.sn = rw;
++		v.sn = rh;
++
++		++res;
++
++		rw = res->x1 - res->x0;	/* width of the resolution level computed */
++		rh = res->y1 - res->y0;	/* height of the resolution level computed */
++
++		h.dn = rw - h.sn;
++		h.cas = res->x0 % 2;
++
++		for(j = rh; j > 0; j -= 4){
++			v4dwt_interleave_h(&h, aj, w, bufsize);
++			v4dwt_decode(&h);
++			if(j >= 4){
++				int k;
++				for(k = rw; --k >= 0;){
++					aj[k    ] = h.wavelet[k].f[0];
++					aj[k+w  ] = h.wavelet[k].f[1];
++					aj[k+w*2] = h.wavelet[k].f[2];
++					aj[k+w*3] = h.wavelet[k].f[3];
++				}
++			}else{
++				int k;
++				for(k = rw; --k >= 0;){
++					switch(j) {
++						case 3: aj[k+w*2] = h.wavelet[k].f[2];
++						case 2: aj[k+w  ] = h.wavelet[k].f[1];
++						case 1: aj[k    ] = h.wavelet[k].f[0];
++					}
++				}
++			}
++			aj += w*4;
++			bufsize -= w*4;
++		}
++
++		v.dn = rh - v.sn;
++		v.cas = res->y0 % 2;
++
++		aj = (float*) tilec->data;
++		for(j = rw; j > 0; j -= 4){
++			v4dwt_interleave_v(&v, aj, w);
++			v4dwt_decode(&v);
++			if(j >= 4){
++				int k;
++				for(k = 0; k < rh; ++k){
++					memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(float));
++				}
++			}else{
++				int k;
++				for(k = 0; k < rh; ++k){
++					memcpy(&aj[k*w], &v.wavelet[k], j * sizeof(float));
++				}
++			}
++			aj += 4;
++		}
++	}
++
++	opj_aligned_free(h.wavelet);
++}
++
+diff -urN -x.svn ../trunk.orig/libopenjpeg/dwt.h ./libopenjpeg/dwt.h
+--- ../trunk.orig/libopenjpeg/dwt.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/dwt.h	2007-11-27 22:39:50.000000000 +0000
+@@ -57,9 +57,9 @@
+ Inverse 5-3 wavelet tranform in 2-D.
+ Apply a reversible inverse DWT transform to a component of an image.
+ @param tilec Tile component information (current tile)
+-@param stop FIXME Number of decoded resolution levels ?
++@param numres Number of resolution levels to decode
+ */
+-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop);
++void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
+ /**
+ Get the gain of a subband for the reversible 5-3 DWT.
+ @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
+@@ -83,9 +83,9 @@
+ Inverse 9-7 wavelet transform in 2-D. 
+ Apply an irreversible inverse DWT transform to a component of an image.
+ @param tilec Tile component information (current tile)
+-@param stop FIXME Number of decoded resolution levels ?
++@param numres Number of resolution levels to decode
+ */
+-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop);
++void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
+ /**
+ Get the gain of a subband for the irreversible 9-7 DWT.
+ @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
+@@ -100,9 +100,9 @@
+ */
+ double dwt_getnorm_real(int level, int orient);
+ /**
+-FIXME : comment ???
+-@param tccp
+-@param prec
++Explicit calculation of the Quantization Stepsizes 
++@param tccp Tile-component coding parameters
++@param prec Precint analyzed
+ */
+ void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
+ /* ----------------------------------------------------------------------- */
+diff -urN -x.svn ../trunk.orig/libopenjpeg/image.c ./libopenjpeg/image.c
+--- ../trunk.orig/libopenjpeg/image.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/image.c	2007-11-27 22:39:50.000000000 +0000
+@@ -35,7 +35,7 @@
+ 	int compno;
+ 	opj_image_t *image = NULL;
+ 
+-	image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
++	image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));
+ 	if(image) {
+ 		image->color_space = clrspc;
+ 		image->numcomps = numcmpts;
+@@ -58,7 +58,7 @@
+ 			comp->prec = cmptparms[compno].prec;
+ 			comp->bpp = cmptparms[compno].bpp;
+ 			comp->sgnd = cmptparms[compno].sgnd;
+-			comp->data = (int*)opj_malloc(comp->w * comp->h * sizeof(int));
++			comp->data = (int*) opj_calloc(comp->w * comp->h, sizeof(int));
+ 			if(!comp->data) {
+ 				fprintf(stderr,"Unable to allocate memory for image.\n");
+ 				opj_image_destroy(image);
+diff -urN -x.svn ../trunk.orig/libopenjpeg/j2k.c ./libopenjpeg/j2k.c
+--- ../trunk.orig/libopenjpeg/j2k.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/j2k.c	2007-11-27 22:39:50.000000000 +0000
+@@ -259,13 +259,13 @@
+ }
+ 
+ static void j2k_check_poc_val(opj_cparameters_t *parameters, int numcomps, int numlayers){
++	int* packet_array;
+ 	int index, resno, compno, layno, i;
+-	char loss = 0;
+ 	int step_c = 1;
+ 	int step_r = numcomps * step_c;
+ 	int step_l = parameters->numresolution * step_r;
+-	int array_size = step_l * numlayers * sizeof(int);
+-	int *packet_array = (int *) opj_malloc(array_size);
++	bool loss = false;
++	packet_array = (int*) opj_calloc(step_l * numlayers, sizeof(int));
+ 	
+ 	for (i = 0; i < parameters->numpocs ; i++) {
+ 		int layno0 = 0;
+@@ -285,12 +285,12 @@
+ 			for (layno = 0; layno < numlayers ; layno++) {
+ 				index = step_r * resno + step_c * compno + step_l * layno;
+ 				if(!(	packet_array[index]== 1)){
+-					loss = 1;
++					loss = true;
+ 				}
+ 			}
+ 		}
+ 	}
+-	if(loss == 1)
++	if(loss)
+ 		fprintf(stdout,"Missing packets possible loss of data\n");
+ 	opj_free(packet_array);
+ }
+@@ -406,7 +406,7 @@
+ 
+ /**	mem allocation for TLM marker*/
+ int j2k_calculate_tp(opj_cp_t *cp,int img_numcomp,opj_image_t *image,opj_j2k_t *j2k ){
+-	int pino,tileno,maxres=0,totnum_tp=0;
++	int pino,tileno,totnum_tp=0;
+ 	j2k->cur_totnum_tp = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+ 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+ 		int cur_totnum_tp = 0;
+@@ -434,6 +434,15 @@
+ static void j2k_write_soc(opj_j2k_t *j2k) {
+ 	opj_cio_t *cio = j2k->cio;
+ 	cio_write(cio, J2K_MS_SOC, 2);
++
++/* UniPG>> */
++#ifdef USE_JPWL
++
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio) - 2, 2);
++
++#endif /* USE_JPWL */
++/* <<UniPG */
+ }
+ 
+ static void j2k_read_soc(opj_j2k_t *j2k) {	
+@@ -536,7 +545,7 @@
+ 	}
+ #endif /* USE_JPWL */
+ 
+-	image->comps = (opj_image_comp_t *) opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
++	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
+ 	for (i = 0; i < image->numcomps; i++) {
+ 		int tmp, w, h;
+ 		tmp = cio_read(cio, 1);		/* Ssiz_i */
+@@ -579,7 +588,7 @@
+ 		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);
+ 
+ 		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
+-		image->comps[i].factor = 0;			/* reducing factor per component */
++		image->comps[i].factor = cp->reduce; /* reducing factor per component */
+ 	}
+ 	
+ 	cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
+@@ -625,8 +634,8 @@
+ 	}
+ #endif /* USE_JPWL */
+ 
+-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
+-	cp->tileno = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
++	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
++	cp->tileno = (int*) opj_malloc(cp->tw * cp->th * sizeof(int));
+ 	cp->tileno_size = 0;
+ 	
+ #ifdef USE_JPWL
+@@ -654,13 +663,13 @@
+ 	cp->ppm_data_first = NULL;
+ 	cp->ppm_previous = 0;
+ 	cp->ppm_store = 0;
+-	
+-	j2k->default_tcp->tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
++
++	j2k->default_tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+ 	for (i = 0; i < cp->tw * cp->th; i++) {
+-		cp->tcps[i].tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
+-	}
+-	j2k->tile_data = (unsigned char **) opj_malloc(cp->tw * cp->th * sizeof(unsigned char *));
+-	j2k->tile_len = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
++		cp->tcps[i].tccps = (opj_tccp_t*) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
++	}	
++	j2k->tile_data = (unsigned char**) opj_calloc(cp->tw * cp->th, sizeof(unsigned char*));
++	j2k->tile_len = (int*) opj_calloc(cp->tw * cp->th, sizeof(int));
+ 	j2k->state = J2K_STATE_MH;
+ 
+ 	/* Index */
+@@ -675,7 +684,7 @@
+ 		cstr_info->tile_y = cp->tdy;	
+ 		cstr_info->tile_Ox = cp->tx0;	
+ 		cstr_info->tile_Oy = cp->ty0;			
+-		cstr_info->tile = (opj_tile_info_t*) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));		
++		cstr_info->tile = (opj_tile_info_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tile_info_t));		
+ 	}
+ }
+ 
+@@ -741,8 +750,13 @@
+ 
+ 	tccp->numresolutions = cio_read(cio, 1) + 1;	/* SPcox (D) */
+ 
+-	/* check the reduce value */
+-	cp->reduce = int_min((tccp->numresolutions)-1, cp->reduce);
++	// If user wants to remove more resolutions than the codestream contains, return error
++	if (cp->reduce >= tccp->numresolutions) {
++		opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
++					"of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
++		j2k->state |= J2K_STATE_ERR;
++	}
++
+ 	tccp->cblkw = cio_read(cio, 1) + 2;	/* SPcox (E) */
+ 	tccp->cblkh = cio_read(cio, 1) + 2;	/* SPcox (F) */
+ 	tccp->cblksty = cio_read(cio, 1);	/* SPcox (G) */
+@@ -824,7 +838,7 @@
+ 		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+ 		cstr_info->prog = tcp->prg;
+ 		cstr_info->numlayers = tcp->numlayers;
+-		cstr_info->numdecompos = (int*) malloc (image->numcomps * sizeof(int));
++		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+ 		for (i = 0; i < image->numcomps; i++) {
+ 			cstr_info->numdecompos[i] = tcp->tccps[i].numresolutions - 1;
+ 		}
+@@ -1069,7 +1083,6 @@
+ 	
+ 	opj_cp_t *cp = j2k->cp;
+ 	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+-	opj_tccp_t *tccp = &tcp->tccps[0];
+ 	opj_cio_t *cio = j2k->cio;
+ 	
+ 	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
+@@ -1200,7 +1213,7 @@
+ 						"JPWL: failed memory allocation during PPM marker parsing (pos. %x)\n",
+ 						cio_tell(cio));
+ 					if (!JPWL_ASSUME || JPWL_ASSUME) {
+-						free(cp->ppm_data);
++						opj_free(cp->ppm_data);
+ 						opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+ 						return;
+ 					}
+@@ -1280,6 +1293,13 @@
+ 	cio_seek(cio, lenp);
+ 	cio_write(cio, len, 2);				/* Lsot */
+ 	cio_seek(cio, lenp + len);
++
++	/* UniPG>> */
++#ifdef USE_JPWL
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_SOT, j2k->sot_start, len + 2);
++#endif /* USE_JPWL */
++	/* <<UniPG */
+ }
+ 
+ static void j2k_read_sot(opj_j2k_t *j2k) {
+@@ -1437,6 +1457,12 @@
+ 			if(cstr_info->tile[j2k->curtileno].packet[cstr_info->packno - 1].end_pos < cio_tell(cio))
+ 				cstr_info->tile[j2k->curtileno].packet[cstr_info->packno].start_pos = cio_tell(cio);
+ 		}
++		/* UniPG>> */
++#ifdef USE_JPWL
++		/* update markers struct */
++		j2k_add_marker(j2k->cstr_info, J2K_MS_SOD, j2k->sod_start, 2);
++#endif /* USE_JPWL */
++		/* <<UniPG */
+ 	}
+ 	/* << INDEX */
+ 	
+@@ -1488,11 +1514,8 @@
+ 		truncate = 1;		/* Case of a truncate codestream */
+ 	}	
+ 
+-	data = (unsigned char *) opj_malloc((j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
+-
+-	for (i = 0; i < j2k->tile_len[curtileno]; i++) {
+-		data[i] = j2k->tile_data[curtileno][i];
+-	}
++	data = j2k->tile_data[curtileno];
++	data = (unsigned char*) opj_realloc(data, (j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
+ 
+ 	data_ptr = data + j2k->tile_len[curtileno];
+ 	for (i = 0; i < len; i++) {
+@@ -1500,7 +1523,6 @@
+ 	}
+ 
+ 	j2k->tile_len[curtileno] += len;
+-	opj_free(j2k->tile_data[curtileno]);
+ 	j2k->tile_data[curtileno] = data;
+ 	
+ 	if (!truncate) {
+@@ -1558,10 +1580,18 @@
+ 	opj_cio_t *cio = j2k->cio;
+ 	/* opj_event_msg(j2k->cinfo, "%.8x: EOC\n", cio_tell(cio) + j2k->pos_correction); */
+ 	cio_write(cio, J2K_MS_EOC, 2);
++
++/* UniPG>> */
++#ifdef USE_JPWL
++	/* update markers struct */
++	j2k_add_marker(j2k->cstr_info, J2K_MS_EOC, cio_tell(cio) - 2, 2);
++#endif /* USE_JPWL */
++/* <<UniPG */
+ }
+ 
+ static void j2k_read_eoc(opj_j2k_t *j2k) {
+ 	int i, tileno;
++	bool success;
+ 
+ 	/* if packets should be decoded */
+ 	if (j2k->cp->limit_decoding != DECODE_ALL_BUT_PACKETS) {
+@@ -1570,10 +1600,14 @@
+ 		for (i = 0; i < j2k->cp->tileno_size; i++) {
+ 			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
+ 			tileno = j2k->cp->tileno[i];
+-			tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
++			success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
+ 			opj_free(j2k->tile_data[tileno]);
+ 			j2k->tile_data[tileno] = NULL;
+ 			tcd_free_decode_tile(tcd, i);
++			if (success == false) {
++				j2k->state |= J2K_STATE_ERR;
++				break;
++			}
+ 		}
+ 		tcd_free_decode(tcd);
+ 		tcd_destroy(tcd);
+@@ -1586,7 +1620,10 @@
+ 			j2k->tile_data[tileno] = NULL;
+ 		}
+ 	}	
+-	j2k->state = J2K_STATE_MT;
++	if (j2k->state & J2K_STATE_ERR)
++		j2k->state = J2K_STATE_MT + J2K_STATE_ERR;
++	else
++		j2k->state = J2K_STATE_MT; 
+ }
+ 
+ typedef struct opj_dec_mstabent {
+@@ -1714,15 +1751,19 @@
+ /* ----------------------------------------------------------------------- */
+ 
+ opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo) {
+-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
+-	if(j2k) {
+-		j2k->cinfo = cinfo;
+-		j2k->default_tcp = (opj_tcp_t*)opj_malloc(sizeof(opj_tcp_t));
+-		if(!j2k->default_tcp) {
+-			opj_free(j2k);
+-			return NULL;
+-		}
++	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
++	if(!j2k)
++		return NULL;
++
++	j2k->default_tcp = (opj_tcp_t*) opj_calloc(1, sizeof(opj_tcp_t));
++	if(!j2k->default_tcp) {
++		opj_free(j2k);
++		return NULL;
+ 	}
++
++	j2k->cinfo = cinfo;
++	j2k->tile_data = NULL;
++
+ 	return j2k;
+ }
+ 
+@@ -1776,7 +1817,7 @@
+ void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters) {
+ 	if(j2k && parameters) {
+ 		/* create and initialize the coding parameters structure */
+-		opj_cp_t *cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
++		opj_cp_t *cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
+ 		cp->reduce = parameters->cp_reduce;	
+ 		cp->layer = parameters->cp_layer;
+ 		cp->limit_decoding = parameters->cp_limit_decoding;
+@@ -1872,6 +1913,9 @@
+ 		if (e->handler) {
+ 			(*e->handler)(j2k);
+ 		}
++		if (j2k->state & J2K_STATE_ERR) 
++			return NULL;	
++
+ 		if (j2k->state == J2K_STATE_MT) {
+ 			break;
+ 		}
+@@ -1978,7 +2022,7 @@
+ /* ----------------------------------------------------------------------- */
+ 
+ opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo) {
+-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
++	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
+ 	if(j2k) {
+ 		j2k->cinfo = cinfo;
+ 	}
+@@ -2017,7 +2061,7 @@
+ 	}
+ 
+ 	/* create and initialize the coding parameters structure */
+-	cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
++	cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
+ 
+ 	/* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
+ 	j2k->cp = cp;
+@@ -2141,7 +2185,7 @@
+ 
+ 	/* initialize the mutiple tiles */
+ 	/* ---------------------------- */
+-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
++	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+ 
+ 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+ 		opj_tcp_t *tcp = &cp->tcps[tileno];
+@@ -2188,8 +2232,8 @@
+ 			tcp->numpocs = 0;
+ 		}
+ 
+-		tcp->tccps = (opj_tccp_t *) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
+-		
++		tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
++
+ 		for (i = 0; i < image->numcomps; i++) {
+ 			opj_tccp_t *tccp = &tcp->tccps[i];
+ 			tccp->csty = parameters->csty & 0x01;	/* 0 => one precinct || 1 => custom precinct  */
+@@ -2273,10 +2317,6 @@
+ 
+ 	opj_tcd_t *tcd = NULL;	/* TCD component */
+ 
+-	/* UniPG>> */
+-	int acc_pack_num = 0;
+-	/* <<UniPG */
+-
+ 	j2k->cio = cio;	
+ 	j2k->image = image;
+ 
+@@ -2300,12 +2340,15 @@
+ 		cstr_info->tile_Oy = cp->ty0;	/* new version parser */
+ 		cstr_info->numcomps = image->numcomps;
+ 		cstr_info->numlayers = (&cp->tcps[0])->numlayers;
+-		cstr_info->numdecompos = (int*) malloc (image->numcomps * sizeof(int));
++		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+ 		for (compno=0; compno < image->numcomps; compno++) {
+ 			cstr_info->numdecompos[compno] = (&cp->tcps[0])->tccps->numresolutions - 1;
+ 		}
+-		cstr_info->D_max = 0;		/* ADD Marcela */
++		cstr_info->D_max = 0.0;		/* ADD Marcela */
+ 		cstr_info->main_head_start = cio_tell(cio); /* position of SOC */
++		cstr_info->maxmarknum = 100;
++		cstr_info->marker = (opj_marker_info_t *) opj_malloc(cstr_info->maxmarknum * sizeof(opj_marker_info_t));
++		cstr_info->marknum = 0;
+ 	}
+ 	/* << INDEX */
+ 
+@@ -2356,6 +2399,10 @@
+ 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+ 		int pino;
+ 		int tilepartno=0;
++		/* UniPG>> */
++		int acc_pack_num = 0;
++		/* <<UniPG */
++
+ 
+ 		opj_tcp_t *tcp = &cp->tcps[tileno];
+ 		opj_event_msg(j2k->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
+@@ -2415,6 +2462,8 @@
+ 				if(cstr_info) {
+ 					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_pos =
+ 						cio_tell(cio) + j2k->pos_correction - 1;
++					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pack =
++						acc_pack_num;
+ 					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_numpacks =
+ 						cstr_info->packno - acc_pack_num;
+ 					acc_pack_num = cstr_info->packno;
+@@ -2451,7 +2500,7 @@
+ 	tcd_free_encode(tcd);
+ 	tcd_destroy(tcd);
+ 
+-	free(j2k->cur_totnum_tp);
++	opj_free(j2k->cur_totnum_tp);
+ 
+ 	j2k_write_eoc(j2k);
+ 
+diff -urN -x.svn ../trunk.orig/libopenjpeg/j2k.h ./libopenjpeg/j2k.h
+--- ../trunk.orig/libopenjpeg/j2k.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/j2k.h	2007-11-27 22:39:50.000000000 +0000
+@@ -104,7 +104,8 @@
+ 	J2K_STATE_TPHSOT = 0x0008, /**< the decoding process is in a tile part header and expects a SOT marker */
+ 	J2K_STATE_TPH    = 0x0010, /**< the decoding process is in a tile part header */
+ 	J2K_STATE_MT     = 0x0020, /**< the EOC marker has just been read */
+-	J2K_STATE_NEOC   = 0x0040  /**< the decoding process must not expect a EOC marker because the codestream is truncated */
++	J2K_STATE_NEOC   = 0x0040, /**< the decoding process must not expect a EOC marker because the codestream is truncated */
++	J2K_STATE_ERR    = 0x0080  /**< the decoding process has encountered an error */
+ } J2K_STATUS;
+ 
+ /* ----------------------------------------------------------------------- */
+diff -urN -x.svn ../trunk.orig/libopenjpeg/j2k_lib.c ./libopenjpeg/j2k_lib.c
+--- ../trunk.orig/libopenjpeg/j2k_lib.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/j2k_lib.c	2007-11-27 22:39:50.000000000 +0000
+@@ -57,20 +57,3 @@
+ #endif
+ }
+ 
+-void* opj_malloc( size_t size ) {
+-	void *memblock = malloc(size);
+-	if(memblock) {
+-		memset(memblock, 0, size);
+-	}
+-	return memblock;
+-}
+-
+-void* opj_realloc( void *memblock, size_t size ) {
+-	return realloc(memblock, size);
+-}
+-
+-void opj_free( void *memblock ) {
+-	free(memblock);	
+-}
+-
+-
+diff -urN -x.svn ../trunk.orig/libopenjpeg/j2k_lib.h ./libopenjpeg/j2k_lib.h
+--- ../trunk.orig/libopenjpeg/j2k_lib.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/j2k_lib.h	2007-11-27 22:39:50.000000000 +0000
+@@ -29,13 +29,9 @@
+ @file j2k_lib.h
+ @brief Internal functions
+ 
+-The functions in J2K_LIB.C are internal utilities mainly used for memory management.
++The functions in J2K_LIB.C are internal utilities mainly used for timing.
+ */
+ 
+-#ifndef __GNUC__
+-#define __attribute__(x) /* */
+-#endif
+-
+ /** @defgroup MISC MISC - Miscellaneous internal functions */
+ /*@{*/
+ 
+@@ -49,71 +45,6 @@
+ */
+ double opj_clock(void);
+ 
+-/**
+-Allocate a memory block with elements initialized to 0
+-@param size Bytes to allocate
+-@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+-*/
+-void* __attribute__ ((malloc)) opj_malloc( size_t size );
+-
+-/**
+-Allocate memory aligned to a 16 byte boundry
+-@param size Bytes to allocate
+-@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+-*/
+-#ifdef WIN32
+-
+-#ifdef __GNUC__
+-#include <mm_malloc.h>
+-#else /* MSVC, Intel C++ */
+-#include <malloc.h>
+-#endif
+-
+-#ifdef _mm_malloc
+-  #define opj_aligned_malloc(size) _mm_malloc(size, 16)
+-  #else
+-  #define opj_aligned_malloc(size) malloc(size)
+- #endif
+- 
+- #ifdef _mm_free
+-  #define opj_aligned_free(m) _mm_free(m)
+-  #else
+-  #define opj_aligned_free(m) free(m)
+- #endif
+-
+-#else /* Not WIN32 */
+-
+-/* Linux x86_64 and OSX always align allocations to 16 bytes */
+-#if defined(__amd64__) || defined(__APPLE__)
+-#define opj_aligned_malloc(size) malloc(size)
+-#else
+-extern int posix_memalign (void **, size_t, size_t);
+-
+-static INLINE void* __attribute__ ((malloc)) opj_aligned_malloc(size_t size){
+-	void* mem = NULL;
+-	posix_memalign(&mem, 16, size);
+-	return mem;
+-}
+-#endif
+-
+-#define opj_aligned_free(m) free(m)
+-
+-#endif
+-
+-/**
+-Reallocate memory blocks.
+-@param memblock Pointer to previously allocated memory block
+-@param size New size in bytes
+-@return Returns a void pointer to the reallocated (and possibly moved) memory block
+-*/
+-void* __attribute__ ((malloc)) opj_realloc( void *memblock, size_t size );
+-
+-/**
+-Deallocates or frees a memory block.
+-@param memblock Previously allocated memory block to be freed
+-*/
+-void opj_free( void *memblock );
+-
+ /* ----------------------------------------------------------------------- */
+ /*@}*/
+ 
+diff -urN -x.svn ../trunk.orig/libopenjpeg/jp2.c ./libopenjpeg/jp2.c
+--- ../trunk.orig/libopenjpeg/jp2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/jp2.c	2007-11-27 22:39:50.000000000 +0000
+@@ -507,7 +507,7 @@
+ /* ----------------------------------------------------------------------- */
+ 
+ opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo) {
+-	opj_jp2_t *jp2 = (opj_jp2_t*)opj_malloc(sizeof(opj_jp2_t));
++	opj_jp2_t *jp2 = (opj_jp2_t*) opj_calloc(1, sizeof(opj_jp2_t));
+ 	if(jp2) {
+ 		jp2->cinfo = cinfo;
+ 		/* create the J2K codec */
+diff -urN -x.svn ../trunk.orig/libopenjpeg/mct.c ./libopenjpeg/mct.c
+--- ../trunk.orig/libopenjpeg/mct.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/mct.c	2007-11-27 22:39:50.000000000 +0000
+@@ -44,16 +44,20 @@
+ /* <summary> */
+ /* Foward reversible MCT. */
+ /* </summary> */
+-void mct_encode(int *c0, int *c1, int *c2, int n) {
++void mct_encode(
++		int* restrict c0,
++		int* restrict c1,
++		int* restrict c2,
++		int n)
++{
+ 	int i;
+-	for (i = 0; i < n; i++) {
+-		int r, g, b, y, u, v;
+-		r = c0[i];
+-		g = c1[i];
+-		b = c2[i];
+-		y = (r + (g << 1) + b) >> 2;
+-		u = b - g;
+-		v = r - g;
++	for(i = 0; i < n; ++i) {
++		int r = c0[i];
++		int g = c1[i];
++		int b = c2[i];
++		int y = (r + (g * 2) + b) >> 2;
++		int u = b - g;
++		int v = r - g;
+ 		c0[i] = y;
+ 		c1[i] = u;
+ 		c2[i] = v;
+@@ -63,16 +67,20 @@
+ /* <summary> */
+ /* Inverse reversible MCT. */
+ /* </summary> */
+-void mct_decode(int *c0, int *c1, int *c2, int n) {
++void mct_decode(
++		int* restrict c0,
++		int* restrict c1, 
++		int* restrict c2, 
++		int n)
++{
+ 	int i;
+-	for (i = 0; i < n; i++) {
+-		int y, u, v, r, g, b;
+-		y = c0[i];
+-		u = c1[i];
+-		v = c2[i];
+-		g = y - ((u + v) >> 2);
+-		r = v + g;
+-		b = u + g;
++	for (i = 0; i < n; ++i) {
++		int y = c0[i];
++		int u = c1[i];
++		int v = c2[i];
++		int g = y - ((u + v) >> 2);
++		int r = v + g;
++		int b = u + g;
+ 		c0[i] = r;
+ 		c1[i] = g;
+ 		c2[i] = b;
+@@ -89,16 +97,20 @@
+ /* <summary> */
+ /* Foward irreversible MCT. */
+ /* </summary> */
+-void mct_encode_real(int *c0, int *c1, int *c2, int n) {
++void mct_encode_real(
++		int* restrict c0,
++		int* restrict c1,
++		int* restrict c2,
++		int n)
++{
+ 	int i;
+-	for (i = 0; i < n; i++) {
+-		int r, g, b, y, u, v;
+-		r = c0[i];
+-		g = c1[i];
+-		b = c2[i];
+-		y = fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
+-		u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
+-		v = fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
++	for(i = 0; i < n; ++i) {
++		int r = c0[i];
++		int g = c1[i];
++		int b = c2[i];
++		int y =  fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
++		int u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
++		int v =  fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+ 		c0[i] = y;
+ 		c1[i] = u;
+ 		c2[i] = v;
+@@ -108,16 +120,20 @@
+ /* <summary> */
+ /* Inverse irreversible MCT. */
+ /* </summary> */
+-void mct_decode_real(int *c0, int *c1, int *c2, int n) {
++void mct_decode_real(
++		float* restrict c0,
++		float* restrict c1,
++		float* restrict c2,
++		int n)
++{
+ 	int i;
+-	for (i = 0; i < n; i++) {
+-		int y, u, v, r, g, b;
+-		y = c0[i];
+-		u = c1[i];
+-		v = c2[i];
+-		r = y + fix_mul(v, 11485);
+-		g = y - fix_mul(u, 2819) - fix_mul(v, 5850);
+-		b = y + fix_mul(u, 14516);
++	for(i = 0; i < n; ++i) {
++		float y = c0[i];
++		float u = c1[i];
++		float v = c2[i];
++		float r = y + (v * 1.402f);
++		float g = y - (u * 0.34413f) - (v * (0.71414f));
++		float b = y + (u * 1.772f);
+ 		c0[i] = r;
+ 		c1[i] = g;
+ 		c2[i] = b;
+diff -urN -x.svn ../trunk.orig/libopenjpeg/mct.h ./libopenjpeg/mct.h
+--- ../trunk.orig/libopenjpeg/mct.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/mct.h	2007-11-27 22:39:50.000000000 +0000
+@@ -83,7 +83,7 @@
+ @param c2 Samples for blue chrominance component
+ @param n Number of samples for each component
+ */
+-void mct_decode_real(int *c0, int *c1, int *c2, int n);
++void mct_decode_real(float* c0, float* c1, float* c2, int n);
+ /**
+ Get norm of the basis function used for the irreversible multi-component transform
+ @param compno Number of the component (0->Y, 1->U, 2->V)
+diff -urN -x.svn ../trunk.orig/libopenjpeg/openjpeg.c ./libopenjpeg/openjpeg.c
+--- ../trunk.orig/libopenjpeg/openjpeg.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/openjpeg.c	2007-11-27 22:39:50.000000000 +0000
+@@ -324,5 +324,6 @@
+ 			opj_free(tile_info->tp);
+ 		}
+ 		opj_free(cstr_info->tile);
++		opj_free(cstr_info->marker);
+ 	}
+ }
+diff -urN -x.svn ../trunk.orig/libopenjpeg/openjpeg.h ./libopenjpeg/openjpeg.h
+--- ../trunk.orig/libopenjpeg/openjpeg.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/openjpeg.h	2007-11-27 22:39:50.000000000 +0000
+@@ -303,6 +303,10 @@
+ 	char infile[OPJ_PATH_LEN];
+ 	/** output file name */
+ 	char outfile[OPJ_PATH_LEN];
++	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
++	int index_on;
++	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
++	char index[OPJ_PATH_LEN];
+ 	/** subimage encoding: origin image offset in x direction */
+ 	int image_offset_x0;
+ 	/** subimage encoding: origin image offset in y direction */
+@@ -486,7 +490,7 @@
+ 	/** pointer to the start of the buffer */
+ 	unsigned char *buffer;
+ 	/** buffer size in bytes */
+-	unsigned int length;
++	int length;
+ 
+ 	/** pointer to the start of the stream */
+ 	unsigned char *start;
+@@ -606,6 +610,8 @@
+ 	int tp_end_header;
+ 	/** end position of tile part */
+ 	int tp_end_pos;
++	/** start packet of tile part */
++	int tp_start_pack;
+ 	/** number of packets of tile part */
+ 	int tp_numpacks;
+ } opj_tp_info_t;
+@@ -697,6 +703,8 @@
+ 	int marknum;
+ 	/** list of markers */
+ 	opj_marker_info_t *marker;
++	/** actual size of markers array */
++	int maxmarknum;
+ /* <<UniPG */
+ 	/** main header position */
+ 	int main_head_start;
+diff -urN -x.svn ../trunk.orig/libopenjpeg/opj_includes.h ./libopenjpeg/opj_includes.h
+--- ../trunk.orig/libopenjpeg/opj_includes.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/opj_includes.h	2007-11-27 22:39:50.000000000 +0000
+@@ -54,6 +54,11 @@
+  ==========================================================
+ */
+ 
++/* Ignore GCC attributes if this is not GCC */
++#ifndef __GNUC__
++	#define __attribute__(x) /* __attribute__(x) */
++#endif
++
+ /*
+ The inline keyword is supported by C99 but not by C90. 
+ Most compilers implement their own version of this keyword ... 
+@@ -71,7 +76,32 @@
+ 	#endif /* defined(<Compiler>) */
+ #endif /* INLINE */
+ 
++/* Are restricted pointers available? (C99) */
++#if (__STDC_VERSION__ != 199901L)
++	/* Not a C99 compiler */
++	#ifdef __GNUC__
++		#define restrict __restrict__
++	#else
++		#define restrict /* restrict */
++	#endif
++#endif
++
++/* MSVC does not have lrintf */
++#ifdef _MSC_VER
++static INLINE long lrintf(float f){
++	int i;
++
++	_asm{
++		fld f
++		fistp i
++	};
++
++	return i;
++}
++#endif
++
+ #include "j2k_lib.h"
++#include "opj_malloc.h"
+ #include "event.h"
+ #include "cio.h"
+ 
+diff -urN -x.svn ../trunk.orig/libopenjpeg/opj_malloc.h ./libopenjpeg/opj_malloc.h
+--- ../trunk.orig/libopenjpeg/opj_malloc.h	1970-01-01 01:00:00.000000000 +0100
++++ ./libopenjpeg/opj_malloc.h	2007-11-27 22:39:50.000000000 +0000
+@@ -0,0 +1,140 @@
++/*
++ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
++ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++#ifndef __OPJ_MALLOC_H
++#define __OPJ_MALLOC_H
++/**
++@file opj_malloc.h
++@brief Internal functions
++
++The functions in opj_malloc.h are internal utilities used for memory management.
++*/
++
++/** @defgroup MISC MISC - Miscellaneous internal functions */
++/*@{*/
++
++/** @name Exported functions */
++/*@{*/
++/* ----------------------------------------------------------------------- */
++
++/**
++Allocate an uninitialized memory block
++@param size Bytes to allocate
++@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
++*/
++#define opj_malloc(size) malloc(size)
++
++/**
++Allocate a memory block with elements initialized to 0
++@param num Blocks to allocate
++@param size Bytes per block to allocate
++@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
++*/
++#define opj_calloc(num, size) calloc(num, size)
++
++/**
++Allocate memory aligned to a 16 byte boundry
++@param size Bytes to allocate
++@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
++*/
++/* FIXME: These should be set with cmake tests, but we're currently not requiring use of cmake */
++#ifdef WIN32
++	/* Someone should tell the mingw people that their malloc.h ought to provide _mm_malloc() */
++	#ifdef __GNUC__
++		#include <mm_malloc.h>
++		#define HAVE_MM_MALLOC
++	#else /* MSVC, Intel C++ */
++		#include <malloc.h>
++		#ifdef _mm_malloc
++			#define HAVE_MM_MALLOC
++		#endif
++	#endif
++#else /* Not WIN32 */
++	#if defined(__sun)
++		#define HAVE_MEMALIGN
++	/* Linux x86_64 and OSX always align allocations to 16 bytes */
++	#elif !defined(__amd64__) && !defined(__APPLE__)
++		/* FIXME: Yes, this is a big assumption */
++		#define HAVE_POSIX_MEMALIGN
++	#endif
++#endif
++
++#define opj_aligned_malloc(size) malloc(size)
++#define opj_aligned_free(m) free(m)
++
++#ifdef HAVE_MM_MALLOC
++	#undef opj_aligned_malloc
++	#define opj_aligned_malloc(size) _mm_malloc(size, 16)
++	#undef opj_aligned_free
++	#define opj_aligned_free(m) _mm_free(m)
++#endif
++
++#ifdef HAVE_MEMALIGN
++	extern void* memalign(size_t, size_t);
++	#undef opj_aligned_malloc
++	#define opj_aligned_malloc(size) memalign(16, (size))
++	#undef opj_aligned_free
++	#define opj_aligned_free(m) free(m)
++#endif
++
++#ifdef HAVE_POSIX_MEMALIGN
++	#undef opj_aligned_malloc
++	extern int posix_memalign(void**, size_t, size_t);
++
++	static INLINE void* __attribute__ ((malloc)) opj_aligned_malloc(size_t size){
++		void* mem = NULL;
++		posix_memalign(&mem, 16, size);
++		return mem;
++	}
++	#undef opj_aligned_free
++	#define opj_aligned_free(m) free(m)
++#endif
++
++/**
++Reallocate memory blocks.
++@param memblock Pointer to previously allocated memory block
++@param size New size in bytes
++@return Returns a void pointer to the reallocated (and possibly moved) memory block
++*/
++#define opj_realloc(m, s) realloc(m, s)
++
++/**
++Deallocates or frees a memory block.
++@param memblock Previously allocated memory block to be freed
++*/
++#define opj_free(m) free(m)
++
++#ifdef __GNUC__
++#pragma GCC poison malloc calloc realloc free
++#endif
++
++/* ----------------------------------------------------------------------- */
++/*@}*/
++
++/*@}*/
++
++#endif /* __OPJ_MALLOC_H */
++
+diff -urN -x.svn ../trunk.orig/libopenjpeg/pi.c ./libopenjpeg/pi.c
+--- ../trunk.orig/libopenjpeg/pi.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/pi.c	2007-11-27 22:39:50.000000000 +0000
+@@ -413,17 +413,15 @@
+ 	opj_pi_iterator_t *pi = NULL;
+ 	opj_tcp_t *tcp = NULL;
+ 	opj_tccp_t *tccp = NULL;
+-	size_t array_size;
+-	
++
+ 	tcp = &cp->tcps[tileno];
+ 
+-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
+-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
++	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
+ 	if(!pi) {
+ 		/* TODO: throw an error */
+ 		return NULL;
+ 	}
+-	
++
+ 	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
+ 		int maxres = 0;
+ 		int maxprec = 0;
+@@ -436,14 +434,12 @@
+ 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+ 		pi[pino].numcomps = image->numcomps;
+ 
+-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
+-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
++		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
+ 		if(!pi[pino].comps) {
+ 			/* TODO: throw an error */
+ 			pi_destroy(pi, cp, tileno);
+ 			return NULL;
+ 		}
+-		memset(pi[pino].comps, 0, array_size);
+ 		
+ 		for (compno = 0; compno < pi->numcomps; compno++) {
+ 			int tcx0, tcy0, tcx1, tcy1;
+@@ -453,8 +449,7 @@
+ 			comp->dy = image->comps[compno].dy;
+ 			comp->numresolutions = tccp->numresolutions;
+ 
+-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
+-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
++			comp->resolutions = (opj_pi_resolution_t*) opj_calloc(comp->numresolutions, sizeof(opj_pi_resolution_t));
+ 			if(!comp->resolutions) {
+ 				/* TODO: throw an error */
+ 				pi_destroy(pi, cp, tileno);
+@@ -507,8 +502,7 @@
+ 		pi[pino].step_l = maxres * pi[pino].step_r;
+ 		
+ 		if (pino == 0) {
+-			array_size = image->numcomps * maxres * tcp->numlayers * maxprec * sizeof(short int);
+-			pi[pino].include = (short int *) opj_malloc(array_size);
++			pi[pino].include = (short int*) opj_calloc(image->numcomps * maxres * tcp->numlayers * maxprec, sizeof(short int));
+ 			if(!pi[pino].include) {
+ 				/* TODO: throw an error */
+ 				pi_destroy(pi, cp, tileno);
+@@ -554,15 +548,13 @@
+ 	opj_pi_iterator_t *pi = NULL;
+ 	opj_tcp_t *tcp = NULL;
+ 	opj_tccp_t *tccp = NULL;
+-	size_t array_size;
+ 	
+ 	tcp = &cp->tcps[tileno];
+ 
+-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
+-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
++	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
+ 	if(!pi) {	return NULL;}
+ 	pi->tp_on = cp->tp_on;
+-	
++
+ 	for(pino = 0;pino < tcp->numpocs+1 ; pino ++){
+ 		p = tileno % cp->tw;
+ 		q = tileno / cp->tw;
+@@ -573,13 +565,11 @@
+ 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+ 		pi[pino].numcomps = image->numcomps;
+ 		
+-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
+-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
++		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
+ 		if(!pi[pino].comps) {
+ 			pi_destroy(pi, cp, tileno);
+ 			return NULL;
+ 		}
+-		memset(pi[pino].comps, 0, array_size);
+ 		
+ 		for (compno = 0; compno < pi[pino].numcomps; compno++) {
+ 			int tcx0, tcy0, tcx1, tcy1;
+@@ -589,8 +579,7 @@
+ 			comp->dy = image->comps[compno].dy;
+ 			comp->numresolutions = tccp->numresolutions;
+ 
+-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
+-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
++			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(comp->numresolutions * sizeof(opj_pi_resolution_t));
+ 			if(!comp->resolutions) {
+ 				pi_destroy(pi, cp, tileno);
+ 				return NULL;
+@@ -653,8 +642,7 @@
+ 		}
+ 
+ 		if (pino == 0) {
+-			array_size = tcp->numlayers * pi[pino].step_l * sizeof(short int);
+-			pi[pino].include = (short int *) opj_malloc(array_size);
++			pi[pino].include = (short int*) opj_calloc(tcp->numlayers * pi[pino].step_l, sizeof(short int));
+ 			if(!pi[pino].include) {
+ 				pi_destroy(pi, cp, tileno);
+ 				return NULL;
+diff -urN -x.svn ../trunk.orig/libopenjpeg/t1.c ./libopenjpeg/t1.c
+--- ../trunk.orig/libopenjpeg/t1.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/t1.c	2007-11-27 22:39:50.000000000 +0000
+@@ -194,7 +194,7 @@
+ */
+ static void t1_encode_cblk(
+ 		opj_t1_t *t1,
+-		opj_tcd_cblk_t * cblk,
++		opj_tcd_cblk_enc_t* cblk,
+ 		int orient,
+ 		int compno,
+ 		int level,
+@@ -213,7 +213,7 @@
+ */
+ static void t1_decode_cblk(
+ 		opj_t1_t *t1,
+-		opj_tcd_cblk_t * cblk,
++		opj_tcd_cblk_dec_t* cblk,
+ 		int orient,
+ 		int roishift,
+ 		int cblksty);
+@@ -762,7 +762,7 @@
+ 
+ 	if(datasize > t1->datasize){
+ 		opj_aligned_free(t1->data);
+-		t1->data=opj_aligned_malloc(datasize * sizeof(int));
++		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
+ 		if(!t1->data){
+ 			return false;
+ 		}
+@@ -775,7 +775,7 @@
+ 
+ 	if(flagssize > t1->flagssize){
+ 		opj_aligned_free(t1->flags);
+-		t1->flags=opj_aligned_malloc(flagssize * sizeof(flag_t));
++		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
+ 		if(!t1->flags){
+ 			return false;
+ 		}
+@@ -792,7 +792,7 @@
+ /** mod fixed_quality */
+ static void t1_encode_cblk(
+ 		opj_t1_t *t1,
+-		opj_tcd_cblk_t * cblk,
++		opj_tcd_cblk_enc_t* cblk,
+ 		int orient,
+ 		int compno,
+ 		int level,
+@@ -802,23 +802,22 @@
+ 		int numcomps,
+ 		opj_tcd_tile_t * tile)
+ {
+-	int i, j;
+-	int passno;
+-	int bpno, passtype;
+-	int max;
+-	int nmsedec = 0;
+ 	double cumwmsedec = 0.0;
+-	char type = T1_TYPE_MQ;
+-	
++
+ 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+-	
++
++	int passno, bpno, passtype;
++	int nmsedec = 0;
++	int i, max;
++	char type = T1_TYPE_MQ;
++	double tempwmsedec;
++
+ 	max = 0;
+-	for (j = 0; j < t1->h; ++j) {
+-		for (i = 0; i < t1->w; ++i) {
+-			max = int_max(max, int_abs(t1->data[(j * t1->w) + i]));
+-		}
++	for (i = 0; i < t1->w * t1->h; ++i) {
++		int tmp = abs(t1->data[i]);
++		max = int_max(max, tmp);
+ 	}
+-	
++
+ 	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
+ 	
+ 	bpno = cblk->numbps - 1;
+@@ -851,8 +850,9 @@
+ 		}
+ 		
+ 		/* fixed_quality */
+-		cumwmsedec += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+-		tile->distotile += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
++		tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
++		cumwmsedec += tempwmsedec;
++		tile->distotile += tempwmsedec;
+ 		
+ 		/* Code switch "RESTART" (i.e. TERMALL) */
+ 		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
+@@ -925,17 +925,17 @@
+ 
+ static void t1_decode_cblk(
+ 		opj_t1_t *t1,
+-		opj_tcd_cblk_t * cblk,
++		opj_tcd_cblk_dec_t* cblk,
+ 		int orient,
+ 		int roishift,
+ 		int cblksty)
+ {
++	opj_raw_t *raw = t1->raw;	/* RAW component */
++	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
++
+ 	int bpno, passtype;
+ 	int segno, passno;
+ 	char type = T1_TYPE_MQ; /* BYPASS mode */
+-	
+-	opj_raw_t *raw = t1->raw;	/* RAW component */
+-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+ 
+ 	if(!allocate_buffers(
+ 				t1,
+@@ -958,10 +958,14 @@
+ 		
+ 		/* BYPASS mode */
+ 		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
++		/* FIXME: slviewer gets here with a null pointer. Why? Partially downloaded and/or corrupt textures? */
++		if(seg->data == NULL){
++			continue;
++		}
+ 		if (type == T1_TYPE_RAW) {
+-			raw_init_dec(raw, seg->data, seg->len);
++			raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
+ 		} else {
+-			mqc_init_dec(mqc, seg->data, seg->len);
++			mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len);
+ 		}
+ 		
+ 		for (passno = 0; passno < seg->numpasses; ++passno) {
+@@ -998,15 +1002,15 @@
+ 	if(!t1)
+ 		return NULL;
+ 
+-		t1->cinfo = cinfo;
+-		/* create MQC and RAW handles */
+-		t1->mqc = mqc_create();
+-		t1->raw = raw_create();
++	t1->cinfo = cinfo;
++	/* create MQC and RAW handles */
++	t1->mqc = mqc_create();
++	t1->raw = raw_create();
+ 
+-	t1->datasize=0;
+ 	t1->data=NULL;
+-	t1->flagssize=0;
+ 	t1->flags=NULL;
++	t1->datasize=0;
++	t1->flagssize=0;
+ 
+ 	return t1;
+ }
+@@ -1018,7 +1022,7 @@
+ 		raw_destroy(t1->raw);
+ 		opj_aligned_free(t1->data);
+ 		opj_aligned_free(t1->flags);
+-		free(t1);
++		opj_free(t1);
+ 	}
+ }
+ 
+@@ -1032,23 +1036,29 @@
+ 	tile->distotile = 0;		/* fixed_quality */
+ 
+ 	for (compno = 0; compno < tile->numcomps; ++compno) {
+-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
++		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
++		opj_tccp_t* tccp = &tcp->tccps[compno];
++		int tile_w = tilec->x1 - tilec->x0;
+ 
+ 		for (resno = 0; resno < tilec->numresolutions; ++resno) {
+ 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+ 
+ 			for (bandno = 0; bandno < res->numbands; ++bandno) {
+-				opj_tcd_band_t *band = &res->bands[bandno];
++				opj_tcd_band_t* restrict band = &res->bands[bandno];
+ 
+ 				for (precno = 0; precno < res->pw * res->ph; ++precno) {
+ 					opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 
+ 					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
+-						int x, y, w, i, j;
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++						opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
++						int* restrict datap;
++						int* restrict tiledp;
++						int cblk_w;
++						int cblk_h;
++						int i, j;
+ 
+-						x = cblk->x0 - band->x0;
+-						y = cblk->y0 - band->y0;
++						int x = cblk->x0 - band->x0;
++						int y = cblk->y0 - band->y0;
+ 						if (band->bandno & 1) {
+ 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+ 							x += pres->x1 - pres->x0;
+@@ -1066,20 +1076,25 @@
+ 							return;
+ 						}
+ 
+-						w = tilec->x1 - tilec->x0;
+-						if (tcp->tccps[compno].qmfbid == 1) {
+-							for (j = 0; j < t1->h; ++j) {
+-								for (i = 0; i < t1->w; ++i) {
+-									t1->data[(j * t1->w) + i] =
+-										tilec->data[(x + i) + (y + j) * w] << T1_NMSEDEC_FRACBITS;
++						datap=t1->data;
++						cblk_w = t1->w;
++						cblk_h = t1->h;
++
++						tiledp=&tilec->data[(y * tile_w) + x];
++						if (tccp->qmfbid == 1) {
++							for (j = 0; j < cblk_h; ++j) {
++								for (i = 0; i < cblk_w; ++i) {
++									int tmp = tiledp[(j * tile_w) + i];
++									datap[(j * cblk_w) + i] = tmp << T1_NMSEDEC_FRACBITS;
+ 								}
+ 							}
+-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
+-							for (j = 0; j < t1->h; ++j) {
+-								for (i = 0; i < t1->w; ++i) {
+-									t1->data[(j * t1->w) + i] = 
++						} else {		/* if (tccp->qmfbid == 0) */
++							for (j = 0; j < cblk_h; ++j) {
++								for (i = 0; i < cblk_w; ++i) {
++									int tmp = tiledp[(j * tile_w) + i];
++									datap[(j * cblk_w) + i] =
+ 										fix_mul(
+-										tilec->data[x + i + (y + j) * w],
++										tmp,
+ 										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (11 - T1_NMSEDEC_FRACBITS);
+ 								}
+ 							}
+@@ -1091,9 +1106,9 @@
+ 								band->bandno,
+ 								compno,
+ 								tilec->numresolutions - 1 - resno,
+-								tcp->tccps[compno].qmfbid,
++								tccp->qmfbid,
+ 								band->stepsize,
+-								tcp->tccps[compno].cblksty,
++								tccp->cblksty,
+ 								tile->numcomps,
+ 								tile);
+ 
+@@ -1105,87 +1120,89 @@
+ }
+ 
+ void t1_decode_cblks(
+-		opj_t1_t *t1,
+-		opj_tcd_tile_t *tile,
+-		opj_tcp_t *tcp)
+-{
+-	int compno, resno, bandno, precno, cblkno;
+-
+-	for (compno = 0; compno < tile->numcomps; ++compno) {
+-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+-
+-		for (resno = 0; resno < tilec->numresolutions; ++resno) {
+-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+-
+-			for (bandno = 0; bandno < res->numbands; ++bandno) {
+-				opj_tcd_band_t *band = &res->bands[bandno];
+-
+-				for (precno = 0; precno < res->pw * res->ph; ++precno) {
+-					opj_tcd_precinct_t *prc = &band->precincts[precno];
+-
+-					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
+-						int x, y, w, i, j, cblk_w, cblk_h;
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+-
+-						t1_decode_cblk(
+-								t1,
+-								cblk,
+-								band->bandno,
+-								tcp->tccps[compno].roishift,
+-								tcp->tccps[compno].cblksty);
+-
+-						x = cblk->x0 - band->x0;
+-						y = cblk->y0 - band->y0;
+-						if (band->bandno & 1) {
+-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+-							x += pres->x1 - pres->x0;
+-						}
+-						if (band->bandno & 2) {
+-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+-							y += pres->y1 - pres->y0;
+-						}
+-
+-						cblk_w = cblk->x1 - cblk->x0;
+-						cblk_h = cblk->y1 - cblk->y0;
+-
+-						if (tcp->tccps[compno].roishift) {
+-							int thresh = 1 << tcp->tccps[compno].roishift;
+-							for (j = 0; j < cblk_h; ++j) {
+-								for (i = 0; i < cblk_w; ++i) {
+-									int val = t1->data[(j * t1->w) + i];
+-									int mag = int_abs(val);
+-									if (mag >= thresh) {
+-										mag >>= tcp->tccps[compno].roishift;
+-										t1->data[(j * t1->w) + i] = val < 0 ? -mag : mag;
+-									}
++		opj_t1_t* t1,
++		opj_tcd_tilecomp_t* tilec,
++		opj_tccp_t* tccp)
++{
++	int resno, bandno, precno, cblkno;
++
++	int tile_w = tilec->x1 - tilec->x0;
++
++	for (resno = 0; resno < tilec->numresolutions; ++resno) {
++		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
++
++		for (bandno = 0; bandno < res->numbands; ++bandno) {
++			opj_tcd_band_t* restrict band = &res->bands[bandno];
++
++			for (precno = 0; precno < res->pw * res->ph; ++precno) {
++				opj_tcd_precinct_t* precinct = &band->precincts[precno];
++
++				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
++					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
++					int* restrict datap;
++					void* restrict tiledp;
++					int cblk_w, cblk_h;
++					int x, y;
++					int i, j;
++
++					t1_decode_cblk(
++							t1,
++							cblk,
++							band->bandno,
++							tccp->roishift,
++							tccp->cblksty);
++
++					x = cblk->x0 - band->x0;
++					y = cblk->y0 - band->y0;
++					if (band->bandno & 1) {
++						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
++						x += pres->x1 - pres->x0;
++					}
++					if (band->bandno & 2) {
++						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
++						y += pres->y1 - pres->y0;
++					}
++
++					datap=t1->data;
++					cblk_w = t1->w;
++					cblk_h = t1->h;
++
++					if (tccp->roishift) {
++						int thresh = 1 << tccp->roishift;
++						for (j = 0; j < cblk_h; ++j) {
++							for (i = 0; i < cblk_w; ++i) {
++								int val = datap[(j * cblk_w) + i];
++								int mag = abs(val);
++								if (mag >= thresh) {
++									mag >>= tccp->roishift;
++									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
+ 								}
+ 							}
+ 						}
+-						
+-						w = tilec->x1 - tilec->x0;
+-						if (tcp->tccps[compno].qmfbid == 1) {
+-							for (j = 0; j < cblk_h; ++j) {
+-								for (i = 0; i < cblk_w; ++i) {
+-									tilec->data[x + i + (y + j) * w] = t1->data[(j * t1->w) + i]/2;
+-								}
++					}
++
++					tiledp=(void*)&tilec->data[(y * tile_w) + x];
++					if (tccp->qmfbid == 1) {
++						for (j = 0; j < cblk_h; ++j) {
++							for (i = 0; i < cblk_w; ++i) {
++								int tmp = datap[(j * cblk_w) + i];
++								((int*)tiledp)[(j * tile_w) + i] = tmp / 2;
+ 							}
+-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
+-							for (j = 0; j < cblk_h; ++j) {
+-								for (i = 0; i < cblk_w; ++i) {
+-									if (t1->data[(j * t1->w) + i] >> 1 == 0) {
+-										tilec->data[x + i + (y + j) * w] = 0;
+-									} else {
+-										double tmp = (double)(t1->data[(j * t1->w) + i] * band->stepsize * 4096.0);
+-										int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);									
+-										tilec->data[x + i + (y + j) * w] = ((tmp<0)?-tmp2:tmp2);
+-									}
+-								}
++						}
++					} else {		/* if (tccp->qmfbid == 0) */
++						for (j = 0; j < cblk_h; ++j) {
++							for (i = 0; i < cblk_w; ++i) {
++								float tmp = datap[(j * cblk_w) + i] * band->stepsize;
++								((float*)tiledp)[(j * tile_w) + i] = tmp;
+ 							}
+ 						}
+-					} /* cblkno */
+-				} /* precno */
+-			} /* bandno */
+-		} /* resno */
+-	} /* compno */
++					}
++					opj_free(cblk->data);
++					opj_free(cblk->segs);
++				} /* cblkno */
++				opj_free(precinct->cblks.dec);
++			} /* precno */
++		} /* bandno */
++	} /* resno */
+ }
+ 
+diff -urN -x.svn ../trunk.orig/libopenjpeg/t1.h ./libopenjpeg/t1.h
+--- ../trunk.orig/libopenjpeg/t1.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/t1.h	2007-11-27 22:39:50.000000000 +0000
+@@ -138,7 +138,7 @@
+ @param tile The tile to decode
+ @param tcp Tile coding parameters
+ */
+-void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
++void t1_decode_cblks(opj_t1_t* t1, opj_tcd_tilecomp_t* tilec, opj_tccp_t* tccp);
+ /* ----------------------------------------------------------------------- */
+ /*@}*/
+ 
+diff -urN -x.svn ../trunk.orig/libopenjpeg/t2.c ./libopenjpeg/t2.c
+--- ../trunk.orig/libopenjpeg/t2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/t2.c	2007-11-27 22:39:50.000000000 +0000
+@@ -63,7 +63,7 @@
+ @param cblksty
+ @param first
+ */
+-static void t2_init_seg(opj_tcd_seg_t *seg, int cblksty, int first);
++static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first);
+ /**
+ Decode a packet of a tile from a source buffer
+ @param t2 T2 handle
+@@ -160,7 +160,7 @@
+ 			tgt_reset(prc->incltree);
+ 			tgt_reset(prc->imsbtree);
+ 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++				opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+ 				cblk->numpasses = 0;
+ 				tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
+ 			}
+@@ -176,14 +176,14 @@
+ 		opj_tcd_band_t *band = &res->bands[bandno];
+ 		opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+ 			opj_tcd_layer_t *layer = &cblk->layers[layno];
+ 			if (!cblk->numpasses && layer->numpasses) {
+ 				tgt_setvalue(prc->incltree, cblkno, layno);
+ 			}
+ 		}
+ 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+ 			opj_tcd_layer_t *layer = &cblk->layers[layno];
+ 			int increment = 0;
+ 			int nump = 0;
+@@ -267,7 +267,7 @@
+ 		opj_tcd_band_t *band = &res->bands[bandno];
+ 		opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+ 			opj_tcd_layer_t *layer = &cblk->layers[layno];
+ 			if (!layer->numpasses) {
+ 				continue;
+@@ -294,7 +294,12 @@
+ 	return (c - dest);
+ }
+ 
+-static void t2_init_seg(opj_tcd_seg_t * seg, int cblksty, int first) {
++static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first) {
++	opj_tcd_seg_t* seg;
++	cblk->segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, (index + 1) * sizeof(opj_tcd_seg_t));
++	seg = &cblk->segs[index];
++	seg->data = NULL;
++	seg->dataindex = 0;
+ 	seg->numpasses = 0;
+ 	seg->len = 0;
+ 	if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
+@@ -323,9 +328,8 @@
+ 	int precno = pi->precno;	/* precinct value */
+ 	int layno  = pi->layno;		/* quality layer value */
+ 
+-	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+-	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+-	
++	opj_tcd_resolution_t* res = &tile->comps[compno].resolutions[resno];
++
+ 	unsigned char *hd = NULL;
+ 	int present;
+ 	
+@@ -341,7 +345,7 @@
+ 			tgt_reset(prc->incltree);
+ 			tgt_reset(prc->imsbtree);
+ 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++				opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+ 				cblk->numsegs = 0;
+ 			}
+ 		}
+@@ -425,9 +429,8 @@
+ 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
+ 		
+ 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-			int included, increment, n;
+-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+-			opj_tcd_seg_t *seg = NULL;
++			int included, increment, n, segno;
++			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+ 			/* if cblk not yet included before --> inclusion tagtree */
+ 			if (!cblk->numsegs) {
+ 				included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
+@@ -455,23 +458,25 @@
+ 			increment = t2_getcommacode(bio);
+ 			/* length indicator increment */
+ 			cblk->numlenbits += increment;
++			segno = 0;
+ 			if (!cblk->numsegs) {
+-				seg = &cblk->segs[0];
+-				t2_init_seg(seg, tcp->tccps[compno].cblksty, 1);
++				t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 1);
+ 			} else {
+-				seg = &cblk->segs[cblk->numsegs - 1];
+-				if (seg->numpasses == seg->maxpasses) {
+-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
++				segno = cblk->numsegs - 1;
++				if (cblk->segs[segno].numpasses == cblk->segs[segno].maxpasses) {
++					++segno;
++					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
+ 				}
+ 			}
+ 			n = cblk->numnewpasses;
+ 			
+ 			do {
+-				seg->numnewpasses = int_min(seg->maxpasses - seg->numpasses, n);
+-				seg->newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(seg->numnewpasses));
+-				n -= seg->numnewpasses;
++				cblk->segs[segno].numnewpasses = int_min(cblk->segs[segno].maxpasses - cblk->segs[segno].numpasses, n);
++				cblk->segs[segno].newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(cblk->segs[segno].numnewpasses));
++				n -= cblk->segs[segno].numnewpasses;
+ 				if (n > 0) {
+-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
++					++segno;
++					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
+ 				}
+ 			} while (n > 0);
+ 		}
+@@ -519,7 +524,7 @@
+ 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
+ 		
+ 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+ 			opj_tcd_seg_t *seg = NULL;
+ 			if (!cblk->numnewpasses)
+ 				continue;
+@@ -560,9 +565,11 @@
+ 
+ #endif /* USE_JPWL */
+ 				
++				cblk->data = (unsigned char*) opj_realloc(cblk->data, (cblk->len + seg->newlen) * sizeof(unsigned char*));
+ 				memcpy(cblk->data + cblk->len, c, seg->newlen);
+ 				if (seg->numpasses == 0) {
+-					seg->data = cblk->data + cblk->len;
++					seg->data = &cblk->data;
++					seg->dataindex = cblk->len;
+ 				}
+ 				c += seg->newlen;
+ 				cblk->len += seg->newlen;
+@@ -586,7 +593,6 @@
+ 	unsigned char *c = dest;
+ 	int e = 0;
+ 	int compno;
+-	int comp_len = 0;
+ 	opj_pi_iterator_t *pi = NULL;
+ 	int poc;
+ 	opj_image_t *image = t2->image;
+diff -urN -x.svn ../trunk.orig/libopenjpeg/tcd.c ./libopenjpeg/tcd.c
+--- ../trunk.orig/libopenjpeg/tcd.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/tcd.c	2007-11-27 22:39:50.000000000 +0000
+@@ -33,7 +33,7 @@
+ #include "opj_includes.h"
+ 
+ void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {
+-	int tileno, compno, resno, bandno, precno, cblkno;
++	int tileno, compno, resno, bandno, precno;//, cblkno;
+ 
+ 	fprintf(fd, "image {\n");
+ 	fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
+@@ -68,6 +68,7 @@
+ 						fprintf(fd,
+ 							"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
+ 							prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
++						/*
+ 						for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
+ 							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
+ 							fprintf(fd, "            cblk {\n");
+@@ -76,6 +77,7 @@
+ 								cblk->x0, cblk->y0, cblk->x1, cblk->y1);
+ 							fprintf(fd, "            }\n");
+ 						}
++						*/
+ 						fprintf(fd, "          }\n");
+ 					}
+ 					fprintf(fd, "        }\n");
+@@ -313,7 +315,7 @@
+ 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+ 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+ 
+-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cw * prc->ch) * sizeof(opj_tcd_cblk_t));
++						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc((prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t));
+ 						prc->incltree = tgt_create(prc->cw, prc->ch);
+ 						prc->imsbtree = tgt_create(prc->cw, prc->ch);
+ 						
+@@ -323,13 +325,18 @@
+ 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+ 							int cblkyend = cblkystart + (1 << cblkheightexpn);
+ 							
+-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+ 
+ 							/* code-block size (global) */
+ 							cblk->x0 = int_max(cblkxstart, prc->x0);
+ 							cblk->y0 = int_max(cblkystart, prc->y0);
+ 							cblk->x1 = int_min(cblkxend, prc->x1);
+ 							cblk->y1 = int_min(cblkyend, prc->y1);
++							cblk->data = (unsigned char*) opj_calloc(8192+2, sizeof(unsigned char));
++							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
++							cblk->data += 2;
++							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
++							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
+ 						}
+ 					}
+ 				}
+@@ -341,7 +348,7 @@
+ }
+ 
+ void tcd_free_encode(opj_tcd_t *tcd) {
+-	int tileno, compno, resno, bandno, precno;
++	int tileno, compno, resno, bandno, precno, cblkno;
+ 
+ 	for (tileno = 0; tileno < 1; tileno++) {
+ 		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
+@@ -366,8 +373,12 @@
+ 							tgt_destroy(prc->imsbtree);	
+ 							prc->imsbtree = NULL;
+ 						}
+-						opj_free(prc->cblks);
+-						prc->cblks = NULL;
++						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
++							opj_free(prc->cblks.enc[cblkno].data - 2);
++							opj_free(prc->cblks.enc[cblkno].layers);
++							opj_free(prc->cblks.enc[cblkno].passes);
++						}
++						opj_free(prc->cblks.enc);
+ 					} /* for (precno */
+ 					opj_free(band->precincts);
+ 					band->precincts = NULL;
+@@ -547,8 +558,8 @@
+ 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+ 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+ 
+-						opj_free(prc->cblks);
+-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
++						opj_free(prc->cblks.enc);
++						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc(prc->cw * prc->ch, sizeof(opj_tcd_cblk_enc_t));
+ 
+ 						if (prc->incltree != NULL) {
+ 							tgt_destroy(prc->incltree);
+@@ -566,13 +577,16 @@
+ 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+ 							int cblkyend = cblkystart + (1 << cblkheightexpn);
+ 
+-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+-							
++							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
++
+ 							/* code-block size (global) */
+ 							cblk->x0 = int_max(cblkxstart, prc->x0);
+ 							cblk->y0 = int_max(cblkystart, prc->y0);
+ 							cblk->x1 = int_min(cblkxend, prc->x1);
+ 							cblk->y1 = int_min(cblkyend, prc->y1);
++							cblk->data = (unsigned char*) opj_calloc(8192, sizeof(unsigned char));
++							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
++							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
+ 						}
+ 					} /* precno */
+ 				} /* bandno */
+@@ -603,7 +617,7 @@
+ 		tileno = cp->tileno[j];		
+ 		tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);		
+ 		tile->numcomps = image->numcomps;
+-		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(image->numcomps * sizeof(opj_tcd_tilecomp_t));
++		tile->comps = (opj_tcd_tilecomp_t*) opj_calloc(image->numcomps, sizeof(opj_tcd_tilecomp_t));
+ 	}
+ 
+ 	for (i = 0; i < image->numcomps; i++) {
+@@ -637,11 +651,10 @@
+ 			x1 = j == 0 ? tilec->x1 : int_max(x1,	(unsigned int) tilec->x1);
+ 			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
+ 		}
+-		
+-		w = x1 - x0;
+-		h = y1 - y0;
+-		
+-		image->comps[i].data = (int *) opj_malloc(w * h * sizeof(int));
++
++		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
++		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
++
+ 		image->comps[i].w = w;
+ 		image->comps[i].h = h;
+ 		image->comps[i].x0 = x0;
+@@ -651,7 +664,6 @@
+ 
+ void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info) {
+ 	int compno, resno, bandno, precno, cblkno;
+-	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0;
+ 	opj_tcp_t *tcp;
+ 	opj_tcd_tile_t *tile;
+ 
+@@ -671,8 +683,7 @@
+ 		tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+ 		tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+ 		tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+-		
+-		tilec->data = (int*) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
++
+ 		tilec->numresolutions = tccp->numresolutions;
+ 		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+ 		
+@@ -757,7 +768,7 @@
+ 				ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+ 				gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
+ 				numbps = image->comps[compno].prec + gain;
+-				band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
++				band->stepsize = (float)(((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn)) * 0.5);
+ 				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+ 				
+ 				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+@@ -782,9 +793,9 @@
+ 					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+ 					prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+ 					prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+-					
+-					prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
+-					
++
++					prc->cblks.dec = (opj_tcd_cblk_dec_t*) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_dec_t));
++
+ 					prc->incltree = tgt_create(prc->cw, prc->ch);
+ 					prc->imsbtree = tgt_create(prc->cw, prc->ch);
+ 					
+@@ -793,13 +804,16 @@
+ 						int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+ 						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+ 						int cblkyend = cblkystart + (1 << cblkheightexpn);					
+-						
++
++						opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
++						cblk->data = NULL;
++						cblk->segs = NULL;
+ 						/* code-block size (global) */
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+ 						cblk->x0 = int_max(cblkxstart, prc->x0);
+ 						cblk->y0 = int_max(cblkystart, prc->y0);
+ 						cblk->x1 = int_min(cblkxend, prc->x1);
+ 						cblk->y1 = int_min(cblkyend, prc->y1);
++						cblk->numsegs = 0;
+ 					}
+ 				} /* precno */
+ 			} /* bandno */
+@@ -839,7 +853,7 @@
+ 				for (precno = 0; precno < res->pw * res->ph; precno++) {
+ 					opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+ 						opj_tcd_layer_t *layer = &cblk->layers[layno];
+ 						int n;
+ 						int imsb = tcd->image->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
+@@ -920,7 +934,7 @@
+ 				for (precno = 0; precno < res->pw * res->ph; precno++) {
+ 					opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+ 						opj_tcd_layer_t *layer = &cblk->layers[layno];
+ 						
+ 						int n;
+@@ -1004,7 +1018,7 @@
+ 					opj_tcd_precinct_t *prc = &band->precincts[precno];
+ 
+ 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
++						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+ 
+ 						for (passno = 0; passno < cblk->totalpasses; passno++) {
+ 							opj_tcd_pass_t *pass = &cblk->passes[passno];
+@@ -1179,7 +1193,7 @@
+ 				cstr_info->tile[tileno].pdx[i] = tccp->prcw[i];
+ 				cstr_info->tile[tileno].pdy[i] = tccp->prch[i];
+ 			}
+-			cstr_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(cstr_info->numcomps * cstr_info->numlayers * numpacks * sizeof(opj_packet_info_t));
++			cstr_info->tile[tileno].packet = (opj_packet_info_t*) opj_calloc(cstr_info->numcomps * cstr_info->numlayers * numpacks, sizeof(opj_packet_info_t));
+ 		}
+ 		/* << INDEX */
+ 		
+@@ -1350,7 +1364,12 @@
+ 	
+ 	t1_time = opj_clock();	/* time needed to decode a tile */
+ 	t1 = t1_create(tcd->cinfo);
+-	t1_decode_cblks(t1, tile, tcd->tcp);
++	for (compno = 0; compno < tile->numcomps; ++compno) {
++		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
++		/* The +3 is headroom required by the vectorized DWT */
++		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
++		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
++	}
+ 	t1_destroy(t1);
+ 	t1_time = opj_clock() - t1_time;
+ 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tiers-1 took %f s\n", t1_time);
+@@ -1360,80 +1379,93 @@
+ 	dwt_time = opj_clock();	/* time needed to decode a tile */
+ 	for (compno = 0; compno < tile->numcomps; compno++) {
+ 		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
++		int numres2decode;
++
+ 		if (tcd->cp->reduce != 0) {
+ 			tcd->image->comps[compno].resno_decoded =
+ 				tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
+-		}
+-        
+-		if (tcd->tcp->tccps[compno].qmfbid == 1) {
+-			dwt_decode(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
+-		} else {
+-			dwt_decode_real(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
++			if (tcd->image->comps[compno].resno_decoded < 0) {
++				opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. The number of resolutions to remove is higher than the number "
++					"of resolutions in the original codestream\nModify the cp_reduce parameter.\n");
++				return false;
++			}
+ 		}
+ 
+-		if (tile->comps[compno].numresolutions > 0) {
+-			tcd->image->comps[compno].factor = tile->comps[compno].numresolutions - (tcd->image->comps[compno].resno_decoded + 1);
++		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
++		if(numres2decode > 0){
++			if (tcd->tcp->tccps[compno].qmfbid == 1) {
++				dwt_decode(tilec, numres2decode);
++			} else {
++				dwt_decode_real(tilec, numres2decode);
++			}
+ 		}
+ 	}
+ 	dwt_time = opj_clock() - dwt_time;
+ 	opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
+-	
++
+ 	/*----------------MCT-------------------*/
+-	
++
+ 	if (tcd->tcp->mct) {
++		int n = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
+ 		if (tcd->tcp->tccps[0].qmfbid == 1) {
+-			mct_decode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
+-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
++			mct_decode(
++					tile->comps[0].data,
++					tile->comps[1].data,
++					tile->comps[2].data, 
++					n);
+ 		} else {
+-			mct_decode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
+-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
++			mct_decode_real(
++					(float*)tile->comps[0].data,
++					(float*)tile->comps[1].data,
++					(float*)tile->comps[2].data, 
++					n);
+ 		}
+ 	}
+-	
++
+ 	/*---------------TILE-------------------*/
+-	
+-	for (compno = 0; compno < tile->numcomps; compno++) {
+-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+-		opj_tcd_resolution_t *res =	&tilec->resolutions[tcd->image->comps[compno].resno_decoded];
+-		int adjust = tcd->image->comps[compno].sgnd ? 0 : 1 << (tcd->image->comps[compno].prec - 1);
+-		int min = tcd->image->comps[compno].sgnd ? 
+-			-(1 << (tcd->image->comps[compno].prec - 1)) : 0;
+-		int max = tcd->image->comps[compno].sgnd ? 
+-			(1 << (tcd->image->comps[compno].prec - 1)) - 1 : (1 << tcd->image->comps[compno].prec) - 1;
+-		
++
++	for (compno = 0; compno < tile->numcomps; ++compno) {
++		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
++		opj_image_comp_t* imagec = &tcd->image->comps[compno];
++		opj_tcd_resolution_t* res = &tilec->resolutions[imagec->resno_decoded];
++		int adjust = imagec->sgnd ? 0 : 1 << (imagec->prec - 1);
++		int min = imagec->sgnd ? -(1 << (imagec->prec - 1)) : 0;
++		int max = imagec->sgnd ?  (1 << (imagec->prec - 1)) - 1 : (1 << imagec->prec) - 1;
++
+ 		int tw = tilec->x1 - tilec->x0;
+-		int w = tcd->image->comps[compno].w;
+-		
+-		int i, j;
+-		int offset_x = int_ceildivpow2(tcd->image->comps[compno].x0, tcd->image->comps[compno].factor);
+-		int offset_y = int_ceildivpow2(tcd->image->comps[compno].y0, tcd->image->comps[compno].factor);
+-		
+-		for (j = res->y0; j < res->y1; j++) {
+-			for (i = res->x0; i < res->x1; i++) {
+-				int v;
+-				float tmp = (float)((tilec->data[i - res->x0 + (j - res->y0) * tw]) / 8192.0);
++		int w = imagec->w;
+ 
+-				if (tcd->tcp->tccps[compno].qmfbid == 1) {
+-					v = tilec->data[i - res->x0 + (j - res->y0) * tw];
+-				} else {
+-					int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
+-					v = ((tmp < 0) ? -tmp2:tmp2);
++		int offset_x = int_ceildivpow2(imagec->x0, imagec->factor);
++		int offset_y = int_ceildivpow2(imagec->y0, imagec->factor);
++
++		int i, j;
++		if(!imagec->data){
++			imagec->data = (int*) opj_malloc(imagec->w * imagec->h * sizeof(int));
++		}
++		if(tcd->tcp->tccps[compno].qmfbid == 1) {
++			for(j = res->y0; j < res->y1; ++j) {
++				for(i = res->x0; i < res->x1; ++i) {
++					int v = tilec->data[i - res->x0 + (j - res->y0) * tw];
++					v += adjust;
++					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
++				}
++			}
++		}else{
++			for(j = res->y0; j < res->y1; ++j) {
++				for(i = res->x0; i < res->x1; ++i) {
++					float tmp = ((float*)tilec->data)[i - res->x0 + (j - res->y0) * tw];
++					int v = lrintf(tmp);
++					v += adjust;
++					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+ 				}
+-				v += adjust;
+-				
+-				tcd->image->comps[compno].data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+ 			}
+ 		}
++		opj_aligned_free(tilec->data);
+ 	}
+-	
++
+ 	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
+ 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
+ 
+-	for (compno = 0; compno < tile->numcomps; compno++) {
+-		opj_aligned_free(tcd->tcd_image->tiles[tileno].comps[compno].data);
+-		tcd->tcd_image->tiles[tileno].comps[compno].data = NULL;
+-	}
+-
+ 	if (eof) {
+ 		return false;
+ 	}
+@@ -1443,7 +1475,7 @@
+ 
+ void tcd_free_decode(opj_tcd_t *tcd) {
+ 	opj_tcd_image_t *tcd_image = tcd->tcd_image;	
+-	if (tcd_image->tiles != NULL) opj_free(tcd_image->tiles);
++	opj_free(tcd_image->tiles);
+ }
+ 
+ void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
+@@ -1460,20 +1492,14 @@
+ 				opj_tcd_band_t *band = &res->bands[bandno];
+ 				for (precno = 0; precno < res->ph * res->pw; precno++) {
+ 					opj_tcd_precinct_t *prec = &band->precincts[precno];
+-					if (prec->cblks != NULL) opj_free(prec->cblks);
+ 					if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+ 					if (prec->incltree != NULL) tgt_destroy(prec->incltree);
+ 				}
+-				if (band->precincts != NULL) opj_free(band->precincts);
++				opj_free(band->precincts);
+ 			}
+ 		}
+-		if (tilec->resolutions != NULL) opj_free(tilec->resolutions);
++		opj_free(tilec->resolutions);
+ 	}
+-	if (tile->comps != NULL) opj_free(tile->comps);
++	opj_free(tile->comps);
+ }
+ 
+-
+-
+-
+-
+-
+diff -urN -x.svn ../trunk.orig/libopenjpeg/tcd.h ./libopenjpeg/tcd.h
+--- ../trunk.orig/libopenjpeg/tcd.h	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/tcd.h	2007-11-27 22:39:50.000000000 +0000
+@@ -45,9 +45,10 @@
+ FIXME: documentation
+ */
+ typedef struct opj_tcd_seg {
++  unsigned char** data;
++  int dataindex;
+   int numpasses;
+   int len;
+-  unsigned char *data;
+   int maxpasses;
+   int numnewpasses;
+   int newlen;
+@@ -75,21 +76,28 @@
+ /**
+ FIXME: documentation
+ */
+-typedef struct opj_tcd_cblk {
++typedef struct opj_tcd_cblk_enc {
++  unsigned char* data;	/* Data */
++  opj_tcd_layer_t* layers;	/* layer information */
++  opj_tcd_pass_t* passes;	/* information about the passes */
+   int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+   int numbps;
+   int numlenbits;
+-  int len;			/* length */
+   int numpasses;		/* number of pass already done for the code-blocks */
+-  int numnewpasses;		/* number of pass added to the code-blocks */
+-  int numsegs;			/* number of segments */
+-  opj_tcd_seg_t segs[100];		/* segments informations */
+-  unsigned char data[8192];	/* Data */
+   int numpassesinlayers;	/* number of passes in the layer */
+-  opj_tcd_layer_t layers[100];	/* layer information */
+   int totalpasses;		/* total number of passes */
+-  opj_tcd_pass_t passes[100];	/* information about the passes */
+-} opj_tcd_cblk_t;
++} opj_tcd_cblk_enc_t;
++
++typedef struct opj_tcd_cblk_dec {
++  unsigned char* data;	/* Data */
++  opj_tcd_seg_t* segs;		/* segments informations */
++	int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
++  int numbps;
++  int numlenbits;
++  int len;			/* length */
++  int numnewpasses;		/* number of pass added to the code-blocks */
++  int numsegs;			/* number of segments */
++} opj_tcd_cblk_dec_t;
+ 
+ /**
+ FIXME: documentation
+@@ -97,7 +105,10 @@
+ typedef struct opj_tcd_precinct {
+   int x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
+   int cw, ch;			/* number of precinct in width and heigth */
+-  opj_tcd_cblk_t *cblks;		/* code-blocks informations */
++  union{		/* code-blocks informations */
++	  opj_tcd_cblk_enc_t* enc;
++	  opj_tcd_cblk_dec_t* dec;
++  } cblks;
+   opj_tgt_tree_t *incltree;		/* inclusion tree */
+   opj_tgt_tree_t *imsbtree;		/* IMSB tree */
+ } opj_tcd_precinct_t;
+diff -urN -x.svn ../trunk.orig/libopenjpeg/tgt.c ./libopenjpeg/tgt.c
+--- ../trunk.orig/libopenjpeg/tgt.c	2007-09-28 11:36:31.000000000 +0100
++++ ./libopenjpeg/tgt.c	2007-11-27 22:39:50.000000000 +0000
+@@ -71,7 +71,7 @@
+ 		return NULL;
+ 	}
+ 
+-	tree->nodes = (opj_tgt_node_t *) opj_malloc(tree->numnodes * sizeof(opj_tgt_node_t));
++	tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
+ 	if(!tree->nodes) {
+ 		opj_free(tree);
+ 		return NULL;
+diff -urN -x.svn ../trunk.orig/LibOpenJPEG.vcproj ./LibOpenJPEG.vcproj
+--- ../trunk.orig/LibOpenJPEG.vcproj	2007-09-28 11:36:31.000000000 +0100
++++ ./LibOpenJPEG.vcproj	2007-11-27 22:39:51.000000000 +0000
+@@ -3,7 +3,7 @@
+ 	ProjectType="Visual C++"
+ 	Version="8,00"
+ 	Name="LibOpenJPEG"
+-	ProjectGUID="{BDB8C37B-824E-4617-827C-B13E2F015EFE}"
++	ProjectGUID="{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+ 	>
+ 	<Platforms>
+ 		<Platform
+@@ -604,6 +604,10 @@
+ 				>
+ 			</File>
+ 			<File
++				RelativePath=".\libopenjpeg\opj_malloc.h"
++				>
++			</File>
++			<File
+ 				RelativePath="libopenjpeg\pi.h"
+ 				>
+ 			</File>
+diff -urN -x.svn ../trunk.orig/Makefile ./Makefile
+--- ../trunk.orig/Makefile	2007-09-28 11:36:31.000000000 +0100
++++ ./Makefile	2007-11-27 22:41:39.000000000 +0000
+@@ -4,7 +4,7 @@
+ VER_MINOR = 1.2.0
+ 
+ SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
+-INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_includes.h
++INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_malloc.h ./libopenjpeg/opj_includes.h 
+ INCLUDE = -Ilibopenjpeg
+ 
+ # General configuration variables:
+@@ -18,7 +18,7 @@
+ # Converts cr/lf to just lf
+ DOS2UNIX = dos2unix
+ 
+-COMPILERFLAGS = -O3 -fPIC
++COMPILERFLAGS = -Wall -O3 -ffast-math -std=c99 -fPIC
+ LIBRARIES = -lstdc++
+ 
+ MODULES = $(SRCS:.c=.o)
+diff -urN -x.svn ../trunk.orig/mj2/extract_j2k_from_mj2.c ./mj2/extract_j2k_from_mj2.c
+--- ../trunk.orig/mj2/extract_j2k_from_mj2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/extract_j2k_from_mj2.c	2007-11-27 22:39:49.000000000 +0000
+@@ -26,7 +26,13 @@
+  * POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+-#include "opj_includes.h"
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++
++#include "openjpeg.h"
++#include "j2k.h"
++#include "jp2.h"
+ #include "mj2.h"
+ 
+ /* -------------------------------------------------------------------------- */
+diff -urN -x.svn ../trunk.orig/mj2/frames_to_mj2.c ./mj2/frames_to_mj2.c
+--- ../trunk.orig/mj2/frames_to_mj2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/frames_to_mj2.c	2007-11-27 22:39:50.000000000 +0000
+@@ -25,7 +25,15 @@
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+ 
+-#include "opj_includes.h"
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++
++#include "openjpeg.h"
++#include "j2k_lib.h"
++#include "j2k.h"
++#include "jp2.h"
++#include "cio.h"
+ #include "mj2.h"
+ #include "mj2_convert.h"
+ #include "compat/getopt.h"
+@@ -697,8 +705,8 @@
+   fwrite(buf,cio_tell(cio),1,mj2file);
+   offset = cio_tell(cio);
+   opj_cio_close(cio);
+-  opj_free(buf);
+-  
++  free(buf);
++
+   for (i = 0; i < movie->num_stk + movie->num_htk + movie->num_vtk; i++) {
+     if (movie->tk[i].track_type != 0) {
+       fprintf(stderr, "Unable to write sound or hint tracks\n");
+@@ -755,7 +763,7 @@
+ 
+       }
+ 			/* free buffer data */
+-			opj_free(buf);
++			free(buf);
+ 			/* free image data */
+ 			opj_image_destroy(img);
+     }
+@@ -770,14 +778,14 @@
+   cio_write(cio, offset - mdat_initpos, 4);
+   fwrite(buf, 4, 1, mj2file);
+   fseek(mj2file,0,SEEK_END);
+-  opj_free(buf);
+-  
++  free(buf);
++
+   // Writing MOOV box 
+ 	buf = (char*) malloc ((TEMP_BUF+numframes*20) * sizeof(char));
+ 	cio = opj_cio_open(movie->cinfo, buf, (TEMP_BUF+numframes*20));
+ 	mj2_write_moov(movie, cio);
+   fwrite(buf,cio_tell(cio),1,mj2file);
+-  opj_free(buf);
++  free(buf);
+ 
+ 	fprintf(stdout,"Total encoding time: %.2f s for %d frames (%.1f fps)\n", total_time, numframes, (float)numframes/total_time);
+   
+diff -urN -x.svn ../trunk.orig/mj2/frames_to_mj2.vcproj ./mj2/frames_to_mj2.vcproj
+--- ../trunk.orig/mj2/frames_to_mj2.vcproj	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/frames_to_mj2.vcproj	2007-11-27 22:39:50.000000000 +0000
+@@ -75,6 +75,7 @@
+ 				OutputFile=".\Release/frames_to_mj2.exe"
+ 				LinkIncremental="1"
+ 				SuppressStartupBanner="true"
++				IgnoreDefaultLibraryNames="LIBC"
+ 				ProgramDatabaseFile=".\Release/frames_to_mj2.pdb"
+ 				SubSystem="1"
+ 				TargetMachine="1"
+@@ -166,7 +167,7 @@
+ 				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.exe"
+ 				LinkIncremental="2"
+ 				SuppressStartupBanner="true"
+-				IgnoreDefaultLibraryNames="libcmt"
++				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+ 				GenerateDebugInformation="true"
+ 				ProgramDatabaseFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pdb"
+ 				SubSystem="1"
+diff -urN -x.svn ../trunk.orig/mj2/mj2.c ./mj2/mj2.c
+--- ../trunk.orig/mj2/mj2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/mj2.c	2007-11-27 22:39:50.000000000 +0000
+@@ -96,9 +96,8 @@
+   movie->brand = MJ2_MJ2;
+   movie->minversion = 0;
+   movie->num_cl = 2;
+-  movie->cl =
+-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
+-	
++  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
++
+   movie->cl[0] = MJ2_MJ2;
+   movie->cl[1] = MJ2_MJ2S;
+   time(&ltime);			/* Time since 1/1/70 */
+@@ -139,9 +138,7 @@
+       tk->same_sample_size = 0;
+ 			
+       tk->num_samplestochunk = 1;	/* One sample per chunk                                      */
+-      tk->sampletochunk =
+-				(mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
+-				sizeof(mj2_sampletochunk_t));
++		tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
+       tk->sampletochunk[0].first_chunk = 1;
+       tk->sampletochunk[0].samples_per_chunk = 1;
+       tk->sampletochunk[0].sample_descr_idx = 1;
+@@ -158,7 +155,7 @@
+       }
+ 			
+       tk->num_tts = 1;
+-      tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
++		tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
+       tk->tts[0].sample_count = tk->num_samples;
+       tk->tts[0].sample_delta = tk->timescale / tk->sample_rate;
+ 			
+@@ -196,7 +193,7 @@
+       tk->or_fieldcount = 1;
+       tk->or_fieldorder = 0;
+       tk->num_br = 2;
+-      tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
++		tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
+       tk->br[0] = MJ2_JP2;
+       tk->br[1] = MJ2_J2P0;
+       tk->num_jp2x = 0;
+@@ -226,10 +223,9 @@
+   for (i = 0; i < tk->num_tts; i++) {
+     tk->num_samples += tk->tts[i].sample_count;
+   }
+-	
+-  tk->sample =
+-    (mj2_sample_t *) malloc(tk->num_samples * sizeof(mj2_sample_t));
+-	
++
++  tk->sample = (mj2_sample_t*) opj_malloc(tk->num_samples * sizeof(mj2_sample_t));
++
+   for (i = 0; i < tk->num_tts; i++) {
+     for (j = 0; j < tk->tts[i].sample_count; j++) {
+       tk->sample[j].sample_delta = tk->tts[i].sample_delta;
+@@ -251,15 +247,13 @@
+     tk->num_chunks =
+       (unsigned int) ceil((double) tk->num_samples /
+       (double) tk->sampletochunk[0].samples_per_chunk);
+-    tk->chunk =
+-      (mj2_chunk_t *) malloc(tk->num_chunks * sizeof(mj2_chunk_t));
++	 tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_chunks * sizeof(mj2_chunk_t));
+     for (k = 0; k < tk->num_chunks; k++) {
+       tk->chunk[k].num_samples = tk->sampletochunk[0].samples_per_chunk;
+     }
+     
+   } else {
+-    tk->chunk =
+-      (mj2_chunk_t *) malloc(tk->num_samples * sizeof(mj2_chunk_t));
++    tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_samples * sizeof(mj2_chunk_t));
+     tk->num_chunks = 0;
+     for (i = 0; i < tk->num_samplestochunk -1 ; i++) {
+       for (j = tk->sampletochunk[i].first_chunk - 1;
+@@ -275,7 +269,7 @@
+       tk->chunk[k].num_samples =
+ 				tk->sampletochunk[tk->num_samplestochunk - 1].samples_per_chunk;
+     }
+-    tk->chunk = realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
++    tk->chunk = opj_realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
+   }
+   
+ }
+@@ -396,9 +390,8 @@
+   movie->brand = cio_read(cio, 4);	/* BR              */
+   movie->minversion = cio_read(cio, 4);	/* MinV            */
+   movie->num_cl = (box.length - 16) / 4;
+-  movie->cl =
+-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
+-	
++  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
++
+   for (i = movie->num_cl - 1; i > -1; i--)
+     movie->cl[i] = cio_read(cio, 4);	/* CLi */
+ 	
+@@ -643,12 +636,9 @@
+   }
+ 	
+   tk->num_samplestochunk = cio_read(cio, 4);
+-	
+-  tk->sampletochunk =
+-    (mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
+-		sizeof(mj2_sampletochunk_t));
+-	
+-	
++
++  tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
++
+   for (i = 0; i < tk->num_samplestochunk; i++) {
+     tk->sampletochunk[i].first_chunk = cio_read(cio, 4);
+     tk->sampletochunk[i].samples_per_chunk = cio_read(cio, 4);
+@@ -725,9 +715,9 @@
+   }
+ 	
+   tk->num_tts = cio_read(cio, 4);
+-	
+-  tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
+-	
++
++  tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
++
+   for (i = 0; i < tk->num_tts; i++) {
+     tk->tts[i].sample_count = cio_read(cio, 4);
+     tk->tts[i].sample_delta = cio_read(cio, 4);
+@@ -905,8 +895,8 @@
+ 	
+ 	
+   tk->num_br = (box.length - 12) / 4;
+-  tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
+-	
++  tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
++
+   for (i = 0; i < tk->num_br; i++) {
+     tk->br[i] = cio_read(cio, 4);
+   }
+@@ -964,9 +954,8 @@
+ 	
+ 	
+   tk->num_jp2x = (box.length - 8);
+-  tk->jp2xdata =
+-    (unsigned char *) malloc(tk->num_jp2x * sizeof(unsigned char));
+-	
++  tk->jp2xdata = (unsigned char*) opj_malloc(tk->num_jp2x * sizeof(unsigned char));
++
+   for (i = 0; i < tk->num_jp2x; i++) {
+     tk->jp2xdata[i] = cio_read(cio, 1);
+   }
+@@ -1172,10 +1161,10 @@
+ 		opj_event_msg(tk->cinfo, EVT_ERROR, "Error reading JP2H Box\n");
+     return 1;
+   }
+-  
+-  tk->jp2_struct.comps = (opj_jp2_comps_t *) malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
+-  tk->jp2_struct.cl = (int *) malloc(sizeof(int));
+-	
++
++  tk->jp2_struct.comps = (opj_jp2_comps_t*) opj_malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
++  tk->jp2_struct.cl = (int*) opj_malloc(sizeof(int));
++
+   tk->num_br = 0;
+   tk->num_jp2x = 0;
+ 	
+@@ -2046,8 +2035,8 @@
+   cio_skip(cio,12);			/* Reserved */
+ 	
+   tk->name_size = box.length - 32;
+-	
+-  tk->name = (char *) malloc(tk->name_size * sizeof(char));
++
++  tk->name = (char*) opj_malloc(tk->name_size * sizeof(char));
+   for (i = 0; i < tk->name_size; i++) {
+     tk->name[i] = cio_read(cio, 1);	/* Name */
+   }
+@@ -2581,10 +2570,9 @@
+ 	
+   if (mj2_read_mvhd(movie, cio))
+     return 1;
+-	
+-  movie->tk =
+-    (mj2_tk_t *) malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
+-	
++
++  movie->tk = (mj2_tk_t*) opj_malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
++
+   for (i = 0; cio_tell(cio) - box.init_pos < box.length; i++) {
+ 		mj2_tk_t *tk = &movie->tk[i];
+ 		tk->cinfo = movie->cinfo;
+@@ -2622,8 +2610,8 @@
+ 	opj_cio_t *cio;
+ 	
+ 	/* open a byte stream for reading */	
+-	src = (char*) malloc (300 * sizeof(char));	
+-	  
++	src = (char*) opj_malloc(300 * sizeof(char));	
++
+ 	/* Assuming that jp and ftyp markers size do
+      not exceed 300 bytes */
+   fread(src,300,1, file);  
+@@ -2706,7 +2694,7 @@
+   }	
+ 
+   fseek(file,foffset,SEEK_SET);
+-  src = realloc(src,box.length);
++  src = opj_realloc(src,box.length);
+   fsresult = fread(src,box.length,1,file);
+   if (fsresult != 1) {
+     opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MOOV box\n"); 
+@@ -2717,8 +2705,8 @@
+   
+   if (mj2_read_moov(movie, &img, cio))
+     return 1;
+-  
+-  free(src);
++
++  opj_free(src);
+   return 0;
+ }
+ 
+@@ -2728,12 +2716,12 @@
+ 
+ opj_dinfo_t* mj2_create_decompress() {
+ 	opj_mj2_t* mj2;
+-	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_malloc(sizeof(opj_dinfo_t));
++	opj_dinfo_t *dinfo = (opj_dinfo_t*) opj_calloc(1, sizeof(opj_dinfo_t));
+ 	if(!dinfo) return NULL;
+ 
+ 	dinfo->is_decompressor = true;	
+ 
+-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
++	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
+ 	dinfo->mj2_handle = mj2;
+ 	if(mj2) {
+ 		mj2->cinfo = (opj_common_ptr)dinfo;
+@@ -2806,10 +2794,10 @@
+ 
+ opj_cinfo_t* mj2_create_compress() {
+ 	opj_mj2_t* mj2;
+-	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_malloc(sizeof(opj_cinfo_t));
++	opj_cinfo_t *cinfo = (opj_cinfo_t*) opj_calloc(1, sizeof(opj_cinfo_t));
+ 	if(!cinfo) return NULL;
+ 
+-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
++	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
+ 	cinfo->mj2_handle = mj2;
+ 	if(mj2) {
+ 		mj2->cinfo = (opj_common_ptr)cinfo;
+@@ -2831,16 +2819,14 @@
+ 
+ 		movie->brand = MJ2_MJ2;  // One brand: MJ2
+ 		movie->num_cl = 2;	  // Two compatible brands: MJ2 and MJ2S
+-		movie->cl = (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
++		movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+ 		movie->cl[0] = MJ2_MJ2;
+ 		movie->cl[1] = MJ2_MJ2S;
+ 		movie->minversion = 0;	  // Minimum version: 0		
+ 
+-		movie->tk = (mj2_tk_t*) malloc (sizeof(mj2_tk_t)); //Memory allocation for the video track
+-		movie->tk[0].sample = (mj2_sample_t*) malloc (sizeof(mj2_sample_t));
+-		movie->tk[0].chunk = (mj2_chunk_t *) malloc(sizeof(mj2_chunk_t));  
+-		movie->tk[0].track_type = 0;	  // Video track
++		movie->tk = (mj2_tk_t*) opj_malloc(sizeof(mj2_tk_t)); //Memory allocation for the video track
+ 		movie->tk[0].track_ID = 1;	  // Track ID = 1 
++		movie->tk[0].track_type = 0;	  // Video track
+ 		movie->tk[0].Dim[0] = parameters->Dim[0];
+ 		movie->tk[0].Dim[1] = parameters->Dim[1];
+ 		movie->tk[0].w = parameters->w;
+@@ -2848,17 +2834,19 @@
+ 		movie->tk[0].CbCr_subsampling_dx = parameters->CbCr_subsampling_dx;
+ 		movie->tk[0].CbCr_subsampling_dy = parameters->CbCr_subsampling_dy;
+ 		movie->tk[0].sample_rate = parameters->frame_rate;
+-		
++		movie->tk[0].name_size = 0;
++		movie->tk[0].chunk = (mj2_chunk_t*) opj_malloc(sizeof(mj2_chunk_t));  
++		movie->tk[0].sample = (mj2_sample_t*) opj_malloc(sizeof(mj2_sample_t));
++
+ 		jp2_struct = &movie->tk[0].jp2_struct;
+ 		jp2_struct->numcomps = 3;	// NC  		
+-		jp2_struct->comps =
+-			(opj_jp2_comps_t *) malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
++		jp2_struct->comps = (opj_jp2_comps_t*) opj_malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
+ 		jp2_struct->precedence = 0;   /* PRECEDENCE*/
+ 		jp2_struct->approx = 0;   /* APPROX*/		
+ 		jp2_struct->brand = JP2_JP2;	/* BR         */
+ 		jp2_struct->minversion = 0;	/* MinV       */
+ 		jp2_struct->numcl = 1;
+-		jp2_struct->cl = (unsigned int *) malloc(jp2_struct->numcl * sizeof(int));
++		jp2_struct->cl = (unsigned int*) opj_malloc(jp2_struct->numcl * sizeof(int));
+ 		jp2_struct->cl[0] = JP2_JP2;	/* CL0 : JP2  */		
+ 		jp2_struct->C = 7;      /* C : Always 7*/
+ 		jp2_struct->UnkC = 0;      /* UnkC, colorspace specified in colr box*/
+diff -urN -x.svn ../trunk.orig/mj2/mj2_to_frames.c ./mj2/mj2_to_frames.c
+--- ../trunk.orig/mj2/mj2_to_frames.c	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/mj2_to_frames.c	2007-11-27 22:39:50.000000000 +0000
+@@ -25,7 +25,14 @@
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+ 
+-#include "opj_includes.h"
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++
++#include "openjpeg.h"
++#include "j2k_lib.h"
++#include "j2k.h"
++#include "jp2.h"
+ #include "mj2.h"
+ #include "mj2_convert.h"
+ 
+diff -urN -x.svn ../trunk.orig/mj2/wrap_j2k_in_mj2.c ./mj2/wrap_j2k_in_mj2.c
+--- ../trunk.orig/mj2/wrap_j2k_in_mj2.c	2007-09-28 11:36:31.000000000 +0100
++++ ./mj2/wrap_j2k_in_mj2.c	2007-11-27 22:39:50.000000000 +0000
+@@ -26,9 +26,20 @@
+  * POSSIBILITY OF SUCH DAMAGE.
+  */
+ 
+-#include "opj_includes.h"
++#include <stdio.h>
++#include <stdlib.h>
++#include <string.h>
++
++#include "openjpeg.h"
++#include "j2k.h"
++#include "jp2.h"
++#include "cio.h"
+ #include "mj2.h"
+ 
++static int int_ceildiv(int a, int b) {
++	return (a + b - 1) / b;
++}
++
+ /**
+ Size of memory first allocated for MOOV box
+ */
+diff -urN -x.svn ../trunk.orig/OPJViewer/Makefile ./OPJViewer/Makefile
+--- ../trunk.orig/OPJViewer/Makefile	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/Makefile	2007-12-01 18:40:47.000000000 +0000
+@@ -1,41 +1,41 @@
+-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
+-
+-# General configuration variables:
+-CC = $(shell wx-config-2.8 --cxx)
+-AR = ar
+-
+-CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
+-
+-OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp
+-
+-MODULES = $(OPJV_SRCS:.cpp=.o)
+-
+-all: opjviewer lib
+-
+-.cpp.o:
+-	$(CC) $(CFLAGS) -c $< -o $@
+-
+-lib:
+-	cd ../jpwl; make
+-
+-opjviewer: $(OPJV_SRCS) lib
+-	$(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)  
+-
+-
+-clean:
+-	rm -f OPJViewer *.o *.a
+-	cd ../libopenjpeg; rm -f *.o
+-
+-
+-
+-
+-#.cpp.o :
+-#	$(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
+-
+-#all:    $(PROGRAM)
+-
+-#$(PROGRAM):     $(OBJECTS)
+-#	$(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
+-
+-#clean:
+-#	rm -f *.o $(PROGRAM)
++# Makefile for OPJViewer
++
++# General configuration variables:
++CC = $(shell wx-config-2.8 --cxx)
++AR = ar
++
++CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
++
++OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp source/OPJViewer.cpp source/OPJThreads.cpp
++
++MODULES = $(OPJV_SRCS:.cpp=.o)
++
++all: opjviewer lib
++
++.cpp.o:
++	$(CC) $(CFLAGS) -c $< -o $@
++
++lib:
++	cd ../jpwl; make
++
++opjviewer: $(OPJV_SRCS) lib
++        $(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)
++
++
++clean:
++	rm -f OPJViewer *.o *.a
++	cd ../libopenjpeg; rm -f *.o
++
++
++
++
++#.cpp.o :
++#       $(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
++
++#all:    $(PROGRAM)
++
++#$(PROGRAM):     $(OBJECTS)
++#       $(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
++
++#clean:
++#       rm -f *.o $(PROGRAM)
+diff -urN -x.svn ../trunk.orig/OPJViewer/OPJViewer.dsp ./OPJViewer/OPJViewer.dsp
+--- ../trunk.orig/OPJViewer/OPJViewer.dsp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/OPJViewer.dsp	2007-12-01 18:40:47.000000000 +0000
+@@ -42,15 +42,15 @@
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+-# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "c:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /D "OPJ_INICONFIG" /FR /FD /c
++# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /I "../libopenjpeg" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /D "USE_MXF" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /D "OPJ_INICONFIG" /FR /FD /c
+ # ADD BASE RSC /l 0x410 /d "NDEBUG"
+-# ADD RSC /l 0x409 /i "c:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
++# ADD RSC /l 0x409 /i "d:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"c:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
++# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
+ # SUBTRACT LINK32 /pdb:none
+ # Begin Special Build Tool
+ SOURCE="$(InputPath)"
+@@ -72,15 +72,15 @@
+ # PROP Ignore_Export_Lib 0
+ # PROP Target_Dir ""
+ # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "d:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
++# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "c:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "c:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
+ # ADD BASE RSC /l 0x410 /d "_DEBUG"
+-# ADD RSC /l 0x410 /i "d:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
++# ADD RSC /l 0x410 /i "c:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
+ BSC32=bscmake.exe
+ # ADD BASE BSC32 /nologo
+ # ADD BSC32 /nologo
+ LINK32=link.exe
+ # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlibd.lib wxregexd.lib wxpngd.lib wxjpegd.lib wxtiffd.lib wxbase28d.lib wxmsw28d_core.lib wxmsw28d_html.lib wxmsw28d_adv.lib LibOpenJPEG_JPWLd.lib /nologo /subsystem:windows /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Debug"
++# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlibd.lib wxregexd.lib wxpngd.lib wxjpegd.lib wxtiffd.lib wxbase28d.lib wxmsw28d_core.lib wxmsw28d_html.lib wxmsw28d_adv.lib LibOpenJPEG_JPWLd.lib /nologo /subsystem:windows /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"c:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Debug"
+ # SUBTRACT LINK32 /pdb:none
+ 
+ !ENDIF 
+@@ -111,6 +111,26 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=.\source\imagmxf.cpp
++# End Source File
++# Begin Source File
++
++SOURCE=..\codec\index.c
++# End Source File
++# Begin Source File
++
++SOURCE=.\source\OPJAbout.cpp
++# End Source File
++# Begin Source File
++
++SOURCE=.\source\OPJDialogs.cpp
++# End Source File
++# Begin Source File
++
++SOURCE=.\source\OPJThreads.cpp
++# End Source File
++# Begin Source File
++
+ SOURCE=.\source\OPJViewer.cpp
+ # End Source File
+ # Begin Source File
+@@ -156,6 +176,14 @@
+ # End Source File
+ # Begin Source File
+ 
++SOURCE=.\source\imagmxf.h
++# End Source File
++# Begin Source File
++
++SOURCE=..\codec\index.h
++# End Source File
++# Begin Source File
++
+ SOURCE=.\source\OPJViewer.h
+ # End Source File
+ # End Group
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/about_htm.h ./OPJViewer/source/about_htm.h
+--- ../trunk.orig/OPJViewer/source/about_htm.h	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/about_htm.h	2007-11-27 22:39:50.000000000 +0000
+@@ -24,8 +24,8 @@
+ "In addition to the basic codec, various other features are under development.</font><br>"
+ "<font size=-2 color=red>* Build: ")
+ #include "build.h"
+-wxT("</font><br>")
+-wxT("<font size=-2 color=red>* " wxVERSION_STRING ", " __DATE__ ", " __TIME__ "</font><br>")
++wxT(", " __DATE__ ", " __TIME__ "</font><br>")
++wxT("<font size=-2 color=red>* " wxVERSION_STRING "</font><br>")
+ #ifdef USE_JPWL
+ wxT("<font size=-2 color=green>- Compiled with JPWL support</font><br>")
+ #endif // USE_JPWL
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/build.h ./OPJViewer/source/build.h
+--- ../trunk.orig/OPJViewer/source/build.h	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/build.h	2007-12-01 18:40:47.000000000 +0000
+@@ -1 +1 @@
+-wxT("219") 
++wxT("404") 
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagj2k.cpp ./OPJViewer/source/imagj2k.cpp
+--- ../trunk.orig/OPJViewer/source/imagj2k.cpp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/imagj2k.cpp	2007-12-01 18:40:47.000000000 +0000
+@@ -189,7 +189,7 @@
+ 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+ 
+ 	/* decode the stream and fill the image structure */
+-	opjimage = opj_decode(dinfo, cio, &cstr_info);
++	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+ 	if (!opjimage) {
+ #ifndef __WXGTK__ 
+ 		wxMutexGuiEnter();
+@@ -231,6 +231,11 @@
+ 
+ }
+ 
++#define CINEMA_24_CS 1302083	/* Codestream length for 24fps */
++#define CINEMA_48_CS 651041		/* Codestream length for 48fps */
++#define COMP_24_CS 1041666		/* Maximum size per color component for 2K & 4K @ 24fps */
++#define COMP_48_CS 520833		/* Maximum size per color component for 2K @ 48fps */
++
+ // save the j2k codestream
+ bool wxJ2KHandler::SaveFile( wxImage *wimage, wxOutputStream& stream, bool verbose )
+ {
+@@ -261,15 +266,15 @@
+ 	parameters.cp_cinema = OFF;
+ 
+ 	/* subsampling */
+-	if (sscanf(m_subsampling.c_str(), wxT("%d,%d"), &(parameters.subsampling_dx), &(parameters.subsampling_dy)) != 2) {
++	if (sscanf(m_subsampling.ToAscii(), "%d,%d", &(parameters.subsampling_dx), &(parameters.subsampling_dy)) != 2) {
+ 		wxLogError(wxT("Wrong sub-sampling encoder setting: dx,dy"));
+ 		return false;
+ 	}
+ 
+ 	/* compression rates */
+-	if (m_rates != wxT("")) {
+-		char *s1 = (char *) m_rates.c_str();
+-		wxLogMessage("rates %s", s1);
++	if ((m_rates != wxT("")) && (!m_enablequality)) {
++		const char *s1 = m_rates.ToAscii();
++		wxLogMessage(wxT("rates %s"), s1);
+ 		while (sscanf(s1, "%f", &(parameters.tcp_rates[parameters.tcp_numlayers])) == 1) {
+ 			parameters.tcp_numlayers++;
+ 			while (*s1 && *s1 != ',') {
+@@ -279,14 +284,14 @@
+ 				break;
+ 			s1++;
+ 		}
+-		wxLogMessage("%d layers", parameters.tcp_numlayers);
++		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+ 		parameters.cp_disto_alloc = 1;
+ 	}
+ 
+ 	/* image quality, dB */
+-	if (m_rates == wxT("")) {
+-		char *s2 = (char *) m_quality.c_str();
+-		wxLogMessage("qualities %s", s2);
++	if ((m_quality != wxT("")) && (m_enablequality)) {
++		const char *s2 = m_quality.ToAscii();
++		wxLogMessage(wxT("qualities %s"), s2);
+ 		while (sscanf(s2, "%f", &parameters.tcp_distoratio[parameters.tcp_numlayers]) == 1) {
+ 			parameters.tcp_numlayers++;
+ 			while (*s2 && *s2 != ',') {
+@@ -296,21 +301,21 @@
+ 				break;
+ 			s2++;
+ 		}
+-		wxLogMessage("%d layers", parameters.tcp_numlayers);
++		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+ 		parameters.cp_fixed_quality = 1;
+ 	}
+ 
+ 	/* image origin */
+-	if (sscanf(m_origin.c_str(), "%d,%d", &parameters.image_offset_x0, &parameters.image_offset_y0) != 2) {
++	if (sscanf(m_origin.ToAscii(), "%d,%d", &parameters.image_offset_x0, &parameters.image_offset_y0) != 2) {
+ 		wxLogError(wxT("bad coordinate of the image origin: x0,y0"));
+ 		return false;
+ 	}
+ 				
+ 	/* Create comment for codestream */
+ 	if(m_enablecomm) {
+-		parameters.cp_comment = (char *) malloc(strlen(m_comment.c_str()) + 1);
++		parameters.cp_comment = (char *) malloc(strlen(m_comment.ToAscii()) + 1);
+ 		if(parameters.cp_comment) {
+-			strcpy(parameters.cp_comment, m_comment.c_str());
++			strcpy(parameters.cp_comment, m_comment.ToAscii());
+ 		}
+ 	} else {
+ 		parameters.cp_comment = NULL;
+@@ -318,8 +323,8 @@
+ 
+ 	/* indexing file */
+ 	if (m_enableidx) {
+-		strncpy(indexfilename, m_index.c_str(), OPJ_PATH_LEN);
+-		wxLogMessage("index file is %s", indexfilename);
++		strncpy(indexfilename, m_index.ToAscii(), OPJ_PATH_LEN);
++		wxLogMessage(wxT("index file is %s"), indexfilename);
+ 	}
+ 
+ 	/* if no rate entered, lossless by default */
+@@ -338,9 +343,9 @@
+ 	/* codeblocks size */
+ 	if (m_cbsize != wxT("")) {
+ 		int cblockw_init = 0, cblockh_init = 0;
+-		sscanf(m_cbsize.c_str(), "%d,%d", &cblockw_init, &cblockh_init);
++		sscanf(m_cbsize.ToAscii(), "%d,%d", &cblockw_init, &cblockh_init);
+ 		if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024 || cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+-			wxLogError("!! Size of code_block error !! Restrictions:\n  width*height<=4096\n  4<=width,height<= 1024");
++			wxLogError(wxT("!! Size of code_block error !! Restrictions:\n  width*height<=4096\n  4<=width,height<= 1024"));
+ 			return false;
+ 		}
+ 		parameters.cblockw_init = cblockw_init;
+@@ -364,13 +369,13 @@
+ 
+ 	/* tiles */
+ 	if (m_tsize != wxT("")) {
+-		sscanf(m_tsize.c_str(), "%d,%d", &parameters.cp_tdx, &parameters.cp_tdy);
++		sscanf(m_tsize.ToAscii(), "%d,%d", &parameters.cp_tdx, &parameters.cp_tdy);
+ 		parameters.tile_size_on = true;
+ 	}
+ 
+ 	/* tile origin */
+-	if (sscanf(m_torigin.c_str(), "%d,%d", &parameters.cp_tx0, &parameters.cp_ty0) != 2) {
+-		wxLogError("tile offset setting error: X0,Y0");
++	if (sscanf(m_torigin.ToAscii(), "%d,%d", &parameters.cp_tx0, &parameters.cp_ty0) != 2) {
++		wxLogError(wxT("tile offset setting error: X0,Y0"));
+ 		return false;
+ 	}
+ 
+@@ -382,14 +387,103 @@
+ 	if (m_enableeph)
+ 		parameters.csty |= 0x04;
+ 
++	/* multiple component transform */
++	if (m_multicomp)
++		parameters.tcp_mct = 1;
++	else
++		parameters.tcp_mct = 0;
++
++	/* mode switch */
++	parameters.mode = (m_enablebypass ? 1 : 0) + (m_enablereset ? 2 : 0)
++		+ (m_enablerestart ? 4 : 0) + (m_enablevsc ? 8 : 0)
++		+ (m_enableerterm ? 16 : 0) + (m_enablesegmark ? 32 : 0);
++
++	/* progression order */
++	switch (m_progression) {
++
++		/* LRCP */
++	case 0:
++		parameters.prog_order = LRCP;
++		break;
++
++		/* RLCP */
++	case 1:
++		parameters.prog_order = RLCP;
++		break;
++
++		/* RPCL */
++	case 2:
++		parameters.prog_order = RPCL;
++		break;
++
++		/* PCRL */
++	case 3:
++		parameters.prog_order = PCRL;
++		break;
++
++		/* CPRL */
++	case 4:
++		parameters.prog_order = CPRL;
++		break;
++
++		/* DCI2K24 */
++	case 5:
++		parameters.cp_cinema = CINEMA2K_24;
++		parameters.cp_rsiz = CINEMA2K;
++		break;
++
++		/* DCI2K48 */
++	case 6:
++		parameters.cp_cinema = CINEMA2K_48;
++		parameters.cp_rsiz = CINEMA2K;
++		break;
++
++		/* DCI4K */
++	case 7:
++		parameters.cp_cinema = CINEMA4K_24;
++		parameters.cp_rsiz = CINEMA4K;
++		break;
++
++	default:
++		break;
++	}
++
++	/* check cinema */
++	if (parameters.cp_cinema) {
++
++		/* set up */
++		parameters.tile_size_on = false;
++		parameters.cp_tdx=1;
++		parameters.cp_tdy=1;
++		
++		/*Tile part*/
++		parameters.tp_flag = 'C';
++		parameters.tp_on = 1;
++
++		/*Tile and Image shall be at (0,0)*/
++		parameters.cp_tx0 = 0;
++		parameters.cp_ty0 = 0;
++		parameters.image_offset_x0 = 0;
++		parameters.image_offset_y0 = 0;
++
++		/*Codeblock size= 32*32*/
++		parameters.cblockw_init = 32;	
++		parameters.cblockh_init = 32;
++		parameters.csty |= 0x01;
++
++		/*The progression order shall be CPRL*/
++		parameters.prog_order = CPRL;
++
++		/* No ROI */
++		parameters.roi_compno = -1;
++
++		parameters.subsampling_dx = 1;
++		parameters.subsampling_dy = 1;
+ 
++		/* 9-7 transform */
++		parameters.irreversible = 1;
+ 
+-	/* compression settings */
+-	//parameters.tcp_numlayers = 1;
+-	//parameters.tcp_rates[0] = 10.0;
+-	//parameters.cp_disto_alloc = 1;
+-	//parameters.irreversible = 1;
+-	parameters.tcp_mct = 1;
++	}				
+ 
+ 	/* convert wx image into opj image */
+ 	cmptparm = (opj_image_cmptparm_t*) malloc(3 * sizeof(opj_image_cmptparm_t));
+@@ -429,6 +523,103 @@
+ 			oimage->comps[2].data[i] = *(value++);
+ 	}
+ 
++	/* check cinema again */
++	if (parameters.cp_cinema) {
++		int i;
++		float temp_rate;
++		opj_poc_t *POC = NULL;
++
++		switch (parameters.cp_cinema) {
++
++		case CINEMA2K_24:
++		case CINEMA2K_48:
++			if (parameters.numresolution > 6) {
++				parameters.numresolution = 6;
++			}
++			if (!((oimage->comps[0].w == 2048) | (oimage->comps[0].h == 1080))) {
++				wxLogWarning(wxT("Image coordinates %d x %d is not 2K compliant. JPEG Digital Cinema Profile-3 "
++					"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080"),
++					oimage->comps[0].w, oimage->comps[0].h);
++				parameters.cp_rsiz = STD_RSIZ;
++			}
++		break;
++		
++		case CINEMA4K_24:
++			if (parameters.numresolution < 1) {
++					parameters.numresolution = 1;
++			} else if (parameters.numresolution > 7) {
++					parameters.numresolution = 7;
++			}
++			if (!((oimage->comps[0].w == 4096) | (oimage->comps[0].h == 2160))) {
++				wxLogWarning(wxT("Image coordinates %d x %d is not 4K compliant. JPEG Digital Cinema Profile-4" 
++					"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160"),
++					oimage->comps[0].w, oimage->comps[0].h);
++				parameters.cp_rsiz = STD_RSIZ;
++			}
++			parameters.POC[0].tile  = 1; 
++			parameters.POC[0].resno0  = 0; 
++			parameters.POC[0].compno0 = 0;
++			parameters.POC[0].layno1  = 1;
++			parameters.POC[0].resno1  = parameters.numresolution - 1;
++			parameters.POC[0].compno1 = 3;
++			parameters.POC[0].prg1 = CPRL;
++			parameters.POC[1].tile  = 1;
++			parameters.POC[1].resno0  = parameters.numresolution - 1; 
++			parameters.POC[1].compno0 = 0;
++			parameters.POC[1].layno1  = 1;
++			parameters.POC[1].resno1  = parameters.numresolution;
++			parameters.POC[1].compno1 = 3;
++			parameters.POC[1].prg1 = CPRL;
++			parameters.numpocs = 2;
++			break;
++		}
++
++		switch (parameters.cp_cinema) {
++		case CINEMA2K_24:
++		case CINEMA4K_24:
++			for (i = 0 ; i < parameters.tcp_numlayers; i++) {
++				temp_rate = 0;
++				if (parameters.tcp_rates[i] == 0) {
++					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++					(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++				}else{
++					temp_rate = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++					if (temp_rate > CINEMA_24_CS ) {
++						parameters.tcp_rates[i]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++						(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++					} else {
++						/* do nothing */
++					}
++				}
++			}
++			parameters.max_comp_size = COMP_24_CS;
++			break;
++			
++		case CINEMA2K_48:
++			for (i = 0; i < parameters.tcp_numlayers; i++) {
++				temp_rate = 0 ;
++				if (parameters.tcp_rates[i] == 0) {
++					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++					(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++				}else{
++					temp_rate =((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++					if (temp_rate > CINEMA_48_CS ){
++						parameters.tcp_rates[0]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
++						(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
++					}else{
++						/* do nothing */
++					}
++				}
++			}
++			parameters.max_comp_size = COMP_48_CS;
++			break;
++		}
++
++		parameters.cp_disto_alloc = 1;
++	}
++	
+ 	/* get a J2K compressor handle */
+ 	opj_cinfo_t* cinfo = opj_create_compress(CODEC_J2K);
+ 
+@@ -443,7 +634,7 @@
+ 	cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+ 
+ 	/* encode the image */
+-	bSuccess = opj_encode(cinfo, cio, oimage, &cstr_info);
++	bSuccess = opj_encode_with_info(cinfo, cio, oimage, &cstr_info);
+ 	if (!bSuccess) {
+ 
+ 		opj_cio_close(cio);
+@@ -479,8 +670,7 @@
+ 
+ 	/* Write the index to disk */
+ 	if (*indexfilename) {
+-		bSuccess = write_index_file(&cstr_info, indexfilename);
+-		if (bSuccess) {
++		if (write_index_file(&cstr_info, indexfilename)) {
+ 			wxLogError(wxT("Failed to output index file"));
+ 		}
+ 	}
+@@ -526,231 +716,6 @@
+     return hdr[0] == 0xFF && hdr[1] == 0x4F;
+ }
+ 
+-/**
+-Create an index and write it to a file
+-@param cstr_info Codestream information 
+-@param index Index filename
+-@return Returns 0 if successful, returns 1 otherwise
+-*/
+-bool wxJ2KHandler::write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+-	FILE *stream = NULL;
+-	int tilepartno;
+-
+-	if (!cstr_info)		
+-		return 1;
+-
+-	stream = fopen(index, "w");
+-	if (!stream) {
+-		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+-		return 1;
+-	}
+-	
+-	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+-	fprintf(stream, "%d\n", cstr_info->prog);
+-	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+-	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+-	fprintf(stream, "%d\n", cstr_info->numcomps);
+-	fprintf(stream, "%d\n", cstr_info->numlayers);
+-	fprintf(stream, "%d\n", cstr_info->numdecompos);
+-	
+-	for (resno = cstr_info->numdecompos; resno >= 0; resno--) {
+-		fprintf(stream, "[%d,%d] ", 
+-			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 */
+-	}
+-	fprintf(stream, "\n");
+-	fprintf(stream, "%d\n", cstr_info->main_head_start);
+-	fprintf(stream, "%d\n", cstr_info->main_head_end);
+-	fprintf(stream, "%d\n", cstr_info->codestream_size);
+-	
+-	fprintf(stream, "\nINFO ON TILES\n");
+-	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts\n");
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		fprintf(stream, "%4d %9d %9d %9d %9d\n",
+-			cstr_info->tile[tileno].tileno,
+-			cstr_info->tile[tileno].start_pos,
+-			cstr_info->tile[tileno].end_header,
+-			cstr_info->tile[tileno].end_pos,
+-			cstr_info->tile[tileno].num_tps);
+-	}
+-		
+-	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+-		int start_pos, end_ph_pos, end_pos;
+-		pack_nb = 0;
+-
+-		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+-		fprintf(stream, "part_nb tileno  num_packs  start_pos end_tph_pos   end_pos\n");
+-		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+-			fprintf(stream, "%4d %9d  %9d  %9d %11d %9d\n",
+-				tilepartno, tileno,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+-				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+-				);
+-		if (cstr_info->prog == LRCP) {	/* LRCP */
+-			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos\n");
+-
+-			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-				for (resno = 0; resno < cstr_info->numdecompos + 1; resno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d\n",
+-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* LRCP */
+-		else if (cstr_info->prog == RLCP) {	/* RLCP */
+-
+-			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
+-
+-			for (resno = 0; resno < cstr_info->numdecompos + 1; resno++) {
+-				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-						int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-						for (precno = 0; precno < prec_max; precno++) {
+-							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d\n",
+-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
+-							pack_nb++;
+-						}
+-					}
+-				}
+-			}
+-		} /* RLCP */
+-		else if (cstr_info->prog == RPCL) {	/* RPCL */
+-
+-			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (resno = 0; resno < cstr_info->numdecompos + 1; resno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* compno */
+-			} /* resno */
+-		} /* RPCL */
+-		else if (cstr_info->prog == PCRL) {	/* PCRL */
+-			/* I suppose components have same XRsiz, YRsiz */
+-			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-			int x1 = x0 + cstr_info->tile_x;
+-			int y1 = y0 + cstr_info->tile_y;
+-
+-			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				for (resno = 0; resno < cstr_info->numdecompos + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {							
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {									
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							} 
+-						}  /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* PCRL */
+-		else {	/* CPRL */
+-
+-			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos\n"); 
+-
+-			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+-				/* I suppose components have same XRsiz, YRsiz */
+-				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+-				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+-				int x1 = x0 + cstr_info->tile_x;
+-				int y1 = y0 + cstr_info->tile_y;
+-				
+-				for (resno = 0; resno < cstr_info->numdecompos + 1; resno++) {
+-					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+-					for (precno = 0; precno < prec_max; precno++) {
+-						int pcnx = cstr_info->tile[tileno].pw[resno];
+-						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos - resno );
+-						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos - resno );
+-						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+-						int precno_y = (int) floor( (float)precno/(float)pcnx );
+-						for(y = y0; y < y1; y++) {
+-							if (precno_y*pcy == y ) {
+-								for (x = x0; x < x1; x++) {
+-									if (precno_x*pcx == x ) {
+-										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+-											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+-											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+-											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d\n",
+-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
+-											pack_nb++; 
+-										}
+-									}
+-								}/* x = x0..x1 */
+-							}
+-						} /* y = y0..y1 */
+-					} /* precno */
+-				} /* resno */
+-			} /* compno */
+-		} /* CPRL */   
+-	} /* tileno */
+-	
+-	fclose(stream);
+-
+-	fprintf(stderr,"Generated index file %s\n", index);
+-
+-	return true;
+-}
+-
+ #endif   // wxUSE_STREAMS
+ 
+ #endif   // wxUSE_LIBOPENJPEG
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagj2k.h ./OPJViewer/source/imagj2k.h
+--- ../trunk.orig/OPJViewer/source/imagj2k.h	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/imagj2k.h	2007-12-01 18:40:47.000000000 +0000
+@@ -45,6 +45,7 @@
+ 
+ #include "wx/image.h"
+ #include "libopenjpeg/openjpeg.h"
++#include "codec/index.h"
+ 
+ #define wxBITMAP_TYPE_J2K	47
+ 
+@@ -82,8 +83,11 @@
+ 		m_origin = wxT("0,0");
+ 		m_rates = wxT("20,10,5");
+ 		m_quality = wxT("30,35,40");
++		m_enablequality = false;
++		m_multicomp = false;
+ 		m_irreversible = false;
+ 		m_resolutions = 6;
++		m_progression = 0;
+ 		m_cbsize = wxT("32,32");
+ 		m_prsize = wxT("[128,128],[128,128]");
+ 		m_tsize = wxT("");
+@@ -92,11 +96,19 @@
+ 		m_resilience*/
+ 		m_enablesop = false;
+ 		m_enableeph = false;
++		m_enablereset = false;
++		m_enablesegmark = false;
++		m_enablevsc = false;
++		m_enablerestart = false;
++		m_enableerterm = false;
++		m_enablebypass = false;
+ 		/*m_roicompo
+ 		m_roiup
+ 		m_indexfname*/
+ 		m_enableidx = false;
+ 		m_index = wxT("index.txt");
++		m_enablepoc = false;
++		m_poc = wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL");
+ 		m_enablecomm = true;
+ 
+ #if defined __WXMSW__
+@@ -108,9 +120,9 @@
+ #endif
+ 
+ #ifdef USE_JPWL
+-		m_comment += wxString::Format("%s with JPWL", opj_version());
++		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+ #else
+-		m_comment += wxString::Format("%s", opj_version());
++		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+ #endif
+ 
+     }
+@@ -127,8 +139,11 @@
+ 	wxString m_origin;
+ 	wxString m_rates;
+ 	wxString m_quality;
++	bool m_enablequality;
++	bool m_multicomp;
+ 	bool m_irreversible;
+ 	int m_resolutions;
++	int m_progression;
+ 	wxString m_cbsize;
+ 	wxString m_prsize;
+ 	wxString m_tsize;
+@@ -137,6 +152,12 @@
+ 	m_resilience*/
+ 	bool m_enablesop;
+ 	bool m_enableeph;
++	bool m_enablebypass;
++	bool m_enableerterm;
++	bool m_enablerestart;
++	bool m_enablereset;
++	bool m_enablesegmark;
++	bool m_enablevsc;
+ 	/*m_roicompo
+ 	m_roiup
+ 	m_indexfname*/
+@@ -144,8 +165,8 @@
+ 	wxString m_index;
+ 	bool m_enablecomm;
+ 	wxString m_comment;
+-
+-	bool write_index_file(opj_codestream_info_t *cstr_info, char *index);
++	bool m_enablepoc;
++	wxString m_poc;
+ 
+ #if wxUSE_STREAMS
+     virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
+@@ -155,6 +176,7 @@
+ #endif
+ 
+ private:
++	OPJ_PROG_ORDER give_progression(char progression[4]);
+     DECLARE_DYNAMIC_CLASS(wxJ2KHandler)
+ };
+ 
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagjp2.cpp ./OPJViewer/source/imagjp2.cpp
+--- ../trunk.orig/OPJViewer/source/imagjp2.cpp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/imagjp2.cpp	2007-11-27 22:39:50.000000000 +0000
+@@ -194,7 +194,7 @@
+ 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+ 
+ 	/* decode the stream and fill the image structure */
+-	opjimage = opj_decode(dinfo, cio, &cstr_info);
++	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+ 	if (!opjimage) {
+ #ifndef __WXGTK__ 
+ 		wxMutexGuiEnter();
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagmj2.cpp ./OPJViewer/source/imagmj2.cpp
+--- ../trunk.orig/OPJViewer/source/imagmj2.cpp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/imagmj2.cpp	2007-11-27 22:39:50.000000000 +0000
+@@ -700,7 +700,7 @@
+ 	cio = opj_cio_open((opj_common_ptr)dinfo, src, my_jPheadSIZE + jp2hboxlen + jp2cboxlen);
+ 
+ 	/* decode the stream and fill the image structure */
+-	opjimage = opj_decode(dinfo, cio, &cstr_info);
++	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+ 	if (!opjimage) {
+ 		wxMutexGuiEnter();
+ 		wxLogError(wxT("MJ2: failed to decode image!"));
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagmxf.cpp ./OPJViewer/source/imagmxf.cpp
+--- ../trunk.orig/OPJViewer/source/imagmxf.cpp	1970-01-01 01:00:00.000000000 +0100
++++ ./OPJViewer/source/imagmxf.cpp	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,274 @@
++/*
++ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++/////////////////////////////////////////////////////////////////////////////
++// Name:        imagmxf.cpp
++// Purpose:     wxImage MXF (Material eXchange Format) JPEG 2000 file format handler
++// Author:      Giuseppe Baruffa - based on imagjpeg.cpp, Vaclav Slavik
++// RCS-ID:      $Id: imagmxf.cpp,v 0.00 2007/11/19 17:00:00 MW Exp $
++// Copyright:   (c) Giuseppe Baruffa
++// Licence:     wxWindows licence
++/////////////////////////////////////////////////////////////////////////////
++
++#ifdef USE_MXF
++
++// For compilers that support precompilation, includes "wx.h".
++#include "wx/wxprec.h"
++
++#ifdef __BORLANDC__
++    #pragma hdrstop
++#endif
++
++#if wxUSE_IMAGE && wxUSE_LIBOPENJPEG
++
++#include "imagmxf.h"
++
++#ifndef WX_PRECOMP
++    #include "wx/log.h"
++    #include "wx/app.h"
++    #include "wx/intl.h"
++    #include "wx/bitmap.h"
++    #include "wx/module.h"
++#endif
++
++
++#include "libopenjpeg/openjpeg.h"
++
++
++#include "wx/filefn.h"
++#include "wx/wfstream.h"
++
++// ----------------------------------------------------------------------------
++// types
++// ----------------------------------------------------------------------------
++
++
++//-----------------------------------------------------------------------------
++// wxMXFHandler
++//-----------------------------------------------------------------------------
++
++IMPLEMENT_DYNAMIC_CLASS(wxMXFHandler,wxImageHandler)
++
++#if wxUSE_STREAMS
++
++//------------- JPEG 2000 Data Source Manager
++
++#define J2K_CFMT 0
++#define JP2_CFMT 1
++#define JPT_CFMT 2
++#define MJ2_CFMT 3
++#define PXM_DFMT 0
++#define PGX_DFMT 1
++#define BMP_DFMT 2
++#define YUV_DFMT 3
++
++#define MAX_MESSAGE_LEN 200
++
++/* sample error callback expecting a FILE* client object */
++void mxf_error_callback(const char *msg, void *client_data) {
++	int message_len = strlen(msg) - 1;
++	if (msg[message_len] != '\n')
++		message_len = MAX_MESSAGE_LEN;
++#ifndef __WXGTK__ 
++		wxMutexGuiEnter();
++#endif /* __WXGTK__ */
++	wxLogMessage(wxT("[ERROR] %.*s"), message_len, msg);
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif /* __WXGTK__ */
++}
++
++/* sample warning callback expecting a FILE* client object */
++void mxf_warning_callback(const char *msg, void *client_data) {
++	int message_len = strlen(msg) - 1;
++	if (msg[message_len] != '\n')
++		message_len = MAX_MESSAGE_LEN;
++#ifndef __WXGTK__ 
++		wxMutexGuiEnter();
++#endif /* __WXGTK__ */
++	wxLogMessage(wxT("[WARNING] %.*s"), message_len, msg);
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif /* __WXGTK__ */
++}
++
++/* sample debug callback expecting no client object */
++void mxf_info_callback(const char *msg, void *client_data) {
++	int message_len = strlen(msg) - 1;
++	if (msg[message_len] != '\n')
++		message_len = MAX_MESSAGE_LEN;
++#ifndef __WXGTK__ 
++		wxMutexGuiEnter();
++#endif /* __WXGTK__ */
++	wxLogMessage(wxT("[INFO] %.*s"), message_len, msg);
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif /* __WXGTK__ */
++}
++
++
++/////////////////////////////////////////////////
++/////////////////////////////////////////////////
++
++// load the mxf file format
++bool wxMXFHandler::LoadFile(wxImage *image, wxInputStream& stream, bool verbose, int index)
++{
++	opj_dparameters_t parameters;	/* decompression parameters */
++	opj_event_mgr_t event_mgr;		/* event manager */
++	opj_image_t *opjimage = NULL;
++	unsigned char *src = NULL;
++    unsigned char *ptr;
++	int file_length, j2k_point, j2k_len;
++	opj_codestream_info_t cstr_info;  /* Codestream information structure */
++
++	// destroy the image
++    image->Destroy();
++
++	/* handle to a decompressor */
++	opj_dinfo_t* dinfo = NULL;	
++	opj_cio_t *cio = NULL;
++
++	/* configure the event callbacks (not required) */
++	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
++	event_mgr.error_handler = mxf_error_callback;
++	event_mgr.warning_handler = mxf_warning_callback;
++	event_mgr.info_handler = mxf_info_callback;
++
++	/* set decoding parameters to default values */
++	opj_set_default_decoder_parameters(&parameters);
++
++	/* prepare parameters */
++	strncpy(parameters.infile, "", sizeof(parameters.infile)-1);
++	strncpy(parameters.outfile, "", sizeof(parameters.outfile)-1);
++	parameters.decod_format = J2K_CFMT;
++	parameters.cod_format = BMP_DFMT;
++	if (m_reducefactor)
++		parameters.cp_reduce = m_reducefactor;
++	if (m_qualitylayers)
++		parameters.cp_layer = m_qualitylayers;
++	/*if (n_components)
++		parameters. = n_components;*/
++
++	/* JPWL only */
++#ifdef USE_JPWL
++	parameters.jpwl_exp_comps = m_expcomps;
++	parameters.jpwl_max_tiles = m_maxtiles;
++	parameters.jpwl_correct = m_enablejpwl;
++#endif /* USE_JPWL */
++
++	/* get a decoder handle */
++	dinfo = opj_create_decompress(CODEC_J2K);
++
++	/* find length of the stream */
++	stream.SeekI(0, wxFromEnd);
++	file_length = (int) stream.TellI();
++
++	/* search for the m_framenum codestream position and length  */
++	//jp2c_point = searchjp2c(stream, file_length, m_framenum);
++	//jp2c_len = searchjp2c(stream, file_length, m_framenum);
++	j2k_point = 0;
++	j2k_len = 10;
++
++	// malloc memory source
++    src = (unsigned char *) malloc(j2k_len);
++
++	// copy the jp2c
++	stream.SeekI(j2k_point, wxFromStart);
++	stream.Read(src, j2k_len);
++
++	/* catch events using our callbacks and give a local context */
++	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
++
++	/* setup the decoder decoding parameters using user parameters */
++	opj_setup_decoder(dinfo, &parameters);
++
++	/* open a byte stream */
++	cio = opj_cio_open((opj_common_ptr)dinfo, src, j2k_len);
++
++	/* decode the stream and fill the image structure */
++	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
++	if (!opjimage) {
++		wxMutexGuiEnter();
++		wxLogError(wxT("MXF: failed to decode image!"));
++		wxMutexGuiLeave();
++		opj_destroy_decompress(dinfo);
++		opj_cio_close(cio);
++		free(src);
++		return false;
++	}
++
++	/* close the byte stream */
++	opj_cio_close(cio);
++
++	/* common rendering method */
++#include "imagjpeg2000.cpp"
++
++    wxMutexGuiEnter();
++    wxLogMessage(wxT("MXF: image loaded."));
++    wxMutexGuiLeave();
++
++	/* close openjpeg structs */
++	opj_destroy_decompress(dinfo);
++	opj_image_destroy(opjimage);
++	free(src);
++
++	if (!image->Ok())
++		return false;
++	else
++		return true;
++
++}
++
++// save the mxf file format
++bool wxMXFHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )
++{
++    wxLogError(wxT("MXF: Couldn't save movie -> not implemented."));
++    return false;
++}
++
++#ifdef __VISUALC__
++    #pragma warning(default:4611)
++#endif /* VC++ */
++
++// recognize the MXF JPEG 2000 starting box
++bool wxMXFHandler::DoCanRead( wxInputStream& stream )
++{
++    unsigned char hdr[4];
++
++    if ( !stream.Read(hdr, WXSIZEOF(hdr)) )
++        return false;
++
++    return (hdr[0] == 0x06 &&
++			hdr[1] == 0x0E &&
++			hdr[2] == 0x2B &&
++			hdr[3] == 0x34);
++}
++
++#endif   // wxUSE_STREAMS
++
++#endif   // wxUSE_LIBOPENJPEG
++
++#endif // USE_MXF
++
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/imagmxf.h ./OPJViewer/source/imagmxf.h
+--- ../trunk.orig/OPJViewer/source/imagmxf.h	1970-01-01 01:00:00.000000000 +0100
++++ ./OPJViewer/source/imagmxf.h	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,96 @@
++/*
++ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++/////////////////////////////////////////////////////////////////////////////
++// Name:        imagmxf.h
++// Purpose:     wxImage MXF (Material eXchange Format) JPEG 2000 file format handler
++// Author:      G. Baruffa - based on imagjpeg.h, Vaclav Slavik
++// RCS-ID:      $Id: imagmj2.h,v 0.0 2007/11/19 17:00:00 VZ Exp $
++// Copyright:   (c) Giuseppe Baruffa
++// Licence:     wxWindows licence
++/////////////////////////////////////////////////////////////////////////////
++
++#ifndef _WX_IMAGMXF_H_
++#define _WX_IMAGMXF_H_
++
++#ifdef USE_MXF
++
++#include "wx/defs.h"
++
++//-----------------------------------------------------------------------------
++// wxMXFHandler
++//-----------------------------------------------------------------------------
++
++#if wxUSE_LIBOPENJPEG
++
++#include "wx/image.h"
++#include "libopenjpeg/openjpeg.h"
++
++#define wxBITMAP_TYPE_MXF	50
++
++class WXDLLEXPORT wxMXFHandler: public wxImageHandler
++{
++public:
++    inline wxMXFHandler()
++    {
++        m_name = wxT("MXF JPEG 2000 file format");
++        m_extension = wxT("mxf");
++        m_type = wxBITMAP_TYPE_MXF;
++        m_mime = wxT("image/mxf");
++
++		m_reducefactor = 0;
++		m_qualitylayers = 0;
++		m_components = 0;
++#ifdef USE_JPWL
++		m_enablejpwl = true;
++		m_expcomps = JPWL_EXPECTED_COMPONENTS;
++		m_maxtiles = JPWL_MAXIMUM_TILES;
++#endif // USE_JPWL
++    }
++
++		// decoding engine parameters
++		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
++#ifdef USE_JPWL
++		bool m_enablejpwl;
++		int m_expcomps, m_maxtiles;
++#endif // USE_JPWL
++
++#if wxUSE_STREAMS
++    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
++    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
++protected:
++    virtual bool DoCanRead( wxInputStream& stream );
++#endif
++
++private:
++    DECLARE_DYNAMIC_CLASS(wxMXFHandler)
++};
++
++#endif // wxUSE_LIBOPENJPEG
++
++#endif // USE_MXF
++
++#endif // _WX_IMAGMXF_H_
++
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/OPJDialogs.cpp ./OPJViewer/source/OPJDialogs.cpp
+--- ../trunk.orig/OPJViewer/source/OPJDialogs.cpp	1970-01-01 01:00:00.000000000 +0100
++++ ./OPJViewer/source/OPJDialogs.cpp	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,1373 @@
++/*
++ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita'  degli studi di Perugia (UPG), Italy
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++#include "OPJViewer.h"
++
++// ----------------------------------------------------------------------------
++// OPJDecoderDialog
++// ----------------------------------------------------------------------------
++
++IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
++
++BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
++	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
++#ifdef USE_JPWL
++	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
++#endif // USE_JPWL
++END_EVENT_TABLE()
++
++OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
++{
++	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
++
++	Create(win, wxID_ANY, wxT("Decoder settings"),
++		wxDefaultPosition, wxDefaultSize,
++		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
++		);
++
++	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
++
++	m_settingsNotebook = GetBookCtrl();
++
++	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
++	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
++	if (!wxGetApp().m_enabledeco)
++		jpeg2000Settings->Enable(false);
++	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
++	if (!wxGetApp().m_enabledeco)
++		mjpeg2000Settings->Enable(false);
++#ifdef USE_JPWL
++	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
++	if (!wxGetApp().m_enabledeco)
++		jpwlSettings->Enable(false);
++#endif // USE_JPWL
++
++	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
++	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
++	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
++#ifdef USE_JPWL
++	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
++#endif // USE_JPWL
++
++	LayoutDialog();
++}
++
++OPJDecoderDialog::~OPJDecoderDialog()
++{
++}
++
++wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++		// sub top sizer
++		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
++
++		// add decoding enabling check box
++		subtopSizer->Add(
++			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
++			0, wxGROW | wxALL, 5);
++		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
++
++		// add parsing enabling check box
++		subtopSizer->Add(
++			m_enableparseCheck = new wxCheckBox(panel, OPJDECO_ENABLEPARSE, wxT("Enable parsing"), wxDefaultPosition, wxDefaultSize),
++			0, wxGROW | wxALL, 5);
++		m_enableparseCheck->SetValue(wxGetApp().m_enableparse);
++
++			// resize settings, column
++			wxString choices[] = {wxT("Don't resize"), wxT("Low quality"), wxT("High quality")};
++			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
++				wxT("Resize method"),
++				wxDefaultPosition, wxDefaultSize,
++				WXSIZEOF(choices),
++				choices,
++				1,
++				wxRA_SPECIFY_ROWS);
++			m_resizeBox->SetSelection(wxGetApp().m_resizemethod + 1);
++
++		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++	// add some space
++	//topSizer->AddSpacer(5);
++
++		// sub top sizer
++		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
++
++			// frame settings, column
++			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
++			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
++
++				// selected frame number, row
++				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				framenumSizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				framenumSizer->Add(
++					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
++								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								1, 100000, wxGetApp().m_framenum),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++
++			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++	// add some space
++	//topSizer->AddSpacer(5);
++
++		// sub top sizer
++		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
++
++			// resolutions settings, column
++			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
++			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
++
++				// reduce factor sizer, row
++				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				reduceSizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				reduceSizer->Add(
++					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
++					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								0, 10000, wxGetApp().m_reducefactor),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++
++			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
++
++			// quality layer settings, column
++			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
++			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
++
++				// quality layers sizer, row
++				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				qualitySizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				qualitySizer->Add(
++					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
++								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								0, 100000, wxGetApp().m_qualitylayers),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++
++			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
++
++			// component settings, column
++			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
++			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
++
++				// quality layers sizer, row
++				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				numcompsSizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				numcompsSizer->Add(
++					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
++								wxString::Format(wxT("%d"), wxGetApp().m_components),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								0, 100000, wxGetApp().m_components),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++				m_numcompsCtrl->Enable(true);
++
++			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++#ifdef USE_JPWL
++wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++	// add some space
++	//topSizer->AddSpacer(5);
++
++		// sub top sizer
++		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
++
++		// add JPWL enabling check box
++		subtopSizer->Add(
++			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
++			0, wxGROW | wxALL, 5);
++		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
++
++			// component settings, column
++			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
++			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
++
++				// expected components sizer, row
++				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				expcompsSizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				expcompsSizer->Add(
++					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
++								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								1, 100000, wxGetApp().m_expcomps),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
++
++			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
++
++			// tiles settings, column
++			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
++			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
++
++				// maximum tiles sizer, row
++				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
++
++				// add some horizontal space
++				maxtileSizer->Add(5, 5, 1, wxALL, 0);
++
++				// add the value control
++				maxtileSizer->Add(
++					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
++								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								1, 100000, wxGetApp().m_maxtiles),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
++				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
++
++			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
++
++		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
++{
++	size_t pp;
++
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("Decoding enabled"));
++		m_resizeBox->Enable(true);
++		// enable all tabs except ourselves
++		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
++			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
++				m_settingsNotebook->GetPage(pp)->Enable(true);
++		}
++	} else {
++		wxLogMessage(wxT("Decoding disabled"));
++		m_resizeBox->Enable(false);
++		// disable all tabs except ourselves
++		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
++			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
++				m_settingsNotebook->GetPage(pp)->Enable(false);
++		}
++	}
++
++}
++
++void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
++{
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("JPWL enabled"));
++		m_expcompsCtrl->Enable(true);
++		m_maxtilesCtrl->Enable(true);
++	} else {
++		wxLogMessage(wxT("JPWL disabled"));
++		m_expcompsCtrl->Enable(false);
++		m_maxtilesCtrl->Enable(false);
++	}
++
++}
++
++#endif // USE_JPWL
++
++
++
++
++// ----------------------------------------------------------------------------
++// OPJEncoderDialog
++// ----------------------------------------------------------------------------
++
++IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
++
++BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
++	EVT_CHECKBOX(OPJENCO_ENABLECOMM, OPJEncoderDialog::OnEnableComm)
++	EVT_CHECKBOX(OPJENCO_ENABLEINDEX, OPJEncoderDialog::OnEnableIdx)
++	EVT_CHECKBOX(OPJENCO_ENABLEPOC, OPJEncoderDialog::OnEnablePoc)
++	EVT_RADIOBUTTON(OPJENCO_RATERADIO, OPJEncoderDialog::OnRadioQualityRate)
++	EVT_RADIOBUTTON(OPJENCO_QUALITYRADIO, OPJEncoderDialog::OnRadioQualityRate)
++#ifdef USE_JPWL
++	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
++	EVT_CHOICE(OPJENCO_HPROT, OPJEncoderDialog::OnHprotSelect)
++	EVT_CHOICE(OPJENCO_PPROT, OPJEncoderDialog::OnPprotSelect)
++	EVT_CHOICE(OPJENCO_SENSI, OPJEncoderDialog::OnSensiSelect)
++#endif // USE_JPWL
++END_EVENT_TABLE()
++
++OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
++{
++	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
++
++	Create(win, wxID_ANY, wxT("Encoder settings"),
++		wxDefaultPosition, wxDefaultSize,
++		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
++		);
++
++	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
++
++	m_settingsNotebook = GetBookCtrl();
++
++	wxPanel* jpeg2000_1Settings = CreatePart1_1SettingsPage(m_settingsNotebook);
++	wxPanel* jpeg2000_2Settings = CreatePart1_2SettingsPage(m_settingsNotebook);
++	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
++#ifdef USE_JPWL
++	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
++#endif // USE_JPWL
++
++#ifdef USE_JPWL
++	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
++#endif // USE_JPWL
++	m_settingsNotebook->AddPage(jpeg2000_1Settings, wxT("JPEG 2000 - 1"), false);
++	m_settingsNotebook->AddPage(jpeg2000_2Settings, wxT("JPEG 2000 - 2"), false);
++	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
++
++	LayoutDialog();
++}
++
++OPJEncoderDialog::~OPJEncoderDialog()
++{
++}
++
++wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++		// sub top sizer
++		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++#ifdef USE_JPWL
++wxPanel* OPJEncoderDialog::CreatePart11SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++	int specno;
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++		// add JPWL enabling check box
++		topSizer->Add(
++			m_enablejpwlCheck = new wxCheckBox(panel, OPJENCO_ENABLEJPWL, wxT("Enable JPWL"),
++			wxDefaultPosition, wxDefaultSize),
++			0, wxGROW | wxALL | wxALIGN_CENTER, 5);
++		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwle);
++
++		// sub top sizer
++		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
++
++			// header settings, column
++			wxStaticBox* headerBox = new wxStaticBox(panel, wxID_ANY, wxT("Header protection"));
++			wxBoxSizer* headerSizer = new wxStaticBoxSizer(headerBox, wxVERTICAL);
++
++				// info sizer, row
++				wxBoxSizer* info1Sizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				info1Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Type")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++				// add some horizontal space
++				info1Sizer->Add(3, 3, 1, wxALL, 0);
++
++				// add some text
++				info1Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Tile part")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++			headerSizer->Add(info1Sizer, 0, wxGROW | wxALL, 0);
++
++			// specify specs
++			wxString hprotvalues[] = {wxT("None"), wxT("Pred."), wxT("CRC16"), wxT("CRC32"),
++				wxT("RS37"), wxT("RS38"), wxT("RS40"), wxT("RS43"), wxT("RS45"), wxT("RS48"),
++				wxT("RS51"), wxT("RS53"), wxT("RS56"), wxT("RS64"), wxT("RS75"), wxT("RS80"),
++				wxT("RS85"), wxT("RS96"), wxT("RS112"), wxT("RS128")};
++			for (specno = 0; specno < MYJPWL_MAX_NO_TILESPECS; specno++) {
++
++					// tile+hprot sizer, row
++					wxBoxSizer* tilehprotSizer = new wxBoxSizer(wxHORIZONTAL);
++
++					// add the value selection
++					tilehprotSizer->Add(
++						m_hprotChoice[specno] = new wxChoice(panel, OPJENCO_HPROT,
++							wxDefaultPosition, wxSize(60, wxDefaultCoord),
++							WXSIZEOF(hprotvalues), hprotvalues),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++					m_hprotChoice[specno]->SetSelection(wxGetApp().m_hprotsel[specno]);
++
++					// add some horizontal space
++					tilehprotSizer->Add(3, 3, 1, wxALL, 0);
++
++					// add the value control
++					tilehprotSizer->Add(
++						m_htileCtrl[specno] = new wxSpinCtrl(panel, OPJENCO_HTILE,
++							wxString::Format(wxT("%d"), wxGetApp().m_htileval[specno]),
++							wxDefaultPosition, wxSize(45, wxDefaultCoord),
++							wxSP_ARROW_KEYS,
++							0, JPWL_MAXIMUM_TILES - 1, 0),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++
++				headerSizer->Add(tilehprotSizer, 0, wxGROW | wxALL, 0);
++			}
++
++			wxCommandEvent event1;
++			OnHprotSelect(event1);
++
++		subtopSizer->Add(headerSizer, 0, wxGROW | wxALL, 3);
++
++			// packet settings, column
++			wxStaticBox* packetBox = new wxStaticBox(panel, wxID_ANY, wxT("Packet protection"));
++			wxBoxSizer* packetSizer = new wxStaticBoxSizer(packetBox, wxVERTICAL);
++
++				// info sizer, row
++				wxBoxSizer* info2Sizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				info2Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Type")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++				// add some horizontal space
++				info2Sizer->Add(3, 3, 1, wxALL, 0);
++
++				// add some text
++				info2Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Tile part")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++				// add some horizontal space
++				info2Sizer->Add(3, 3, 1, wxALL, 0);
++
++				// add some text
++				info2Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Packet")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++			packetSizer->Add(info2Sizer, 0, wxGROW | wxALL, 0);
++
++			// specify specs
++			wxString pprotvalues[] = {wxT("None"), wxT("Pred."), wxT("CRC16"), wxT("CRC32"),
++				wxT("RS37"), wxT("RS38"), wxT("RS40"), wxT("RS43"), wxT("RS45"), wxT("RS48"),
++				wxT("RS51"), wxT("RS53"), wxT("RS56"), wxT("RS64"), wxT("RS75"), wxT("RS80"),
++				wxT("RS85"), wxT("RS96"), wxT("RS112"), wxT("RS128")};
++			for (specno = 0; specno < MYJPWL_MAX_NO_TILESPECS; specno++) {
++
++					// tile+pprot sizer, row
++					wxBoxSizer* tilepprotSizer = new wxBoxSizer(wxHORIZONTAL);
++
++					// add the value selection
++					tilepprotSizer->Add(
++						m_pprotChoice[specno] = new wxChoice(panel, OPJENCO_PPROT,
++							wxDefaultPosition, wxSize(60, wxDefaultCoord),
++							WXSIZEOF(pprotvalues), pprotvalues),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++					m_pprotChoice[specno]->SetSelection(wxGetApp().m_pprotsel[specno]);
++
++					// add some horizontal space
++					tilepprotSizer->Add(3, 3, 1, wxALL, 0);
++
++					// add the value control
++					tilepprotSizer->Add(
++						m_ptileCtrl[specno] = new wxSpinCtrl(panel, OPJENCO_PTILE,
++							wxString::Format(wxT("%d"), wxGetApp().m_ptileval[specno]),
++							wxDefaultPosition, wxSize(45, wxDefaultCoord),
++							wxSP_ARROW_KEYS,
++							0, JPWL_MAXIMUM_TILES - 1, 0),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++
++					// add some horizontal space
++					tilepprotSizer->Add(3, 3, 1, wxALL, 0);
++
++					// add the value control
++					tilepprotSizer->Add(
++						m_ppackCtrl[specno] = new wxSpinCtrl(panel, OPJENCO_PPACK,
++							wxString::Format(wxT("%d"), wxGetApp().m_ppackval[specno]),
++							wxDefaultPosition, wxSize(50, wxDefaultCoord),
++							wxSP_ARROW_KEYS,
++							0, 2047, 0),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++
++				packetSizer->Add(tilepprotSizer, 0, wxGROW | wxALL, 0);
++			}
++
++			wxCommandEvent event2;
++			OnPprotSelect(event2);
++
++		subtopSizer->Add(packetSizer, 0, wxGROW | wxALL, 3);
++
++			// sensitivity settings, column
++			wxStaticBox* sensiBox = new wxStaticBox(panel, wxID_ANY, wxT("Sensitivity"));
++			wxBoxSizer* sensiSizer = new wxStaticBoxSizer(sensiBox, wxVERTICAL);
++
++				// info sizer, row
++				wxBoxSizer* info3Sizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				info3Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Type")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++				// add some horizontal space
++				info3Sizer->Add(3, 3, 1, wxALL, 0);
++
++				// add some text
++				info3Sizer->Add(new wxStaticText(panel, wxID_ANY,
++								wxT("Tile part")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 1);
++
++			sensiSizer->Add(info3Sizer, 0, wxGROW | wxALL, 0);
++
++			// specify specs
++			wxString sensivalues[] = {wxT("None"), wxT("RELATIVE ERROR"), wxT("MSE"),
++				wxT("MSE REDUCTION"), wxT("PSNR INCREMENT"), wxT("MAXERR"), wxT("TSE")};
++			for (specno = 0; specno < MYJPWL_MAX_NO_TILESPECS; specno++) {
++
++					// tile+sensi sizer, row
++					wxBoxSizer* tilesensiSizer = new wxBoxSizer(wxHORIZONTAL);
++
++					// add the value selection
++					tilesensiSizer->Add(
++						m_sensiChoice[specno] = new wxChoice(panel, OPJENCO_SENSI,
++							wxDefaultPosition, wxSize(110, wxDefaultCoord),
++							WXSIZEOF(sensivalues), sensivalues),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++					m_sensiChoice[specno]->SetSelection(wxGetApp().m_sensisel[specno]);
++
++					// add some horizontal space
++					tilesensiSizer->Add(3, 3, 1, wxALL, 0);
++
++					// add the value control
++					tilesensiSizer->Add(
++						m_stileCtrl[specno] = new wxSpinCtrl(panel, OPJENCO_STILE,
++							wxString::Format(wxT("%d"), wxGetApp().m_stileval[specno]),
++							wxDefaultPosition, wxSize(45, wxDefaultCoord),
++							wxSP_ARROW_KEYS,
++							0, JPWL_MAXIMUM_TILES - 1, 0),
++						0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 1);
++
++				sensiSizer->Add(tilesensiSizer, 0, wxGROW | wxALL, 0);
++			}
++
++			wxCommandEvent event3;
++			OnSensiSelect(event3);
++
++		subtopSizer->Add(sensiSizer, 0, wxGROW | wxALL, 3);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++#endif // USE_JPWL
++
++wxPanel* OPJEncoderDialog::CreatePart1_1SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++	// add some space
++	//topSizer->AddSpacer(5);
++
++		// sub top sizer
++		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
++
++			// image settings, column
++			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
++			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
++
++				// subsampling factor sizer, row
++				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				subsSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				subsSizer->Add(
++					m_subsamplingCtrl = new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
++								wxGetApp().m_subsampling,
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
++
++				// origin sizer, row
++				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				imorigSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				imorigSizer->Add(
++					m_originCtrl = new wxTextCtrl(panel, OPJENCO_IMORIG,
++								wxGetApp().m_origin,
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
++
++			// layer settings, column
++			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers/compression"));
++			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
++
++				// rate factor sizer, row
++				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				/*rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
++
++				// add the radio button
++				rateSizer->Add(
++					m_rateRadio = new wxRadioButton(panel, OPJENCO_RATERADIO, wxT("&Rate values"),
++								wxDefaultPosition, wxDefaultSize,
++								wxRB_GROUP),
++								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
++								);
++				m_rateRadio->SetValue(!(wxGetApp().m_enablequality));
++
++				// add some horizontal space
++				rateSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				rateSizer->Add(
++					m_rateCtrl = new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
++								wxGetApp().m_rates,
++								wxDefaultPosition, wxSize(100, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++				if (wxGetApp().m_enablequality == true)
++					m_rateCtrl->Enable(false);
++
++			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
++
++				// quality factor sizer, row
++				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				/*qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
++
++				// add the radio button
++				qualitySizer->Add(
++					m_qualityRadio = new wxRadioButton(panel, OPJENCO_QUALITYRADIO, wxT("&Quality values"),
++								wxDefaultPosition, wxDefaultSize),
++								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
++								);
++				m_qualityRadio->SetValue(wxGetApp().m_enablequality);
++
++				// add some horizontal space
++				qualitySizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				qualitySizer->Add(
++					m_qualityCtrl = new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
++								wxGetApp().m_quality,
++								wxDefaultPosition, wxSize(100, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++				if (wxGetApp().m_enablequality == false)
++					m_qualityCtrl->Enable(false);
++
++			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
++
++			// wavelet settings, column
++			wxStaticBox* transformBox = new wxStaticBox(panel, wxID_ANY, wxT("Transforms"));
++			wxBoxSizer* transformSizer = new wxStaticBoxSizer(transformBox, wxVERTICAL);
++
++			// multiple component check box
++			transformSizer->Add(
++				m_mctCheck = new wxCheckBox(panel, OPJENCO_ENABLEMCT, wxT("Multiple component"),
++				wxDefaultPosition, wxDefaultSize),
++				0, wxGROW | wxALL, 3);
++			m_mctCheck->SetValue(wxGetApp().m_multicomp);
++
++			// irreversible wavelet check box
++			transformSizer->Add(
++				m_irrevCheck = new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible wavelet"),
++				wxDefaultPosition, wxDefaultSize),
++				0, wxGROW | wxALL, 3);
++			m_irrevCheck->SetValue(wxGetApp().m_irreversible);
++
++				// resolution number sizer, row
++				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				resnumSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				resnumSizer->Add(
++					m_resolutionsCtrl = new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
++								wxString::Format(wxT("%d"), wxGetApp().m_resolutions),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								1, 256, 6),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			transformSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(transformSizer, 0, wxGROW | wxALL, 3);
++
++			// codestream settings, column
++			wxStaticBox* codestreamBox = new wxStaticBox(panel, wxID_ANY, wxT("Codestream"));
++			wxBoxSizer* codestreamSizer = new wxStaticBoxSizer(codestreamBox, wxVERTICAL);
++
++				// codeblock sizer, row
++				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				codeblockSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				codeblockSizer->Add(
++					m_cbsizeCtrl = new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
++								wxGetApp().m_cbsize,
++								wxDefaultPosition, wxSize(100, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			codestreamSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
++
++				// precinct sizer, row
++				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				precinctSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				precinctSizer->Add(
++					m_prsizeCtrl = new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
++								wxGetApp().m_prsize,
++								wxDefaultPosition, wxSize(100, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			codestreamSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(codestreamSizer, 0, wxGROW | wxALL, 3);
++
++			// tile settings, column
++			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
++			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
++
++				// tile size sizer, row
++				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				tilesizeSizer->Add(
++					m_tsizeCtrl = new wxTextCtrl(panel, OPJENCO_TILESIZE,
++								wxGetApp().m_tsize,
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
++
++				// tile origin sizer, row
++				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				tilorigSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				tilorigSizer->Add(
++					m_toriginCtrl = new wxTextCtrl(panel, OPJENCO_TILORIG,
++								wxGetApp().m_torigin,
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
++
++			// progression and profile settings, column
++			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL"),
++				wxT("DCI2K24"), wxT("DCI2K48"), wxT("DCI4K")};
++			progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
++				wxT("Progression order/profile"),
++				wxDefaultPosition, wxDefaultSize,
++				WXSIZEOF(choices),
++				choices,
++				3,
++				wxRA_SPECIFY_COLS);
++			progressionBox->SetSelection(wxGetApp().m_progression);
++
++		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++wxPanel* OPJEncoderDialog::CreatePart1_2SettingsPage(wxWindow* parent)
++{
++    wxPanel* panel = new wxPanel(parent, wxID_ANY);
++
++	// top sizer
++    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
++
++	// add some space
++	//topSizer->AddSpacer(5);
++
++		// sub top sizer
++		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
++			
++			// resilience settings, column
++			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Error resilience"));
++			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
++
++				// resil2 sizer, row
++				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// SOP check box
++				resil2Sizer->Add(
++					m_sopCheck = new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
++						wxDefaultPosition, wxDefaultSize),
++						0, wxGROW | wxALL, 3);
++				m_sopCheck->SetValue(wxGetApp().m_enablesop);
++
++				// EPH check box
++				resil2Sizer->Add(
++					m_ephCheck = new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
++						wxDefaultPosition, wxDefaultSize),
++						0, wxGROW | wxALL, 3);
++				m_ephCheck->SetValue(wxGetApp().m_enableeph);
++
++			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
++
++			// separation
++			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
++
++				// resil3 sizer, row
++				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
++
++				// BYPASS check box
++				resil3Sizer->Add(
++					m_enablebypassCheck = new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enablebypassCheck->SetValue(wxGetApp().m_enablebypass);
++
++				// RESET check box
++				resil3Sizer->Add(
++					m_enableresetCheck = new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enableresetCheck->SetValue(wxGetApp().m_enablereset);
++
++				// RESTART check box
++				resil3Sizer->Add(
++					m_enablerestartCheck = new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enablerestartCheck->SetValue(wxGetApp().m_enablerestart);
++
++				// VSC check box
++				resil3Sizer->Add(
++					m_enablevscCheck = new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enablevscCheck->SetValue(wxGetApp().m_enablevsc);
++
++				// ERTERM check box
++				resil3Sizer->Add(
++					m_enableertermCheck = new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enableertermCheck->SetValue(wxGetApp().m_enableerterm);
++
++				// SEGMARK check box
++				resil3Sizer->Add(
++					m_enablesegmarkCheck = new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
++					wxDefaultPosition, wxDefaultSize),
++					0, wxGROW | wxALL, 3);
++				m_enablesegmarkCheck->SetValue(wxGetApp().m_enablesegmark);
++
++			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
++
++			// ROI settings, column
++			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("Region Of Interest"));
++			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
++
++				// component number sizer, row
++				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				roicompSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				roicompSizer->Add(
++					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
++								wxT("0"),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								0, 256, 0),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
++
++				// upshift sizer, row
++				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				roishiftSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				roishiftSizer->Add(
++					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
++								wxT("0"),
++								wxDefaultPosition, wxSize(80, wxDefaultCoord),
++								wxSP_ARROW_KEYS,
++								0, 37, 0),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++
++			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
++
++			// POC settings, column
++			wxStaticBox* pocBox = new wxStaticBox(panel, wxID_ANY, wxT("POC"));
++			wxBoxSizer* pocSizer = new wxStaticBoxSizer(pocBox, wxVERTICAL);
++
++			// POC check box
++			pocSizer->Add(
++				m_enablepocCheck = new wxCheckBox(panel, OPJENCO_ENABLEPOC, wxT("Enabled (tn=rs,cs,le,re,ce,pr)"),
++				wxDefaultPosition, wxDefaultSize),
++				0, wxGROW | wxALL, 3);
++			m_enablepocCheck->SetValue(wxGetApp().m_enablepoc);
++
++				// POC sizer, row
++				wxBoxSizer* pocspecSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				pocspecSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Changes:")),
++								0, wxALL | wxALIGN_TOP, 3);
++
++				// add some horizontal space
++				pocspecSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				pocspecSizer->Add(
++					m_pocCtrl = new wxTextCtrl(panel, OPJENCO_POCSPEC,
++								wxGetApp().m_poc,
++								wxDefaultPosition, wxSize(140, 60),
++								wxTE_LEFT | wxTE_MULTILINE),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++				m_pocCtrl->Enable(wxGetApp().m_enablepoc);
++
++			pocSizer->Add(pocspecSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(pocSizer, 0, wxGROW | wxALL, 3);
++			
++			// Comment settings, column
++			wxStaticBox* commentBox = new wxStaticBox(panel, wxID_ANY, wxT("Comment"));
++			wxBoxSizer* commentSizer = new wxStaticBoxSizer(commentBox, wxVERTICAL);
++
++			// commenting check box
++			commentSizer->Add(
++				m_enablecommCheck = new wxCheckBox(panel, OPJENCO_ENABLECOMM, wxT("Enabled (empty to reset)"),
++				wxDefaultPosition, wxDefaultSize),
++				0, wxGROW | wxALL, 3);
++			m_enablecommCheck->SetValue(wxGetApp().m_enablecomm);
++
++			// add some horizontal space
++			commentSizer->Add(3, 3, 1, wxALL, 0);
++
++			// add the value control
++			commentSizer->Add(
++				m_commentCtrl = new wxTextCtrl(panel, OPJENCO_COMMENTTEXT,
++							wxGetApp().m_comment,
++							wxDefaultPosition, wxSize(wxDefaultCoord, 60),
++							wxTE_LEFT | wxTE_MULTILINE),
++				0, wxGROW | wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++			m_commentCtrl->Enable(wxGetApp().m_enablecomm);
++
++		subtopSizer->Add(commentSizer, 0, wxGROW | wxALL, 3);
++
++			// Index file settings, column
++			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
++			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
++
++			// indexing check box
++			indexSizer->Add(
++				m_enableidxCheck = new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
++				wxDefaultPosition, wxDefaultSize),
++				0, wxGROW | wxALL, 3);
++			m_enableidxCheck->SetValue(wxGetApp().m_enableidx);
++
++				// index file sizer, row
++				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
++
++				// add some text
++				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
++								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
++
++				// add some horizontal space
++				indexnameSizer->Add(3, 3, 1, wxALL, 0);
++
++				// add the value control
++				indexnameSizer->Add(
++					m_indexCtrl = new wxTextCtrl(panel, OPJENCO_INDEXNAME,
++								wxGetApp().m_index,
++								wxDefaultPosition, wxSize(120, wxDefaultCoord),
++								wxTE_LEFT),
++					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
++				m_indexCtrl->Enable(wxGetApp().m_enableidx);
++
++			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
++
++		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
++
++	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
++
++	// assign top and fit it
++    panel->SetSizer(topSizer);
++    topSizer->Fit(panel);
++
++    return panel;
++}
++
++void OPJEncoderDialog::OnEnableComm(wxCommandEvent& event)
++{
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("Comment enabled"));
++		m_commentCtrl->Enable(true);
++	} else {
++		wxLogMessage(wxT("Comment disabled"));
++		m_commentCtrl->Enable(false);
++	}
++
++}
++
++void OPJEncoderDialog::OnEnableIdx(wxCommandEvent& event)
++{
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("Index enabled"));
++		m_indexCtrl->Enable(true);
++	} else {
++		wxLogMessage(wxT("Index disabled"));
++		m_indexCtrl->Enable(false);
++	}
++
++}
++
++void OPJEncoderDialog::OnEnablePoc(wxCommandEvent& event)
++{
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("POC enabled"));
++		m_pocCtrl->Enable(true);
++	} else {
++		wxLogMessage(wxT("POC disabled"));
++		m_pocCtrl->Enable(false);
++	}
++
++}
++
++void OPJEncoderDialog::OnRadioQualityRate(wxCommandEvent& event)
++{
++	if (event.GetId() == OPJENCO_QUALITYRADIO) {
++		wxLogMessage(wxT("Quality selected"));
++		m_rateCtrl->Enable(false);
++		m_qualityCtrl->Enable(true);
++	} else {
++		wxLogMessage(wxT("Rate selected"));
++		m_rateCtrl->Enable(true);
++		m_qualityCtrl->Enable(false);
++	}
++}
++
++#ifdef USE_JPWL
++void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
++{
++	int specno;
++
++	if (event.IsChecked()) {
++		wxLogMessage(wxT("JPWL enabled"));
++		for (specno = 0; specno < MYJPWL_MAX_NO_TILESPECS; specno++) {
++			m_hprotChoice[specno]->Enable(true);
++			m_htileCtrl[specno]->Enable(true);
++			m_pprotChoice[specno]->Enable(true);
++			m_ptileCtrl[specno]->Enable(true);
++			m_ppackCtrl[specno]->Enable(true);
++			m_sensiChoice[specno]->Enable(true);
++			m_stileCtrl[specno]->Enable(true);
++		}
++		OnHprotSelect(event);
++		OnPprotSelect(event);
++		OnSensiSelect(event);
++	} else {
++		wxLogMessage(wxT("JPWL disabled"));
++		for (specno = 0; specno < MYJPWL_MAX_NO_TILESPECS; specno++) {
++			m_hprotChoice[specno]->Enable(false);
++			m_htileCtrl[specno]->Enable(false);
++			m_pprotChoice[specno]->Enable(false);
++			m_ptileCtrl[specno]->Enable(false);
++			m_ppackCtrl[specno]->Enable(false);
++			m_sensiChoice[specno]->Enable(false);
++			m_stileCtrl[specno]->Enable(false);
++		}
++	}
++
++}
++
++void OPJEncoderDialog::OnHprotSelect(wxCommandEvent& event)
++{
++	int specno;
++
++	// deactivate properly
++	for (specno = MYJPWL_MAX_NO_TILESPECS - 1; specno >= 0; specno--) {
++		if (!m_hprotChoice[specno]->GetSelection()) {
++			m_hprotChoice[specno]->Enable(false);
++			m_htileCtrl[specno]->Enable(false);
++		} else
++			break;
++	}
++	if (specno < (MYJPWL_MAX_NO_TILESPECS - 1)) {
++		m_hprotChoice[specno + 1]->Enable(true);
++		m_htileCtrl[specno + 1]->Enable(true);
++	}
++
++	//wxLogMessage(wxT("hprot changed: %d"), specno);
++}
++
++void OPJEncoderDialog::OnPprotSelect(wxCommandEvent& event)
++{
++	int specno;
++
++	// deactivate properly
++	for (specno = MYJPWL_MAX_NO_TILESPECS - 1; specno >= 0; specno--) {
++		if (!m_pprotChoice[specno]->GetSelection()) {
++			m_pprotChoice[specno]->Enable(false);
++			m_ptileCtrl[specno]->Enable(false);
++			m_ppackCtrl[specno]->Enable(false);
++		} else
++			break;
++	}
++	if (specno < (MYJPWL_MAX_NO_TILESPECS - 1)) {
++		m_pprotChoice[specno + 1]->Enable(true);
++		m_ptileCtrl[specno + 1]->Enable(true);
++		m_ppackCtrl[specno + 1]->Enable(true);
++	}
++
++	//wxLogMessage(wxT("pprot changed: %d"), specno);
++}
++
++void OPJEncoderDialog::OnSensiSelect(wxCommandEvent& event)
++{
++	int specno;
++
++	// deactivate properly
++	for (specno = MYJPWL_MAX_NO_TILESPECS - 1; specno >= 0; specno--) {
++		if (!m_sensiChoice[specno]->GetSelection()) {
++			m_sensiChoice[specno]->Enable(false);
++			m_stileCtrl[specno]->Enable(false);
++		} else
++			break;
++	}
++	if (specno < (MYJPWL_MAX_NO_TILESPECS - 1)) {
++		m_sensiChoice[specno + 1]->Enable(true);
++		m_stileCtrl[specno + 1]->Enable(true);
++	}
++
++	//wxLogMessage(wxT("sprot changed: %d"), specno);
++}
++
++
++#endif // USE_JPWL
++
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/OPJThreads.cpp ./OPJViewer/source/OPJThreads.cpp
+--- ../trunk.orig/OPJViewer/source/OPJThreads.cpp	1970-01-01 01:00:00.000000000 +0100
++++ ./OPJViewer/source/OPJThreads.cpp	2007-12-01 18:40:47.000000000 +0000
+@@ -0,0 +1,1251 @@
++/*
++ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita'  degli studi di Perugia (UPG), Italy
++ * All rights reserved.
++ *
++ * Redistribution and use in source and binary forms, with or without
++ * modification, are permitted provided that the following conditions
++ * are met:
++ * 1. Redistributions of source code must retain the above copyright
++ *    notice, this list of conditions and the following disclaimer.
++ * 2. Redistributions in binary form must reproduce the above copyright
++ *    notice, this list of conditions and the following disclaimer in the
++ *    documentation and/or other materials provided with the distribution.
++ *
++ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
++ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
++ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
++ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
++ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
++ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
++ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
++ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
++ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
++ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
++ * POSSIBILITY OF SUCH DAMAGE.
++ */
++#include "OPJViewer.h"
++
++
++/////////////////////////////////////////////////////////////////////
++// Encoding thread class
++/////////////////////////////////////////////////////////////////////
++
++OPJEncoThread::OPJEncoThread(OPJCanvas *canvas)
++        : wxThread()
++{
++    m_count = 0;
++    m_canvas = canvas;
++}
++
++void OPJEncoThread::WriteText(const wxString& text)
++{
++    wxString msg;
++
++    // before doing any GUI calls we must ensure that this thread is the only
++    // one doing it!
++
++#ifndef __WXGTK__ 
++    wxMutexGuiEnter();
++#endif // __WXGTK__
++
++    msg << text;
++    m_canvas->WriteText(msg);
++
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif // __WXGTK__
++}
++
++void OPJEncoThread::OnExit()
++{
++    wxCriticalSectionLocker locker(wxGetApp().m_enco_critsect);
++
++    wxArrayThread& ethreads = wxGetApp().m_enco_threads;
++    ethreads.Remove(this);
++
++    if (ethreads.IsEmpty() )
++    {
++        // signal the main thread that there are no more threads left if it is
++        // waiting for us
++        if (wxGetApp().m_enco_waitingUntilAllDone) {
++            wxGetApp().m_enco_waitingUntilAllDone = false;
++            wxGetApp().m_enco_semAllDone.Post();
++        }
++    }
++}
++
++void *OPJEncoThread::Entry()
++{
++    wxString text;
++
++	srand(GetId());
++	//int m_countnum = rand() % 9;
++    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
++    //            GetId(), GetPriority(), m_countnum);
++    text.Printf(wxT("Enco thread %d started"), m_canvas->m_childframe->m_winnumber);
++    WriteText(text);
++
++	// set handler properties
++	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
++	j2kkkhandler->m_subsampling = wxGetApp().m_subsampling;
++	j2kkkhandler->m_origin = wxGetApp().m_origin;
++	j2kkkhandler->m_rates = wxGetApp().m_rates;
++	j2kkkhandler->m_quality = wxGetApp().m_quality;
++	j2kkkhandler->m_enablequality = wxGetApp().m_enablequality;
++	j2kkkhandler->m_multicomp = wxGetApp().m_multicomp;
++	j2kkkhandler->m_irreversible = wxGetApp().m_irreversible;
++	j2kkkhandler->m_resolutions = wxGetApp().m_resolutions;
++	j2kkkhandler->m_progression = wxGetApp().m_progression;
++	j2kkkhandler->m_cbsize = wxGetApp().m_cbsize;
++	j2kkkhandler->m_prsize = wxGetApp().m_prsize;
++	j2kkkhandler->m_tsize = wxGetApp().m_tsize;
++	j2kkkhandler->m_torigin = wxGetApp().m_torigin;
++	j2kkkhandler->m_enablesop = wxGetApp().m_enablesop;
++	j2kkkhandler->m_enableeph = wxGetApp().m_enableeph;
++	j2kkkhandler->m_enablebypass = wxGetApp().m_enablebypass;
++	j2kkkhandler->m_enablerestart = wxGetApp().m_enablerestart;
++	j2kkkhandler->m_enablereset = wxGetApp().m_enablereset;
++	j2kkkhandler->m_enablesegmark = wxGetApp().m_enablesegmark;
++	j2kkkhandler->m_enableerterm = wxGetApp().m_enableerterm;
++	j2kkkhandler->m_enablevsc = wxGetApp().m_enablevsc;
++	j2kkkhandler->m_enableidx = wxGetApp().m_enableidx;
++	j2kkkhandler->m_index = m_canvas->m_savename.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR) + wxGetApp().m_index;
++	j2kkkhandler->m_enablecomm = wxGetApp().m_enablecomm;
++	j2kkkhandler->m_comment = wxGetApp().m_comment;
++	j2kkkhandler->m_enablepoc = wxGetApp().m_enablepoc;
++	j2kkkhandler->m_poc = wxGetApp().m_poc;
++
++	// save the file
++	if (!m_canvas->m_image100.SaveFile(m_canvas->m_savename.GetFullPath(), (wxBitmapType) wxBITMAP_TYPE_J2K)) {
++		WriteText(wxT("Can't save image"));
++		return NULL;
++	}
++
++    text.Printf(wxT("Enco thread %d finished"), m_canvas->m_childframe->m_winnumber);
++    WriteText(text);
++    return NULL;
++}
++
++
++/////////////////////////////////////////////////////////////////////
++// Decoding thread class
++/////////////////////////////////////////////////////////////////////
++
++OPJDecoThread::OPJDecoThread(OPJCanvas *canvas)
++        : wxThread()
++{
++    m_count = 0;
++    m_canvas = canvas;
++}
++
++void OPJDecoThread::WriteText(const wxString& text)
++{
++    wxString msg;
++
++    // before doing any GUI calls we must ensure that this thread is the only
++    // one doing it!
++
++#ifndef __WXGTK__ 
++    wxMutexGuiEnter();
++#endif // __WXGTK__
++
++    msg << text;
++    m_canvas->WriteText(msg);
++
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif // __WXGTK__
++}
++
++void OPJDecoThread::OnExit()
++{
++    wxCriticalSectionLocker locker(wxGetApp().m_deco_critsect);
++
++    wxArrayThread& dthreads = wxGetApp().m_deco_threads;
++    dthreads.Remove(this);
++
++    if (dthreads.IsEmpty() )
++    {
++        // signal the main thread that there are no more threads left if it is
++        // waiting for us
++        if (wxGetApp().m_deco_waitingUntilAllDone) {
++            wxGetApp().m_deco_waitingUntilAllDone = false;
++            wxGetApp().m_deco_semAllDone.Post();
++        }
++    }
++}
++
++void *OPJDecoThread::Entry()
++{
++
++    wxString text;
++
++	srand(GetId());
++	//int m_countnum = rand() % 9;
++    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
++    //            GetId(), GetPriority(), m_countnum);
++    text.Printf(wxT("Deco thread %d started"), m_canvas->m_childframe->m_winnumber);
++
++    WriteText(text);
++
++    wxBitmap bitmap(100, 100);
++    wxImage image(100, 100, true); //= bitmap.ConvertToImage();
++    image.Destroy();
++
++	WriteText(m_canvas->m_fname.GetFullPath());
++
++
++	// set handler properties
++	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
++	j2kkkhandler->m_reducefactor = wxGetApp().m_reducefactor;
++	j2kkkhandler->m_qualitylayers = wxGetApp().m_qualitylayers;
++	j2kkkhandler->m_components = wxGetApp().m_components;
++#ifdef USE_JPWL
++	j2kkkhandler->m_enablejpwl = wxGetApp().m_enablejpwl;
++	j2kkkhandler->m_expcomps = wxGetApp().m_expcomps;
++	j2kkkhandler->m_maxtiles = wxGetApp().m_maxtiles;
++#endif // USE_JPWL
++
++	wxJP2Handler *jp222handler = (wxJP2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_JP2);
++	jp222handler->m_reducefactor = wxGetApp().m_reducefactor;
++	jp222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
++	jp222handler->m_components = wxGetApp().m_components;
++#ifdef USE_JPWL
++	jp222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
++	jp222handler->m_expcomps = wxGetApp().m_expcomps;
++	jp222handler->m_maxtiles = wxGetApp().m_maxtiles;
++#endif // USE_JPWL
++
++	wxMJ2Handler *mj222handler = (wxMJ2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_MJ2);
++	mj222handler->m_reducefactor = wxGetApp().m_reducefactor;
++	mj222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
++	mj222handler->m_components = wxGetApp().m_components;
++	mj222handler->m_framenum = wxGetApp().m_framenum;
++#ifdef USE_JPWL
++	mj222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
++	mj222handler->m_expcomps = wxGetApp().m_expcomps;
++	mj222handler->m_maxtiles = wxGetApp().m_maxtiles;
++#endif // USE_JPWL
++
++	if (wxGetApp().m_enabledeco) {
++
++		// load the file
++		if (!image.LoadFile(m_canvas->m_fname.GetFullPath(), wxBITMAP_TYPE_ANY, 0)) {
++			WriteText(wxT("Can't load image"));
++			return NULL;
++		}
++
++	} else {
++
++		// display a macaron
++		if (!image.Create(300, 5, false)) {
++			WriteText(wxT("Can't create image"));
++			return NULL;
++		}
++
++	}
++
++	// assign 100% image
++    m_canvas->m_image100 = wxBitmap(image);
++
++	// find a fit-to-width zoom
++	int zooml, wzooml, hzooml;
++	wxSize clientsize = m_canvas->GetClientSize();
++	wzooml = (int) floor(100.0 * (double) clientsize.GetWidth() / (double) (2 * OPJ_CANVAS_BORDER + image.GetWidth()));
++	hzooml = (int) floor(100.0 * (double) clientsize.GetHeight() / (double) (2 * OPJ_CANVAS_BORDER + image.GetHeight()));
++	zooml = wxMin(100, wxMin(wzooml, hzooml));
++
++	// fit to width
++#ifndef __WXGTK__
++	m_canvas->m_childframe->m_frame->Rescale(zooml, m_canvas->m_childframe);
++#endif // __WXGTK__
++
++	//m_canvas->m_image = m_canvas->m_image100;
++	//m_canvas->Refresh();
++	//m_canvas->SetScrollbars(20, 20, (int)(0.5 + (double) image.GetWidth() / 20.0), (int)(0.5 + (double) image.GetHeight() / 20.0));
++
++    //text.Printf(wxT("Deco thread 0x%lx finished."), GetId());
++    text.Printf(wxT("Deco thread %d finished"), m_canvas->m_childframe->m_winnumber);
++    WriteText(text);
++    return NULL;
++
++}
++
++/////////////////////////////////////////////////////////////////////
++// Parsing thread class
++/////////////////////////////////////////////////////////////////////
++
++OPJParseThread::OPJParseThread(OPJMarkerTree *tree, wxTreeItemId parentid)
++        : wxThread()
++{
++    m_count = 0;
++    m_tree = tree;
++	m_parentid = parentid;
++}
++
++void OPJParseThread::WriteText(const wxString& text)
++{
++    wxString msg;
++
++    // before doing any GUI calls we must ensure that this thread is the only
++    // one doing it!
++
++#ifndef __WXGTK__ 
++    wxMutexGuiEnter();
++#endif // __WXGTK
++
++    msg << text;
++    m_tree->WriteText(msg);
++
++#ifndef __WXGTK__ 
++    wxMutexGuiLeave();
++#endif // __WXGTK
++}
++
++void OPJParseThread::OnExit()
++{
++    wxCriticalSectionLocker locker(wxGetApp().m_parse_critsect);
++
++    wxArrayThread& threads = wxGetApp().m_parse_threads;
++    threads.Remove(this);
++
++    if (threads.IsEmpty()) {
++        // signal the main thread that there are no more threads left if it is
++        // waiting for us
++        if (wxGetApp().m_parse_waitingUntilAllDone) {
++            wxGetApp().m_parse_waitingUntilAllDone = false;
++            wxGetApp().m_parse_semAllDone.Post();
++        }
++    }
++}
++
++void *OPJParseThread::Entry()
++{
++
++	printf("Entering\n\n");
++
++    wxString text;
++
++	srand(GetId());
++	int m_countnum = rand() % 9;
++    text.Printf(wxT("Parse thread 0x%lx started (priority = %u, time = %d)."),
++            GetId(), GetPriority(), m_countnum);
++    WriteText(text);
++    LoadFile(m_tree->m_fname);
++    text.Printf(wxT("Parse thread 0x%lx finished."), GetId());
++    WriteText(text);
++
++
++    //wxLogMessage(wxT("Entering\n")); //test wxLog thread safeness
++
++	//wxBusyCursor wait;
++	//wxBusyInfo wait(wxT("Decoding image ..."));
++
++
++    /*for ( m_count = 0; m_count < m_countnum; m_count++ )
++    {
++        // check if we were asked to exit
++        if ( TestDestroy() )
++            break;
++
++        text.Printf(wxT("[%u] Parse thread 0x%lx here."), m_count, GetId());
++        WriteText(text);
++
++        // wxSleep() can't be called from non-GUI thread!
++        wxThread::Sleep(10);
++    }*/
++
++    // wxLogMessage(text); -- test wxLog thread safeness
++
++	printf("Exiting\n\n");
++
++    return NULL;
++}
++
++
++///////////////////////////////////////////
++// Parsing hread and related
++///////////////////////////////////////////
++
++#if USE_GENERIC_TREECTRL
++BEGIN_EVENT_TABLE(OPJMarkerTree, wxGenericTreeCtrl)
++#else
++BEGIN_EVENT_TABLE(OPJMarkerTree, wxTreeCtrl)
++#endif
++    /*EVT_TREE_BEGIN_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginDrag)
++    EVT_TREE_BEGIN_RDRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginRDrag)
++    EVT_TREE_END_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnEndDrag)*/
++    /*EVT_TREE_BEGIN_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnBeginLabelEdit)
++    EVT_TREE_END_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnEndLabelEdit)*/
++    /*EVT_TREE_DELETE_ITEM(TreeTest_Ctrl, OPJMarkerTree::OnDeleteItem)*/
++#if 0       // there are so many of those that logging them causes flicker
++    /*EVT_TREE_GET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnGetInfo)*/
++#endif
++    /*EVT_TREE_SET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnSetInfo)
++    EVT_TREE_ITEM_EXPANDED(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanded)*/
++    EVT_TREE_ITEM_EXPANDING(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanding)
++    /*EVT_TREE_ITEM_COLLAPSED(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsed)
++    EVT_TREE_ITEM_COLLAPSING(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsing)*/
++
++    EVT_TREE_SEL_CHANGED(TreeTest_Ctrl, OPJMarkerTree::OnSelChanged)
++    /*EVT_TREE_SEL_CHANGING(TreeTest_Ctrl, OPJMarkerTree::OnSelChanging)*/
++    /*EVT_TREE_KEY_DOWN(TreeTest_Ctrl, OPJMarkerTree::OnTreeKeyDown)*/
++    /*EVT_TREE_ITEM_ACTIVATED(TreeTest_Ctrl, OPJMarkerTree::OnItemActivated)*/
++
++    // so many differents ways to handle right mouse button clicks...
++    /*EVT_CONTEXT_MENU(OPJMarkerTree::OnContextMenu)*/
++    // EVT_TREE_ITEM_MENU is the preferred event for creating context menus
++    // on a tree control, because it includes the point of the click or item,
++    // meaning that no additional placement calculations are required.
++    EVT_TREE_ITEM_MENU(TreeTest_Ctrl, OPJMarkerTree::OnItemMenu)
++    /*EVT_TREE_ITEM_RIGHT_CLICK(TreeTest_Ctrl, OPJMarkerTree::OnItemRClick)*/
++
++    /*EVT_RIGHT_DOWN(OPJMarkerTree::OnRMouseDown)
++    EVT_RIGHT_UP(OPJMarkerTree::OnRMouseUp)
++    EVT_RIGHT_DCLICK(OPJMarkerTree::OnRMouseDClick)*/
++END_EVENT_TABLE()
++
++// OPJMarkerTree implementation
++#if USE_GENERIC_TREECTRL
++IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxGenericTreeCtrl)
++#else
++IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxTreeCtrl)
++#endif
++
++OPJMarkerTree::OPJMarkerTree(wxWindow *parent, OPJChildFrame *subframe, wxFileName fname, wxString name, const wxWindowID id,
++           const wxPoint& pos, const wxSize& size, long style)
++          : wxTreeCtrl(parent, id, pos, size, style)
++{
++    m_reverseSort = false;
++	m_fname = fname;
++
++	m_peektextCtrl = ((OPJFrame *) (parent->GetParent()->GetParent()))->m_textCtrlbrowse;
++    CreateImageList();
++
++    // Add some items to the tree
++    //AddTestItemsToTree(5, 5);
++    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
++    wxTreeItemId rootId = AddRoot(name,
++                                  image, image,
++                                  new OPJMarkerData(name));
++
++    OPJParseThread *pthread = CreateParseThread(0x00, subframe);
++    if (pthread->Run() != wxTHREAD_NO_ERROR)
++        wxLogMessage(wxT("Can't start parse thread!"));
++    else
++		wxLogMessage(wxT("New parse thread started."));
++
++	m_childframe = subframe;
++}
++
++void OPJMarkerTree::CreateImageList(int size)
++{
++    if (size == -1) {
++        SetImageList(NULL);
++        return;
++    }
++    if (size == 0)
++        size = m_imageSize;
++    else
++        m_imageSize = size;
++
++    // Make an image list containing small icons
++    wxImageList *images = new wxImageList(size, size, true);
++
++    // should correspond to TreeCtrlIcon_xxx enum
++    wxBusyCursor wait;
++    wxIcon icons[5];
++    icons[0] = wxIcon(icon1_xpm);
++    icons[1] = wxIcon(icon2_xpm);
++    icons[2] = wxIcon(icon3_xpm);
++    icons[3] = wxIcon(icon4_xpm);
++    icons[4] = wxIcon(icon5_xpm);
++
++    int sizeOrig = icons[0].GetWidth();
++    for (size_t i = 0; i < WXSIZEOF(icons); i++) {
++        if (size == sizeOrig) {
++            images->Add(icons[i]);
++        } else {
++            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
++        }
++    }
++
++    AssignImageList(images);
++}
++
++#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
++void OPJMarkerTree::CreateButtonsImageList(int size)
++{
++    if ( size == -1 ) {
++        SetButtonsImageList(NULL);
++        return;
++    }
++
++    // Make an image list containing small icons
++    wxImageList *images = new wxImageList(size, size, true);
++
++    // should correspond to TreeCtrlIcon_xxx enum
++    wxBusyCursor wait;
++    wxIcon icons[4];
++    icons[0] = wxIcon(icon3_xpm);   // closed
++    icons[1] = wxIcon(icon3_xpm);   // closed, selected
++    icons[2] = wxIcon(icon5_xpm);   // open
++    icons[3] = wxIcon(icon5_xpm);   // open, selected
++
++    for ( size_t i = 0; i < WXSIZEOF(icons); i++ ) {
++        int sizeOrig = icons[i].GetWidth();
++        if ( size == sizeOrig ) {
++            images->Add(icons[i]);
++        } else {
++            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
++        }
++    }
++
++    AssignButtonsImageList(images);
++#else
++void OPJMarkerTree::CreateButtonsImageList(int WXUNUSED(size))
++{
++#endif
++}
++
++void OPJParseThread::LoadFile(wxFileName fname)
++{
++	wxTreeItemId rootid;
++
++	// this is the root node
++	int image = wxGetApp().ShowImages() ? m_tree->TreeCtrlIcon_Folder : -1;
++
++	if (this->m_parentid) {
++		// leaf of a tree
++		rootid = m_parentid;
++		m_tree->SetItemText(rootid, wxT("Parsing..."));
++
++	} else {
++
++		// delete the existing tree hierarchy
++		m_tree->DeleteAllItems();
++
++		// new tree
++		rootid = m_tree->AddRoot(wxT("Parsing..."),
++			image,
++			image,
++			new OPJMarkerData(fname.GetFullPath())
++			);
++		//m_tree->SetItemFont(rootid, *wxITALIC_FONT);
++		m_tree->SetItemBold(rootid);
++	}
++
++	// open the file
++	wxFile m_file(fname.GetFullPath().c_str(), wxFile::read);
++
++	// parsing enabled?
++	if (wxGetApp().m_enableparse) {
++
++		// what is the extension?
++		if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
++
++			// parse the file
++			ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
++
++		} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
++
++			// parse the file
++			if (this->m_parentid) {
++				//WriteText(wxT("Only a subsection of jp2"));
++				OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
++				ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
++				m_tree->Expand(rootid);
++
++			} else {
++				// as usual
++				ParseJP2File(&m_file, 0, m_file.Length(), rootid);
++			}
++
++		} else {
++
++			// unknown extension
++			WriteText(wxT("Unknown file format!"));
++
++		}
++
++	}
++
++
++	// this is the root node
++	if (this->m_parentid)
++		m_tree->SetItemText(rootid, wxT("Codestream"));
++	else
++		//m_tree->SetItemText(rootid, wxString::Format(wxT("%s (%d B)"), fname.GetFullName(), m_file.Length()));
++		m_tree->SetItemText(rootid, fname.GetFullName());
++
++	// close the file
++	m_file.Close();
++
++	WriteText(wxT("Parsing finished!"));
++}
++
++/*int OPJMarkerTree::OnCompareItems(const wxTreeItemId& item1,
++                               const wxTreeItemId& item2)
++{
++    if ( m_reverseSort )
++    {
++        // just exchange 1st and 2nd items
++        return wxTreeCtrl::OnCompareItems(item2, item1);
++    }
++    else
++    {
++        return wxTreeCtrl::OnCompareItems(item1, item2);
++    }
++}*/
++
++/*void OPJMarkerTree::AddItemsRecursively(const wxTreeItemId& idParent,
++                                     size_t numChildren,
++                                     size_t depth,
++                                     size_t folder)
++{
++    if ( depth > 0 )
++    {
++        bool hasChildren = depth > 1;
++
++        wxString str;
++        for ( size_t n = 0; n < numChildren; n++ )
++        {
++            // at depth 1 elements won't have any more children
++            if ( hasChildren )
++                str.Printf(wxT("%s child %u"), wxT("Folder"), unsigned(n + 1));
++            else
++                str.Printf(wxT("%s child %u.%u"), wxT("File"), unsigned(folder), unsigned(n + 1));
++
++            // here we pass to AppendItem() normal and selected item images (we
++            // suppose that selected image follows the normal one in the enum)
++            int image, imageSel;
++            if ( wxGetApp().ShowImages() )
++            {
++                image = depth == 1 ? TreeCtrlIcon_File : TreeCtrlIcon_Folder;
++                imageSel = image + 1;
++            }
++            else
++            {
++                image = imageSel = -1;
++            }
++            wxTreeItemId id = AppendItem(idParent, str, image, imageSel,
++                                         new OPJMarkerData(str));
++
++            // and now we also set the expanded one (only for the folders)
++            if ( hasChildren && wxGetApp().ShowImages() )
++            {
++                SetItemImage(id, TreeCtrlIcon_FolderOpened,
++                             wxTreeItemIcon_Expanded);
++            }
++
++            // remember the last child for OnEnsureVisible()
++            if ( !hasChildren && n == numChildren - 1 )
++            {
++                m_lastItem = id;
++            }
++
++            AddItemsRecursively(id, numChildren, depth - 1, n + 1);
++        }
++    }
++    //else: done!
++}*/
++
++/*void OPJMarkerTree::AddTestItemsToTree(size_t numChildren,
++                                    size_t depth)
++{
++    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
++    wxTreeItemId rootId = AddRoot(wxT("Root"),
++                                  image, image,
++                                  new OPJMarkerData(wxT("Root item")));
++    if ( image != -1 )
++    {
++        SetItemImage(rootId, TreeCtrlIcon_FolderOpened, wxTreeItemIcon_Expanded);
++    }
++
++    AddItemsRecursively(rootId, numChildren, depth, 0);
++
++    // set some colours/fonts for testing
++    SetItemFont(rootId, *wxITALIC_FONT);
++
++    wxTreeItemIdValue cookie;
++    wxTreeItemId id = GetFirstChild(rootId, cookie);
++    SetItemTextColour(id, *wxBLUE);
++
++    id = GetNextChild(rootId, cookie);
++    id = GetNextChild(rootId, cookie);
++    SetItemTextColour(id, *wxRED);
++    SetItemBackgroundColour(id, *wxLIGHT_GREY);
++}*/
++
++/*void OPJMarkerTree::GetItemsRecursively(const wxTreeItemId& idParent,
++                                     wxTreeItemIdValue cookie)
++{
++    wxTreeItemId id;
++
++    if ( !cookie )
++        id = GetFirstChild(idParent, cookie);
++    else
++        id = GetNextChild(idParent, cookie);
++
++    if ( !id.IsOk() )
++        return;
++
++    wxString text = GetItemText(id);
++    wxLogMessage(text);
++
++    if (ItemHasChildren(id))
++        GetItemsRecursively(id);
++
++    GetItemsRecursively(idParent, cookie);
++}*/
++
++/*void OPJMarkerTree::DoToggleIcon(const wxTreeItemId& item)
++{
++    int image = (GetItemImage(item) == TreeCtrlIcon_Folder)
++                    ? TreeCtrlIcon_File
++                    : TreeCtrlIcon_Folder;
++    SetItemImage(item, image, wxTreeItemIcon_Normal);
++
++    image = (GetItemImage(item) == TreeCtrlIcon_FolderSelected)
++                    ? TreeCtrlIcon_FileSelected
++                    : TreeCtrlIcon_FolderSelected;
++    SetItemImage(item, image, wxTreeItemIcon_Selected);
++}*/
++
++void OPJMarkerTree::LogEvent(const wxChar *name, const wxTreeEvent& event)
++{
++    wxTreeItemId item = event.GetItem();
++    wxString text;
++    if ( item.IsOk() )
++        text << wxT('"') << GetItemText(item).c_str() << wxT('"');
++    else
++        text = wxT("invalid item");
++    wxLogMessage(wxT("%s(%s)"), name, text.c_str());
++}
++
++OPJParseThread *OPJMarkerTree::CreateParseThread(wxTreeItemId parentid, OPJChildFrame *subframe)
++{
++    OPJParseThread *pthread = new OPJParseThread(this, parentid);
++
++    if (pthread->Create() != wxTHREAD_NO_ERROR)
++		wxLogError(wxT("Can't create parse thread!"));
++
++    wxCriticalSectionLocker enter(wxGetApp().m_parse_critsect);
++    wxGetApp().m_parse_threads.Add(pthread);
++
++    return pthread;
++}
++
++
++/*// avoid repetition
++#define TREE_EVENT_HANDLER(name)                                 \
++void OPJMarkerTree::name(wxTreeEvent& event)                        \
++{                                                                \
++    LogEvent(_T(#name), event);                                  \
++    SetLastItem(wxTreeItemId());                                 \
++    event.Skip();                                                \
++}*/
++
++/*TREE_EVENT_HANDLER(OnBeginRDrag)*/
++/*TREE_EVENT_HANDLER(OnDeleteItem)*/
++/*TREE_EVENT_HANDLER(OnGetInfo)
++TREE_EVENT_HANDLER(OnSetInfo)*/
++/*TREE_EVENT_HANDLER(OnItemExpanded)
++TREE_EVENT_HANDLER(OnItemExpanding)*/
++/*TREE_EVENT_HANDLER(OnItemCollapsed)*/
++/*TREE_EVENT_HANDLER(OnSelChanged)
++TREE_EVENT_HANDLER(OnSelChanging)*/
++
++/*#undef TREE_EVENT_HANDLER*/
++
++void OPJMarkerTree::OnItemExpanding(wxTreeEvent& event)
++{
++	wxTreeItemId item = event.GetItem();
++	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
++	wxString text;
++
++	if (item.IsOk())
++		text << wxT('"') << GetItemText(item).c_str() << wxT('"');
++	else
++		text = wxT("invalid item");
++
++	if (wxStrcmp(data->GetDesc1(), wxT("INFO-CSTREAM")))
++		return;
++
++	wxLogMessage(wxT("Expanding... (%s -> %s, %s, %d, %d)"),
++		text.c_str(), data->GetDesc1(), data->GetDesc2(),
++		data->m_start, data->m_length);
++
++	// the codestream box is being asked for expansion
++	wxTreeItemIdValue cookie;
++	if (!GetFirstChild(item, cookie).IsOk()) {
++		OPJParseThread *pthread = CreateParseThread(item);
++		if (pthread->Run() != wxTHREAD_NO_ERROR)
++			wxLogMessage(wxT("Can't start parse thread!"));
++		else
++			wxLogMessage(wxT("New parse thread started."));
++	}
++}
++
++void OPJMarkerTree::OnSelChanged(wxTreeEvent& event)
++{
++	int bunch_linesize = 16;
++	int bunch_numlines = 7;
++
++	wxTreeItemId item = event.GetItem();
++	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
++	wxString text;
++	int l, c, pos = 0, pre_pos;
++
++	m_peektextCtrl->Clear();
++
++	/*text << wxString::Format(wxT("Selected... (%s -> %s, %s, %d, %d)"),
++		text.c_str(), data->GetDesc1(), data->GetDesc2(),
++		data->m_start, data->m_length) << wxT("\n");*/
++
++	// open the file and browse a little
++	wxFile *fp = new wxFile(m_fname.GetFullPath().c_str(), wxFile::read);
++
++	// go to position claimed
++	fp->Seek(data->m_start, wxFromStart);
++
++	// read a bunch
++	int max_read = wxMin(wxFileOffset(bunch_linesize * bunch_numlines), data->m_length - data->m_start + 1);
++	if (data->m_desc == wxT("MARK (65380)")) {
++		/*wxLogMessage(data->m_desc);*/
++		max_read = data->m_length - data->m_start + 1;
++		bunch_numlines = (int) ceil((float) max_read / (float) bunch_linesize);
++	}
++	unsigned char *buffer = new unsigned char[bunch_linesize * bunch_numlines];
++	fp->Read(buffer, max_read);
++
++	// write the file data between start and stop
++	pos = 0;
++	for (l = 0; l < bunch_numlines; l++) {
++
++		text << wxString::Format(wxT("%010d:"), data->m_start + pos);
++
++		pre_pos = pos;
++
++		// add hex browsing text
++		for (c = 0; c < bunch_linesize; c++) {
++
++			if (!(c % 8))
++				text << wxT(" ");
++
++			if (pos < max_read) {
++				text << wxString::Format(wxT("%02X "), buffer[pos]);
++			} else
++				text << wxT("   ");
++			pos++;
++		}
++
++		text << wxT("    ");
++
++		// add char browsing text
++		for (c = 0; c < bunch_linesize; c++) {
++
++			if (pre_pos < max_read) {
++				if ((buffer[pre_pos] == '\n') ||
++					(buffer[pre_pos] == '\t') ||
++					(buffer[pre_pos] == '\0') ||
++					(buffer[pre_pos] == 0x0D) ||
++					(buffer[pre_pos] == 0x0B))
++					buffer[pre_pos] = ' ';
++				text << wxString::FromAscii((char) buffer[pre_pos]) << wxT(".");
++			} else
++				text << wxT("  ");
++			pre_pos++;
++		}
++
++		text << wxT("\n");
++
++	}
++
++	// close the file
++	fp->Close();
++
++	m_peektextCtrl->WriteText(text);
++
++	delete buffer;
++}
++
++/*void LogKeyEvent(const wxChar *name, const wxKeyEvent& event)
++{
++    wxString key;
++    long keycode = event.GetKeyCode();
++    {
++        switch ( keycode )
++        {
++            case WXK_BACK: key = wxT("BACK"); break;
++            case WXK_TAB: key = wxT("TAB"); break;
++            case WXK_RETURN: key = wxT("RETURN"); break;
++            case WXK_ESCAPE: key = wxT("ESCAPE"); break;
++            case WXK_SPACE: key = wxT("SPACE"); break;
++            case WXK_DELETE: key = wxT("DELETE"); break;
++            case WXK_START: key = wxT("START"); break;
++            case WXK_LBUTTON: key = wxT("LBUTTON"); break;
++            case WXK_RBUTTON: key = wxT("RBUTTON"); break;
++            case WXK_CANCEL: key = wxT("CANCEL"); break;
++            case WXK_MBUTTON: key = wxT("MBUTTON"); break;
++            case WXK_CLEAR: key = wxT("CLEAR"); break;
++            case WXK_SHIFT: key = wxT("SHIFT"); break;
++            case WXK_ALT: key = wxT("ALT"); break;
++            case WXK_CONTROL: key = wxT("CONTROL"); break;
++            case WXK_MENU: key = wxT("MENU"); break;
++            case WXK_PAUSE: key = wxT("PAUSE"); break;
++            case WXK_CAPITAL: key = wxT("CAPITAL"); break;
++            case WXK_END: key = wxT("END"); break;
++            case WXK_HOME: key = wxT("HOME"); break;
++            case WXK_LEFT: key = wxT("LEFT"); break;
++            case WXK_UP: key = wxT("UP"); break;
++            case WXK_RIGHT: key = wxT("RIGHT"); break;
++            case WXK_DOWN: key = wxT("DOWN"); break;
++            case WXK_SELECT: key = wxT("SELECT"); break;
++            case WXK_PRINT: key = wxT("PRINT"); break;
++            case WXK_EXECUTE: key = wxT("EXECUTE"); break;
++            case WXK_SNAPSHOT: key = wxT("SNAPSHOT"); break;
++            case WXK_INSERT: key = wxT("INSERT"); break;
++            case WXK_HELP: key = wxT("HELP"); break;
++            case WXK_NUMPAD0: key = wxT("NUMPAD0"); break;
++            case WXK_NUMPAD1: key = wxT("NUMPAD1"); break;
++            case WXK_NUMPAD2: key = wxT("NUMPAD2"); break;
++            case WXK_NUMPAD3: key = wxT("NUMPAD3"); break;
++            case WXK_NUMPAD4: key = wxT("NUMPAD4"); break;
++            case WXK_NUMPAD5: key = wxT("NUMPAD5"); break;
++            case WXK_NUMPAD6: key = wxT("NUMPAD6"); break;
++            case WXK_NUMPAD7: key = wxT("NUMPAD7"); break;
++            case WXK_NUMPAD8: key = wxT("NUMPAD8"); break;
++            case WXK_NUMPAD9: key = wxT("NUMPAD9"); break;
++            case WXK_MULTIPLY: key = wxT("MULTIPLY"); break;
++            case WXK_ADD: key = wxT("ADD"); break;
++            case WXK_SEPARATOR: key = wxT("SEPARATOR"); break;
++            case WXK_SUBTRACT: key = wxT("SUBTRACT"); break;
++            case WXK_DECIMAL: key = wxT("DECIMAL"); break;
++            case WXK_DIVIDE: key = wxT("DIVIDE"); break;
++            case WXK_F1: key = wxT("F1"); break;
++            case WXK_F2: key = wxT("F2"); break;
++            case WXK_F3: key = wxT("F3"); break;
++            case WXK_F4: key = wxT("F4"); break;
++            case WXK_F5: key = wxT("F5"); break;
++            case WXK_F6: key = wxT("F6"); break;
++            case WXK_F7: key = wxT("F7"); break;
++            case WXK_F8: key = wxT("F8"); break;
++            case WXK_F9: key = wxT("F9"); break;
++            case WXK_F10: key = wxT("F10"); break;
++            case WXK_F11: key = wxT("F11"); break;
++            case WXK_F12: key = wxT("F12"); break;
++            case WXK_F13: key = wxT("F13"); break;
++            case WXK_F14: key = wxT("F14"); break;
++            case WXK_F15: key = wxT("F15"); break;
++            case WXK_F16: key = wxT("F16"); break;
++            case WXK_F17: key = wxT("F17"); break;
++            case WXK_F18: key = wxT("F18"); break;
++            case WXK_F19: key = wxT("F19"); break;
++            case WXK_F20: key = wxT("F20"); break;
++            case WXK_F21: key = wxT("F21"); break;
++            case WXK_F22: key = wxT("F22"); break;
++            case WXK_F23: key = wxT("F23"); break;
++            case WXK_F24: key = wxT("F24"); break;
++            case WXK_NUMLOCK: key = wxT("NUMLOCK"); break;
++            case WXK_SCROLL: key = wxT("SCROLL"); break;
++            case WXK_PAGEUP: key = wxT("PAGEUP"); break;
++            case WXK_PAGEDOWN: key = wxT("PAGEDOWN"); break;
++            case WXK_NUMPAD_SPACE: key = wxT("NUMPAD_SPACE"); break;
++            case WXK_NUMPAD_TAB: key = wxT("NUMPAD_TAB"); break;
++            case WXK_NUMPAD_ENTER: key = wxT("NUMPAD_ENTER"); break;
++            case WXK_NUMPAD_F1: key = wxT("NUMPAD_F1"); break;
++            case WXK_NUMPAD_F2: key = wxT("NUMPAD_F2"); break;
++            case WXK_NUMPAD_F3: key = wxT("NUMPAD_F3"); break;
++            case WXK_NUMPAD_F4: key = wxT("NUMPAD_F4"); break;
++            case WXK_NUMPAD_HOME: key = wxT("NUMPAD_HOME"); break;
++            case WXK_NUMPAD_LEFT: key = wxT("NUMPAD_LEFT"); break;
++            case WXK_NUMPAD_UP: key = wxT("NUMPAD_UP"); break;
++            case WXK_NUMPAD_RIGHT: key = wxT("NUMPAD_RIGHT"); break;
++            case WXK_NUMPAD_DOWN: key = wxT("NUMPAD_DOWN"); break;
++            case WXK_NUMPAD_PAGEUP: key = wxT("NUMPAD_PAGEUP"); break;
++            case WXK_NUMPAD_PAGEDOWN: key = wxT("NUMPAD_PAGEDOWN"); break;
++            case WXK_NUMPAD_END: key = wxT("NUMPAD_END"); break;
++            case WXK_NUMPAD_BEGIN: key = wxT("NUMPAD_BEGIN"); break;
++            case WXK_NUMPAD_INSERT: key = wxT("NUMPAD_INSERT"); break;
++            case WXK_NUMPAD_DELETE: key = wxT("NUMPAD_DELETE"); break;
++            case WXK_NUMPAD_EQUAL: key = wxT("NUMPAD_EQUAL"); break;
++            case WXK_NUMPAD_MULTIPLY: key = wxT("NUMPAD_MULTIPLY"); break;
++            case WXK_NUMPAD_ADD: key = wxT("NUMPAD_ADD"); break;
++            case WXK_NUMPAD_SEPARATOR: key = wxT("NUMPAD_SEPARATOR"); break;
++            case WXK_NUMPAD_SUBTRACT: key = wxT("NUMPAD_SUBTRACT"); break;
++            case WXK_NUMPAD_DECIMAL: key = wxT("NUMPAD_DECIMAL"); break;
++
++            default:
++            {
++               if ( keycode < 128 && wxIsprint((int)keycode) )
++                   key.Printf(wxT("'%c'"), (char)keycode);
++               else if ( keycode > 0 && keycode < 27 )
++                   key.Printf(_("Ctrl-%c"), wxT('A') + keycode - 1);
++               else
++                   key.Printf(wxT("unknown (%ld)"), keycode);
++            }
++        }
++    }
++
++    wxLogMessage(wxT("%s event: %s (flags = %c%c%c%c)"),
++                  name,
++                  key.c_str(),
++                  event.ControlDown() ? wxT('C') : wxT('-'),
++                  event.AltDown() ? wxT('A') : wxT('-'),
++                  event.ShiftDown() ? wxT('S') : wxT('-'),
++                  event.MetaDown() ? wxT('M') : wxT('-'));
++}
++
++void OPJMarkerTree::OnTreeKeyDown(wxTreeEvent& event)
++{
++    LogKeyEvent(wxT("Tree key down "), event.GetKeyEvent());
++
++    event.Skip();
++}*/
++
++/*void OPJMarkerTree::OnBeginDrag(wxTreeEvent& event)
++{
++    // need to explicitly allow drag
++    if ( event.GetItem() != GetRootItem() )
++    {
++        m_draggedItem = event.GetItem();
++
++        wxLogMessage(wxT("OnBeginDrag: started dragging %s"),
++                     GetItemText(m_draggedItem).c_str());
++
++        event.Allow();
++    }
++    else
++    {
++        wxLogMessage(wxT("OnBeginDrag: this item can't be dragged."));
++    }
++}
++
++void OPJMarkerTree::OnEndDrag(wxTreeEvent& event)
++{
++    wxTreeItemId itemSrc = m_draggedItem,
++                 itemDst = event.GetItem();
++    m_draggedItem = (wxTreeItemId)0l;
++
++    // where to copy the item?
++    if ( itemDst.IsOk() && !ItemHasChildren(itemDst) )
++    {
++        // copy to the parent then
++        itemDst = GetItemParent(itemDst);
++    }
++
++    if ( !itemDst.IsOk() )
++    {
++        wxLogMessage(wxT("OnEndDrag: can't drop here."));
++
++        return;
++    }
++
++    wxString text = GetItemText(itemSrc);
++    wxLogMessage(wxT("OnEndDrag: '%s' copied to '%s'."),
++                 text.c_str(), GetItemText(itemDst).c_str());
++
++    // just do append here - we could also insert it just before/after the item
++    // on which it was dropped, but this requires slightly more work... we also
++    // completely ignore the client data and icon of the old item but could
++    // copy them as well.
++    //
++    // Finally, we only copy one item here but we might copy the entire tree if
++    // we were dragging a folder.
++    int image = wxGetApp().ShowImages() ? TreeCtrlIcon_File : -1;
++    AppendItem(itemDst, text, image);
++}*/
++
++/*void OPJMarkerTree::OnBeginLabelEdit(wxTreeEvent& event)
++{
++    wxLogMessage(wxT("OnBeginLabelEdit"));
++
++    // for testing, prevent this item's label editing
++    wxTreeItemId itemId = event.GetItem();
++    if ( IsTestItem(itemId) )
++    {
++        wxMessageBox(wxT("You can't edit this item."));
++
++        event.Veto();
++    }
++    else if ( itemId == GetRootItem() )
++    {
++        // test that it is possible to change the text of the item being edited
++        SetItemText(itemId, _T("Editing root item"));
++    }
++}
++
++void OPJMarkerTree::OnEndLabelEdit(wxTreeEvent& event)
++{
++    wxLogMessage(wxT("OnEndLabelEdit"));
++
++    // don't allow anything except letters in the labels
++    if ( !event.GetLabel().IsWord() )
++    {
++        wxMessageBox(wxT("The new label should be a single word."));
++
++        event.Veto();
++    }
++}*/
++
++/*void OPJMarkerTree::OnItemCollapsing(wxTreeEvent& event)
++{
++    wxLogMessage(wxT("OnItemCollapsing"));
++
++    // for testing, prevent the user from collapsing the first child folder
++    wxTreeItemId itemId = event.GetItem();
++    if ( IsTestItem(itemId) )
++    {
++        wxMessageBox(wxT("You can't collapse this item."));
++
++        event.Veto();
++    }
++}*/
++
++/*void OPJMarkerTree::OnItemActivated(wxTreeEvent& event)
++{
++    // show some info about this item
++    wxTreeItemId itemId = event.GetItem();
++    OPJMarkerData *item = (OPJMarkerData *)GetItemData(itemId);
++
++    if ( item != NULL )
++    {
++        item->ShowInfo(this);
++    }
++
++    wxLogMessage(wxT("OnItemActivated"));
++}*/
++
++void OPJMarkerTree::OnItemMenu(wxTreeEvent& event)
++{
++    /*wxTreeItemId itemId = event.GetItem();
++    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
++                                         : NULL;
++
++    wxLogMessage(wxT("OnItemMenu for item \"%s\""), item ? item->GetDesc()
++                                                         : _T(""));*/
++
++	//wxLogMessage(wxT("EEEEEEEEEE"));
++
++    //event.Skip();
++}
++
++/*void OPJMarkerTree::OnContextMenu(wxContextMenuEvent& event)
++{
++    wxPoint pt = event.GetPosition();
++    wxTreeItemId item;
++    wxLogMessage(wxT("OnContextMenu at screen coords (%i, %i)"), pt.x, pt.y);
++
++    // check if event was generated by keyboard (MSW-specific?)
++    if ( pt.x == -1 && pt.y == -1 ) //(this is how MSW indicates it)
++    {
++        if ( !HasFlag(wxTR_MULTIPLE) )
++            item = GetSelection();
++
++        // attempt to guess where to show the menu
++        if ( item.IsOk() )
++        {
++            // if an item was clicked, show menu to the right of it
++            wxRect rect;
++            GetBoundingRect(item, rect, true );// only the label
++            pt = wxPoint(rect.GetRight(), rect.GetTop());
++        }
++        else
++        {
++            pt = wxPoint(0, 0);
++        }
++    }
++    else // event was generated by mouse, use supplied coords
++    {
++        pt = ScreenToClient(pt);
++        item = HitTest(pt);
++    }
++
++    ShowMenu(item, pt);
++}*/
++
++/*void OPJMarkerTree::ShowMenu(wxTreeItemId id, const wxPoint& pt)
++{
++    wxString title;
++    if ( id.IsOk() )
++    {
++        title << wxT("Menu for ") << GetItemText(id);
++    }
++    else
++    {
++        title = wxT("Menu for no particular item");
++    }
++
++#if wxUSE_MENUS
++    wxMenu menu(title);
++    menu.Append(TreeTest_About, wxT("&About..."));
++    menu.AppendSeparator();
++    menu.Append(TreeTest_Highlight, wxT("&Highlight item"));
++    menu.Append(TreeTest_Dump, wxT("&Dump"));
++
++    PopupMenu(&menu, pt);
++#endif // wxUSE_MENUS
++}*/
++
++/*void OPJMarkerTree::OnItemRClick(wxTreeEvent& event)
++{
++    wxTreeItemId itemId = event.GetItem();
++    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
++                                         : NULL;
++
++    wxLogMessage(wxT("Item \"%s\" right clicked"), item ? item->GetDesc()
++                                                        : _T(""));
++
++    event.Skip();
++}*/
++
++/*
++void OPJMarkerTree::OnRMouseDown(wxMouseEvent& event)
++{
++    wxLogMessage(wxT("Right mouse button down"));
++
++    event.Skip();
++}
++
++void OPJMarkerTree::OnRMouseUp(wxMouseEvent& event)
++{
++    wxLogMessage(wxT("Right mouse button up"));
++
++    event.Skip();
++}
++
++void OPJMarkerTree::OnRMouseDClick(wxMouseEvent& event)
++{
++    wxTreeItemId id = HitTest(event.GetPosition());
++    if ( !id )
++        wxLogMessage(wxT("No item under mouse"));
++    else
++    {
++        OPJMarkerData *item = (OPJMarkerData *)GetItemData(id);
++        if ( item )
++            wxLogMessage(wxT("Item '%s' under mouse"), item->GetDesc());
++    }
++
++    event.Skip();
++}
++*/
++
++static inline const wxChar *Bool2String(bool b)
++{
++    return b ? wxT("") : wxT("not ");
++}
++
++void OPJMarkerData::ShowInfo(wxTreeCtrl *tree)
++{
++    wxLogMessage(wxT("Item '%s': %sselected, %sexpanded, %sbold,\n")
++                 wxT("%u children (%u immediately under this item)."),
++                 m_desc.c_str(),
++                 Bool2String(tree->IsSelected(GetId())),
++                 Bool2String(tree->IsExpanded(GetId())),
++                 Bool2String(tree->IsBold(GetId())),
++                 unsigned(tree->GetChildrenCount(GetId())),
++                 unsigned(tree->GetChildrenCount(GetId(), false)));
++}
++
++
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/OPJViewer.cpp ./OPJViewer/source/OPJViewer.cpp
+--- ../trunk.orig/OPJViewer/source/OPJViewer.cpp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/OPJViewer.cpp	2007-12-01 18:40:47.000000000 +0000
+@@ -1,5 +1,5 @@
+ /*
+- * Copyright (c) 2007, Digital Signal Processing Laboratory, UniversitÃ  degli studi di Perugia (UPG), Italy
++ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita' degli studi di Perugia (UPG), Italy
+  * All rights reserved.
+  *
+  * Redistribution and use in source and binary forms, with or without
+@@ -132,11 +132,11 @@
+ // Initialise this in OnInit, not statically
+ bool OPJViewerApp::OnInit(void)
+ {
++	int n;
+ #if wxUSE_UNICODE
+ 
+     wxChar **wxArgv = new wxChar *[argc + 1];
+ 
+-	int n;
+     for (n = 0; n < argc; n++ ) {
+         wxMB2WXbuf warg = wxConvertMB2WX((char *) argv[n]);
+         wxArgv[n] = wxStrdup(warg);
+@@ -189,6 +189,9 @@
+ #if wxUSE_LIBJPEG
+   wxImage::AddHandler( new wxJPEGHandler );
+ #endif
++#if USE_MXF
++  wxImage::AddHandler( new wxMXFHandler );
++#endif // USE_MXF
+ #if wxUSE_LIBOPENJPEG
+   wxImage::AddHandler( new wxJ2KHandler );
+   wxImage::AddHandler( new wxJP2Handler );
+@@ -211,17 +214,17 @@
+ 	//load decoding engine parameters
+ 	OPJconfig = new wxConfig(OPJ_APPLICATION, OPJ_APPLICATION_VENDOR);
+ 
+-	OPJconfig->Read(wxT("enabledeco"), &m_enabledeco, (bool) true);
+-	OPJconfig->Read(wxT("enableparse"), &m_enableparse, (bool) true);
+-	OPJconfig->Read(wxT("resizemethod"), &m_resizemethod, (long) 0);
+-	OPJconfig->Read(wxT("reducefactor"), &m_reducefactor, (long) 0);
+-	OPJconfig->Read(wxT("qualitylayers"), &m_qualitylayers, (long) 0);
+-	OPJconfig->Read(wxT("components"), &m_components, (long) 0);
+-	OPJconfig->Read(wxT("framenum"), &m_framenum, (long) 0);
++	OPJconfig->Read(wxT("decode/enabledeco"), &m_enabledeco, (bool) true);
++	OPJconfig->Read(wxT("decode/enableparse"), &m_enableparse, (bool) true);
++	OPJconfig->Read(wxT("decode/resizemethod"), &m_resizemethod, (long) 0);
++	OPJconfig->Read(wxT("decode/xxxreducefactor"), &m_reducefactor, (long) 0);
++	OPJconfig->Read(wxT("decode/xxxqualitylayers"), &m_qualitylayers, (long) 0);
++	OPJconfig->Read(wxT("decode/xxxcomponents"), &m_components, (long) 0);
++	OPJconfig->Read(wxT("decode/xxxframenum"), &m_framenum, (long) 0);
+ #ifdef USE_JPWL
+-	OPJconfig->Read(wxT("enablejpwl"), &m_enablejpwl, (bool) true);
+-	OPJconfig->Read(wxT("expcomps"), &m_expcomps, (long) JPWL_EXPECTED_COMPONENTS);
+-	OPJconfig->Read(wxT("maxtiles"), &m_maxtiles, (long) JPWL_MAXIMUM_TILES);
++	OPJconfig->Read(wxT("decode/enablejpwl"), &m_enablejpwl, (bool) true);
++	OPJconfig->Read(wxT("decode/expcomps"), &m_expcomps, (long) JPWL_EXPECTED_COMPONENTS);
++	OPJconfig->Read(wxT("decode/maxtiles"), &m_maxtiles, (long) JPWL_MAXIMUM_TILES);
+ #endif // USE_JPWL
+ 
+ 	OPJconfig->Write(wxT("teststring"), wxT("This is a test value"));
+@@ -237,22 +240,45 @@
+ 	OPJconfig->Read(wxT("frameheight"), &m_frameheight, (long) OPJ_FRAME_HEIGHT);
+ 
+ 	// load encoding engine parameters
+-	OPJconfig->Read(wxT("subsampling"), &m_subsampling, (wxString) wxT("1,1"));
+-	OPJconfig->Read(wxT("origin"), &m_origin, (wxString) wxT("0,0"));
+-	OPJconfig->Read(wxT("rates"), &m_rates, (wxString) wxT("20,10,5"));
+-	OPJconfig->Read(wxT("quality"), &m_quality, (wxString) wxT("30,35,40"));
+-	OPJconfig->Read(wxT("irreversible"), &m_irreversible, (bool) false);	
+-	OPJconfig->Read(wxT("resolutions"), &m_resolutions, (int) 6);	
+-	OPJconfig->Read(wxT("cbsize"), &m_cbsize, (wxString) wxT("32,32"));
+-	OPJconfig->Read(wxT("prsize"), &m_prsize, (wxString) wxT("[128,128],[128,128]"));
+-	OPJconfig->Read(wxT("tsize"), &m_tsize, (wxString) wxT(""));
+-	OPJconfig->Read(wxT("torigin"), &m_torigin, (wxString) wxT("0,0"));
+-	OPJconfig->Read(wxT("enablesop"), &m_enablesop, (bool) false);	
+-	OPJconfig->Read(wxT("enableeph"), &m_enableeph, (bool) false);	
+-	OPJconfig->Read(wxT("enablecomm"), &m_enablecomm, (bool) true);	
+-	OPJconfig->Read(wxT("comment"), &m_comment, (wxString) wxT(""));
+-	OPJconfig->Read(wxT("enableidx"), &m_enableidx, (bool) false);	
+-	OPJconfig->Read(wxT("index"), &m_index, (wxString) wxT("index.txt"));
++	OPJconfig->Read(wxT("encode/subsampling"), &m_subsampling, (wxString) wxT("1,1"));
++	OPJconfig->Read(wxT("encode/origin"), &m_origin, (wxString) wxT("0,0"));
++	OPJconfig->Read(wxT("encode/rates"), &m_rates, (wxString) wxT("20,10,5"));
++	OPJconfig->Read(wxT("encode/quality"), &m_quality, (wxString) wxT("30,35,40"));
++	OPJconfig->Read(wxT("encode/enablequality"), &m_enablequality, (bool) false);
++	OPJconfig->Read(wxT("encode/multicomp"), &m_multicomp, (bool) false);	
++	OPJconfig->Read(wxT("encode/irreversible"), &m_irreversible, (bool) false);	
++	OPJconfig->Read(wxT("encode/resolutions"), &m_resolutions, (int) 6);	
++	OPJconfig->Read(wxT("encode/progression"), &m_progression, (int) 0);	
++	OPJconfig->Read(wxT("encode/cbsize"), &m_cbsize, (wxString) wxT("32,32"));
++	OPJconfig->Read(wxT("encode/prsize"), &m_prsize, (wxString) wxT("[128,128],[128,128]"));
++	OPJconfig->Read(wxT("encode/tsize"), &m_tsize, (wxString) wxT(""));
++	OPJconfig->Read(wxT("encode/torigin"), &m_torigin, (wxString) wxT("0,0"));
++	OPJconfig->Read(wxT("encode/enablesop"), &m_enablesop, (bool) false);	
++	OPJconfig->Read(wxT("encode/enableeph"), &m_enableeph, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablebypass"), &m_enablebypass, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablereset"), &m_enablereset, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablerestart"), &m_enablerestart, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablevsc"), &m_enablevsc, (bool) false);	
++	OPJconfig->Read(wxT("encode/enableerterm"), &m_enableerterm, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablesegmark"), &m_enablesegmark, (bool) false);	
++	OPJconfig->Read(wxT("encode/enablecomm"), &m_enablecomm, (bool) true);	
++	OPJconfig->Read(wxT("encode/enablepoc"), &m_enablepoc, (bool) false);	
++	OPJconfig->Read(wxT("encode/comment"), &m_comment, (wxString) wxT(""));
++	OPJconfig->Read(wxT("encode/poc"), &m_poc, (wxString) wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL"));
++	OPJconfig->Read(wxT("encode/enableidx"), &m_enableidx, (bool) false);	
++	OPJconfig->Read(wxT("encode/index"), &m_index, (wxString) wxT("index.txt"));
++#ifdef USE_JPWL
++	OPJconfig->Read(wxT("encode/enablejpwl"), &m_enablejpwle, (bool) true);
++	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
++		OPJconfig->Read(wxT("encode/jpwl/hprotsel") + wxString::Format(wxT("%02d"), n), &m_hprotsel[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/htileval") + wxString::Format(wxT("%02d"), n), &m_htileval[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/pprotsel") + wxString::Format(wxT("%02d"), n), &m_pprotsel[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/ptileval") + wxString::Format(wxT("%02d"), n), &m_ptileval[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/ppackval") + wxString::Format(wxT("%02d"), n), &m_ppackval[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/sensisel") + wxString::Format(wxT("%02d"), n), &m_sensisel[n], 0);
++		OPJconfig->Read(wxT("encode/jpwl/stileval") + wxString::Format(wxT("%02d"), n), &m_stileval[n], 0);
++	}
++#endif // USE_JPWL
+ 
+ #else
+ 	// set decoding engine parameters
+@@ -281,18 +307,40 @@
+ 	m_origin = wxT("0,0");
+ 	m_rates = wxT("20,10,5");
+ 	m_quality = wxT("30,35,40");
++	m_enablequality = false;
++	m_multicomp = false;
+ 	m_irreversible = false;
+ 	m_resolutions = 6;
++	m_progression = 0;
+ 	m_cbsize= wxT("32,32");
+ 	m_prsize= wxT("[128,128],[128,128]");
+ 	m_tsize = wxT("");
+ 	m_torigin = wxT("0,0");
+ 	m_enablesop = false;
+ 	m_enableeph = false;
++	m_enablebypass = false;
++	m_enablereset = false;
++	m_enablerestart = false;
++	m_enablevsc = false;
++	m_enableerterm = false;
++	m_enablesegmark = false;
+ 	m_enableidx = false;
+ 	m_index = wxT("index.txt");
+ 	m_enablecomm = true;
+ 	m_comment = wxT("");
++	m_enablepoc = false;
++	m_poc = wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL");
++#ifdef USE_JPWL
++	m_enablejpwle = true;
++	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
++		m_hprotsel[n] = 0;
++		m_htileval[n] = 0;
++		m_pprotsel[n] = 0;
++		m_ptileval[n] = 0;
++		m_sensisel[n] = 0;
++		m_stileval[n] = 0;
++	}
++#endif // USE_JPWL
+ 
+ #endif // OPJ_INICONFIG
+ 
+@@ -306,9 +354,9 @@
+ #endif
+ 
+ #ifdef USE_JPWL
+-		m_comment += wxString::Format("%s with JPWL", opj_version());
++		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+ #else
+-		m_comment += wxString::Format("%s", opj_version());
++		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+ #endif
+ 	}
+ 
+@@ -344,18 +392,20 @@
+ 
+ int OPJViewerApp::OnExit()
+ {
++	int n;
++
+ #ifdef OPJ_INICONFIG
+-	OPJconfig->Write(wxT("enabledeco"), m_enabledeco);
+-	OPJconfig->Write(wxT("enableparse"), m_enableparse);
+-	OPJconfig->Write(wxT("resizemethod"), m_resizemethod);
+-	OPJconfig->Write(wxT("reducefactor"), m_reducefactor);
+-	OPJconfig->Write(wxT("qualitylayers"), m_qualitylayers);
+-	OPJconfig->Write(wxT("components"), m_components);
+-	OPJconfig->Write(wxT("framenum"), m_framenum);
++	OPJconfig->Write(wxT("decode/enabledeco"), m_enabledeco);
++	OPJconfig->Write(wxT("decode/enableparse"), m_enableparse);
++	OPJconfig->Write(wxT("decode/resizemethod"), m_resizemethod);
++	OPJconfig->Write(wxT("decode/reducefactor"), m_reducefactor);
++	OPJconfig->Write(wxT("decode/qualitylayers"), m_qualitylayers);
++	OPJconfig->Write(wxT("decode/components"), m_components);
++	OPJconfig->Write(wxT("decode/framenum"), m_framenum);
+ #ifdef USE_JPWL
+-	OPJconfig->Write(wxT("enablejpwl"), m_enablejpwl);
+-	OPJconfig->Write(wxT("expcomps"), m_expcomps);
+-	OPJconfig->Write(wxT("maxtiles"), m_maxtiles);
++	OPJconfig->Write(wxT("decode/enablejpwl"), m_enablejpwl);
++	OPJconfig->Write(wxT("decode/expcomps"), m_expcomps);
++	OPJconfig->Write(wxT("decode/maxtiles"), m_maxtiles);
+ #endif // USE_JPWL
+ 	OPJconfig->Write(wxT("showtoolbar"), m_showtoolbar);
+ 	OPJconfig->Write(wxT("showbrowser"), m_showbrowser);
+@@ -365,22 +415,45 @@
+ 	OPJconfig->Write(wxT("framewidth"), m_framewidth);
+ 	OPJconfig->Write(wxT("frameheight"), m_frameheight);
+ 
+-	OPJconfig->Write(wxT("subsampling"), m_subsampling);
+-	OPJconfig->Write(wxT("origin"), m_origin);
+-	OPJconfig->Write(wxT("rates"), m_rates);
+-	OPJconfig->Write(wxT("quality"), m_quality);
+-	OPJconfig->Write(wxT("irreversible"), m_irreversible);
+-	OPJconfig->Write(wxT("resolutions"), m_resolutions);
+-	OPJconfig->Write(wxT("cbsize"), m_cbsize);
+-	OPJconfig->Write(wxT("prsize"), m_prsize);
+-	OPJconfig->Write(wxT("tiles"), m_tsize);
+-	OPJconfig->Write(wxT("torigin"), m_torigin);
+-	OPJconfig->Write(wxT("enablesop"), m_enablesop);
+-	OPJconfig->Write(wxT("enableeph"), m_enableeph);
+-	OPJconfig->Write(wxT("enableidx"), m_enableidx);
+-	OPJconfig->Write(wxT("index"), m_index);
+-	OPJconfig->Write(wxT("enablecomm"), m_enablecomm);
+-	OPJconfig->Write(wxT("comment"), m_comment);
++	OPJconfig->Write(wxT("encode/subsampling"), m_subsampling);
++	OPJconfig->Write(wxT("encode/origin"), m_origin);
++	OPJconfig->Write(wxT("encode/rates"), m_rates);
++	OPJconfig->Write(wxT("encode/quality"), m_quality);
++	OPJconfig->Write(wxT("encode/enablequality"), m_enablequality);
++	OPJconfig->Write(wxT("encode/multicomp"), m_multicomp);
++	OPJconfig->Write(wxT("encode/irreversible"), m_irreversible);
++	OPJconfig->Write(wxT("encode/resolutions"), m_resolutions);
++	OPJconfig->Write(wxT("encode/progression"), m_progression);
++	OPJconfig->Write(wxT("encode/cbsize"), m_cbsize);
++	OPJconfig->Write(wxT("encode/prsize"), m_prsize);
++	OPJconfig->Write(wxT("encode/tiles"), m_tsize);
++	OPJconfig->Write(wxT("encode/torigin"), m_torigin);
++	OPJconfig->Write(wxT("encode/enablesop"), m_enablesop);
++	OPJconfig->Write(wxT("encode/enableeph"), m_enableeph);
++	OPJconfig->Write(wxT("encode/enablebypass"), m_enablebypass);
++	OPJconfig->Write(wxT("encode/enablereset"), m_enablereset);
++	OPJconfig->Write(wxT("encode/enablerestart"), m_enablerestart);
++	OPJconfig->Write(wxT("encode/enablevsc"), m_enablevsc);
++	OPJconfig->Write(wxT("encode/enableerterm"), m_enableerterm);
++	OPJconfig->Write(wxT("encode/enablesegmark"), m_enablesegmark);
++	OPJconfig->Write(wxT("encode/enableidx"), m_enableidx);
++	OPJconfig->Write(wxT("encode/index"), m_index);
++	OPJconfig->Write(wxT("encode/enablecomm"), m_enablecomm);
++	OPJconfig->Write(wxT("encode/comment"), m_comment);
++	OPJconfig->Write(wxT("encode/enablepoc"), m_enablepoc);
++	OPJconfig->Write(wxT("encode/poc"), m_poc);
++#ifdef USE_JPWL
++	OPJconfig->Write(wxT("encode/enablejpwl"), m_enablejpwle);
++	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
++		OPJconfig->Write(wxT("encode/jpwl/hprotsel") + wxString::Format(wxT("%02d"), n), m_hprotsel[n]);
++		OPJconfig->Write(wxT("encode/jpwl/htileval") + wxString::Format(wxT("%02d"), n), m_htileval[n]);
++		OPJconfig->Write(wxT("encode/jpwl/pprotsel") + wxString::Format(wxT("%02d"), n), m_pprotsel[n]);
++		OPJconfig->Write(wxT("encode/jpwl/ptileval") + wxString::Format(wxT("%02d"), n), m_ptileval[n]);
++		OPJconfig->Write(wxT("encode/jpwl/ppackval") + wxString::Format(wxT("%02d"), n), m_ppackval[n]);
++		OPJconfig->Write(wxT("encode/jpwl/sensisel") + wxString::Format(wxT("%02d"), n), m_sensisel[n]);
++		OPJconfig->Write(wxT("encode/jpwl/stileval") + wxString::Format(wxT("%02d"), n), m_stileval[n]);
++	}
++#endif // USE_JPWL
+ 
+ #endif // OPJ_INICONFIG
+ 
+@@ -415,6 +488,15 @@
+     EVT_MENU(OPJFRAME_VIEWPREVFRAME, OPJFrame::OnPrevFrame)
+     EVT_MENU(OPJFRAME_VIEWHOMEFRAME, OPJFrame::OnHomeFrame)
+     EVT_MENU(OPJFRAME_VIEWNEXTFRAME, OPJFrame::OnNextFrame)
++    EVT_MENU(OPJFRAME_VIEWLESSLAYERS, OPJFrame::OnLessLayers)
++    EVT_MENU(OPJFRAME_VIEWALLLAYERS, OPJFrame::OnAllLayers)
++    EVT_MENU(OPJFRAME_VIEWMORELAYERS, OPJFrame::OnMoreLayers)
++    EVT_MENU(OPJFRAME_VIEWLESSRES, OPJFrame::OnLessRes)
++    EVT_MENU(OPJFRAME_VIEWFULLRES, OPJFrame::OnFullRes)
++    EVT_MENU(OPJFRAME_VIEWMORERES, OPJFrame::OnMoreRes)
++    EVT_MENU(OPJFRAME_VIEWPREVCOMP, OPJFrame::OnPrevComp)
++    EVT_MENU(OPJFRAME_VIEWALLCOMPS, OPJFrame::OnAllComps)
++    EVT_MENU(OPJFRAME_VIEWNEXTCOMP, OPJFrame::OnNextComp)
+     EVT_MENU(OPJFRAME_FILETOGGLEB, OPJFrame::OnToggleBrowser)
+     EVT_MENU(OPJFRAME_FILETOGGLEP, OPJFrame::OnTogglePeeker)
+     EVT_MENU(OPJFRAME_FILETOGGLET, OPJFrame::OnToggleToolbar)
+@@ -486,6 +568,39 @@
+ 	view_menu->Append(OPJFRAME_VIEWNEXTFRAME, wxT("&Next frame\tRight"));
+ 	view_menu->SetHelpString(OPJFRAME_VIEWNEXTFRAME, wxT("View next frame"));
+ 
++	view_menu->AppendSeparator();
++
++	view_menu->Append(OPJFRAME_VIEWLESSLAYERS, wxT("&Less layers\t-"));
++	view_menu->SetHelpString(OPJFRAME_VIEWLESSLAYERS, wxT("Remove a layer"));
++
++	view_menu->Append(OPJFRAME_VIEWALLLAYERS, wxT("&All layers\t0"));
++	view_menu->SetHelpString(OPJFRAME_VIEWALLLAYERS, wxT("Show all layers"));
++
++	view_menu->Append(OPJFRAME_VIEWMORELAYERS, wxT("&More layers\t+"));
++	view_menu->SetHelpString(OPJFRAME_VIEWMORELAYERS, wxT("Add a layer"));
++
++	view_menu->AppendSeparator();
++
++	view_menu->Append(OPJFRAME_VIEWLESSRES, wxT("&Less resolution\t<"));
++	view_menu->SetHelpString(OPJFRAME_VIEWLESSRES, wxT("Reduce the resolution"));
++
++	view_menu->Append(OPJFRAME_VIEWFULLRES, wxT("&Full resolution\tf"));
++	view_menu->SetHelpString(OPJFRAME_VIEWFULLRES, wxT("Full resolution"));
++
++	view_menu->Append(OPJFRAME_VIEWMORERES, wxT("&More resolution\t>"));
++	view_menu->SetHelpString(OPJFRAME_VIEWMORERES, wxT("Increase the resolution"));
++
++	view_menu->AppendSeparator();
++
++	view_menu->Append(OPJFRAME_VIEWPREVCOMP, wxT("&Prev component\tDown"));
++	view_menu->SetHelpString(OPJFRAME_VIEWPREVCOMP, wxT("View previous component"));
++
++	view_menu->Append(OPJFRAME_VIEWALLCOMPS, wxT("&All components\ta"));
++	view_menu->SetHelpString(OPJFRAME_VIEWALLCOMPS, wxT("View all components"));
++
++	view_menu->Append(OPJFRAME_VIEWNEXTCOMP, wxT("&Next component\tUp"));
++	view_menu->SetHelpString(OPJFRAME_VIEWNEXTCOMP, wxT("View next component"));
++
+ 
+ 	// settings menu and its items
+ 	wxMenu *sets_menu = new wxMenu;
+@@ -539,6 +654,18 @@
+ 												wxDefaultSize);
+ 	wxBitmap bmpNextframe = wxArtProvider::GetBitmap(wxART_GO_FORWARD, wxART_TOOLBAR,
+ 												wxDefaultSize);
++	wxBitmap bmpLesslayers = bmpPrevframe;
++	wxBitmap bmpAlllayers = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
++												wxDefaultSize);
++	wxBitmap bmpMorelayers = bmpNextframe;
++	wxBitmap bmpLessres = bmpPrevframe;
++	wxBitmap bmpFullres = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
++												wxDefaultSize);
++	wxBitmap bmpMoreres = bmpNextframe;
++	wxBitmap bmpPrevcomp = bmpPrevframe;
++	wxBitmap bmpAllcomps = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
++												wxDefaultSize);
++	wxBitmap bmpNextcomp = bmpNextframe;
+ 
+ 	tool_bar->AddTool(OPJFRAME_FILEOPEN, bmpOpen, wxT("Open"));
+ 	tool_bar->AddTool(OPJFRAME_FILESAVEAS, bmpSaveAs, wxT("Save as "));
+@@ -554,6 +681,18 @@
+ 	tool_bar->AddTool(OPJFRAME_VIEWPREVFRAME, bmpPrevframe, wxT("Previous frame"));
+ 	tool_bar->AddTool(OPJFRAME_VIEWHOMEFRAME, bmpHomeframe, wxT("Starting frame"));
+ 	tool_bar->AddTool(OPJFRAME_VIEWNEXTFRAME, bmpNextframe, wxT("Next frame"));
++	tool_bar->AddSeparator();
++	tool_bar->AddTool(OPJFRAME_VIEWLESSLAYERS, bmpLesslayers, wxT("Remove a layer"));
++	tool_bar->AddTool(OPJFRAME_VIEWALLLAYERS, bmpAlllayers, wxT("Show all layers"));
++	tool_bar->AddTool(OPJFRAME_VIEWMORELAYERS, bmpMorelayers, wxT("Add a layer"));
++	tool_bar->AddSeparator();
++	tool_bar->AddTool(OPJFRAME_VIEWLESSRES, bmpLessres, wxT("Reduce the resolution"));
++	tool_bar->AddTool(OPJFRAME_VIEWFULLRES, bmpFullres, wxT("Full resolution"));
++	tool_bar->AddTool(OPJFRAME_VIEWMORERES, bmpMoreres, wxT("Increase the resolution"));
++	tool_bar->AddSeparator();
++	tool_bar->AddTool(OPJFRAME_VIEWPREVCOMP, bmpPrevcomp, wxT("Previous component"));
++	tool_bar->AddTool(OPJFRAME_VIEWALLCOMPS, bmpAllcomps, wxT("All components"));
++	tool_bar->AddTool(OPJFRAME_VIEWNEXTCOMP, bmpNextcomp, wxT("Next component"));
+ 	tool_bar->Realize();
+ 	
+ 	// associate the toolbar with the frame
+@@ -693,6 +832,8 @@
+ 
+ void OPJFrame::OnSetsEnco(wxCommandEvent& event)
+ {
++	int n;
++
+     OPJEncoderDialog dialog(this, event.GetId());
+ 
+     if (dialog.ShowModal() == wxID_OK) {
+@@ -702,18 +843,41 @@
+ 		wxGetApp().m_origin = dialog.m_originCtrl->GetValue();
+ 		wxGetApp().m_rates = dialog.m_rateCtrl->GetValue();
+ 		wxGetApp().m_quality = dialog.m_qualityCtrl->GetValue();
++		wxGetApp().m_enablequality = dialog.m_qualityRadio->GetValue();
++		wxGetApp().m_multicomp = dialog.m_mctCheck->GetValue();
+ 		wxGetApp().m_irreversible = dialog.m_irrevCheck->GetValue();
+ 		wxGetApp().m_resolutions = dialog.m_resolutionsCtrl->GetValue();
+ 		wxGetApp().m_cbsize = dialog.m_cbsizeCtrl->GetValue();
+ 		wxGetApp().m_prsize = dialog.m_prsizeCtrl->GetValue();
+ 		wxGetApp().m_tsize = dialog.m_tsizeCtrl->GetValue();
+ 		wxGetApp().m_torigin = dialog.m_toriginCtrl->GetValue();
++		wxGetApp().m_progression = dialog.progressionBox->GetSelection();
+ 		wxGetApp().m_enablesop = dialog.m_sopCheck->GetValue();
+ 		wxGetApp().m_enableeph = dialog.m_ephCheck->GetValue();
++		wxGetApp().m_enablebypass = dialog.m_enablebypassCheck->GetValue();
++		wxGetApp().m_enablereset = dialog.m_enableresetCheck->GetValue();
++		wxGetApp().m_enablerestart = dialog.m_enablerestartCheck->GetValue();
++		wxGetApp().m_enablevsc = dialog.m_enablevscCheck->GetValue();
++		wxGetApp().m_enableerterm = dialog.m_enableertermCheck->GetValue();
++		wxGetApp().m_enablesegmark = dialog.m_enablesegmarkCheck->GetValue();
+ 		wxGetApp().m_enableidx = dialog.m_enableidxCheck->GetValue();
+ 		wxGetApp().m_index = dialog.m_indexCtrl->GetValue();
+ 		wxGetApp().m_enablecomm = dialog.m_enablecommCheck->GetValue();
+ 		wxGetApp().m_comment = dialog.m_commentCtrl->GetValue();
++		wxGetApp().m_enablepoc = dialog.m_enablepocCheck->GetValue();
++		wxGetApp().m_poc = dialog.m_pocCtrl->GetValue();
++#ifdef USE_JPWL
++		wxGetApp().m_enablejpwle = dialog.m_enablejpwlCheck->GetValue();
++		for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
++			wxGetApp().m_hprotsel[n] = dialog.m_hprotChoice[n]->GetSelection();
++			wxGetApp().m_htileval[n] = dialog.m_htileCtrl[n]->GetValue();
++			wxGetApp().m_pprotsel[n] = dialog.m_pprotChoice[n]->GetSelection();
++			wxGetApp().m_ptileval[n] = dialog.m_ptileCtrl[n]->GetValue();
++			wxGetApp().m_ppackval[n] = dialog.m_ppackCtrl[n]->GetValue();
++			wxGetApp().m_sensisel[n] = dialog.m_sensiChoice[n]->GetSelection();
++			wxGetApp().m_stileval[n] = dialog.m_stileCtrl[n]->GetValue();
++		}
++#endif // USE_JPWL
+ 	};
+ }
+ 
+@@ -850,7 +1014,6 @@
+ 	if (--wxGetApp().m_framenum < 0)
+ 		wxGetApp().m_framenum = 0;
+ 
+-	//wxLogMessage(wxT("================Go prev, dude!======================="));
+ 	wxCommandEvent e;
+ 	OnReload(e);
+ }
+@@ -859,8 +1022,6 @@
+ {
+ 	wxGetApp().m_framenum = 0;
+ 
+-	//wxLogMessage(wxT("================Go home, dude!======================="));
+-
+ 	wxCommandEvent e;
+ 	OnReload(e);
+ }
+@@ -869,66 +1030,83 @@
+ {
+ 	++wxGetApp().m_framenum;
+ 
+-	//wxLogMessage(wxT("================Go next, dude!======================="));
+ 	wxCommandEvent e;
+ 	OnReload(e);
+ }
+ 
+-// about window for the frame
+-void OPJFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
++void OPJFrame::OnLessLayers(wxCommandEvent& event)
+ {
+-#ifdef OPJ_HTMLABOUT
+-#include "about_htm.h"
+-#include "opj_logo.xpm"
++	if (--wxGetApp().m_qualitylayers < 1)
++		wxGetApp().m_qualitylayers = 1;
+ 
+-    wxBoxSizer *topsizer;
+-    wxHtmlWindow *html;
+-    wxDialog dlg(this, wxID_ANY, wxString(_("About")));
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-    wxMemoryFSHandler::AddFile(wxT("opj_logo.xpm"), wxBitmap(opj_logo), wxBITMAP_TYPE_XPM);
++void OPJFrame::OnAllLayers(wxCommandEvent& event)
++{
++	wxGetApp().m_qualitylayers = 0;
+ 
+-    topsizer = new wxBoxSizer(wxVERTICAL);
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-    html = new wxHtmlWindow(&dlg, wxID_ANY, wxDefaultPosition, wxSize(320, 250), wxHW_SCROLLBAR_NEVER);
+-    html->SetBorders(0);
+-    //html->LoadPage(wxT("about/about.htm"));
+-	//html->SetPage("<html><body>Hello, world!</body></html>");
+-	html->SetPage(htmlaboutpage);
+-    html->SetSize(html->GetInternalRepresentation()->GetWidth(),
+-                    html->GetInternalRepresentation()->GetHeight());
++void OPJFrame::OnMoreLayers(wxCommandEvent& event)
++{
++	++wxGetApp().m_qualitylayers;
+ 
+-    topsizer->Add(html, 1, wxALL, 10);
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-    topsizer->Add(new wxStaticLine(&dlg, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 10);
++void OPJFrame::OnLessRes(wxCommandEvent& event)
++{
++	++wxGetApp().m_reducefactor;
+ 
+-    wxButton *bu1 = new wxButton(&dlg, wxID_OK, wxT("OK"));
+-    bu1->SetDefault();
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-    topsizer->Add(bu1, 0, wxALL | wxALIGN_RIGHT, 15);
++void OPJFrame::OnFullRes(wxCommandEvent& event)
++{
++	wxGetApp().m_reducefactor = 0;
+ 
+-    dlg.SetSizer(topsizer);
+-    topsizer->Fit(&dlg);
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-    dlg.ShowModal();
++void OPJFrame::OnMoreRes(wxCommandEvent& event)
++{
++	if (--wxGetApp().m_reducefactor < 0)
++		wxGetApp().m_reducefactor = 0;
+ 
+-#else
++	wxCommandEvent e;
++	OnReload(e);
++}
+ 
+-	wxMessageBox(wxString::Format(OPJ_APPLICATION_TITLEBAR
+-								  wxT("\n\n")
+-								  wxT("Built with %s and OpenJPEG ")
+-								  wxT(OPENJPEG_VERSION)
+-								  wxT("\non ") wxT(__DATE__) wxT(", ") wxT(__TIME__)
+-								  wxT("\nRunning under %s\n\n")
+-								  OPJ_APPLICATION_COPYRIGHT,
+-								  wxVERSION_STRING,
+-								  wxGetOsDescription().c_str()),
+-				 wxT("About ") OPJ_APPLICATION_NAME,
+-				 wxOK | wxICON_INFORMATION,
+-				 this
+-				 );
++void OPJFrame::OnPrevComp(wxCommandEvent& event)
++{
++	if (--wxGetApp().m_components < 1)
++		wxGetApp().m_components = 1;
+ 
+-#endif
++	wxCommandEvent e;
++	OnReload(e);
++}
++
++void OPJFrame::OnAllComps(wxCommandEvent& event)
++{
++	wxGetApp().m_components = 0;
++
++	wxCommandEvent e;
++	OnReload(e);
++}
++
++void OPJFrame::OnNextComp(wxCommandEvent& event)
++{
++	++wxGetApp().m_components;
+ 
++	wxCommandEvent e;
++	OnReload(e);
+ }
+ 
+ void OPJFrame::OnToggleBrowser(wxCommandEvent& WXUNUSED(event))
+@@ -1102,6 +1280,9 @@
+ #if wxUSE_LIBOPENJPEG
+ 	wxT("JPEG 2000 files (*.jp2,*.j2k,*.j2c,*.mj2)|*.jp2;*.j2k;*.j2c;*.mj2")
+ #endif
++#if USE_MXF
++	wxT("|MXF JPEG 2000 video (*.mxf)|*.mxf")
++#endif // USE_MXF
+ #if wxUSE_LIBJPEG
+ 		wxT("|JPEG files (*.jpg)|*.jpg")
+ #endif
+@@ -1159,6 +1340,9 @@
+ 
+ void OPJFrame::OnMemoryOpen(wxCommandEvent& WXUNUSED(event))
+ {
++	// do nothing
++	return;
++	
+ 	wxTextEntryDialog dialog(this, wxT("Memory HEX address range: start_address-stop_address"),
+ 							wxT("Decode a memory buffer"),
+ 							wxT("0x-0x"),
+@@ -1245,7 +1429,11 @@
+ 	} else {
+ 		dc.SetFont(*wxSWISS_FONT);
+ 		dc.SetPen(*wxBLACK_PEN);
++#ifdef __WXGTK__
++		dc.DrawText(_T("Decoding image, please wait... (press \"Zoom to Fit\" to show the image)"), 40, 50);
++#else
+ 		dc.DrawText(_T("Decoding image, please wait..."), 40, 50);
++#endif
+ 	}
+ }
+ 
+@@ -1371,2218 +1559,22 @@
+ 	//wxLogMessage(wxT("Lost focus: %d (%x)"), m_winnumber, event.GetWindow());
+ }
+ 
+-#if USE_GENERIC_TREECTRL
+-BEGIN_EVENT_TABLE(OPJMarkerTree, wxGenericTreeCtrl)
+-#else
+-BEGIN_EVENT_TABLE(OPJMarkerTree, wxTreeCtrl)
+-#endif
+-    /*EVT_TREE_BEGIN_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginDrag)
+-    EVT_TREE_BEGIN_RDRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginRDrag)
+-    EVT_TREE_END_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnEndDrag)*/
+-    /*EVT_TREE_BEGIN_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnBeginLabelEdit)
+-    EVT_TREE_END_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnEndLabelEdit)*/
+-    /*EVT_TREE_DELETE_ITEM(TreeTest_Ctrl, OPJMarkerTree::OnDeleteItem)*/
+-#if 0       // there are so many of those that logging them causes flicker
+-    /*EVT_TREE_GET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnGetInfo)*/
+-#endif
+-    /*EVT_TREE_SET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnSetInfo)
+-    EVT_TREE_ITEM_EXPANDED(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanded)*/
+-    EVT_TREE_ITEM_EXPANDING(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanding)
+-    /*EVT_TREE_ITEM_COLLAPSED(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsed)
+-    EVT_TREE_ITEM_COLLAPSING(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsing)*/
+-
+-    EVT_TREE_SEL_CHANGED(TreeTest_Ctrl, OPJMarkerTree::OnSelChanged)
+-    /*EVT_TREE_SEL_CHANGING(TreeTest_Ctrl, OPJMarkerTree::OnSelChanging)*/
+-    /*EVT_TREE_KEY_DOWN(TreeTest_Ctrl, OPJMarkerTree::OnTreeKeyDown)*/
+-    /*EVT_TREE_ITEM_ACTIVATED(TreeTest_Ctrl, OPJMarkerTree::OnItemActivated)*/
+-
+-    // so many differents ways to handle right mouse button clicks...
+-    /*EVT_CONTEXT_MENU(OPJMarkerTree::OnContextMenu)*/
+-    // EVT_TREE_ITEM_MENU is the preferred event for creating context menus
+-    // on a tree control, because it includes the point of the click or item,
+-    // meaning that no additional placement calculations are required.
+-    EVT_TREE_ITEM_MENU(TreeTest_Ctrl, OPJMarkerTree::OnItemMenu)
+-    /*EVT_TREE_ITEM_RIGHT_CLICK(TreeTest_Ctrl, OPJMarkerTree::OnItemRClick)*/
+-
+-    /*EVT_RIGHT_DOWN(OPJMarkerTree::OnRMouseDown)
+-    EVT_RIGHT_UP(OPJMarkerTree::OnRMouseUp)
+-    EVT_RIGHT_DCLICK(OPJMarkerTree::OnRMouseDClick)*/
+-END_EVENT_TABLE()
+-
+-// OPJMarkerTree implementation
+-#if USE_GENERIC_TREECTRL
+-IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxGenericTreeCtrl)
+-#else
+-IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxTreeCtrl)
+-#endif
+-
+-OPJMarkerTree::OPJMarkerTree(wxWindow *parent, OPJChildFrame *subframe, wxFileName fname, wxString name, const wxWindowID id,
+-           const wxPoint& pos, const wxSize& size, long style)
+-          : wxTreeCtrl(parent, id, pos, size, style)
+-{
+-    m_reverseSort = false;
+-	m_fname = fname;
+-
+-	m_peektextCtrl = ((OPJFrame *) (parent->GetParent()->GetParent()))->m_textCtrlbrowse;
+-    CreateImageList();
+-
+-    // Add some items to the tree
+-    //AddTestItemsToTree(5, 5);
+-    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
+-    wxTreeItemId rootId = AddRoot(name,
+-                                  image, image,
+-                                  new OPJMarkerData(name));
+-
+-    OPJParseThread *pthread = CreateParseThread(0x00, subframe);
+-    if (pthread->Run() != wxTHREAD_NO_ERROR)
+-        wxLogMessage(wxT("Can't start parse thread!"));
+-    else
+-		wxLogMessage(wxT("New parse thread started."));
+-
+-	m_childframe = subframe;
+-}
+-
+-void OPJMarkerTree::CreateImageList(int size)
+-{
+-    if (size == -1) {
+-        SetImageList(NULL);
+-        return;
+-    }
+-    if (size == 0)
+-        size = m_imageSize;
+-    else
+-        m_imageSize = size;
+-
+-    // Make an image list containing small icons
+-    wxImageList *images = new wxImageList(size, size, true);
+-
+-    // should correspond to TreeCtrlIcon_xxx enum
+-    wxBusyCursor wait;
+-    wxIcon icons[5];
+-    icons[0] = wxIcon(icon1_xpm);
+-    icons[1] = wxIcon(icon2_xpm);
+-    icons[2] = wxIcon(icon3_xpm);
+-    icons[3] = wxIcon(icon4_xpm);
+-    icons[4] = wxIcon(icon5_xpm);
+-
+-    int sizeOrig = icons[0].GetWidth();
+-    for (size_t i = 0; i < WXSIZEOF(icons); i++) {
+-        if (size == sizeOrig) {
+-            images->Add(icons[i]);
+-        } else {
+-            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
+-        }
+-    }
+-
+-    AssignImageList(images);
+-}
+-
+-#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
+-void OPJMarkerTree::CreateButtonsImageList(int size)
+-{
+-    if ( size == -1 ) {
+-        SetButtonsImageList(NULL);
+-        return;
+-    }
+-
+-    // Make an image list containing small icons
+-    wxImageList *images = new wxImageList(size, size, true);
+-
+-    // should correspond to TreeCtrlIcon_xxx enum
+-    wxBusyCursor wait;
+-    wxIcon icons[4];
+-    icons[0] = wxIcon(icon3_xpm);   // closed
+-    icons[1] = wxIcon(icon3_xpm);   // closed, selected
+-    icons[2] = wxIcon(icon5_xpm);   // open
+-    icons[3] = wxIcon(icon5_xpm);   // open, selected
+-
+-    for ( size_t i = 0; i < WXSIZEOF(icons); i++ ) {
+-        int sizeOrig = icons[i].GetWidth();
+-        if ( size == sizeOrig ) {
+-            images->Add(icons[i]);
+-        } else {
+-            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
+-        }
+-    }
+-
+-    AssignButtonsImageList(images);
+-#else
+-void OPJMarkerTree::CreateButtonsImageList(int WXUNUSED(size))
+-{
+-#endif
+-}
+-
+-void OPJParseThread::LoadFile(wxFileName fname)
+-{
+-	wxTreeItemId rootid;
+-
+-	// this is the root node
+-	int image = wxGetApp().ShowImages() ? m_tree->TreeCtrlIcon_Folder : -1;
+-
+-	if (this->m_parentid) {
+-		// leaf of a tree
+-		rootid = m_parentid;
+-		m_tree->SetItemText(rootid, wxT("Parsing..."));
+-
+-	} else {
+-
+-		// delete the existing tree hierarchy
+-		m_tree->DeleteAllItems();
+-
+-		// new tree
+-		rootid = m_tree->AddRoot(wxT("Parsing..."),
+-			image,
+-			image,
+-			new OPJMarkerData(fname.GetFullPath())
+-			);
+-		//m_tree->SetItemFont(rootid, *wxITALIC_FONT);
+-		m_tree->SetItemBold(rootid);
+-	}
+-
+-	// open the file
+-	wxFile m_file(fname.GetFullPath().c_str(), wxFile::read);
+-
+-	// parsing enabled?
+-	if (wxGetApp().m_enableparse) {
+-
+-		// what is the extension?
+-		if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
+-
+-			// parse the file
+-			ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
+-
+-		} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
+-
+-			// parse the file
+-			if (this->m_parentid) {
+-				//WriteText(wxT("Only a subsection of jp2"));
+-				OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
+-				ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
+-				m_tree->Expand(rootid);
+-
+-			} else {
+-				// as usual
+-				ParseJP2File(&m_file, 0, m_file.Length(), rootid);
+-			}
+-
+-		} else {
+-
+-			// unknown extension
+-			WriteText(wxT("Unknown file format!"));
+-
+-		}
+-
+-	}
+-
+-
+-	// this is the root node
+-	if (this->m_parentid)
+-		m_tree->SetItemText(rootid, wxT("Codestream"));
+-	else
+-		//m_tree->SetItemText(rootid, wxString::Format(wxT("%s (%d B)"), fname.GetFullName(), m_file.Length()));
+-		m_tree->SetItemText(rootid, fname.GetFullName());
+-
+-	// close the file
+-	m_file.Close();
+-
+-	WriteText(wxT("Parsing finished!"));
+-}
+-
+-/*int OPJMarkerTree::OnCompareItems(const wxTreeItemId& item1,
+-                               const wxTreeItemId& item2)
+-{
+-    if ( m_reverseSort )
+-    {
+-        // just exchange 1st and 2nd items
+-        return wxTreeCtrl::OnCompareItems(item2, item1);
+-    }
+-    else
+-    {
+-        return wxTreeCtrl::OnCompareItems(item1, item2);
+-    }
+-}*/
+-
+-/*void OPJMarkerTree::AddItemsRecursively(const wxTreeItemId& idParent,
+-                                     size_t numChildren,
+-                                     size_t depth,
+-                                     size_t folder)
+-{
+-    if ( depth > 0 )
+-    {
+-        bool hasChildren = depth > 1;
+-
+-        wxString str;
+-        for ( size_t n = 0; n < numChildren; n++ )
+-        {
+-            // at depth 1 elements won't have any more children
+-            if ( hasChildren )
+-                str.Printf(wxT("%s child %u"), wxT("Folder"), unsigned(n + 1));
+-            else
+-                str.Printf(wxT("%s child %u.%u"), wxT("File"), unsigned(folder), unsigned(n + 1));
+-
+-            // here we pass to AppendItem() normal and selected item images (we
+-            // suppose that selected image follows the normal one in the enum)
+-            int image, imageSel;
+-            if ( wxGetApp().ShowImages() )
+-            {
+-                image = depth == 1 ? TreeCtrlIcon_File : TreeCtrlIcon_Folder;
+-                imageSel = image + 1;
+-            }
+-            else
+-            {
+-                image = imageSel = -1;
+-            }
+-            wxTreeItemId id = AppendItem(idParent, str, image, imageSel,
+-                                         new OPJMarkerData(str));
+-
+-            // and now we also set the expanded one (only for the folders)
+-            if ( hasChildren && wxGetApp().ShowImages() )
+-            {
+-                SetItemImage(id, TreeCtrlIcon_FolderOpened,
+-                             wxTreeItemIcon_Expanded);
+-            }
+-
+-            // remember the last child for OnEnsureVisible()
+-            if ( !hasChildren && n == numChildren - 1 )
+-            {
+-                m_lastItem = id;
+-            }
+-
+-            AddItemsRecursively(id, numChildren, depth - 1, n + 1);
+-        }
+-    }
+-    //else: done!
+-}*/
+-
+-/*void OPJMarkerTree::AddTestItemsToTree(size_t numChildren,
+-                                    size_t depth)
+-{
+-    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
+-    wxTreeItemId rootId = AddRoot(wxT("Root"),
+-                                  image, image,
+-                                  new OPJMarkerData(wxT("Root item")));
+-    if ( image != -1 )
+-    {
+-        SetItemImage(rootId, TreeCtrlIcon_FolderOpened, wxTreeItemIcon_Expanded);
+-    }
+-
+-    AddItemsRecursively(rootId, numChildren, depth, 0);
+-
+-    // set some colours/fonts for testing
+-    SetItemFont(rootId, *wxITALIC_FONT);
+-
+-    wxTreeItemIdValue cookie;
+-    wxTreeItemId id = GetFirstChild(rootId, cookie);
+-    SetItemTextColour(id, *wxBLUE);
+-
+-    id = GetNextChild(rootId, cookie);
+-    id = GetNextChild(rootId, cookie);
+-    SetItemTextColour(id, *wxRED);
+-    SetItemBackgroundColour(id, *wxLIGHT_GREY);
+-}*/
+-
+-/*void OPJMarkerTree::GetItemsRecursively(const wxTreeItemId& idParent,
+-                                     wxTreeItemIdValue cookie)
+-{
+-    wxTreeItemId id;
+-
+-    if ( !cookie )
+-        id = GetFirstChild(idParent, cookie);
+-    else
+-        id = GetNextChild(idParent, cookie);
+-
+-    if ( !id.IsOk() )
+-        return;
+-
+-    wxString text = GetItemText(id);
+-    wxLogMessage(text);
+-
+-    if (ItemHasChildren(id))
+-        GetItemsRecursively(id);
+-
+-    GetItemsRecursively(idParent, cookie);
+-}*/
+-
+-/*void OPJMarkerTree::DoToggleIcon(const wxTreeItemId& item)
+-{
+-    int image = (GetItemImage(item) == TreeCtrlIcon_Folder)
+-                    ? TreeCtrlIcon_File
+-                    : TreeCtrlIcon_Folder;
+-    SetItemImage(item, image, wxTreeItemIcon_Normal);
+-
+-    image = (GetItemImage(item) == TreeCtrlIcon_FolderSelected)
+-                    ? TreeCtrlIcon_FileSelected
+-                    : TreeCtrlIcon_FolderSelected;
+-    SetItemImage(item, image, wxTreeItemIcon_Selected);
+-}*/
+-
+-void OPJMarkerTree::LogEvent(const wxChar *name, const wxTreeEvent& event)
+-{
+-    wxTreeItemId item = event.GetItem();
+-    wxString text;
+-    if ( item.IsOk() )
+-        text << wxT('"') << GetItemText(item).c_str() << wxT('"');
+-    else
+-        text = wxT("invalid item");
+-    wxLogMessage(wxT("%s(%s)"), name, text.c_str());
+-}
+-
+-OPJParseThread *OPJMarkerTree::CreateParseThread(wxTreeItemId parentid, OPJChildFrame *subframe)
+-{
+-    OPJParseThread *pthread = new OPJParseThread(this, parentid);
+-
+-    if (pthread->Create() != wxTHREAD_NO_ERROR)
+-		wxLogError(wxT("Can't create parse thread!"));
+-
+-    wxCriticalSectionLocker enter(wxGetApp().m_parse_critsect);
+-    wxGetApp().m_parse_threads.Add(pthread);
+-
+-    return pthread;
+-}
+-
+-
+-/*// avoid repetition
+-#define TREE_EVENT_HANDLER(name)                                 \
+-void OPJMarkerTree::name(wxTreeEvent& event)                        \
+-{                                                                \
+-    LogEvent(_T(#name), event);                                  \
+-    SetLastItem(wxTreeItemId());                                 \
+-    event.Skip();                                                \
+-}*/
+-
+-/*TREE_EVENT_HANDLER(OnBeginRDrag)*/
+-/*TREE_EVENT_HANDLER(OnDeleteItem)*/
+-/*TREE_EVENT_HANDLER(OnGetInfo)
+-TREE_EVENT_HANDLER(OnSetInfo)*/
+-/*TREE_EVENT_HANDLER(OnItemExpanded)
+-TREE_EVENT_HANDLER(OnItemExpanding)*/
+-/*TREE_EVENT_HANDLER(OnItemCollapsed)*/
+-/*TREE_EVENT_HANDLER(OnSelChanged)
+-TREE_EVENT_HANDLER(OnSelChanging)*/
+-
+-/*#undef TREE_EVENT_HANDLER*/
+-
+-void OPJMarkerTree::OnItemExpanding(wxTreeEvent& event)
+-{
+-	wxTreeItemId item = event.GetItem();
+-	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
+-	wxString text;
+-
+-	if (item.IsOk())
+-		text << wxT('"') << GetItemText(item).c_str() << wxT('"');
+-	else
+-		text = wxT("invalid item");
+-
+-	if (wxStrcmp(data->GetDesc1(), wxT("INFO-CSTREAM")))
+-		return;
+-
+-	wxLogMessage(wxT("Expanding... (%s -> %s, %s, %d, %d)"),
+-		text.c_str(), data->GetDesc1(), data->GetDesc2(),
+-		data->m_start, data->m_length);
+-
+-	// the codestream box is being asked for expansion
+-	wxTreeItemIdValue cookie;
+-	if (!GetFirstChild(item, cookie).IsOk()) {
+-		OPJParseThread *pthread = CreateParseThread(item);
+-		if (pthread->Run() != wxTHREAD_NO_ERROR)
+-			wxLogMessage(wxT("Can't start parse thread!"));
+-		else
+-			wxLogMessage(wxT("New parse thread started."));
+-	}
+-}
+-
+-void OPJMarkerTree::OnSelChanged(wxTreeEvent& event)
+-{
+-#define BUNCH_LINESIZE	16
+-#define BUNCH_NUMLINES	7
+-
+-	wxTreeItemId item = event.GetItem();
+-	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
+-	wxString text;
+-	int l, c, pos = 0, pre_pos;
+-	unsigned char buffer[BUNCH_LINESIZE * BUNCH_NUMLINES];
+-
+-	m_peektextCtrl->Clear();
+-
+-	/*text << wxString::Format(wxT("Selected... (%s -> %s, %s, %d, %d)"),
+-		text.c_str(), data->GetDesc1(), data->GetDesc2(),
+-		data->m_start, data->m_length) << wxT("\n");*/
+-
+-	// open the file and browse a little
+-	wxFile *fp = new wxFile(m_fname.GetFullPath().c_str(), wxFile::read);
+-
+-	// go to position claimed
+-	fp->Seek(data->m_start, wxFromStart);
+-
+-	// read a bunch
+-	int max_read = wxMin(wxFileOffset(WXSIZEOF(buffer)), data->m_length - data->m_start + 1);
+-	fp->Read(buffer, max_read);
+-
+-	// write the file data between start and stop
+-	pos = 0;
+-	for (l = 0; l < BUNCH_NUMLINES; l++) {
+-
+-		text << wxString::Format(wxT("%010d:"), data->m_start + pos);
+ 
+-		pre_pos = pos;
++////////////////////////////////
++// drag and drop 
++////////////////////////////////
+ 
+-		// add hex browsing text
+-		for (c = 0; c < BUNCH_LINESIZE; c++) {
+-
+-			if (!(c % 8))
+-				text << wxT(" ");
+-
+-			if (pos < max_read) {
+-				text << wxString::Format(wxT("%02X "), buffer[pos]);
+-			} else
+-				text << wxT("   ");
+-			pos++;
+-		}
+-
+-		text << wxT("    ");
+-
+-		// add char browsing text
+-		for (c = 0; c < BUNCH_LINESIZE; c++) {
+-
+-			if (pre_pos < max_read) {
+-				if ((buffer[pre_pos] == '\n') ||
+-					(buffer[pre_pos] == '\t') ||
+-					(buffer[pre_pos] == '\0') ||
+-					(buffer[pre_pos] == 0x0D) ||
+-					(buffer[pre_pos] == 0x0B))
+-					buffer[pre_pos] = ' ';
+-				text << wxString::Format(wxT("%c."), wxChar(buffer[pre_pos]));
+-			} else
+-				text << wxT("  ");
+-			pre_pos++;
+-		}
+-
+-		text << wxT("\n");
+-
+-	}
+-
+-	// close the file
+-	fp->Close();
+-
+-	m_peektextCtrl->WriteText(text);
+-}
+-
+-/*void LogKeyEvent(const wxChar *name, const wxKeyEvent& event)
++bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
+ {
+-    wxString key;
+-    long keycode = event.GetKeyCode();
+-    {
+-        switch ( keycode )
+-        {
+-            case WXK_BACK: key = wxT("BACK"); break;
+-            case WXK_TAB: key = wxT("TAB"); break;
+-            case WXK_RETURN: key = wxT("RETURN"); break;
+-            case WXK_ESCAPE: key = wxT("ESCAPE"); break;
+-            case WXK_SPACE: key = wxT("SPACE"); break;
+-            case WXK_DELETE: key = wxT("DELETE"); break;
+-            case WXK_START: key = wxT("START"); break;
+-            case WXK_LBUTTON: key = wxT("LBUTTON"); break;
+-            case WXK_RBUTTON: key = wxT("RBUTTON"); break;
+-            case WXK_CANCEL: key = wxT("CANCEL"); break;
+-            case WXK_MBUTTON: key = wxT("MBUTTON"); break;
+-            case WXK_CLEAR: key = wxT("CLEAR"); break;
+-            case WXK_SHIFT: key = wxT("SHIFT"); break;
+-            case WXK_ALT: key = wxT("ALT"); break;
+-            case WXK_CONTROL: key = wxT("CONTROL"); break;
+-            case WXK_MENU: key = wxT("MENU"); break;
+-            case WXK_PAUSE: key = wxT("PAUSE"); break;
+-            case WXK_CAPITAL: key = wxT("CAPITAL"); break;
+-            case WXK_END: key = wxT("END"); break;
+-            case WXK_HOME: key = wxT("HOME"); break;
+-            case WXK_LEFT: key = wxT("LEFT"); break;
+-            case WXK_UP: key = wxT("UP"); break;
+-            case WXK_RIGHT: key = wxT("RIGHT"); break;
+-            case WXK_DOWN: key = wxT("DOWN"); break;
+-            case WXK_SELECT: key = wxT("SELECT"); break;
+-            case WXK_PRINT: key = wxT("PRINT"); break;
+-            case WXK_EXECUTE: key = wxT("EXECUTE"); break;
+-            case WXK_SNAPSHOT: key = wxT("SNAPSHOT"); break;
+-            case WXK_INSERT: key = wxT("INSERT"); break;
+-            case WXK_HELP: key = wxT("HELP"); break;
+-            case WXK_NUMPAD0: key = wxT("NUMPAD0"); break;
+-            case WXK_NUMPAD1: key = wxT("NUMPAD1"); break;
+-            case WXK_NUMPAD2: key = wxT("NUMPAD2"); break;
+-            case WXK_NUMPAD3: key = wxT("NUMPAD3"); break;
+-            case WXK_NUMPAD4: key = wxT("NUMPAD4"); break;
+-            case WXK_NUMPAD5: key = wxT("NUMPAD5"); break;
+-            case WXK_NUMPAD6: key = wxT("NUMPAD6"); break;
+-            case WXK_NUMPAD7: key = wxT("NUMPAD7"); break;
+-            case WXK_NUMPAD8: key = wxT("NUMPAD8"); break;
+-            case WXK_NUMPAD9: key = wxT("NUMPAD9"); break;
+-            case WXK_MULTIPLY: key = wxT("MULTIPLY"); break;
+-            case WXK_ADD: key = wxT("ADD"); break;
+-            case WXK_SEPARATOR: key = wxT("SEPARATOR"); break;
+-            case WXK_SUBTRACT: key = wxT("SUBTRACT"); break;
+-            case WXK_DECIMAL: key = wxT("DECIMAL"); break;
+-            case WXK_DIVIDE: key = wxT("DIVIDE"); break;
+-            case WXK_F1: key = wxT("F1"); break;
+-            case WXK_F2: key = wxT("F2"); break;
+-            case WXK_F3: key = wxT("F3"); break;
+-            case WXK_F4: key = wxT("F4"); break;
+-            case WXK_F5: key = wxT("F5"); break;
+-            case WXK_F6: key = wxT("F6"); break;
+-            case WXK_F7: key = wxT("F7"); break;
+-            case WXK_F8: key = wxT("F8"); break;
+-            case WXK_F9: key = wxT("F9"); break;
+-            case WXK_F10: key = wxT("F10"); break;
+-            case WXK_F11: key = wxT("F11"); break;
+-            case WXK_F12: key = wxT("F12"); break;
+-            case WXK_F13: key = wxT("F13"); break;
+-            case WXK_F14: key = wxT("F14"); break;
+-            case WXK_F15: key = wxT("F15"); break;
+-            case WXK_F16: key = wxT("F16"); break;
+-            case WXK_F17: key = wxT("F17"); break;
+-            case WXK_F18: key = wxT("F18"); break;
+-            case WXK_F19: key = wxT("F19"); break;
+-            case WXK_F20: key = wxT("F20"); break;
+-            case WXK_F21: key = wxT("F21"); break;
+-            case WXK_F22: key = wxT("F22"); break;
+-            case WXK_F23: key = wxT("F23"); break;
+-            case WXK_F24: key = wxT("F24"); break;
+-            case WXK_NUMLOCK: key = wxT("NUMLOCK"); break;
+-            case WXK_SCROLL: key = wxT("SCROLL"); break;
+-            case WXK_PAGEUP: key = wxT("PAGEUP"); break;
+-            case WXK_PAGEDOWN: key = wxT("PAGEDOWN"); break;
+-            case WXK_NUMPAD_SPACE: key = wxT("NUMPAD_SPACE"); break;
+-            case WXK_NUMPAD_TAB: key = wxT("NUMPAD_TAB"); break;
+-            case WXK_NUMPAD_ENTER: key = wxT("NUMPAD_ENTER"); break;
+-            case WXK_NUMPAD_F1: key = wxT("NUMPAD_F1"); break;
+-            case WXK_NUMPAD_F2: key = wxT("NUMPAD_F2"); break;
+-            case WXK_NUMPAD_F3: key = wxT("NUMPAD_F3"); break;
+-            case WXK_NUMPAD_F4: key = wxT("NUMPAD_F4"); break;
+-            case WXK_NUMPAD_HOME: key = wxT("NUMPAD_HOME"); break;
+-            case WXK_NUMPAD_LEFT: key = wxT("NUMPAD_LEFT"); break;
+-            case WXK_NUMPAD_UP: key = wxT("NUMPAD_UP"); break;
+-            case WXK_NUMPAD_RIGHT: key = wxT("NUMPAD_RIGHT"); break;
+-            case WXK_NUMPAD_DOWN: key = wxT("NUMPAD_DOWN"); break;
+-            case WXK_NUMPAD_PAGEUP: key = wxT("NUMPAD_PAGEUP"); break;
+-            case WXK_NUMPAD_PAGEDOWN: key = wxT("NUMPAD_PAGEDOWN"); break;
+-            case WXK_NUMPAD_END: key = wxT("NUMPAD_END"); break;
+-            case WXK_NUMPAD_BEGIN: key = wxT("NUMPAD_BEGIN"); break;
+-            case WXK_NUMPAD_INSERT: key = wxT("NUMPAD_INSERT"); break;
+-            case WXK_NUMPAD_DELETE: key = wxT("NUMPAD_DELETE"); break;
+-            case WXK_NUMPAD_EQUAL: key = wxT("NUMPAD_EQUAL"); break;
+-            case WXK_NUMPAD_MULTIPLY: key = wxT("NUMPAD_MULTIPLY"); break;
+-            case WXK_NUMPAD_ADD: key = wxT("NUMPAD_ADD"); break;
+-            case WXK_NUMPAD_SEPARATOR: key = wxT("NUMPAD_SEPARATOR"); break;
+-            case WXK_NUMPAD_SUBTRACT: key = wxT("NUMPAD_SUBTRACT"); break;
+-            case WXK_NUMPAD_DECIMAL: key = wxT("NUMPAD_DECIMAL"); break;
+-
+-            default:
+-            {
+-               if ( keycode < 128 && wxIsprint((int)keycode) )
+-                   key.Printf(wxT("'%c'"), (char)keycode);
+-               else if ( keycode > 0 && keycode < 27 )
+-                   key.Printf(_("Ctrl-%c"), wxT('A') + keycode - 1);
+-               else
+-                   key.Printf(wxT("unknown (%ld)"), keycode);
+-            }
+-        }
++    /*size_t nFiles = filenames.GetCount();
++    wxString str;
++    str.Printf( _T("%d files dropped\n"), (int)nFiles);
++    for ( size_t n = 0; n < nFiles; n++ ) {
++        str << filenames[n] << wxT("\n");
+     }
++    wxLogMessage(str);*/
++	m_pOwner->OpenFiles(filenames, filenames);
+ 
+-    wxLogMessage(wxT("%s event: %s (flags = %c%c%c%c)"),
+-                  name,
+-                  key.c_str(),
+-                  event.ControlDown() ? wxT('C') : wxT('-'),
+-                  event.AltDown() ? wxT('A') : wxT('-'),
+-                  event.ShiftDown() ? wxT('S') : wxT('-'),
+-                  event.MetaDown() ? wxT('M') : wxT('-'));
+-}
+-
+-void OPJMarkerTree::OnTreeKeyDown(wxTreeEvent& event)
+-{
+-    LogKeyEvent(wxT("Tree key down "), event.GetKeyEvent());
+-
+-    event.Skip();
+-}*/
+-
+-/*void OPJMarkerTree::OnBeginDrag(wxTreeEvent& event)
+-{
+-    // need to explicitly allow drag
+-    if ( event.GetItem() != GetRootItem() )
+-    {
+-        m_draggedItem = event.GetItem();
+-
+-        wxLogMessage(wxT("OnBeginDrag: started dragging %s"),
+-                     GetItemText(m_draggedItem).c_str());
+-
+-        event.Allow();
+-    }
+-    else
+-    {
+-        wxLogMessage(wxT("OnBeginDrag: this item can't be dragged."));
+-    }
++    return true;
+ }
+ 
+-void OPJMarkerTree::OnEndDrag(wxTreeEvent& event)
+-{
+-    wxTreeItemId itemSrc = m_draggedItem,
+-                 itemDst = event.GetItem();
+-    m_draggedItem = (wxTreeItemId)0l;
+-
+-    // where to copy the item?
+-    if ( itemDst.IsOk() && !ItemHasChildren(itemDst) )
+-    {
+-        // copy to the parent then
+-        itemDst = GetItemParent(itemDst);
+-    }
+-
+-    if ( !itemDst.IsOk() )
+-    {
+-        wxLogMessage(wxT("OnEndDrag: can't drop here."));
+-
+-        return;
+-    }
+-
+-    wxString text = GetItemText(itemSrc);
+-    wxLogMessage(wxT("OnEndDrag: '%s' copied to '%s'."),
+-                 text.c_str(), GetItemText(itemDst).c_str());
+-
+-    // just do append here - we could also insert it just before/after the item
+-    // on which it was dropped, but this requires slightly more work... we also
+-    // completely ignore the client data and icon of the old item but could
+-    // copy them as well.
+-    //
+-    // Finally, we only copy one item here but we might copy the entire tree if
+-    // we were dragging a folder.
+-    int image = wxGetApp().ShowImages() ? TreeCtrlIcon_File : -1;
+-    AppendItem(itemDst, text, image);
+-}*/
+-
+-/*void OPJMarkerTree::OnBeginLabelEdit(wxTreeEvent& event)
+-{
+-    wxLogMessage(wxT("OnBeginLabelEdit"));
+-
+-    // for testing, prevent this item's label editing
+-    wxTreeItemId itemId = event.GetItem();
+-    if ( IsTestItem(itemId) )
+-    {
+-        wxMessageBox(wxT("You can't edit this item."));
+-
+-        event.Veto();
+-    }
+-    else if ( itemId == GetRootItem() )
+-    {
+-        // test that it is possible to change the text of the item being edited
+-        SetItemText(itemId, _T("Editing root item"));
+-    }
+-}
+-
+-void OPJMarkerTree::OnEndLabelEdit(wxTreeEvent& event)
+-{
+-    wxLogMessage(wxT("OnEndLabelEdit"));
+-
+-    // don't allow anything except letters in the labels
+-    if ( !event.GetLabel().IsWord() )
+-    {
+-        wxMessageBox(wxT("The new label should be a single word."));
+-
+-        event.Veto();
+-    }
+-}*/
+-
+-/*void OPJMarkerTree::OnItemCollapsing(wxTreeEvent& event)
+-{
+-    wxLogMessage(wxT("OnItemCollapsing"));
+-
+-    // for testing, prevent the user from collapsing the first child folder
+-    wxTreeItemId itemId = event.GetItem();
+-    if ( IsTestItem(itemId) )
+-    {
+-        wxMessageBox(wxT("You can't collapse this item."));
+-
+-        event.Veto();
+-    }
+-}*/
+-
+-/*void OPJMarkerTree::OnItemActivated(wxTreeEvent& event)
+-{
+-    // show some info about this item
+-    wxTreeItemId itemId = event.GetItem();
+-    OPJMarkerData *item = (OPJMarkerData *)GetItemData(itemId);
+-
+-    if ( item != NULL )
+-    {
+-        item->ShowInfo(this);
+-    }
+-
+-    wxLogMessage(wxT("OnItemActivated"));
+-}*/
+-
+-void OPJMarkerTree::OnItemMenu(wxTreeEvent& event)
+-{
+-    /*wxTreeItemId itemId = event.GetItem();
+-    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
+-                                         : NULL;
+-
+-    wxLogMessage(wxT("OnItemMenu for item \"%s\""), item ? item->GetDesc()
+-                                                         : _T(""));*/
+-
+-	//wxLogMessage(wxT("EEEEEEEEEE"));
+-
+-    //event.Skip();
+-}
+-
+-/*void OPJMarkerTree::OnContextMenu(wxContextMenuEvent& event)
+-{
+-    wxPoint pt = event.GetPosition();
+-    wxTreeItemId item;
+-    wxLogMessage(wxT("OnContextMenu at screen coords (%i, %i)"), pt.x, pt.y);
+-
+-    // check if event was generated by keyboard (MSW-specific?)
+-    if ( pt.x == -1 && pt.y == -1 ) //(this is how MSW indicates it)
+-    {
+-        if ( !HasFlag(wxTR_MULTIPLE) )
+-            item = GetSelection();
+-
+-        // attempt to guess where to show the menu
+-        if ( item.IsOk() )
+-        {
+-            // if an item was clicked, show menu to the right of it
+-            wxRect rect;
+-            GetBoundingRect(item, rect, true );// only the label
+-            pt = wxPoint(rect.GetRight(), rect.GetTop());
+-        }
+-        else
+-        {
+-            pt = wxPoint(0, 0);
+-        }
+-    }
+-    else // event was generated by mouse, use supplied coords
+-    {
+-        pt = ScreenToClient(pt);
+-        item = HitTest(pt);
+-    }
+-
+-    ShowMenu(item, pt);
+-}*/
+-
+-/*void OPJMarkerTree::ShowMenu(wxTreeItemId id, const wxPoint& pt)
+-{
+-    wxString title;
+-    if ( id.IsOk() )
+-    {
+-        title << wxT("Menu for ") << GetItemText(id);
+-    }
+-    else
+-    {
+-        title = wxT("Menu for no particular item");
+-    }
+-
+-#if wxUSE_MENUS
+-    wxMenu menu(title);
+-    menu.Append(TreeTest_About, wxT("&About..."));
+-    menu.AppendSeparator();
+-    menu.Append(TreeTest_Highlight, wxT("&Highlight item"));
+-    menu.Append(TreeTest_Dump, wxT("&Dump"));
+-
+-    PopupMenu(&menu, pt);
+-#endif // wxUSE_MENUS
+-}*/
+-
+-/*void OPJMarkerTree::OnItemRClick(wxTreeEvent& event)
+-{
+-    wxTreeItemId itemId = event.GetItem();
+-    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
+-                                         : NULL;
+-
+-    wxLogMessage(wxT("Item \"%s\" right clicked"), item ? item->GetDesc()
+-                                                        : _T(""));
+-
+-    event.Skip();
+-}*/
+-
+-/*
+-void OPJMarkerTree::OnRMouseDown(wxMouseEvent& event)
+-{
+-    wxLogMessage(wxT("Right mouse button down"));
+-
+-    event.Skip();
+-}
+-
+-void OPJMarkerTree::OnRMouseUp(wxMouseEvent& event)
+-{
+-    wxLogMessage(wxT("Right mouse button up"));
+-
+-    event.Skip();
+-}
+-
+-void OPJMarkerTree::OnRMouseDClick(wxMouseEvent& event)
+-{
+-    wxTreeItemId id = HitTest(event.GetPosition());
+-    if ( !id )
+-        wxLogMessage(wxT("No item under mouse"));
+-    else
+-    {
+-        OPJMarkerData *item = (OPJMarkerData *)GetItemData(id);
+-        if ( item )
+-            wxLogMessage(wxT("Item '%s' under mouse"), item->GetDesc());
+-    }
+-
+-    event.Skip();
+-}
+-*/
+-
+-static inline const wxChar *Bool2String(bool b)
+-{
+-    return b ? wxT("") : wxT("not ");
+-}
+-
+-void OPJMarkerData::ShowInfo(wxTreeCtrl *tree)
+-{
+-    wxLogMessage(wxT("Item '%s': %sselected, %sexpanded, %sbold,\n")
+-                 wxT("%u children (%u immediately under this item)."),
+-                 m_desc.c_str(),
+-                 Bool2String(tree->IsSelected(GetId())),
+-                 Bool2String(tree->IsExpanded(GetId())),
+-                 Bool2String(tree->IsBold(GetId())),
+-                 unsigned(tree->GetChildrenCount(GetId())),
+-                 unsigned(tree->GetChildrenCount(GetId(), false)));
+-}
+-
+-/////////////////////////////////////////////////////////////////////
+-// Encoding thread class
+-/////////////////////////////////////////////////////////////////////
+-
+-OPJEncoThread::OPJEncoThread(OPJCanvas *canvas)
+-        : wxThread()
+-{
+-    m_count = 0;
+-    m_canvas = canvas;
+-}
+-
+-void OPJEncoThread::WriteText(const wxString& text)
+-{
+-    wxString msg;
+-
+-    // before doing any GUI calls we must ensure that this thread is the only
+-    // one doing it!
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiEnter();
+-#endif // __WXGTK__
+-
+-    msg << text;
+-    m_canvas->WriteText(msg);
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiLeave();
+-#endif // __WXGTK__
+-}
+-
+-void OPJEncoThread::OnExit()
+-{
+-    wxCriticalSectionLocker locker(wxGetApp().m_enco_critsect);
+-
+-    wxArrayThread& ethreads = wxGetApp().m_enco_threads;
+-    ethreads.Remove(this);
+-
+-    if (ethreads.IsEmpty() )
+-    {
+-        // signal the main thread that there are no more threads left if it is
+-        // waiting for us
+-        if (wxGetApp().m_enco_waitingUntilAllDone) {
+-            wxGetApp().m_enco_waitingUntilAllDone = false;
+-            wxGetApp().m_enco_semAllDone.Post();
+-        }
+-    }
+-}
+-
+-void *OPJEncoThread::Entry()
+-{
+-    wxString text;
+-
+-	srand(GetId());
+-	//int m_countnum = rand() % 9;
+-    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
+-    //            GetId(), GetPriority(), m_countnum);
+-    text.Printf(wxT("Enco thread %d started"), m_canvas->m_childframe->m_winnumber);
+-    WriteText(text);
+-
+-	// set handler properties
+-	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
+-	j2kkkhandler->m_subsampling = wxGetApp().m_subsampling;
+-	j2kkkhandler->m_origin = wxGetApp().m_origin;
+-	j2kkkhandler->m_rates = wxGetApp().m_rates;
+-	j2kkkhandler->m_quality = wxGetApp().m_quality;
+-	j2kkkhandler->m_irreversible = wxGetApp().m_irreversible;
+-	j2kkkhandler->m_resolutions = wxGetApp().m_resolutions;
+-	j2kkkhandler->m_cbsize = wxGetApp().m_cbsize;
+-	j2kkkhandler->m_prsize = wxGetApp().m_prsize;
+-	j2kkkhandler->m_tsize = wxGetApp().m_tsize;
+-	j2kkkhandler->m_torigin = wxGetApp().m_torigin;
+-	j2kkkhandler->m_enablesop = wxGetApp().m_enablesop;
+-	j2kkkhandler->m_enableeph = wxGetApp().m_enableeph;
+-	j2kkkhandler->m_enableidx = wxGetApp().m_enableidx;
+-	j2kkkhandler->m_index = m_canvas->m_savename.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR) + wxGetApp().m_index;
+-	j2kkkhandler->m_enablecomm = wxGetApp().m_enablecomm;
+-	j2kkkhandler->m_comment = wxGetApp().m_comment;
+-
+-	// save the file
+-	if (!m_canvas->m_image100.SaveFile(m_canvas->m_savename.GetFullPath(), wxBITMAP_TYPE_J2K)) {
+-		WriteText(wxT("Can't save image"));
+-		return NULL;
+-	}
+-
+-    text.Printf(wxT("Enco thread %d finished"), m_canvas->m_childframe->m_winnumber);
+-    WriteText(text);
+-    return NULL;
+-}
+-
+-/////////////////////////////////////////////////////////////////////
+-// Decoding thread class
+-/////////////////////////////////////////////////////////////////////
+-
+-OPJDecoThread::OPJDecoThread(OPJCanvas *canvas)
+-        : wxThread()
+-{
+-    m_count = 0;
+-    m_canvas = canvas;
+-}
+-
+-void OPJDecoThread::WriteText(const wxString& text)
+-{
+-    wxString msg;
+-
+-    // before doing any GUI calls we must ensure that this thread is the only
+-    // one doing it!
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiEnter();
+-#endif // __WXGTK__
+-
+-    msg << text;
+-    m_canvas->WriteText(msg);
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiLeave();
+-#endif // __WXGTK__
+-}
+-
+-void OPJDecoThread::OnExit()
+-{
+-    wxCriticalSectionLocker locker(wxGetApp().m_deco_critsect);
+-
+-    wxArrayThread& dthreads = wxGetApp().m_deco_threads;
+-    dthreads.Remove(this);
+-
+-    if (dthreads.IsEmpty() )
+-    {
+-        // signal the main thread that there are no more threads left if it is
+-        // waiting for us
+-        if (wxGetApp().m_deco_waitingUntilAllDone) {
+-            wxGetApp().m_deco_waitingUntilAllDone = false;
+-            wxGetApp().m_deco_semAllDone.Post();
+-        }
+-    }
+-}
+-
+-void *OPJDecoThread::Entry()
+-{
+-
+-    wxString text;
+-
+-	srand(GetId());
+-	//int m_countnum = rand() % 9;
+-    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
+-    //            GetId(), GetPriority(), m_countnum);
+-    text.Printf(wxT("Deco thread %d started"), m_canvas->m_childframe->m_winnumber);
+-
+-    WriteText(text);
+-
+-    wxBitmap bitmap(100, 100);
+-    wxImage image(100, 100, true); //= bitmap.ConvertToImage();
+-    image.Destroy();
+-
+-	WriteText(m_canvas->m_fname.GetFullPath());
+-
+-
+-	// set handler properties
+-	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
+-	j2kkkhandler->m_reducefactor = wxGetApp().m_reducefactor;
+-	j2kkkhandler->m_qualitylayers = wxGetApp().m_qualitylayers;
+-	j2kkkhandler->m_components = wxGetApp().m_components;
+-#ifdef USE_JPWL
+-	j2kkkhandler->m_enablejpwl = wxGetApp().m_enablejpwl;
+-	j2kkkhandler->m_expcomps = wxGetApp().m_expcomps;
+-	j2kkkhandler->m_maxtiles = wxGetApp().m_maxtiles;
+-#endif // USE_JPWL
+-
+-	wxJP2Handler *jp222handler = (wxJP2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_JP2);
+-	jp222handler->m_reducefactor = wxGetApp().m_reducefactor;
+-	jp222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
+-	jp222handler->m_components = wxGetApp().m_components;
+-#ifdef USE_JPWL
+-	jp222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
+-	jp222handler->m_expcomps = wxGetApp().m_expcomps;
+-	jp222handler->m_maxtiles = wxGetApp().m_maxtiles;
+-#endif // USE_JPWL
+-
+-	wxMJ2Handler *mj222handler = (wxMJ2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_MJ2);
+-	mj222handler->m_reducefactor = wxGetApp().m_reducefactor;
+-	mj222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
+-	mj222handler->m_components = wxGetApp().m_components;
+-	mj222handler->m_framenum = wxGetApp().m_framenum;
+-#ifdef USE_JPWL
+-	mj222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
+-	mj222handler->m_expcomps = wxGetApp().m_expcomps;
+-	mj222handler->m_maxtiles = wxGetApp().m_maxtiles;
+-#endif // USE_JPWL
+-
+-	if (wxGetApp().m_enabledeco) {
+-
+-		// load the file
+-		if (!image.LoadFile(m_canvas->m_fname.GetFullPath(), wxBITMAP_TYPE_ANY, 0)) {
+-			WriteText(wxT("Can't load image"));
+-			return NULL;
+-		}
+-
+-	} else {
+-
+-		// display a macaron
+-		if (!image.Create(300, 5, false)) {
+-			WriteText(wxT("Can't create image"));
+-			return NULL;
+-		}
+-
+-	}
+-
+-	// assign 100% image
+-    m_canvas->m_image100 = wxBitmap(image);
+-
+-	// find a fit-to-width zoom
+-	int zooml, wzooml, hzooml;
+-	wxSize clientsize = m_canvas->GetClientSize();
+-	wzooml = (int) floor(100.0 * (double) clientsize.GetWidth() / (double) (2 * OPJ_CANVAS_BORDER + image.GetWidth()));
+-	hzooml = (int) floor(100.0 * (double) clientsize.GetHeight() / (double) (2 * OPJ_CANVAS_BORDER + image.GetHeight()));
+-	zooml = wxMin(100, wxMin(wzooml, hzooml));
+-
+-	// fit to width
+-#ifndef __WXGTK__
+-	m_canvas->m_childframe->m_frame->Rescale(zooml, m_canvas->m_childframe);
+-#endif // __WXGTK__
+-
+-	//m_canvas->m_image = m_canvas->m_image100;
+-	//m_canvas->Refresh();
+-	//m_canvas->SetScrollbars(20, 20, (int)(0.5 + (double) image.GetWidth() / 20.0), (int)(0.5 + (double) image.GetHeight() / 20.0));
+-
+-    //text.Printf(wxT("Deco thread 0x%lx finished."), GetId());
+-    text.Printf(wxT("Deco thread %d finished"), m_canvas->m_childframe->m_winnumber);
+-    WriteText(text);
+-    return NULL;
+-
+-}
+-
+-/////////////////////////////////////////////////////////////////////
+-// Parsing thread class
+-/////////////////////////////////////////////////////////////////////
+-
+-OPJParseThread::OPJParseThread(OPJMarkerTree *tree, wxTreeItemId parentid)
+-        : wxThread()
+-{
+-    m_count = 0;
+-    m_tree = tree;
+-	m_parentid = parentid;
+-}
+-
+-void OPJParseThread::WriteText(const wxString& text)
+-{
+-    wxString msg;
+-
+-    // before doing any GUI calls we must ensure that this thread is the only
+-    // one doing it!
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiEnter();
+-#endif // __WXGTK
+-
+-    msg << text;
+-    m_tree->WriteText(msg);
+-
+-#ifndef __WXGTK__ 
+-    wxMutexGuiLeave();
+-#endif // __WXGTK
+-}
+-
+-void OPJParseThread::OnExit()
+-{
+-    wxCriticalSectionLocker locker(wxGetApp().m_parse_critsect);
+-
+-    wxArrayThread& threads = wxGetApp().m_parse_threads;
+-    threads.Remove(this);
+-
+-    if (threads.IsEmpty()) {
+-        // signal the main thread that there are no more threads left if it is
+-        // waiting for us
+-        if (wxGetApp().m_parse_waitingUntilAllDone) {
+-            wxGetApp().m_parse_waitingUntilAllDone = false;
+-            wxGetApp().m_parse_semAllDone.Post();
+-        }
+-    }
+-}
+-
+-void *OPJParseThread::Entry()
+-{
+-
+-	printf("Entering\n\n");
+-
+-    wxString text;
+-
+-	srand(GetId());
+-	int m_countnum = rand() % 9;
+-    text.Printf(wxT("Parse thread 0x%lx started (priority = %u, time = %d)."),
+-            GetId(), GetPriority(), m_countnum);
+-    WriteText(text);
+-    LoadFile(m_tree->m_fname);
+-    text.Printf(wxT("Parse thread 0x%lx finished."), GetId());
+-    WriteText(text);
+-
+-
+-    //wxLogMessage(wxT("Entering\n")); //test wxLog thread safeness
+-
+-	//wxBusyCursor wait;
+-	//wxBusyInfo wait(wxT("Decoding image ..."));
+-
+-
+-    /*for ( m_count = 0; m_count < m_countnum; m_count++ )
+-    {
+-        // check if we were asked to exit
+-        if ( TestDestroy() )
+-            break;
+-
+-        text.Printf(wxT("[%u] Parse thread 0x%lx here."), m_count, GetId());
+-        WriteText(text);
+-
+-        // wxSleep() can't be called from non-GUI thread!
+-        wxThread::Sleep(10);
+-    }*/
+-
+-    // wxLogMessage(text); -- test wxLog thread safeness
+-
+-	printf("Exiting\n\n");
+-
+-    return NULL;
+-}
+-
+-
+-
+-
+-
+-
+-
+-// ----------------------------------------------------------------------------
+-// OPJDecoderDialog
+-// ----------------------------------------------------------------------------
+-
+-IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
+-
+-BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
+-#ifdef USE_JPWL
+-	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
+-	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
+-#endif // USE_JPWL
+-END_EVENT_TABLE()
+-
+-OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
+-{
+-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+-
+-	Create(win, wxID_ANY, wxT("Decoder settings"),
+-		wxDefaultPosition, wxDefaultSize,
+-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+-		);
+-
+-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+-
+-	m_settingsNotebook = GetBookCtrl();
+-
+-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+-	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
+-	if (!wxGetApp().m_enabledeco)
+-		jpeg2000Settings->Enable(false);
+-	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
+-	if (!wxGetApp().m_enabledeco)
+-		mjpeg2000Settings->Enable(false);
+-#ifdef USE_JPWL
+-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+-	if (!wxGetApp().m_enabledeco)
+-		jpwlSettings->Enable(false);
+-#endif // USE_JPWL
+-
+-	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
+-	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
+-	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
+-#ifdef USE_JPWL
+-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+-#endif // USE_JPWL
+-
+-	LayoutDialog();
+-}
+-
+-OPJDecoderDialog::~OPJDecoderDialog()
+-{
+-}
+-
+-wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-		// add decoding enabling check box
+-		subtopSizer->Add(
+-			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
+-			0, wxGROW | wxALL, 5);
+-		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
+-
+-		// add parsing enabling check box
+-		subtopSizer->Add(
+-			m_enableparseCheck = new wxCheckBox(panel, OPJDECO_ENABLEPARSE, wxT("Enable parsing"), wxDefaultPosition, wxDefaultSize),
+-			0, wxGROW | wxALL, 5);
+-		m_enableparseCheck->SetValue(wxGetApp().m_enableparse);
+-
+-			// resize settings, column
+-			wxString choices[] = {wxT("Don't resize"), wxT("Low quality"), wxT("High quality")};
+-			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
+-				wxT("Resize method"),
+-				wxDefaultPosition, wxDefaultSize,
+-				WXSIZEOF(choices),
+-				choices,
+-				1,
+-				wxRA_SPECIFY_ROWS);
+-			m_resizeBox->SetSelection(wxGetApp().m_resizemethod + 1);
+-
+-		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	// add some space
+-	//topSizer->AddSpacer(5);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-			// frame settings, column
+-			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
+-			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
+-
+-				// selected frame number, row
+-				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				framenumSizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				framenumSizer->Add(
+-					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
+-								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								1, 100000, wxGetApp().m_framenum),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	// add some space
+-	//topSizer->AddSpacer(5);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-			// resolutions settings, column
+-			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
+-			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
+-
+-				// reduce factor sizer, row
+-				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				reduceSizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				reduceSizer->Add(
+-					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
+-					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 10000, wxGetApp().m_reducefactor),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
+-
+-			// quality layer settings, column
+-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
+-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+-
+-				// quality layers sizer, row
+-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				qualitySizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				qualitySizer->Add(
+-					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
+-								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 100000, wxGetApp().m_qualitylayers),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
+-
+-			// component settings, column
+-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+-
+-				// quality layers sizer, row
+-				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				numcompsSizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				numcompsSizer->Add(
+-					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
+-								wxString::Format(wxT("%d"), wxGetApp().m_components),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 100000, wxGetApp().m_components),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-				m_numcompsCtrl->Enable(true);
+-
+-			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-#ifdef USE_JPWL
+-wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	// add some space
+-	//topSizer->AddSpacer(5);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-		// add JPWL enabling check box
+-		subtopSizer->Add(
+-			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
+-			0, wxGROW | wxALL, 5);
+-		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
+-
+-			// component settings, column
+-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+-
+-				// expected components sizer, row
+-				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				expcompsSizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				expcompsSizer->Add(
+-					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
+-								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								1, 100000, wxGetApp().m_expcomps),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
+-
+-			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+-
+-			// tiles settings, column
+-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+-
+-				// maximum tiles sizer, row
+-				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+-
+-				// add some horizontal space
+-				maxtileSizer->Add(5, 5, 1, wxALL, 0);
+-
+-				// add the value control
+-				maxtileSizer->Add(
+-					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
+-								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								1, 100000, wxGetApp().m_maxtiles),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+-				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
+-
+-			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
+-
+-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
+-{
+-	size_t pp;
+-
+-	if (event.IsChecked()) {
+-		wxLogMessage(wxT("Decoding enabled"));
+-		m_resizeBox->Enable(true);
+-		// enable all tabs except ourselves
+-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+-				m_settingsNotebook->GetPage(pp)->Enable(true);
+-		}
+-	} else {
+-		wxLogMessage(wxT("Decoding disabled"));
+-		m_resizeBox->Enable(false);
+-		// disable all tabs except ourselves
+-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+-				m_settingsNotebook->GetPage(pp)->Enable(false);
+-		}
+-	}
+-
+-}
+-
+-void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
+-{
+-	if (event.IsChecked()) {
+-		wxLogMessage(wxT("JPWL enabled"));
+-		m_expcompsCtrl->Enable(true);
+-		m_maxtilesCtrl->Enable(true);
+-	} else {
+-		wxLogMessage(wxT("JPWL disabled"));
+-		m_expcompsCtrl->Enable(false);
+-		m_maxtilesCtrl->Enable(false);
+-	}
+-
+-}
+-
+-#endif // USE_JPWL
+-
+-bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
+-{
+-    /*size_t nFiles = filenames.GetCount();
+-    wxString str;
+-    str.Printf( _T("%d files dropped\n"), (int)nFiles);
+-    for ( size_t n = 0; n < nFiles; n++ ) {
+-        str << filenames[n] << wxT("\n");
+-    }
+-    wxLogMessage(str);*/
+-	m_pOwner->OpenFiles(filenames, filenames);
+-
+-    return true;
+-}
+-
+-
+-
+-
+-
+-// ----------------------------------------------------------------------------
+-// OPJEncoderDialog
+-// ----------------------------------------------------------------------------
+-
+-IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
+-
+-BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
+-#ifdef USE_JPWL
+-	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
+-	EVT_CHECKBOX(OPJENCO_ENABLECOMM, OPJEncoderDialog::OnEnableComm)
+-	EVT_CHECKBOX(OPJENCO_ENABLEINDEX, OPJEncoderDialog::OnEnableIdx)
+-#endif // USE_JPWL
+-END_EVENT_TABLE()
+-
+-OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
+-{
+-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+-
+-	Create(win, wxID_ANY, wxT("Encoder settings"),
+-		wxDefaultPosition, wxDefaultSize,
+-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+-		);
+-
+-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+-
+-	m_settingsNotebook = GetBookCtrl();
+-
+-	wxPanel* jpeg2000_1Settings = CreatePart1_1SettingsPage(m_settingsNotebook);
+-	wxPanel* jpeg2000_2Settings = CreatePart1_2SettingsPage(m_settingsNotebook);
+-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+-#ifdef USE_JPWL
+-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+-#endif // USE_JPWL
+-
+-	m_settingsNotebook->AddPage(jpeg2000_1Settings, wxT("JPEG 2000 - 1"), false);
+-	m_settingsNotebook->AddPage(jpeg2000_2Settings, wxT("JPEG 2000 - 2"), false);
+-	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
+-#ifdef USE_JPWL
+-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+-#endif // USE_JPWL
+-
+-	LayoutDialog();
+-}
+-
+-OPJEncoderDialog::~OPJEncoderDialog()
+-{
+-}
+-
+-wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-#ifdef USE_JPWL
+-wxPanel* OPJEncoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-		// sub top sizer
+-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-#endif // USE_JPWL
+-
+-wxPanel* OPJEncoderDialog::CreatePart1_1SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	// add some space
+-	//topSizer->AddSpacer(5);
+-
+-		// sub top sizer
+-		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+-
+-			// image settings, column
+-			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
+-			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
+-
+-				// subsampling factor sizer, row
+-				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				subsSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				subsSizer->Add(
+-					m_subsamplingCtrl = new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
+-								wxGetApp().m_subsampling,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
+-
+-				// origin sizer, row
+-				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				imorigSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				imorigSizer->Add(
+-					m_originCtrl = new wxTextCtrl(panel, OPJENCO_IMORIG,
+-								wxGetApp().m_origin,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
+-
+-			// layer settings, column
+-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers/compression"));
+-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+-
+-				// rate factor sizer, row
+-				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				rateSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				rateSizer->Add(
+-					m_rateCtrl = new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
+-								wxGetApp().m_rates,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
+-
+-				// quality factor sizer, row
+-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				qualitySizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				qualitySizer->Add(
+-					m_qualityCtrl = new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
+-								wxGetApp().m_quality,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
+-
+-			// wavelet settings, column
+-			wxStaticBox* waveletBox = new wxStaticBox(panel, wxID_ANY, wxT("Wavelet transform"));
+-			wxBoxSizer* waveletSizer = new wxStaticBoxSizer(waveletBox, wxVERTICAL);
+-
+-			// irreversible check box
+-			waveletSizer->Add(
+-				m_irrevCheck = new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible"),
+-				wxDefaultPosition, wxDefaultSize),
+-				0, wxGROW | wxALL, 3);
+-			m_irrevCheck->SetValue(wxGetApp().m_irreversible);
+-
+-				// resolution number sizer, row
+-				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				resnumSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				resnumSizer->Add(
+-					m_resolutionsCtrl = new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
+-								wxString::Format("%d", wxGetApp().m_resolutions),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 256, 6),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			waveletSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(waveletSizer, 0, wxGROW | wxALL, 3);
+-
+-			// codestream settings, column
+-			wxStaticBox* codestreamBox = new wxStaticBox(panel, wxID_ANY, wxT("Codestream"));
+-			wxBoxSizer* codestreamSizer = new wxStaticBoxSizer(codestreamBox, wxVERTICAL);
+-
+-				// codeblock sizer, row
+-				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				codeblockSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				codeblockSizer->Add(
+-					m_cbsizeCtrl = new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
+-								wxGetApp().m_cbsize,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			codestreamSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
+-
+-				// precinct sizer, row
+-				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				precinctSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				precinctSizer->Add(
+-					m_prsizeCtrl = new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
+-								wxGetApp().m_prsize,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			codestreamSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(codestreamSizer, 0, wxGROW | wxALL, 3);
+-
+-			// tile settings, column
+-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+-
+-				// tile size sizer, row
+-				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				tilesizeSizer->Add(
+-					m_tsizeCtrl = new wxTextCtrl(panel, OPJENCO_TILESIZE,
+-								wxGetApp().m_tsize,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
+-
+-				// tile origin sizer, row
+-				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				tilorigSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				tilorigSizer->Add(
+-					m_toriginCtrl = new wxTextCtrl(panel, OPJENCO_TILORIG,
+-								wxGetApp().m_torigin,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
+-
+-			// progression and profile settings, column
+-			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL"),
+-				wxT("DCI2K24"), wxT("DCI2K48"), wxT("DCI4K")};
+-			wxRadioBox *progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
+-				wxT("Progression order/profile"),
+-				wxDefaultPosition, wxDefaultSize,
+-				WXSIZEOF(choices),
+-				choices,
+-				3,
+-				wxRA_SPECIFY_COLS);
+-			progressionBox->SetSelection(0);
+-
+-		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-wxPanel* OPJEncoderDialog::CreatePart1_2SettingsPage(wxWindow* parent)
+-{
+-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+-
+-	// top sizer
+-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+-
+-	// add some space
+-	//topSizer->AddSpacer(5);
+-
+-		// sub top sizer
+-		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+-			
+-			// resilience settings, column
+-			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Error resilience"));
+-			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
+-
+-				// resil2 sizer, row
+-				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// SOP check box
+-				resil2Sizer->Add(
+-					m_sopCheck = new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
+-						wxDefaultPosition, wxDefaultSize),
+-						0, wxGROW | wxALL, 3);
+-				m_sopCheck->SetValue(wxGetApp().m_enablesop);
+-
+-				// EPH check box
+-				resil2Sizer->Add(
+-					m_ephCheck = new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
+-						wxDefaultPosition, wxDefaultSize),
+-						0, wxGROW | wxALL, 3);
+-				m_ephCheck->SetValue(wxGetApp().m_enableeph);
+-
+-			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
+-
+-			// separation
+-			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
+-
+-				// resil3 sizer, row
+-				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
+-
+-				// BYPASS check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-				// RESET check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-				// RESTART check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-				// VSC check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-				// ERTERM check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-				// SEGMARK check box
+-				resil3Sizer->Add(
+-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
+-					wxDefaultPosition, wxDefaultSize),
+-					0, wxGROW | wxALL, 3);
+-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
+-
+-			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
+-
+-			// ROI settings, column
+-			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("Region Of Interest"));
+-			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
+-
+-				// component number sizer, row
+-				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				roicompSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				roicompSizer->Add(
+-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
+-								wxT("0"),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 256, 0),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
+-
+-				// upshift sizer, row
+-				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				roishiftSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				roishiftSizer->Add(
+-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
+-								wxT("0"),
+-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+-								wxSP_ARROW_KEYS,
+-								0, 37, 0),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
+-
+-			// Index file settings, column
+-			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
+-			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
+-
+-			// indexing check box
+-			indexSizer->Add(
+-				m_enableidxCheck = new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
+-				wxDefaultPosition, wxDefaultSize),
+-				0, wxGROW | wxALL, 3);
+-			m_enableidxCheck->SetValue(wxGetApp().m_enableidx);
+-
+-				// index file sizer, row
+-				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				indexnameSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				indexnameSizer->Add(
+-					m_indexCtrl = new wxTextCtrl(panel, OPJENCO_INDEXNAME,
+-								wxGetApp().m_index,
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-				m_indexCtrl->Enable(wxGetApp().m_enableidx);
+-
+-			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
+-
+-			// Comment settings, column
+-			wxStaticBox* commentBox = new wxStaticBox(panel, wxID_ANY, wxT("Comment"));
+-			wxBoxSizer* commentSizer = new wxStaticBoxSizer(commentBox, wxVERTICAL);
+-
+-			// commenting check box
+-			commentSizer->Add(
+-				m_enablecommCheck = new wxCheckBox(panel, OPJENCO_ENABLECOMM, wxT("Enabled"),
+-				wxDefaultPosition, wxDefaultSize),
+-				0, wxGROW | wxALL, 3);
+-			m_enablecommCheck->SetValue(wxGetApp().m_enablecomm);
+-
+-			// add some horizontal space
+-			commentSizer->Add(3, 3, 1, wxALL, 0);
+-
+-			// add the value control
+-			commentSizer->Add(
+-				m_commentCtrl = new wxTextCtrl(panel, OPJENCO_COMMENTTEXT,
+-							wxGetApp().m_comment,
+-							wxDefaultPosition, wxSize(wxDefaultCoord, 60),
+-							wxTE_LEFT | wxTE_MULTILINE),
+-				0, wxGROW | wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-			m_commentCtrl->Enable(wxGetApp().m_enablecomm);
+-
+-		subtopSizer->Add(commentSizer, 0, wxGROW | wxALL, 3);
+-
+-			// POC settings, column
+-			wxStaticBox* pocBox = new wxStaticBox(panel, wxID_ANY, wxT("POC"));
+-			wxBoxSizer* pocSizer = new wxStaticBoxSizer(pocBox, wxVERTICAL);
+-
+-			// POC check box
+-			pocSizer->Add(
+-				m_enablepocCheck = new wxCheckBox(panel, OPJENCO_ENABLEPOC, wxT("Enabled"),
+-				wxDefaultPosition, wxDefaultSize),
+-				0, wxGROW | wxALL, 3);
+-			m_enablepocCheck->SetValue(/*wxGetApp().m_enableidx*/true);
+-
+-				// POC sizer, row
+-				wxBoxSizer* pocspecSizer = new wxBoxSizer(wxHORIZONTAL);
+-
+-				// add some text
+-				pocspecSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Changes:")),
+-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+-
+-				// add some horizontal space
+-				pocspecSizer->Add(3, 3, 1, wxALL, 0);
+-
+-				// add the value control
+-				pocspecSizer->Add(
+-					m_pocCtrl = new wxTextCtrl(panel, OPJENCO_POCSPEC,
+-								/*wxGetApp().m_index*/wxT("RRRR"),
+-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+-								wxTE_LEFT),
+-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+-				m_pocCtrl->Enable(/*wxGetApp().m_enableidx*/true);
+-
+-			pocSizer->Add(pocspecSizer, 0, wxGROW | wxALL, 3);
+-
+-		subtopSizer->Add(pocSizer, 0, wxGROW | wxALL, 3);
+-
+-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+-
+-	// assign top and fit it
+-    panel->SetSizer(topSizer);
+-    topSizer->Fit(panel);
+-
+-    return panel;
+-}
+-
+-void OPJEncoderDialog::OnEnableComm(wxCommandEvent& event)
+-{
+-	if (event.IsChecked()) {
+-		wxLogMessage(wxT("Comment enabled"));
+-		m_commentCtrl->Enable(true);
+-	} else {
+-		wxLogMessage(wxT("Comment disabled"));
+-		m_commentCtrl->Enable(false);
+-	}
+-
+-}
+-
+-void OPJEncoderDialog::OnEnableIdx(wxCommandEvent& event)
+-{
+-	if (event.IsChecked()) {
+-		wxLogMessage(wxT("Index enabled"));
+-		m_indexCtrl->Enable(true);
+-	} else {
+-		wxLogMessage(wxT("Index disabled"));
+-		m_indexCtrl->Enable(false);
+-	}
+-}
+-
+-#ifdef USE_JPWL
+-void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
+-{
+-	/*if (event.IsChecked()) {
+-		wxLogMessage(wxT("JPWL enabled"));
+-		m_expcompsCtrl->Enable(true);
+-		m_maxtilesCtrl->Enable(true);
+-	} else {
+-		wxLogMessage(wxT("JPWL disabled"));
+-		m_expcompsCtrl->Enable(false);
+-		m_maxtilesCtrl->Enable(false);
+-	}*/
+-
+-}
+-#endif // USE_JPWL
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/OPJViewer.h ./OPJViewer/source/OPJViewer.h
+--- ../trunk.orig/OPJViewer/source/OPJViewer.h	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/OPJViewer.h	2007-12-01 18:40:47.000000000 +0000
+@@ -106,6 +106,9 @@
+ #include "imagj2k.h"
+ #include "imagjp2.h"
+ #include "imagmj2.h"
++#ifdef USE_MXF
++#include "imagmxf.h"
++#endif // USE_MXF
+ 
+ #ifdef __WXMSW__
+ typedef unsigned __int64 int8byte;
+@@ -150,6 +153,16 @@
+ #define OPJ_CANVAS_BORDER 10
+ #define OPJ_CANVAS_COLOUR *wxWHITE
+ 
++
++
++#ifdef USE_JPWL
++
++//#define MYJPWL_MAX_NO_TILESPECS JPWL_MAX_NO_TILESPECS
++#define MYJPWL_MAX_NO_TILESPECS 4
++
++#endif // USE_JPWL
++
++
+ class OPJDecoThread;
+ class OPJEncoThread;
+ class OPJParseThread;
+@@ -198,16 +211,25 @@
+ 		bool m_enabledeco, m_enableparse;
+ 		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
+ #ifdef USE_JPWL
+-		bool m_enablejpwl;
++		bool m_enablejpwl, m_enablejpwle;
+ 		int m_expcomps, m_maxtiles;
+ 		int m_framewidth, m_frameheight;
+ #endif // USE_JPWL
+ 
+ 		// encoding engine parameters
+ 		wxString m_subsampling, m_origin, m_rates, m_comment, m_index, m_quality;
+-		wxString m_cbsize, m_prsize, m_tsize, m_torigin;
+-		bool m_enablecomm, m_enableidx, m_irreversible, m_enablesop, m_enableeph;
+-		int m_resolutions;
++		wxString m_cbsize, m_prsize, m_tsize, m_torigin, m_poc;
++		bool m_enablecomm, m_enableidx, m_multicomp, m_irreversible, m_enablesop, m_enableeph;
++		bool m_enablebypass, m_enablereset, m_enablerestart, m_enablevsc, m_enableerterm;
++		bool m_enablesegmark, m_enablepoc;
++		bool m_enablequality;
++		int m_resolutions, m_progression;
++#ifdef USE_JPWL
++		int m_hprotsel[MYJPWL_MAX_NO_TILESPECS], m_pprotsel[MYJPWL_MAX_NO_TILESPECS];
++		int m_htileval[MYJPWL_MAX_NO_TILESPECS], m_ptileval[MYJPWL_MAX_NO_TILESPECS],
++			m_ppackval[MYJPWL_MAX_NO_TILESPECS];
++		int m_sensisel[MYJPWL_MAX_NO_TILESPECS], m_stileval[MYJPWL_MAX_NO_TILESPECS];
++#endif // USE_JPWL
+ 
+ 		// some layout settings
+ 		bool m_showtoolbar, m_showbrowser, m_showpeeker;
+@@ -272,10 +294,10 @@
+ 		const wxChar *GetDesc1() const { return m_desc.c_str(); }
+ 		const wxChar *GetDesc2() const { return m_filestring.c_str(); }
+ 		wxFileOffset m_start, m_length;
++		wxString m_desc;
+ 
+ 	// private methods and variables
+ 	private:
+-		wxString m_desc;
+ 		wxString m_filestring;
+ };
+ 
+@@ -404,6 +426,15 @@
+ 	void OnPrevFrame(wxCommandEvent& event);
+ 	void OnHomeFrame(wxCommandEvent& event);
+ 	void OnNextFrame(wxCommandEvent& event);
++	void OnLessLayers(wxCommandEvent& event);
++	void OnAllLayers(wxCommandEvent& event);
++	void OnMoreLayers(wxCommandEvent& event);
++	void OnLessRes(wxCommandEvent& event);
++	void OnFullRes(wxCommandEvent& event);
++	void OnMoreRes(wxCommandEvent& event);
++	void OnPrevComp(wxCommandEvent& event);
++	void OnAllComps(wxCommandEvent& event);
++	void OnNextComp(wxCommandEvent& event);
+ 	void OnSetsEnco(wxCommandEvent& event);
+ 	void OnSetsDeco(wxCommandEvent& event);
+ 	void OnSashDrag(wxSashEvent& event);
+@@ -475,6 +506,15 @@
+ 	OPJFRAME_VIEWPREVFRAME,
+ 	OPJFRAME_VIEWHOMEFRAME,
+ 	OPJFRAME_VIEWNEXTFRAME,
++	OPJFRAME_VIEWLESSLAYERS,
++	OPJFRAME_VIEWALLLAYERS,
++	OPJFRAME_VIEWMORELAYERS,
++	OPJFRAME_VIEWLESSRES,
++	OPJFRAME_VIEWFULLRES,
++	OPJFRAME_VIEWMORERES,
++	OPJFRAME_VIEWPREVCOMP,
++	OPJFRAME_VIEWALLCOMPS,
++	OPJFRAME_VIEWNEXTCOMP,
+ 	OPJFRAME_FILECLOSE,
+ 	OPJFRAME_SETSENCO,
+ 	OPJFRAME_SETSDECO,
+@@ -634,19 +674,35 @@
+     wxPanel* CreatePart1_1SettingsPage(wxWindow* parent);
+     wxPanel* CreatePart1_2SettingsPage(wxWindow* parent);
+ /*    wxPanel* CreatePart3SettingsPage(wxWindow* parent);*/
+-#ifdef USE_JPWL
+-	void OnEnableJPWL(wxCommandEvent& event);
+ 	void OnEnableComm(wxCommandEvent& event);
+ 	void OnEnableIdx(wxCommandEvent& event);
++	void OnEnablePoc(wxCommandEvent& event);
++	void OnRadioQualityRate(wxCommandEvent& event);
++#ifdef USE_JPWL
++	void OnEnableJPWL(wxCommandEvent& event);
+ 	wxPanel* CreatePart11SettingsPage(wxWindow* parent);
+ 	/*wxCheckBox *m_enablejpwlCheck;*/
++	wxChoice *m_hprotChoice[MYJPWL_MAX_NO_TILESPECS];
++	wxSpinCtrl *m_htileCtrl[MYJPWL_MAX_NO_TILESPECS];
++	wxChoice *m_pprotChoice[MYJPWL_MAX_NO_TILESPECS];
++	wxSpinCtrl *m_ptileCtrl[MYJPWL_MAX_NO_TILESPECS];
++	wxSpinCtrl *m_ppackCtrl[MYJPWL_MAX_NO_TILESPECS];
++	wxChoice *m_sensiChoice[MYJPWL_MAX_NO_TILESPECS];
++	wxSpinCtrl *m_stileCtrl[MYJPWL_MAX_NO_TILESPECS];
++	void OnHprotSelect(wxCommandEvent& event);
++	void OnPprotSelect(wxCommandEvent& event);
++	void OnSensiSelect(wxCommandEvent& event);
+ #endif // USE_JPWL
+ 
+ 	wxTextCtrl *m_subsamplingCtrl, *m_originCtrl, *m_rateCtrl, *m_commentCtrl;
++	wxRadioButton *m_rateRadio, *m_qualityRadio;
+ 	wxTextCtrl *m_indexCtrl, *m_qualityCtrl, *m_cbsizeCtrl, *m_prsizeCtrl, *m_pocCtrl;
+ 	wxTextCtrl *m_tsizeCtrl, *m_toriginCtrl;
+-	wxCheckBox *m_enablecommCheck, *m_enableidxCheck, *m_irrevCheck, *m_sopCheck, *m_ephCheck;
+-	wxCheckBox *m_enablepocCheck;
++	wxRadioBox *progressionBox;
++	wxCheckBox *m_enablecommCheck, *m_enableidxCheck, *m_mctCheck, *m_irrevCheck;
++	wxCheckBox *m_sopCheck, *m_ephCheck, *m_enablebypassCheck, *m_enableresetCheck,
++		*m_enablerestartCheck, *m_enablevscCheck, *m_enableertermCheck, *m_enablesegmarkCheck;
++	wxCheckBox *m_enablepocCheck, *m_enablejpwlCheck;
+ 	wxSpinCtrl *m_resolutionsCtrl;
+ 
+ protected:
+@@ -654,7 +710,9 @@
+     enum {
+ 		OPJENCO_ENABLEJPWL = 100,
+ 		OPJENCO_RATEFACTOR,
++		OPJENCO_RATERADIO,
+ 		OPJENCO_QUALITYFACTOR,
++		OPJENCO_QUALITYRADIO,
+ 		OPJENCO_RESNUMBER,
+ 		OPJENCO_CODEBLOCKSIZE,
+ 		OPJENCO_PRECINCTSIZE,
+@@ -674,12 +732,20 @@
+ 		OPJENCO_ROISHIFT,
+ 		OPJENCO_IMORIG,
+ 		OPJENCO_TILORIG,
++		OPJENCO_ENABLEMCT,
+ 		OPJENCO_ENABLEIRREV,
+ 		OPJENCO_ENABLEINDEX,
+ 		OPJENCO_INDEXNAME,
+ 		OPJENCO_POCSPEC,
+ 		OPJENCO_ENABLECOMM,
+-		OPJENCO_COMMENTTEXT
++		OPJENCO_COMMENTTEXT,
++		OPJENCO_HPROT,
++		OPJENCO_HTILE,
++		OPJENCO_PPROT,
++		OPJENCO_PTILE,
++		OPJENCO_PPACK,
++		OPJENCO_SENSI,
++		OPJENCO_STILE
+     };
+ 
+ DECLARE_EVENT_TABLE()
+diff -urN -x.svn ../trunk.orig/OPJViewer/source/wxj2kparser.cpp ./OPJViewer/source/wxj2kparser.cpp
+--- ../trunk.orig/OPJViewer/source/wxj2kparser.cpp	2007-09-28 11:36:31.000000000 +0100
++++ ./OPJViewer/source/wxj2kparser.cpp	2007-11-27 22:39:50.000000000 +0000
+@@ -255,7 +255,8 @@
+ 			wxString::FromAscii(marker_name[m]) + 
+ 			wxString::Format(wxT(" (0x%04X)"), marker_val[m]),
+ 			image, imageSel,
+-			new OPJMarkerData(wxT("MARK"), m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
++			new OPJMarkerData(wxT("MARK") + wxString::Format(wxT(" (%d)"), marker_val[m]),
++				m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
+ 			);
+ 
+ 		// append some info
diff -urN -xdebian -x.svn ./DllOpenJPEG.sln /usr/src/openjpeg/trunk/DllOpenJPEG.sln
--- ./DllOpenJPEG.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/DllOpenJPEG.sln	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllOpenJPEG", "DllOpenJPEG.vcproj", "{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.ActiveCfg = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.Build.0 = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.ActiveCfg = Release|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./DllOpenJPEG.vcproj /usr/src/openjpeg/trunk/DllOpenJPEG.vcproj
--- ./DllOpenJPEG.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/DllOpenJPEG.vcproj	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,670 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="DllOpenJPEG"
+	ProjectGUID="{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Release/OpenJPEG.dll"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/OpenJPEG.pdb"
+				LinkTimeCodeGeneration="0"
+				ImportLibrary=".\Release/OpenJPEG.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Release\OpenJPEG.dll dist&#x0D;&#x0A;copy Release\OpenJPEG.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Debug/OpenJPEGd.dll"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/OpenJPEGd.pdb"
+				ImportLibrary=".\Debug/OpenJPEGd.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Debug\OpenJPEGd.dll dist&#x0D;&#x0A;copy Debug\OpenJPEGd.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./doc/CMakeLists.txt /usr/src/openjpeg/trunk/doc/CMakeLists.txt
--- ./doc/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/doc/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,12 @@
+FIND_PACKAGE(Doxygen REQUIRED)
+
+# The Doxyfile.dox is poorly defined and produce output
+# in the source dir
+ADD_CUSTOM_TARGET(doxygen
+# By default doxygen target is added to the 'all' target. Project is small
+# thus running doxygen is not too time consuming
+  ALL
+  ${DOXYGEN}
+  ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.dox
+  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
+)
diff -urN -xdebian -x.svn ./doc/Doxyfile.dox /usr/src/openjpeg/trunk/doc/Doxyfile.dox
--- ./doc/Doxyfile.dox	2007-11-29 18:27:19.000000000 +0000
+++ /usr/src/openjpeg/trunk/doc/Doxyfile.dox	2007-09-28 11:33:49.000000000 +0100
@@ -190,7 +190,8 @@
 SEARCH_INCLUDES        = YES
 INCLUDE_PATH           = 
 INCLUDE_FILE_PATTERNS  = 
-PREDEFINED             = USE_JPWL
+PREDEFINED             = USE_JPWL \
+                         USE_JPSEC
 EXPAND_AS_DEFINED      = 
 SKIP_FUNCTION_MACROS   = YES
 #---------------------------------------------------------------------------
diff -urN -xdebian -x.svn ./indexer_JPIP/CMakeLists.txt /usr/src/openjpeg/trunk/indexer_JPIP/CMakeLists.txt
--- ./indexer_JPIP/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/indexer_JPIP/CMakeLists.txt	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,5 @@
+# index_create
+
+ADD_EXECUTABLE(index_create
+bio.c cio.c int.c pi.c t2.c tgt.c tcd.c index_create.c jpip.c jp2.c
+)
diff -urN -xdebian -x.svn ./j2kviewer/src/CMakeLists.txt /usr/src/openjpeg/trunk/j2kviewer/src/CMakeLists.txt
--- ./j2kviewer/src/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/j2kviewer/src/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,8 @@
+PROJECT(j2kviewer Java)
+
+ADD_LIBRARY(j2kviewer
+  Exec.java
+  ImageViewer.java
+  MML.java
+  PgmImage.java
+)
diff -urN -xdebian -x.svn ./jp3d/CMakeLists.txt /usr/src/openjpeg/trunk/jp3d/CMakeLists.txt
--- ./jp3d/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/jp3d/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,11 @@
+# Linux makefile for OpenJPEG
+
+#VER_MAJOR = 1
+#VER_MINOR = 0.0
+
+SUBDIRS(
+  libjp3dvm
+  codec
+)
+
+
diff -urN -xdebian -x.svn ./jp3d/codec/CMakeLists.txt /usr/src/openjpeg/trunk/jp3d/codec/CMakeLists.txt
--- ./jp3d/codec/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/jp3d/codec/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,53 @@
+# Build the demo app, small examples
+
+# First thing define the common source:
+SET(common_SRCS
+  convert.c
+  )
+# Then check if getopt is present:
+INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
+SET(DONT_HAVE_GETOPT 1)
+IF(UNIX) #I am pretty sure only *nix sys have this anyway
+  CHECK_INCLUDE_FILE("getopt.h" CMAKE_HAVE_GETOPT_H)
+  # Seems like we need the contrary:
+  IF(CMAKE_HAVE_GETOPT_H)
+    SET(DONT_HAVE_GETOPT 0)
+  ENDIF(CMAKE_HAVE_GETOPT_H)
+ENDIF(UNIX)
+
+# If not getopt was found then add it to the lib:
+IF(DONT_HAVE_GETOPT)
+  ADD_DEFINITIONS(-DDONT_HAVE_GETOPT)
+  SET(common_SRCS
+    ${common_SRCS}
+    compat/getopt.c
+  )
+ENDIF(DONT_HAVE_GETOPT)
+
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${CMAKE_CURRENT_SOURCE_DIR}/../libjp3dvm
+  )
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+#FIND_PACKAGE(TIFF REQUIRED)
+
+# Loop over all executables:
+FOREACH(exe jp3d_to_volume volume_to_jp3d)
+  ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
+  TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjp3dvm) # ${TIFF_LIBRARIES})
+  # On unix you need to link to the math library:
+  IF(UNIX)
+    TARGET_LINK_LIBRARIES(${exe} m)
+  ENDIF(UNIX)
+  # Install exe
+  INSTALL_TARGETS(/bin/ ${exe})
+ENDFOREACH(exe)
+
+
diff -urN -xdebian -x.svn ./jp3d/codec/dirent.h /usr/src/openjpeg/trunk/jp3d/codec/dirent.h
--- ./jp3d/codec/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/jp3d/codec/dirent.h	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,676 @@
+/*
+ * uce-dirent.h - operating system independent dirent implementation
+ * 
+ * Copyright (C) 1998-2002  Toni Ronkko
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * 
+ * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
+ *
+ * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
+ *
+ * $Log: uce-dirent.h,v $
+ * Revision 1.7  2002/05/13 10:48:35  tr
+ * embedded some source code directly to the header so that no source
+ * modules need to be included in the MS Visual C project using the
+ * interface, removed all the dependencies to other headers of the `uce'
+ * library so that the header can be made public
+ *
+ * Revision 1.6  2002/04/12 16:22:04  tr
+ * Unified Compiling Environment (UCE) replaced `std' library
+ *
+ * Revision 1.5  2001/07/20 16:33:40  tr
+ * moved to `std' library and re-named defines accordingly
+ *
+ * Revision 1.4  2001/07/10 16:47:18  tronkko
+ * revised comments
+ *
+ * Revision 1.3  2001/01/11 13:16:43  tr
+ * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
+ *
+ * Revision 1.2  2000/10/08 16:00:41  tr
+ * copy of FreeBSD man page
+ *
+ * Revision 1.1  2000/07/10 05:53:16  tr
+ * Initial revision
+ *
+ * Revision 1.2  1998/07/19 18:29:14  tr
+ * Added error reporting capabilities and some asserts.
+ *
+ * Revision 1.1  1998/07/04 16:27:51  tr
+ * Initial revision
+ *
+ * 
+ * MSVC 1.0 scans automatic dependencies incorrectly when your project
+ * contains this very header.  The problem is that MSVC cannot handle
+ * include directives inside #if..#endif block those are never entered.
+ * Since this header ought to compile in many different operating systems,
+ * there had to be several conditional blocks that are compiled only in
+ * operating systems for what they were designed for.  MSVC 1.0 cannot
+ * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
+ * operating system.  To fix the problem you need to insert DIR.H into
+ * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
+ * Consult manuals for more informaton about the problem.
+ *
+ * Since many UNIX systems have dirent.h we assume to have one also.
+ * However, if your UNIX system does not have dirent.h you can download one
+ * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
+ * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
+ * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
+ * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
+ * HAVE_SYS_NDIR_H according to the files found.
+ */
+#ifndef DIRENT_H
+#define DIRENT_H
+#define DIRENT_H_INCLUDED
+
+/* find out platform */
+#if defined(MSDOS)                             /* MS-DOS */
+#elif defined(__MSDOS__)                       /* Turbo C/Borland */
+# define MSDOS
+#elif defined(__DOS__)                         /* Watcom */
+# define MSDOS
+#endif
+
+#if defined(WIN32)                             /* MS-Windows */
+#elif defined(__NT__)                          /* Watcom */
+# define WIN32
+#elif defined(_WIN32)                          /* Microsoft */
+# define WIN32
+#elif defined(__WIN32__)                       /* Borland */
+# define WIN32
+#endif
+
+/*
+ * See what kind of dirent interface we have unless autoconf has already
+ * determinated that.
+ */
+#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
+# if defined(_MSC_VER)                         /* Microsoft C/C++ */
+    /* no dirent.h */
+# elif defined(__BORLANDC__)                   /* Borland C/C++ */
+#   define HAVE_DIRENT_H
+#   define VOID_CLOSEDIR
+# elif defined(__TURBOC__)                     /* Borland Turbo C */
+    /* no dirent.h */
+# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
+#   define HAVE_DIRECT_H
+# elif defined(__apollo)                       /* Apollo */
+#   define HAVE_SYS_DIR_H
+# elif defined(__hpux)                         /* HP-UX */
+#   define HAVE_DIRENT_H
+# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
+#   error "not implemented"
+# elif defined(__sgi)                          /* Silicon Graphics */
+#   define HAVE_DIRENT_H
+# elif defined(sun) || defined(_sun)           /* Sun Solaris */
+#   define HAVE_DIRENT_H
+# elif defined(__FreeBSD__)                    /* FreeBSD */
+#   define HAVE_DIRENT_H
+# elif defined(__linux__)                      /* Linux */
+#   define HAVE_DIRENT_H
+# elif defined(__GNUC__)                       /* GNU C/C++ */
+#   define HAVE_DIRENT_H
+# else
+#   error "not implemented"
+# endif
+#endif
+
+/* include proper interface headers */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+# ifdef FREEBSD
+#   define NAMLEN(dp) ((int)((dp)->d_namlen))
+# else
+#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+# endif
+
+#elif defined(HAVE_NDIR_H)
+# include <ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_NDIR_H)
+# include <sys/ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIRECT_H)
+# include <direct.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIR_H)
+# include <dir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_DIR_H)
+# include <sys/types.h>
+# include <sys/dir.h>
+# ifndef dirent
+#   define dirent direct
+# endif
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(MSDOS) || defined(WIN32)
+
+  /* figure out type of underlaying directory interface to be used */
+# if defined(WIN32)
+#   define DIRENT_WIN32_INTERFACE
+# elif defined(MSDOS)
+#   define DIRENT_MSDOS_INTERFACE
+# else
+#   error "missing native dirent interface"
+# endif
+
+  /*** WIN32 specifics ***/
+# if defined(DIRENT_WIN32_INTERFACE)
+#   include <windows.h>
+#   if !defined(DIRENT_MAXNAMLEN)
+#     define DIRENT_MAXNAMLEN (MAX_PATH)
+#   endif
+
+
+  /*** MS-DOS specifics ***/
+# elif defined(DIRENT_MSDOS_INTERFACE)
+#   include <dos.h>
+
+    /* Borland defines file length macros in dir.h */
+#   if defined(__BORLANDC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     if !defined(_find_t)
+#       define _find_t find_t
+#     endif
+
+    /* Turbo C defines ffblk structure in dir.h */
+#   elif defined(__TURBOC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     define DIRENT_USE_FFBLK
+
+    /* MSVC */
+#   elif defined(_MSC_VER)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN (12)
+#     endif
+
+    /* Watcom */
+#   elif defined(__WATCOMC__)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       if defined(__OS2__) || defined(__NT__)
+#         define DIRENT_MAXNAMLEN (255)
+#       else
+#         define DIRENT_MAXNAMLEN (12)
+#       endif
+#     endif
+
+#   endif
+# endif
+
+  /*** generic MS-DOS and MS-Windows stuff ***/
+# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
+#   define NAME_MAX DIRENT_MAXNAMLEN
+# endif
+# if NAME_MAX < DIRENT_MAXNAMLEN
+#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
+# endif
+
+
+  /*
+   * Substitute for real dirent structure.  Note that `d_name' field is a
+   * true character array although we have it copied in the implementation
+   * dependent data.  We could save some memory if we had declared `d_name'
+   * as a pointer refering the name within implementation dependent data.
+   * We have not done that since some code may rely on sizeof(d_name) to be
+   * something other than four.  Besides, directory entries are typically so
+   * small that it takes virtually no time to copy them from place to place.
+   */
+  typedef struct dirent {
+    char d_name[NAME_MAX + 1];
+
+    /*** Operating system specific part ***/
+# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
+    WIN32_FIND_DATA data;
+# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
+#   if defined(DIRENT_USE_FFBLK)
+    struct ffblk data;
+#   else
+    struct _find_t data;
+#   endif
+# endif
+  } dirent;
+
+  /* DIR substitute structure containing directory name.  The name is
+   * essential for the operation of ``rewinndir'' function. */
+  typedef struct DIR {
+    char          *dirname;                    /* directory being scanned */
+    dirent        current;                     /* current entry */
+    int           dirent_filled;               /* is current un-processed? */
+
+  /*** Operating system specific part ***/
+#  if defined(DIRENT_WIN32_INTERFACE)
+    HANDLE        search_handle;
+#  elif defined(DIRENT_MSDOS_INTERFACE)
+#  endif
+  } DIR;
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/* supply prototypes for dirent functions */
+static DIR *opendir (const char *dirname);
+static struct dirent *readdir (DIR *dirp);
+static int closedir (DIR *dirp);
+static void rewinddir (DIR *dirp);
+
+/*
+ * Implement dirent interface as static functions so that the user does not
+ * need to change his project in any way to use dirent function.  With this
+ * it is sufficient to include this very header from source modules using
+ * dirent functions and the functions will be pulled in automatically.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+/* use ffblk instead of _find_t if requested */
+#if defined(DIRENT_USE_FFBLK)
+# define _A_ARCH   (FA_ARCH)
+# define _A_HIDDEN (FA_HIDDEN)
+# define _A_NORMAL (0)
+# define _A_RDONLY (FA_RDONLY)
+# define _A_SUBDIR (FA_DIREC)
+# define _A_SYSTEM (FA_SYSTEM)
+# define _A_VOLID  (FA_LABEL)
+# define _dos_findnext(dest) findnext(dest)
+# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
+#endif
+
+static int _initdir (DIR *p);
+static const char *_getdirname (const struct dirent *dp);
+static void _setdirname (struct DIR *dirp);
+
+/*
+ * <function name="opendir">
+ * <intro>open directory stream for reading
+ * <syntax>DIR *opendir (const char *dirname);
+ *
+ * <desc>Open named directory stream for read and return pointer to the
+ * internal working area that is used for retrieving individual directory
+ * entries.  The internal working area has no fields of your interest.
+ *
+ * <ret>Returns a pointer to the internal working area or NULL in case the 
+ * directory stream could not be opened.  Global `errno' variable will set
+ * in case of error as follows:
+ *
+ * <table>
+ * [EACESS  |Permission denied.
+ * [EMFILE  |Too many open files used by the process.
+ * [ENFILE  |Too many open files in system.
+ * [ENOENT  |Directory does not exist.
+ * [ENOMEM  |Insufficient memory.
+ * [ENOTDIR |dirname does not refer to directory.  This value is not
+ *           reliable on MS-DOS and MS-Windows platforms.  Many
+ *           implementations return ENOENT even when the name refers to a
+ *           file.]
+ * </table>
+ * </function>
+ */
+static DIR *opendir(const char *dirname)
+{
+  DIR *dirp;
+  assert (dirname != NULL);
+  
+  dirp = (DIR*)malloc (sizeof (struct DIR));
+  if (dirp != NULL) {
+    char *p;
+    
+    /* allocate room for directory name */
+    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
+    if (dirp->dirname == NULL) {
+      /* failed to duplicate directory name.  errno set by malloc() */
+      free (dirp);
+      return NULL;
+    }
+    /* Copy directory name while appending directory separator and "*.*".
+     * Directory separator is not appended if the name already ends with
+     * drive or directory separator.  Directory separator is assumed to be
+     * '/' or '\' and drive separator is assumed to be ':'. */
+    strcpy (dirp->dirname, dirname);
+    p = strchr (dirp->dirname, '\0');
+    if (dirp->dirname < p  &&
+        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
+    {
+      strcpy (p++, "\\");
+    }
+# ifdef DIRENT_WIN32_INTERFACE
+    strcpy (p, "*"); /*scan files with and without extension in win32*/
+# else
+    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
+# endif
+
+    /* open stream */
+    if (_initdir (dirp) == 0) {
+      /* initialization failed */
+      free (dirp->dirname);
+      free (dirp);
+      return NULL;
+    }
+  }
+  return dirp;
+}
+
+
+/*
+ * <function name="readdir">
+ * <intro>read a directory entry
+ * <syntax>struct dirent *readdir (DIR *dirp);
+ *
+ * <desc>Read individual directory entry and return pointer to a structure
+ * containing the name of the entry.  Individual directory entries returned
+ * include normal files, sub-directories, pseudo-directories "." and ".."
+ * and also volume labels, hidden files and system files in MS-DOS and
+ * MS-Windows.   You might want to use stat(2) function to determinate which
+ * one are you dealing with.  Many dirent implementations already contain
+ * equivalent information in dirent structure but you cannot depend on
+ * this.
+ *
+ * The dirent structure contains several system dependent fields that
+ * generally have no interest to you.  The only interesting one is char
+ * d_name[] that is also portable across different systems.  The d_name
+ * field contains the name of the directory entry without leading path.
+ * While d_name is portable across different systems the actual storage
+ * capacity of d_name varies from system to system and there is no portable
+ * way to find out it at compile time as different systems define the
+ * capacity of d_name with different macros and some systems do not define
+ * capacity at all (besides actual declaration of the field). If you really
+ * need to find out storage capacity of d_name then you might want to try
+ * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
+ * there are many MS-DOS and MS-Windows implementations those do not define
+ * it.  There are also systems that declare d_name as "char d_name[1]" and
+ * then allocate suitable amount of memory at run-time.  Thanks to Alain
+ * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
+ *
+ * This all leads to the fact that it is difficult to allocate space
+ * for the directory names when the very same program is being compiled on
+ * number of operating systems.  Therefore I suggest that you always
+ * allocate space for directory names dynamically.
+ *
+ * <ret>
+ * Returns a pointer to a structure containing name of the directory entry
+ * in `d_name' field or NULL if there was an error.  In case of an error the
+ * global `errno' variable will set as follows:
+ *
+ * <table>
+ * [EBADF  |dir parameter refers to an invalid directory stream.  This value
+ *          is not set reliably on all implementations.]
+ * </table>
+ * </function>
+ */
+static struct dirent *
+readdir (DIR *dirp)
+{
+  assert(dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return NULL;
+  }
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* directory stream was opened/rewound incorrectly or it ended normally */
+    errno = EBADF;
+    return NULL;
+  }
+#endif
+
+  if (dirp->dirent_filled != 0) {
+    /*
+     * Directory entry has already been retrieved and there is no need to
+     * retrieve a new one.  Directory entry will be retrieved in advance
+     * when the user calls readdir function for the first time.  This is so
+     * because real dirent has separate functions for opening and reading
+     * the stream whereas Win32 and DOS dirents open the stream
+     * automatically when we retrieve the first file.  Therefore, we have to
+     * save the first file when opening the stream and later we have to
+     * return the saved entry when the user tries to read the first entry.
+     */
+    dirp->dirent_filled = 0;
+  } else {
+    /* fill in entry and return that */
+#if defined(DIRENT_WIN32_INTERFACE)
+    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
+      /* Last file has been processed or an error occured */
+      FindClose (dirp->search_handle);
+      dirp->search_handle = INVALID_HANDLE_VALUE;
+      errno = ENOENT;
+      return NULL;
+    }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+    if (_dos_findnext (&dirp->current.data) != 0) {
+      /* _dos_findnext and findnext will set errno to ENOENT when no
+       * more entries could be retrieved. */
+      return NULL;
+    }
+# endif
+
+    _setdirname (dirp);
+    assert (dirp->dirent_filled == 0);
+  }
+  return &dirp->current;
+}
+
+
+/*
+ * <function name="closedir">
+ * <intro>close directory stream.
+ * <syntax>int closedir (DIR *dirp);
+ *
+ * <desc>Close directory stream opened by the `opendir' function.  Close of
+ * directory stream invalidates the DIR structure as well as previously read
+ * dirent entry.
+ *
+ * <ret>The function typically returns 0 on success and -1 on failure but
+ * the function may be declared to return void on same systems.  At least
+ * Borland C/C++ and some UNIX implementations use void as a return type.
+ * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
+ * known to return nothing.  The very same definition is made by the GNU
+ * autoconf if you happen to use it.
+ *
+ * The global `errno' variable will set to EBADF in case of error.
+ * </function>
+ */
+static int
+closedir (DIR *dirp)
+{   
+  int retcode = 0;
+
+  /* make sure that dirp points to legal structure */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+ 
+  /* free directory name and search handles */
+  if (dirp->dirname != NULL) free (dirp->dirname);
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      retcode = -1;
+      errno = EBADF;
+    }
+  }
+#endif                     
+
+  /* clear dirp structure to make sure that it cannot be used anymore*/
+  memset (dirp, 0, sizeof (*dirp));
+# if defined(DIRENT_WIN32_INTERFACE)
+  dirp->search_handle = INVALID_HANDLE_VALUE;
+# endif
+
+  free (dirp);
+  return retcode;
+}
+
+
+/*
+ * <function name="rewinddir">
+ * <intro>rewind directory stream to the beginning
+ * <syntax>void rewinddir (DIR *dirp);
+ *
+ * <desc>Rewind directory stream to the beginning so that the next call of
+ * readdir() returns the very first directory entry again.  However, note
+ * that next call of readdir() may not return the same directory entry as it
+ * did in first time.  The directory stream may have been affected by newly
+ * created files.
+ *
+ * Almost every dirent implementation ensure that rewinddir will update
+ * the directory stream to reflect any changes made to the directory entries
+ * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
+ * this if your program depends on the feature.  I know at least one dirent
+ * implementation where you are required to close and re-open the stream to
+ * see the changes.
+ *
+ * <ret>Returns nothing.  If something went wrong while rewinding, you will
+ * notice it later when you try to retrieve the first directory entry.
+ */
+static void
+rewinddir (DIR *dirp)
+{   
+  /* make sure that dirp is legal */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return;
+  }
+  assert (dirp->dirname != NULL);
+  
+  /* close previous stream */
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      errno = EBADF;
+    }
+  }
+#endif
+
+  /* re-open previous stream */
+  if (_initdir (dirp) == 0) {
+    /* initialization failed but we cannot deal with error.  User will notice
+     * error later when she tries to retrieve first directory enty. */
+    /*EMPTY*/;
+  }
+}
+
+
+/*
+ * Open native directory stream object and retrieve first file.
+ * Be sure to close previous stream before opening new one.
+ */
+static int
+_initdir (DIR *dirp)
+{ 
+  assert (dirp != NULL);
+  assert (dirp->dirname != NULL);
+  dirp->dirent_filled = 0;
+
+# if defined(DIRENT_WIN32_INTERFACE)
+  /* Open stream and retrieve first file */
+  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* something went wrong but we don't know what.  GetLastError() could
+     * give us more information about the error, but then we should map
+     * the error code into errno. */
+    errno = ENOENT;
+    return 0;
+  }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+  if (_dos_findfirst (dirp->dirname,
+          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
+          &dirp->current.data) != 0)
+  {
+    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
+     * more entries could be retrieved. */
+    return 0;
+  }
+# endif
+
+  /* initialize DIR and it's first entry */
+  _setdirname (dirp);
+  dirp->dirent_filled = 1;
+  return 1;
+}
+
+
+/*
+ * Return implementation dependent name of the current directory entry.
+ */
+static const char *
+_getdirname (const struct dirent *dp)
+{
+#if defined(DIRENT_WIN32_INTERFACE)
+  return dp->data.cFileName;
+  
+#elif defined(DIRENT_USE_FFBLK)
+  return dp->data.ff_name;
+  
+#else
+  return dp->data.name;
+#endif  
+}
+
+
+/*
+ * Copy name of implementation dependent directory entry to the d_name field.
+ */
+static void
+_setdirname (struct DIR *dirp) {
+  /* make sure that d_name is long enough */
+  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
+  
+  strncpy (dirp->current.d_name,
+      _getdirname (&dirp->current),
+      NAME_MAX);
+  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
+}
+  
+# ifdef __cplusplus
+}
+# endif
+# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+
+#else
+# error "missing dirent interface"
+#endif
+
+
+#endif /*DIRENT_H*/
diff -urN -xdebian -x.svn ./jp3d/libjp3dvm/CMakeLists.txt /usr/src/openjpeg/trunk/jp3d/libjp3dvm/CMakeLists.txt
--- ./jp3d/libjp3dvm/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/jp3d/libjp3dvm/CMakeLists.txt	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,24 @@
+INCLUDE_REGULAR_EXPRESSION("^.*$")
+# Defines the source code for the library
+SET(JP3DVM_SRCS
+bio.c  cio.c  dwt.c  event.c  jp3d.c  jp3d_lib.c  mct.c  mqc.c  openjpeg.c  pi.c  raw.c  t1.c  t1_3d.c  t2.c  tcd.c  tgt.c  volume.c
+)
+
+# Pass proper definition to preprocessor to generate shared lib
+IF(WIN32)
+  IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_EXPORTS)
+  ELSE(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_STATIC)
+  ENDIF(BUILD_SHARED_LIBS)
+ENDIF(WIN32)
+
+# Create the library
+#ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+ADD_LIBRARY(${OPJ_PREFIX}openjp3dvm ${JP3DVM_SRCS})
+
+# Install library
+INSTALL_TARGETS(/lib/ ${OPJ_PREFIX}openjp3dvm)
+
+# Install includes files
+INSTALL_FILES(/include .h)
diff -urN -xdebian -x.svn ./jp3d/libjp3dvm/dirent.h /usr/src/openjpeg/trunk/jp3d/libjp3dvm/dirent.h
--- ./jp3d/libjp3dvm/dirent.h	2007-11-29 18:27:04.000000000 +0000
+++ /usr/src/openjpeg/trunk/jp3d/libjp3dvm/dirent.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,676 +0,0 @@
-/*
- * uce-dirent.h - operating system independent dirent implementation
- * 
- * Copyright (C) 1998-2002  Toni Ronkko
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * ``Software''), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- * 
- * 
- * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
- *
- * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
- *
- * $Log: uce-dirent.h,v $
- * Revision 1.7  2002/05/13 10:48:35  tr
- * embedded some source code directly to the header so that no source
- * modules need to be included in the MS Visual C project using the
- * interface, removed all the dependencies to other headers of the `uce'
- * library so that the header can be made public
- *
- * Revision 1.6  2002/04/12 16:22:04  tr
- * Unified Compiling Environment (UCE) replaced `std' library
- *
- * Revision 1.5  2001/07/20 16:33:40  tr
- * moved to `std' library and re-named defines accordingly
- *
- * Revision 1.4  2001/07/10 16:47:18  tronkko
- * revised comments
- *
- * Revision 1.3  2001/01/11 13:16:43  tr
- * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
- *
- * Revision 1.2  2000/10/08 16:00:41  tr
- * copy of FreeBSD man page
- *
- * Revision 1.1  2000/07/10 05:53:16  tr
- * Initial revision
- *
- * Revision 1.2  1998/07/19 18:29:14  tr
- * Added error reporting capabilities and some asserts.
- *
- * Revision 1.1  1998/07/04 16:27:51  tr
- * Initial revision
- *
- * 
- * MSVC 1.0 scans automatic dependencies incorrectly when your project
- * contains this very header.  The problem is that MSVC cannot handle
- * include directives inside #if..#endif block those are never entered.
- * Since this header ought to compile in many different operating systems,
- * there had to be several conditional blocks that are compiled only in
- * operating systems for what they were designed for.  MSVC 1.0 cannot
- * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
- * operating system.  To fix the problem you need to insert DIR.H into
- * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
- * Consult manuals for more informaton about the problem.
- *
- * Since many UNIX systems have dirent.h we assume to have one also.
- * However, if your UNIX system does not have dirent.h you can download one
- * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
- * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
- * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
- * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
- * HAVE_SYS_NDIR_H according to the files found.
- */
-#ifndef DIRENT_H
-#define DIRENT_H
-#define DIRENT_H_INCLUDED
-
-/* find out platform */
-#if defined(MSDOS)                             /* MS-DOS */
-#elif defined(__MSDOS__)                       /* Turbo C/Borland */
-# define MSDOS
-#elif defined(__DOS__)                         /* Watcom */
-# define MSDOS
-#endif
-
-#if defined(WIN32)                             /* MS-Windows */
-#elif defined(__NT__)                          /* Watcom */
-# define WIN32
-#elif defined(_WIN32)                          /* Microsoft */
-# define WIN32
-#elif defined(__WIN32__)                       /* Borland */
-# define WIN32
-#endif
-
-/*
- * See what kind of dirent interface we have unless autoconf has already
- * determinated that.
- */
-#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
-# if defined(_MSC_VER)                         /* Microsoft C/C++ */
-    /* no dirent.h */
-# elif defined(__BORLANDC__)                   /* Borland C/C++ */
-#   define HAVE_DIRENT_H
-#   define VOID_CLOSEDIR
-# elif defined(__TURBOC__)                     /* Borland Turbo C */
-    /* no dirent.h */
-# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
-#   define HAVE_DIRECT_H
-# elif defined(__apollo)                       /* Apollo */
-#   define HAVE_SYS_DIR_H
-# elif defined(__hpux)                         /* HP-UX */
-#   define HAVE_DIRENT_H
-# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
-#   error "not implemented"
-# elif defined(__sgi)                          /* Silicon Graphics */
-#   define HAVE_DIRENT_H
-# elif defined(sun) || defined(_sun)           /* Sun Solaris */
-#   define HAVE_DIRENT_H
-# elif defined(__FreeBSD__)                    /* FreeBSD */
-#   define HAVE_DIRENT_H
-# elif defined(__linux__)                      /* Linux */
-#   define HAVE_DIRENT_H
-# elif defined(__GNUC__)                       /* GNU C/C++ */
-#   define HAVE_DIRENT_H
-# else
-#   error "not implemented"
-# endif
-#endif
-
-/* include proper interface headers */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-# ifdef FREEBSD
-#   define NAMLEN(dp) ((int)((dp)->d_namlen))
-# else
-#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
-# endif
-
-#elif defined(HAVE_NDIR_H)
-# include <ndir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_SYS_NDIR_H)
-# include <sys/ndir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_DIRECT_H)
-# include <direct.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_DIR_H)
-# include <dir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_SYS_DIR_H)
-# include <sys/types.h>
-# include <sys/dir.h>
-# ifndef dirent
-#   define dirent direct
-# endif
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(MSDOS) || defined(WIN32)
-
-  /* figure out type of underlaying directory interface to be used */
-# if defined(WIN32)
-#   define DIRENT_WIN32_INTERFACE
-# elif defined(MSDOS)
-#   define DIRENT_MSDOS_INTERFACE
-# else
-#   error "missing native dirent interface"
-# endif
-
-  /*** WIN32 specifics ***/
-# if defined(DIRENT_WIN32_INTERFACE)
-#   include <windows.h>
-#   if !defined(DIRENT_MAXNAMLEN)
-#     define DIRENT_MAXNAMLEN (MAX_PATH)
-#   endif
-
-
-  /*** MS-DOS specifics ***/
-# elif defined(DIRENT_MSDOS_INTERFACE)
-#   include <dos.h>
-
-    /* Borland defines file length macros in dir.h */
-#   if defined(__BORLANDC__)
-#     include <dir.h>
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
-#     endif
-#     if !defined(_find_t)
-#       define _find_t find_t
-#     endif
-
-    /* Turbo C defines ffblk structure in dir.h */
-#   elif defined(__TURBOC__)
-#     include <dir.h>
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
-#     endif
-#     define DIRENT_USE_FFBLK
-
-    /* MSVC */
-#   elif defined(_MSC_VER)
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN (12)
-#     endif
-
-    /* Watcom */
-#   elif defined(__WATCOMC__)
-#     if !defined(DIRENT_MAXNAMLEN)
-#       if defined(__OS2__) || defined(__NT__)
-#         define DIRENT_MAXNAMLEN (255)
-#       else
-#         define DIRENT_MAXNAMLEN (12)
-#       endif
-#     endif
-
-#   endif
-# endif
-
-  /*** generic MS-DOS and MS-Windows stuff ***/
-# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
-#   define NAME_MAX DIRENT_MAXNAMLEN
-# endif
-# if NAME_MAX < DIRENT_MAXNAMLEN
-#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
-# endif
-
-
-  /*
-   * Substitute for real dirent structure.  Note that `d_name' field is a
-   * true character array although we have it copied in the implementation
-   * dependent data.  We could save some memory if we had declared `d_name'
-   * as a pointer refering the name within implementation dependent data.
-   * We have not done that since some code may rely on sizeof(d_name) to be
-   * something other than four.  Besides, directory entries are typically so
-   * small that it takes virtually no time to copy them from place to place.
-   */
-  typedef struct dirent {
-    char d_name[NAME_MAX + 1];
-
-    /*** Operating system specific part ***/
-# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
-    WIN32_FIND_DATA data;
-# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
-#   if defined(DIRENT_USE_FFBLK)
-    struct ffblk data;
-#   else
-    struct _find_t data;
-#   endif
-# endif
-  } dirent;
-
-  /* DIR substitute structure containing directory name.  The name is
-   * essential for the operation of ``rewinndir'' function. */
-  typedef struct DIR {
-    char          *dirname;                    /* directory being scanned */
-    dirent        current;                     /* current entry */
-    int           dirent_filled;               /* is current un-processed? */
-
-  /*** Operating system specific part ***/
-#  if defined(DIRENT_WIN32_INTERFACE)
-    HANDLE        search_handle;
-#  elif defined(DIRENT_MSDOS_INTERFACE)
-#  endif
-  } DIR;
-
-# ifdef __cplusplus
-extern "C" {
-# endif
-
-/* supply prototypes for dirent functions */
-static DIR *opendir (const char *dirname);
-static struct dirent *readdir (DIR *dirp);
-static int closedir (DIR *dirp);
-static void rewinddir (DIR *dirp);
-
-/*
- * Implement dirent interface as static functions so that the user does not
- * need to change his project in any way to use dirent function.  With this
- * it is sufficient to include this very header from source modules using
- * dirent functions and the functions will be pulled in automatically.
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-
-/* use ffblk instead of _find_t if requested */
-#if defined(DIRENT_USE_FFBLK)
-# define _A_ARCH   (FA_ARCH)
-# define _A_HIDDEN (FA_HIDDEN)
-# define _A_NORMAL (0)
-# define _A_RDONLY (FA_RDONLY)
-# define _A_SUBDIR (FA_DIREC)
-# define _A_SYSTEM (FA_SYSTEM)
-# define _A_VOLID  (FA_LABEL)
-# define _dos_findnext(dest) findnext(dest)
-# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
-#endif
-
-static int _initdir (DIR *p);
-static const char *_getdirname (const struct dirent *dp);
-static void _setdirname (struct DIR *dirp);
-
-/*
- * <function name="opendir">
- * <intro>open directory stream for reading
- * <syntax>DIR *opendir (const char *dirname);
- *
- * <desc>Open named directory stream for read and return pointer to the
- * internal working area that is used for retrieving individual directory
- * entries.  The internal working area has no fields of your interest.
- *
- * <ret>Returns a pointer to the internal working area or NULL in case the 
- * directory stream could not be opened.  Global `errno' variable will set
- * in case of error as follows:
- *
- * <table>
- * [EACESS  |Permission denied.
- * [EMFILE  |Too many open files used by the process.
- * [ENFILE  |Too many open files in system.
- * [ENOENT  |Directory does not exist.
- * [ENOMEM  |Insufficient memory.
- * [ENOTDIR |dirname does not refer to directory.  This value is not
- *           reliable on MS-DOS and MS-Windows platforms.  Many
- *           implementations return ENOENT even when the name refers to a
- *           file.]
- * </table>
- * </function>
- */
-static DIR *opendir(const char *dirname)
-{
-  DIR *dirp;
-  assert (dirname != NULL);
-  
-  dirp = (DIR*)malloc (sizeof (struct DIR));
-  if (dirp != NULL) {
-    char *p;
-    
-    /* allocate room for directory name */
-    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
-    if (dirp->dirname == NULL) {
-      /* failed to duplicate directory name.  errno set by malloc() */
-      free (dirp);
-      return NULL;
-    }
-    /* Copy directory name while appending directory separator and "*.*".
-     * Directory separator is not appended if the name already ends with
-     * drive or directory separator.  Directory separator is assumed to be
-     * '/' or '\' and drive separator is assumed to be ':'. */
-    strcpy (dirp->dirname, dirname);
-    p = strchr (dirp->dirname, '\0');
-    if (dirp->dirname < p  &&
-        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
-    {
-      strcpy (p++, "\\");
-    }
-# ifdef DIRENT_WIN32_INTERFACE
-    strcpy (p, "*"); /*scan files with and without extension in win32*/
-# else
-    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
-# endif
-
-    /* open stream */
-    if (_initdir (dirp) == 0) {
-      /* initialization failed */
-      free (dirp->dirname);
-      free (dirp);
-      return NULL;
-    }
-  }
-  return dirp;
-}
-
-
-/*
- * <function name="readdir">
- * <intro>read a directory entry
- * <syntax>struct dirent *readdir (DIR *dirp);
- *
- * <desc>Read individual directory entry and return pointer to a structure
- * containing the name of the entry.  Individual directory entries returned
- * include normal files, sub-directories, pseudo-directories "." and ".."
- * and also volume labels, hidden files and system files in MS-DOS and
- * MS-Windows.   You might want to use stat(2) function to determinate which
- * one are you dealing with.  Many dirent implementations already contain
- * equivalent information in dirent structure but you cannot depend on
- * this.
- *
- * The dirent structure contains several system dependent fields that
- * generally have no interest to you.  The only interesting one is char
- * d_name[] that is also portable across different systems.  The d_name
- * field contains the name of the directory entry without leading path.
- * While d_name is portable across different systems the actual storage
- * capacity of d_name varies from system to system and there is no portable
- * way to find out it at compile time as different systems define the
- * capacity of d_name with different macros and some systems do not define
- * capacity at all (besides actual declaration of the field). If you really
- * need to find out storage capacity of d_name then you might want to try
- * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
- * there are many MS-DOS and MS-Windows implementations those do not define
- * it.  There are also systems that declare d_name as "char d_name[1]" and
- * then allocate suitable amount of memory at run-time.  Thanks to Alain
- * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
- *
- * This all leads to the fact that it is difficult to allocate space
- * for the directory names when the very same program is being compiled on
- * number of operating systems.  Therefore I suggest that you always
- * allocate space for directory names dynamically.
- *
- * <ret>
- * Returns a pointer to a structure containing name of the directory entry
- * in `d_name' field or NULL if there was an error.  In case of an error the
- * global `errno' variable will set as follows:
- *
- * <table>
- * [EBADF  |dir parameter refers to an invalid directory stream.  This value
- *          is not set reliably on all implementations.]
- * </table>
- * </function>
- */
-static struct dirent *
-readdir (DIR *dirp)
-{
-  assert(dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return NULL;
-  }
-
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
-    /* directory stream was opened/rewound incorrectly or it ended normally */
-    errno = EBADF;
-    return NULL;
-  }
-#endif
-
-  if (dirp->dirent_filled != 0) {
-    /*
-     * Directory entry has already been retrieved and there is no need to
-     * retrieve a new one.  Directory entry will be retrieved in advance
-     * when the user calls readdir function for the first time.  This is so
-     * because real dirent has separate functions for opening and reading
-     * the stream whereas Win32 and DOS dirents open the stream
-     * automatically when we retrieve the first file.  Therefore, we have to
-     * save the first file when opening the stream and later we have to
-     * return the saved entry when the user tries to read the first entry.
-     */
-    dirp->dirent_filled = 0;
-  } else {
-    /* fill in entry and return that */
-#if defined(DIRENT_WIN32_INTERFACE)
-    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
-      /* Last file has been processed or an error occured */
-      FindClose (dirp->search_handle);
-      dirp->search_handle = INVALID_HANDLE_VALUE;
-      errno = ENOENT;
-      return NULL;
-    }
-
-# elif defined(DIRENT_MSDOS_INTERFACE)
-    if (_dos_findnext (&dirp->current.data) != 0) {
-      /* _dos_findnext and findnext will set errno to ENOENT when no
-       * more entries could be retrieved. */
-      return NULL;
-    }
-# endif
-
-    _setdirname (dirp);
-    assert (dirp->dirent_filled == 0);
-  }
-  return &dirp->current;
-}
-
-
-/*
- * <function name="closedir">
- * <intro>close directory stream.
- * <syntax>int closedir (DIR *dirp);
- *
- * <desc>Close directory stream opened by the `opendir' function.  Close of
- * directory stream invalidates the DIR structure as well as previously read
- * dirent entry.
- *
- * <ret>The function typically returns 0 on success and -1 on failure but
- * the function may be declared to return void on same systems.  At least
- * Borland C/C++ and some UNIX implementations use void as a return type.
- * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
- * known to return nothing.  The very same definition is made by the GNU
- * autoconf if you happen to use it.
- *
- * The global `errno' variable will set to EBADF in case of error.
- * </function>
- */
-static int
-closedir (DIR *dirp)
-{   
-  int retcode = 0;
-
-  /* make sure that dirp points to legal structure */
-  assert (dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return -1;
-  }
- 
-  /* free directory name and search handles */
-  if (dirp->dirname != NULL) free (dirp->dirname);
-
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
-    if (FindClose (dirp->search_handle) == FALSE) {
-      /* Unknown error */
-      retcode = -1;
-      errno = EBADF;
-    }
-  }
-#endif                     
-
-  /* clear dirp structure to make sure that it cannot be used anymore*/
-  memset (dirp, 0, sizeof (*dirp));
-# if defined(DIRENT_WIN32_INTERFACE)
-  dirp->search_handle = INVALID_HANDLE_VALUE;
-# endif
-
-  free (dirp);
-  return retcode;
-}
-
-
-/*
- * <function name="rewinddir">
- * <intro>rewind directory stream to the beginning
- * <syntax>void rewinddir (DIR *dirp);
- *
- * <desc>Rewind directory stream to the beginning so that the next call of
- * readdir() returns the very first directory entry again.  However, note
- * that next call of readdir() may not return the same directory entry as it
- * did in first time.  The directory stream may have been affected by newly
- * created files.
- *
- * Almost every dirent implementation ensure that rewinddir will update
- * the directory stream to reflect any changes made to the directory entries
- * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
- * this if your program depends on the feature.  I know at least one dirent
- * implementation where you are required to close and re-open the stream to
- * see the changes.
- *
- * <ret>Returns nothing.  If something went wrong while rewinding, you will
- * notice it later when you try to retrieve the first directory entry.
- */
-static void
-rewinddir (DIR *dirp)
-{   
-  /* make sure that dirp is legal */
-  assert (dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return;
-  }
-  assert (dirp->dirname != NULL);
-  
-  /* close previous stream */
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
-    if (FindClose (dirp->search_handle) == FALSE) {
-      /* Unknown error */
-      errno = EBADF;
-    }
-  }
-#endif
-
-  /* re-open previous stream */
-  if (_initdir (dirp) == 0) {
-    /* initialization failed but we cannot deal with error.  User will notice
-     * error later when she tries to retrieve first directory enty. */
-    /*EMPTY*/;
-  }
-}
-
-
-/*
- * Open native directory stream object and retrieve first file.
- * Be sure to close previous stream before opening new one.
- */
-static int
-_initdir (DIR *dirp)
-{ 
-  assert (dirp != NULL);
-  assert (dirp->dirname != NULL);
-  dirp->dirent_filled = 0;
-
-# if defined(DIRENT_WIN32_INTERFACE)
-  /* Open stream and retrieve first file */
-  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
-  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
-    /* something went wrong but we don't know what.  GetLastError() could
-     * give us more information about the error, but then we should map
-     * the error code into errno. */
-    errno = ENOENT;
-    return 0;
-  }
-
-# elif defined(DIRENT_MSDOS_INTERFACE)
-  if (_dos_findfirst (dirp->dirname,
-          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
-          &dirp->current.data) != 0)
-  {
-    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
-     * more entries could be retrieved. */
-    return 0;
-  }
-# endif
-
-  /* initialize DIR and it's first entry */
-  _setdirname (dirp);
-  dirp->dirent_filled = 1;
-  return 1;
-}
-
-
-/*
- * Return implementation dependent name of the current directory entry.
- */
-static const char *
-_getdirname (const struct dirent *dp)
-{
-#if defined(DIRENT_WIN32_INTERFACE)
-  return dp->data.cFileName;
-  
-#elif defined(DIRENT_USE_FFBLK)
-  return dp->data.ff_name;
-  
-#else
-  return dp->data.name;
-#endif  
-}
-
-
-/*
- * Copy name of implementation dependent directory entry to the d_name field.
- */
-static void
-_setdirname (struct DIR *dirp) {
-  /* make sure that d_name is long enough */
-  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
-  
-  strncpy (dirp->current.d_name,
-      _getdirname (&dirp->current),
-      NAME_MAX);
-  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
-}
-  
-# ifdef __cplusplus
-}
-# endif
-# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
-
-#else
-# error "missing dirent interface"
-#endif
-
-
-#endif /*DIRENT_H*/
diff -urN -xdebian -x.svn ./jpwl/CMakeLists.txt /usr/src/openjpeg/trunk/jpwl/CMakeLists.txt
--- ./jpwl/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/jpwl/CMakeLists.txt	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,55 @@
+# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
+
+ADD_DEFINITIONS(-DUSE_JPWL)
+
+SET(OPJ_SRCS 
+../libopenjpeg/bio.c 
+../libopenjpeg/cio.c 
+../libopenjpeg/dwt.c 
+../libopenjpeg/event.c 
+../libopenjpeg/image.c 
+../libopenjpeg/j2k.c 
+../libopenjpeg/j2k_lib.c 
+../libopenjpeg/jp2.c 
+../libopenjpeg/jpt.c 
+../libopenjpeg/mct.c 
+../libopenjpeg/mqc.c 
+../libopenjpeg/openjpeg.c 
+../libopenjpeg/pi.c 
+../libopenjpeg/raw.c 
+../libopenjpeg/t1.c 
+../libopenjpeg/t2.c 
+../libopenjpeg/tcd.c 
+../libopenjpeg/tgt.c
+)
+SET(JPWL_SRCS crc.c jpwl.c jpwl_lib.c rs.c)
+
+ADD_LIBRARY(openjpeg_JPWL ${JPWL_SRCS} ${OPJ_SRCS})
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+FIND_PACKAGE(TIFF REQUIRED)
+
+ADD_EXECUTABLE(JPWL_j2k_to_image
+../codec/convert.c ../codec/j2k_to_image.c
+)
+TARGET_LINK_LIBRARIES(JPWL_j2k_to_image openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_j2k_to_image m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(JPWL_image_to_j2k
+../codec/convert.c ../codec/image_to_j2k.c)
+TARGET_LINK_LIBRARIES(JPWL_image_to_j2k openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_image_to_j2k m)
+ENDIF(UNIX)
+
diff -urN -xdebian -x.svn ./jpwl/jpwl.c /usr/src/openjpeg/trunk/jpwl/jpwl.c
--- ./jpwl/jpwl.c	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/jpwl.c	2007-12-01 18:40:47.000000000 +0000
@@ -29,20 +29,20 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef USE_JPWL
-
 #include "../libopenjpeg/opj_includes.h"
 
+#ifdef USE_JPWL
+
 /** @defgroup JPWL JPWL - JPEG-2000 Part11 (JPWL) codestream manager */
 /*@{*/
 
 /** @name Local static variables */
 /*@{*/
 
-/** position of markers to insert */
-static jpwl_marker_t jwmarker[JPWL_MAX_NO_MARKERS]; 
-/** number of prepared markers */
+/** number of JPWL prepared markers */
 static int jwmarker_num;
+/** properties of JPWL markers to insert */
+static jpwl_marker_t jwmarker[JPWL_MAX_NO_MARKERS]; 
 
 /*@}*/
 
@@ -88,42 +88,114 @@
 int jpwl_markcomp(const void *arg1, const void *arg2);
 
 /** write an EPB MS to a buffer
+@param j2k J2K compressor handle
 @param epbmark pointer to the EPB MS
 @param buf pointer to the memory buffer
 */
-void jpwl_epb_write(jpwl_epb_ms_t *epbmark, unsigned char *buf);
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf);
 
 /** write an EPC MS to a buffer
+@param j2k J2K compressor handle
 @param epcmark pointer to the EPC MS
 @param buf pointer to the memory buffer
 */
-void jpwl_epc_write(jpwl_epc_ms_t *epcmark, unsigned char *buf);
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epcmark, unsigned char *buf);
 
 /** write an ESD MS to a buffer
+@param j2k J2K compressor handle
 @param esdmark pointer to the ESD MS
 @param buf pointer to the memory buffer
 */
-void jpwl_esd_write(jpwl_esd_ms_t *esdmark, unsigned char *buf);
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esdmark, unsigned char *buf);
 
 /*-----------------------------------------------------------------*/
 
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+
+	int mm;
+
+	/* let's reset some settings */
+
+	/* clear the existing markers */
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		switch (jwmarker[mm].id) {
+
+		case J2K_MS_EPB:
+			free(jwmarker[mm].epbmark);
+			break;
+
+		case J2K_MS_EPC:
+			free(jwmarker[mm].epcmark);
+			break;
+
+		case J2K_MS_ESD:
+			free(jwmarker[mm].esdmark);
+			break;
+
+		case J2K_MS_RED:
+			free(jwmarker[mm].redmark);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* clear the marker structure array */
+	memset(jwmarker, 0, sizeof(jpwl_marker_t) * JPWL_MAX_NO_MARKERS);
+
+	/* no more markers in the list */
+	jwmarker_num = 0;
+
+	/* let's begin creating a marker list, according to user wishes */
+	jpwl_prepare_marks(j2k, cio, image);
+
+	/* now we dump the JPWL markers on the codestream */
+	jpwl_dump_marks(j2k, cio, image);
+
+	/* do not know exactly what is this for,
+	but it gets called during index creation */
+	j2k->pos_correction = 0;
+
+}
+
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
+
+	if (!cstr_info)
+		return;
+
+	/* expand the list? */
+	if ((cstr_info->marknum + 1) > cstr_info->maxmarknum) {
+		cstr_info->maxmarknum = 100 + (int) ((float) cstr_info->maxmarknum * 1.0F);
+		cstr_info->marker = opj_realloc(cstr_info->marker, cstr_info->maxmarknum);
+	}
+
+	/* add the marker */
+	cstr_info->marker[cstr_info->marknum].type = type;
+	cstr_info->marker[cstr_info->marknum].pos = pos;
+	cstr_info->marker[cstr_info->marknum].len = len;
+	cstr_info->marknum++;
+
+}
+
 void jpwl_prepare_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
 
 	unsigned short int socsiz_len = 0;
-	int ciopos = cio_tell(cio);
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
 	unsigned char *socp = NULL;
 
-	int tileno, tilespec, hprot, sens, pprot, packspec, lastileno, packno;
+	int tileno, acc_tpno, tpno, tilespec, hprot, sens, pprot, packspec, lastileno, packno;
 
 	jpwl_epb_ms_t *epb_mark;
 	jpwl_epc_ms_t *epc_mark;
 	jpwl_esd_ms_t *esd_mark;
 
-	/* find SOC + SIZ length */
+	/* find (SOC + SIZ) length */
 	/* I assume SIZ is always the first marker after SOC */
-	cio_seek(cio, 4);
+	cio_seek(cio, soc_pos + 4);
 	socsiz_len = (unsigned short int) cio_read(cio, 2) + 4; /* add the 2 marks length itself */
-	cio_seek(cio, 0);
+	cio_seek(cio, soc_pos + 0);
 	socp = cio_getbp(cio); /* pointer to SOC */
 
 	/* 
@@ -142,7 +214,7 @@
 		if (epc_mark) {
 			jwmarker[jwmarker_num].id = J2K_MS_EPC; /* its type */
 			jwmarker[jwmarker_num].epcmark = epc_mark; /* the EPC */
-			jwmarker[jwmarker_num].pos = socsiz_len; /* after SIZ */
+			jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
 			jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.1; /* not so first */
 			jwmarker[jwmarker_num].len = epc_mark->Lepc; /* its length */
 			jwmarker[jwmarker_num].len_ready = true; /* ready */
@@ -179,7 +251,7 @@
 			(unsigned char) j2k->cp->sens_MH, /* sensitivity method */
 			j2k->cp->sens_size, /* sensitivity size */
 			-1, /* this ESD is in main header */
-			0 /*j2k->image_info->num*/, /* number of packets in codestream */
+			0 /*j2k->cstr_info->num*/, /* number of packets in codestream */
 			NULL /*sensval*/ /* pointer to sensitivity data of packets */
 			)) {
 			
@@ -187,7 +259,7 @@
 			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
 				jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
 				jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
-				jwmarker[jwmarker_num].pos = socsiz_len; /* we choose to place it after SIZ */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* we choose to place it after SIZ */
 				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
 				jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
 				jwmarker[jwmarker_num].len_ready = true; /* not ready, yet */
@@ -212,89 +284,107 @@
 	/* 
 	 ESD MSs for Tile Part Headers 
 	*/
-	/* cycle through TPHs */
+	/* cycle through tiles */
 	sens = -1; /* default spec: no ESD */
 	tilespec = 0; /* first tile spec */
-	for (tileno = 0; tileno < j2k->image_info->tw * j2k->image_info->th; tileno++) {
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
 
-		int sot_len, Psot, Psotp, mm;
-		unsigned long sot_pos, post_sod_pos;
-
-		unsigned long int left_THmarks_len;
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
 
-		sot_pos = j2k->image_info->tile[tileno].start_pos;
-		cio_seek(cio, sot_pos + 2); 
-		sot_len = cio_read(cio, 2); /* SOT Len */
-		cio_skip(cio, 2);
-		Psotp = cio_tell(cio);
-		Psot = cio_read(cio, 4); /* tile length */
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) {
+	
+			int sot_len, Psot, Psotp, mm;
+			unsigned long sot_pos, post_sod_pos;
 
-		post_sod_pos = j2k->image_info->tile[tileno].end_header + 1;
-		left_THmarks_len = post_sod_pos - sot_pos;
+			unsigned long int left_THmarks_len;
 
-		/* add all the lengths of the markers which are len-ready and stay within SOT and SOD */
-		for (mm = 0; mm < jwmarker_num; mm++) {
-			if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
-				if (jwmarker[mm].len_ready)
-					left_THmarks_len += jwmarker[mm].len + 2;
-				else {
-					opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
-						jwmarker[mm].id, jwmarker[mm].dpos);				
-					exit(1);
+			/******* sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/******* post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - sot_pos;
+
+			/* add all the lengths of the markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
 				}
 			}
-		}
 
-		if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == tileno))
-			/* we got a specification from this tile onwards */
-			sens = j2k->cp->sens_TPH[tilespec++];
-	
-		/* must this TPH have an ESD MS? */
-		if (j2k->cp->esd_on && (sens >= 0)) {
+			/******* if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile onwards */
+				sens = j2k->cp->sens_TPH[tilespec++];
+		
+			/* must this TPH have an ESD MS? */
+			if (j2k->cp->esd_on && (sens >= 0)) {
 
-			/* Create the ESD */
-			if (esd_mark = jpwl_esd_create(
-				j2k, /* this encoder handle */
-				-1, /* we are averaging over all components */
-				(unsigned char) j2k->cp->sens_range, /* range method */
-				(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing size */
-				(unsigned char) sens, /* sensitivity method */
-				j2k->cp->sens_size, /* sensitivity value size */
-				tileno, /* this ESD is in a tile */
-				0, /* number of packets in codestream */
-				NULL /* pointer to sensitivity data of packets */
-				)) {
-				
-				/* Add this marker to the 'insertanda' list */
-				if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
-					jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
-					jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
-					jwmarker[jwmarker_num].pos = j2k->image_info->tile[tileno].start_pos + sot_len + 2; /* after SOT */
-					jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
-					jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
-					jwmarker[jwmarker_num].len_ready = true; /* ready, yet */
-					jwmarker[jwmarker_num].pos_ready = true; /* ready */
-					jwmarker[jwmarker_num].parms_ready = true; /* not ready */
-					jwmarker[jwmarker_num].data_ready = false; /* ready */
-					jwmarker_num++;
-				}
+				/* Create the ESD */
+				if (esd_mark = jpwl_esd_create(
+					j2k, /* this encoder handle */
+					-1, /* we are averaging over all components */
+					(unsigned char) j2k->cp->sens_range, /* range method */
+					(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing size */
+					(unsigned char) sens, /* sensitivity method */
+					j2k->cp->sens_size, /* sensitivity value size */
+					tileno, /* this ESD is in a tile */
+					0, /* number of packets in codestream */
+					NULL /* pointer to sensitivity data of packets */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
+						jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
+						jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready, yet */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* not ready */
+						jwmarker[jwmarker_num].data_ready = false; /* ready */
+						jwmarker_num++;
+					}
 
-				/* update Psot of the tile  */
-				cio_seek(cio, Psotp);
-				cio_write(cio, Psot + esd_mark->Lesd + 2, 4);
+					/* update Psot of the tile  */
+					cio_seek(cio, Psotp);
+					cio_write(cio, Psot + esd_mark->Lesd + 2, 4);
 
-				opj_event_msg(j2k->cinfo, EVT_INFO,
-					"TPH ESDs: tile %02d, method %d\n",
-					tileno,
-					sens
-					);
-
-			} else {
-				/* ooops, problems */
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d\n", tileno);				
-			};
+					opj_event_msg(j2k->cinfo, EVT_INFO,
+						/******* "TPH ESDs: tile %02d, method %d\n", */
+						"TPH ESDs: tile %02d, part %02d, method %d\n",
+						/******* tileno, */
+						tileno, tpno,
+						sens
+						);
 
-		}				
+				} else {
+					/* ooops, problems */
+					/***** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d\n", tileno); */
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d,%d\n", tileno, tpno);
+				};
+
+			}
+			
+		}
 	
 	};
 
@@ -307,7 +397,7 @@
 		int mm;
 
 		/* position of SOT */
-		unsigned int sot_pos = j2k->image_info->main_head_end + 1;
+		unsigned int sot_pos = j2k->cstr_info->main_head_end + 1;
 
 		/* how much space is there between end of SIZ and beginning of SOT? */
 		int left_MHmarks_len = sot_pos - socsiz_len;
@@ -341,7 +431,7 @@
 			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
 				jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
 				jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
-				jwmarker[jwmarker_num].pos = socsiz_len; /* after SIZ */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
 				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
 				jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
 				jwmarker[jwmarker_num].len_ready = true; /* ready */
@@ -371,200 +461,245 @@
 	lastileno = 0;
 	packspec = 0;
 	pprot = -1;
-	for (tileno = 0; tileno < j2k->image_info->tw * j2k->image_info->th; tileno++) {
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
 
-		int sot_len, Psot, Psotp, mm, epb_index = 0, prot_len = 0;
-		unsigned long sot_pos, post_sod_pos;
-		unsigned long int left_THmarks_len, epbs_len = 0;
-		int startpack = 0, stoppack = j2k->image_info->num;
-		jpwl_epb_ms_t *tph_epb = NULL;
-
-		sot_pos = j2k->image_info->tile[tileno].start_pos;
-		cio_seek(cio, sot_pos + 2); 
-		sot_len = cio_read(cio, 2); /* SOT Len */
-		cio_skip(cio, 2);
-		Psotp = cio_tell(cio);
-		Psot = cio_read(cio, 4); /* tile length */
-
-		/* a-priori length of the data dwelling between SOT and SOD */
-		post_sod_pos = j2k->image_info->tile[tileno].end_header + 1;
-		left_THmarks_len = post_sod_pos - (sot_pos + sot_len + 2);
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
 
-		/* add all the lengths of the JPWL markers which are len-ready and stay within SOT and SOD */
-		for (mm = 0; mm < jwmarker_num; mm++) {
-			if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
-				if (jwmarker[mm].len_ready)
-					left_THmarks_len += jwmarker[mm].len + 2;
-				else {
-					opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
-						jwmarker[mm].id, jwmarker[mm].dpos);				
-					exit(1);
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) { 
+		
+			int sot_len, Psot, Psotp, mm, epb_index = 0, prot_len = 0;
+			unsigned long sot_pos, post_sod_pos;
+			unsigned long int left_THmarks_len, epbs_len = 0;
+			int startpack = 0, stoppack = j2k->cstr_info->packno;
+			int first_tp_pack, last_tp_pack;
+			jpwl_epb_ms_t *tph_epb = NULL;
+
+			/****** sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/* a-priori length of the data dwelling between SOT and SOD */
+			/****** post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - (sot_pos + sot_len + 2);
+
+			/* add all the lengths of the JPWL markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
 				}
 			}
-		}
 
-		if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == tileno))
-			/* we got a specification from this tile onwards */
-			hprot = j2k->cp->hprot_TPH[tilespec++];
-	
-		/* must this TPH have an EPB MS? */
-		if (j2k->cp->epb_on && (hprot > 0)) {
-
-			/* Create the EPB */
-			if (epb_mark = jpwl_epb_create(
-				j2k, /* this encoder handle */
-				false, /* is it the latest? in TPH, no for now (if huge data size in TPH, we'd need more) */
-				true, /* is it packed? yes for now */
-				tileno, /* we are in TPH */
-				epb_index++, /* its index is 0 (first) */
-				hprot, /* protection type parameters of following data */
-				sot_len + 2, /* pre-data length: only SOT */
-				left_THmarks_len /* post-data length: from SOT end to SOD inclusive */
-				)) {
-				
-				/* Add this marker to the 'insertanda' list */
-				if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
-					jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
-					jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
-					jwmarker[jwmarker_num].pos = j2k->image_info->tile[tileno].start_pos + sot_len + 2; /* after SOT */
-					jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
-					jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
-					jwmarker[jwmarker_num].len_ready = true; /* ready */
-					jwmarker[jwmarker_num].pos_ready = true; /* ready */
-					jwmarker[jwmarker_num].parms_ready = true; /* ready */
-					jwmarker[jwmarker_num].data_ready = false; /* not ready */
-					jwmarker_num++;
-				}
+			/****** if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile part onwards */
+				hprot = j2k->cp->hprot_TPH[tilespec++];
+		
+			/* must this TPH have an EPB MS? */
+			if (j2k->cp->epb_on && (hprot > 0)) {
 
-				/* update Psot of the tile  */
-				Psot += epb_mark->Lepb + 2;
+				/* Create the EPB */
+				if (epb_mark = jpwl_epb_create(
+					j2k, /* this encoder handle */
+					false, /* is it the latest? in TPH, no for now (if huge data size in TPH, we'd need more) */
+					true, /* is it packed? yes for now */
+					tileno, /* we are in TPH */
+					epb_index++, /* its index is 0 (first) */
+					hprot, /* protection type parameters of following data */
+					sot_len + 2, /* pre-data length: only SOT */
+					left_THmarks_len /* post-data length: from SOT end to SOD inclusive */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
+						jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
+						jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* ready */
+						jwmarker[jwmarker_num].data_ready = false; /* not ready */
+						jwmarker_num++;
+					}
 
-				opj_event_msg(j2k->cinfo, EVT_INFO,
-					"TPH EPB : tile %02d, prot. %d\n",
-					tileno,
-					hprot
-					);
-
-				/* save this TPH EPB address */
-				tph_epb = epb_mark;
-
-			} else {
-				/* ooops, problems */
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB #%d\n", tileno);				
-			};
+					/* update Psot of the tile  */
+					Psot += epb_mark->Lepb + 2;
 
-		}				
-	
-		startpack = 0;
-		/* EPB MSs for UEP packet data protection in Tile Parts */
-		for (packno = 0; packno < j2k->image_info->num; packno++) {
-
-			if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
-				(j2k->cp->pprot_tileno[packspec] == tileno) && (j2k->cp->pprot_packno[packspec] == packno)) {
-
-				/* we got a specification from this tile and packet onwards */
-				/* print the previous spec */
-				if (packno > 0) {
-					stoppack = packno - 1;				
 					opj_event_msg(j2k->cinfo, EVT_INFO,
-						"UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
-						tileno,
-						startpack,
-						stoppack,
-						j2k->image_info->tile[tileno].packet[startpack].start_pos,
-						j2k->image_info->tile[tileno].packet[stoppack].end_pos,
-						pprot);
-
-					prot_len = j2k->image_info->tile[tileno].packet[stoppack].end_pos + 1 -
-						j2k->image_info->tile[tileno].packet[startpack].start_pos;
-
-					/*
-					  particular case: if this is the last header and the last packet,
-					  then it is better to protect even the EOC marker
-					*/
-					if ((tileno == ((j2k->image_info->tw * j2k->image_info->th) - 1)) &&
-						(stoppack == (j2k->image_info->num - 1)))
-						/* add the EOC len */
-						prot_len += 2;
-
-					/* let's add the EPBs */
-					Psot += jpwl_epbs_add(
-						j2k, /* J2K handle */
-						jwmarker, /* pointer to JPWL markers list */
-						&jwmarker_num, /* pointer to the number of current markers */
-						false, /* latest */
-						true, /* packed */
-						false, /* inside MH */
-						&epb_index, /* pointer to EPB index */
-						pprot, /* protection type */
-						(double) (j2k->image_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, /* position */
-						tileno, /* number of tile */
-						0, /* length of pre-data */
-						prot_len /*4000*/ /* length of post-data */
+						/***** "TPH EPB : tile %02d, prot. %d\n", */
+						"TPH EPB : tile %02d, part %02d, prot. %d\n",
+						/***** tileno, */
+						tileno, tpno,
+						hprot
 						);
+
+					/* save this TPH EPB address */
+					tph_epb = epb_mark;
+
+				} else {
+					/* ooops, problems */
+					/****** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB #%d\n", tileno);	*/
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB in #%d,d\n", tileno, tpno);
+				};
+
+			}				
+		
+			startpack = 0;
+			/* EPB MSs for UEP packet data protection in Tile Parts */
+			/****** for (packno = 0; packno < j2k->cstr_info->num; packno++) { */
+			/*first_tp_pack = (tpno > 0) ? (first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno - 1].tp_numpacks) : 0;*/
+			first_tp_pack = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pack;
+			last_tp_pack = first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks - 1;
+			for (packno = 0; packno < j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks; packno++) {
+
+				/******** if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == tileno) && (j2k->cp->pprot_packno[packspec] == packno)) { */
+				if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == acc_tpno) && (j2k->cp->pprot_packno[packspec] == packno)) {
+
+					/* we got a specification from this tile and packet onwards */
+					/* print the previous spec */
+					if (packno > 0) {
+						stoppack = packno - 1;				
+						opj_event_msg(j2k->cinfo, EVT_INFO,
+							/***** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+							"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+							/***** tileno, */
+							tileno, tpno,
+							startpack,
+							stoppack,
+							/***** j2k->cstr_info->tile[tileno].packet[startpack].start_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+							/***** j2k->cstr_info->tile[tileno].packet[stoppack].end_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+							pprot);
+
+						/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+						prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+						/*
+						  particular case: if this is the last header and the last packet,
+						  then it is better to protect even the EOC marker
+						*/
+						/****** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(stoppack == (j2k->cstr_info->num - 1))) */
+						if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+							(stoppack == last_tp_pack))
+							/* add the EOC len */
+							prot_len += 2;
+
+						/* let's add the EPBs */
+						Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							false, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/****** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, */ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+					}
+
+					startpack = packno;
+					pprot = j2k->cp->pprot[packspec++];
 				}
 
-				startpack = packno;
-				pprot = j2k->cp->pprot[packspec++];
+				//printf("Tile %02d, pack %02d ==> %d\n", tileno, packno, pprot);
+		
 			}
 
-			//printf("Tile %02d, pack %02d ==> %d\n", tileno, packno, pprot);
-	
-		}
+			/* we are at the end: print the remaining spec */
+			stoppack = packno - 1;
+			if (pprot >= 0) {
 
-		/* we are at the end: print the remaining spec */
-		stoppack = packno - 1;
-		if (pprot >= 0) {
+				opj_event_msg(j2k->cinfo, EVT_INFO,
+					/**** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+					"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+					/**** tileno, */
+					tileno, tpno,
+					startpack,
+					stoppack,
+					/***** j2k->image_info->tile[tileno].packet[startpack].start_pos,
+					j2k->image_info->tile[tileno].packet[stoppack].end_pos, */
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+					pprot);
+
+				/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+				prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+				/*
+				  particular case: if this is the last header and the last packet,
+				  then it is better to protect even the EOC marker
+				*/
+				/***** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(stoppack == (j2k->cstr_info->num - 1))) */
+				if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+					(stoppack == last_tp_pack))
+					/* add the EOC len */
+					prot_len += 2;
+
+				/* let's add the EPBs */
+				Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							true, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/***** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001,*/ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+			}
 
-			opj_event_msg(j2k->cinfo, EVT_INFO,
-				"UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
-				tileno,
-				startpack,
-				stoppack,
-				j2k->image_info->tile[tileno].packet[startpack].start_pos,
-				j2k->image_info->tile[tileno].packet[stoppack].end_pos,
-				pprot);
-
-			prot_len = j2k->image_info->tile[tileno].packet[stoppack].end_pos + 1 -
-				j2k->image_info->tile[tileno].packet[startpack].start_pos;
-
-			/*
-			  particular case: if this is the last header and the last packet,
-			  then it is better to protect even the EOC marker
-			*/
-			if ((tileno == ((j2k->image_info->tw * j2k->image_info->th) - 1)) &&
-				(stoppack == (j2k->image_info->num - 1)))
-				/* add the EOC len */
-				prot_len += 2;
-
-			/* let's add the EPBs */
-			Psot += jpwl_epbs_add(
-						j2k, /* J2K handle */
-						jwmarker, /* pointer to JPWL markers list */
-						&jwmarker_num, /* pointer to the number of current markers */
-						true, /* latest */
-						true, /* packed */
-						false, /* inside MH */
-						&epb_index, /* pointer to EPB index */
-						pprot, /* protection type */
-						(double) (j2k->image_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, /* position */
-						tileno, /* number of tile */
-						0, /* length of pre-data */
-						prot_len /*4000*/ /* length of post-data */
-						);
-		}
+			/* we can now check if the TPH EPB was really the last one */
+			if (tph_epb && (epb_index == 1)) {
+				/* set the TPH EPB to be the last one in current header */
+				tph_epb->Depb |= (unsigned char) ((true & 0x0001) << 6);
+				tph_epb = NULL;
+			}
 
-		/* we can now check if the TPH EPB was really the last one */
-		if (tph_epb && (epb_index == 1)) {
-			/* set the TPH EPB to be the last one in current header */
-			tph_epb->Depb |= (unsigned char) ((true & 0x0001) << 6);
-			tph_epb = NULL;
+			/* write back Psot */
+			cio_seek(cio, Psotp);
+			cio_write(cio, Psot, 4);
+		
 		}
 
-		/* write back Psot */
-		cio_seek(cio, Psotp);
-		cio_write(cio, Psot, 4);
-
 	};
 
 	/* reset the position */
@@ -575,9 +710,9 @@
 void jpwl_dump_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
 
 	int mm;
-	unsigned long int old_size = j2k->image_info->codestream_size;
+	unsigned long int old_size = j2k->cstr_info->codestream_size;
 	unsigned long int new_size = old_size;
-	int ciopos = cio_tell(cio);
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
 	unsigned char *jpwl_buf, *orig_buf;
 	unsigned long int orig_pos;
 	double epbcoding_time = 0.0, esdcoding_time = 0.0;
@@ -585,23 +720,27 @@
 	/* Order JPWL markers according to their wishlist position */
 	qsort((void *) jwmarker, (size_t) jwmarker_num, sizeof (jpwl_marker_t), jpwl_markcomp);
 
-	/* compute markers total size */
+	/* compute markers total size */ 
 	for (mm = 0; mm < jwmarker_num; mm++) {
 		/*printf("%x, %d, %.10f, %d long\n", jwmarker[mm].id, jwmarker[mm].pos,
 			jwmarker[mm].dpos, jwmarker[mm].len);*/
 		new_size += jwmarker[mm].len + 2;
 	}
 
-	/* allocate a temporary buffer of proper size */
-	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) new_size * sizeof (unsigned char)))) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL temp codestream buffer\n");
+	/* allocate a new buffer of proper size */
+	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) (new_size + soc_pos) * sizeof(unsigned char)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL codestream buffer\n");
 		exit(1);
 	};
+
+	/* copy the jp2 part, if any */
 	orig_buf = jpwl_buf;
+	memcpy(jpwl_buf, cio->buffer, soc_pos);
+	jpwl_buf += soc_pos;
 
 	/* cycle through markers */
-	orig_pos = 0; /* start from the beginning */
-	cio_seek(cio, 0); /* rewind the original */
+	orig_pos = soc_pos + 0; /* start from the beginning */
+	cio_seek(cio, soc_pos + 0); /* rewind the original */
 	for (mm = 0; mm < jwmarker_num; mm++) {
 
 		/*
@@ -619,15 +758,15 @@
 		switch (jwmarker[mm].id) {
 
 		case J2K_MS_EPB:
-			jpwl_epb_write(jwmarker[mm].epbmark, jpwl_buf);
+			jpwl_epb_write(j2k, jwmarker[mm].epbmark, jpwl_buf);
 			break;
 
 		case J2K_MS_EPC:
-			jpwl_epc_write(jwmarker[mm].epcmark, jpwl_buf);
+			jpwl_epc_write(j2k, jwmarker[mm].epcmark, jpwl_buf);
 			break;
 
 		case J2K_MS_ESD:
-			jpwl_esd_write(jwmarker[mm].esdmark, jpwl_buf);
+			jpwl_esd_write(j2k, jwmarker[mm].esdmark, jpwl_buf);
 			break;
 
 		case J2K_MS_RED:
@@ -638,6 +777,10 @@
 			break;
 		};
 
+		/* we update the markers struct */
+		if (j2k->cstr_info)
+			j2k->cstr_info->marker[j2k->cstr_info->marknum - 1].pos = (jpwl_buf - orig_buf);
+		
 		/* we set the marker dpos to the new position in the JPWL codestream */
 		jwmarker[mm].dpos = (double) (jpwl_buf - orig_buf);
 
@@ -647,15 +790,15 @@
 	}
 
 	/* finish remaining original codestream */
-	memcpy(jpwl_buf, cio_getbp(cio), old_size - orig_pos);
-	jpwl_buf += old_size - orig_pos;
-	cio_seek(cio, old_size);
+	memcpy(jpwl_buf, cio_getbp(cio), old_size - (orig_pos - soc_pos));
+	jpwl_buf += old_size - (orig_pos - soc_pos);
+	cio_seek(cio, soc_pos + old_size);
 	
 	/*
 	update info file based on added markers
 	*/
 	if (!jpwl_update_info(j2k, jwmarker, jwmarker_num))
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not update OPJ image_info structure\n");
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not update OPJ cstr_info structure\n");
 
 	/* now we need to repass some markers and fill their data fields */
 	
@@ -746,14 +889,14 @@
 
 	/* free original cio buffer and set it to the JPWL one */
 	opj_free(cio->buffer);
-	/*cio->cinfo;*/ /* no change */
-	/*cio->openmode;*/ /* no change */
-	cio->buffer = jpwl_buf - new_size;
-	cio->length = new_size;
-	cio->start = jpwl_buf - new_size;
-	cio->end = jpwl_buf - 1;
-	cio->bp = jpwl_buf - new_size;
-	cio_seek(cio, new_size);
+	cio->cinfo = cio->cinfo; /* no change */
+	cio->openmode = cio->openmode; /* no change */
+	cio->buffer = orig_buf;
+	cio->length = new_size + soc_pos;
+	cio->start = cio->buffer;
+	cio->end = cio->buffer + cio->length;
+	cio->bp = cio->buffer;
+	cio_seek(cio, soc_pos + new_size);
 
 }
 
@@ -864,6 +1007,10 @@
 		cio_write(cio, Pcrc, 2);
 
 	cio_seek(cio, Lepcp + Lepc);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, Lepcp - 2, Lepc + 2);
+
 }
 
 void j2k_read_epb(opj_j2k_t *j2k) {
@@ -1012,6 +1159,9 @@
 	cio_write(cio, Lepb, 2);		/* Lepb */
 
 	cio_seek(cio, Lepbp + Lepb);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, Lepbp - 2, Lepb + 2);
 }
 
 void j2k_read_esd(opj_j2k_t *j2k) {
@@ -1069,6 +1219,7 @@
 
 bool jpwl_check_tile(opj_j2k_t *j2k, opj_tcd_t *tcd, int tileno) {
 
+#ifdef oerhgierhgvhreit4u
 	/*
 	   we navigate through the tile and find possible invalid parameters:
        this saves a lot of crashes!!!!!
@@ -1130,9 +1281,77 @@
 		}
 	}
 
+#endif
+
 	return true;
 }
 
 /*@}*/
 
 #endif /* USE_JPWL */
+
+
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+
+/** @name Local static functions */
+/*@{*/
+
+void j2k_read_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the SEC length */
+	Lsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"SEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Lsec - 2);  
+}
+
+void j2k_write_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec = 24;
+	int i;
+
+	opj_cio_t *cio = j2k->cio;
+
+	cio_write(cio, J2K_MS_SEC, 2);	/* SEC */
+	cio_write(cio, Lsec, 2);
+
+	/* write dummy data */
+	for (i = 0; i < Lsec - 2; i++)
+		cio_write(cio, 0, 1);
+}
+
+void j2k_read_insec(opj_j2k_t *j2k) {
+	unsigned short int Linsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the INSEC length */
+	Linsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"INSEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Linsec - 2);  
+}
+
+
+/*@}*/
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
diff -urN -xdebian -x.svn ./jpwl/jpwl.h /usr/src/openjpeg/trunk/jpwl/jpwl.h
--- ./jpwl/jpwl.h	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/jpwl.h	2007-11-27 22:39:51.000000000 +0000
@@ -206,6 +206,14 @@
 }	jpwl_marker_t;
 
 /**
+Encode according to JPWL specs
+@param j2k J2K handle
+@param cio codestream handle
+@param image image handle
+*/
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image);
+
+/**
 Prepare the list of JPWL markers, after the Part 1 codestream
 has been finalized (index struct is full)
 @param j2k J2K handle
@@ -227,6 +235,7 @@
 @param j2k J2K handle
 */
 void j2k_read_epc(opj_j2k_t *j2k);
+
 /**
 Write the EPC marker (Error Protection Capability), BUT the DL field is always set to 0
 (this simplifies the management of EPBs and it is openly stated in the standard
@@ -235,21 +244,25 @@
 @param j2k J2K handle
 */
 void j2k_write_epc(opj_j2k_t *j2k);
+
 /**
 Read the EPB marker (Error Protection Block)
 @param j2k J2K handle
 */
 void j2k_read_epb(opj_j2k_t *j2k);
+
 /**
 Write the EPB marker (Error Protection Block)
 @param j2k J2K handle
 */
 void j2k_write_epb(opj_j2k_t *j2k);
+
 /**
 Read the ESD marker (Error Sensitivity Descriptor)
 @param j2k J2K handle
 */
 void j2k_read_esd(opj_j2k_t *j2k);
+
 /**
 Read the RED marker (Residual Error Descriptor)
 @param j2k J2K handle
@@ -321,6 +334,8 @@
 
 bool jpwl_epb_fill(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf, unsigned char *post_buf);
 
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
+
 /** corrects the data in the JPWL codestream
 @param j2k J2K compressor handle
 @return true if correction is performed correctly
@@ -379,5 +394,32 @@
 
 #endif /* USE_JPWL */
 
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+/**
+Read the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_sec(opj_j2k_t *j2k);
+
+/**
+Write the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_write_sec(opj_j2k_t *j2k);
+
+/**
+Read the INSEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_insec(opj_j2k_t *j2k);
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
 #endif /* __JPWL_H */
 
diff -urN -xdebian -x.svn ./jpwl/JPWL_image_to_j2k.dsp /usr/src/openjpeg/trunk/jpwl/JPWL_image_to_j2k.dsp
--- ./jpwl/JPWL_image_to_j2k.dsp	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/JPWL_image_to_j2k.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -42,7 +42,8 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /FR /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /c
+# SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x80c /d "NDEBUG"
 # ADD RSC /l 0x80c /d "NDEBUG"
 BSC32=bscmake.exe
@@ -50,7 +51,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWL.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"Release"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWL.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /libpath:"Release"
 
 !ELSEIF  "$(CFG)" == "JPWL_image_to_j2k - Win32 Debug"
 
@@ -66,7 +67,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /FR /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /GZ /c
 # ADD BASE RSC /l 0x80c /d "_DEBUG"
 # ADD RSC /l 0x80c /d "_DEBUG"
 BSC32=bscmake.exe
@@ -97,6 +98,10 @@
 
 SOURCE=..\codec\image_to_j2k.c
 # End Source File
+# Begin Source File
+
+SOURCE=..\codec\index.c
+# End Source File
 # End Group
 # Begin Group "Header Files"
 
@@ -111,6 +116,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\codec\index.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\libopenjpeg\openjpeg.h
 # End Source File
 # End Group
diff -urN -xdebian -x.svn ./jpwl/JPWL_j2k_to_image.dsp /usr/src/openjpeg/trunk/jpwl/JPWL_j2k_to_image.dsp
--- ./jpwl/JPWL_j2k_to_image.dsp	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/JPWL_j2k_to_image.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -42,7 +42,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
 # ADD BASE RSC /l 0x80c /d "NDEBUG"
 # ADD RSC /l 0x80c /d "NDEBUG"
 BSC32=bscmake.exe
@@ -50,7 +50,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmt.lib"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386
 
 !ELSEIF  "$(CFG)" == "JPWL_j2k_to_image - Win32 Debug"
 
@@ -66,7 +66,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
 # ADD BASE RSC /l 0x80c /d "_DEBUG"
 # ADD RSC /l 0x80c /d "_DEBUG"
 BSC32=bscmake.exe
@@ -74,7 +74,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept
 
 !ENDIF 
 
@@ -91,27 +91,15 @@
 # End Source File
 # Begin Source File
 
-SOURCE=.\crc.c
-# End Source File
-# Begin Source File
-
 SOURCE=..\codec\compat\getopt.c
 # End Source File
 # Begin Source File
 
-SOURCE=..\codec\j2k_to_image.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\jpwl.c
+SOURCE=..\codec\index.c
 # End Source File
 # Begin Source File
 
-SOURCE=.\jpwl_lib.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\rs.c
+SOURCE=..\codec\j2k_to_image.c
 # End Source File
 # End Group
 # Begin Group "Header Files"
@@ -131,6 +119,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\codec\index.h
+# End Source File
+# Begin Source File
+
 SOURCE=.\jpwl.h
 # End Source File
 # Begin Source File
diff -urN -xdebian -x.svn ./jpwl/jpwl_lib.c /usr/src/openjpeg/trunk/jpwl/jpwl_lib.c
--- ./jpwl/jpwl_lib.c	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/jpwl_lib.c	2007-12-01 18:40:47.000000000 +0000
@@ -32,6 +32,7 @@
 #ifdef USE_JPWL
 
 #include "../libopenjpeg/opj_includes.h"
+#include <limits.h>
 
 /** Minimum and maximum values for the double->pfp conversion */
 #define MIN_V1 0.0
@@ -128,21 +129,26 @@
 	while (post_len > 0) {
 
 		/* maximum postlen in order to respect EPB size
-		(we use 65450 instead of 65535 for keeping room for EPB parms)*/
+		(we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms)*/
 		/*      (message word size)    *            (number of containable parity words)  */
-		max_postlen = k_post * (unsigned long int) floor(65450.0 / (double) (n_post - k_post));
+		max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
 
 		/* maximum postlen in order to respect EPB size */
 		if (*idx == 0)
-			/* (we use (65500 - L2) instead of 65535 for keeping room for EPB parms + pre-data) */
+			/* (we use (JPWL_MAXIMUM_EPB_ROOM - L2) instead of 65535 for keeping room for EPB parms + pre-data) */
 			/*      (message word size)    *                   (number of containable parity words)  */
-			max_postlen = k_post * (unsigned long int) floor((double) (65500 - L2) / (double) (n_post - k_post));
+			max_postlen = k_post * (unsigned long int) floor((double) (JPWL_MAXIMUM_EPB_ROOM - L2) / (double) (n_post - k_post));
 
 		else
-			/* (we use 65500 instead of 65535 for keeping room for EPB parms) */
+			/* (we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms) */
 			/*      (message word size)    *            (number of containable parity words)  */
-			max_postlen = k_post * (unsigned long int) floor(65500.0 / (double) (n_post - k_post));
+			max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
 
+		/* null protection case */
+		/* the max post length can be as large as the LDPepb field can host */
+		if (hprot == 0)
+			max_postlen = INT_MAX;
+		
 		/* length to use */
 		dL4 = min(max_postlen, post_len);
 
@@ -289,7 +295,7 @@
 	return epb;
 }
 
-void jpwl_epb_write(jpwl_epb_ms_t *epb, unsigned char *buf) {
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epb, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_EPB >> 8); 
@@ -317,6 +323,10 @@
 	/* Data */
 	/*memcpy(buf, epb->data, (size_t) epb->Lepb - 11);*/
 	memset(buf, 0, (size_t) epb->Lepb - 11);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, -1, epb->Lepb + 2);
+
 };
 
 
@@ -793,7 +803,7 @@
 	/* Initialize RS structures */
 	P = n_pre - k_pre;
 	NN_P = NN - P;
-	tt = (int) floor((float) P / 2.0F);
+	tt = (int) floor((float) P / 2.0F); /* correction capability of the code */
 	memset(codeword, 0, NN);
 	parityword = codeword + NN_P;
 	init_rs(NN_P);
@@ -834,7 +844,8 @@
 			/*if (conn == NULL)
 				opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
 
-		} else if (status < tt) {
+		} else if (status <= tt) {
+			/* it has corrected 0 <= errs <= tt */
 			/*if (conn == NULL)
 				opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
 			errnum += status;
@@ -848,21 +859,21 @@
 
 
 		/* advance parity buffer */
-		if ((status >= 0) && (status < tt))
+		if ((status >= 0) && (status <= tt))
 			/* copy back corrected parity only if all is OK */
 			memcpy(L2_buf, parityword, P);
 		L2_buf += P;
 
 		/* advance message buffer */
 		if (remaining < k_pre) {
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L1_buf, codeword, remaining);
 			L1_buf += remaining;
 			remaining = 0;
 
 		} else {
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L1_buf, codeword, k_pre);
 			L1_buf += k_pre;
@@ -1043,7 +1054,7 @@
 		/* Initialize RS structures */
 		P = n_post - k_post;
 		NN_P = NN - P;
-		tt = (int) floor((float) P / 2.0F);
+		tt = (int) floor((float) P / 2.0F); /* again, correction capability */
 		memset(codeword, 0, NN);
 		parityword = codeword + NN_P;
 		init_rs(NN_P);
@@ -1080,7 +1091,7 @@
 				/*if (conn == NULL)
 					opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
 
-			} else if (status < tt) {
+			} else if (status <= tt) {
 				/*if (conn == NULL)
 					opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
 				errnum += status;
@@ -1094,21 +1105,21 @@
 
 
 			/* advance parity buffer */
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L3_buf, parityword, P);
 			L3_buf += P;
 
 			/* advance message buffer */
 			if (remaining < k_post) {
-				if ((status >= 0) && (status < tt))
+				if ((status >= 0) && (status <= tt))
 					/* copy back corrected data only if all is OK */
 					memcpy(L4_buf, codeword, remaining);
 				L4_buf += remaining;
 				remaining = 0;
 
 			} else {
-				if ((status >= 0) && (status < tt))
+				if ((status >= 0) && (status <= tt))
 					/* copy back corrected data only if all is OK */
 					memcpy(L4_buf, codeword, k_post);
 				L4_buf += k_post;
@@ -1138,7 +1149,7 @@
 	return true;
 }
 
-void jpwl_epc_write(jpwl_epc_ms_t *epc, unsigned char *buf) {
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epc, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_EPC >> 8); 
@@ -1164,6 +1175,10 @@
 	/* Data */
 	/*memcpy(buf, epc->data, (size_t) epc->Lepc - 9);*/
 	memset(buf, 0, (size_t) epc->Lepc - 9);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, -1, epc->Lepc + 2);
+
 };
 
 int jpwl_esds_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
@@ -1215,7 +1230,7 @@
 		if (ad_size == 0)
 			/* if there are more than 66% of (2^16 - 1) bytes, switch to 4 bytes
 			 (we keep space for possible EPBs being inserted) */
-			ad_size = (j2k->image_info->codestream_size > (1 * 65535 / 3)) ? 4 : 2;
+			ad_size = (j2k->cstr_info->codestream_size > (1 * 65535 / 3)) ? 4 : 2;
 		esd->sensval_size = ad_size + ad_size + se_size; 
 		break;
 
@@ -1224,7 +1239,7 @@
 		/* auto sense address size */
 		if (ad_size == 0)
 			/* if there are more than 2^16 - 1 packets, switch to 4 bytes */
-			ad_size = (j2k->image_info->num > 65535) ? 4 : 2;
+			ad_size = (j2k->cstr_info->packno > 65535) ? 4 : 2;
 		esd->sensval_size = ad_size + ad_size + se_size; 
 		break;
 
@@ -1245,17 +1260,17 @@
 		/* just based on the portions of a codestream */
 		case (0):
 			/* MH + no. of THs + no. of packets */
-			svalnum = 1 + (j2k->image_info->tw * j2k->image_info->th) * (1 + j2k->image_info->num);
+			svalnum = 1 + (j2k->cstr_info->tw * j2k->cstr_info->th) * (1 + j2k->cstr_info->packno);
 			break;
 
 		/* all the ones that are based on the packets */
 		default:
 			if (tileno < 0)
 				/* MH: all the packets and all the tiles info is written */
-				svalnum = j2k->image_info->tw * j2k->image_info->th * j2k->image_info->num;
+				svalnum = j2k->cstr_info->tw * j2k->cstr_info->th * j2k->cstr_info->packno;
 			else
 				/* TPH: only that tile info is written */
-				svalnum = j2k->image_info->num;
+				svalnum = j2k->cstr_info->packno;
 			break;
 
 		}
@@ -1355,26 +1370,26 @@
 		buf += 7;
 
 	/* let's fill the data fields */
-	for (vv = (esd->tileno < 0) ? 0 : (j2k->image_info->num * esd->tileno); vv < esd->svalnum; vv++) {
+	for (vv = (esd->tileno < 0) ? 0 : (j2k->cstr_info->packno * esd->tileno); vv < esd->svalnum; vv++) {
 
-		int thistile = vv / j2k->image_info->num, thispacket = vv % j2k->image_info->num;
+		int thistile = vv / j2k->cstr_info->packno, thispacket = vv % j2k->cstr_info->packno;
 
 		/* skip for the hack some lines below */
-		if (thistile == j2k->image_info->tw * j2k->image_info->th)
+		if (thistile == j2k->cstr_info->tw * j2k->cstr_info->th)
 			break;
 
 		/* starting tile distortion */
 		if (thispacket == 0) {
-			TSE = j2k->image_info->tile[thistile].distotile;
-			oldMSE = TSE / j2k->image_info->tile[thistile].nbpix;
+			TSE = j2k->cstr_info->tile[thistile].distotile;
+			oldMSE = TSE / j2k->cstr_info->tile[thistile].numpix;
 			oldPSNR = 10.0 * log10(Omax2 / oldMSE);
 		}
 
 		/* TSE */
-		TSE -= j2k->image_info->tile[thistile].packet[thispacket].disto;
+		TSE -= j2k->cstr_info->tile[thistile].packet[thispacket].disto;
 
 		/* MSE */
-		MSE = TSE / j2k->image_info->tile[thistile].nbpix;
+		MSE = TSE / j2k->cstr_info->tile[thistile].numpix;
 
 		/* PSNR */
 		PSNR = 10.0 * log10(Omax2 / MSE);
@@ -1390,9 +1405,9 @@
 		/* byte range */
 		case (1):
 			/* start address of packet */
-			addr1 = (j2k->image_info->tile[thistile].packet[thispacket].start_pos) & addrmask;
+			addr1 = (j2k->cstr_info->tile[thistile].packet[thispacket].start_pos) & addrmask;
 			/* end address of packet */
-			addr2 = (j2k->image_info->tile[thistile].packet[thispacket].end_pos) & addrmask;
+			addr2 = (j2k->cstr_info->tile[thistile].packet[thispacket].end_pos) & addrmask;
 			break;
 
 		/* packet range */
@@ -1416,7 +1431,7 @@
 			if ((thistile == 0) && !doneMH) {
 				/* we have to manage MH addresses */
 				addr1 = 0; /* start of MH */
-				addr2 = j2k->image_info->main_head_end; /* end of MH */
+				addr2 = j2k->cstr_info->main_head_end; /* end of MH */
 				/* set special dvalue for this MH */
 				dvalue = -10.0;
 				doneMH = true; /* don't come here anymore */
@@ -1424,8 +1439,8 @@
 
 			} else if (!doneTPH) {
 				/* we have to manage TPH addresses */
-				addr1 = j2k->image_info->tile[thistile].start_pos;
-				addr2 = j2k->image_info->tile[thistile].end_header;
+				addr1 = j2k->cstr_info->tile[thistile].start_pos;
+				addr2 = j2k->cstr_info->tile[thistile].end_header;
 				/* set special dvalue for this TPH */
 				dvalue = -1.0;
 				doneTPH = true; /* don't come here till the next tile */
@@ -1483,7 +1498,7 @@
 			else
 				/* packet: first is most important, and then in decreasing order
 				down to the last, which counts for 1 */
-				dvalue = jpwl_pfp_to_double((unsigned short) (j2k->image_info->num - thispacket), esd->se_size);
+				dvalue = jpwl_pfp_to_double((unsigned short) (j2k->cstr_info->packno - thispacket), esd->se_size);
 			break;
 
 		/* MSE */
@@ -1554,7 +1569,7 @@
 	return true;
 }
 
-void jpwl_esd_write(jpwl_esd_ms_t *esd, unsigned char *buf) {
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esd, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_ESD >> 8); 
@@ -1579,6 +1594,10 @@
 	else
 		memset(buf, 0xAA, (size_t) esd->Lesd - 5);
 		/*memcpy(buf, esd->data, (size_t) esd->Lesd - 5);*/
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_ESD, -1, esd->Lesd + 2);
+
 }
 
 unsigned short int jpwl_double_to_pfp(double V, int bytes) {
@@ -1656,8 +1675,8 @@
 	int mm;
 	unsigned long int addlen;
 
-	opj_image_info_t *info = j2k->image_info;
-	int tileno, packno, numtiles = info->th * info->tw, numpacks = info->num;
+	opj_codestream_info_t *info = j2k->cstr_info;
+	int tileno, tpno, packno, numtiles = info->th * info->tw, numpacks = info->packno;
 
 	if (!j2k || !jwmarker ) {
 		opj_event_msg(j2k->cinfo, EVT_ERROR, "J2K handle or JPWL markers list badly allocated\n");
@@ -1696,22 +1715,56 @@
 
 		/* end_pos: increment with markers before the end of this tile */
 		/* code is disabled, since according to JPWL no markers can be beyond TPH */
-		/*addlen = 0;
+		addlen = 0;
 		for (mm = 0; mm < jwmarker_num; mm++)
 			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].end_pos)
-				addlen += jwmarker[mm].len + 2;*/
+				addlen += jwmarker[mm].len + 2;
 		info->tile[tileno].end_pos += addlen;
 
+		/* navigate through all the tile parts */
+		for (tpno = 0; tpno < info->tile[tileno].num_tps; tpno++) {
+
+			/* start_pos: increment with markers before SOT */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_start_pos += addlen;
+
+			/* end_header: increment with markers before of it */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_header)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_header += addlen;
+
+			/* end_pos: increment with markers before the end of this tile part */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_pos += addlen;
+
+		}
+
 		/* navigate through all the packets in this tile */
 		for (packno = 0; packno < numpacks; packno++) {
 			
 			/* start_pos: increment with markers before the packet */
 			/* disabled for the same reason as before */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos <= (unsigned long int) info->tile[tileno].packet[packno].start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].packet[packno].start_pos += addlen;
+
+			/* end_ph_pos: increment with markers before the packet */
+			/* disabled for the same reason as before */
 			/*addlen = 0;
 			for (mm = 0; mm < jwmarker_num; mm++)
-				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].start_pos)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].end_ph_pos)
 					addlen += jwmarker[mm].len + 2;*/
-			info->tile[tileno].packet[packno].start_pos += addlen;
+			info->tile[tileno].packet[packno].end_ph_pos += addlen;
 
 			/* end_pos: increment if marker is before the end of packet */
 			/* disabled for the same reason as before */
@@ -1724,6 +1777,8 @@
 		}
 	}
 
+	/* reorder the markers list */
+
 	return true;
 }
 
diff -urN -xdebian -x.svn ./jpwl/LibOpenJPEG_JPWL.dsp /usr/src/openjpeg/trunk/jpwl/LibOpenJPEG_JPWL.dsp
--- ./jpwl/LibOpenJPEG_JPWL.dsp	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/LibOpenJPEG_JPWL.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -41,7 +41,7 @@
 # PROP Intermediate_Dir "Release"
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
 # ADD BASE RSC /l 0x80c /d "NDEBUG"
 # ADD RSC /l 0x80c /d "NDEBUG"
 BSC32=bscmake.exe
@@ -64,7 +64,7 @@
 # PROP Intermediate_Dir "Debug"
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
 # ADD BASE RSC /l 0x80c /d "_DEBUG"
 # ADD RSC /l 0x80c /d "_DEBUG"
 BSC32=bscmake.exe
@@ -245,6 +245,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\libopenjpeg\opj_malloc.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\libopenjpeg\pi.h
 # End Source File
 # Begin Source File
diff -urN -xdebian -x.svn ./jpwl/Makefile /usr/src/openjpeg/trunk/jpwl/Makefile
--- ./jpwl/Makefile	2007-12-01 19:18:51.000000000 +0000
+++ /usr/src/openjpeg/trunk/jpwl/Makefile	2007-11-27 22:39:51.000000000 +0000
@@ -1,33 +1,83 @@
-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
-
-# General configuration variables:
-CC = gcc
-AR = ar
-
-CFLAGS = -O3 -DUSE_JPWL # -g -p -pg -DUSE_JPWL
-
-OPJ_SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c
-JPWL_SRCS = crc.c jpwl.c jpwl_lib.c rs.c
-
-TARGET  = openjpeg_JPWL
-STATICLIB = lib$(TARGET).a
-
-MODULES = $(OPJ_SRCS:.c=.o) $(JPWL_SRCS:.c=.o)
-
-all: JPWL_image_to_j2k JPWL_j2k_to_image
-
-.c.o:
-	$(CC) $(CFLAGS) -c $< -o $@
-
-$(STATICLIB): $(MODULES)
-	$(AR) r $@ $(MODULES)
-
-JPWL_j2k_to_image: ../codec/j2k_to_image.c $(STATICLIB)
-	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
-
-JPWL_image_to_j2k: ../codec/image_to_j2k.c $(STATICLIB)
-	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
-
-clean:
-	rm -f JPWL_j2k_to_image JPWL_image_to_j2k *.o *.a
-	cd ../libopenjpeg; rm -f *.o
+# Linux makefile for OpenJPEG + JPWL
+
+VER_MAJOR = 2
+VER_MINOR = 1.2.0
+
+JPWL_SRCS = ./crc.c ./jpwl.c ./jpwl_lib.c ./rs.c
+SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c $(JPWL_SRCS)
+INCLS = ../libopenjpeg/bio.h ../libopenjpeg/cio.h ../libopenjpeg/dwt.h ../libopenjpeg/event.h ../libopenjpeg/fix.h ../libopenjpeg/image.h ../libopenjpeg/int.h ../libopenjpeg/j2k.h ../libopenjpeg/j2k_lib.h ../libopenjpeg/jp2.h ../libopenjpeg/jpt.h ../libopenjpeg/mct.h ../libopenjpeg/mqc.h ../libopenjpeg/openjpeg.h ../libopenjpeg/pi.h ../libopenjpeg/raw.h ../libopenjpeg/t1.h ../libopenjpeg/t2.h ../libopenjpeg/tcd.h ../libopenjpeg/tgt.h ../libopenjpeg/opj_malloc.h ../libopenjpeg/opj_includes.h
+INCLUDE = -Ilibopenjpeg_JPWL
+
+# General configuration variables:
+CC = gcc
+AR = ar
+
+PREFIX = /usr
+INSTALL_LIBDIR = $(PREFIX)/lib
+INSTALL_INCLUDE = $(PREFIX)/include
+
+# Converts cr/lf to just lf
+DOS2UNIX = dos2unix
+
+COMPILERFLAGS = -O3 -fPIC
+LIBRARIES = -lstdc++
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE) -DUSE_JPWL
+
+TARGET  = openjpeg_JPWL
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
+LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
+
+
+
+default: all
+
+all: OpenJPEG_JPWL JPWL_image_to_j2k JPWL_j2k_to_image
+
+dist: OpenJPEG_JPWL
+	install -d dist
+	install -m 644 $(STATICLIB) dist
+	install -m 755 $(SHAREDLIB) dist
+	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
+	install libopenjpeg/openjpeg.h dist
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+OpenJPEG_JPWL: $(STATICLIB) $(SHAREDLIB)
+
+JPWL_codec: JPWL_j2k_to_image JPWL_image_to_j2k $(STATICLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(AR) r $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
+
+JPWL_j2k_to_image: ../codec/j2k_to_image.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+JPWL_image_to_j2k: ../codec/image_to_j2k.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+install: OpenJPEG
+	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
+	install -m 644 -o root -g root $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
+	install -m 755 -o root -g root $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
+	install -m 644 -o root -g root libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
+	-ldconfig
+
+cleanlib:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+
+cleancodec:
+	rm -f JPWL_j2k_to_image JPWL_image_to_j2k JPWL_j2k_to_image.o JPWL_image_to_j2k.o
+
+clean: cleanlib cleancodec
\ No newline at end of file
diff -urN -xdebian -x.svn ./libopenjpeg/bio.c /usr/src/openjpeg/trunk/libopenjpeg/bio.c
--- ./libopenjpeg/bio.c	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/bio.c	2007-09-28 11:33:44.000000000 +0100
@@ -114,7 +114,7 @@
 ==========================================================
 */
 
-opj_bio_t* bio_create() {
+opj_bio_t* bio_create(void) {
 	opj_bio_t *bio = (opj_bio_t*)opj_malloc(sizeof(opj_bio_t));
 	return bio;
 }
diff -urN -xdebian -x.svn ./libopenjpeg/bio.h /usr/src/openjpeg/trunk/libopenjpeg/bio.h
--- ./libopenjpeg/bio.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/bio.h	2007-09-28 11:33:44.000000000 +0100
@@ -64,7 +64,7 @@
 Create a new BIO handle 
 @return Returns a new BIO handle if successful, returns NULL otherwise
 */
-opj_bio_t* bio_create();
+opj_bio_t* bio_create(void);
 /**
 Destroy a previously created BIO handle
 @param bio BIO handle to destroy
diff -urN -xdebian -x.svn ./libopenjpeg/cio.c /usr/src/openjpeg/trunk/libopenjpeg/cio.c
--- ./libopenjpeg/cio.c	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/cio.c	2007-09-28 11:33:44.000000000 +0100
@@ -58,9 +58,10 @@
 				opj_free(cio);
 				return NULL;
 		}
-		cio->length = (int) (1.3 * cp->img_size);
+		cio->length = (unsigned int) (0.1625 * cp->img_size + 2000); /* 0.1625 = 1.3/8 and 2000 bytes as a minimum for headers */
 		cio->buffer = (unsigned char *)opj_malloc(cio->length);
 		if(!cio->buffer) {
+			opj_event_msg(cio->cinfo, EVT_ERROR, "Error allocating memory for compressed bitstream\n");
 			opj_free(cio);
 			return NULL;
 		}
@@ -139,7 +140,7 @@
  */
 unsigned char cio_bytein(opj_cio_t *cio) {
 	if (cio->bp >= cio->end) {
-		opj_event_msg(cio->cinfo, EVT_ERROR, "read error\n");
+		opj_event_msg(cio->cinfo, EVT_ERROR, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n", cio->start, cio->bp, cio->end);
 		return 0;
 	}
 	return *cio->bp++;
diff -urN -xdebian -x.svn ./libopenjpeg/CMakeLists.txt /usr/src/openjpeg/trunk/libopenjpeg/CMakeLists.txt
--- ./libopenjpeg/CMakeLists.txt	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/CMakeLists.txt	2007-09-28 11:33:44.000000000 +0100
@@ -32,9 +32,13 @@
 
 # Create the library
 ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+SET_TARGET_PROPERTIES(${OPENJPEG_LIBRARY_NAME} PROPERTIES
+	${OPENJPEG_LIBRARY_PROPERTIES})
 
 # Install library
-INSTALL_TARGETS(/lib/ ${OPENJPEG_LIBRARY_NAME})
+INSTALL(TARGETS ${OPENJPEG_LIBRARY_NAME}
+	DESTINATION lib)
 
 # Install includes files
-INSTALL_FILES(/include .h)
+INSTALL(FILES openjpeg.h
+	DESTINATION ${INCLUDE_INSTALL_DIR}/openjpeg)
diff -urN -xdebian -x.svn ./libopenjpeg/dwt.c /usr/src/openjpeg/trunk/libopenjpeg/dwt.c
--- ./libopenjpeg/dwt.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/dwt.c	2007-11-27 22:39:50.000000000 +0000
@@ -5,6 +5,8 @@
  * Copyright (c) 2002-2003, Yannick Verschueren
  * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Jonathan Ballard <dzonatas@dzonux.net>
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -29,6 +31,9 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#ifdef __SSE__
+#include <xmmintrin.h>
+#endif
 
 #include "opj_includes.h"
 
@@ -41,12 +46,32 @@
 /** @name Local data structures */
 /*@{*/
 
-typedef struct dwt_local{
-	int *	mem ;
+typedef struct dwt_local {
+	int* mem;
+	int dn;
+	int sn;
+	int cas;
+} dwt_t;
+
+typedef union {
+	float	f[4];
+} v4;
+
+typedef struct v4dwt_local {
+	v4*	wavelet ;
 	int		dn ;
 	int		sn ;
 	int		cas ;
-	} dwt_t ; 
+} v4dwt_t ;
+
+static const float alpha =  1.586134342f; //  12994
+static const float beta  =  0.052980118f; //    434
+static const float gamma = -0.882911075f; //  -7233
+static const float delta = -0.443506852f; //  -3633
+
+static const float K      = 1.230174105f; //  10078
+/* FIXME: What is this constant? */
+static const float c13318 = 1.625732422f;
 
 /*@}*/
 
@@ -75,11 +100,11 @@
 */
 static void dwt_interleave_v(dwt_t* v, int *a, int x);
 /**
-Forward 5-3 wavelet tranform in 1-D
+Forward 5-3 wavelet transform in 1-D
 */
 static void dwt_encode_1(int *a, int dn, int sn, int cas);
 /**
-Inverse 5-3 wavelet tranform in 1-D
+Inverse 5-3 wavelet transform in 1-D
 */
 static void dwt_decode_1(dwt_t *v);
 /**
@@ -87,17 +112,13 @@
 */
 static void dwt_encode_1_real(int *a, int dn, int sn, int cas);
 /**
-Inverse 9-7 wavelet transform in 1-D
-*/
-static void dwt_decode_1_real(dwt_t *v);
-/**
-FIXME : comment ???
+Explicit calculation of the Quantization Stepsizes 
 */
 static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
 /**
-Inverse wavelet tranform in 2-D.
+Inverse wavelet transform in 2-D.
 */
-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop , DWT1DFN fn);
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
 
 /*@}*/
 
@@ -199,7 +220,7 @@
 
 
 /* <summary>                            */
-/* Forward 5-3 wavelet tranform in 1-D. */
+/* Forward 5-3 wavelet transform in 1-D. */
 /* </summary>                           */
 static void dwt_encode_1(int *a, int dn, int sn, int cas) {
 	int i;
@@ -220,7 +241,7 @@
 }
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 1-D. */
+/* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
 static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
 	int i;
@@ -241,7 +262,7 @@
 }
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 1-D. */
+/* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
 static void dwt_decode_1(dwt_t *v) {
 	dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
@@ -285,102 +306,6 @@
 	}
 }
 
-static void dwt_decode_sm(dwt_t* v, int k, int n, int x) {
-	int m = k > n ? n : k;
-	int l = v->mem[1];			//D(0);
-	int j;
-	int i;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WS(i) -= fix_mul( ( l = WD(i) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WS(i) -= l;
-	}
-}
-
-static void dwt_decode_sp(dwt_t* v, int k, int n, int x) {
-	int m = k > n ? n : k;
-	int l = v->mem[1];			//D(0);
-	int j;
-	int i;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WS(i) += fix_mul( ( l = WD(i) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WS(i) += l;
-	}
-}
-
-static void dwt_decode_dm(dwt_t* v, int k, int n, int x) {
-	int m = k >= n ? n-1 : k;
-	int l = v->mem[0];				//S(0);
-	int i;
-	int j;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WD(i) -=  fix_mul( ( l = WS(i+1) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WD(i) -= l;
-	}
-}
-
-static void dwt_decode_dp(dwt_t* v, int k, int n, int x) {
-	int m = k >= n ? n-1 : k;
-	int l = v->mem[0];				//S(0);
-	int i;
-	int j;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WD(i) +=  fix_mul( ( l = WS(i+1) ) + j , x);
-	}
-
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WD(i) += l;
-	}
-}
-
-
-/* <summary>                             */
-/* Inverse 9-7 wavelet transform in 1-D. */
-/* </summary>                            */
-static void dwt_decode_1_real(dwt_t* v) {
-	int i;
-	if (!v->cas) {
-		if ((v->dn > 0) || (v->sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < v->sn; i++)
-				WS(i) = fix_mul(WS(i), 10078);	/* 10076 */
-			for (i = 0; i < v->dn; i++)
-				WD(i) = fix_mul(WD(i), 13318);	/* 13320 */
-			dwt_decode_sm(v, v->sn, v->dn, 3633);
-			dwt_decode_dm(v, v->dn, v->sn, 7233);
-			dwt_decode_sp(v, v->sn, v->dn, 434);
-			dwt_decode_dp(v, v->dn, v->sn, 12994);
-		}
-	} else {
-		if ((v->sn > 0) || (v->dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < v->sn; i++)
-				WD(i) = fix_mul(WD(i), 10078);	/* 10076 */
-			for (i = 0; i < v->dn; i++)
-				WS(i) = fix_mul(WS(i), 13318);	/* 13320 */
-			dwt_decode_dm(v, v->sn, v->dn, 3633);
-			dwt_decode_sm(v, v->dn, v->sn, 7233);
-			dwt_decode_dp(v, v->sn, v->dn, 434);
-			dwt_decode_sp(v, v->dn, v->sn, 12994);
-		}
-	}
-}
-
 static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
 	int p, n;
 	p = int_floorlog2(stepsize) - 13;
@@ -396,7 +321,7 @@
 */
 
 /* <summary>                            */
-/* Forward 5-3 wavelet tranform in 2-D. */
+/* Forward 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
 void dwt_encode(opj_tcd_tilecomp_t * tilec) {
 	int i, j, k;
@@ -411,7 +336,7 @@
 	
 	for (i = 0; i < l; i++) {
 		int rw;			/* width of the resolution level computed                                                           */
-		int rh;			/* heigth of the resolution level computed                                                          */
+		int rh;			/* height of the resolution level computed                                                          */
 		int rw1;		/* width of the resolution level once lower than computed one                                       */
 		int rh1;		/* height of the resolution level once lower than computed one                                      */
 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
@@ -452,10 +377,10 @@
 
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 2-D. */
+/* Inverse 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop) {
-	dwt_decode_tile(tilec, stop, &dwt_decode_1);
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
+	dwt_decode_tile(tilec, numres, &dwt_decode_1);
 }
 
 
@@ -494,7 +419,7 @@
 	
 	for (i = 0; i < l; i++) {
 		int rw;			/* width of the resolution level computed                                                     */
-		int rh;			/* heigth of the resolution level computed                                                    */
+		int rh;			/* height of the resolution level computed                                                    */
 		int rw1;		/* width of the resolution level once lower than computed one                                 */
 		int rh1;		/* height of the resolution level once lower than computed one                                */
 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
@@ -534,14 +459,6 @@
 }
 
 
-/* <summary>                             */
-/* Inverse 9-7 wavelet transform in 2-D. */
-/* </summary>                            */
-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop) {
-	dwt_decode_tile(tilec, stop, dwt_decode_1_real);
-}
-
-
 /* <summary>                          */
 /* Get gain of 9-7 wavelet transform. */
 /* </summary>                         */
@@ -582,7 +499,7 @@
 /* <summary>                             */
 /* Determine maximum computed resolution level for inverse wavelet transform */
 /* </summary>                            */
-static int dwt_decode_max_resolution(opj_tcd_resolution_t* r, int i) {
+static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
 	int mr	= 1;
 	int w;
 	while( --i ) {
@@ -597,65 +514,312 @@
 
 
 /* <summary>                            */
-/* Inverse wavelet tranform in 2-D.     */
+/* Inverse wavelet transform in 2-D.     */
 /* </summary>                           */
-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop, DWT1DFN dwt_1D) {
-	opj_tcd_resolution_t* tr;
-	int i, j, k;
-	int *a = NULL;
-	int *aj = NULL;
-	int *m;
-	int w; //, l;
-	int rw;			/* width of the resolution level computed  */
-	int rh;			/* heigth of the resolution level computed  */
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
 	dwt_t h;
 	dwt_t v;
-	
-	if( 1 > ( i = tilec->numresolutions - stop ) )
-		return ;
 
-	tr = tilec->resolutions;
+	opj_tcd_resolution_t* tr = tilec->resolutions;
 
-	w = tilec->x1-tilec->x0;
-	a = tilec->data;
+	int rw = tr->x1 - tr->x0;	/* width of the resolution level computed */
+	int rh = tr->y1 - tr->y0;	/* height of the resolution level computed */
 
-	m = (int*)opj_malloc(sizeof(int) * (dwt_decode_max_resolution(tr, i)+5));
-	h.mem = v.mem = (int*)( (unsigned)m + 16 - ( (unsigned)m % 16 ) ) ;
+	int w = tilec->x1 - tilec->x0;
 
-	rw = tr->x1 - tr->x0;
-	rh = tr->y1 - tr->y0;
+	h.mem = opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
+	v.mem = h.mem;
 
-	while( --i ) {
-		tr++;
+	while( --numres) {
+		int * restrict tiledp = tilec->data;
+		int j;
+
+		++tr;
 		h.sn = rw;
 		v.sn = rh;
-		h.dn = ( rw = tr->x1 - tr->x0 ) - h.sn;
-		v.dn = ( rh = tr->y1 - tr->y0 ) - v.sn;
-				
+
+		rw = tr->x1 - tr->x0;
+		rh = tr->y1 - tr->y0;
+
+		h.dn = rw - h.sn;
 		h.cas = tr->x0 % 2;
-		v.cas = tr->y0 % 2;
 
-		aj = a;
-		j = rh;
-		while( j-- ) {		
-			dwt_interleave_h(&h, aj);
+		for(j = 0; j < rh; ++j) {
+			dwt_interleave_h(&h, &tiledp[j*w]);
 			(dwt_1D)(&h);
-			k = rw;
-			while( k-- )
-				aj[k] = h.mem[k];
-			aj += w;
+			memcpy(&tiledp[j*w], h.mem, rw * sizeof(int));
 		}
 
-		aj = a;
-		j = rw;
-		while( j-- ) {
-			dwt_interleave_v(&v, aj, w);
+		v.dn = rh - v.sn;
+		v.cas = tr->y0 % 2;
+
+		for(j = 0; j < rw; ++j){
+			int k;
+			dwt_interleave_v(&v, &tiledp[j], w);
 			(dwt_1D)(&v);
-			k = rh;
-			while( k-- )
-				aj[k * w] = v.mem[k];
-			aj++;
+			for(k = 0; k < rh; ++k) {
+				tiledp[k * w + j] = v.mem[k];
+			}
+		}
+	}
+	opj_aligned_free(h.mem);
+}
+
+static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
+	float* restrict bi = (float*) (w->wavelet + w->cas);
+	int count = w->sn;
+	int i, k;
+	for(k = 0; k < 2; ++k){
+		for(i = 0; i < count; ++i){
+			int j = i;
+			bi[i*8    ] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 1] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 2] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 3] = a[j];
+		}
+		bi = (float*) (w->wavelet + 1 - w->cas);
+		a += w->sn;
+		size -= w->sn;
+		count = w->dn;
+	}
+}
+
+static void v4dwt_interleave_v(v4dwt_t* restrict v , float* restrict a , int x){
+	v4* restrict bi = v->wavelet + v->cas;
+	int i;
+	for(i = 0; i < v->sn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+	a += v->sn * x;
+	bi = v->wavelet + 1 - v->cas;
+	for(i = 0; i < v->dn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+}
+
+#ifdef __SSE__
+
+static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		__m128 tmp = vw[i*2];
+		vw[i*2] = tmp * c;
+	}
+}
+
+static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
+	__m128* restrict vl = (__m128*) l;
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		__m128 tmp1 = vl[ 0];
+		__m128 tmp2 = vw[-1];
+		__m128 tmp3 = vw[ 0];
+		vw[-1] = tmp2 + ((tmp1 + tmp3) * c);
+		vl = vw;
+		vw += 2;
+	}
+	if(m >= k){
+		return;
+	}
+	c += c;
+	c *= vl[0];
+	for(; m < k; ++m){
+		__m128 tmp = vw[-1];
+		vw[-1] = tmp + c;
+		vw += 2;
+	}
+}
+
+#else
+
+static void v4dwt_decode_step1(v4* w, int count, const float c){
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		float tmp1 = fw[i*8    ];
+		float tmp2 = fw[i*8 + 1];
+		float tmp3 = fw[i*8 + 2];
+		float tmp4 = fw[i*8 + 3];
+		fw[i*8    ] = tmp1 * c;
+		fw[i*8 + 1] = tmp2 * c;
+		fw[i*8 + 2] = tmp3 * c;
+		fw[i*8 + 3] = tmp4 * c;
+	}
+}
+
+static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
+	float* restrict fl = (float*) l;
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		float tmp1_1 = fl[0];
+		float tmp1_2 = fl[1];
+		float tmp1_3 = fl[2];
+		float tmp1_4 = fl[3];
+		float tmp2_1 = fw[-4];
+		float tmp2_2 = fw[-3];
+		float tmp2_3 = fw[-2];
+		float tmp2_4 = fw[-1];
+		float tmp3_1 = fw[0];
+		float tmp3_2 = fw[1];
+		float tmp3_3 = fw[2];
+		float tmp3_4 = fw[3];
+		fw[-4] = tmp2_1 + ((tmp1_1 + tmp3_1) * c);
+		fw[-3] = tmp2_2 + ((tmp1_2 + tmp3_2) * c);
+		fw[-2] = tmp2_3 + ((tmp1_3 + tmp3_3) * c);
+		fw[-1] = tmp2_4 + ((tmp1_4 + tmp3_4) * c);
+		fl = fw;
+		fw += 8;
+	}
+	if(m < k){
+		float c1;
+		float c2;
+		float c3;
+		float c4;
+		c += c;
+		c1 = fl[0] * c;
+		c2 = fl[1] * c;
+		c3 = fl[2] * c;
+		c4 = fl[3] * c;
+		for(; m < k; ++m){
+			float tmp1 = fw[-4];
+			float tmp2 = fw[-3];
+			float tmp3 = fw[-2];
+			float tmp4 = fw[-1];
+			fw[-4] = tmp1 + c1;
+			fw[-3] = tmp2 + c2;
+			fw[-2] = tmp3 + c3;
+			fw[-1] = tmp4 + c4;
+			fw += 8;
+		}
+	}
+}
+
+#endif
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 1-D. */
+/* </summary>                            */
+static void v4dwt_decode(v4dwt_t* restrict dwt){
+	int a, b;
+	if(dwt->cas == 0) {
+		if(!((dwt->dn > 0) || (dwt->sn > 1))){
+			return;
+		}
+		a = 0;
+		b = 1;
+	}else{
+		if(!((dwt->sn > 0) || (dwt->dn > 1))) {
+			return;
+		}
+		a = 1;
+		b = 0;
+	}
+#ifdef __SSE__
+	v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(K));
+	v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(c13318));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(delta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(gamma));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(beta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(alpha));
+#else
+	v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, K);
+	v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, c13318);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), delta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), gamma);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), beta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), alpha);
+#endif
+}
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 2-D. */
+/* </summary>                            */
+void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
+	v4dwt_t h;
+	v4dwt_t v;
+
+	opj_tcd_resolution_t* res = tilec->resolutions;
+
+	int rw = res->x1 - res->x0;	/* width of the resolution level computed */
+	int rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+	int w = tilec->x1 - tilec->x0;
+
+	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
+	v.wavelet = h.wavelet;
+
+	while( --numres) {
+		float * restrict aj = (float*) tilec->data;
+		int bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
+		int j;
+
+		h.sn = rw;
+		v.sn = rh;
+
+		++res;
+
+		rw = res->x1 - res->x0;	/* width of the resolution level computed */
+		rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+		h.dn = rw - h.sn;
+		h.cas = res->x0 % 2;
+
+		for(j = rh; j > 0; j -= 4){
+			v4dwt_interleave_h(&h, aj, w, bufsize);
+			v4dwt_decode(&h);
+			if(j >= 4){
+				int k;
+				for(k = rw; --k >= 0;){
+					aj[k    ] = h.wavelet[k].f[0];
+					aj[k+w  ] = h.wavelet[k].f[1];
+					aj[k+w*2] = h.wavelet[k].f[2];
+					aj[k+w*3] = h.wavelet[k].f[3];
+				}
+			}else{
+				int k;
+				for(k = rw; --k >= 0;){
+					switch(j) {
+						case 3: aj[k+w*2] = h.wavelet[k].f[2];
+						case 2: aj[k+w  ] = h.wavelet[k].f[1];
+						case 1: aj[k    ] = h.wavelet[k].f[0];
+					}
+				}
+			}
+			aj += w*4;
+			bufsize -= w*4;
+		}
+
+		v.dn = rh - v.sn;
+		v.cas = res->y0 % 2;
+
+		aj = (float*) tilec->data;
+		for(j = rw; j > 0; j -= 4){
+			v4dwt_interleave_v(&v, aj, w);
+			v4dwt_decode(&v);
+			if(j >= 4){
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(float));
+				}
+			}else{
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], j * sizeof(float));
+				}
+			}
+			aj += 4;
 		}
 	}
-	opj_free(m);
+
+	opj_aligned_free(h.wavelet);
 }
+
diff -urN -xdebian -x.svn ./libopenjpeg/dwt.h /usr/src/openjpeg/trunk/libopenjpeg/dwt.h
--- ./libopenjpeg/dwt.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/dwt.h	2007-11-27 22:39:50.000000000 +0000
@@ -57,9 +57,9 @@
 Inverse 5-3 wavelet tranform in 2-D.
 Apply a reversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
-@param stop FIXME Number of decoded resolution levels ?
+@param numres Number of resolution levels to decode
 */
-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop);
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the reversible 5-3 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
@@ -83,9 +83,9 @@
 Inverse 9-7 wavelet transform in 2-D. 
 Apply an irreversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
-@param stop FIXME Number of decoded resolution levels ?
+@param numres Number of resolution levels to decode
 */
-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop);
+void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the irreversible 9-7 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
@@ -100,9 +100,9 @@
 */
 double dwt_getnorm_real(int level, int orient);
 /**
-FIXME : comment ???
-@param tccp
-@param prec
+Explicit calculation of the Quantization Stepsizes 
+@param tccp Tile-component coding parameters
+@param prec Precint analyzed
 */
 void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
 /* ----------------------------------------------------------------------- */
diff -urN -xdebian -x.svn ./libopenjpeg/image.c /usr/src/openjpeg/trunk/libopenjpeg/image.c
--- ./libopenjpeg/image.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/image.c	2007-11-27 22:39:50.000000000 +0000
@@ -26,7 +26,7 @@
 
 #include "opj_includes.h"
 
-opj_image_t* opj_image_create0() {
+opj_image_t* opj_image_create0(void) {
 	opj_image_t *image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
 	return image;
 }
@@ -35,13 +35,14 @@
 	int compno;
 	opj_image_t *image = NULL;
 
-	image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
+	image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));
 	if(image) {
 		image->color_space = clrspc;
 		image->numcomps = numcmpts;
 		/* allocate memory for the per-component information */
 		image->comps = (opj_image_comp_t*)opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
 		if(!image->comps) {
+			fprintf(stderr,"Unable to allocate memory for image.\n");
 			opj_image_destroy(image);
 			return NULL;
 		}
@@ -57,8 +58,9 @@
 			comp->prec = cmptparms[compno].prec;
 			comp->bpp = cmptparms[compno].bpp;
 			comp->sgnd = cmptparms[compno].sgnd;
-			comp->data = (int*)opj_malloc(comp->w * comp->h * sizeof(int));
+			comp->data = (int*) opj_calloc(comp->w * comp->h, sizeof(int));
 			if(!comp->data) {
+				fprintf(stderr,"Unable to allocate memory for image.\n");
 				opj_image_destroy(image);
 				return NULL;
 			}
diff -urN -xdebian -x.svn ./libopenjpeg/image.h /usr/src/openjpeg/trunk/libopenjpeg/image.h
--- ./libopenjpeg/image.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/image.h	2007-09-28 11:33:44.000000000 +0100
@@ -40,7 +40,7 @@
 @todo this function should be removed
 @return returns an empty image if successful, returns NULL otherwise
 */
-opj_image_t* opj_image_create0();
+opj_image_t* opj_image_create0(void);
 
 /*@}*/
 
diff -urN -xdebian -x.svn ./libopenjpeg/j2k.c /usr/src/openjpeg/trunk/libopenjpeg/j2k.c
--- ./libopenjpeg/j2k.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/j2k.c	2007-11-27 22:39:50.000000000 +0000
@@ -259,13 +259,13 @@
 }
 
 static void j2k_check_poc_val(opj_cparameters_t *parameters, int numcomps, int numlayers){
+	int* packet_array;
 	int index, resno, compno, layno, i;
-	char loss = 0;
 	int step_c = 1;
 	int step_r = numcomps * step_c;
 	int step_l = parameters->numresolution * step_r;
-	int array_size = step_l * numlayers * sizeof(int);
-	int *packet_array = (int *) opj_malloc(array_size);
+	bool loss = false;
+	packet_array = (int*) opj_calloc(step_l * numlayers, sizeof(int));
 	
 	for (i = 0; i < parameters->numpocs ; i++) {
 		int layno0 = 0;
@@ -285,12 +285,12 @@
 			for (layno = 0; layno < numlayers ; layno++) {
 				index = step_r * resno + step_c * compno + step_l * layno;
 				if(!(	packet_array[index]== 1)){
-					loss = 1;
+					loss = true;
 				}
 			}
 		}
 	}
-	if(loss == 1)
+	if(loss)
 		fprintf(stdout,"Missing packets possible loss of data\n");
 	opj_free(packet_array);
 }
@@ -406,7 +406,7 @@
 
 /**	mem allocation for TLM marker*/
 int j2k_calculate_tp(opj_cp_t *cp,int img_numcomp,opj_image_t *image,opj_j2k_t *j2k ){
-	int pino,tileno,maxres=0,totnum_tp=0;
+	int pino,tileno,totnum_tp=0;
 	j2k->cur_totnum_tp = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		int cur_totnum_tp = 0;
@@ -421,6 +421,12 @@
 			pi_destroy(pi, cp, tileno);
 		}
 		j2k->cur_totnum_tp[tileno] = cur_totnum_tp;
+		/* INDEX >> */
+		if (j2k->cstr_info) {
+			j2k->cstr_info->tile[tileno].num_tps = cur_totnum_tp;
+			j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
+		}
+		/* << INDEX */
 	}
 	return totnum_tp;
 }
@@ -428,10 +434,24 @@
 static void j2k_write_soc(opj_j2k_t *j2k) {
 	opj_cio_t *cio = j2k->cio;
 	cio_write(cio, J2K_MS_SOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio) - 2, 2);
+
+#endif /* USE_JPWL */
+/* <<UniPG */
 }
 
-static void j2k_read_soc(opj_j2k_t *j2k) {
+static void j2k_read_soc(opj_j2k_t *j2k) {	
 	j2k->state = J2K_STATE_MHSIZ;
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->main_head_start = cio_tell(j2k->cio) - 2;
+		j2k->cstr_info->codestream_size = cio_numbytesleft(j2k->cio) + 2 - j2k->cstr_info->main_head_start;
+	}
 }
 
 static void j2k_write_siz(opj_j2k_t *j2k) {
@@ -525,7 +545,7 @@
 	}
 #endif /* USE_JPWL */
 
-	image->comps = (opj_image_comp_t *) opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
+	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
 	for (i = 0; i < image->numcomps; i++) {
 		int tmp, w, h;
 		tmp = cio_read(cio, 1);		/* Ssiz_i */
@@ -563,13 +583,12 @@
 		}
 #endif /* USE_JPWL */
 
-
 		/* TODO: unused ? */
 		w = int_ceildiv(image->x1 - image->x0, image->comps[i].dx);
 		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);
 
 		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
-		image->comps[i].factor = 0;			/* reducing factor per component */
+		image->comps[i].factor = cp->reduce; /* reducing factor per component */
 	}
 	
 	cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
@@ -615,8 +634,8 @@
 	}
 #endif /* USE_JPWL */
 
-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
-	cp->tileno = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+	cp->tileno = (int*) opj_malloc(cp->tw * cp->th * sizeof(int));
 	cp->tileno_size = 0;
 	
 #ifdef USE_JPWL
@@ -644,14 +663,29 @@
 	cp->ppm_data_first = NULL;
 	cp->ppm_previous = 0;
 	cp->ppm_store = 0;
-	
-	j2k->default_tcp->tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
+
+	j2k->default_tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
 	for (i = 0; i < cp->tw * cp->th; i++) {
-		cp->tcps[i].tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
-	}
-	j2k->tile_data = (unsigned char **) opj_malloc(cp->tw * cp->th * sizeof(unsigned char *));
-	j2k->tile_len = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+		cp->tcps[i].tccps = (opj_tccp_t*) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
+	}	
+	j2k->tile_data = (unsigned char**) opj_calloc(cp->tw * cp->th, sizeof(unsigned char*));
+	j2k->tile_len = (int*) opj_calloc(cp->tw * cp->th, sizeof(int));
 	j2k->state = J2K_STATE_MH;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	
+		cstr_info->tile_y = cp->tdy;	
+		cstr_info->tile_Ox = cp->tx0;	
+		cstr_info->tile_Oy = cp->ty0;			
+		cstr_info->tile = (opj_tile_info_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tile_info_t));		
+	}
 }
 
 static void j2k_write_com(opj_j2k_t *j2k) {
@@ -665,7 +699,7 @@
 		cio_write(cio, J2K_MS_COM, 2);
 		lenp = cio_tell(cio);
 		cio_skip(cio, 2);
-		cio_write(cio, 0, 2);
+		cio_write(cio, 1, 2);		/* General use (IS 8859-15:1999 (Latin) values) */
 		for (i = 0; i < strlen(comment); i++) {
 			cio_write(cio, comment[i], 1);
 		}
@@ -716,8 +750,13 @@
 
 	tccp->numresolutions = cio_read(cio, 1) + 1;	/* SPcox (D) */
 
-	/* check the reduce value */
-	cp->reduce = int_min((tccp->numresolutions)-1, cp->reduce);
+	// If user wants to remove more resolutions than the codestream contains, return error
+	if (cp->reduce >= tccp->numresolutions) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
+					"of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
+		j2k->state |= J2K_STATE_ERR;
+	}
+
 	tccp->cblkw = cio_read(cio, 1) + 2;	/* SPcox (E) */
 	tccp->cblkh = cio_read(cio, 1) + 2;	/* SPcox (F) */
 	tccp->cblksty = cio_read(cio, 1);	/* SPcox (G) */
@@ -729,6 +768,21 @@
 			tccp->prch[i] = tmp >> 4;
 		}
 	}
+
+	/* INDEX >> */
+	if(j2k->cstr_info && compno == 0) {
+		for (i = 0; i < tccp->numresolutions; i++) {
+			if (tccp->csty & J2K_CP_CSTY_PRT) {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = tccp->prcw[i];
+				j2k->cstr_info->tile[j2k->curtileno].pdy[i] = tccp->prch[i];
+			}
+			else {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+			}
+		}
+	}
+	/* << INDEX */
 }
 
 static void j2k_write_cod(opj_j2k_t *j2k) {
@@ -778,6 +832,17 @@
 		cio_seek(cio, pos);
 		j2k_read_cox(j2k, i);
 	}
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->prog = tcp->prg;
+		cstr_info->numlayers = tcp->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (i = 0; i < image->numcomps; i++) {
+			cstr_info->numdecompos[i] = tcp->tccps[i].numresolutions - 1;
+		}
+	}
 }
 
 static void j2k_write_coc(opj_j2k_t *j2k, int compno) {
@@ -1018,7 +1083,6 @@
 	
 	opj_cp_t *cp = j2k->cp;
 	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_tccp_t *tccp = &tcp->tccps[0];
 	opj_cio_t *cio = j2k->cio;
 	
 	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
@@ -1149,7 +1213,7 @@
 						"JPWL: failed memory allocation during PPM marker parsing (pos. %x)\n",
 						cio_tell(cio));
 					if (!JPWL_ASSUME || JPWL_ASSUME) {
-						free(cp->ppm_data);
+						opj_free(cp->ppm_data);
 						opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
 						return;
 					}
@@ -1229,6 +1293,13 @@
 	cio_seek(cio, lenp);
 	cio_write(cio, len, 2);				/* Lsot */
 	cio_seek(cio, lenp + len);
+
+	/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOT, j2k->sot_start, len + 2);
+#endif /* USE_JPWL */
+	/* <<UniPG */
 }
 
 static void j2k_read_sot(opj_j2k_t *j2k) {
@@ -1238,7 +1309,7 @@
 
 	opj_cp_t *cp = j2k->cp;
 	opj_cio_t *cio = j2k->cio;
-	
+
 	len = cio_read(cio, 2);
 	tileno = cio_read(cio, 2);
 
@@ -1267,7 +1338,6 @@
 		backup_tileno++;
 	};
 #endif /* USE_JPWL */
-
 	
 	if (cp->tileno_size == 0) {
 		cp->tileno[cp->tileno_size] = tileno;
@@ -1315,12 +1385,34 @@
 	numparts = cio_read(cio, 1);
 	
 	j2k->curtileno = tileno;
+	j2k->cur_tp_num = partno;
 	j2k->eot = cio_getbp(cio) - 12 + totlen;
 	j2k->state = J2K_STATE_TPH;
 	tcp = &cp->tcps[j2k->curtileno];
+
+	/* Index */
+	if (j2k->cstr_info) {
+		if (tcp->first) {
+			if (tileno == 0) 
+				j2k->cstr_info->main_head_end = cio_tell(cio) - 13;
+			j2k->cstr_info->tile[tileno].tileno = tileno;
+			j2k->cstr_info->tile[tileno].start_pos = cio_tell(cio) - 12;
+			j2k->cstr_info->tile[tileno].end_pos = j2k->cstr_info->tile[tileno].start_pos + totlen - 1;				
+			j2k->cstr_info->tile[tileno].num_tps = numparts;
+			if (numparts)
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));
+			else
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)
+		}
+		else {
+			j2k->cstr_info->tile[tileno].end_pos += totlen;
+		}		
+		j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = cio_tell(cio) - 12;
+		j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos = 
+			j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
+	}
 	
-	if (tcp->first == 1) {
-		
+	if (tcp->first == 1) {		
 		/* Initialization PPT */
 		opj_tccp_t *tmp = tcp->tccps;
 		memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t));
@@ -1340,7 +1432,7 @@
 	int l, layno;
 	int totlen;
 	opj_tcp_t *tcp = NULL;
-	opj_image_info_t *image_info = NULL;
+	opj_codestream_info_t *cstr_info = NULL;
 	
 	opj_tcd_t *tcd = (opj_tcd_t*)tile_coder;	/* cast is needed because of conflicts in header inclusions */
 	opj_cp_t *cp = j2k->cp;
@@ -1348,17 +1440,29 @@
 
 	tcd->tp_num = j2k->tp_num ;
 	tcd->cur_tp_num = j2k->cur_tp_num;
-	tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
 	
 	cio_write(cio, J2K_MS_SOD, 2);
 	if (j2k->curtileno == 0) {
 		j2k->sod_start = cio_tell(cio) + j2k->pos_correction;
 	}
-	
+
 	/* INDEX >> */
-	image_info = j2k->image_info;
-	if (image_info && image_info->index_on) {
-		image_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+	cstr_info = j2k->cstr_info;
+	if (cstr_info) {
+		if (!j2k->cur_tp_num ) {
+			cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+			j2k->cstr_info->tile[j2k->curtileno].tileno = j2k->curtileno;
+		}
+		else{
+			if(cstr_info->tile[j2k->curtileno].packet[cstr_info->packno - 1].end_pos < cio_tell(cio))
+				cstr_info->tile[j2k->curtileno].packet[cstr_info->packno].start_pos = cio_tell(cio);
+		}
+		/* UniPG>> */
+#ifdef USE_JPWL
+		/* update markers struct */
+		j2k_add_marker(j2k->cstr_info, J2K_MS_SOD, j2k->sod_start, 2);
+#endif /* USE_JPWL */
+		/* <<UniPG */
 	}
 	/* << INDEX */
 	
@@ -1366,11 +1470,13 @@
 	for (layno = 0; layno < tcp->numlayers; layno++) {
 		tcp->rates[layno] -= tcp->rates[layno] ? (j2k->sod_start / (cp->th * cp->tw)) : 0;
 	}
-	if(image_info) {
-		image_info->num = 0;
+	if(j2k->cur_tp_num == 0){
+		tcd->tcd_image->tiles->packno = 0;
+		if(cstr_info)
+			cstr_info->packno = 0;
 	}
 	
-	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, image_info);
+	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, cstr_info);
 	
 	/* Writing Psot in SOT marker */
 	totlen = cio_tell(cio) + l - j2k->sot_start;
@@ -1392,26 +1498,31 @@
 
 	opj_cio_t *cio = j2k->cio;
 	int curtileno = j2k->curtileno;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+			cio_tell(cio) + j2k->pos_correction - 1;
+		if (j2k->cur_tp_num == 0)
+			j2k->cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+		j2k->cstr_info->packno = 0;
+	}
 	
 	len = int_min(j2k->eot - cio_getbp(cio), cio_numbytesleft(cio) + 1);
-	
+
 	if (len == cio_numbytesleft(cio) + 1) {
 		truncate = 1;		/* Case of a truncate codestream */
-	}
-	
-	data = (unsigned char *) opj_malloc((j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
+	}	
 
-	for (i = 0; i < j2k->tile_len[curtileno]; i++) {
-		data[i] = j2k->tile_data[curtileno][i];
-	}
+	data = j2k->tile_data[curtileno];
+	data = (unsigned char*) opj_realloc(data, (j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
 
 	data_ptr = data + j2k->tile_len[curtileno];
 	for (i = 0; i < len; i++) {
 		data_ptr[i] = cio_read(cio, 1);
 	}
-	
+
 	j2k->tile_len[curtileno] += len;
-	opj_free(j2k->tile_data[curtileno]);
 	j2k->tile_data[curtileno] = data;
 	
 	if (!truncate) {
@@ -1419,10 +1530,10 @@
 	} else {
 		j2k->state = J2K_STATE_NEOC;	/* RAJOUTE !! */
 	}
+	j2k->cur_tp_num++;
 }
 
 static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno) {
-	
 	opj_cp_t *cp = j2k->cp;
 	opj_tcp_t *tcp = &cp->tcps[tileno];
 	opj_cio_t *cio = j2k->cio;
@@ -1469,20 +1580,34 @@
 	opj_cio_t *cio = j2k->cio;
 	/* opj_event_msg(j2k->cinfo, "%.8x: EOC\n", cio_tell(cio) + j2k->pos_correction); */
 	cio_write(cio, J2K_MS_EOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EOC, cio_tell(cio) - 2, 2);
+#endif /* USE_JPWL */
+/* <<UniPG */
 }
 
 static void j2k_read_eoc(opj_j2k_t *j2k) {
 	int i, tileno;
+	bool success;
 
 	/* if packets should be decoded */
 	if (j2k->cp->limit_decoding != DECODE_ALL_BUT_PACKETS) {
 		opj_tcd_t *tcd = tcd_create(j2k->cinfo);
 		tcd_malloc_decode(tcd, j2k->image, j2k->cp);
 		for (i = 0; i < j2k->cp->tileno_size; i++) {
+			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
 			tileno = j2k->cp->tileno[i];
-			tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno);
+			success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
 			opj_free(j2k->tile_data[tileno]);
 			j2k->tile_data[tileno] = NULL;
+			tcd_free_decode_tile(tcd, i);
+			if (success == false) {
+				j2k->state |= J2K_STATE_ERR;
+				break;
+			}
 		}
 		tcd_free_decode(tcd);
 		tcd_destroy(tcd);
@@ -1494,9 +1619,11 @@
 			opj_free(j2k->tile_data[tileno]);
 			j2k->tile_data[tileno] = NULL;
 		}
-	}
-	
-	j2k->state = J2K_STATE_MT;
+	}	
+	if (j2k->state & J2K_STATE_ERR)
+		j2k->state = J2K_STATE_MT + J2K_STATE_ERR;
+	else
+		j2k->state = J2K_STATE_MT; 
 }
 
 typedef struct opj_dec_mstabent {
@@ -1535,6 +1662,10 @@
   {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},
   {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},
 #endif /* USE_JPWL */
+#ifdef USE_JPSEC
+  {J2K_MS_SEC, J2K_STATE_MH, j2k_read_sec},
+  {J2K_MS_INSEC, 0, j2k_read_insec},
+#endif /* USE_JPSEC */
 
   {0, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_unk}
 };
@@ -1620,15 +1751,19 @@
 /* ----------------------------------------------------------------------- */
 
 opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
-	if(j2k) {
-		j2k->cinfo = cinfo;
-		j2k->default_tcp = (opj_tcp_t*)opj_malloc(sizeof(opj_tcp_t));
-		if(!j2k->default_tcp) {
-			opj_free(j2k);
-			return NULL;
-		}
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
+	if(!j2k)
+		return NULL;
+
+	j2k->default_tcp = (opj_tcp_t*) opj_calloc(1, sizeof(opj_tcp_t));
+	if(!j2k->default_tcp) {
+		opj_free(j2k);
+		return NULL;
 	}
+
+	j2k->cinfo = cinfo;
+	j2k->tile_data = NULL;
+
 	return j2k;
 }
 
@@ -1676,14 +1811,13 @@
 
 		opj_free(cp);
 	}
-
 	opj_free(j2k);
 }
 
 void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters) {
 	if(j2k && parameters) {
 		/* create and initialize the coding parameters structure */
-		opj_cp_t *cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+		opj_cp_t *cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
 		cp->reduce = parameters->cp_reduce;	
 		cp->layer = parameters->cp_layer;
 		cp->limit_decoding = parameters->cp_limit_decoding;
@@ -1700,12 +1834,15 @@
 	}
 }
 
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio) {
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	opj_image_t *image = NULL;
 
-	opj_common_ptr cinfo = j2k->cinfo;
+	opj_common_ptr cinfo = j2k->cinfo;	
 
 	j2k->cio = cio;
+	j2k->cstr_info = cstr_info;
+	if (cstr_info)
+		memset(cstr_info, 0, sizeof(opj_codestream_info_t));
 
 	/* create an empty image */
 	image = opj_image_create0();
@@ -1717,7 +1854,6 @@
 		opj_dec_mstabent_t *e;
 		int id = cio_read(cio, 2);
 
-
 #ifdef USE_JPWL
 		/* we try to honor JPWL correction power */
 		if (j2k->cp->correct) {
@@ -1777,6 +1913,9 @@
 		if (e->handler) {
 			(*e->handler)(j2k);
 		}
+		if (j2k->state & J2K_STATE_ERR) 
+			return NULL;	
+
 		if (j2k->state == J2K_STATE_MT) {
 			break;
 		}
@@ -1799,7 +1938,7 @@
 * Read a JPT-stream and decode file
 *
 */
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio) {
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio,  opj_codestream_info_t *cstr_info) {
 	opj_image_t *image = NULL;
 	opj_jpt_msg_header_t header;
 	int position;
@@ -1810,6 +1949,7 @@
 
 	/* create an empty image */
 	image = opj_image_create0();
+	j2k->image = image;
 
 	j2k->state = J2K_STATE_MHSOC;
 	
@@ -1882,7 +2022,7 @@
 /* ----------------------------------------------------------------------- */
 
 opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
 	if(j2k) {
 		j2k->cinfo = cinfo;
 	}
@@ -1893,20 +2033,6 @@
 	int tileno;
 
 	if(!j2k) return;
-
-	if(j2k->image_info != NULL) {
-		opj_image_info_t *image_info = j2k->image_info;
-		if (image_info->index_on && j2k->cp) {
-			opj_cp_t *cp = j2k->cp;
-			for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-				opj_tile_info_t *tile_info = &image_info->tile[tileno];
-				opj_free(tile_info->thresh);
-				opj_free(tile_info->packet);
-			}
-			opj_free(image_info->tile);
-		}
-		opj_free(image_info);
-	}
 	if(j2k->cp != NULL) {
 		opj_cp_t *cp = j2k->cp;
 
@@ -1935,7 +2061,7 @@
 	}
 
 	/* create and initialize the coding parameters structure */
-	cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+	cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
 
 	/* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
 	j2k->cp = cp;
@@ -1961,12 +2087,6 @@
 		memcpy(cp->matrice, parameters->cp_matrice, array_size);
 	}
 
-	/* creation of an index file ? */
-	cp->index_on = parameters->index_on;
-	if(cp->index_on) {
-		j2k->image_info = (opj_image_info_t*)opj_malloc(sizeof(opj_image_info_t));
-	}
-
 	/* tiles */
 	cp->tdx = parameters->cp_tdx;
 	cp->tdy = parameters->cp_tdy;
@@ -2065,7 +2185,7 @@
 
 	/* initialize the mutiple tiles */
 	/* ---------------------------- */
-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
 
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		opj_tcp_t *tcp = &cp->tcps[tileno];
@@ -2112,8 +2232,8 @@
 			tcp->numpocs = 0;
 		}
 
-		tcp->tccps = (opj_tccp_t *) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
-		
+		tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+
 		for (i = 0; i < image->numcomps; i++) {
 			opj_tccp_t *tccp = &tcp->tccps[i];
 			tccp->csty = parameters->csty & 0x01;	/* 0 => one precinct || 1 => custom precinct  */
@@ -2191,244 +2311,8 @@
 	}
 }
 
-/**
-Create an index file
-@param j2k
-@param cio
-@param image_info
-@param index Index filename
-@return Returns 1 if successful, returns 0 otherwise
-*/
-static int j2k_create_index(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_info_t *image_info, char *index) {
-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
-	FILE *stream = NULL;
-	double total_disto = 0;
-
-	image_info->codestream_size = cio_tell(cio) + j2k->pos_correction;	/* Correction 14/4/03 suite rmq de Patrick */
-
-
-#ifdef USE_JPWL
-	/* if JPWL is enabled and the name coincides with our own set
-	   then discard the creation of the file: this was just done to
-	   enable indexing, we do not want an index file
-	*/
-	if (j2k->cp->epc_on && !strcmp(index, JPWL_PRIVATEINDEX_NAME))
-		return 1;
-#endif /* USE_JPWL */
-
-
-	stream = fopen(index, "w");
-	if (!stream) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to open %s for writing\n", index);
-		return 0;
-	}
-	
-	fprintf(stream, "%d %d\n", image_info->image_w, image_info->image_h);
-	fprintf(stream, "%d\n", image_info->prog);
-	fprintf(stream, "%d %d\n", image_info->tile_x, image_info->tile_y);
-	fprintf(stream, "%d %d\n", image_info->tw, image_info->th);
-	fprintf(stream, "%d\n", image_info->comp);
-	fprintf(stream, "%d\n", image_info->layer);
-	fprintf(stream, "%d\n", image_info->decomposition);
-	
-	for (resno = image_info->decomposition; resno >= 0; resno--) {
-		fprintf(stream, "[%d,%d] ", 
-			(1 << image_info->tile[0].pdx[resno]), (1 << image_info->tile[0].pdx[resno]));	/* based on tile 0 */
-	}
-	fprintf(stream, "\n");
-	fprintf(stream, "%d\n", image_info->main_head_end);
-	fprintf(stream, "%d\n", image_info->codestream_size);
-	
-	for (tileno = 0; tileno < image_info->tw * image_info->th; tileno++) {
-		fprintf(stream, "%4d %9d %9d %9d %9e %9d %9e\n",
-			image_info->tile[tileno].num_tile,
-			image_info->tile[tileno].start_pos,
-			image_info->tile[tileno].end_header,
-			image_info->tile[tileno].end_pos,
-			image_info->tile[tileno].distotile, image_info->tile[tileno].nbpix,
-			image_info->tile[tileno].distotile / image_info->tile[tileno].nbpix);
-	}
-	
-	for (tileno = 0; tileno < image_info->tw * image_info->th; tileno++) {
-		int start_pos, end_pos;
-		double disto = 0;
-		pack_nb = 0;
-		
-		/*
-		fprintf(stream, "pkno tileno layerno resno compno precno start_pos   end_pos       deltaSE        \n");
-		*/
-		
-		if (image_info->prog == LRCP) {	/* LRCP */
-			/*
-			fprintf(stream, "pack_nb tileno layno resno compno precno start_pos  end_pos   disto");
-			*/
-			for (layno = 0; layno < image_info->layer; layno++) {
-				for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-						for (precno = 0; precno < prec_max; precno++) {
-							start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-							end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-							disto = image_info->tile[tileno].packet[pack_nb].disto;
-							fprintf(stream, "%4d %6d %7d %5d %6d %6d %9d %9d %8e\n",
-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_pos, disto);
-							total_disto += disto;
-							pack_nb++;
-						}
-					}
-				}
-			}
-		} /* LRCP */
-		else if (image_info->prog == RLCP) {	/* RLCP */
-			/*
-			fprintf(stream, "pack_nb tileno resno layno compno precno start_pos  end_pos   disto");
-			*/
-			for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-				for (layno = 0; layno < image_info->layer; layno++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-						for (precno = 0; precno < prec_max; precno++) {
-							start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-							end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-							disto = image_info->tile[tileno].packet[pack_nb].disto;
-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d %9d %8e\n",
-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_pos, disto);
-							total_disto += disto;
-							pack_nb++;
-						}
-					}
-				}
-			}
-		} /* RLCP */
-		else if (image_info->prog == RPCL) {	/* RPCL */
-			/*
-			fprintf(stream, "\npack_nb tileno resno precno compno layno start_pos  end_pos   disto\n"); 
-			*/
-			for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-				/* I suppose components have same XRsiz, YRsiz */
-				int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-				int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-				int x1 = x0 + image_info->tile_x;
-				int y1 = y0 + image_info->tile_y;
-				for(y = y0; y < y1; y++) {
-					for(x = x0; x < x1; x++) {
-						for (compno = 0; compno < image_info->comp; compno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d %9d %8e\n",
-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* compno */
-					} /* x = x0..x1 */
-				} /* y = y0..y1 */
-			} /* resno */
-		} /* RPCL */
-		else if (image_info->prog == PCRL) {	/* PCRL */
-			/* I suppose components have same XRsiz, YRsiz */
-			int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-			int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-			int x1 = x0 + image_info->tile_x;
-			int y1 = y0 + image_info->tile_y;
-			/*
-			fprintf(stream, "\npack_nb tileno precno compno resno layno start_pos  end_pos   disto\n"); 
-			*/
-			for(y = y0; y < y1; y++) {
-				for(x = x0; x < x1; x++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* resno */
-					} /* compno */
-				} /* x = x0..x1 */
-			} /* y = y0..y1 */
-		} /* PCRL */
-		else {	/* CPRL */
-			/*
-			fprintf(stream, "\npack_nb tileno compno precno resno layno start_pos  end_pos   disto\n"); 
-			*/
-			for (compno = 0; compno < image_info->comp; compno++) {
-				/* I suppose components have same XRsiz, YRsiz */
-				int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-				int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-				int x1 = x0 + image_info->tile_x;
-				int y1 = y0 + image_info->tile_y;
-				for(y = y0; y < y1; y++) {
-					for(x = x0; x < x1; x++) {
-						for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* resno */
-					} /* x = x0..x1 */
-				} /* y = y0..y1 */
-			} /* comno */
-		} /* CPRL */   
-	} /* tileno */
-	
-	fprintf(stream, "%8e\n", image_info->D_max); /* SE max */
-	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
-	fclose(stream);
-
-	return 1;
-}
-
-bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, char *index) {
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	int tileno, compno;
-	opj_image_info_t *image_info = NULL;
 	opj_cp_t *cp = NULL;
 
 	opj_tcd_t *tcd = NULL;	/* TCD component */
@@ -2441,31 +2325,38 @@
 	/* j2k_dump_cp(stdout, image, cp); */
 
 	/* INDEX >> */
-	image_info = j2k->image_info;
-	if (image_info && cp->index_on) {
-		image_info->index_on = cp->index_on;
-		image_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
-		image_info->image_w = image->x1 - image->x0;
-		image_info->image_h = image->y1 - image->y0;
-		image_info->prog = (&cp->tcps[0])->prg;
-		image_info->tw = cp->tw;
-		image_info->th = cp->th;
-		image_info->tile_x = cp->tdx;	/* new version parser */
-		image_info->tile_y = cp->tdy;	/* new version parser */
-		image_info->tile_Ox = cp->tx0;	/* new version parser */
-		image_info->tile_Oy = cp->ty0;	/* new version parser */
-		image_info->comp = image->numcomps;
-		image_info->layer = (&cp->tcps[0])->numlayers;
-		image_info->decomposition = (&cp->tcps[0])->tccps->numresolutions - 1;
-		image_info->D_max = 0;		/* ADD Marcela */
+	j2k->cstr_info = cstr_info;
+	if (cstr_info) {
+		int compno;
+		cstr_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->prog = (&cp->tcps[0])->prg;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	/* new version parser */
+		cstr_info->tile_y = cp->tdy;	/* new version parser */
+		cstr_info->tile_Ox = cp->tx0;	/* new version parser */
+		cstr_info->tile_Oy = cp->ty0;	/* new version parser */
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->numlayers = (&cp->tcps[0])->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (compno=0; compno < image->numcomps; compno++) {
+			cstr_info->numdecompos[compno] = (&cp->tcps[0])->tccps->numresolutions - 1;
+		}
+		cstr_info->D_max = 0.0;		/* ADD Marcela */
+		cstr_info->main_head_start = cio_tell(cio); /* position of SOC */
+		cstr_info->maxmarknum = 100;
+		cstr_info->marker = (opj_marker_info_t *) opj_malloc(cstr_info->maxmarknum * sizeof(opj_marker_info_t));
+		cstr_info->marknum = 0;
 	}
 	/* << INDEX */
-	
+
 	j2k_write_soc(j2k);
 	j2k_write_siz(j2k);
 	j2k_write_cod(j2k);
 	j2k_write_qcd(j2k);
-	
+
 	if(cp->cinema){
 		for (compno = 1; compno < image->numcomps; compno++) {
 			j2k_write_coc(j2k, compno);
@@ -2481,61 +2372,72 @@
 	if (cp->comment != NULL) {
 		j2k_write_com(j2k);
 	}
-	/* INDEX >> */
-	if(image_info && image_info->index_on) {
-		image_info->main_head_end = cio_tell(cio) - 1;
-	}
-	/* << INDEX */
 
 	j2k->totnum_tp = j2k_calculate_tp(cp,image->numcomps,image,j2k);
-	/*	 TLM Marker*/
+	/* TLM Marker*/
 	if(cp->cinema){
 		j2k_write_tlm(j2k);
 		if (cp->cinema == CINEMA4K_24) {
 			j2k_write_poc(j2k);
 		}
 	}
+
+	/* uncomment only for testing JPSEC marker writing */
+	/* j2k_write_sec(j2k); */
+
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->main_head_end = cio_tell(cio) - 1;
+	}
+	/* << INDEX */
 	/**** Main Header ENDS here ***/
-	
+
 	/* create the tile encoder */
 	tcd = tcd_create(j2k->cinfo);
 
 	/* encode each tile */
-
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		int pino;
 		int tilepartno=0;
+		/* UniPG>> */
+		int acc_pack_num = 0;
+		/* <<UniPG */
+
 
 		opj_tcp_t *tcp = &cp->tcps[tileno];
 		opj_event_msg(j2k->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
-		
+
 		j2k->curtileno = tileno;
 		j2k->cur_tp_num = 0;
-
+		tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
 		/* initialisation before tile encoding  */
 		if (tileno == 0) {
 			tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
 		} else {
 			tcd_init_encode(tcd, image, cp, j2k->curtileno);
 		}
-		
+
 		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-			image_info->tile[j2k->curtileno].num_tile = j2k->curtileno;
-			image_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
 		}
 		/* << INDEX */
 
 		for(pino = 0; pino <= tcp->numpocs; pino++) {
 			int tot_num_tp;
 			tcd->cur_pino=pino;
-			
+
 			/*Get number of tile parts*/
 			tot_num_tp = j2k_get_num_tp(cp,pino,tileno);
 			tcd->tp_pos = cp->tp_pos;
 
 			for(tilepartno = 0; tilepartno < tot_num_tp ; tilepartno++){
 				j2k->tp_num = tilepartno;
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pos =
+					cio_tell(cio) + j2k->pos_correction;
+				/* << INDEX */
 				j2k_write_sot(j2k);
 
 				if(j2k->cur_tp_num == 0 && cp->cinema == 0){
@@ -2548,83 +2450,86 @@
 					}
 				}
 
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+					cio_tell(cio) + j2k->pos_correction + 1;
+				/* << INDEX */
+
 				j2k_write_sod(j2k, tcd);
-				j2k->cur_tp_num ++;
-			}
-			
+
+				/* INDEX >> */
+				if(cstr_info) {
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_pos =
+						cio_tell(cio) + j2k->pos_correction - 1;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pack =
+						acc_pack_num;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_numpacks =
+						cstr_info->packno - acc_pack_num;
+					acc_pack_num = cstr_info->packno;
+				}
+				/* << INDEX */
+
+				j2k->cur_tp_num++;
+			}			
 		}
-		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-			image_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
 		}
-		/* << INDEX */
-		
-		
+
+
 		/*
 		if (tile->PPT) { // BAD PPT !!! 
-			FILE *PPT_file;
-			int i;
-			PPT_file=fopen("PPT","rb");
-			fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
-			for (i=0;i<tile->len_ppt;i++) {
-				unsigned char elmt;
-				fread(&elmt, 1, 1, PPT_file);
-				fwrite(&elmt,1,1,f);
-			}
-			fclose(PPT_file);
-			unlink("PPT");
+		FILE *PPT_file;
+		int i;
+		PPT_file=fopen("PPT","rb");
+		fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
+		for (i=0;i<tile->len_ppt;i++) {
+		unsigned char elmt;
+		fread(&elmt, 1, 1, PPT_file);
+		fwrite(&elmt,1,1,f);
+		}
+		fclose(PPT_file);
+		unlink("PPT");
 		}
 		*/
-		
+
 	}
-	
+
 	/* destroy the tile encoder */
 	tcd_free_encode(tcd);
 	tcd_destroy(tcd);
 
+	opj_free(j2k->cur_totnum_tp);
+
 	j2k_write_eoc(j2k);
-	
-	/* Creation of the index file */
-	if(image_info && image_info->index_on) {
-		if(!j2k_create_index(j2k, cio, image_info, index)) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to create index file %s\n", index);
-			return false;
-		}
-	}
 
+	if(cstr_info) {
+		cstr_info->codestream_size = cio_tell(cio) + j2k->pos_correction;
+		/* UniPG>> */
+		/* The following adjustment is done to adjust the codestream size */
+		/* if SOD is not at 0 in the buffer. Useful in case of JP2, where */
+		/* the first bunch of bytes is not in the codestream              */
+		cstr_info->codestream_size -= cstr_info->main_head_start;
+		/* <<UniPG */
+	}
 
 #ifdef USE_JPWL
 	/*
-	preparation of JPWL marker segments: can be finalized only when the whole
-	codestream is known
+	preparation of JPWL marker segments
 	*/
-	if(image_info && image_info->index_on && cp->epc_on) {
-
-		/* let's begin creating a marker list, according to user wishes */
-		jpwl_prepare_marks(j2k, cio, image);
+	if(cp->epc_on) {
 
-		/* now we dump the JPWL markers on the codestream */
-		jpwl_dump_marks(j2k, cio, image);
-
-		/* do not know exactly what is this for,
-		but it gets called during index creation */
-		j2k->pos_correction = 0;
-
-		/* Re-creation of the index file, with updated info */
-		if(image_info && image_info->index_on) {
-			if(!j2k_create_index(j2k, cio, image_info, index)) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to re-create index file %s\n", index);
-				return false;
-			}
-		}
-
-		/* now we finalize the marker contents */
-		/*jpwl_finalize_marks(j2k, cio, image);*/
+		/* encode according to JPWL */
+		jpwl_encode(j2k, cio, image);
 
 	}
 #endif /* USE_JPWL */
 
-	
 	return true;
 }
 
+
+
+
+
diff -urN -xdebian -x.svn ./libopenjpeg/j2k.h /usr/src/openjpeg/trunk/libopenjpeg/j2k.h
--- ./libopenjpeg/j2k.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/j2k.h	2007-11-27 22:39:50.000000000 +0000
@@ -79,13 +79,18 @@
 #define J2K_MS_COM 0xff64	/**< COM marker value */
 /* UniPG>> */
 #ifdef USE_JPWL
-#define J2K_MS_EPC 0xff68	/**< EPC marker value (Part11) */
-#define J2K_MS_EPB 0xff66	/**< EPB marker value (Part11) */ 
-#define J2K_MS_ESD 0xff67	/**< ESD marker value (Part11) */ 
-#define J2K_MS_RED 0xff69	/**< RED marker value (Part11) */
+#define J2K_MS_EPC 0xff68	/**< EPC marker value (Part 11: JPEG 2000 for Wireless) */
+#define J2K_MS_EPB 0xff66	/**< EPB marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_ESD 0xff67	/**< ESD marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_RED 0xff69	/**< RED marker value (Part 11: JPEG 2000 for Wireless) */
 #endif /* USE_JPWL */
+#ifdef USE_JPSEC
+#define J2K_MS_SEC 0xff65    /**< SEC marker value (Part 8: Secure JPEG 2000) */
+#define J2K_MS_INSEC 0xff94  /**< INSEC marker value (Part 8: Secure JPEG 2000) */
+#endif /* USE_JPSEC */
 /* <<UniPG */
 
+
 /* ----------------------------------------------------------------------- */
 
 /**
@@ -99,7 +104,8 @@
 	J2K_STATE_TPHSOT = 0x0008, /**< the decoding process is in a tile part header and expects a SOT marker */
 	J2K_STATE_TPH    = 0x0010, /**< the decoding process is in a tile part header */
 	J2K_STATE_MT     = 0x0020, /**< the EOC marker has just been read */
-	J2K_STATE_NEOC   = 0x0040  /**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J2K_STATE_NEOC   = 0x0040, /**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J2K_STATE_ERR    = 0x0080  /**< the decoding process has encountered an error */
 } J2K_STATUS;
 
 /* ----------------------------------------------------------------------- */
@@ -222,8 +228,6 @@
 	int layer;
 	/** if == NO_LIMITATION, decode entire codestream; if == LIMIT_TO_MAIN_HEADER then only decode the main header */
 	OPJ_LIMIT_DECODING limit_decoding;
-	/** 0 = no index || 1 = index */
-	int index_on;
 	/** XTOsiz */
 	int tx0;
 	/** YTOsiz */
@@ -305,92 +309,6 @@
 } opj_cp_t;
 
 /**
-Information concerning a packet inside tile
-*/
-typedef struct opj_packet_info {
-	/** start position */
-	int start_pos;
-	/** end position */
-	int end_pos;
-	/** ADD for Marcela */
-	double disto;
-} opj_packet_info_t;
-
-/**
-Index structure : information regarding tiles inside image
-*/
-typedef struct opj_tile_info {
-	/** value of thresh for each layer by tile cfr. Marcela   */
-	double *thresh;
-	/** number of tile */
-	int num_tile;
-	/** start position */
-	int start_pos;
-	/** end position of the header */
-	int end_header;
-	/** end position */
-	int end_pos;
-	/** precinct number for each resolution level (width) */
-	int pw[33];
-	/** precinct number for each resolution level (height) */
-	int ph[33];
-	/** precinct size (in power of 2), in X for each resolution level */
-	int pdx[33];
-	/** precinct size (in power of 2), in Y for each resolution level */
-	int pdy[33];
-	/** information concerning packets inside tile */
-	opj_packet_info_t *packet;
-	/** add fixed_quality */
-	int nbpix;
-	/** add fixed_quality */
-	double distotile;
-} opj_tile_info_t;
-
-/**
-Index structure
-*/
-typedef struct opj_image_info {
-	/** 0 = no index || 1 = index */
-	int index_on;
-	/** maximum distortion reduction on the whole image (add for Marcela) */
-	double D_max;
-	/** packet number */
-	int num;
-	/** writing the packet in the index with t2_encode_packets */
-	int index_write;
-	/** image width */
-	int image_w;
-	/** image height */
-	int image_h;
-	/** progression order */
-	OPJ_PROG_ORDER prog;
-	/** tile size in x */
-	int tile_x;
-	/** tile size in y */
-	int tile_y;
-	/** */
-	int tile_Ox;
-	/** */
-	int tile_Oy;
-	/** number of tiles in X */
-	int tw;
-	/** number of tiles in Y */
-	int th;
-	/** component numbers */
-	int comp;
-	/** number of layer */
-	int layer;
-	/** number of decomposition */
-	int decomposition;
-	/** main header position */
-	int main_head_end;
-	/** codestream's size */
-	int codestream_size;
-	/** information regarding tiles inside image */
-	opj_tile_info_t *tile;
-} opj_image_info_t;
-
-/**
 JPEG-2000 codestream reader/writer
 */
 typedef struct opj_j2k {
@@ -445,7 +363,7 @@
 	/** pointer to the coding parameters */
 	opj_cp_t *cp;
 	/** helper used to write the index file */
-	opj_image_info_t *image_info;
+	opj_codestream_info_t *cstr_info;
 	/** pointer to the byte i/o stream */
 	opj_cio_t *cio;
 } opj_j2k_t;
@@ -475,16 +393,18 @@
 Decode an image from a JPEG-2000 codestream
 @param j2k J2K decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio);
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Decode an image form a JPT-stream (JPEG 2000, JPIP)
 @param j2k J2K decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio);
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a J2K compression structure
 @param cinfo Codec context info
@@ -513,10 +433,11 @@
 @param j2k J2K compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns true if successful, returns false otherwise
 */
-bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, char *index);
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN -xdebian -x.svn ./libopenjpeg/j2k_lib.c /usr/src/openjpeg/trunk/libopenjpeg/j2k_lib.c
--- ./libopenjpeg/j2k_lib.c	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/j2k_lib.c	2007-11-27 22:39:50.000000000 +0000
@@ -33,7 +33,7 @@
 #endif /* WIN32 */
 #include "opj_includes.h"
 
-double opj_clock() {
+double opj_clock(void) {
 #ifdef WIN32
 	/* WIN32: use QueryPerformance (very accurate) */
     LARGE_INTEGER freq , t ;
@@ -57,20 +57,3 @@
 #endif
 }
 
-void* opj_malloc( size_t size ) {
-	void *memblock = malloc(size);
-	if(memblock) {
-		memset(memblock, 0, size);
-	}
-	return memblock;
-}
-
-void* opj_realloc( void *memblock, size_t size ) {
-	return realloc(memblock, size);
-}
-
-void opj_free( void *memblock ) {
-	free(memblock);
-}
-
-
diff -urN -xdebian -x.svn ./libopenjpeg/j2k_lib.h /usr/src/openjpeg/trunk/libopenjpeg/j2k_lib.h
--- ./libopenjpeg/j2k_lib.h	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/j2k_lib.h	2007-11-27 22:39:50.000000000 +0000
@@ -29,7 +29,7 @@
 @file j2k_lib.h
 @brief Internal functions
 
-The functions in J2K_LIB.C are internal utilities mainly used for memory management.
+The functions in J2K_LIB.C are internal utilities mainly used for timing.
 */
 
 /** @defgroup MISC MISC - Miscellaneous internal functions */
@@ -43,28 +43,7 @@
 Difference in successive opj_clock() calls tells you the elapsed time
 @return Returns time in seconds
 */
-double opj_clock();
-
-/**
-Allocate a memory block with elements initialized to 0
-@param size Bytes to allocate
-@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
-*/
-void* opj_malloc( size_t size );
-
-/**
-Reallocate memory blocks.
-@param memblock Pointer to previously allocated memory block
-@param size New size in bytes
-@return Returns a void pointer to the reallocated (and possibly moved) memory block
-*/
-void* opj_realloc( void *memblock, size_t size );
-
-/**
-Deallocates or frees a memory block.
-@param memblock Previously allocated memory block to be freed
-*/
-void opj_free( void *memblock );
+double opj_clock(void);
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff -urN -xdebian -x.svn ./libopenjpeg/jp2.c /usr/src/openjpeg/trunk/libopenjpeg/jp2.c
--- ./libopenjpeg/jp2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/jp2.c	2007-11-27 22:39:50.000000000 +0000
@@ -71,7 +71,7 @@
 @return Returns true if successful, returns false otherwise
 */
 static bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index);
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
 static bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset);
 static void jp2_write_jp(opj_cio_t *cio);
 /**
@@ -404,7 +404,7 @@
 	return true;
 }
 
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index) {
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	unsigned int j2k_codestream_offset, j2k_codestream_length;
 	opj_jp2_box_t box;
 
@@ -416,7 +416,7 @@
 
 	/* J2K encoding */
 	j2k_codestream_offset = cio_tell(cio);
-	if(!j2k_encode(j2k, cio, image, index)) {
+	if(!j2k_encode(j2k, cio, image, cstr_info)) {
 		opj_event_msg(j2k->cinfo, EVT_ERROR, "Failed to encode image\n");
 		return 0;
 	}
@@ -507,7 +507,7 @@
 /* ----------------------------------------------------------------------- */
 
 opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo) {
-	opj_jp2_t *jp2 = (opj_jp2_t*)opj_malloc(sizeof(opj_jp2_t));
+	opj_jp2_t *jp2 = (opj_jp2_t*) opj_calloc(1, sizeof(opj_jp2_t));
 	if(jp2) {
 		jp2->cinfo = cinfo;
 		/* create the J2K codec */
@@ -541,7 +541,7 @@
 	/* further JP2 initializations go here */
 }
 
-opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio) {
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	opj_common_ptr cinfo;
 	opj_image_t *image = NULL;
 
@@ -558,11 +558,21 @@
 	}
 
 	/* J2K decoding */
-	image = j2k_decode(jp2->j2k, cio);
+	image = j2k_decode(jp2->j2k, cio, cstr_info);
 	if(!image) {
 		opj_event_msg(cinfo, EVT_ERROR, "Failed to decode J2K image\n");
 	}
 
+	/* Set Image Color Space */
+	if (jp2->enumcs == 16)
+		image->color_space = CLRSPC_SRGB;
+	else if (jp2->enumcs == 17)
+		image->color_space = CLRSPC_GRAY;
+	else if (jp2->enumcs == 18)
+		image->color_space = CLRSPC_SYCC;
+	else
+		image->color_space = CLRSPC_UNKNOWN;
+
 	return image;
 }
 
@@ -676,7 +686,7 @@
 
 }
 
-bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index) {
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 
 	/* JP2 encoding */
 
@@ -689,7 +699,7 @@
 
 	/* J2K encoding */
 
-	if(!jp2_write_jp2c(jp2, cio, image, index)) {
+	if(!jp2_write_jp2c(jp2, cio, image, cstr_info)) {
 		opj_event_msg(jp2->cinfo, EVT_ERROR, "Failed to encode image\n");
 		return false;
 	}
diff -urN -xdebian -x.svn ./libopenjpeg/jp2.h /usr/src/openjpeg/trunk/libopenjpeg/jp2.h
--- ./libopenjpeg/jp2.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/jp2.h	2007-09-28 11:33:44.000000000 +0100
@@ -136,9 +136,10 @@
 Decode an image from a JPEG-2000 file stream
 @param jp2 JP2 decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio);
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a JP2 compression structure
 @param cinfo Codec context info
@@ -163,10 +164,10 @@
 @param jp2 JP2 compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns true if successful, returns false otherwise
 */
-bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index);
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN -xdebian -x.svn ./libopenjpeg/mct.c /usr/src/openjpeg/trunk/libopenjpeg/mct.c
--- ./libopenjpeg/mct.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/mct.c	2007-11-27 22:39:50.000000000 +0000
@@ -44,16 +44,20 @@
 /* <summary> */
 /* Foward reversible MCT. */
 /* </summary> */
-void mct_encode(int *c0, int *c1, int *c2, int n) {
+void mct_encode(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int r, g, b, y, u, v;
-		r = c0[i];
-		g = c1[i];
-		b = c2[i];
-		y = (r + (g << 1) + b) >> 2;
-		u = b - g;
-		v = r - g;
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y = (r + (g * 2) + b) >> 2;
+		int u = b - g;
+		int v = r - g;
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -63,16 +67,20 @@
 /* <summary> */
 /* Inverse reversible MCT. */
 /* </summary> */
-void mct_decode(int *c0, int *c1, int *c2, int n) {
+void mct_decode(
+		int* restrict c0,
+		int* restrict c1, 
+		int* restrict c2, 
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int y, u, v, r, g, b;
-		y = c0[i];
-		u = c1[i];
-		v = c2[i];
-		g = y - ((u + v) >> 2);
-		r = v + g;
-		b = u + g;
+	for (i = 0; i < n; ++i) {
+		int y = c0[i];
+		int u = c1[i];
+		int v = c2[i];
+		int g = y - ((u + v) >> 2);
+		int r = v + g;
+		int b = u + g;
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
@@ -89,16 +97,20 @@
 /* <summary> */
 /* Foward irreversible MCT. */
 /* </summary> */
-void mct_encode_real(int *c0, int *c1, int *c2, int n) {
+void mct_encode_real(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int r, g, b, y, u, v;
-		r = c0[i];
-		g = c1[i];
-		b = c2[i];
-		y = fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
-		u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
-		v = fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y =  fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
+		int u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
+		int v =  fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -108,16 +120,20 @@
 /* <summary> */
 /* Inverse irreversible MCT. */
 /* </summary> */
-void mct_decode_real(int *c0, int *c1, int *c2, int n) {
+void mct_decode_real(
+		float* restrict c0,
+		float* restrict c1,
+		float* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int y, u, v, r, g, b;
-		y = c0[i];
-		u = c1[i];
-		v = c2[i];
-		r = y + fix_mul(v, 11485);
-		g = y - fix_mul(u, 2819) - fix_mul(v, 5850);
-		b = y + fix_mul(u, 14516);
+	for(i = 0; i < n; ++i) {
+		float y = c0[i];
+		float u = c1[i];
+		float v = c2[i];
+		float r = y + (v * 1.402f);
+		float g = y - (u * 0.34413f) - (v * (0.71414f));
+		float b = y + (u * 1.772f);
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
diff -urN -xdebian -x.svn ./libopenjpeg/mct.h /usr/src/openjpeg/trunk/libopenjpeg/mct.h
--- ./libopenjpeg/mct.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/mct.h	2007-11-27 22:39:50.000000000 +0000
@@ -83,7 +83,7 @@
 @param c2 Samples for blue chrominance component
 @param n Number of samples for each component
 */
-void mct_decode_real(int *c0, int *c1, int *c2, int n);
+void mct_decode_real(float* c0, float* c1, float* c2, int n);
 /**
 Get norm of the basis function used for the irreversible multi-component transform
 @param compno Number of the component (0->Y, 1->U, 2->V)
diff -urN -xdebian -x.svn ./libopenjpeg/mqc.c /usr/src/openjpeg/trunk/libopenjpeg/mqc.c
--- ./libopenjpeg/mqc.c	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/mqc.c	2007-09-28 11:33:44.000000000 +0100
@@ -344,7 +344,7 @@
 ==========================================================
 */
 
-opj_mqc_t* mqc_create() {
+opj_mqc_t* mqc_create(void) {
 	opj_mqc_t *mqc = (opj_mqc_t*)opj_malloc(sizeof(opj_mqc_t));
 	return mqc;
 }
@@ -371,10 +371,6 @@
 	mqc->start = bp;
 }
 
-void mqc_setcurctx(opj_mqc_t *mqc, int ctxno) {
-	mqc->curctx = &mqc->ctxs[ctxno];
-}
-
 void mqc_encode(opj_mqc_t *mqc, int d) {
 	if ((*mqc->curctx)->mps == d) {
 		mqc_codemps(mqc);
diff -urN -xdebian -x.svn ./libopenjpeg/mqc.h /usr/src/openjpeg/trunk/libopenjpeg/mqc.h
--- ./libopenjpeg/mqc.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/mqc.h	2007-09-28 11:33:44.000000000 +0100
@@ -79,7 +79,7 @@
 Create a new MQC handle 
 @return Returns a new MQC handle if successful, returns NULL otherwise
 */
-opj_mqc_t* mqc_create();
+opj_mqc_t* mqc_create(void);
 /**
 Destroy a previously created MQC handle
 @param mqc MQC handle to destroy
@@ -116,7 +116,7 @@
 @param mqc MQC handle
 @param ctxno Number that identifies the context
 */
-void mqc_setcurctx(opj_mqc_t *mqc, int ctxno);
+#define mqc_setcurctx(mqc, ctxno)	(mqc)->curctx = &(mqc)->ctxs[(int)(ctxno)]
 /**
 Encode a symbol using the MQ-coder
 @param mqc MQC handle
diff -urN -xdebian -x.svn ./libopenjpeg/openjpeg.c /usr/src/openjpeg/trunk/libopenjpeg/openjpeg.c
--- ./libopenjpeg/openjpeg.c	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/openjpeg.c	2007-11-27 22:39:50.000000000 +0000
@@ -53,7 +53,7 @@
 /* ---------------------------------------------------------------------- */
 
 
-const char* OPJ_CALLCONV opj_version() {
+const char* OPJ_CALLCONV opj_version(void) {
     return OPENJPEG_VERSION;
 }
 
@@ -148,20 +148,23 @@
 }
 
 opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio) {
+	return opj_decode_with_info(dinfo, cio, NULL);
+}
+
+opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	if(dinfo && cio) {
 		switch(dinfo->codec_format) {
 			case CODEC_J2K:
-				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio);
+				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
 			case CODEC_JPT:
-				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio);
+				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
 			case CODEC_JP2:
-				return jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio);
+				return jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio, cstr_info);
 			case CODEC_UNKNOWN:
 			default:
 				break;
 		}
 	}
-
 	return NULL;
 }
 
@@ -203,10 +206,10 @@
 		/* destroy the codec */
 		switch(cinfo->codec_format) {
 			case CODEC_J2K:
-				j2k_destroy_decompress((opj_j2k_t*)cinfo->j2k_handle);
+				j2k_destroy_compress((opj_j2k_t*)cinfo->j2k_handle);
 				break;
 			case CODEC_JP2:
-				jp2_destroy_decompress((opj_jp2_t*)cinfo->jp2_handle);
+				jp2_destroy_compress((opj_jp2_t*)cinfo->jp2_handle);
 				break;
 			case CODEC_JPT:
 			case CODEC_UNKNOWN:
@@ -288,20 +291,39 @@
 }
 
 bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index) {
+	if (index != NULL)
+		opj_event_msg((opj_common_ptr)cinfo, EVT_WARNING, "Set index to NULL when calling the opj_encode function.\n"
+		"To extract the index, use the opj_encode_with_info() function.\n"
+		"No index will be generated during this encoding\n");
+	return opj_encode_with_info(cinfo, cio, image, NULL);
+}
+
+bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	if(cinfo && cio && image) {
 		switch(cinfo->codec_format) {
 			case CODEC_J2K:
-				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, index);
+				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, cstr_info);
 			case CODEC_JP2:
-				return jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, index);
+				return jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, cstr_info);
 			case CODEC_JPT:
 			case CODEC_UNKNOWN:
 			default:
 				break;
 		}
 	}
-
 	return false;
 }
 
-
+void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info) {
+	if (cstr_info) {
+		int tileno;
+		for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+			opj_tile_info_t *tile_info = &cstr_info->tile[tileno];
+			opj_free(tile_info->thresh);
+			opj_free(tile_info->packet);
+			opj_free(tile_info->tp);
+		}
+		opj_free(cstr_info->tile);
+		opj_free(cstr_info->marker);
+	}
+}
diff -urN -xdebian -x.svn ./libopenjpeg/openjpeg.h /usr/src/openjpeg/trunk/libopenjpeg/openjpeg.h
--- ./libopenjpeg/openjpeg.h	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/openjpeg.h	2007-11-27 22:39:50.000000000 +0000
@@ -104,6 +104,7 @@
 #define JPWL_EXPECTED_COMPONENTS 3 /**< Expect this number of components, so you'll find better the first EPB */
 #define JPWL_MAXIMUM_TILES 8192 /**< Expect this maximum number of tiles, to avoid some crashes */
 #define JPWL_MAXIMUM_HAMMING 2 /**< Expect this maximum number of bit errors in marker id's */
+#define JPWL_MAXIMUM_EPB_ROOM 65450 /**< Expect this maximum number of bytes for composition of EPBs */
 /* <<UniPG */
 
 /* 
@@ -302,9 +303,9 @@
 	char infile[OPJ_PATH_LEN];
 	/** output file name */
 	char outfile[OPJ_PATH_LEN];
-	/** creation of an index file, default to 0 (false) */
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
 	int index_on;
-	/** index file name */
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
 	char index[OPJ_PATH_LEN];
 	/** subimage encoding: origin image offset in x direction */
 	int image_offset_x0;
@@ -579,6 +580,142 @@
 	int sgnd;
 } opj_image_cmptparm_t;
 
+/* 
+==========================================================
+   Information on the JPEG 2000 codestream
+==========================================================
+*/
+
+/**
+Index structure : Information concerning a packet inside tile
+*/
+typedef struct opj_packet_info {
+	/** packet start position (including SOP marker if it exists) */
+	int start_pos;
+	/** end of packet header position (including EPH marker if it exists)*/
+	int end_ph_pos;
+	/** packet end position */
+	int end_pos;
+	/** packet distorsion */
+	double disto;
+} opj_packet_info_t;
+
+/**
+Index structure : Information concerning tile-parts
+*/
+typedef struct opj_tp_info {
+	/** start position of tile part */
+	int tp_start_pos;
+	/** end position of tile part header */
+	int tp_end_header;
+	/** end position of tile part */
+	int tp_end_pos;
+	/** start packet of tile part */
+	int tp_start_pack;
+	/** number of packets of tile part */
+	int tp_numpacks;
+} opj_tp_info_t;
+
+/**
+Index structure : information regarding tiles 
+*/
+typedef struct opj_tile_info {
+	/** value of thresh for each layer by tile cfr. Marcela   */
+	double *thresh;
+	/** number of tile */
+	int tileno;
+	/** start position */
+	int start_pos;
+	/** end position of the header */
+	int end_header;
+	/** end position */
+	int end_pos;
+	/** precinct number for each resolution level (width) */
+	int pw[33];
+	/** precinct number for each resolution level (height) */
+	int ph[33];
+	/** precinct size (in power of 2), in X for each resolution level */
+	int pdx[33];
+	/** precinct size (in power of 2), in Y for each resolution level */
+	int pdy[33];
+	/** information concerning packets inside tile */
+	opj_packet_info_t *packet;
+	/** add fixed_quality */
+	int numpix;
+	/** add fixed_quality */
+	double distotile;
+	/** number of tile parts */
+	int num_tps;
+	/** information concerning tile parts */
+	opj_tp_info_t *tp;
+} opj_tile_info_t;
+
+/* UniPG>> */
+/**
+Marker structure
+*/
+typedef struct opj_marker_info_t {
+	/** marker type */
+	unsigned short int type;
+	/** position in codestream */
+	int pos;
+	/** length, marker val included */
+	int len;
+} opj_marker_info_t;
+/* <<UniPG */
+
+/**
+Index structure of the codestream
+*/
+typedef struct opj_codestream_info {
+	/** maximum distortion reduction on the whole image (add for Marcela) */
+	double D_max;
+	/** packet number */
+	int packno;
+	/** writing the packet in the index with t2_encode_packets */
+	int index_write;
+	/** image width */
+	int image_w;
+	/** image height */
+	int image_h;
+	/** progression order */
+	OPJ_PROG_ORDER prog;
+	/** tile size in x */
+	int tile_x;
+	/** tile size in y */
+	int tile_y;
+	/** */
+	int tile_Ox;
+	/** */
+	int tile_Oy;
+	/** number of tiles in X */
+	int tw;
+	/** number of tiles in Y */
+	int th;
+	/** component numbers */
+	int numcomps;
+	/** number of layer */
+	int numlayers;
+	/** number of decomposition for each component */
+	int *numdecompos;
+/* UniPG>> */
+	/** number of markers */
+	int marknum;
+	/** list of markers */
+	opj_marker_info_t *marker;
+	/** actual size of markers array */
+	int maxmarknum;
+/* <<UniPG */
+	/** main header position */
+	int main_head_start;
+	/** main header position */
+	int main_head_end;
+	/** codestream's size */
+	int codestream_size;
+	/** information regarding tiles inside image */
+	opj_tile_info_t *tile;
+} opj_codestream_info_t;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -590,7 +727,7 @@
 ==========================================================
 */
 
-OPJ_API const char * OPJ_CALLCONV opj_version();
+OPJ_API const char * OPJ_CALLCONV opj_version(void);
 
 /* 
 ==========================================================
@@ -688,12 +825,21 @@
 */
 OPJ_API void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters);
 /**
-Decode an image from a JPEG-2000 codestream
+Decode an image from a JPEG-2000 codestream 
 @param dinfo decompressor handle
 @param cio Input buffer stream
 @return Returns a decoded image if successful, returns NULL otherwise
 */
 OPJ_API opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio);
+
+/**
+Decode an image from a JPEG-2000 codestream and extract the codestream information
+@param dinfo decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a J2K/JP2 compression structure
 @param format Coder to select
@@ -729,9 +875,9 @@
 OPJ_API void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters);
 /**
 Setup the encoder parameters using the current image and using user parameters. 
-@param cinfo compressor handle
-@param parameters compression parameters
-@param image input filled image
+@param cinfo Compressor handle
+@param parameters Compression parameters
+@param image Input filled image
 */
 OPJ_API void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image);
 /**
@@ -739,10 +885,24 @@
 @param cinfo compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param index Depreacted -> Set to NULL. To extract index, used opj_encode_wci()
 @return Returns true if successful, returns false otherwise
 */
 OPJ_API bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index);
+/**
+Encode an image into a JPEG-2000 codestream and extract the codestream information
+@param cinfo compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+OPJ_API bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+/**
+Destroy Codestream information after compression or decompression
+@param cstr_info Codestream information structure
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info);
 
 #ifdef __cplusplus
 }
diff -urN -xdebian -x.svn ./libopenjpeg/opj_includes.h /usr/src/openjpeg/trunk/libopenjpeg/opj_includes.h
--- ./libopenjpeg/opj_includes.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/opj_includes.h	2007-11-27 22:39:50.000000000 +0000
@@ -54,6 +54,11 @@
  ==========================================================
 */
 
+/* Ignore GCC attributes if this is not GCC */
+#ifndef __GNUC__
+	#define __attribute__(x) /* __attribute__(x) */
+#endif
+
 /*
 The inline keyword is supported by C99 but not by C90. 
 Most compilers implement their own version of this keyword ... 
@@ -71,7 +76,32 @@
 	#endif /* defined(<Compiler>) */
 #endif /* INLINE */
 
+/* Are restricted pointers available? (C99) */
+#if (__STDC_VERSION__ != 199901L)
+	/* Not a C99 compiler */
+	#ifdef __GNUC__
+		#define restrict __restrict__
+	#else
+		#define restrict /* restrict */
+	#endif
+#endif
+
+/* MSVC does not have lrintf */
+#ifdef _MSC_VER
+static INLINE long lrintf(float f){
+	int i;
+
+	_asm{
+		fld f
+		fistp i
+	};
+
+	return i;
+}
+#endif
+
 #include "j2k_lib.h"
+#include "opj_malloc.h"
 #include "event.h"
 #include "cio.h"
 
diff -urN -xdebian -x.svn ./libopenjpeg/pi.c /usr/src/openjpeg/trunk/libopenjpeg/pi.c
--- ./libopenjpeg/pi.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/pi.c	2007-11-27 22:39:50.000000000 +0000
@@ -413,17 +413,15 @@
 	opj_pi_iterator_t *pi = NULL;
 	opj_tcp_t *tcp = NULL;
 	opj_tccp_t *tccp = NULL;
-	size_t array_size;
-	
+
 	tcp = &cp->tcps[tileno];
 
-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
 	if(!pi) {
 		/* TODO: throw an error */
 		return NULL;
 	}
-	
+
 	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
 		int maxres = 0;
 		int maxprec = 0;
@@ -436,14 +434,12 @@
 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
 		pi[pino].numcomps = image->numcomps;
 
-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
 		if(!pi[pino].comps) {
 			/* TODO: throw an error */
 			pi_destroy(pi, cp, tileno);
 			return NULL;
 		}
-		memset(pi[pino].comps, 0, array_size);
 		
 		for (compno = 0; compno < pi->numcomps; compno++) {
 			int tcx0, tcy0, tcx1, tcy1;
@@ -453,8 +449,7 @@
 			comp->dy = image->comps[compno].dy;
 			comp->numresolutions = tccp->numresolutions;
 
-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
+			comp->resolutions = (opj_pi_resolution_t*) opj_calloc(comp->numresolutions, sizeof(opj_pi_resolution_t));
 			if(!comp->resolutions) {
 				/* TODO: throw an error */
 				pi_destroy(pi, cp, tileno);
@@ -507,8 +502,7 @@
 		pi[pino].step_l = maxres * pi[pino].step_r;
 		
 		if (pino == 0) {
-			array_size = image->numcomps * maxres * tcp->numlayers * maxprec * sizeof(short int);
-			pi[pino].include = (short int *) opj_malloc(array_size);
+			pi[pino].include = (short int*) opj_calloc(image->numcomps * maxres * tcp->numlayers * maxprec, sizeof(short int));
 			if(!pi[pino].include) {
 				/* TODO: throw an error */
 				pi_destroy(pi, cp, tileno);
@@ -554,15 +548,13 @@
 	opj_pi_iterator_t *pi = NULL;
 	opj_tcp_t *tcp = NULL;
 	opj_tccp_t *tccp = NULL;
-	size_t array_size;
 	
 	tcp = &cp->tcps[tileno];
 
-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
 	if(!pi) {	return NULL;}
 	pi->tp_on = cp->tp_on;
-	
+
 	for(pino = 0;pino < tcp->numpocs+1 ; pino ++){
 		p = tileno % cp->tw;
 		q = tileno / cp->tw;
@@ -573,13 +565,11 @@
 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
 		pi[pino].numcomps = image->numcomps;
 		
-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
 		if(!pi[pino].comps) {
 			pi_destroy(pi, cp, tileno);
 			return NULL;
 		}
-		memset(pi[pino].comps, 0, array_size);
 		
 		for (compno = 0; compno < pi[pino].numcomps; compno++) {
 			int tcx0, tcy0, tcx1, tcy1;
@@ -589,8 +579,7 @@
 			comp->dy = image->comps[compno].dy;
 			comp->numresolutions = tccp->numresolutions;
 
-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
+			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(comp->numresolutions * sizeof(opj_pi_resolution_t));
 			if(!comp->resolutions) {
 				pi_destroy(pi, cp, tileno);
 				return NULL;
@@ -653,8 +642,7 @@
 		}
 
 		if (pino == 0) {
-			array_size = tcp->numlayers * pi[pino].step_l * sizeof(short int);
-			pi[pino].include = (short int *) opj_malloc(array_size);
+			pi[pino].include = (short int*) opj_calloc(tcp->numlayers * pi[pino].step_l, sizeof(short int));
 			if(!pi[pino].include) {
 				pi_destroy(pi, cp, tileno);
 				return NULL;
@@ -665,7 +653,7 @@
 		}
 		
 		/* Generation of boundaries for each prog flag*/
-			if(tcp->POC & (t2_mode == FINAL_PASS)){
+			if(tcp->POC && ( cp->cinema || ((!cp->cinema) && (t2_mode == FINAL_PASS)))){
 				tcp->pocs[pino].compS= tcp->pocs[pino].compno0;
 				tcp->pocs[pino].compE= tcp->pocs[pino].compno1;
 				tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
@@ -820,7 +808,7 @@
 }
 
 
-void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos){
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode){
 	char *prog;
 	int i,l;
 	int incr_top=1,resetX=0;
@@ -831,7 +819,7 @@
 	pi[pino].first = 1;
 	pi[pino].poc.prg = tcp->prg;	
 	
-	if(!(cp->tp_on)){
+	if(!(cp->tp_on && ((!cp->cinema && (t2_mode == FINAL_PASS)) || cp->cinema))){
 		pi[pino].poc.resno0 = tcp->resS;
 		pi[pino].poc.resno1 = tcp->resE;
 		pi[pino].poc.compno0 = tcp->compS;
@@ -1076,3 +1064,4 @@
 }
 
 
+
diff -urN -xdebian -x.svn ./libopenjpeg/pi.h /usr/src/openjpeg/trunk/libopenjpeg/pi.h
--- ./libopenjpeg/pi.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/pi.h	2007-09-28 11:33:44.000000000 +0100
@@ -118,7 +118,7 @@
 @param tpnum Tile part number of the current tile
 @param tppos The position of the tile part flag in the progression order
 */
-void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos);
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode);
 /**
 Create a packet iterator for Decoder
 @param image Raw image for which the packets will be listed
diff -urN -xdebian -x.svn ./libopenjpeg/raw.c /usr/src/openjpeg/trunk/libopenjpeg/raw.c
--- ./libopenjpeg/raw.c	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/raw.c	2007-09-28 11:33:44.000000000 +0100
@@ -42,7 +42,7 @@
 ==========================================================
 */
 
-opj_raw_t* raw_create() {
+opj_raw_t* raw_create(void) {
 	opj_raw_t *raw = (opj_raw_t*)opj_malloc(sizeof(opj_raw_t));
 	return raw;
 }
diff -urN -xdebian -x.svn ./libopenjpeg/raw.h /usr/src/openjpeg/trunk/libopenjpeg/raw.h
--- ./libopenjpeg/raw.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/raw.h	2007-09-28 11:33:44.000000000 +0100
@@ -67,7 +67,7 @@
 Create a new RAW handle 
 @return Returns a new RAW handle if successful, returns NULL otherwise
 */
-opj_raw_t* raw_create();
+opj_raw_t* raw_create(void);
 /**
 Destroy a previously created RAW handle
 @param raw RAW handle to destroy
diff -urN -xdebian -x.svn ./libopenjpeg/t1.c /usr/src/openjpeg/trunk/libopenjpeg/t1.c
--- ./libopenjpeg/t1.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t1.c	2007-11-27 22:39:50.000000000 +0000
@@ -39,9 +39,9 @@
 /** @name Local static functions */
 /*@{*/
 
-static char t1_getctxno_zc(int f, int orient);
+static INLINE char t1_getctxno_zc(int f, int orient);
 static char t1_getctxno_sc(int f);
-static char t1_getctxno_mag(int f);
+static INLINE int t1_getctxno_mag(int f);
 static char t1_getspb(int f);
 static short t1_getnmsedec_sig(int x, int bitpos);
 static short t1_getnmsedec_ref(int x, int bitpos);
@@ -194,7 +194,7 @@
 */
 static void t1_encode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_enc_t* cblk,
 		int orient,
 		int compno,
 		int level,
@@ -213,7 +213,7 @@
 */
 static void t1_decode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_dec_t* cblk,
 		int orient,
 		int roishift,
 		int cblksty);
@@ -232,8 +232,10 @@
 	return lut_ctxno_sc[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
 }
 
-static char t1_getctxno_mag(int f) {
-	return lut_ctxno_mag[(f & T1_SIG_OTH) | (((f & T1_REFINE) != 0) << 11)];
+static int t1_getctxno_mag(int f) {
+	int tmp1 = (f & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+	int tmp2 = (f & T1_REFINE) ? T1_CTXNO_MAG + 2 : tmp1;
+	return (tmp2);
 }
 
 static char t1_getspb(int f) {
@@ -261,21 +263,22 @@
 	flag_t *sp = flagsp + stride;
 
 	static const flag_t mod[] = {
-		T1_SIG_S,            T1_SIG_N,            T1_SIG_E,            T1_SIG_W,
-		T1_SIG_S | T1_SGN_S, T1_SIG_N | T1_SGN_N, T1_SIG_E | T1_SGN_E, T1_SIG_W | T1_SGN_W
+		T1_SIG_S, T1_SIG_S|T1_SGN_S,
+		T1_SIG_E, T1_SIG_E|T1_SGN_E,
+		T1_SIG_W, T1_SIG_W|T1_SGN_W,
+		T1_SIG_N, T1_SIG_N|T1_SGN_N
 	};
 
-	s <<= 2;
-
 	np[-1] |= T1_SIG_SE;
 	np[0]  |= mod[s];
 	np[1]  |= T1_SIG_SW;
 
 	flagsp[-1] |= mod[s+2];
-	flagsp[1]  |= mod[s+3];
+	flagsp[0]  |= T1_SIG;
+	flagsp[1]  |= mod[s+4];
 
 	sp[-1] |= T1_SIG_NE;
-	sp[0]  |= mod[s+1];
+	sp[0]  |= mod[s+6];
 	sp[1]  |= T1_SIG_NW;
 }
 
@@ -297,25 +300,22 @@
 	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
 	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
 		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
 			mqc_bypass_enc(mqc, v);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
 			mqc_encode(mqc, v);
 		}
 		if (v) {
 			v = *datap < 0 ? 1 : 0;
 			*nmsedec +=	t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
 			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-				mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
 				mqc_bypass_enc(mqc, v);
 			} else {
-				mqc_setcurctx(mqc, t1_getctxno_sc(flag));
 				mqc_encode(mqc, v ^ t1_getspb(flag));
 			}
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 		*flagsp |= T1_VISIT;
 	}
@@ -342,7 +342,6 @@
 				v = raw_decode(raw);	/* ESSAI */
 				*datap = v ? -oneplushalf : oneplushalf;
 				t1_updateflags(flagsp, v, t1->flags_stride);
-				*flagsp |= T1_SIG;
 			}
 		} else {
 			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
@@ -351,7 +350,6 @@
 				v = mqc_decode(mqc) ^ t1_getspb(flag);
 				*datap = v ? -oneplushalf : oneplushalf;
 				t1_updateflags(flagsp, v, t1->flags_stride);
-				*flagsp |= T1_SIG;
 			}
 		}
 		*flagsp |= T1_VISIT;
@@ -434,11 +432,10 @@
 	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
 		*nmsedec += t1_getnmsedec_ref(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
 		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 			mqc_bypass_enc(mqc, v);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));
 			mqc_encode(mqc, v);
 		}
 		*flagsp |= T1_REFINE;
@@ -461,11 +458,10 @@
 	
 	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
 	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 			v = raw_decode(raw);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));
 			v = mqc_decode(mqc);
 		}
 		t = v ? poshalf : neghalf;
@@ -560,7 +556,6 @@
 			v = *datap < 0 ? 1 : 0;
 			mqc_encode(mqc, v ^ t1_getspb(flag));
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 	}
 	*flagsp &= ~T1_VISIT;
@@ -591,7 +586,6 @@
 			v = mqc_decode(mqc) ^ t1_getspb(flag);
 			*datap = v ? -oneplushalf : oneplushalf;
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 	}
 	*flagsp &= ~T1_VISIT;
@@ -758,53 +752,47 @@
 	return wmsedec;
 }
 
-static void allocate_buffers(
+static bool allocate_buffers(
 		opj_t1_t *t1,
 		int w,
 		int h)
 {
-	int datasize;
+	int datasize=w * h;
 	int flagssize;
 
-	datasize=w * h;
-	//fprintf(stderr,"w=%i h=%i datasize=%i flagssize=%i\n",w,h,datasize,flagssize);
-
 	if(datasize > t1->datasize){
-		//fprintf(stderr,"Allocating t1->data: datasize=%i\n",datasize);
-		free(t1->data);
-		t1->data=malloc(datasize * sizeof(int));
+		opj_aligned_free(t1->data);
+		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
 		if(!t1->data){
-			return;
+			return false;
 		}
 		t1->datasize=datasize;
 	}
-	//memset(t1->data,0xff,t1->datasize);
 	memset(t1->data,0,datasize * sizeof(int));
 
 	t1->flags_stride=w+2;
 	flagssize=t1->flags_stride * (h+2);
 
 	if(flagssize > t1->flagssize){
-		//fprintf(stderr,"Allocating t1->flags: flagssize=%i\n",flagssize);
-		free(t1->flags);
-		t1->flags=malloc(flagssize * sizeof(flag_t));
+		opj_aligned_free(t1->flags);
+		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
 		if(!t1->flags){
-			fprintf(stderr,"Allocating t1->flags FAILED!\n");
-			return;
+			return false;
 		}
 		t1->flagssize=flagssize;
 	}
-	//memset(t1->flags,0xff,t1->flagssize);
 	memset(t1->flags,0,flagssize * sizeof(flag_t));
 
 	t1->w=w;
 	t1->h=h;
+
+	return true;
 }
 
 /** mod fixed_quality */
 static void t1_encode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_enc_t* cblk,
 		int orient,
 		int compno,
 		int level,
@@ -814,23 +802,22 @@
 		int numcomps,
 		opj_tcd_tile_t * tile)
 {
-	int i, j;
-	int passno;
-	int bpno, passtype;
-	int max;
-	int nmsedec = 0;
 	double cumwmsedec = 0.0;
-	char type = T1_TYPE_MQ;
-	
+
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
+
+	int passno, bpno, passtype;
+	int nmsedec = 0;
+	int i, max;
+	char type = T1_TYPE_MQ;
+	double tempwmsedec;
+
 	max = 0;
-	for (j = 0; j < t1->h; ++j) {
-		for (i = 0; i < t1->w; ++i) {
-			max = int_max(max, int_abs(t1->data[(j * t1->w) + i]));
-		}
+	for (i = 0; i < t1->w * t1->h; ++i) {
+		int tmp = abs(t1->data[i]);
+		max = int_max(max, tmp);
 	}
-	
+
 	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
 	
 	bpno = cblk->numbps - 1;
@@ -863,8 +850,9 @@
 		}
 		
 		/* fixed_quality */
-		cumwmsedec += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
-		tile->distotile += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+		tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+		cumwmsedec += tempwmsedec;
+		tile->distotile += tempwmsedec;
 		
 		/* Code switch "RESTART" (i.e. TERMALL) */
 		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
@@ -937,23 +925,26 @@
 
 static void t1_decode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_dec_t* cblk,
 		int orient,
 		int roishift,
 		int cblksty)
 {
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+
 	int bpno, passtype;
 	int segno, passno;
 	char type = T1_TYPE_MQ; /* BYPASS mode */
-	
-	opj_raw_t *raw = t1->raw;	/* RAW component */
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	allocate_buffers(
-			t1,
-			cblk->x1 - cblk->x0,
-			cblk->y1 - cblk->y0);
-	
+
+	if(!allocate_buffers(
+				t1,
+				cblk->x1 - cblk->x0,
+				cblk->y1 - cblk->y0))
+	{
+		return;
+	}
+
 	bpno = roishift + cblk->numbps - 1;
 	passtype = 2;
 	
@@ -967,10 +958,14 @@
 		
 		/* BYPASS mode */
 		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		/* FIXME: slviewer gets here with a null pointer. Why? Partially downloaded and/or corrupt textures? */
+		if(seg->data == NULL){
+			continue;
+		}
 		if (type == T1_TYPE_RAW) {
-			raw_init_dec(raw, seg->data, seg->len);
+			raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
 		} else {
-			mqc_init_dec(mqc, seg->data, seg->len);
+			mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len);
 		}
 		
 		for (passno = 0; passno < seg->numpasses; ++passno) {
@@ -1003,19 +998,19 @@
 /* ----------------------------------------------------------------------- */
 
 opj_t1_t* t1_create(opj_common_ptr cinfo) {
-	opj_t1_t *t1 = (opj_t1_t*) malloc(sizeof(opj_t1_t));
+	opj_t1_t *t1 = (opj_t1_t*) opj_malloc(sizeof(opj_t1_t));
 	if(!t1)
 		return NULL;
 
-		t1->cinfo = cinfo;
-		/* create MQC and RAW handles */
-		t1->mqc = mqc_create();
-		t1->raw = raw_create();
+	t1->cinfo = cinfo;
+	/* create MQC and RAW handles */
+	t1->mqc = mqc_create();
+	t1->raw = raw_create();
 
-	t1->datasize=0;
 	t1->data=NULL;
-	t1->flagssize=0;
 	t1->flags=NULL;
+	t1->datasize=0;
+	t1->flagssize=0;
 
 	return t1;
 }
@@ -1025,9 +1020,9 @@
 		/* destroy MQC and RAW handles */
 		mqc_destroy(t1->mqc);
 		raw_destroy(t1->raw);
-		free(t1->data);
-		free(t1->flags);
-		free(t1);
+		opj_aligned_free(t1->data);
+		opj_aligned_free(t1->flags);
+		opj_free(t1);
 	}
 }
 
@@ -1041,23 +1036,29 @@
 	tile->distotile = 0;		/* fixed_quality */
 
 	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_tccp_t* tccp = &tcp->tccps[compno];
+		int tile_w = tilec->x1 - tilec->x0;
 
 		for (resno = 0; resno < tilec->numresolutions; ++resno) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
 
 			for (bandno = 0; bandno < res->numbands; ++bandno) {
-				opj_tcd_band_t *band = &res->bands[bandno];
+				opj_tcd_band_t* restrict band = &res->bands[bandno];
 
 				for (precno = 0; precno < res->pw * res->ph; ++precno) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
-						int x, y, w, i, j, orient;
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+						int* restrict datap;
+						int* restrict tiledp;
+						int cblk_w;
+						int cblk_h;
+						int i, j;
 
-						x = cblk->x0 - band->x0;
-						y = cblk->y0 - band->y0;
+						int x = cblk->x0 - band->x0;
+						int y = cblk->y0 - band->y0;
 						if (band->bandno & 1) {
 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
 							x += pres->x1 - pres->x0;
@@ -1067,45 +1068,47 @@
 							y += pres->y1 - pres->y0;
 						}
 
-						allocate_buffers(
-								t1,
-								cblk->x1 - cblk->x0,
-								cblk->y1 - cblk->y0);
+						if(!allocate_buffers(
+									t1,
+									cblk->x1 - cblk->x0,
+									cblk->y1 - cblk->y0))
+						{
+							return;
+						}
 
-						w = tilec->x1 - tilec->x0;
-						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < t1->h; ++j) {
-								for (i = 0; i < t1->w; ++i) {
-									t1->data[(j * t1->w) + i] =
-										tilec->data[(x + i) + (y + j) * w] << T1_NMSEDEC_FRACBITS;
+						datap=t1->data;
+						cblk_w = t1->w;
+						cblk_h = t1->h;
+
+						tiledp=&tilec->data[(y * tile_w) + x];
+						if (tccp->qmfbid == 1) {
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] = tmp << T1_NMSEDEC_FRACBITS;
 								}
 							}
-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < t1->h; ++j) {
-								for (i = 0; i < t1->w; ++i) {
-									t1->data[(j * t1->w) + i] = 
+						} else {		/* if (tccp->qmfbid == 0) */
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] =
 										fix_mul(
-										tilec->data[x + i + (y + j) * w],
+										tmp,
 										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (11 - T1_NMSEDEC_FRACBITS);
 								}
 							}
 						}
-						orient = band->bandno;	/* FIXME */
-						if (orient == 2) {
-							orient = 1;
-						} else if (orient == 1) {
-							orient = 2;
-						}
 
 						t1_encode_cblk(
 								t1,
 								cblk,
-								orient,
+								band->bandno,
 								compno,
 								tilec->numresolutions - 1 - resno,
-								tcp->tccps[compno].qmfbid,
+								tccp->qmfbid,
 								band->stepsize,
-								tcp->tccps[compno].cblksty,
+								tccp->cblksty,
 								tile->numcomps,
 								tile);
 
@@ -1117,94 +1120,89 @@
 }
 
 void t1_decode_cblks(
-		opj_t1_t *t1,
-		opj_tcd_tile_t *tile,
-		opj_tcp_t *tcp)
+		opj_t1_t* t1,
+		opj_tcd_tilecomp_t* tilec,
+		opj_tccp_t* tccp)
 {
-	int compno, resno, bandno, precno, cblkno;
-
-	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-
-		for (resno = 0; resno < tilec->numresolutions; ++resno) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-
-			for (bandno = 0; bandno < res->numbands; ++bandno) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-
-				for (precno = 0; precno < res->pw * res->ph; ++precno) {
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
-						int x, y, w, i, j, orient, cblk_w, cblk_h;
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-
-						orient = band->bandno;	/* FIXME */
-						if (orient == 2) {
-							orient = 1;
-						} else if (orient == 1) {
-							orient = 2;
-						}
-						
-						t1_decode_cblk(
-								t1,
-								cblk,
-								orient,
-								tcp->tccps[compno].roishift,
-								tcp->tccps[compno].cblksty);
+	int resno, bandno, precno, cblkno;
 
-						x = cblk->x0 - band->x0;
-						y = cblk->y0 - band->y0;
-						if (band->bandno & 1) {
-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
-							x += pres->x1 - pres->x0;
-						}
-						if (band->bandno & 2) {
-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
-							y += pres->y1 - pres->y0;
-						}
+	int tile_w = tilec->x1 - tilec->x0;
 
-						cblk_w = cblk->x1 - cblk->x0;
-						cblk_h = cblk->y1 - cblk->y0;
+	for (resno = 0; resno < tilec->numresolutions; ++resno) {
+		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
 
-						if (tcp->tccps[compno].roishift) {
-							int thresh = 1 << tcp->tccps[compno].roishift;
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									int val = t1->data[(j * t1->w) + i];
-									int mag = int_abs(val);
-									if (mag >= thresh) {
-										mag >>= tcp->tccps[compno].roishift;
-										t1->data[(j * t1->w) + i] = val < 0 ? -mag : mag;
-									}
+		for (bandno = 0; bandno < res->numbands; ++bandno) {
+			opj_tcd_band_t* restrict band = &res->bands[bandno];
+
+			for (precno = 0; precno < res->pw * res->ph; ++precno) {
+				opj_tcd_precinct_t* precinct = &band->precincts[precno];
+
+				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
+					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
+					int* restrict datap;
+					void* restrict tiledp;
+					int cblk_w, cblk_h;
+					int x, y;
+					int i, j;
+
+					t1_decode_cblk(
+							t1,
+							cblk,
+							band->bandno,
+							tccp->roishift,
+							tccp->cblksty);
+
+					x = cblk->x0 - band->x0;
+					y = cblk->y0 - band->y0;
+					if (band->bandno & 1) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						x += pres->x1 - pres->x0;
+					}
+					if (band->bandno & 2) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						y += pres->y1 - pres->y0;
+					}
+
+					datap=t1->data;
+					cblk_w = t1->w;
+					cblk_h = t1->h;
+
+					if (tccp->roishift) {
+						int thresh = 1 << tccp->roishift;
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int val = datap[(j * cblk_w) + i];
+								int mag = abs(val);
+								if (mag >= thresh) {
+									mag >>= tccp->roishift;
+									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
 								}
 							}
 						}
-						
-						w = tilec->x1 - tilec->x0;
-						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									tilec->data[x + i + (y + j) * w] = t1->data[(j * t1->w) + i]/2;
-								}
+					}
+
+					tiledp=(void*)&tilec->data[(y * tile_w) + x];
+					if (tccp->qmfbid == 1) {
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int tmp = datap[(j * cblk_w) + i];
+								((int*)tiledp)[(j * tile_w) + i] = tmp / 2;
 							}
-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									if (t1->data[(j * t1->w) + i] >> 1 == 0) {
-										tilec->data[x + i + (y + j) * w] = 0;
-									} else {
-										double tmp = (double)(t1->data[(j * t1->w) + i] * band->stepsize * 4096.0);
-										int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);									
-										tilec->data[x + i + (y + j) * w] = ((tmp<0)?-tmp2:tmp2);
-									}
-								}
+						}
+					} else {		/* if (tccp->qmfbid == 0) */
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								float tmp = datap[(j * cblk_w) + i] * band->stepsize;
+								((float*)tiledp)[(j * tile_w) + i] = tmp;
 							}
 						}
-					} /* cblkno */
-				} /* precno */
-			} /* bandno */
-		} /* resno */
-	} /* compno */
+					}
+					opj_free(cblk->data);
+					opj_free(cblk->segs);
+				} /* cblkno */
+				opj_free(precinct->cblks.dec);
+			} /* precno */
+		} /* bandno */
+	} /* resno */
 }
 
diff -urN -xdebian -x.svn ./libopenjpeg/t1_generate_luts.c /usr/src/openjpeg/trunk/libopenjpeg/t1_generate_luts.c
--- ./libopenjpeg/t1_generate_luts.c	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t1_generate_luts.c	2007-09-28 11:33:44.000000000 +0100
@@ -146,16 +146,6 @@
 	return (T1_CTXNO_SC + n);
 }
 
-static int t1_init_ctxno_mag(int f) {
-	int n;
-	if (!(f & T1_REFINE))
-		n = (f & (T1_SIG_OTH)) ? 1 : 0;
-	else
-		n = 2;
-
-	return (T1_CTXNO_MAG + n);
-}
-
 static int t1_init_spb(int f) {
 	int hc, vc, n;
 
@@ -197,7 +187,6 @@
 	double u, v, t;
 
 	int lut_ctxno_zc[1024];
-	int lut_ctxno_mag[4096];
 	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
 	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
 	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
@@ -208,11 +197,17 @@
 	// lut_ctxno_zc
 	for (j = 0; j < 4; ++j) {
 		for (i = 0; i < 256; ++i) {
-			lut_ctxno_zc[(j << 8) | i] = t1_init_ctxno_zc(i, j);
+			int orient = j;
+			if (orient == 2) {
+				orient = 1;
+			} else if (orient == 1) {
+				orient = 2;
+			}
+			lut_ctxno_zc[(orient << 8) | i] = t1_init_ctxno_zc(i, j);
 		}
 	}
 
-	printf("static int8_t lut_ctxno_zc[1024] = {\n  ");
+	printf("static char lut_ctxno_zc[1024] = {\n  ");
 	for (i = 0; i < 1023; ++i) {
 		printf("%i, ", lut_ctxno_zc[i]);
 		if(!((i+1)&0x1f))
@@ -221,7 +216,7 @@
 	printf("%i\n};\n\n", lut_ctxno_zc[1023]);
 
 	// lut_ctxno_sc
-	printf("static int8_t lut_ctxno_sc[256] = {\n  ");
+	printf("static char lut_ctxno_sc[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("0x%x, ", t1_init_ctxno_sc(i << 4));
 		if(!((i+1)&0xf))
@@ -229,23 +224,8 @@
 	}
 	printf("0x%x\n};\n\n", t1_init_ctxno_sc(255 << 4));
 
-	// lut_ctxno_mag
-	for (j = 0; j < 2; ++j) {
-		for (i = 0; i < 2048; ++i) {
-			lut_ctxno_mag[(j << 11) + i] = t1_init_ctxno_mag((j ? T1_REFINE : 0) | i);
-		}
-	}
-
-	printf("static int8_t lut_ctxno_mag[4096] = {\n  ");
-	for (i = 0; i < 4095; ++i) {
-		printf("%i, ", lut_ctxno_mag[i]);
-		if(!((i+1)&0xf))
-			printf("\n  ");
-	}
-	printf("%i\n};\n\n", lut_ctxno_mag[4095]);
-
 	// lut_spb
-	printf("static int8_t lut_spb[256] = {\n  ");
+	printf("static char lut_spb[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("%i, ", t1_init_spb(i << 4));
 		if(!((i+1)&0x1f))
@@ -279,16 +259,16 @@
 					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
 	}
 
-	printf("static int16_t lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_sig, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_sig0, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_ref, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_ref0, 1 << T1_NMSEDEC_BITS);
 
 	return 0;
diff -urN -xdebian -x.svn ./libopenjpeg/t1.h /usr/src/openjpeg/trunk/libopenjpeg/t1.h
--- ./libopenjpeg/t1.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t1.h	2007-11-27 22:39:50.000000000 +0000
@@ -138,7 +138,7 @@
 @param tile The tile to decode
 @param tcp Tile coding parameters
 */
-void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+void t1_decode_cblks(opj_t1_t* t1, opj_tcd_tilecomp_t* tilec, opj_tccp_t* tccp);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN -xdebian -x.svn ./libopenjpeg/t1_luts.h /usr/src/openjpeg/trunk/libopenjpeg/t1_luts.h
--- ./libopenjpeg/t1_luts.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t1_luts.h	2007-09-28 11:33:44.000000000 +0100
@@ -9,14 +9,6 @@
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
-  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
-  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
@@ -25,6 +17,14 @@
   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   0, 3, 3, 6, 3, 6, 6, 8, 3, 6, 6, 8, 6, 8, 8, 8, 1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 
   1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
   1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
@@ -54,265 +54,6 @@
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd
 };
 
-static char lut_ctxno_mag[4096] = {
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
-};
-
 static char lut_spb[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
   0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 
diff -urN -xdebian -x.svn ./libopenjpeg/t2.c /usr/src/openjpeg/trunk/libopenjpeg/t2.c
--- ./libopenjpeg/t2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t2.c	2007-11-27 22:39:50.000000000 +0000
@@ -53,17 +53,17 @@
 @param pi Packet identity
 @param dest Destination buffer
 @param len Length of the destination buffer
-@param image_info Structure to create an index file
+@param cstr_info Codestream information structure 
 @param tileno Number of the tile encoded
 @return 
 */
-static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_image_info_t *image_info, int tileno);
+static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_codestream_info_t *cstr_info, int tileno);
 /**
 @param seg
 @param cblksty
 @param first
 */
-static void t2_init_seg(opj_tcd_seg_t *seg, int cblksty, int first);
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first);
 /**
 Decode a packet of a tile from a source buffer
 @param t2 T2 handle
@@ -74,7 +74,8 @@
 @param pi Packet identity
 @return 
 */
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi);
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info);
 
 /*@}*/
 
@@ -126,9 +127,8 @@
 	return (37 + bio_read(bio, 7));
 }
 
-static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_image_info_t * image_info, int tileno) {
+static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_codestream_info_t *cstr_info, int tileno) {
 	int bandno, cblkno;
-	unsigned char *sop = 0, *eph = 0;
 	unsigned char *c = dest;
 
 	int compno = pi->compno;	/* component value */
@@ -143,15 +143,12 @@
 	
 	/* <SOP 0xff91> */
 	if (tcp->csty & J2K_CP_CSTY_SOP) {
-		sop = (unsigned char *) opj_malloc(6 * sizeof(unsigned char));
-		sop[0] = 255;
-		sop[1] = 145;
-		sop[2] = 0;
-		sop[3] = 4;
-		sop[4] = (image_info->num % 65536) / 256;
-		sop[5] = (image_info->num % 65536) % 256;
-		memcpy(c, sop, 6);
-		opj_free(sop);
+		c[0] = 255;
+		c[1] = 145;
+		c[2] = 0;
+		c[3] = 4;
+		c[4] = (tile->packno % 65536) / 256;
+		c[5] = (tile->packno % 65536) % 256;
 		c += 6;
 	}
 	/* </SOP> */
@@ -163,7 +160,7 @@
 			tgt_reset(prc->incltree);
 			tgt_reset(prc->imsbtree);
 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 				cblk->numpasses = 0;
 				tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
 			}
@@ -179,14 +176,14 @@
 		opj_tcd_band_t *band = &res->bands[bandno];
 		opj_tcd_precinct_t *prc = &band->precincts[precno];
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			if (!cblk->numpasses && layer->numpasses) {
 				tgt_setvalue(prc->incltree, cblkno, layno);
 			}
 		}
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			int increment = 0;
 			int nump = 0;
@@ -238,25 +235,31 @@
 			}
 		}
 	}
-	
+
 	if (bio_flush(bio)) {
+		bio_destroy(bio);
 		return -999;		/* modified to eliminate longjmp !! */
 	}
-	
-	c += bio_numbytes(bio);
 
+	c += bio_numbytes(bio);
 	bio_destroy(bio);
 	
 	/* <EPH 0xff92> */
 	if (tcp->csty & J2K_CP_CSTY_EPH) {
-		eph = (unsigned char *) opj_malloc(2 * sizeof(unsigned char));
-		eph[0] = 255;
-		eph[1] = 146;
-		memcpy(c, eph, 2);
-		opj_free(eph);
+		c[0] = 255;
+		c[1] = 146;
 		c += 2;
 	}
 	/* </EPH> */
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(cstr_info && cstr_info->index_write) {
+		opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+		info_PK->end_ph_pos = (int)(c - dest);
+	}
+	/* INDEX >> */
 	
 	/* Writing the packet body */
 	
@@ -264,7 +267,7 @@
 		opj_tcd_band_t *band = &res->bands[bandno];
 		opj_tcd_precinct_t *prc = &band->precincts[precno];
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			if (!layer->numpasses) {
 				continue;
@@ -276,23 +279,27 @@
 			memcpy(c, layer->data, layer->len);
 			cblk->numpasses += layer->numpasses;
 			c += layer->len;
-			/* ADD for index Cfr. Marcela --> delta disto by packet */
-			if(image_info && image_info->index_write && image_info->index_on) {
-				opj_tile_info_t *info_TL = &image_info->tile[tileno];
-				opj_packet_info_t *info_PK = &info_TL->packet[image_info->num];
+			/* << INDEX */ 
+			if(cstr_info && cstr_info->index_write) {
+				opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
 				info_PK->disto += layer->disto;
-				if (image_info->D_max < info_PK->disto) {
-					image_info->D_max = info_PK->disto;
+				if (cstr_info->D_max < info_PK->disto) {
+					cstr_info->D_max = info_PK->disto;
 				}
 			}
-			/* </ADD> */
+			/* INDEX >> */
 		}
 	}
 	
 	return (c - dest);
 }
 
-static void t2_init_seg(opj_tcd_seg_t * seg, int cblksty, int first) {
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first) {
+	opj_tcd_seg_t* seg;
+	cblk->segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, (index + 1) * sizeof(opj_tcd_seg_t));
+	seg = &cblk->segs[index];
+	seg->data = NULL;
+	seg->dataindex = 0;
 	seg->numpasses = 0;
 	seg->len = 0;
 	if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
@@ -309,7 +316,8 @@
 	}
 }
 
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi) {
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info) {
 	int bandno, cblkno;
 	unsigned char *c = src;
 
@@ -320,9 +328,8 @@
 	int precno = pi->precno;	/* precinct value */
 	int layno  = pi->layno;		/* quality layer value */
 
-	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-	
+	opj_tcd_resolution_t* res = &tile->comps[compno].resolutions[resno];
+
 	unsigned char *hd = NULL;
 	int present;
 	
@@ -338,7 +345,7 @@
 			tgt_reset(prc->incltree);
 			tgt_reset(prc->imsbtree);
 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 				cblk->numsegs = 0;
 			}
 		}
@@ -392,6 +399,14 @@
 				hd += 2;
 			}
 		}
+
+		/* << INDEX */
+		// End of packet header position. Currently only represents the distance to start of packet
+		// Will be updated later by incrementing with packet start value
+		if(pack_info) {
+			pack_info->end_ph_pos = (int)(c - src);
+		}
+		/* INDEX >> */
 		
 		if (cp->ppm == 1) {		/* PPM case */
 			cp->ppm_len += cp->ppm_data-hd;
@@ -414,9 +429,8 @@
 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
 		
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			int included, increment, n;
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-			opj_tcd_seg_t *seg = NULL;
+			int included, increment, n, segno;
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 			/* if cblk not yet included before --> inclusion tagtree */
 			if (!cblk->numsegs) {
 				included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
@@ -444,23 +458,25 @@
 			increment = t2_getcommacode(bio);
 			/* length indicator increment */
 			cblk->numlenbits += increment;
+			segno = 0;
 			if (!cblk->numsegs) {
-				seg = &cblk->segs[0];
-				t2_init_seg(seg, tcp->tccps[compno].cblksty, 1);
+				t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 1);
 			} else {
-				seg = &cblk->segs[cblk->numsegs - 1];
-				if (seg->numpasses == seg->maxpasses) {
-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+				segno = cblk->numsegs - 1;
+				if (cblk->segs[segno].numpasses == cblk->segs[segno].maxpasses) {
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
 				}
 			}
 			n = cblk->numnewpasses;
 			
 			do {
-				seg->numnewpasses = int_min(seg->maxpasses - seg->numpasses, n);
-				seg->newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(seg->numnewpasses));
-				n -= seg->numnewpasses;
+				cblk->segs[segno].numnewpasses = int_min(cblk->segs[segno].maxpasses - cblk->segs[segno].numpasses, n);
+				cblk->segs[segno].newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(cblk->segs[segno].numnewpasses));
+				n -= cblk->segs[segno].numnewpasses;
 				if (n > 0) {
-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
 				}
 			} while (n > 0);
 		}
@@ -482,6 +498,14 @@
 			hd += 2;
 		}
 	}
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(pack_info) {
+		pack_info->end_ph_pos = (int)(hd - src);
+	}
+	/* INDEX >> */
 	
 	if (cp->ppm==1) {
 		cp->ppm_len+=cp->ppm_data-hd;
@@ -500,7 +524,7 @@
 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
 		
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 			opj_tcd_seg_t *seg = NULL;
 			if (!cblk->numnewpasses)
 				continue;
@@ -541,9 +565,11 @@
 
 #endif /* USE_JPWL */
 				
+				cblk->data = (unsigned char*) opj_realloc(cblk->data, (cblk->len + seg->newlen) * sizeof(unsigned char*));
 				memcpy(cblk->data + cblk->len, c, seg->newlen);
 				if (seg->numpasses == 0) {
-					seg->data = cblk->data + cblk->len;
+					seg->data = &cblk->data;
+					seg->dataindex = cblk->len;
 				}
 				c += seg->newlen;
 				cblk->len += seg->newlen;
@@ -563,15 +589,15 @@
 
 /* ----------------------------------------------------------------------- */
 
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_image_info_t *image_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode){
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode){
 	unsigned char *c = dest;
 	int e = 0;
 	int compno;
-	int comp_len = 0;
 	opj_pi_iterator_t *pi = NULL;
 	int poc;
 	opj_image_t *image = t2->image;
 	opj_cp_t *cp = t2->cp;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
 	int pocno = cp->cinema == CINEMA4K_24? 2: 1;
 	int maxcomp = cp->max_comp_size > 0 ? image->numcomps : 1;
 	
@@ -581,19 +607,15 @@
 		return -999;
 	}
 	
-	if(image_info) {
-		image_info->num = 0;
-	}
-	
-	if(t2_mode == THRESH_CALC ){
+	if(t2_mode == THRESH_CALC ){ /* Calculating threshold */
 		for(compno = 0; compno < maxcomp; compno++ ){
 			for(poc = 0; poc < pocno ; poc++){
 				int comp_len = 0;
 				int tpnum = compno;
-				pi_create_encode(pi, cp,tileno,poc,tpnum,tppos); 
+				pi_create_encode(pi, cp,tileno,poc,tpnum,tppos,t2_mode); 
 				while (pi_next(&pi[poc])) {
 					if (pi[poc].layno < maxlayers) {
-						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, image_info, tileno);
+						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, cstr_info, tileno);
 						comp_len = comp_len + e;
 						if (e == -999) {
 							break;
@@ -605,57 +627,61 @@
 				if (e == -999) break;
 				if (cp->max_comp_size){
 					if (comp_len > cp->max_comp_size){
-								e = -999;
-								break;
+						e = -999;
+						break;
 					}
 				}
 			}
 			if (e == -999)  break;
 		}
-	}else{
-		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos); 
+	}else{  /* t2_mode == FINAL_PASS  */
+		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos,t2_mode);
 		while (pi_next(&pi[pino])) {
 			if (pi[pino].layno < maxlayers) {
-				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, image_info, tileno);
+				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, cstr_info, tileno);
 				if (e == -999) {
 					break;
 				} else {
 					c += e;
 				}
-			}
-		}
-	}
-
-		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-				if(image_info->index_write) {
-					opj_tile_info_t *info_TL = &image_info->tile[tileno];
-					opj_packet_info_t *info_PK = &info_TL->packet[image_info->num];
-					if (!image_info->num) {
-						info_PK->start_pos = info_TL->end_header + 1;
-					} else {
-						info_PK->start_pos = info_TL->packet[image_info->num - 1].end_pos + 1;
+				/* INDEX >> */
+				if(cstr_info) {
+					if(cstr_info->index_write) {
+						opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+						opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+						if (!cstr_info->packno) {
+							info_PK->start_pos = info_TL->end_header + 1;
+						} else {
+							info_PK->start_pos = ((cp->tp_on | tcp->POC)&& info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+						}
+						info_PK->end_pos = info_PK->start_pos + e - 1;
+						info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																														// to start of packet is incremented by value of start of packet
 					}
-					info_PK->end_pos = info_PK->start_pos + e - 1;
+					
+					cstr_info->packno++;
 				}
-
-				image_info->num++;
+				/* << INDEX */
+				tile->packno++;
 			}
-		/* << INDEX */
-		pi_destroy(pi, cp, tileno);
+		}
+	}
+	
+	pi_destroy(pi, cp, tileno);
 	
 	if (e == -999) {
 		return e;
 	}
-
-    return (c - dest);
+	
+  return (c - dest);
 }
 
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile) {
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info) {
 	unsigned char *c = src;
 	opj_pi_iterator_t *pi;
 	int pino, e = 0;
-	int n = 0;
+	int n = 0, curtp = 0;
+	int tp_start_packno;
 
 	opj_image_t *image = t2->image;
 	opj_cp_t *cp = t2->cp;
@@ -666,11 +692,18 @@
 		/* TODO: throw an error */
 		return -999;
 	}
+
+	tp_start_packno = 0;
 	
 	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
 		while (pi_next(&pi[pino])) {
 			if ((cp->layer==0) || (cp->layer>=((pi[pino].layno)+1))) {
-				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino]);
+				opj_packet_info_t *pack_info;
+				if (cstr_info)
+					pack_info = &cstr_info->tile[tileno].packet[cstr_info->packno];
+				else
+					pack_info = NULL;
+				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino], pack_info);
 			} else {
 				e = 0;
 			}
@@ -681,14 +714,40 @@
 				int_max(pi[pino].resno, image->comps[pi[pino].compno].resno_decoded) 
 				: image->comps[pi[pino].compno].resno_decoded;
 			n++;
+
+			/* INDEX >> */
+			if(cstr_info) {
+				opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+				opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+				if (!cstr_info->packno) {
+					info_PK->start_pos = info_TL->end_header + 1;
+				} else if (info_TL->packet[cstr_info->packno-1].end_pos >= (int)cstr_info->tile[tileno].tp[curtp].tp_end_pos){ // New tile part
+					info_TL->tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in previous tile-part
+					tp_start_packno = cstr_info->packno;
+					curtp++;
+					info_PK->start_pos = cstr_info->tile[tileno].tp[curtp].tp_end_header+1;
+				} else {
+					info_PK->start_pos = (cp->tp_on && info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+				}
+				info_PK->end_pos = info_PK->start_pos + e - 1;
+				info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																												// to start of packet is incremented by value of start of packet
+				cstr_info->packno++;
+			}
+			/* << INDEX */
 			
 			if (e == -999) {		/* ADD */
 				break;
 			} else {
 				c += e;
-			}
+			}			
 		}
 	}
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->tile[tileno].tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in last tile-part
+	}
+	/* << INDEX */
 
 	/* don't forget to release pi */
 	pi_destroy(pi, cp, tileno);
@@ -697,7 +756,7 @@
 		return e;
 	}
 	
-    return (c - src);
+	return (c - src);
 }
 
 /* ----------------------------------------------------------------------- */
@@ -719,3 +778,6 @@
 	}
 }
 
+
+
+
diff -urN -xdebian -x.svn ./libopenjpeg/t2.h /usr/src/openjpeg/trunk/libopenjpeg/t2.h
--- ./libopenjpeg/t2.h	2007-11-29 18:26:58.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/t2.h	2007-09-28 11:33:44.000000000 +0100
@@ -64,12 +64,12 @@
 @param maxlayers maximum number of layers
 @param dest the destination buffer
 @param len the length of the destination buffer
-@param image_info structure to create an index file
+@param cstr_info Codestream information structure 
 @param tpnum Tile part number of the current tile
 @param tppos The position of the tile part flag in the progression order
 @param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
 */
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_image_info_t *image_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode);
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode);
 /**
 Decode the packets of a tile from a source buffer
 @param t2 T2 handle
@@ -78,7 +78,7 @@
 @param tileno number that identifies the tile for which to decode the packets
 @param tile tile for which to decode the packets
  */
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile);
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info);
 
 /**
 Create a T2 handle
diff -urN -xdebian -x.svn ./libopenjpeg/tcd.c /usr/src/openjpeg/trunk/libopenjpeg/tcd.c
--- ./libopenjpeg/tcd.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/tcd.c	2007-11-27 22:39:50.000000000 +0000
@@ -33,7 +33,7 @@
 #include "opj_includes.h"
 
 void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {
-	int tileno, compno, resno, bandno, precno, cblkno;
+	int tileno, compno, resno, bandno, precno;//, cblkno;
 
 	fprintf(fd, "image {\n");
 	fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
@@ -68,6 +68,7 @@
 						fprintf(fd,
 							"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
 							prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
+						/*
 						for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
 							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
 							fprintf(fd, "            cblk {\n");
@@ -76,6 +77,7 @@
 								cblk->x0, cblk->y0, cblk->x1, cblk->y1);
 							fprintf(fd, "            }\n");
 						}
+						*/
 						fprintf(fd, "          }\n");
 					}
 					fprintf(fd, "        }\n");
@@ -151,6 +153,13 @@
 		/* Modification of the RATE >> */
 		for (j = 0; j < tcp->numlayers; j++) {
 			tcp->rates[j] = tcp->rates[j] ? 
+				cp->tp_on ? 
+					(((float) (tile->numcomps 
+					* (tile->x1 - tile->x0) 
+					* (tile->y1 - tile->y0)
+					* image->comps[0].prec))
+					/(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)) - (((tcd->cur_totnum_tp - 1) * 14 )/ tcp->numlayers)
+					:
 				((float) (tile->numcomps 
 					* (tile->x1 - tile->x0) 
 					* (tile->y1 - tile->y0) 
@@ -165,6 +174,10 @@
 					if (!j && tcp->rates[j] < 30)
 						tcp->rates[j] = 30;
 				}
+				
+				if(j == (tcp->numlayers-1)){
+					tcp->rates[j] = tcp->rates[j]- 2;
+				}
 			}
 		}
 		/* << Modification of the RATE */
@@ -181,7 +194,7 @@
 			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
 			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
 			tilec->numresolutions = tccp->numresolutions;
 
 			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
@@ -302,7 +315,7 @@
 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cw * prc->ch) * sizeof(opj_tcd_cblk_t));
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc((prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t));
 						prc->incltree = tgt_create(prc->cw, prc->ch);
 						prc->imsbtree = tgt_create(prc->cw, prc->ch);
 						
@@ -312,13 +325,18 @@
 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
 							int cblkyend = cblkystart + (1 << cblkheightexpn);
 							
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 
 							/* code-block size (global) */
 							cblk->x0 = int_max(cblkxstart, prc->x0);
 							cblk->y0 = int_max(cblkystart, prc->y0);
 							cblk->x1 = int_min(cblkxend, prc->x1);
 							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192+2, sizeof(unsigned char));
+							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
+							cblk->data += 2;
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
 						}
 					}
 				}
@@ -330,7 +348,7 @@
 }
 
 void tcd_free_encode(opj_tcd_t *tcd) {
-	int tileno, compno, resno, bandno, precno;
+	int tileno, compno, resno, bandno, precno, cblkno;
 
 	for (tileno = 0; tileno < 1; tileno++) {
 		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
@@ -355,8 +373,12 @@
 							tgt_destroy(prc->imsbtree);	
 							prc->imsbtree = NULL;
 						}
-						opj_free(prc->cblks);
-						prc->cblks = NULL;
+						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+							opj_free(prc->cblks.enc[cblkno].data - 2);
+							opj_free(prc->cblks.enc[cblkno].layers);
+							opj_free(prc->cblks.enc[cblkno].passes);
+						}
+						opj_free(prc->cblks.enc);
 					} /* for (precno */
 					opj_free(band->precincts);
 					band->precincts = NULL;
@@ -426,7 +448,7 @@
 			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
 			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
 			tilec->numresolutions = tccp->numresolutions;
 			/* tilec->resolutions=(opj_tcd_resolution_t*)opj_realloc(tilec->resolutions,tilec->numresolutions*sizeof(opj_tcd_resolution_t)); */
 			for (resno = 0; resno < tilec->numresolutions; resno++) {
@@ -536,8 +558,8 @@
 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						opj_free(prc->cblks);
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
+						opj_free(prc->cblks.enc);
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc(prc->cw * prc->ch, sizeof(opj_tcd_cblk_enc_t));
 
 						if (prc->incltree != NULL) {
 							tgt_destroy(prc->incltree);
@@ -555,13 +577,16 @@
 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
 							int cblkyend = cblkystart + (1 << cblkheightexpn);
 
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-							
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+
 							/* code-block size (global) */
 							cblk->x0 = int_max(cblkxstart, prc->x0);
 							cblk->y0 = int_max(cblkystart, prc->y0);
 							cblk->x1 = int_min(cblkxend, prc->x1);
 							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192, sizeof(unsigned char));
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
 						}
 					} /* precno */
 				} /* bandno */
@@ -573,206 +598,228 @@
 }
 
 void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp) {
-	int tileno, compno, resno, bandno, precno, cblkno, i, j, p, q;
+	int i, j, tileno, p, q;
 	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0, w, h;
 
 	tcd->image = image;
-	tcd->cp = cp;
 	tcd->tcd_image->tw = cp->tw;
 	tcd->tcd_image->th = cp->th;
 	tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcd_tile_t));
-	
-	for (i = 0; i < cp->tileno_size; i++) {
-		opj_tcp_t *tcp = &(cp->tcps[cp->tileno[i]]);
-		opj_tcd_tile_t *tile = &(tcd->tcd_image->tiles[cp->tileno[i]]);
-	
-		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
-		tileno = cp->tileno[i];
-		p = tileno % cp->tw;	/* si numerotation matricielle .. */
-		q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
 
-		/* 4 borders of the tile rescale on the image if necessary */
-		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+	/* 
+	Allocate place to store the decoded data = final image
+	Place limited by the tile really present in the codestream 
+	*/
+
+	for (j = 0; j < cp->tileno_size; j++) {
+		opj_tcd_tile_t *tile;
 		
+		tileno = cp->tileno[j];		
+		tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);		
 		tile->numcomps = image->numcomps;
-		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(image->numcomps * sizeof(opj_tcd_tilecomp_t));
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tccp_t *tccp = &tcp->tccps[compno];
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		tile->comps = (opj_tcd_tilecomp_t*) opj_calloc(image->numcomps, sizeof(opj_tcd_tilecomp_t));
+	}
 
-			/* border of each tile component (global) */
-			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
-			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
-			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
-			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+	for (i = 0; i < image->numcomps; i++) {
+		for (j = 0; j < cp->tileno_size; j++) {
+			opj_tcd_tile_t *tile;
+			opj_tcd_tilecomp_t *tilec;
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
-			tilec->numresolutions = tccp->numresolutions;
-			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+			/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
+			
+			tileno = cp->tileno[j];
+			
+			tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+			tilec = &tile->comps[i];
+			
+			p = tileno % cp->tw;	/* si numerotation matricielle .. */
+			q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
+			
+			/* 4 borders of the tile rescale on the image if necessary */
+			tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+			tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+			tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+			tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+
+			tilec->x0 = int_ceildiv(tile->x0, image->comps[i].dx);
+			tilec->y0 = int_ceildiv(tile->y0, image->comps[i].dy);
+			tilec->x1 = int_ceildiv(tile->x1, image->comps[i].dx);
+			tilec->y1 = int_ceildiv(tile->y1, image->comps[i].dy);
+
+			x0 = j == 0 ? tilec->x0 : int_min(x0, (unsigned int) tilec->x0);
+			y0 = j == 0 ? tilec->y0 : int_min(y0,	(unsigned int) tilec->x0);
+			x1 = j == 0 ? tilec->x1 : int_max(x1,	(unsigned int) tilec->x1);
+			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
+		}
 
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				int pdx, pdy;
-				int levelno = tilec->numresolutions - 1 - resno;
-				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
-				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
-				int cbgwidthexpn, cbgheightexpn;
-				int cblkwidthexpn, cblkheightexpn;
+		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
+		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
 
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				
-				/* border for each resolution level (global) */
-				res->x0 = int_ceildivpow2(tilec->x0, levelno);
-				res->y0 = int_ceildivpow2(tilec->y0, levelno);
-				res->x1 = int_ceildivpow2(tilec->x1, levelno);
-				res->y1 = int_ceildivpow2(tilec->y1, levelno);
-				res->numbands = resno == 0 ? 1 : 3;
-				
-				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					pdx = tccp->prcw[resno];
-					pdy = tccp->prch[resno];
-				} else {
-					pdx = 15;
-					pdy = 15;
-				}
-				
-				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
-				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
-				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
-				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
-				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+		image->comps[i].w = w;
+		image->comps[i].h = h;
+		image->comps[i].x0 = x0;
+		image->comps[i].y0 = y0;
+	}
+}
+
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info) {
+	int compno, resno, bandno, precno, cblkno;
+	opj_tcp_t *tcp;
+	opj_tcd_tile_t *tile;
+
+	tcd->cp = cp;
+	
+	tcp = &(cp->tcps[cp->tileno[tileno]]);
+	tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+	
+	tileno = cp->tileno[tileno];
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tccp_t *tccp = &tcp->tccps[compno];
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		
+		/* border of each tile component (global) */
+		tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
+		tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+		tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+		tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 
-				res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
-				res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+		tilec->numresolutions = tccp->numresolutions;
+		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+		
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			int pdx, pdy;
+			int levelno = tilec->numresolutions - 1 - resno;
+			int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+			int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+			int cbgwidthexpn, cbgheightexpn;
+			int cblkwidthexpn, cblkheightexpn;
+			
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			
+			/* border for each resolution level (global) */
+			res->x0 = int_ceildivpow2(tilec->x0, levelno);
+			res->y0 = int_ceildivpow2(tilec->y0, levelno);
+			res->x1 = int_ceildivpow2(tilec->x1, levelno);
+			res->y1 = int_ceildivpow2(tilec->y1, levelno);
+			res->numbands = resno == 0 ? 1 : 3;
+			
+			/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
+			if (tccp->csty & J2K_CCP_CSTY_PRT) {
+				pdx = tccp->prcw[resno];
+				pdy = tccp->prch[resno];
+			} else {
+				pdx = 15;
+				pdy = 15;
+			}			
+			
+			/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
+			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+			
+			res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
+			res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+			
+			if (resno == 0) {
+				tlcbgxstart = tlprcxstart;
+				tlcbgystart = tlprcystart;
+				brcbgxend = brprcxend;
+				brcbgyend = brprcyend;
+				cbgwidthexpn = pdx;
+				cbgheightexpn = pdy;
+			} else {
+				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+				brcbgxend = int_ceildivpow2(brprcxend, 1);
+				brcbgyend = int_ceildivpow2(brprcyend, 1);
+				cbgwidthexpn = pdx - 1;
+				cbgheightexpn = pdy - 1;
+			}
+			
+			cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
+			cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+			
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				int x0b, y0b;
+				int gain, numbps;
+				opj_stepsize_t *ss = NULL;
 				
-				if (resno == 0) {
-					tlcbgxstart = tlprcxstart;
-					tlcbgystart = tlprcystart;
-					brcbgxend = brprcxend;
-					brcbgyend = brprcyend;
-					cbgwidthexpn = pdx;
-					cbgheightexpn = pdy;
+				opj_tcd_band_t *band = &res->bands[bandno];
+				band->bandno = resno == 0 ? 0 : bandno + 1;
+				x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
+				y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
+				
+				if (band->bandno == 0) {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0, levelno);
+					band->y0 = int_ceildivpow2(tilec->y0, levelno);
+					band->x1 = int_ceildivpow2(tilec->x1, levelno);
+					band->y1 = int_ceildivpow2(tilec->y1, levelno);
 				} else {
-					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
-					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
-					brcbgxend = int_ceildivpow2(brprcxend, 1);
-					brcbgyend = int_ceildivpow2(brprcyend, 1);
-					cbgwidthexpn = pdx - 1;
-					cbgheightexpn = pdy - 1;
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
+					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
+					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
+					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
 				}
 				
-				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
-				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+				ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+				gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
+				numbps = image->comps[compno].prec + gain;
+				band->stepsize = (float)(((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn)) * 0.5);
+				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
 				
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					int x0b, y0b;
-					int gain, numbps;
-					opj_stepsize_t *ss = NULL;
-
-					opj_tcd_band_t *band = &res->bands[bandno];
-					band->bandno = resno == 0 ? 0 : bandno + 1;
-					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
-					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
-					
-					if (band->bandno == 0) {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0, levelno);
-						band->y0 = int_ceildivpow2(tilec->y0, levelno);
-						band->x1 = int_ceildivpow2(tilec->x1, levelno);
-						band->y1 = int_ceildivpow2(tilec->y1, levelno);
-					} else {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
-						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
-						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
-						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
-					}
-					
-					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
-					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
-					numbps = image->comps[compno].prec + gain;
-					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
-					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+				
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+					int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
+					int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
+					int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+					int cbgyend = cbgystart + (1 << cbgheightexpn);
 					
-					band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					/* precinct size (global) */
+					prc->x0 = int_max(cbgxstart, band->x0);
+					prc->y0 = int_max(cbgystart, band->y0);
+					prc->x1 = int_min(cbgxend, band->x1);
+					prc->y1 = int_min(cbgyend, band->y1);
 					
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
-						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
-						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
-						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
-						int cbgyend = cbgystart + (1 << cbgheightexpn);
+					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+					prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+					prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						opj_tcd_precinct_t *prc = &band->precincts[precno];
-						/* precinct size (global) */
-						prc->x0 = int_max(cbgxstart, band->x0);
-						prc->y0 = int_max(cbgystart, band->y0);
-						prc->x1 = int_min(cbgxend, band->x1);
-						prc->y1 = int_min(cbgyend, band->y1);
-						
-						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
-						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
-						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
-						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
-						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
-						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
-						
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
-						
-						prc->incltree = tgt_create(prc->cw, prc->ch);
-						prc->imsbtree = tgt_create(prc->cw, prc->ch);
-						
-						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
-							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
-							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
-							int cblkyend = cblkystart + (1 << cblkheightexpn);					
-							
-							/* code-block size (global) */
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-							cblk->x0 = int_max(cblkxstart, prc->x0);
-							cblk->y0 = int_max(cblkystart, prc->y0);
-							cblk->x1 = int_min(cblkxend, prc->x1);
-							cblk->y1 = int_min(cblkyend, prc->y1);
-						}
-					} /* precno */
-				} /* bandno */
-			} /* resno */
-		} /* compno */
-	} /* i = 0..cp->tileno_size */
+					prc->cblks.dec = (opj_tcd_cblk_dec_t*) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_dec_t));
 
+					prc->incltree = tgt_create(prc->cw, prc->ch);
+					prc->imsbtree = tgt_create(prc->cw, prc->ch);
+					
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
+						int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+						int cblkyend = cblkystart + (1 << cblkheightexpn);					
+
+						opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+						cblk->data = NULL;
+						cblk->segs = NULL;
+						/* code-block size (global) */
+						cblk->x0 = int_max(cblkxstart, prc->x0);
+						cblk->y0 = int_max(cblkystart, prc->y0);
+						cblk->x1 = int_min(cblkxend, prc->x1);
+						cblk->y1 = int_min(cblkyend, prc->y1);
+						cblk->numsegs = 0;
+					}
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
 	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
-
-	/* 
-	Allocate place to store the decoded data = final image
-	Place limited by the tile really present in the codestream 
-	*/
-	
-	for (i = 0; i < image->numcomps; i++) {
-		for (j = 0; j < cp->tileno_size; j++) {
-			tileno = cp->tileno[j];
-			x0 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].x0 : int_min(x0,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].x0);
-			y0 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].y0 : int_min(y0,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].y0);
-			x1 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].x1 : int_max(x1,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].x1);
-			y1 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].y1 : int_max(y1, 
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].y1);
-		}
-		
-		w = x1 - x0;
-		h = y1 - y0;
-		
-		image->comps[i].data = (int *) opj_malloc(w * h * sizeof(int));
-		image->comps[i].w = w;
-		image->comps[i].h = h;
-		image->comps[i].x0 = x0;
-		image->comps[i].y0 = y0;
-	}
 }
 
 void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final) {
@@ -806,7 +853,7 @@
 				for (precno = 0; precno < res->pw * res->ph; precno++) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 						opj_tcd_layer_t *layer = &cblk->layers[layno];
 						int n;
 						int imsb = tcd->image->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
@@ -887,7 +934,7 @@
 				for (precno = 0; precno < res->pw * res->ph; precno++) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 						opj_tcd_layer_t *layer = &cblk->layers[layno];
 						
 						int n;
@@ -941,7 +988,7 @@
 	}
 }
 
-bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_image_info_t * image_info) {
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
 	int compno, resno, bandno, precno, cblkno, passno, layno;
 	double min, max;
 	double cumdisto[100];	/* fixed_quality */
@@ -955,11 +1002,11 @@
 	min = DBL_MAX;
 	max = 0;
 	
-	tcd_tile->nbpix = 0;		/* fixed_quality */
+	tcd_tile->numpix = 0;		/* fixed_quality */
 	
 	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
 		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
-		tilec->nbpix = 0;
+		tilec->numpix = 0;
 
 		for (resno = 0; resno < tilec->numresolutions; resno++) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
@@ -971,7 +1018,7 @@
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 
 						for (passno = 0; passno < cblk->totalpasses; passno++) {
 							opj_tcd_pass_t *pass = &cblk->passes[passno];
@@ -997,8 +1044,8 @@
 						} /* passno */
 						
 						/* fixed_quality */
-						tcd_tile->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
-						tilec->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+						tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+						tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
 					} /* cbklno */
 				} /* precno */
 			} /* bandno */
@@ -1006,13 +1053,13 @@
 		
 		maxSE += (((double)(1 << tcd->image->comps[compno].prec) - 1.0) 
 			* ((double)(1 << tcd->image->comps[compno].prec) -1.0)) 
-			* ((double)(tilec->nbpix));
+			* ((double)(tilec->numpix));
 	} /* compno */
 	
 	/* index file */
-	if(image_info && image_info->index_on) {
-		opj_tile_info_t *tile_info = &image_info->tile[tcd->tcd_tileno];
-		tile_info->nbpix = tcd_tile->nbpix;
+	if(cstr_info) {
+		opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];
+		tile_info->numpix = tcd_tile->numpix;
 		tile_info->distotile = tcd_tile->distotile;
 		tile_info->thresh = (double *) opj_malloc(tcd_tcp->numlayers * sizeof(double));
 	}
@@ -1021,7 +1068,6 @@
 		double lo = min;
 		double hi = max;
 		int success = 0;
-		/* TODO: remove maxlen */
 		int maxlen = tcd_tcp->rates[layno] ? int_min(((int) ceil(tcd_tcp->rates[layno])), len) : len;
 		double goodthresh = 0;
 		double stable_thresh = 0;
@@ -1031,19 +1077,24 @@
 		/* fixed_quality */
 		distotarget = tcd_tile->distotile - ((K * maxSE) / pow((float)10, tcd_tcp->distoratio[layno] / 10));
         
-		if ((tcd_tcp->rates[layno]) || (cp->disto_alloc == 0)) {
+		/* Don't try to find an optimal threshold but rather take everything not included yet, if
+		  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
+		  -q xx,yy,zz,0	  (fixed_quality == 1 and distoratio == 0)
+		  ==> possible to have some lossy layers and the last layer for sure lossless */
+		if ( ((cp->disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {
 			opj_t2_t *t2 = t2_create(tcd->cinfo, tcd->image, cp);
+			double thresh = 0;
 
 			for (i = 0; i < 32; i++) {
-				double thresh = (lo + hi) / 2;
 				int l = 0;
 				double distoachieved = 0;	/* fixed_quality */
+				thresh = (lo + hi) / 2;
 				
 				tcd_makelayer(tcd, layno, thresh, 0);
 				
 				if (cp->fixed_quality) {	/* fixed_quality */
 					if(cp->cinema){
-						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, image_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
 						if (l == -999) {
 							lo = thresh;
 							continue;
@@ -1069,7 +1120,7 @@
 						lo = thresh;
 					}
 				} else {
-					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, image_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
 					/* TODO: what to do with l ??? seek / tell ??? */
 					/* opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen); */
 					if (l == -999) {
@@ -1081,7 +1132,7 @@
 				}
 			}
 			success = 1;
-			goodthresh = stable_thresh;
+			goodthresh = stable_thresh == 0? thresh : stable_thresh;
 			t2_destroy(t2);
 		} else {
 			success = 1;
@@ -1092,8 +1143,8 @@
 			return false;
 		}
 		
-		if(image_info && image_info->index_on) {	/* Threshold for Marcela Index */
-			image_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
+		if(cstr_info) {	/* Threshold for Marcela Index */
+			cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
 		}
 		tcd_makelayer(tcd, layno, goodthresh, 1);
         
@@ -1104,9 +1155,9 @@
 	return true;
 }
 
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_image_info_t * image_info) {
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
 	int compno;
-	int l, i, npck = 0;
+	int l, i, numpacks = 0;
 	opj_tcd_tile_t *tile = NULL;
 	opj_tcp_t *tcd_tcp = NULL;
 	opj_cp_t *cp = NULL;
@@ -1129,20 +1180,20 @@
 	if(tcd->cur_tp_num == 0){
 		tcd->encoding_time = opj_clock();	/* time needed to encode a tile */
 		/* INDEX >> "Precinct_nb_X et Precinct_nb_Y" */
-		if(image_info && image_info->index_on) {
+		if(cstr_info) {
 			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[0];	/* based on component 0 */
 			for (i = 0; i < tilec_idx->numresolutions; i++) {
 				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[i];
 				
-				image_info->tile[tileno].pw[i] = res_idx->pw;
-				image_info->tile[tileno].ph[i] = res_idx->ph;
+				cstr_info->tile[tileno].pw[i] = res_idx->pw;
+				cstr_info->tile[tileno].ph[i] = res_idx->ph;
 				
-				npck += res_idx->pw * res_idx->ph;
+				numpacks += res_idx->pw * res_idx->ph;
 				
-				image_info->tile[tileno].pdx[i] = tccp->prcw[i];
-				image_info->tile[tileno].pdy[i] = tccp->prch[i];
+				cstr_info->tile[tileno].pdx[i] = tccp->prcw[i];
+				cstr_info->tile[tileno].pdy[i] = tccp->prch[i];
 			}
-			image_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(image_info->comp * image_info->layer * npck * sizeof(opj_packet_info_t));
+			cstr_info->tile[tileno].packet = (opj_packet_info_t*) opj_calloc(cstr_info->numcomps * cstr_info->numlayers * numpacks, sizeof(opj_packet_info_t));
 		}
 		/* << INDEX */
 		
@@ -1214,12 +1265,12 @@
 		/*-----------RATE-ALLOCATE------------------*/
 		
 		/* INDEX */
-		if(image_info) {
-			image_info->index_write = 0;
+		if(cstr_info) {
+			cstr_info->index_write = 0;
 		}
 		if (cp->disto_alloc || cp->fixed_quality) {	/* fixed_quality */
 			/* Normal Rate/distortion allocation */
-			tcd_rateallocate(tcd, dest, len, image_info);
+			tcd_rateallocate(tcd, dest, len, cstr_info);
 		} else {
 			/* Fixed layer allocation */
 			tcd_rateallocate_fixed(tcd);
@@ -1228,12 +1279,12 @@
 	/*--------------TIER2------------------*/
 
 	/* INDEX */
-	if(image_info) {
-		image_info->index_write = 1;
+	if(cstr_info) {
+		cstr_info->index_write = 1;
 	}
 
 	t2 = t2_create(tcd->cinfo, image, cp);
-	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, image_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS);
+	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS);
 	t2_destroy(t2);
 	
 	/*---------------CLEAN-------------------*/
@@ -1242,18 +1293,18 @@
 	if(tcd->cur_tp_num == tcd->cur_totnum_tp - 1){
 		tcd->encoding_time = opj_clock() - tcd->encoding_time;
 		opj_event_msg(tcd->cinfo, EVT_INFO, "- tile encoded in %f s\n", tcd->encoding_time);
-	
+
 		/* cleaning memory */
 		for (compno = 0; compno < tile->numcomps; compno++) {
 			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			opj_free(tilec->data);
+			opj_aligned_free(tilec->data);
 		}
 	}
-	
+
 	return l;
 }
 
-bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno) {
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info) {
 	int l;
 	int compno;
 	int eof = 0;
@@ -1270,11 +1321,38 @@
 	
 	tile_time = opj_clock();	/* time needed to decode a tile */
 	opj_event_msg(tcd->cinfo, EVT_INFO, "tile %d of %d\n", tileno + 1, tcd->cp->tw * tcd->cp->th);
+
+	/* INDEX >>  */
+	if(cstr_info) {
+		int resno, compno, numprec = 0;
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			opj_tcp_t *tcp = &tcd->cp->tcps[0];
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[compno];	
+			for (resno = 0; resno < tilec_idx->numresolutions; resno++) {
+				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];
+				cstr_info->tile[tileno].pw[resno] = res_idx->pw;
+				cstr_info->tile[tileno].ph[resno] = res_idx->ph;
+				numprec += res_idx->pw * res_idx->ph;
+				if (tccp->csty & J2K_CP_CSTY_PRT) {
+					cstr_info->tile[tileno].pdx[resno] = tccp->prcw[resno];
+					cstr_info->tile[tileno].pdy[resno] = tccp->prch[resno];
+				}
+				else {
+					cstr_info->tile[tileno].pdx[resno] = 15;
+					cstr_info->tile[tileno].pdx[resno] = 15;
+				}
+			}
+		}
+		cstr_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));
+		cstr_info->packno = 0;
+	}
+	/* << INDEX */
 	
 	/*--------------TIER2------------------*/
 	
 	t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
-	l = t2_decode_packets(t2, src, len, tileno, tile);
+	l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
 	t2_destroy(t2);
 
 	if (l == -999) {
@@ -1286,7 +1364,12 @@
 	
 	t1_time = opj_clock();	/* time needed to decode a tile */
 	t1 = t1_create(tcd->cinfo);
-	t1_decode_cblks(t1, tile, tcd->tcp);
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		/* The +3 is headroom required by the vectorized DWT */
+		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
+		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
+	}
 	t1_destroy(t1);
 	t1_time = opj_clock() - t1_time;
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tiers-1 took %f s\n", t1_time);
@@ -1296,80 +1379,93 @@
 	dwt_time = opj_clock();	/* time needed to decode a tile */
 	for (compno = 0; compno < tile->numcomps; compno++) {
 		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		int numres2decode;
+
 		if (tcd->cp->reduce != 0) {
 			tcd->image->comps[compno].resno_decoded =
 				tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
-		}
-        
-		if (tcd->tcp->tccps[compno].qmfbid == 1) {
-			dwt_decode(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
-		} else {
-			dwt_decode_real(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
+			if (tcd->image->comps[compno].resno_decoded < 0) {
+				opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. The number of resolutions to remove is higher than the number "
+					"of resolutions in the original codestream\nModify the cp_reduce parameter.\n");
+				return false;
+			}
 		}
 
-		if (tile->comps[compno].numresolutions > 0) {
-			tcd->image->comps[compno].factor = tile->comps[compno].numresolutions - (tcd->image->comps[compno].resno_decoded + 1);
+		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
+		if(numres2decode > 0){
+			if (tcd->tcp->tccps[compno].qmfbid == 1) {
+				dwt_decode(tilec, numres2decode);
+			} else {
+				dwt_decode_real(tilec, numres2decode);
+			}
 		}
 	}
 	dwt_time = opj_clock() - dwt_time;
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
-	
+
 	/*----------------MCT-------------------*/
-	
+
 	if (tcd->tcp->mct) {
+		int n = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
 		if (tcd->tcp->tccps[0].qmfbid == 1) {
-			mct_decode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
+			mct_decode(
+					tile->comps[0].data,
+					tile->comps[1].data,
+					tile->comps[2].data, 
+					n);
 		} else {
-			mct_decode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
+			mct_decode_real(
+					(float*)tile->comps[0].data,
+					(float*)tile->comps[1].data,
+					(float*)tile->comps[2].data, 
+					n);
 		}
 	}
-	
+
 	/*---------------TILE-------------------*/
-	
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-		opj_tcd_resolution_t *res =	&tilec->resolutions[tcd->image->comps[compno].resno_decoded];
-		int adjust = tcd->image->comps[compno].sgnd ? 0 : 1 << (tcd->image->comps[compno].prec - 1);
-		int min = tcd->image->comps[compno].sgnd ? 
-			-(1 << (tcd->image->comps[compno].prec - 1)) : 0;
-		int max = tcd->image->comps[compno].sgnd ? 
-			(1 << (tcd->image->comps[compno].prec - 1)) - 1 : (1 << tcd->image->comps[compno].prec) - 1;
-		
+
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_image_comp_t* imagec = &tcd->image->comps[compno];
+		opj_tcd_resolution_t* res = &tilec->resolutions[imagec->resno_decoded];
+		int adjust = imagec->sgnd ? 0 : 1 << (imagec->prec - 1);
+		int min = imagec->sgnd ? -(1 << (imagec->prec - 1)) : 0;
+		int max = imagec->sgnd ?  (1 << (imagec->prec - 1)) - 1 : (1 << imagec->prec) - 1;
+
 		int tw = tilec->x1 - tilec->x0;
-		int w = tcd->image->comps[compno].w;
-		
-		int i, j;
-		int offset_x = int_ceildivpow2(tcd->image->comps[compno].x0, tcd->image->comps[compno].factor);
-		int offset_y = int_ceildivpow2(tcd->image->comps[compno].y0, tcd->image->comps[compno].factor);
-		
-		for (j = res->y0; j < res->y1; j++) {
-			for (i = res->x0; i < res->x1; i++) {
-				int v;
-				float tmp = (float)((tilec->data[i - res->x0 + (j - res->y0) * tw]) / 8192.0);
+		int w = imagec->w;
 
-				if (tcd->tcp->tccps[compno].qmfbid == 1) {
-					v = tilec->data[i - res->x0 + (j - res->y0) * tw];
-				} else {
-					int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
-					v = ((tmp < 0) ? -tmp2:tmp2);
+		int offset_x = int_ceildivpow2(imagec->x0, imagec->factor);
+		int offset_y = int_ceildivpow2(imagec->y0, imagec->factor);
+
+		int i, j;
+		if(!imagec->data){
+			imagec->data = (int*) opj_malloc(imagec->w * imagec->h * sizeof(int));
+		}
+		if(tcd->tcp->tccps[compno].qmfbid == 1) {
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					int v = tilec->data[i - res->x0 + (j - res->y0) * tw];
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+				}
+			}
+		}else{
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					float tmp = ((float*)tilec->data)[i - res->x0 + (j - res->y0) * tw];
+					int v = lrintf(tmp);
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
 				}
-				v += adjust;
-				
-				tcd->image->comps[compno].data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
 			}
 		}
+		opj_aligned_free(tilec->data);
 	}
-	
+
 	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
-		
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_free(tcd->tcd_image->tiles[tileno].comps[compno].data);
-		tcd->tcd_image->tiles[tileno].comps[compno].data = NULL;
-	}
-	
+
 	if (eof) {
 		return false;
 	}
@@ -1378,32 +1474,32 @@
 }
 
 void tcd_free_decode(opj_tcd_t *tcd) {
-	int tileno,compno,resno,bandno,precno;
+	opj_tcd_image_t *tcd_image = tcd->tcd_image;	
+	opj_free(tcd_image->tiles);
+}
+
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
+	int compno,resno,bandno,precno;
 
 	opj_tcd_image_t *tcd_image = tcd->tcd_image;
-	
-	for (tileno = 0; tileno < tcd_image->tw * tcd_image->th; tileno++) {
-		opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					opj_tcd_band_t *band = &res->bands[bandno];
-					for (precno = 0; precno < res->ph * res->pw; precno++) {
-						opj_tcd_precinct_t *prec = &band->precincts[precno];
-						if (prec->cblks != NULL) opj_free(prec->cblks);
-						if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
-						if (prec->incltree != NULL) tgt_destroy(prec->incltree);
-					}
-					if (band->precincts != NULL) opj_free(band->precincts);
+
+	opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->ph * res->pw; precno++) {
+					opj_tcd_precinct_t *prec = &band->precincts[precno];
+					if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+					if (prec->incltree != NULL) tgt_destroy(prec->incltree);
 				}
+				opj_free(band->precincts);
 			}
-			if (tilec->resolutions != NULL) opj_free(tilec->resolutions);
 		}
-		if (tile->comps != NULL) opj_free(tile->comps);
+		opj_free(tilec->resolutions);
 	}
-
-	if (tcd_image->tiles != NULL) opj_free(tcd_image->tiles);
+	opj_free(tile->comps);
 }
 
diff -urN -xdebian -x.svn ./libopenjpeg/tcd.h /usr/src/openjpeg/trunk/libopenjpeg/tcd.h
--- ./libopenjpeg/tcd.h	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/tcd.h	2007-11-27 22:39:50.000000000 +0000
@@ -45,9 +45,10 @@
 FIXME: documentation
 */
 typedef struct opj_tcd_seg {
+  unsigned char** data;
+  int dataindex;
   int numpasses;
   int len;
-  unsigned char *data;
   int maxpasses;
   int numnewpasses;
   int newlen;
@@ -75,21 +76,28 @@
 /**
 FIXME: documentation
 */
-typedef struct opj_tcd_cblk {
+typedef struct opj_tcd_cblk_enc {
+  unsigned char* data;	/* Data */
+  opj_tcd_layer_t* layers;	/* layer information */
+  opj_tcd_pass_t* passes;	/* information about the passes */
   int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
   int numbps;
   int numlenbits;
-  int len;			/* length */
   int numpasses;		/* number of pass already done for the code-blocks */
-  int numnewpasses;		/* number of pass added to the code-blocks */
-  int numsegs;			/* number of segments */
-  opj_tcd_seg_t segs[100];		/* segments informations */
-  unsigned char data[8192];	/* Data */
   int numpassesinlayers;	/* number of passes in the layer */
-  opj_tcd_layer_t layers[100];	/* layer information */
   int totalpasses;		/* total number of passes */
-  opj_tcd_pass_t passes[100];	/* information about the passes */
-} opj_tcd_cblk_t;
+} opj_tcd_cblk_enc_t;
+
+typedef struct opj_tcd_cblk_dec {
+  unsigned char* data;	/* Data */
+  opj_tcd_seg_t* segs;		/* segments informations */
+	int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numbps;
+  int numlenbits;
+  int len;			/* length */
+  int numnewpasses;		/* number of pass added to the code-blocks */
+  int numsegs;			/* number of segments */
+} opj_tcd_cblk_dec_t;
 
 /**
 FIXME: documentation
@@ -97,7 +105,10 @@
 typedef struct opj_tcd_precinct {
   int x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
   int cw, ch;			/* number of precinct in width and heigth */
-  opj_tcd_cblk_t *cblks;		/* code-blocks informations */
+  union{		/* code-blocks informations */
+	  opj_tcd_cblk_enc_t* enc;
+	  opj_tcd_cblk_dec_t* dec;
+  } cblks;
   opj_tgt_tree_t *incltree;		/* inclusion tree */
   opj_tgt_tree_t *imsbtree;		/* IMSB tree */
 } opj_tcd_precinct_t;
@@ -131,7 +142,7 @@
   int numresolutions;		/* number of resolutions level */
   opj_tcd_resolution_t *resolutions;	/* resolutions information */
   int *data;			/* data of the component */
-  int nbpix;			/* add fixed_quality */
+  int numpix;			/* add fixed_quality */
 } opj_tcd_tilecomp_t;
 
 /**
@@ -141,9 +152,11 @@
   int x0, y0, x1, y1;		/* dimension of the tile : left upper corner (x0, y0) right low corner (x1,y1) */
   int numcomps;			/* number of components in tile */
   opj_tcd_tilecomp_t *comps;	/* Components information */
-  int nbpix;			/* add fixed_quality */
+  int numpix;			/* add fixed_quality */
   double distotile;		/* add fixed_quality */
   double distolayer[100];	/* add fixed_quality */
+  /** packet number */
+  int packno;
 } opj_tcd_tile_t;
 
 /**
@@ -234,20 +247,21 @@
 @param cp Coding parameters
 */
 void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp);
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info);
 void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final);
 void tcd_rateallocate_fixed(opj_tcd_t *tcd);
 void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final);
-bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_image_info_t * image_info);
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
 /**
 Encode a tile from the raw image into a buffer
 @param tcd TCD handle
 @param tileno Number that identifies one of the tiles to be encoded
 @param dest Destination buffer
 @param len Length of destination buffer
-@param image_info Creation of index file
+@param cstr_info Codestream information structure 
 @return 
 */
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_image_info_t * image_info);
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
 /**
 Decode a tile from a buffer into a raw image
 @param tcd TCD handle
@@ -255,12 +269,13 @@
 @param len Length of source buffer
 @param tileno Number that identifies one of the tiles to be decoded
 */
-bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno);
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info);
 /**
 Free the memory allocated for decoding
 @param tcd TCD handle
 */
 void tcd_free_decode(opj_tcd_t *tcd);
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno);
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff -urN -xdebian -x.svn ./libopenjpeg/tgt.c /usr/src/openjpeg/trunk/libopenjpeg/tgt.c
--- ./libopenjpeg/tgt.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libopenjpeg/tgt.c	2007-11-27 22:39:50.000000000 +0000
@@ -71,7 +71,7 @@
 		return NULL;
 	}
 
-	tree->nodes = (opj_tgt_node_t *) opj_malloc(tree->numnodes * sizeof(opj_tgt_node_t));
+	tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
 	if(!tree->nodes) {
 		opj_free(tree);
 		return NULL;
diff -urN -xdebian -x.svn ./LibOpenJPEG.sln /usr/src/openjpeg/trunk/LibOpenJPEG.sln
--- ./LibOpenJPEG.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/LibOpenJPEG.sln	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "LibOpenJPEG.vcproj", "{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.Build.0 = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.ActiveCfg = Release|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./LibOpenJPEG.vcproj /usr/src/openjpeg/trunk/LibOpenJPEG.vcproj
--- ./LibOpenJPEG.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/LibOpenJPEG.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,642 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="LibOpenJPEG"
+	ProjectGUID="{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile=".\Release\LibOpenJPEG.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Release\LibOpenJPEG.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				InlineFunctionExpansion="0"
+				EnableIntrinsicFunctions="false"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\LibOpenJPEGd.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Debug\LibOpenJPEGd.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath=".\libopenjpeg\opj_malloc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1_luts.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
Binary files ./libs/libtiff/libtiff.lib and /usr/src/openjpeg/trunk/libs/libtiff/libtiff.lib differ
diff -urN -xdebian -x.svn ./libs/libtiff/Tiffcomp.h /usr/src/openjpeg/trunk/libs/libtiff/Tiffcomp.h
--- ./libs/libtiff/Tiffcomp.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/Tiffcomp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,214 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffcomp.h,v 1.49 1996/04/29 21:56:21 sam Rel $ */
-
-/*
- * Copyright (c) 1990-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _COMPAT_
-#define	_COMPAT_
-/*
- * This file contains a hodgepodge of definitions and
- * declarations that are needed to provide compatibility
- * between the native system and the base implementation
- * that the library assumes.
- *
- * NB: This file is a mess.
- */
-
-/*
- * Setup basic type definitions and function declaratations.
- */
-
-/*
- * Simplify Acorn RISC OS identifier (to avoid confusion with Acorn RISC iX
- * and with defunct Unix Risc OS)
- * No need to specify __arm - hey, Acorn might port the OS, no problem here!
- */
-#ifdef __acornriscos
-#undef __acornriscos
-#endif
-#if defined(__acorn) && defined(__riscos)
-#define __acornriscos
-#endif
-
-#if defined(__MWERKS__) || defined(THINK_C)
-#include <unix.h>
-#include <math.h>
-#endif
-
-#include <stdio.h>
-
-#if defined(__PPCC__) || defined(__SC__) || defined(__MRC__)
-#include <types.h>
-#elif !defined(__MWERKS__) && !defined(THINK_C) && !defined(__acornriscos) && !defined(applec)
-#include <sys/types.h>
-#endif
-
-#if defined(VMS)
-#include <file.h>
-#include <unixio.h>
-#elif !defined(__acornriscos)
-#include <fcntl.h>
-#endif
-
-/*
- * This maze of checks controls defines or not the
- * target system has BSD-style typdedefs declared in
- * an include file and/or whether or not to include
- * <unistd.h> to get the SEEK_* definitions.  Some
- * additional includes are also done to pull in the
- * appropriate definitions we're looking for.
- */
-#if defined(__MWERKS__) || defined(THINK_C) || defined(__PPCC__) || defined(__SC__) || defined(__MRC__)
-#include <stdlib.h>
-#define	BSDTYPES
-#define	HAVE_UNISTD_H	0
-#elif defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
-#define	BSDTYPES
-#elif defined(OS2_16) || defined(OS2_32)
-#define	BSDTYPES
-#elif defined(__acornriscos)
-#include <stdlib.h>
-#define	BSDTYPES
-#define	HAVE_UNISTD_H	0
-#elif defined(VMS)
-#define	HAVE_UNISTD_H	0
-#else
-#define	HAVE_UNISTD_H	1
-#endif
-
-/*
- * The library uses the ANSI C/POSIX SEEK_*
- * definitions that should be defined in unistd.h
- * (except on system where they are in stdio.h and
- * there is no unistd.h).
- */
-#if !defined(SEEK_SET) && HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-/*
- * The library uses memset, memcpy, and memcmp.
- * ANSI C and System V define these in string.h.
- */
-#include <string.h>
-
-/*
- * The BSD typedefs are used throughout the library.
- * If your system doesn't have them in <sys/types.h>,
- * then define BSDTYPES in your Makefile.
- */
-#if defined(BSDTYPES)
-typedef	unsigned char u_char;
-typedef	unsigned short u_short;
-typedef	unsigned int u_int;
-typedef	unsigned long u_long;
-#endif
-
-/*
- * dblparam_t is the type that a double precision
- * floating point value will have on the parameter
- * stack (when coerced by the compiler).
- */
-/* Note: on MacPowerPC "extended" is undefined. So only use it for 68K-Macs */
-#if defined(__SC__) || defined(THINK_C)
-typedef extended dblparam_t;
-#else
-typedef double dblparam_t;
-#endif
-
-/*
- * If your compiler supports inline functions, then
- * set INLINE appropriately to get the known hotspots
- * in the library expanded inline.
- */
-#if defined(__GNUC__)
-#if defined(__STRICT_ANSI__)
-#define	INLINE	__inline__
-#else
-#define	INLINE	inline
-#endif
-#else /* !__GNUC__ */
-#define	INLINE
-#endif
-
-/*
- * GLOBALDATA is a macro that is used to define global variables
- * private to the library.  We use this indirection to hide
- * brain-damage in VAXC (and GCC) under VAX/VMS.  In these
- * environments the macro places the variable in a non-shareable
- * program section, which ought to be done by default (sigh!)
- *
- * Apparently DEC are aware of the problem as this behaviour is the
- * default under VMS on AXP.
- *
- * The GNU C variant is untested.
- */
-#if defined(VAX) && defined(VMS)
-#if defined(VAXC)
-#define GLOBALDATA(TYPE,NAME)	extern noshare TYPE NAME
-#endif
-#if defined(__GNUC__)
-#define GLOBALDATA(TYPE,NAME)	extern TYPE NAME \
-	asm("_$$PsectAttributes_NOSHR$$" #NAME)
-#endif
-#else	/* !VAX/VMS */
-#define GLOBALDATA(TYPE,NAME)	extern TYPE NAME
-#endif
-
-#if defined(__acornriscos)
-/*
- * osfcn.h is part of C++Lib on Acorn C/C++, and as such can't be used
- * on C alone. For that reason, the relevant functions are
- * implemented in tif_acorn.c, and the elements from the header
- * file are included here.
- */
-#if defined(__cplusplus)
-#include <osfcn.h>
-#else
-#define	O_RDONLY	0
-#define	O_WRONLY	1
-#define	O_RDWR		2
-#define	O_APPEND	8
-#define	O_CREAT		0x200
-#define	O_TRUNC		0x400
-typedef long off_t;
-extern int open(const char *name, int flags, int mode);
-extern int close(int fd);
-extern int write(int fd, const char *buf, int nbytes);
-extern int read(int fd, char *buf, int nbytes);
-extern off_t lseek(int fd, off_t offset, int whence);
-extern int creat(const char *path, int mode);
-#endif /* __cplusplus */
-#endif /* __acornriscos */
-
-/* Bit and byte order, the default is MSB to LSB */
-#ifdef VMS
-#undef HOST_FILLORDER
-#undef HOST_BIGENDIAN
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-#define HOST_BIGENDIAN	0
-#endif
-
-
-#endif /* _COMPAT_ */
diff -urN -xdebian -x.svn ./libs/libtiff/tiffconf.h /usr/src/openjpeg/trunk/libs/libtiff/tiffconf.h
--- ./libs/libtiff/tiffconf.h	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/libs/libtiff/tiffconf.h	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,101 @@
+/* libtiff/tiffconf.h.  Generated by configure.  */
+/*
+  Configuration defines for installed libtiff.
+  This file maintained for backward compatibility. Do not use definitions
+  from this file in your programs.
+*/
+
+#ifndef _TIFFCONF_
+#define _TIFFCONF_
+
+/* Define to 1 if the system has the type `int16'. */
+/* #undef HAVE_INT16 */
+
+/* Define to 1 if the system has the type `int32'. */
+/* #undef HAVE_INT32 */
+
+/* Define to 1 if the system has the type `int8'. */
+/* #undef HAVE_INT8 */
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* Compatibility stuff. */
+
+/* Define as 0 or 1 according to the floating point format suported by the
+   machine */
+#define HAVE_IEEEFP 1
+
+/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
+#define HOST_FILLORDER FILLORDER_LSB2MSB
+
+/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
+   (Intel) */
+#define HOST_BIGENDIAN 0
+
+/* Support CCITT Group 3 & 4 algorithms */
+#define CCITT_SUPPORT 1
+
+/* Support JPEG compression (requires IJG JPEG library) */
+#undef JPEG_SUPPORT 
+
+/* Support LogLuv high dynamic range encoding */
+#define LOGLUV_SUPPORT 1
+
+/* Support LZW algorithm */
+#define LZW_SUPPORT 1
+
+/* Support NeXT 2-bit RLE algorithm */
+#define NEXT_SUPPORT 1
+
+/* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
+   fails with unpatched IJG JPEG library) */
+/* #undef OJPEG_SUPPORT */
+
+/* Support Macintosh PackBits algorithm */
+#define PACKBITS_SUPPORT 1
+
+/* Support Pixar log-format algorithm (requires Zlib) */
+#define PIXARLOG_SUPPORT 1
+
+/* Support ThunderScan 4-bit RLE algorithm */
+#define THUNDER_SUPPORT 1
+
+/* Support Deflate compression */
+#define ZIP_SUPPORT 1
+
+/* Support strip chopping (whether or not to convert single-strip uncompressed
+   images to mutiple strips of ~8Kb to reduce memory usage) */
+#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
+
+/* Enable SubIFD tag (330) support */
+#define SUBIFD_SUPPORT 1
+
+/* Treat extra sample as alpha (default enabled). The RGBA interface will
+   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
+   packages produce RGBA files but don't mark the alpha properly. */
+#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
+
+/* Pick up YCbCr subsampling info from the JPEG data stream to support files
+   lacking the tag (default enabled). */
+#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
+
+/* Support MS MDI magic number files as TIFF */
+#define MDI_SUPPORT 1
+
+/*
+ * Feature support definitions.
+ * XXX: These macros are obsoleted. Don't use them in your apps!
+ * Macros stays here for backward compatibility and should be always defined.
+ */
+#define COLORIMETRY_SUPPORT
+#define YCBCR_SUPPORT
+#define CMYK_SUPPORT
+#define ICC_SUPPORT
+#define PHOTOSHOP_SUPPORT
+#define IPTC_SUPPORT
+
+#endif /* _TIFFCONF_ */
diff -urN -xdebian -x.svn ./libs/libtiff/Tiffconf.h /usr/src/openjpeg/trunk/libs/libtiff/Tiffconf.h
--- ./libs/libtiff/Tiffconf.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/Tiffconf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffconf.h,v 1.13 1996/04/05 17:36:53 sam Rel $ */
-/*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFCONF_
-#define	_TIFFCONF_
-/*
- * Library Configuration Definitions.
- *
- * This file defines the default configuration for the library.
- * If the target system does not have make or a way to specify
- * #defines on the command line, this file can be edited to
- * configure the library.  Otherwise, one can override portability
- * and configuration-related definitions from a Makefile or command
- * line by defining FEATURE_SUPPORT and COMPRESSION_SUPPORT (see below).
- */
-
-/*
- * General portability-related defines:
- *
- * HAVE_IEEEFP		define as 0 or 1 according to the floating point
- *			format suported by the machine
- * BSDTYPES		define this if your system does NOT define the
- *			usual 4BSD typedefs u_int et. al.
- * HAVE_MMAP		enable support for memory mapping read-only files;
- *			this is typically deduced by the configure script
- * HOST_FILLORDER	native cpu bit order: one of FILLORDER_MSB2LSB
- *			or FILLODER_LSB2MSB; this is typically set by the
- *			configure script
- * HOST_BIGENDIAN	native cpu byte order: 1 if big-endian (Motorola)
- *			or 0 if little-endian (Intel); this may be used
- *			in codecs to optimize code
- */
-#ifndef HAVE_IEEEFP
-#define	HAVE_IEEEFP	1
-#endif
-#ifndef HOST_FILLORDER
-#define	HOST_FILLORDER	FILLORDER_MSB2LSB
-#endif
-#ifndef	HOST_BIGENDIAN
-#define	HOST_BIGENDIAN	1
-#endif
-
-#ifndef FEATURE_SUPPORT
-/*
- * Feature support definitions:
- *
- *    COLORIMETRY_SUPPORT enable support for 6.0 colorimetry tags
- *    YCBCR_SUPPORT	enable support for 6.0 YCbCr tags
- *    CMYK_SUPPORT	enable support for 6.0 CMYK tags
- */
-#define	COLORIMETRY_SUPPORT
-#define	YCBCR_SUPPORT
-#define	CMYK_SUPPORT
-#endif /* FEATURE_SUPPORT */
-
-#ifndef COMPRESSION_SUPPORT
-/*
- * Compression support defines:
- *
- *    CCITT_SUPPORT	enable support for CCITT Group 3 & 4 algorithms
- *    PACKBITS_SUPPORT	enable support for Macintosh PackBits algorithm
- *    LZW_SUPPORT	enable support for LZW algorithm
- *    THUNDER_SUPPORT	enable support for ThunderScan 4-bit RLE algorithm
- *    NEXT_SUPPORT	enable support for NeXT 2-bit RLE algorithm
- *    OJPEG_SUPPORT	enable support for 6.0-style JPEG DCT algorithms
- *			(no builtin support, only a codec hook)
- *    JPEG_SUPPORT	enable support for post-6.0-style JPEG DCT algorithms
- *			(requires freely available IJG software, see tif_jpeg.c)
- *    ZIP_SUPPORT	enable support for Deflate algorithm
- *			(requires freely available zlib software, see tif_zip.c)
- *    PIXARLOG_SUPPORT	enable support for Pixar log-format algorithm
- */
-/* doesn't work with Windows makefile??? */
-#if 0
-#define	CCITT_SUPPORT
-#endif
-#define	PACKBITS_SUPPORT
-#define	LZW_SUPPORT
-#define	THUNDER_SUPPORT
-#define	NEXT_SUPPORT
-#endif /* COMPRESSION_SUPPORT */
-
-/*
- * If JPEG compression is enabled then we must also include
- * support for the colorimetry and YCbCr-related tags.
- */
-#ifdef JPEG_SUPPORT
-#ifndef YCBCR_SUPPORT
-#define	YCBCR_SUPPORT
-#endif
-#ifndef COLORIMETRY_SUPPORT
-#define	COLORIMETRY_SUPPORT
-#endif
-#endif /* JPEG_SUPPORT */
-
-/*
- * ``Orthogonal Features''
- *
- * STRIPCHOP_SUPPORT	automatically convert single-strip uncompressed images
- *			to mutiple strips of ~8Kb (for reducing memory use)
- * SUBIFD_SUPPORT	enable support for SubIFD tag (thumbnails and such)
- */
-#ifndef STRIPCHOP_SUPPORT
-#define	STRIPCHOP_SUPPORT	1	/* enable strip chopping */
-#endif
-#ifndef SUBIFD_SUPPORT
-#define	SUBIFD_SUPPORT		1	/* enable SubIFD tag (330) support */
-#endif
-#endif /* _TIFFCONF_ */
diff -urN -xdebian -x.svn ./libs/libtiff/tiff.h /usr/src/openjpeg/trunk/libs/libtiff/tiff.h
--- ./libs/libtiff/tiff.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/tiff.h	2007-09-28 11:33:43.000000000 +0100
@@ -1,8 +1,8 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiff.h,v 1.71 1996/04/29 22:16:05 sam Rel $ */
+/* $Id: tiff.h,v 1.42 2005/12/23 15:10:45 dron Exp $ */
 
 /*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and 
  * its documentation for any purpose is hereby granted without fee, provided
@@ -26,6 +26,9 @@
 
 #ifndef _TIFF_
 #define	_TIFF_
+
+#include "tiffconf.h"
+
 /*
  * Tag Image File Format (TIFF)
  *
@@ -36,14 +39,19 @@
  *    Suite 200
  *    Seattle, WA  98104
  *    206-622-5500
+ *    
+ *    (http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf)
+ *
+ * For Big TIFF design notes see the following link
+ *    http://gdal.maptools.org/twiki/bin/view/libtiff/BigTIFFDesign
  */
-#define	TIFF_VERSION	42
+#define	TIFF_VERSION	        42
+#define TIFF_BIGTIFF_VERSION    43
 
 #define	TIFF_BIGENDIAN		0x4d4d
 #define	TIFF_LITTLEENDIAN	0x4949
-
-#ifndef _TIFF_DATA_TYPEDEFS_
-#define _TIFF_DATA_TYPEDEFS_
+#define	MDI_LITTLEENDIAN        0x5045
+#define	MDI_BIGENDIAN           0x4550
 /*
  * Intrinsic data types required by the file format:
  *
@@ -52,47 +60,64 @@
  * 32-bit quantities	int32/uint32
  * strings		unsigned char*
  */
-#ifdef __STDC__
+
+#ifndef HAVE_INT8
 typedef	signed char int8;	/* NB: non-ANSI compilers may not grok */
-#else
-typedef	char int8;
 #endif
 typedef	unsigned char uint8;
+#ifndef HAVE_INT16
 typedef	short int16;
+#endif
 typedef	unsigned short uint16;	/* sizeof (uint16) must == 2 */
-#if defined(__alpha) || (defined(_MIPS_SZLONG) && _MIPS_SZLONG == 64)
+#if SIZEOF_INT == 4
+#ifndef HAVE_INT32
 typedef	int int32;
+#endif
 typedef	unsigned int uint32;	/* sizeof (uint32) must == 4 */
-#else
+#elif SIZEOF_LONG == 4
+#ifndef HAVE_INT32
 typedef	long int32;
+#endif
 typedef	unsigned long uint32;	/* sizeof (uint32) must == 4 */
 #endif
-#endif /* _TIFF_DATA_TYPEDEFS_ */
 
+/* For TIFFReassignTagToIgnore */
+enum TIFFIgnoreSense /* IGNORE tag table */
+{
+	TIS_STORE,
+	TIS_EXTRACT,
+	TIS_EMPTY
+};
+
+/*
+ * TIFF header.
+ */
 typedef	struct {
 	uint16	tiff_magic;	/* magic number (defines byte order) */
+#define TIFF_MAGIC_SIZE		2
 	uint16	tiff_version;	/* TIFF version number */
+#define TIFF_VERSION_SIZE	2
 	uint32	tiff_diroff;	/* byte offset to first directory */
+#define TIFF_DIROFFSET_SIZE	4
 } TIFFHeader;
 
+
 /*
- * TIFF Image File Directories are comprised of
- * a table of field descriptors of the form shown
- * below.  The table is sorted in ascending order
- * by tag.  The values associated with each entry
- * are disjoint and may appear anywhere in the file
- * (so long as they are placed on a word boundary).
+ * TIFF Image File Directories are comprised of a table of field
+ * descriptors of the form shown below.  The table is sorted in
+ * ascending order by tag.  The values associated with each entry are
+ * disjoint and may appear anywhere in the file (so long as they are
+ * placed on a word boundary).
  *
- * If the value is 4 bytes or less, then it is placed
- * in the offset field to save space.  If the value
- * is less than 4 bytes, it is left-justified in the
- * offset field.
+ * If the value is 4 bytes or less, then it is placed in the offset
+ * field to save space.  If the value is less than 4 bytes, it is
+ * left-justified in the offset field.
  */
 typedef	struct {
-	uint16	tdir_tag;	/* see below */
-	uint16	tdir_type;	/* data type; see below */
-	uint32  tdir_count;	/* number of items; length in spec */
-	uint32  tdir_offset;	/* byte offset to field data */
+	uint16		tdir_tag;	/* see below */
+	uint16		tdir_type;	/* data type; see below */
+	uint32		tdir_count;	/* number of items; length in spec */
+	uint32		tdir_offset;	/* byte offset to field data */
 } TIFFDirEntry;
 
 /*
@@ -101,6 +126,7 @@
  *  - items marked with a ! are introduced in revision 6.0.
  *  - items marked with a % are introduced post revision 6.0.
  *  - items marked with a $ are obsoleted by revision 6.0.
+ *  - items marked with a & are introduced by Adobe DNG specification.
  */
 
 /*
@@ -121,7 +147,8 @@
 	TIFF_SLONG	= 9,	/* !32-bit signed integer */
 	TIFF_SRATIONAL	= 10,	/* !64-bit signed fraction */
 	TIFF_FLOAT	= 11,	/* !32-bit IEEE floating point */
-	TIFF_DOUBLE	= 12	/* !64-bit IEEE floating point */
+	TIFF_DOUBLE	= 12,	/* !64-bit IEEE floating point */
+	TIFF_IFD	= 13	/* %32-bit unsigned integer (offset) */
 } TIFFDataType;
 
 /*
@@ -142,21 +169,33 @@
 #define	    COMPRESSION_NONE		1	/* dump mode */
 #define	    COMPRESSION_CCITTRLE	2	/* CCITT modified Huffman RLE */
 #define	    COMPRESSION_CCITTFAX3	3	/* CCITT Group 3 fax encoding */
+#define     COMPRESSION_CCITT_T4        3       /* CCITT T.4 (TIFF 6 name) */
 #define	    COMPRESSION_CCITTFAX4	4	/* CCITT Group 4 fax encoding */
-#define	    COMPRESSION_LZW		5	/* Lempel-Ziv  & Welch */
+#define     COMPRESSION_CCITT_T6        4       /* CCITT T.6 (TIFF 6 name) */
+#define	    COMPRESSION_LZW		5       /* Lempel-Ziv  & Welch */
 #define	    COMPRESSION_OJPEG		6	/* !6.0 JPEG */
 #define	    COMPRESSION_JPEG		7	/* %JPEG DCT compression */
 #define	    COMPRESSION_NEXT		32766	/* NeXT 2-bit RLE */
 #define	    COMPRESSION_CCITTRLEW	32771	/* #1 w/ word alignment */
 #define	    COMPRESSION_PACKBITS	32773	/* Macintosh RLE */
 #define	    COMPRESSION_THUNDERSCAN	32809	/* ThunderScan RLE */
+/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define	    COMPRESSION_IT8CTPAD	32895   /* IT8 CT w/padding */
+#define	    COMPRESSION_IT8LW		32896   /* IT8 Linework RLE */
+#define	    COMPRESSION_IT8MP		32897   /* IT8 Monochrome picture */
+#define	    COMPRESSION_IT8BL		32898   /* IT8 Binary line art */
 /* compression codes 32908-32911 are reserved for Pixar */
 #define     COMPRESSION_PIXARFILM	32908   /* Pixar companded 10bit LZW */
 #define	    COMPRESSION_PIXARLOG	32909   /* Pixar companded 11bit ZIP */
 #define	    COMPRESSION_DEFLATE		32946	/* Deflate compression */
+#define     COMPRESSION_ADOBE_DEFLATE   8       /* Deflate compression,
+						   as recognized by Adobe */
 /* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */
 #define     COMPRESSION_DCS             32947   /* Kodak DCS encoding */
 #define	    COMPRESSION_JBIG		34661	/* ISO JBIG */
+#define     COMPRESSION_SGILOG		34676	/* SGI Log Luminance RLE */
+#define     COMPRESSION_SGILOG24	34677	/* SGI Log 24-bit packed */
+#define     COMPRESSION_JP2000          34712   /* Leadtools JPEG2000 */
 #define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
 #define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
 #define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
@@ -166,6 +205,10 @@
 #define	    PHOTOMETRIC_SEPARATED	5	/* !color separations */
 #define	    PHOTOMETRIC_YCBCR		6	/* !CCIR 601 */
 #define	    PHOTOMETRIC_CIELAB		8	/* !1976 CIE L*a*b* */
+#define	    PHOTOMETRIC_ICCLAB		9	/* ICC L*a*b* [Adobe TIFF Technote 4] */
+#define	    PHOTOMETRIC_ITULAB		10	/* ITU L*a*b* */
+#define     PHOTOMETRIC_LOGL		32844	/* CIE Log2(L) */
+#define     PHOTOMETRIC_LOGLUV		32845	/* CIE Log2(L) (u',v') */
 #define	TIFFTAG_THRESHHOLDING		263	/* +thresholding used on data */
 #define	    THRESHHOLD_BILEVEL		1	/* b&w art scan */
 #define	    THRESHHOLD_HALFTONE		2	/* or dithered scan */
@@ -212,10 +255,12 @@
 #define	    GRAYRESPONSEUNIT_100000S	5	/* hundred-thousandths */
 #define	TIFFTAG_GRAYRESPONSECURVE	291	/* $gray scale response curve */
 #define	TIFFTAG_GROUP3OPTIONS		292	/* 32 flag bits */
+#define	TIFFTAG_T4OPTIONS		292	/* TIFF 6.0 proper name alias */
 #define	    GROUP3OPT_2DENCODING	0x1	/* 2-dimensional coding */
 #define	    GROUP3OPT_UNCOMPRESSED	0x2	/* data not compressed */
 #define	    GROUP3OPT_FILLBITS		0x4	/* fill to byte boundary */
 #define	TIFFTAG_GROUP4OPTIONS		293	/* 32 flag bits */
+#define TIFFTAG_T6OPTIONS               293     /* TIFF 6.0 proper name */
 #define	    GROUP4OPT_UNCOMPRESSED	0x2	/* data not compressed */
 #define	TIFFTAG_RESOLUTIONUNIT		296	/* units of resolutions */
 #define	    RESUNIT_NONE		1	/* no meaningful units */
@@ -234,12 +279,15 @@
 #define	TIFFTAG_ARTIST			315	/* creator of image */
 #define	TIFFTAG_HOSTCOMPUTER		316	/* machine where created */
 #define	TIFFTAG_PREDICTOR		317	/* prediction scheme w/ LZW */
+#define     PREDICTOR_NONE		1	/* no prediction scheme used */
+#define     PREDICTOR_HORIZONTAL	2	/* horizontal differencing */
+#define     PREDICTOR_FLOATINGPOINT	3	/* floating point predictor */
 #define	TIFFTAG_WHITEPOINT		318	/* image white point */
 #define	TIFFTAG_PRIMARYCHROMATICITIES	319	/* !primary chromaticities */
 #define	TIFFTAG_COLORMAP		320	/* RGB map for pallette image */
 #define	TIFFTAG_HALFTONEHINTS		321	/* !highlight+shadow info */
-#define	TIFFTAG_TILEWIDTH		322	/* !rows/data tile */
-#define	TIFFTAG_TILELENGTH		323	/* !cols/data tile */
+#define	TIFFTAG_TILEWIDTH		322	/* !tile width in pixels */
+#define	TIFFTAG_TILELENGTH		323	/* !tile height in pixels */
 #define TIFFTAG_TILEOFFSETS		324	/* !offsets to data tiles */
 #define TIFFTAG_TILEBYTECOUNTS		325	/* !byte counts for tiles */
 #define	TIFFTAG_BADFAXLINES		326	/* lines w/ wrong pixel count */
@@ -250,8 +298,10 @@
 #define	TIFFTAG_CONSECUTIVEBADFAXLINES	328	/* max consecutive bad lines */
 #define	TIFFTAG_SUBIFD			330	/* subimage descriptors */
 #define	TIFFTAG_INKSET			332	/* !inks in separated image */
-#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black */
+#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black color */
+#define	    INKSET_MULTIINK		2	/* !multi-ink or hi-fi color */
 #define	TIFFTAG_INKNAMES		333	/* !ascii names of inks */
+#define	TIFFTAG_NUMBEROFINKS		334	/* !number of inks */
 #define	TIFFTAG_DOTRANGE		336	/* !0% and 100% dot codes */
 #define	TIFFTAG_TARGETPRINTER		337	/* !separation target */
 #define	TIFFTAG_EXTRASAMPLES		338	/* !info about extra samples */
@@ -263,12 +313,23 @@
 #define	    SAMPLEFORMAT_INT		2	/* !signed integer data */
 #define	    SAMPLEFORMAT_IEEEFP		3	/* !IEEE floating point data */
 #define	    SAMPLEFORMAT_VOID		4	/* !untyped data */
+#define	    SAMPLEFORMAT_COMPLEXINT	5	/* !complex signed int */
+#define	    SAMPLEFORMAT_COMPLEXIEEEFP	6	/* !complex ieee floating */
 #define	TIFFTAG_SMINSAMPLEVALUE		340	/* !variable MinSampleValue */
 #define	TIFFTAG_SMAXSAMPLEVALUE		341	/* !variable MaxSampleValue */
+#define	TIFFTAG_CLIPPATH		343	/* %ClipPath
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_XCLIPPATHUNITS		344	/* %XClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_YCLIPPATHUNITS		345	/* %YClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_INDEXED			346	/* %Indexed
+						   [Adobe TIFF Technote 3] */
 #define	TIFFTAG_JPEGTABLES		347	/* %JPEG table stream */
+#define	TIFFTAG_OPIPROXY		351	/* %OPI Proxy [Adobe TIFF technote] */
 /*
- * Tags 512-521 are obsoleted by Technical Note #2
- * which specifies a revised JPEG-in-TIFF scheme.
+ * Tags 512-521 are obsoleted by Technical Note #2 which specifies a
+ * revised JPEG-in-TIFF scheme.
  */
 #define	TIFFTAG_JPEGPROC		512	/* !JPEG processing algorithm */
 #define	    JPEGPROC_BASELINE		1	/* !baseline sequential */
@@ -287,6 +348,11 @@
 #define	    YCBCRPOSITION_CENTERED	1	/* !as in PostScript Level 2 */
 #define	    YCBCRPOSITION_COSITED	2	/* !as in CCIR 601-1 */
 #define	TIFFTAG_REFERENCEBLACKWHITE	532	/* !colorimetry info */
+#define	TIFFTAG_XMLPACKET		700	/* %XML packet
+						   [Adobe XMP Specification,
+						   January 2004 */
+#define TIFFTAG_OPIIMAGEID		32781	/* %OPI ImageID
+						   [Adobe TIFF technote] */
 /* tags 32952-32956 are private tags registered to Island Graphics */
 #define TIFFTAG_REFPTS			32953	/* image reference points */
 #define TIFFTAG_REGIONTACKPOINT		32954	/* region-xform tack point */
@@ -307,31 +373,154 @@
  */
 #define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   /* full image size in x */
 #define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   /* full image size in y */
+ /* Tags 33302-33306 are used to identify special image modes and data
+  * used by Pixar's texture formats.
+  */
+#define TIFFTAG_PIXAR_TEXTUREFORMAT	33302	/* texture map format */
+#define TIFFTAG_PIXAR_WRAPMODES		33303	/* s & t wrap modes */
+#define TIFFTAG_PIXAR_FOVCOT		33304	/* cotan(fov) for env. maps */
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN 33305
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA 33306
 /* tag 33405 is a private tag registered to Eastman Kodak */
 #define TIFFTAG_WRITERSERIALNUMBER      33405   /* device serial number */
 /* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
 #define	TIFFTAG_COPYRIGHT		33432	/* copyright string */
+/* IPTC TAG from RichTIFF specifications */
+#define TIFFTAG_RICHTIFFIPTC		33723
+/* 34016-34029 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define TIFFTAG_IT8SITE			34016	/* site name */
+#define TIFFTAG_IT8COLORSEQUENCE	34017	/* color seq. [RGB,CMYK,etc] */
+#define TIFFTAG_IT8HEADER		34018	/* DDES Header */
+#define TIFFTAG_IT8RASTERPADDING	34019	/* raster scanline padding */
+#define TIFFTAG_IT8BITSPERRUNLENGTH	34020	/* # of bits in short run */
+#define TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH 34021/* # of bits in long run */
+#define TIFFTAG_IT8COLORTABLE		34022	/* LW colortable */
+#define TIFFTAG_IT8IMAGECOLORINDICATOR	34023	/* BP/BL image color switch */
+#define TIFFTAG_IT8BKGCOLORINDICATOR	34024	/* BP/BL bg color switch */
+#define TIFFTAG_IT8IMAGECOLORVALUE	34025	/* BP/BL image color value */
+#define TIFFTAG_IT8BKGCOLORVALUE	34026	/* BP/BL bg color value */
+#define TIFFTAG_IT8PIXELINTENSITYRANGE	34027	/* MP pixel intensity value */
+#define TIFFTAG_IT8TRANSPARENCYINDICATOR 34028	/* HC transparency switch */
+#define TIFFTAG_IT8COLORCHARACTERIZATION 34029	/* color character. table */
+#define TIFFTAG_IT8HCUSAGE		34030	/* HC usage indicator */
+#define TIFFTAG_IT8TRAPINDICATOR	34031	/* Trapping indicator
+						   (untrapped=0, trapped=1) */
+#define TIFFTAG_IT8CMYKEQUIVALENT	34032	/* CMYK color equivalents */
 /* tags 34232-34236 are private tags registered to Texas Instruments */
 #define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
+/* tag 34377 is private tag registered to Adobe for PhotoShop */
+#define TIFFTAG_PHOTOSHOP		34377 
+/* tags 34665, 34853 and 40965 are documented in EXIF specification */
+#define TIFFTAG_EXIFIFD			34665	/* Pointer to EXIF private directory */
+/* tag 34750 is a private tag registered to Adobe? */
+#define TIFFTAG_ICCPROFILE		34675	/* ICC profile data */
 /* tag 34750 is a private tag registered to Pixel Magic */
 #define	TIFFTAG_JBIGOPTIONS		34750	/* JBIG options */
+#define TIFFTAG_GPSIFD			34853	/* Pointer to GPS private directory */
 /* tags 34908-34914 are private tags registered to SGI */
 #define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. parms */
 #define	TIFFTAG_FAXSUBADDRESS		34909	/* received SubAddr string */
 #define	TIFFTAG_FAXRECVTIME		34910	/* receive time (secs) */
+#define	TIFFTAG_FAXDCS			34911	/* encoded fax ses. params, Table 2/T.30 */
+/* tags 37439-37443 are registered to SGI <gregl@sgi.com> */
+#define TIFFTAG_STONITS			37439	/* Sample value to Nits */
+/* tag 34929 is a private tag registered to FedEx */
+#define	TIFFTAG_FEDEX_EDR		34929	/* unknown use */
+#define TIFFTAG_INTEROPERABILITYIFD	40965	/* Pointer to Interoperability private directory */
+/* Adobe Digital Negative (DNG) format tags */
+#define TIFFTAG_DNGVERSION		50706	/* &DNG version number */
+#define TIFFTAG_DNGBACKWARDVERSION	50707	/* &DNG compatibility version */
+#define TIFFTAG_UNIQUECAMERAMODEL	50708	/* &name for the camera model */
+#define TIFFTAG_LOCALIZEDCAMERAMODEL	50709	/* &localized camera model
+						   name */
+#define TIFFTAG_CFAPLANECOLOR		50710	/* &CFAPattern->LinearRaw space
+						   mapping */
+#define TIFFTAG_CFALAYOUT		50711	/* &spatial layout of the CFA */
+#define TIFFTAG_LINEARIZATIONTABLE	50712	/* &lookup table description */
+#define TIFFTAG_BLACKLEVELREPEATDIM	50713	/* &repeat pattern size for
+						   the BlackLevel tag */
+#define TIFFTAG_BLACKLEVEL		50714	/* &zero light encoding level */
+#define TIFFTAG_BLACKLEVELDELTAH	50715	/* &zero light encoding level
+						   differences (columns) */
+#define TIFFTAG_BLACKLEVELDELTAV	50716	/* &zero light encoding level
+						   differences (rows) */
+#define TIFFTAG_WHITELEVEL		50717	/* &fully saturated encoding
+						   level */
+#define TIFFTAG_DEFAULTSCALE		50718	/* &default scale factors */
+#define TIFFTAG_DEFAULTCROPORIGIN	50719	/* &origin of the final image
+						   area */
+#define TIFFTAG_DEFAULTCROPSIZE		50720	/* &size of the final image 
+						   area */
+#define TIFFTAG_COLORMATRIX1		50721	/* &XYZ->reference color space
+						   transformation matrix 1 */
+#define TIFFTAG_COLORMATRIX2		50722	/* &XYZ->reference color space
+						   transformation matrix 2 */
+#define TIFFTAG_CAMERACALIBRATION1	50723	/* &calibration matrix 1 */
+#define TIFFTAG_CAMERACALIBRATION2	50724	/* &calibration matrix 2 */
+#define TIFFTAG_REDUCTIONMATRIX1	50725	/* &dimensionality reduction
+						   matrix 1 */
+#define TIFFTAG_REDUCTIONMATRIX2	50726	/* &dimensionality reduction
+						   matrix 2 */
+#define TIFFTAG_ANALOGBALANCE		50727	/* &gain applied the stored raw
+						   values*/
+#define TIFFTAG_ASSHOTNEUTRAL		50728	/* &selected white balance in
+						   linear reference space */
+#define TIFFTAG_ASSHOTWHITEXY		50729	/* &selected white balance in
+						   x-y chromaticity
+						   coordinates */
+#define TIFFTAG_BASELINEEXPOSURE	50730	/* &how much to move the zero
+						   point */
+#define TIFFTAG_BASELINENOISE		50731	/* &relative noise level */
+#define TIFFTAG_BASELINESHARPNESS	50732	/* &relative amount of
+						   sharpening */
+#define TIFFTAG_BAYERGREENSPLIT		50733	/* &how closely the values of
+						   the green pixels in the
+						   blue/green rows track the
+						   values of the green pixels
+						   in the red/green rows */
+#define TIFFTAG_LINEARRESPONSELIMIT	50734	/* &non-linear encoding range */
+#define TIFFTAG_CAMERASERIALNUMBER	50735	/* &camera's serial number */
+#define TIFFTAG_LENSINFO		50736	/* info about the lens */
+#define TIFFTAG_CHROMABLURRADIUS	50737	/* &chroma blur radius */
+#define TIFFTAG_ANTIALIASSTRENGTH	50738	/* &relative strength of the
+						   camera's anti-alias filter */
+#define TIFFTAG_SHADOWSCALE		50739	/* &used by Adobe Camera Raw */
+#define TIFFTAG_DNGPRIVATEDATA		50740	/* &manufacturer's private data */
+#define TIFFTAG_MAKERNOTESAFETY		50741	/* &whether the EXIF MakerNote
+						   tag is safe to preserve
+						   along with the rest of the
+						   EXIF data */
+#define	TIFFTAG_CALIBRATIONILLUMINANT1	50778	/* &illuminant 1 */
+#define TIFFTAG_CALIBRATIONILLUMINANT2	50779	/* &illuminant 2 */
+#define TIFFTAG_BESTQUALITYSCALE	50780	/* &best quality multiplier */
+#define TIFFTAG_RAWDATAUNIQUEID		50781	/* &unique identifier for
+						   the raw image data */
+#define TIFFTAG_ORIGINALRAWFILENAME	50827	/* &file name of the original
+						   raw file */
+#define TIFFTAG_ORIGINALRAWFILEDATA	50828	/* &contents of the original
+						   raw file */
+#define TIFFTAG_ACTIVEAREA		50829	/* &active (non-masked) pixels
+						   of the sensor */
+#define TIFFTAG_MASKEDAREAS		50830	/* &list of coordinates
+						   of fully masked pixels */
+#define TIFFTAG_ASSHOTICCPROFILE	50831	/* &these two tags used to */
+#define TIFFTAG_ASSHOTPREPROFILEMATRIX	50832	/* map cameras's color space
+						   into ICC profile space */
+#define TIFFTAG_CURRENTICCPROFILE	50833	/* & */
+#define TIFFTAG_CURRENTPREPROFILEMATRIX	50834	/* & */
 /* tag 65535 is an undefined tag used by Eastman Kodak */
 #define TIFFTAG_DCSHUESHIFTVALUES       65535   /* hue shift correction data */
 
 /*
- * The following are ``pseudo tags'' that can be
- * used to control codec-specific functionality.
- * These tags are not written to file.  Note that
- * these values start at 0xffff+1 so that they'll
- * never collide with Aldus-assigned tags.
+ * The following are ``pseudo tags'' that can be used to control
+ * codec-specific functionality.  These tags are not written to file.
+ * Note that these values start at 0xffff+1 so that they'll never
+ * collide with Aldus-assigned tags.
  *
- * If you want your private pseudo tags ``registered''
- * (i.e. added to this file), send mail to sam@sgi.com
- * with the appropriate C definitions to add.
+ * If you want your private pseudo tags ``registered'' (i.e. added to
+ * this file), please post a bug report via the tracking system at
+ * http://www.remotesensing.org/libtiff/bugs.html with the appropriate
+ * C definitions to add.
  */
 #define	TIFFTAG_FAXMODE			65536	/* Group 3/4 format control */
 #define	    FAXMODE_CLASSIC	0x0000		/* default, include RTC */
@@ -377,4 +566,82 @@
 /* Note: quality level is on the ZLIB 1-9 scale. Default value is -1 */
 #define	TIFFTAG_ZIPQUALITY		65557	/* compression quality level */
 #define	TIFFTAG_PIXARLOGQUALITY		65558	/* PixarLog uses same scale */
+/* 65559 is allocated to Oceana Matrix <dev@oceana.com> */
+#define TIFFTAG_DCSCLIPRECTANGLE	65559	/* area of image to acquire */
+#define TIFFTAG_SGILOGDATAFMT		65560	/* SGILog user data format */
+#define     SGILOGDATAFMT_FLOAT		0	/* IEEE float samples */
+#define     SGILOGDATAFMT_16BIT		1	/* 16-bit samples */
+#define     SGILOGDATAFMT_RAW		2	/* uninterpreted data */
+#define     SGILOGDATAFMT_8BIT		3	/* 8-bit RGB monitor values */
+#define TIFFTAG_SGILOGENCODE		65561 /* SGILog data encoding control*/
+#define     SGILOGENCODE_NODITHER	0     /* do not dither encoded values*/
+#define     SGILOGENCODE_RANDITHER	1     /* randomly dither encd values */
+
+/*
+ * EXIF tags
+ */
+#define EXIFTAG_EXPOSURETIME		33434	/* Exposure time */
+#define EXIFTAG_FNUMBER			33437	/* F number */
+#define EXIFTAG_EXPOSUREPROGRAM		34850	/* Exposure program */
+#define EXIFTAG_SPECTRALSENSITIVITY	34852	/* Spectral sensitivity */
+#define EXIFTAG_ISOSPEEDRATINGS		34855	/* ISO speed rating */
+#define EXIFTAG_OECF			34856	/* Optoelectric conversion
+						   factor */
+#define EXIFTAG_EXIFVERSION		36864	/* Exif version */
+#define EXIFTAG_DATETIMEORIGINAL	36867	/* Date and time of original
+						   data generation */
+#define EXIFTAG_DATETIMEDIGITIZED	36868	/* Date and time of digital
+						   data generation */
+#define EXIFTAG_COMPONENTSCONFIGURATION	37121	/* Meaning of each component */
+#define EXIFTAG_COMPRESSEDBITSPERPIXEL	37122	/* Image compression mode */
+#define EXIFTAG_SHUTTERSPEEDVALUE	37377	/* Shutter speed */
+#define EXIFTAG_APERTUREVALUE		37378	/* Aperture */
+#define EXIFTAG_BRIGHTNESSVALUE		37379	/* Brightness */
+#define EXIFTAG_EXPOSUREBIASVALUE	37380	/* Exposure bias */
+#define EXIFTAG_MAXAPERTUREVALUE	37381	/* Maximum lens aperture */
+#define EXIFTAG_SUBJECTDISTANCE		37382	/* Subject distance */
+#define EXIFTAG_METERINGMODE		37383	/* Metering mode */
+#define EXIFTAG_LIGHTSOURCE		37384	/* Light source */
+#define EXIFTAG_FLASH			37385	/* Flash */
+#define EXIFTAG_FOCALLENGTH		37386	/* Lens focal length */
+#define EXIFTAG_SUBJECTAREA		37396	/* Subject area */
+#define EXIFTAG_MAKERNOTE		37500	/* Manufacturer notes */
+#define EXIFTAG_USERCOMMENT		37510	/* User comments */
+#define EXIFTAG_SUBSECTIME		37520	/* DateTime subseconds */
+#define EXIFTAG_SUBSECTIMEORIGINAL	37521	/* DateTimeOriginal subseconds */
+#define EXIFTAG_SUBSECTIMEDIGITIZED	37522	/* DateTimeDigitized subseconds */
+#define EXIFTAG_FLASHPIXVERSION		40960	/* Supported Flashpix version */
+#define EXIFTAG_COLORSPACE		40961	/* Color space information */
+#define EXIFTAG_PIXELXDIMENSION		40962	/* Valid image width */
+#define EXIFTAG_PIXELYDIMENSION		40963	/* Valid image height */
+#define EXIFTAG_RELATEDSOUNDFILE	40964	/* Related audio file */
+#define EXIFTAG_FLASHENERGY		41483	/* Flash energy */
+#define EXIFTAG_SPATIALFREQUENCYRESPONSE 41484	/* Spatial frequency response */
+#define EXIFTAG_FOCALPLANEXRESOLUTION	41486	/* Focal plane X resolution */
+#define EXIFTAG_FOCALPLANEYRESOLUTION	41487	/* Focal plane Y resolution */
+#define EXIFTAG_FOCALPLANERESOLUTIONUNIT 41488	/* Focal plane resolution unit */
+#define EXIFTAG_SUBJECTLOCATION		41492	/* Subject location */
+#define EXIFTAG_EXPOSUREINDEX		41493	/* Exposure index */
+#define EXIFTAG_SENSINGMETHOD		41495	/* Sensing method */
+#define EXIFTAG_FILESOURCE		41728	/* File source */
+#define EXIFTAG_SCENETYPE		41729	/* Scene type */
+#define EXIFTAG_CFAPATTERN		41730	/* CFA pattern */
+#define EXIFTAG_CUSTOMRENDERED		41985	/* Custom image processing */
+#define EXIFTAG_EXPOSUREMODE		41986	/* Exposure mode */
+#define EXIFTAG_WHITEBALANCE		41987	/* White balance */
+#define EXIFTAG_DIGITALZOOMRATIO	41988	/* Digital zoom ratio */
+#define EXIFTAG_FOCALLENGTHIN35MMFILM	41989	/* Focal length in 35 mm film */
+#define EXIFTAG_SCENECAPTURETYPE	41990	/* Scene capture type */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_CONTRAST		41992	/* Contrast */
+#define EXIFTAG_SATURATION		41993	/* Saturation */
+#define EXIFTAG_SHARPNESS		41994	/* Sharpness */
+#define EXIFTAG_DEVICESETTINGDESCRIPTION 41995	/* Device settings description */
+#define EXIFTAG_SUBJECTDISTANCERANGE	41996	/* Subject distance range */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_IMAGEUNIQUEID		42016	/* Unique image ID */
+
 #endif /* _TIFF_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN -xdebian -x.svn ./libs/libtiff/tiffio.h /usr/src/openjpeg/trunk/libs/libtiff/tiffio.h
--- ./libs/libtiff/tiffio.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/tiffio.h	2007-09-28 11:33:43.000000000 +0100
@@ -1,8 +1,8 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffio.h,v 1.93 1996/03/07 17:00:14 sam Rel $ */
+/* $Id: tiffio.h,v 1.50 2006/03/21 16:37:51 dron Exp $ */
 
 /*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and 
  * its documentation for any purpose is hereby granted without fee, provided
@@ -19,8 +19,8 @@
  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  * OF THIS SOFTWARE.
  */
 
@@ -31,15 +31,7 @@
  * TIFF I/O Library Definitions.
  */
 #include "tiff.h"
-
-/*
- * This define can be used in code that requires
- * compilation-related definitions specific to a
- * version or versions of the library.  Runtime
- * version checking should be done based on the
- * string returned by TIFFGetVersion.
- */
-#define	TIFFLIB_VERSION	19960307	/* March 7, 1996 */
+#include "tiffvers.h"
 
 /*
  * TIFF is defined as an incomplete type to hide the
@@ -52,7 +44,7 @@
  * data types used in the *exported* interfaces.  These
  * definitions depend on the proper definition of types
  * in tiff.h.  Note also that the varargs interface used
- * pass tag types and values uses the types defined in
+ * to pass tag types and values uses the types defined in
  * tiff.h directly.
  *
  * NB: ttag_t is unsigned int and not unsigned short because
@@ -63,29 +55,49 @@
  * NB: tsize_t is int32 and not uint32 because some functions
  *     return -1.
  * NB: toff_t is not off_t for many reasons; TIFFs max out at
- *     32-bit file offsets being the most important
+ *     32-bit file offsets being the most important, and to ensure
+ *     that it is unsigned, rather than signed.
  */
-typedef	unsigned int ttag_t;	/* directory tag */
+typedef	uint32 ttag_t;		/* directory tag */
 typedef	uint16 tdir_t;		/* directory index */
 typedef	uint16 tsample_t;	/* sample number */
 typedef	uint32 tstrip_t;	/* strip number */
 typedef uint32 ttile_t;		/* tile number */
 typedef	int32 tsize_t;		/* i/o size in bytes */
+typedef	void* tdata_t;		/* image data ref */
+typedef	uint32 toff_t;		/* file offset */
+
+#if !defined(__WIN32__) && (defined(_WIN32) || defined(WIN32))
+#define __WIN32__
+#endif
+
+/*
+ * On windows you should define USE_WIN32_FILEIO if you are using tif_win32.c
+ * or AVOID_WIN32_FILEIO if you are using something else (like tif_unix.c).
+ *
+ * By default tif_unix.c is assumed.
+ */
+
 #if defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
-#include <windows.h>
-#ifdef __WIN32__
+#  if !defined(__CYGWIN) && !defined(AVOID_WIN32_FILEIO) && !defined(USE_WIN32_FILEIO)
+#    define AVOID_WIN32_FILEIO
+#  endif
+#endif
+
+#if defined(USE_WIN32_FILEIO)
+# define VC_EXTRALEAN
+# include <windows.h>
+# ifdef __WIN32__
 DECLARE_HANDLE(thandle_t);	/* Win32 file handle */
-#else
+# else
 typedef	HFILE thandle_t;	/* client data handle */
-#endif
+# endif /* __WIN32__ */
 #else
 typedef	void* thandle_t;	/* client data handle */
-#endif
-typedef	void* tdata_t;		/* image data ref */
-typedef	int32 toff_t;		/* file offset */
+#endif /* USE_WIN32_FILEIO */
 
 #ifndef NULL
-#define	NULL	0
+# define NULL	(void *)0
 #endif
 
 /*
@@ -102,10 +114,62 @@
 #define	TIFFPRINT_JPEGACTABLES	0x200		/* JPEG AC tables */
 #define	TIFFPRINT_JPEGDCTABLES	0x200		/* JPEG DC tables */
 
+/* 
+ * Colour conversion stuff
+ */
+
+/* reference white */
+#define D65_X0 (95.0470F)
+#define D65_Y0 (100.0F)
+#define D65_Z0 (108.8827F)
+
+#define D50_X0 (96.4250F)
+#define D50_Y0 (100.0F)
+#define D50_Z0 (82.4680F)
+
+/* Structure for holding information about a display device. */
+
+typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
+
+typedef struct {
+	float d_mat[3][3]; 		/* XYZ -> luminance matrix */
+	float d_YCR;			/* Light o/p for reference white */
+	float d_YCG;
+	float d_YCB;
+	uint32 d_Vrwr;			/* Pixel values for ref. white */
+	uint32 d_Vrwg;
+	uint32 d_Vrwb;
+	float d_Y0R;			/* Residual light for black pixel */
+	float d_Y0G;
+	float d_Y0B;
+	float d_gammaR;			/* Gamma values for the three guns */
+	float d_gammaG;
+	float d_gammaB;
+} TIFFDisplay;
+
+typedef struct {				/* YCbCr->RGB support */
+	TIFFRGBValue* clamptab;			/* range clamping table */
+	int*	Cr_r_tab;
+	int*	Cb_b_tab;
+	int32*	Cr_g_tab;
+	int32*	Cb_g_tab;
+        int32*  Y_tab;
+} TIFFYCbCrToRGB;
+
+typedef struct {				/* CIE Lab 1976->RGB support */
+	int	range;				/* Size of conversion table */
+#define CIELABTORGB_TABLE_RANGE 1500
+	float	rstep, gstep, bstep;
+	float	X0, Y0, Z0;			/* Reference white point */
+	TIFFDisplay display;
+	float	Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */
+	float	Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */
+	float	Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */
+} TIFFCIELabToRGB;
+
 /*
  * RGBA-style image support.
  */
-typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
 typedef struct _TIFFRGBAImage TIFFRGBAImage;
 /*
  * The image reading and conversion routines invoke
@@ -126,15 +190,6 @@
 /*
  * RGBA-reader state.
  */
-typedef struct {				/* YCbCr->RGB support */
-	TIFFRGBValue* clamptab;			/* range clamping table */
-	int*	Cr_r_tab;
-	int*	Cb_b_tab;
-	int32*	Cr_g_tab;
-	int32*	Cb_g_tab;
-	float	coeffs[3];			/* cached for repeated use */
-} TIFFYCbCrToRGB;
-
 struct _TIFFRGBAImage {
 	TIFF*	tif;				/* image handle */
 	int	stoponerr;			/* stop on read error */
@@ -145,6 +200,7 @@
 	uint16	bitspersample;			/* image bits/sample */
 	uint16	samplesperpixel;		/* image samples/pixel */
 	uint16	orientation;			/* image orientation */
+	uint16	req_orientation;		/* requested orientation */
 	uint16	photometric;			/* image photometric interp */
 	uint16*	redcmap;			/* colormap pallete */
 	uint16*	greencmap;
@@ -160,6 +216,10 @@
 	uint32** BWmap;				/* black&white map */
 	uint32** PALmap;			/* palette image map */
 	TIFFYCbCrToRGB* ycbcr;			/* YCbCr conversion state */
+        TIFFCIELabToRGB* cielab;		/* CIE L*a*b conversion state */
+
+        int	row_offset;
+        int     col_offset;
 };
 
 /*
@@ -188,10 +248,16 @@
 #include <stdio.h>
 #include <stdarg.h>
 
-#if defined(__cplusplus)
+/* share internal LogLuv conversion routines? */
+#ifndef LOGLUV_PUBLIC
+#define LOGLUV_PUBLIC		1
+#endif
+
+#if defined(c_plusplus) || defined(__cplusplus)
 extern "C" {
 #endif
 typedef	void (*TIFFErrorHandler)(const char*, const char*, va_list);
+typedef	void (*TIFFErrorHandlerExt)(thandle_t, const char*, const char*, va_list);
 typedef	tsize_t (*TIFFReadWriteProc)(thandle_t, tdata_t, tsize_t);
 typedef	toff_t (*TIFFSeekProc)(thandle_t, toff_t, int);
 typedef	int (*TIFFCloseProc)(thandle_t);
@@ -205,6 +271,12 @@
 extern	const TIFFCodec* TIFFFindCODEC(uint16);
 extern	TIFFCodec* TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod);
 extern	void TIFFUnRegisterCODEC(TIFFCodec*);
+extern  int TIFFIsCODECConfigured(uint16);
+extern	TIFFCodec* TIFFGetConfiguredCODECs(void);
+
+/*
+ * Auxiliary functions.
+ */
 
 extern	tdata_t _TIFFmalloc(tsize_t);
 extern	tdata_t _TIFFrealloc(tdata_t, tsize_t);
@@ -213,6 +285,58 @@
 extern	int _TIFFmemcmp(const tdata_t, const tdata_t, tsize_t);
 extern	void _TIFFfree(tdata_t);
 
+/*
+** Stuff, related to tag handling and creating custom tags.
+*/
+extern  int  TIFFGetTagListCount( TIFF * );
+extern  ttag_t TIFFGetTagListEntry( TIFF *, int tag_index );
+    
+#define	TIFF_ANY	TIFF_NOTYPE	/* for field descriptor searching */
+#define	TIFF_VARIABLE	-1		/* marker for variable length tags */
+#define	TIFF_SPP	-2		/* marker for SamplesPerPixel tags */
+#define	TIFF_VARIABLE2	-3		/* marker for uint32 var-length tags */
+
+#define FIELD_CUSTOM    65    
+
+typedef	struct {
+	ttag_t	field_tag;		/* field's tag */
+	short	field_readcount;	/* read count/TIFF_VARIABLE/TIFF_SPP */
+	short	field_writecount;	/* write count/TIFF_VARIABLE */
+	TIFFDataType field_type;	/* type of associated data */
+        unsigned short field_bit;	/* bit in fieldsset bit vector */
+	unsigned char field_oktochange;	/* if true, can change while writing */
+	unsigned char field_passcount;	/* if true, pass dir count on set */
+	char	*field_name;		/* ASCII name */
+} TIFFFieldInfo;
+
+typedef struct _TIFFTagValue {
+    const TIFFFieldInfo  *info;
+    int             count;
+    void           *value;
+} TIFFTagValue;
+
+extern	void TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], int);
+extern	const TIFFFieldInfo* TIFFFindFieldInfo(TIFF*, ttag_t, TIFFDataType);
+extern  const TIFFFieldInfo* TIFFFindFieldInfoByName(TIFF* , const char *,
+						     TIFFDataType);
+extern	const TIFFFieldInfo* TIFFFieldWithTag(TIFF*, ttag_t);
+extern	const TIFFFieldInfo* TIFFFieldWithName(TIFF*, const char *);
+
+typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
+typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
+typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
+    
+typedef struct {
+    TIFFVSetMethod	vsetfield;	/* tag set routine */
+    TIFFVGetMethod	vgetfield;	/* tag get routine */
+    TIFFPrintMethod	printdir;	/* directory print routine */
+} TIFFTagMethods;
+        
+extern  TIFFTagMethods *TIFFAccessTagMethods( TIFF * );
+extern  void *TIFFGetClientInfo( TIFF *, const char * );
+extern  void TIFFSetClientInfo( TIFF *, void *, const char * );
+
+extern	void TIFFCleanup(TIFF*);
 extern	void TIFFClose(TIFF*);
 extern	int TIFFFlush(TIFF*);
 extern	int TIFFFlushData(TIFF*);
@@ -221,9 +345,13 @@
 extern	int TIFFGetFieldDefaulted(TIFF*, ttag_t, ...);
 extern	int TIFFVGetFieldDefaulted(TIFF*, ttag_t, va_list);
 extern	int TIFFReadDirectory(TIFF*);
+extern	int TIFFReadCustomDirectory(TIFF*, toff_t, const TIFFFieldInfo[],
+				    size_t);
+extern	int TIFFReadEXIFDirectory(TIFF*, toff_t);
 extern	tsize_t TIFFScanlineSize(TIFF*);
 extern	tsize_t TIFFRasterScanlineSize(TIFF*);
 extern	tsize_t TIFFStripSize(TIFF*);
+extern	tsize_t TIFFRawStripSize(TIFF*, tstrip_t);
 extern	tsize_t TIFFVStripSize(TIFF*, uint32);
 extern	tsize_t TIFFTileRowSize(TIFF*);
 extern	tsize_t TIFFTileSize(TIFF*);
@@ -231,18 +359,35 @@
 extern	uint32 TIFFDefaultStripSize(TIFF*, uint32);
 extern	void TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
 extern	int TIFFFileno(TIFF*);
+extern  int TIFFSetFileno(TIFF*, int);
+extern  thandle_t TIFFClientdata(TIFF*);
+extern  thandle_t TIFFSetClientdata(TIFF*, thandle_t);
 extern	int TIFFGetMode(TIFF*);
+extern	int TIFFSetMode(TIFF*, int);
 extern	int TIFFIsTiled(TIFF*);
 extern	int TIFFIsByteSwapped(TIFF*);
 extern	int TIFFIsUpSampled(TIFF*);
 extern	int TIFFIsMSB2LSB(TIFF*);
+extern	int TIFFIsBigEndian(TIFF*);
+extern	TIFFReadWriteProc TIFFGetReadProc(TIFF*);
+extern	TIFFReadWriteProc TIFFGetWriteProc(TIFF*);
+extern	TIFFSeekProc TIFFGetSeekProc(TIFF*);
+extern	TIFFCloseProc TIFFGetCloseProc(TIFF*);
+extern	TIFFSizeProc TIFFGetSizeProc(TIFF*);
+extern	TIFFMapFileProc TIFFGetMapFileProc(TIFF*);
+extern	TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF*);
 extern	uint32 TIFFCurrentRow(TIFF*);
 extern	tdir_t TIFFCurrentDirectory(TIFF*);
+extern	tdir_t TIFFNumberOfDirectories(TIFF*);
 extern	uint32 TIFFCurrentDirOffset(TIFF*);
 extern	tstrip_t TIFFCurrentStrip(TIFF*);
 extern	ttile_t TIFFCurrentTile(TIFF*);
 extern	int TIFFReadBufferSetup(TIFF*, tdata_t, tsize_t);
 extern	int TIFFWriteBufferSetup(TIFF*, tdata_t, tsize_t);
+extern	int TIFFSetupStrips(TIFF *);
+extern  int TIFFWriteCheck(TIFF*, int, const char *);
+extern	void TIFFFreeDirectory(TIFF*);
+extern  int TIFFCreateDirectory(TIFF*);
 extern	int TIFFLastDirectory(TIFF*);
 extern	int TIFFSetDirectory(TIFF*, tdir_t);
 extern	int TIFFSetSubDirectory(TIFF*, uint32);
@@ -250,22 +395,35 @@
 extern	int TIFFSetField(TIFF*, ttag_t, ...);
 extern	int TIFFVSetField(TIFF*, ttag_t, va_list);
 extern	int TIFFWriteDirectory(TIFF *);
+extern	int TIFFCheckpointDirectory(TIFF *);
+extern	int TIFFRewriteDirectory(TIFF *);
+extern	int TIFFReassignTagToIgnore(enum TIFFIgnoreSense, int);
+
 #if defined(c_plusplus) || defined(__cplusplus)
 extern	void TIFFPrintDirectory(TIFF*, FILE*, long = 0);
 extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
 extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
 extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,
+				      int = ORIENTATION_BOTLEFT, int = 0);
 #else
 extern	void TIFFPrintDirectory(TIFF*, FILE*, long);
 extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t);
 extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t);
 extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int);
 #endif
+
+extern	int TIFFReadRGBAStrip(TIFF*, tstrip_t, uint32 * );
+extern	int TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * );
 extern	int TIFFRGBAImageOK(TIFF*, char [1024]);
 extern	int TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024]);
 extern	int TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32);
 extern	void TIFFRGBAImageEnd(TIFFRGBAImage*);
 extern	TIFF* TIFFOpen(const char*, const char*);
+# ifdef __WIN32__
+extern	TIFF* TIFFOpenW(const wchar_t*, const char*);
+# endif /* __WIN32__ */
 extern	TIFF* TIFFFdOpen(int, const char*, const char*);
 extern	TIFF* TIFFClientOpen(const char*, const char*,
 	    thandle_t,
@@ -274,10 +432,15 @@
 	    TIFFSizeProc,
 	    TIFFMapFileProc, TIFFUnmapFileProc);
 extern	const char* TIFFFileName(TIFF*);
+extern	const char* TIFFSetFileName(TIFF*, const char *);
 extern	void TIFFError(const char*, const char*, ...);
+extern	void TIFFErrorExt(thandle_t, const char*, const char*, ...);
 extern	void TIFFWarning(const char*, const char*, ...);
+extern	void TIFFWarningExt(thandle_t, const char*, const char*, ...);
 extern	TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt);
 extern	TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt);
 extern	TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc);
 extern	ttile_t TIFFComputeTile(TIFF*, uint32, uint32, uint32, tsample_t);
 extern	int TIFFCheckTile(TIFF*, uint32, uint32, uint32, tsample_t);
@@ -296,16 +459,57 @@
 extern	tsize_t TIFFWriteRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
 extern	tsize_t TIFFWriteEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
 extern	tsize_t TIFFWriteRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	int TIFFDataWidth(TIFFDataType);    /* table of tag datatype widths */
 extern	void TIFFSetWriteOffset(TIFF*, toff_t);
 extern	void TIFFSwabShort(uint16*);
 extern	void TIFFSwabLong(uint32*);
 extern	void TIFFSwabDouble(double*);
 extern	void TIFFSwabArrayOfShort(uint16*, unsigned long);
+extern	void TIFFSwabArrayOfTriples(uint8*, unsigned long);
 extern	void TIFFSwabArrayOfLong(uint32*, unsigned long);
 extern	void TIFFSwabArrayOfDouble(double*, unsigned long);
 extern	void TIFFReverseBits(unsigned char *, unsigned long);
 extern	const unsigned char* TIFFGetBitRevTable(int);
-#if defined(__cplusplus)
+
+#ifdef LOGLUV_PUBLIC
+#define U_NEU		0.210526316
+#define V_NEU		0.473684211
+#define UVSCALE		410.
+extern	double LogL16toY(int);
+extern	double LogL10toY(int);
+extern	void XYZtoRGB24(float*, uint8*);
+extern	int uv_decode(double*, double*, int);
+extern	void LogLuv24toXYZ(uint32, float*);
+extern	void LogLuv32toXYZ(uint32, float*);
+#if defined(c_plusplus) || defined(__cplusplus)
+extern	int LogL16fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int LogL10fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int uv_encode(double, double, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+#else
+extern	int LogL16fromY(double, int);
+extern	int LogL10fromY(double, int);
+extern	int uv_encode(double, double, int);
+extern	uint32 LogLuv24fromXYZ(float*, int);
+extern	uint32 LogLuv32fromXYZ(float*, int);
+#endif
+#endif /* LOGLUV_PUBLIC */
+    
+extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB*, TIFFDisplay *, float*);
+extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,
+			    float *, float *, float *);
+extern void TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,
+			 uint32 *, uint32 *, uint32 *);
+
+extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*);
+extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,
+			   uint32 *, uint32 *, uint32 *);
+
+#if defined(c_plusplus) || defined(__cplusplus)
 }
 #endif
+
 #endif /* _TIFFIO_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN -xdebian -x.svn ./libs/libtiff/Tiffiop.h /usr/src/openjpeg/trunk/libs/libtiff/Tiffiop.h
--- ./libs/libtiff/Tiffiop.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/Tiffiop.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,287 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffiop.h,v 1.80 1996/04/05 17:36:53 sam Rel $ */
-
-/*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFIOP_
-#define	_TIFFIOP_
-/*
- * ``Library-private'' definitions.
- */
-/*
- * UNIX systems should run the configure script to generate
- * a port.h file that reflects the system capabilities.
- * Doing this obviates all the dreck done in tiffcomp.h.
- */
-#if defined(unix) || defined(__unix)
-#include "port.h"
-#include "tiffconf.h"
-#else
-#include "tiffconf.h"
-#include "tiffcomp.h"
-#endif
-#include "tiffio.h"
-#include "tif_dir.h"
-
-#ifndef TRUE
-#define	TRUE	1
-#define	FALSE	0
-#endif
-
-/*
- * Typedefs for ``method pointers'' used internally.
- */
-typedef	unsigned char tidataval_t;	/* internal image data value type */
-typedef	tidataval_t* tidata_t;		/* reference to internal image data */
-
-typedef	void (*TIFFVoidMethod)(TIFF*);
-typedef	int (*TIFFBoolMethod)(TIFF*);
-typedef	int (*TIFFPreMethod)(TIFF*, tsample_t);
-typedef	int (*TIFFCodeMethod)(TIFF*, tidata_t, tsize_t, tsample_t);
-typedef	int (*TIFFSeekMethod)(TIFF*, uint32);
-typedef	void (*TIFFPostMethod)(TIFF*, tidata_t, tsize_t);
-typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
-typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
-typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
-typedef	uint32 (*TIFFStripMethod)(TIFF*, uint32);
-typedef	void (*TIFFTileMethod)(TIFF*, uint32*, uint32*);
-
-struct tiff {
-	char*		tif_name;	/* name of open file */
-	int		tif_fd;		/* open file descriptor */
-	int		tif_mode;	/* open mode (O_*) */
-	uint32		tif_flags;
-#define	TIFF_FILLORDER		0x0003	/* natural bit fill order for machine */
-#define	TIFF_DIRTYHEADER	0x0004	/* header must be written on close */
-#define	TIFF_DIRTYDIRECT	0x0008	/* current directory must be written */
-#define	TIFF_BUFFERSETUP	0x0010	/* data buffers setup */
-#define	TIFF_CODERSETUP		0x0020	/* encoder/decoder setup done */
-#define	TIFF_BEENWRITING	0x0040	/* written 1+ scanlines to file */
-#define	TIFF_SWAB		0x0080	/* byte swap file information */
-#define	TIFF_NOBITREV		0x0100	/* inhibit bit reversal logic */
-#define	TIFF_MYBUFFER		0x0200	/* my raw data buffer; free on close */
-#define	TIFF_ISTILED		0x0400	/* file is tile, not strip- based */
-#define	TIFF_MAPPED		0x0800	/* file is mapped into memory */
-#define	TIFF_POSTENCODE		0x1000	/* need call to postencode routine */
-#define	TIFF_INSUBIFD		0x2000	/* currently writing a subifd */
-#define	TIFF_UPSAMPLED		0x4000	/* library is doing data up-sampling */ 
-#define	TIFF_STRIPCHOP		0x8000	/* enable strip chopping support */
-	toff_t		tif_diroff;	/* file offset of current directory */
-	toff_t		tif_nextdiroff;	/* file offset of following directory */
-	TIFFDirectory	tif_dir;	/* internal rep of current directory */
-	TIFFHeader	tif_header;	/* file's header block */
-        tidata_t        tif_clientdir;  /* client TIFF directory */
-	const int*	tif_typeshift;	/* data type shift counts */
-	const long*	tif_typemask;	/* data type masks */
-	uint32		tif_row;	/* current scanline */
-	tdir_t		tif_curdir;	/* current directory (index) */
-	tstrip_t	tif_curstrip;	/* current strip for read/write */
-	toff_t		tif_curoff;	/* current offset for read/write */
-	toff_t		tif_dataoff;	/* current offset for writing dir */
-#if SUBIFD_SUPPORT
-	uint16		tif_nsubifd;	/* remaining subifds to write */
-	toff_t		tif_subifdoff;	/* offset for patching SubIFD link */
-#endif
-/* tiling support */
-	uint32 		tif_col;	/* current column (offset by row too) */
-	ttile_t		tif_curtile;	/* current tile for read/write */
-	tsize_t		tif_tilesize;	/* # of bytes in a tile */
-/* compression scheme hooks */
-	TIFFBoolMethod	tif_setupdecode;/* called once before predecode */
-	TIFFPreMethod	tif_predecode;	/* pre- row/strip/tile decoding */
-	TIFFBoolMethod	tif_setupencode;/* called once before preencode */
-	TIFFPreMethod	tif_preencode;	/* pre- row/strip/tile encoding */
-	TIFFBoolMethod	tif_postencode;	/* post- row/strip/tile encoding */
-	TIFFCodeMethod	tif_decoderow;	/* scanline decoding routine */
-	TIFFCodeMethod	tif_encoderow;	/* scanline encoding routine */
-	TIFFCodeMethod	tif_decodestrip;/* strip decoding routine */
-	TIFFCodeMethod	tif_encodestrip;/* strip encoding routine */
-	TIFFCodeMethod	tif_decodetile;	/* tile decoding routine */
-	TIFFCodeMethod	tif_encodetile;	/* tile encoding routine */
-	TIFFVoidMethod	tif_close;	/* cleanup-on-close routine */
-	TIFFSeekMethod	tif_seek;	/* position within a strip routine */
-	TIFFVoidMethod	tif_cleanup;	/* cleanup state routine */
-	TIFFStripMethod	tif_defstripsize;/* calculate/constrain strip size */
-	TIFFTileMethod	tif_deftilesize;/* calculate/constrain tile size */
-	tidata_t	tif_data;	/* compression scheme private data */
-/* input/output buffering */
-	tsize_t		tif_scanlinesize;/* # of bytes in a scanline */
-	tsize_t		tif_scanlineskew;/* scanline skew for reading strips */
-	tidata_t	tif_rawdata;	/* raw data buffer */
-	tsize_t		tif_rawdatasize;/* # of bytes in raw data buffer */
-	tidata_t	tif_rawcp;	/* current spot in raw buffer */
-	tsize_t		tif_rawcc;	/* bytes unread from raw buffer */
-/* memory-mapped file support */
-	tidata_t	tif_base;	/* base of mapped file */
-#ifdef __WIN32__
-	void*		pv_map_handle;	/* WIN32 file mapping handle;
-					 * must be contiguous with tif_base
-					 * since map & unmap only get tif_base
-					 * and assume 4 byte offset to
-					 * pv_map_handle. */
-#endif
-	toff_t		tif_size;	/* size of mapped file region (bytes) */
-	TIFFMapFileProc	tif_mapproc;	/* map file method */
-	TIFFUnmapFileProc tif_unmapproc;/* unmap file method */
-/* input/output callback methods */
-	thandle_t	tif_clientdata;	/* callback parameter */
-	TIFFReadWriteProc tif_readproc;	/* read method */
-	TIFFReadWriteProc tif_writeproc;/* write method */
-	TIFFSeekProc	tif_seekproc;	/* lseek method */
-	TIFFCloseProc	tif_closeproc;	/* close method */
-	TIFFSizeProc	tif_sizeproc;	/* filesize method */
-/* post-decoding support */
-	TIFFPostMethod	tif_postdecode;	/* post decoding routine */
-/* tag support */
-	TIFFFieldInfo**	tif_fieldinfo;	/* sorted table of registered tags */
-	int		tif_nfields;	/* # entries in registered tag table */
-	TIFFVSetMethod	tif_vsetfield;	/* tag set routine */
-	TIFFVGetMethod	tif_vgetfield;	/* tag get routine */
-	TIFFPrintMethod	tif_printdir;	/* directory print routine */
-};
-
-#define	isPseudoTag(t)	(t > 0xffff)	/* is tag value normal or pseudo */
-
-#define	isTiled(tif)	(((tif)->tif_flags & TIFF_ISTILED) != 0)
-#define	isMapped(tif)	(((tif)->tif_flags & TIFF_MAPPED) != 0)
-#define	isFillOrder(tif, o)	(((tif)->tif_flags & (o)) != 0)
-#define	isUpSampled(tif)	(((tif)->tif_flags & TIFF_UPSAMPLED) != 0)
-#define	TIFFReadFile(tif, buf, size) \
-	((*(tif)->tif_readproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFWriteFile(tif, buf, size) \
-	((*(tif)->tif_writeproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFSeekFile(tif, off, whence) \
-	((*(tif)->tif_seekproc)((tif)->tif_clientdata,(toff_t)(off),whence))
-#define	TIFFCloseFile(tif) \
-	((*(tif)->tif_closeproc)((tif)->tif_clientdata))
-#define	TIFFGetFileSize(tif) \
-	((*(tif)->tif_sizeproc)((tif)->tif_clientdata))
-#define	TIFFMapFileContents(tif, paddr, psize) \
-	((*(tif)->tif_mapproc)((tif)->tif_clientdata,paddr,psize))
-#ifdef __WIN32__
-#define	TIFFUnmapFileContents(tif, addr, dummy) \
-	((*(tif)->tif_unmapproc)((tif)->tif_clientdata,addr,\
-	    (toff_t)(tif)->pv_map_handle))
-#else
-#define	TIFFUnmapFileContents(tif, addr, size) \
-	((*(tif)->tif_unmapproc)((tif)->tif_clientdata,addr,size))
-#endif
-
-/*
- * Default Read/Seek/Write definitions.
- */
-#ifndef ReadOK
-#define	ReadOK(tif, buf, size) \
-	(TIFFReadFile(tif, (tdata_t) buf, (tsize_t) size) == (tsize_t) size)
-#endif
-#ifndef SeekOK
-#define	SeekOK(tif, off) \
-	(TIFFSeekFile(tif, (toff_t) off, SEEK_SET) == (toff_t) off)
-#endif
-#ifndef WriteOK
-#define	WriteOK(tif, buf, size) \
-	(TIFFWriteFile(tif, (tdata_t) buf, (tsize_t) size) == (tsize_t) size)
-#endif
-
-/* NB: the uint32 casts are to silence certain ANSI-C compilers */
-#define	TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))
-#define	TIFFroundup(x, y) (TIFFhowmany(x,y)*((uint32)(y)))
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	int _TIFFgetMode(const char*, const char*);
-extern	int _TIFFNoRowEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoRowDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	void _TIFFNoPostDecode(TIFF*, tidata_t, tsize_t);
-extern	int _TIFFNoSeek(TIFF*, uint32);
-extern	void _TIFFSwab16BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab32BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab64BitData(TIFF*, tidata_t, tsize_t);
-extern	int TIFFFlushData1(TIFF*);
-extern	void TIFFFreeDirectory(TIFF*);
-extern	int TIFFDefaultDirectory(TIFF*);
-extern	int TIFFSetCompressionScheme(TIFF*, int);
-extern	uint32 _TIFFDefaultStripSize(TIFF*, uint32);
-extern	void _TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
-
-extern	void _TIFFsetByteArray(void**, void*, long);
-extern	void _TIFFsetString(char**, char*);
-extern	void _TIFFsetShortArray(uint16**, uint16*, long);
-extern	void _TIFFsetLongArray(uint32**, uint32*, long);
-extern	void _TIFFsetFloatArray(float**, float*, long);
-extern	void _TIFFsetDoubleArray(double**, double*, long);
-
-extern	void _TIFFprintAscii(FILE*, const char*);
-extern	void _TIFFprintAsciiTag(FILE*, const char*, const char*);
-
-GLOBALDATA(TIFFErrorHandler,_TIFFwarningHandler);
-GLOBALDATA(TIFFErrorHandler,_TIFFerrorHandler);
-
-extern	int TIFFInitDumpMode(TIFF*, int);
-#ifdef PACKBITS_SUPPORT
-extern	int TIFFInitPackBits(TIFF*, int);
-#endif
-#ifdef CCITT_SUPPORT
-extern	int TIFFInitCCITTRLE(TIFF*, int), TIFFInitCCITTRLEW(TIFF*, int);
-extern	int TIFFInitCCITTFax3(TIFF*, int), TIFFInitCCITTFax4(TIFF*, int);
-#endif
-#ifdef THUNDER_SUPPORT
-extern	int TIFFInitThunderScan(TIFF*, int);
-#endif
-#ifdef NEXT_SUPPORT
-extern	int TIFFInitNeXT(TIFF*, int);
-#endif
-#ifdef LZW_SUPPORT
-extern	int TIFFInitLZW(TIFF*, int);
-#endif
-#ifdef OJPEG_SUPPORT
-extern	int TIFFInitOJPEG(TIFF*, int);
-#endif
-#ifdef JPEG_SUPPORT
-extern	int TIFFInitJPEG(TIFF*, int);
-#endif
-#ifdef JBIG_SUPPORT
-extern	int TIFFInitJBIG(TIFF*, int);
-#endif
-#ifdef ZIP_SUPPORT
-extern	int TIFFInitZIP(TIFF*, int);
-#endif
-#ifdef PIXARLOG_SUPPORT
-extern	int TIFFInitPixarLog(TIFF*, int);
-#endif
-#ifdef VMS
-extern	const TIFFCodec _TIFFBuiltinCODECS[];
-#else
-extern	TIFFCodec _TIFFBuiltinCODECS[];
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-#endif /* _TIFFIOP_ */
diff -urN -xdebian -x.svn ./libs/libtiff/tiffvers.h /usr/src/openjpeg/trunk/libs/libtiff/tiffvers.h
--- ./libs/libtiff/tiffvers.h	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/libs/libtiff/tiffvers.h	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+#define TIFFLIB_VERSION_STR "LIBTIFF, Version 3.8.2\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
+/*
+ * This define can be used in code that requires
+ * compilation-related definitions specific to a
+ * version or versions of the library.  Runtime
+ * version checking should be done based on the
+ * string returned by TIFFGetVersion.
+ */
+#define TIFFLIB_VERSION 20060323
diff -urN -xdebian -x.svn ./libs/libtiff/Version.h /usr/src/openjpeg/trunk/libs/libtiff/Version.h
--- ./libs/libtiff/Version.h	2007-11-29 18:26:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/libs/libtiff/Version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#define VERSION "LIBTIFF, Version 3.4beta024\nCopyright (c) 1988-1995 Sam Leffler\nCopyright (c) 1991-1995 Silicon Graphics, Inc."
diff -urN -xdebian -x.svn ./Makefile /usr/src/openjpeg/trunk/Makefile
--- ./Makefile	2007-12-01 19:18:15.000000000 +0000
+++ /usr/src/openjpeg/trunk/Makefile	2007-11-27 22:41:39.000000000 +0000
@@ -4,7 +4,7 @@
 VER_MINOR = 1.2.0
 
 SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
-INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_includes.h
+INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_malloc.h ./libopenjpeg/opj_includes.h 
 INCLUDE = -Ilibopenjpeg
 
 # General configuration variables:
@@ -18,7 +18,7 @@
 # Converts cr/lf to just lf
 DOS2UNIX = dos2unix
 
-COMPILERFLAGS = -O3 -fPIC
+COMPILERFLAGS = -Wall -O3 -ffast-math -std=c99 -fPIC
 LIBRARIES = -lstdc++
 
 MODULES = $(SRCS:.c=.o)
diff -urN -xdebian -x.svn ./mj2/CMakeLists.txt /usr/src/openjpeg/trunk/mj2/CMakeLists.txt
--- ./mj2/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/CMakeLists.txt	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,42 @@
+# Makefile for the MJ2 codecs of the OpenJPEG library: frames_to_mj2, mj2_to_frames, extract_j2k_from_mj2 and wrap_j2k_in_mj2
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+ADD_EXECUTABLE(frames_to_mj2
+  frames_to_mj2.c
+  compat/getopt.c 
+  mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(frames_to_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(frames_to_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(mj2_to_frames
+    mj2_to_frames.c
+    compat/getopt.c mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(mj2_to_frames ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(mj2_to_frames m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(extract_j2k_from_mj2
+    extract_j2k_from_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(wrap_j2k_in_mj2
+    wrap_j2k_in_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 m)
+ENDIF(UNIX)
+
+INSTALL(TARGETS frames_to_mj2 mj2_to_frames extract_j2k_from_mj2 wrap_j2k_in_mj2
+	DESTINATION bin)
diff -urN -xdebian -x.svn ./mj2/extract_j2k_from_mj2.c /usr/src/openjpeg/trunk/mj2/extract_j2k_from_mj2.c
--- ./mj2/extract_j2k_from_mj2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/extract_j2k_from_mj2.c	2007-11-27 22:39:49.000000000 +0000
@@ -26,7 +26,13 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
 #include "mj2.h"
 
 /* -------------------------------------------------------------------------- */
diff -urN -xdebian -x.svn ./mj2/frames_to_mj2.c /usr/src/openjpeg/trunk/mj2/frames_to_mj2.c
--- ./mj2/frames_to_mj2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/frames_to_mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -25,7 +25,15 @@
 * POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
 #include "mj2.h"
 #include "mj2_convert.h"
 #include "compat/getopt.h"
@@ -78,13 +86,6 @@
   fprintf
     (stdout,"COD and QCD never appear in the tile_header.\n");
   fprintf(stdout,"\n");
-  fprintf
-    (stdout,"- This coder can encode a mega image, a test was made on a 24000x24000 pixels \n");
-  fprintf
-    (stdout,"color image.  You need enough disk space memory (twice the original) to encode \n");
-  fprintf
-    (stdout,"the image,i.e. for a 1.5 GB image you need a minimum of 3GB of disk memory)\n");
-  fprintf(stdout,"\n");
   fprintf(stdout,"By default:\n");
   fprintf(stdout,"------------\n");
   fprintf(stdout,"\n");
@@ -149,8 +150,6 @@
   fprintf
     (stdout,"                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
   fprintf
-    (stdout,"-x           : create an index file *.Idx (-x index_name.Idx) \n");
-  fprintf
     (stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
   fprintf
     (stdout,"               for component c=%%d [%%d = 0,1,2]\n");
@@ -248,7 +247,7 @@
 	opj_cinfo_t* cinfo;
   bool bSuccess;
 	int numframes;
-	double total_time = 0;
+	double total_time = 0;	
 
   /* default value */
   /* ------------- */
@@ -258,8 +257,7 @@
   mj2_parameters.h = 288;			// CIF default value
   mj2_parameters.CbCr_subsampling_dx = 2;	// CIF default value
   mj2_parameters.CbCr_subsampling_dy = 2;	// CIF default value
-  mj2_parameters.frame_rate = 25;
-  
+  mj2_parameters.frame_rate = 25;	  
 	/*
 	configure the event callbacks (not required)
 	setting of each callback is optionnal
@@ -282,10 +280,12 @@
 		sprintf(j2k_parameters->cp_comment,"%s%s", comment, version);
 	}
 
+	mj2_parameters.decod_format = 0;
+	mj2_parameters.cod_format = 0;
 
   while (1) {
     int c = getopt(argc, argv,
-      "i:o:r:q:f:t:n:c:b:x:p:s:d:h P:S:E:M:R:T:C:I:W:F:");
+      "i:o:r:q:f:t:n:c:b:p:s:d:h P:S:E:M:R:T:C:I:W:F:");
     if (c == -1)
       break;
     switch (c) {
@@ -468,14 +468,6 @@
 			}
 			break;
       /* ----------------------------------------------------- */
-    case 'x':			/* creation of index file */
-      {
-				char *index = optarg;
-				strncpy(j2k_parameters->index, index, sizeof(j2k_parameters->index)-1);
-				j2k_parameters->index_on = 1;
-			}
-			break;
-      /* ----------------------------------------------------- */
     case 'p':			/* progression order */
 			{
 				char progression[4];
@@ -617,7 +609,7 @@
     
   /* Error messages */
   /* -------------- */
-  if (!mj2_parameters.infile || !mj2_parameters.outfile) {
+	if (!mj2_parameters.cod_format || !mj2_parameters.decod_format) {
     fprintf(stderr,
       "Correct usage: mj2_encoder -i yuv-file -o mj2-file (+ options)\n");
     return 1;
@@ -688,8 +680,8 @@
 	mj2_setup_encoder(movie, &mj2_parameters);   
   
   movie->tk[0].num_samples = yuv_num_frames(&movie->tk[0],mj2_parameters.infile); 
-  if (!movie->tk[0].num_samples) {
-    fprintf(stderr,"Unable to count the number of frames in YUV input file\n");
+  if (movie->tk[0].num_samples == -1) {
+		return 1;
   }
   
   // One sample per chunk
@@ -712,8 +704,9 @@
   cio_write(cio, MJ2_MDAT, 4);	
   fwrite(buf,cio_tell(cio),1,mj2file);
   offset = cio_tell(cio);
-  opj_free(buf);
-  
+  opj_cio_close(cio);
+  free(buf);
+
   for (i = 0; i < movie->num_stk + movie->num_htk + movie->num_vtk; i++) {
     if (movie->tk[i].track_type != 0) {
       fprintf(stderr, "Unable to write sound or hint tracks\n");
@@ -734,7 +727,7 @@
       for (sampleno = 0; sampleno < numframes; sampleno++) {		
 				double init_time = opj_clock();
 				double elapsed_time;
-				if (!yuvtoimage(tk, img, sampleno, j2k_parameters, mj2_parameters.infile)) {
+				if (yuvtoimage(tk, img, sampleno, j2k_parameters, mj2_parameters.infile)) {
 					fprintf(stderr, "Error with frame number %d in YUV file\n", sampleno);
 					return 1;
 				}
@@ -748,7 +741,7 @@
 				cio_write(cio, JP2_JP2C, 4);	// JP2C
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, img, j2k_parameters->index);
+				bSuccess = opj_encode(cinfo, cio, img, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -758,6 +751,7 @@
 				len = cio_tell(cio) - 8;
 				cio_seek(cio, 0);
 				cio_write(cio, len+8,4);
+				opj_cio_close(cio);
 				tk->sample[sampleno].sample_size = len+8;				
 				tk->sample[sampleno].offset = offset;
 				tk->chunk[sampleno].offset = offset;	// There is one sample per chunk 
@@ -769,7 +763,7 @@
 
       }
 			/* free buffer data */
-			opj_free(buf);
+			free(buf);
 			/* free image data */
 			opj_image_destroy(img);
     }
@@ -784,13 +778,14 @@
   cio_write(cio, offset - mdat_initpos, 4);
   fwrite(buf, 4, 1, mj2file);
   fseek(mj2file,0,SEEK_END);
-  opj_free(buf);
-  
+  free(buf);
+
   // Writing MOOV box 
 	buf = (char*) malloc ((TEMP_BUF+numframes*20) * sizeof(char));
 	cio = opj_cio_open(movie->cinfo, buf, (TEMP_BUF+numframes*20));
 	mj2_write_moov(movie, cio);
   fwrite(buf,cio_tell(cio),1,mj2file);
+  free(buf);
 
 	fprintf(stdout,"Total encoding time: %.2f s for %d frames (%.1f fps)\n", total_time, numframes, (float)numframes/total_time);
   
Binary files ./mj2/frames_to_mj2.sln and /usr/src/openjpeg/trunk/mj2/frames_to_mj2.sln differ
diff -urN -xdebian -x.svn ./mj2/frames_to_mj2.vcproj /usr/src/openjpeg/trunk/mj2/frames_to_mj2.vcproj
--- ./mj2/frames_to_mj2.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/frames_to_mj2.vcproj	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,406 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="frames_to_mj2"
+	ProjectGUID="{4C7685BB-E216-488C-8675-FF5A54FEDDDD}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/frames_to_mj2.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/frames_to_mj2.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\frames_to_mj2___Win32_Debug0"
+			IntermediateDirectory=".\frames_to_mj2___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pch"
+				AssemblerListingLocation=".\frames_to_mj2___Win32_Debug0/"
+				ObjectFile=".\frames_to_mj2___Win32_Debug0/"
+				ProgramDataBaseFileName=".\frames_to_mj2___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="frames_to_mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Libopenjpeg Header files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./mj2/mj2.c /usr/src/openjpeg/trunk/mj2/mj2.c
--- ./mj2/mj2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -96,9 +96,8 @@
   movie->brand = MJ2_MJ2;
   movie->minversion = 0;
   movie->num_cl = 2;
-  movie->cl =
-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
-	
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
   movie->cl[0] = MJ2_MJ2;
   movie->cl[1] = MJ2_MJ2S;
   time(&ltime);			/* Time since 1/1/70 */
@@ -139,9 +138,7 @@
       tk->same_sample_size = 0;
 			
       tk->num_samplestochunk = 1;	/* One sample per chunk                                      */
-      tk->sampletochunk =
-				(mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
-				sizeof(mj2_sampletochunk_t));
+		tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
       tk->sampletochunk[0].first_chunk = 1;
       tk->sampletochunk[0].samples_per_chunk = 1;
       tk->sampletochunk[0].sample_descr_idx = 1;
@@ -158,7 +155,7 @@
       }
 			
       tk->num_tts = 1;
-      tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
+		tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
       tk->tts[0].sample_count = tk->num_samples;
       tk->tts[0].sample_delta = tk->timescale / tk->sample_rate;
 			
@@ -196,7 +193,7 @@
       tk->or_fieldcount = 1;
       tk->or_fieldorder = 0;
       tk->num_br = 2;
-      tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
+		tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
       tk->br[0] = MJ2_JP2;
       tk->br[1] = MJ2_J2P0;
       tk->num_jp2x = 0;
@@ -226,10 +223,9 @@
   for (i = 0; i < tk->num_tts; i++) {
     tk->num_samples += tk->tts[i].sample_count;
   }
-	
-  tk->sample =
-    (mj2_sample_t *) malloc(tk->num_samples * sizeof(mj2_sample_t));
-	
+
+  tk->sample = (mj2_sample_t*) opj_malloc(tk->num_samples * sizeof(mj2_sample_t));
+
   for (i = 0; i < tk->num_tts; i++) {
     for (j = 0; j < tk->tts[i].sample_count; j++) {
       tk->sample[j].sample_delta = tk->tts[i].sample_delta;
@@ -251,15 +247,13 @@
     tk->num_chunks =
       (unsigned int) ceil((double) tk->num_samples /
       (double) tk->sampletochunk[0].samples_per_chunk);
-    tk->chunk =
-      (mj2_chunk_t *) malloc(tk->num_chunks * sizeof(mj2_chunk_t));
+	 tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_chunks * sizeof(mj2_chunk_t));
     for (k = 0; k < tk->num_chunks; k++) {
       tk->chunk[k].num_samples = tk->sampletochunk[0].samples_per_chunk;
     }
     
   } else {
-    tk->chunk =
-      (mj2_chunk_t *) malloc(tk->num_samples * sizeof(mj2_chunk_t));
+    tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_samples * sizeof(mj2_chunk_t));
     tk->num_chunks = 0;
     for (i = 0; i < tk->num_samplestochunk -1 ; i++) {
       for (j = tk->sampletochunk[i].first_chunk - 1;
@@ -275,7 +269,7 @@
       tk->chunk[k].num_samples =
 				tk->sampletochunk[tk->num_samplestochunk - 1].samples_per_chunk;
     }
-    tk->chunk = realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
+    tk->chunk = opj_realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
   }
   
 }
@@ -396,9 +390,8 @@
   movie->brand = cio_read(cio, 4);	/* BR              */
   movie->minversion = cio_read(cio, 4);	/* MinV            */
   movie->num_cl = (box.length - 16) / 4;
-  movie->cl =
-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
-	
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
   for (i = movie->num_cl - 1; i > -1; i--)
     movie->cl[i] = cio_read(cio, 4);	/* CLi */
 	
@@ -643,12 +636,9 @@
   }
 	
   tk->num_samplestochunk = cio_read(cio, 4);
-	
-  tk->sampletochunk =
-    (mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
-		sizeof(mj2_sampletochunk_t));
-	
-	
+
+  tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
+
   for (i = 0; i < tk->num_samplestochunk; i++) {
     tk->sampletochunk[i].first_chunk = cio_read(cio, 4);
     tk->sampletochunk[i].samples_per_chunk = cio_read(cio, 4);
@@ -725,9 +715,9 @@
   }
 	
   tk->num_tts = cio_read(cio, 4);
-	
-  tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
-	
+
+  tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
+
   for (i = 0; i < tk->num_tts; i++) {
     tk->tts[i].sample_count = cio_read(cio, 4);
     tk->tts[i].sample_delta = cio_read(cio, 4);
@@ -905,8 +895,8 @@
 	
 	
   tk->num_br = (box.length - 12) / 4;
-  tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
-	
+  tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
+
   for (i = 0; i < tk->num_br; i++) {
     tk->br[i] = cio_read(cio, 4);
   }
@@ -964,9 +954,8 @@
 	
 	
   tk->num_jp2x = (box.length - 8);
-  tk->jp2xdata =
-    (unsigned char *) malloc(tk->num_jp2x * sizeof(unsigned char));
-	
+  tk->jp2xdata = (unsigned char*) opj_malloc(tk->num_jp2x * sizeof(unsigned char));
+
   for (i = 0; i < tk->num_jp2x; i++) {
     tk->jp2xdata[i] = cio_read(cio, 1);
   }
@@ -1172,10 +1161,10 @@
 		opj_event_msg(tk->cinfo, EVT_ERROR, "Error reading JP2H Box\n");
     return 1;
   }
-  
-  tk->jp2_struct.comps = (opj_jp2_comps_t *) malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
-  tk->jp2_struct.cl = (int *) malloc(sizeof(int));
-	
+
+  tk->jp2_struct.comps = (opj_jp2_comps_t*) opj_malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
+  tk->jp2_struct.cl = (int*) opj_malloc(sizeof(int));
+
   tk->num_br = 0;
   tk->num_jp2x = 0;
 	
@@ -2046,8 +2035,8 @@
   cio_skip(cio,12);			/* Reserved */
 	
   tk->name_size = box.length - 32;
-	
-  tk->name = (char *) malloc(tk->name_size * sizeof(char));
+
+  tk->name = (char*) opj_malloc(tk->name_size * sizeof(char));
   for (i = 0; i < tk->name_size; i++) {
     tk->name[i] = cio_read(cio, 1);	/* Name */
   }
@@ -2081,7 +2070,7 @@
   cio_write(cio, tk->creation_time, 4);	/* Creation Time */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, modification_time, 4);	/* Modification Time */
 	
@@ -2224,7 +2213,7 @@
   cio_write(cio, 3, 4);		/* Version=0, flags=3 */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  tk->modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  tk->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, tk->creation_time, 4);	/* Creation Time */
 	
@@ -2416,7 +2405,7 @@
   cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  movie->modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  movie->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, movie->creation_time, 4);	/* Creation Time */
 	
@@ -2581,10 +2570,9 @@
 	
   if (mj2_read_mvhd(movie, cio))
     return 1;
-	
-  movie->tk =
-    (mj2_tk_t *) malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
-	
+
+  movie->tk = (mj2_tk_t*) opj_malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
+
   for (i = 0; cio_tell(cio) - box.init_pos < box.length; i++) {
 		mj2_tk_t *tk = &movie->tk[i];
 		tk->cinfo = movie->cinfo;
@@ -2622,8 +2610,8 @@
 	opj_cio_t *cio;
 	
 	/* open a byte stream for reading */	
-	src = (char*) malloc (300 * sizeof(char));	
-	  
+	src = (char*) opj_malloc(300 * sizeof(char));	
+
 	/* Assuming that jp and ftyp markers size do
      not exceed 300 bytes */
   fread(src,300,1, file);  
@@ -2706,7 +2694,7 @@
   }	
 
   fseek(file,foffset,SEEK_SET);
-  src = realloc(src,box.length);
+  src = opj_realloc(src,box.length);
   fsresult = fread(src,box.length,1,file);
   if (fsresult != 1) {
     opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MOOV box\n"); 
@@ -2717,8 +2705,8 @@
   
   if (mj2_read_moov(movie, &img, cio))
     return 1;
-  
-  free(src);
+
+  opj_free(src);
   return 0;
 }
 
@@ -2728,12 +2716,12 @@
 
 opj_dinfo_t* mj2_create_decompress() {
 	opj_mj2_t* mj2;
-	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_malloc(sizeof(opj_dinfo_t));
+	opj_dinfo_t *dinfo = (opj_dinfo_t*) opj_calloc(1, sizeof(opj_dinfo_t));
 	if(!dinfo) return NULL;
 
 	dinfo->is_decompressor = true;	
 
-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
 	dinfo->mj2_handle = mj2;
 	if(mj2) {
 		mj2->cinfo = (opj_common_ptr)dinfo;
@@ -2748,8 +2736,10 @@
 	movie->num_vtk=0;
   movie->num_stk=0;
   movie->num_htk=0;	
+
 	/* setup the J2K decoder parameters */
 	j2k_setup_decoder(movie->cinfo->j2k_handle, &mj2_parameters->j2k_parameters);
+
 }
 
 void mj2_destroy_decompress(opj_mj2_t *movie) {
@@ -2757,9 +2747,8 @@
 		int i;
 		mj2_tk_t *tk=NULL;
 
-		if (movie->cinfo->j2k_handle) {
+		if (movie->cinfo->j2k_handle) 
 			j2k_destroy_compress(movie->j2k);
-		}
 		
 		if (movie->num_cl != 0)
 			opj_free(movie->cl);
@@ -2805,10 +2794,10 @@
 
 opj_cinfo_t* mj2_create_compress() {
 	opj_mj2_t* mj2;
-	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_malloc(sizeof(opj_cinfo_t));
+	opj_cinfo_t *cinfo = (opj_cinfo_t*) opj_calloc(1, sizeof(opj_cinfo_t));
 	if(!cinfo) return NULL;
 
-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
 	cinfo->mj2_handle = mj2;
 	if(mj2) {
 		mj2->cinfo = (opj_common_ptr)cinfo;
@@ -2830,16 +2819,14 @@
 
 		movie->brand = MJ2_MJ2;  // One brand: MJ2
 		movie->num_cl = 2;	  // Two compatible brands: MJ2 and MJ2S
-		movie->cl = (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
+		movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
 		movie->cl[0] = MJ2_MJ2;
 		movie->cl[1] = MJ2_MJ2S;
 		movie->minversion = 0;	  // Minimum version: 0		
 
-		movie->tk = (mj2_tk_t*) malloc (sizeof(mj2_tk_t)); //Memory allocation for the video track
-		movie->tk[0].sample = (mj2_sample_t*) malloc (sizeof(mj2_sample_t));
-		movie->tk[0].chunk = (mj2_chunk_t *) malloc(sizeof(mj2_chunk_t));  
-		movie->tk[0].track_type = 0;	  // Video track
+		movie->tk = (mj2_tk_t*) opj_malloc(sizeof(mj2_tk_t)); //Memory allocation for the video track
 		movie->tk[0].track_ID = 1;	  // Track ID = 1 
+		movie->tk[0].track_type = 0;	  // Video track
 		movie->tk[0].Dim[0] = parameters->Dim[0];
 		movie->tk[0].Dim[1] = parameters->Dim[1];
 		movie->tk[0].w = parameters->w;
@@ -2847,17 +2834,19 @@
 		movie->tk[0].CbCr_subsampling_dx = parameters->CbCr_subsampling_dx;
 		movie->tk[0].CbCr_subsampling_dy = parameters->CbCr_subsampling_dy;
 		movie->tk[0].sample_rate = parameters->frame_rate;
-		
+		movie->tk[0].name_size = 0;
+		movie->tk[0].chunk = (mj2_chunk_t*) opj_malloc(sizeof(mj2_chunk_t));  
+		movie->tk[0].sample = (mj2_sample_t*) opj_malloc(sizeof(mj2_sample_t));
+
 		jp2_struct = &movie->tk[0].jp2_struct;
 		jp2_struct->numcomps = 3;	// NC  		
-		jp2_struct->comps =
-			(opj_jp2_comps_t *) malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
+		jp2_struct->comps = (opj_jp2_comps_t*) opj_malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
 		jp2_struct->precedence = 0;   /* PRECEDENCE*/
 		jp2_struct->approx = 0;   /* APPROX*/		
 		jp2_struct->brand = JP2_JP2;	/* BR         */
 		jp2_struct->minversion = 0;	/* MinV       */
 		jp2_struct->numcl = 1;
-		jp2_struct->cl = (unsigned int *) malloc(jp2_struct->numcl * sizeof(int));
+		jp2_struct->cl = (unsigned int*) opj_malloc(jp2_struct->numcl * sizeof(int));
 		jp2_struct->cl[0] = JP2_JP2;	/* CL0 : JP2  */		
 		jp2_struct->C = 7;      /* C : Always 7*/
 		jp2_struct->UnkC = 0;      /* UnkC, colorspace specified in colr box*/
diff -urN -xdebian -x.svn ./mj2/mj2_convert.c /usr/src/openjpeg/trunk/mj2/mj2_convert.c
--- ./mj2/mj2_convert.c	2007-11-29 18:26:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2_convert.c	2007-09-28 11:33:42.000000000 +0100
@@ -46,7 +46,7 @@
   f = fopen(infile,"rb");
   if (!f) {  
     fprintf(stderr, "failed to open %s for reading\n",infile);
-    return 1;
+    return -1;
   }
 	
   frame_size = (int) (tk->w * tk->h * (1.0 + (double) 2 / (double) (tk->CbCr_subsampling_dx * tk->CbCr_subsampling_dy)));	/* Calculate frame size */
@@ -58,7 +58,7 @@
     fprintf(stderr,
 			"YUV does not contains any frame of %d x %d size\n", tk->w,
 			tk->h);
-    return 0;
+    return -1;
   }
 	
   numimages = end_of_f / frame_size;	/* Calculate number of images */
@@ -99,7 +99,7 @@
 	return img;
 }
 
-bool yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile)
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile)
 {
   int i, compno;
   int offset;
@@ -111,8 +111,8 @@
 	
   yuvfile = fopen(infile,"rb");
   if (!yuvfile) {  
-    fprintf(stderr, "failed to open %s for reading\n",parameters->infile);
-    return false;
+    fprintf(stderr, "failed to open %s for readings\n",parameters->infile);
+    return 1;
   }
 
   offset = (int) ((double) (frame_num * tk->w * tk->h) * (1.0 +
@@ -125,7 +125,7 @@
     fprintf(stderr, "Cannot reach frame number %d in yuv file !!\n",
 			frame_num);
 		fclose(yuvfile);
-    return false;
+    return 1;
   }
 	
   img->x0 = tk->Dim[0];
@@ -140,13 +140,13 @@
 			&& !feof(yuvfile); i++) {
 			if (!fread(&img->comps[compno].data[i], 1, 1, yuvfile)) {
 				fprintf(stderr, "Error reading %s file !!\n", infile);				
-				return false;
+				return 1;
 			}
 		}
 	}
 	fclose(yuvfile);
 	
-  return true;
+  return 0;
 }
 
 
diff -urN -xdebian -x.svn ./mj2/mj2_convert.h /usr/src/openjpeg/trunk/mj2/mj2_convert.h
--- ./mj2/mj2_convert.h	2007-11-29 18:26:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2_convert.h	2007-09-28 11:33:42.000000000 +0100
@@ -37,7 +37,7 @@
 
 opj_image_t *mj2_image_create(mj2_tk_t * tk, opj_cparameters_t *parameters);
 
-bool yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile);
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile);
 
 int yuv_num_frames(mj2_tk_t * tk, char *infile);
 
diff -urN -xdebian -x.svn ./mj2/MJ2_Extractor.sln /usr/src/openjpeg/trunk/mj2/MJ2_Extractor.sln
--- ./mj2/MJ2_Extractor.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/MJ2_Extractor.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Extractor", "MJ2_Extractor.vcproj", "{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.Build.0 = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.ActiveCfg = Release|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./mj2/MJ2_Extractor.vcproj /usr/src/openjpeg/trunk/mj2/MJ2_Extractor.vcproj
--- ./mj2/MJ2_Extractor.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/MJ2_Extractor.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,354 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Extractor"
+	ProjectGUID="{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/MJ2_Extractor.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Extractor___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Extractor___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\MJ2_Extractor___Win32_Debug/"
+				ObjectFile=".\MJ2_Extractor___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Extractor___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="extract_j2k_from_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./mj2/mj2.h /usr/src/openjpeg/trunk/mj2/mj2.h
--- ./mj2/mj2.h	2007-11-29 18:26:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2.h	2007-09-28 11:33:42.000000000 +0100
@@ -80,13 +80,13 @@
 Decompressed format used in parameters
 YUV = 0
 */
-#define YUV_DFMT 0 
+#define YUV_DFMT 1 
 
 /**
 Compressed format used in parameters
 MJ2 = 0
 */
-#define MJ2_CFMT 0
+#define MJ2_CFMT 2
 
 
 /* ----------------------------------------------------------------------- */
diff -urN -xdebian -x.svn ./mj2/mj2_to_frames.c /usr/src/openjpeg/trunk/mj2/mj2_to_frames.c
--- ./mj2/mj2_to_frames.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2_to_frames.c	2007-11-27 22:39:50.000000000 +0000
@@ -25,7 +25,14 @@
 * POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
 #include "mj2.h"
 #include "mj2_convert.h"
 
@@ -145,6 +152,7 @@
   {
 		double init_time = opj_clock();
 		double elapsed_time;
+
     sample = &track->sample[snum];
 		if (sample->sample_size-8 > max_codstrm_size) {
 			max_codstrm_size =  sample->sample_size-8;
@@ -203,6 +211,7 @@
 	
 	free(frame_codestream);	
   fclose(file);	
+
 	/* free remaining structures */
 	if(dinfo) {
 		mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
diff -urN -xdebian -x.svn ./mj2/mj2_to_frames.sln /usr/src/openjpeg/trunk/mj2/mj2_to_frames.sln
--- ./mj2/mj2_to_frames.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/mj2_to_frames.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_frames", "mj2_to_frames.vcproj", "{64325EAD-A083-4C8E-B852-71006428881D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.Build.0 = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.ActiveCfg = Release|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./mj2/mj2_to_frames.vcproj /usr/src/openjpeg/trunk/mj2/mj2_to_frames.vcproj
--- ./mj2/mj2_to_frames.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/mj2_to_frames.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,324 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="mj2_to_frames"
+	ProjectGUID="{64325EAD-A083-4C8E-B852-71006428881D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_frames___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_frames___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pch"
+				AssemblerListingLocation=".\mj2_to_frames___Win32_Debug0/"
+				ObjectFile=".\mj2_to_frames___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_frames___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib libcmtd.lib"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_frames.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_frames.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_frames.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Headers"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./mj2/mj2_to_metadata.sln /usr/src/openjpeg/trunk/mj2/mj2_to_metadata.sln
--- ./mj2/mj2_to_metadata.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/mj2_to_metadata.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_metadata", "mj2_to_metadata.vcproj", "{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD} = {0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.Build.0 = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.ActiveCfg = Release|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.Build.0 = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.ActiveCfg = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.Build.0 = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.ActiveCfg = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./mj2/mj2_to_metadata.vcproj /usr/src/openjpeg/trunk/mj2/mj2_to_metadata.vcproj
--- ./mj2/mj2_to_metadata.vcproj	2007-11-29 18:26:47.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/mj2_to_metadata.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -1,134 +1,201 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="7.10"
+	Version="8,00"
 	Name="mj2_to_metadata"
-	ProjectGUID="{338C1241-ACB9-469F-98DF-3B9D79ADD1A0}"
-	SccProjectName=""
-	SccLocalPath="">
+	ProjectGUID="{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	>
 	<Platforms>
 		<Platform
-			Name="Win32"/>
+			Name="Win32"
+		/>
 	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
 	<Configurations>
 		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\Release"
-			IntermediateDirectory=".\Release"
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_metadata___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_metadata___Win32_Debug0"
 			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="../libopenjpeg_097"
-				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,DONT_HAVE_GETOPT,NO_PACKETS_DECODING"
-				StringPooling="TRUE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\Release/mj2_to_metadata.pch"
-				AssemblerListingLocation=".\Release/"
-				ObjectFile=".\Release/"
-				ProgramDataBaseFileName=".\Release/"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\mj2_to_metadata___Win32_Debug0/"
+				ObjectFile=".\mj2_to_metadata___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_metadata___Win32_Debug0/"
+				BrowseInformation="1"
 				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="odbc32.lib odbccp32.lib"
-				OutputFile=".\Release/mj2_to_metadata.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				ProgramDatabaseFile=".\Release/mj2_to_metadata.pdb"
-				SubSystem="1"/>
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
 			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/mj2_to_metadata.tlb"/>
+				Name="VCPreLinkEventTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCLinkerTool"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCALinkTool"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCManifestTool"
+			/>
 			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="2057"/>
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.bsc"
+			/>
 			<Tool
-				Name="VCXMLDataGeneratorTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCWebDeploymentTool"/>
+				Name="VCAppVerifierTool"
+			/>
 			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
+				Name="VCWebDeploymentTool"
+			/>
 			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\mj2_to_metadata___Win32_Debug0"
-			IntermediateDirectory=".\mj2_to_metadata___Win32_Debug0"
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
 			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
 			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../libopenjpeg_097"
-				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,DONT_HAVE_GETOPT,NO_PACKETS_DECODING"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="5"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pch"
-				AssemblerListingLocation=".\mj2_to_metadata___Win32_Debug0/"
-				ObjectFile=".\mj2_to_metadata___Win32_Debug0/"
-				ProgramDataBaseFileName=".\mj2_to_metadata___Win32_Debug0/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="0"/>
+				Name="VCPreBuildEventTool"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCCustomBuildTool"
+			/>
 			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="odbc32.lib odbccp32.lib"
-				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="TRUE"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pdb"
-				SubSystem="1"/>
+				Name="VCXMLDataGeneratorTool"
+			/>
 			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.tlb"/>
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="2057"
-				AdditionalIncludeDirectories=""
-				ResourceOutputFileName=""/>
+			/>
 			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
+				Name="VCPreLinkEventTool"
+			/>
 			<Tool
-				Name="VCXMLDataGeneratorTool"/>
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_metadata.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				ProgramDatabaseFile=".\Release/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCWebDeploymentTool"/>
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_metadata.bsc"
+			/>
 			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 	</Configurations>
 	<References>
@@ -136,144 +203,146 @@
 	<Files>
 		<Filter
 			Name="MJ2"
-			Filter="">
-			<File
-				RelativePath=".\compat\getopt.c">
-			</File>
-			<File
-				RelativePath=".\compat\getopt.h">
-			</File>
-			<File
-				RelativePath=".\meta_out.c">
-			</File>
-			<File
-				RelativePath=".\meta_out.h">
-			</File>
-			<File
-				RelativePath=".\mj2.c">
-			</File>
-			<File
-				RelativePath=".\mj2.h">
-			</File>
-			<File
-				RelativePath=".\mj2_convert.c">
-			</File>
-			<File
-				RelativePath=".\mj2_convert.h">
-			</File>
-			<File
-				RelativePath=".\mj2_to_metadata.c">
-			</File>
-			<File
-				RelativePath=".\mj2_to_metadata.h">
-			</File>
-		</Filter>
-		<Filter
-			Name="libopenjpeg_097"
-			Filter="">
-			<File
-				RelativePath="..\libopenjpeg_097\bio.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\bio.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\cio.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\cio.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\dwt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\dwt.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\fix.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\fix.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\int.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\int.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\j2k.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\j2k.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jp2.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jp2.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jpt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jpt.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mct.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mct.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mqc.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mqc.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\openjpeg.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\pi.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\pi.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\raw.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\raw.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t1.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t1.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t2.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t2.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tcd.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tcd.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tgt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tgt.h">
-			</File>
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="meta_out.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="meta_out.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
 		</Filter>
-		<File
-			RelativePath="resource.h">
-		</File>
 	</Files>
 	<Globals>
 	</Globals>
diff -urN -xdebian -x.svn ./mj2/MJ2_Wrapper.sln /usr/src/openjpeg/trunk/mj2/MJ2_Wrapper.sln
--- ./mj2/MJ2_Wrapper.sln	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/MJ2_Wrapper.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Wrapper", "MJ2_Wrapper.vcproj", "{87C98B26-E658-4992-8810-201C3CE67011}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.ActiveCfg = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.Build.0 = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.ActiveCfg = Release|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN -xdebian -x.svn ./mj2/MJ2_Wrapper.vcproj /usr/src/openjpeg/trunk/mj2/MJ2_Wrapper.vcproj
--- ./mj2/MJ2_Wrapper.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/mj2/MJ2_Wrapper.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,353 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Wrapper"
+	ProjectGUID="{87C98B26-E658-4992-8810-201C3CE67011}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/MJ2_Wrapper.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Wrapper___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Wrapper___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\MJ2_Wrapper___Win32_Debug/"
+				ObjectFile=".\MJ2_Wrapper___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Wrapper___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="wrap_j2k_in_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN -xdebian -x.svn ./mj2/wrap_j2k_in_mj2.c /usr/src/openjpeg/trunk/mj2/wrap_j2k_in_mj2.c
--- ./mj2/wrap_j2k_in_mj2.c	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/mj2/wrap_j2k_in_mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -26,9 +26,20 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
 #include "mj2.h"
 
+static int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+
 /**
 Size of memory first allocated for MOOV box
 */
diff -urN -xdebian -x.svn ./OpenJPEG.rc /usr/src/openjpeg/trunk/OpenJPEG.rc
--- ./OpenJPEG.rc	2007-11-29 18:27:40.000000000 +0000
+++ /usr/src/openjpeg/trunk/OpenJPEG.rc	2007-09-28 11:33:52.000000000 +0100
@@ -49,7 +49,7 @@
             VALUE "FileDescription", "OpenJPEG\0"
             VALUE "FileVersion", "1, 1, 0, 0\0"
             VALUE "InternalName", "OpenJPEG\0"
-            VALUE "LegalCopyright", "Copyright © 2002-2006, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium\0"
+            VALUE "LegalCopyright", "Copyright © 2002-2007, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium\0"
             VALUE "LegalTrademarks", "See http://www.openjpeg.org for details\0"
             VALUE "OriginalFilename", "OpenJPEG.dll\0"
             VALUE "PrivateBuild", "\0"
diff -urN -xdebian -x.svn ./OPJViewer/buildupdate.bat /usr/src/openjpeg/trunk/OPJViewer/buildupdate.bat
--- ./OPJViewer/buildupdate.bat	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/OPJViewer/buildupdate.bat	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,15 @@
+::== buildupdate.bat
+@echo off
+setLocal EnableDelayedExpansion
+
+for /f "tokens=2,* delims=^(^) " %%a in ('find /v "" ^< .\source\build.h') do (
+rem echo %%a
+set /A M = %%a + 1
+echo Build %%a done^!
+echo wxT^("!M!"^) > buildtemp283746825t347
+)
+
+if exist buildtemp283746825t347 move /Y buildtemp283746825t347 .\source\build.h
+if exist buildtemp283746825t347 del /F /Q buildtemp283746825t347
+
+::==
\ No newline at end of file
diff -urN -xdebian -x.svn ./OPJViewer/Makefile /usr/src/openjpeg/trunk/OPJViewer/Makefile
--- ./OPJViewer/Makefile	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/Makefile	2007-12-01 18:40:47.000000000 +0000
@@ -1,41 +1,41 @@
-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
-
-# General configuration variables:
-CC = $(shell wx-config-2.8 --cxx)
-AR = ar
-
-CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
-
-OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp
-
-MODULES = $(OPJV_SRCS:.cpp=.o)
-
-all: opjviewer lib
-
-.cpp.o:
-	$(CC) $(CFLAGS) -c $< -o $@
-
-lib:
-	cd ../jpwl; make
-
-opjviewer: $(OPJV_SRCS) lib
-	$(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)  
-
-
-clean:
-	rm -f OPJViewer *.o *.a
-	cd ../libopenjpeg; rm -f *.o
-
-
-
-
-#.cpp.o :
-#	$(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
-
-#all:    $(PROGRAM)
-
-#$(PROGRAM):     $(OBJECTS)
-#	$(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
-
-#clean:
-#	rm -f *.o $(PROGRAM)
+# Makefile for OPJViewer
+
+# General configuration variables:
+CC = $(shell wx-config-2.8 --cxx)
+AR = ar
+
+CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
+
+OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp source/OPJViewer.cpp source/OPJThreads.cpp
+
+MODULES = $(OPJV_SRCS:.cpp=.o)
+
+all: opjviewer lib
+
+.cpp.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+lib:
+	cd ../jpwl; make
+
+opjviewer: $(OPJV_SRCS) lib
+        $(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)
+
+
+clean:
+	rm -f OPJViewer *.o *.a
+	cd ../libopenjpeg; rm -f *.o
+
+
+
+
+#.cpp.o :
+#       $(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
+
+#all:    $(PROGRAM)
+
+#$(PROGRAM):     $(OBJECTS)
+#       $(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
+
+#clean:
+#       rm -f *.o $(PROGRAM)
diff -urN -xdebian -x.svn ./OPJViewer/OPJViewer.dsp /usr/src/openjpeg/trunk/OPJViewer/OPJViewer.dsp
--- ./OPJViewer/OPJViewer.dsp	2007-12-01 19:18:52.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/OPJViewer.dsp	2007-12-01 18:40:47.000000000 +0000
@@ -42,16 +42,21 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "c:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /FR /FD /c
+# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /I "../libopenjpeg" /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /D "USE_MXF" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /D "OPJ_INICONFIG" /FR /FD /c
 # ADD BASE RSC /l 0x410 /d "NDEBUG"
-# ADD RSC /l 0x409 /i "c:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
+# ADD RSC /l 0x409 /i "d:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"c:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
 # SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Desc=Update build number
+PostBuild_Cmds=buildupdate.bat
+# End Special Build Tool
 
 !ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
 
@@ -67,15 +72,15 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "d:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "c:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "c:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
 # ADD BASE RSC /l 0x410 /d "_DEBUG"
-# ADD RSC /l 0x410 /i "d:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
+# ADD RSC /l 0x410 /i "c:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlibd.lib wxregexd.lib wxpngd.lib wxjpegd.lib wxtiffd.lib wxbase28d.lib wxmsw28d_core.lib wxmsw28d_html.lib wxmsw28d_adv.lib LibOpenJPEG_JPWLd.lib /nologo /subsystem:windows /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Debug"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlibd.lib wxregexd.lib wxpngd.lib wxjpegd.lib wxtiffd.lib wxbase28d.lib wxmsw28d_core.lib wxmsw28d_html.lib wxmsw28d_adv.lib LibOpenJPEG_JPWLd.lib /nologo /subsystem:windows /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"c:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Debug"
 # SUBTRACT LINK32 /pdb:none
 
 !ENDIF 
@@ -106,6 +111,26 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\imagmxf.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\index.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJAbout.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJDialogs.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJThreads.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\OPJViewer.cpp
 # End Source File
 # Begin Source File
@@ -126,6 +151,19 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\build.h
+
+!IF  "$(CFG)" == "OPJViewer - Win32 Release"
+
+# PROP Exclude_From_Build 1
+
+!ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\imagj2k.h
 # End Source File
 # Begin Source File
@@ -138,6 +176,14 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\imagmxf.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\index.h
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\OPJViewer.h
 # End Source File
 # End Group
@@ -146,6 +192,50 @@
 # PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
 # Begin Source File
 
+SOURCE=.\source\wx\msw\blank.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\bullseye.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cdrom.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\computer.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cross.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\drive.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\file1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\floppy.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder2.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\hand.cur
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\icon1.xpm
 # End Source File
 # Begin Source File
@@ -166,6 +256,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\wx\msw\magnif1.cur
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\opj_logo.xpm
 # End Source File
 # Begin Source File
@@ -188,6 +282,38 @@
 
 SOURCE=.\source\OPJViewer16.xpm
 # End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pbrush.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pencil.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntleft.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntright.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\removble.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\rightarr.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\roller.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\std.ico
+# End Source File
 # End Group
 # End Target
 # End Project
diff -urN -xdebian -x.svn ./OPJViewer/OPJViewer.iss /usr/src/openjpeg/trunk/OPJViewer/OPJViewer.iss
--- ./OPJViewer/OPJViewer.iss	2007-11-29 18:27:30.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/OPJViewer.iss	2007-09-28 11:33:50.000000000 +0100
@@ -42,3 +42,7 @@
 
 [Run]
 Filename: {app}\OPJViewer.exe; Description: {cm:LaunchProgram,OPJViewer}; Flags: nowait postinstall skipifsilent; WorkingDir: {app}
+
+[Registry]
+Root: HKCU; Subkey: Software\OpenJPEG; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
+Root: HKCU; Subkey: Software\OpenJPEG\OPJViewer; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
diff -urN -xdebian -x.svn ./OPJViewer/Readme.txt /usr/src/openjpeg/trunk/OPJViewer/Readme.txt
--- ./OPJViewer/Readme.txt	2007-11-29 18:27:30.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/Readme.txt	2007-09-28 11:33:50.000000000 +0100
@@ -1,13 +1,8 @@
-===============================================================================
-
+===============================================================================
 	JPEG2000 Visualization Software - OPJViewer
 
-		Version 0.1 alpha
-
-===============================================================================
-
-
-
+		Version 0.3 alpha
+===============================================================================
 
 
 1. Scope
@@ -15,7 +10,7 @@
 
 This document describes the installation and use of the OPJViewer in the framework of OpenJPEG library.
 
-This implementation has been developed using the OpenJPEG library as decoding engine and wxWidgets 2.8.0 as GUI engine.
+This implementation has been developed using the OpenJPEG library as decoding engine and wxWidgets 2.8 as GUI engine.
 
 If you find some bugs or if you have problems using the viewer, please send an e-mail to jpwl@diei.unipg.it
 
@@ -27,7 +22,7 @@
 a) compile from source code
 b) download a precompiled binary.
 
-In order to use option a), it is mandatory to have compiled and built the LibOpenJPEG_JPWL library and the wxWidgets 2.8.0 framework (you have to download it from http://www.wxwidgets.org/ and compile the wx* libraries).
+In order to use option a), it is mandatory to have compiled and built the LibOpenJPEG_JPWL library and the wxWidgets 2.8 framework (you have to download it from http://www.wxwidgets.org/ and compile the wx* libraries).
 
 2.1. Compiling the source code in Windows
 -------------------------------------------
@@ -52,8 +47,7 @@
 3. General information on the viewer
 ====================================
 
-This viewer is conceived to open and display information and image content of J2K, JP2,
-and MJ2 files.
+This viewer is conceived to open and display information and image content of J2K, JP2, and MJ2 files.
 The viewer application interface is divided into three main panels:
 - a browsing pane;
 - a viewing pane;
diff -urN -xdebian -x.svn ./OPJViewer/source/about_htm.h /usr/src/openjpeg/trunk/OPJViewer/source/about_htm.h
--- ./OPJViewer/source/about_htm.h	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/about_htm.h	2007-11-27 22:39:50.000000000 +0000
@@ -1,29 +1,31 @@
 wxString htmlaboutpage = wxT(
 "<html>"
 "<body bgcolor=#FFFFFF>"
-"<table cellspacing=7 cellpadding=1 border=0 width=100%>"
+"<table cellspacing=7 cellpadding=1 border=0 width=100%>"   
 "<tr>"
 "<td rowspan=3 valign=top align=center width=70>"
-"<img src=\"memory:opj_logo.xpm\"><br><br>"
+"<img src=\"memory:opj_logo.xpm\"><br><br>" 
 "</td>"
 "<td align=center>"
-"<font size=+0 color=#000000><b>"
-OPJ_APPLICATION " " OPJ_APPLICATION_VERSION
+"<font size=+0 color=#000000><b>" 
+OPJ_APPLICATION " " OPJ_APPLICATION_VERSION 
 "</b></font><br>"
-"<font size=-1 color=#000000><b>A JPEG 2000 image viewer</b></font><br>"
-"<font size=-2 color=#000000><b>" OPJ_APPLICATION_PLATFORM " version</b></font>"
+"<font size=-1 color=#000000><b>A JPEG 2000 image viewer</b></font><br>"  
+"<font size=-2 color=#000000><b>" OPJ_APPLICATION_PLATFORM " version</b></font>"  
 "</td>"
 "</tr>"
-"<tr height=3 valign=center>"
-"<td valign=center  bgcolor=#cc3300></td>"
+"<tr height=3 valign=center>"  
+"<td valign=center  bgcolor=#cc3300></td>"   
 "</tr>"
 "<tr>"
 "<td align=justify>"
 "<center><font size=+0 color=#000000><a href=\"http://www.openjpeg.org/\">OpenJPEG</a></font></center>"
 "<font size=-1 color=#000000>The OpenJPEG library is an open-source JPEG 2000 codec written in C language. "
 "In addition to the basic codec, various other features are under development.</font><br>"
-"<font size=-2 color=red>* Build: " wxVERSION_STRING ", " __DATE__ ", " __TIME__ "</font><br>"
-)
+"<font size=-2 color=red>* Build: ")
+#include "build.h"
+wxT(", " __DATE__ ", " __TIME__ "</font><br>")
+wxT("<font size=-2 color=red>* " wxVERSION_STRING "</font><br>")
 #ifdef USE_JPWL
 wxT("<font size=-2 color=green>- Compiled with JPWL support</font><br>")
 #endif // USE_JPWL
@@ -33,7 +35,7 @@
 wxT("</td>"
 "</tr>"
 "<tr>"
-"<td colspan=2 bgcolor=#CC3300 height=3 valign=center></td>"
+"<td colspan=2 bgcolor=#CC3300 height=3 valign=center></td>" 
 "</tr>"
 "<tr>"
 "<td colspan=2>"
diff -urN -xdebian -x.svn ./OPJViewer/source/build.h /usr/src/openjpeg/trunk/OPJViewer/source/build.h
--- ./OPJViewer/source/build.h	1970-01-01 01:00:00.000000000 +0100
+++ /usr/src/openjpeg/trunk/OPJViewer/source/build.h	2007-12-01 18:40:47.000000000 +0000
@@ -0,0 +1 @@
+wxT("404") 
diff -urN -xdebian -x.svn ./OPJViewer/source/imagj2k.cpp /usr/src/openjpeg/trunk/OPJViewer/source/imagj2k.cpp
--- ./OPJViewer/source/imagj2k.cpp	2007-12-01 19:19:39.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/imagj2k.cpp	2007-12-01 18:40:47.000000000 +0000
@@ -131,6 +131,7 @@
 	unsigned char *src = NULL;
     unsigned char *ptr;
 	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -188,7 +189,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 #ifndef __WXGTK__ 
 		wxMutexGuiEnter();
@@ -230,18 +231,474 @@
 
 }
 
+#define CINEMA_24_CS 1302083	/* Codestream length for 24fps */
+#define CINEMA_48_CS 651041		/* Codestream length for 48fps */
+#define COMP_24_CS 1041666		/* Maximum size per color component for 2K & 4K @ 24fps */
+#define COMP_48_CS 520833		/* Maximum size per color component for 2K @ 48fps */
+
 // save the j2k codestream
-bool wxJ2KHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )
+bool wxJ2KHandler::SaveFile( wxImage *wimage, wxOutputStream& stream, bool verbose )
 {
+	opj_cparameters_t parameters;	/* compression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *oimage = NULL;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;
+	int codestream_length;
+	bool bSuccess;
+	int i;
+	char indexfilename[OPJ_PATH_LEN] = "";	/* index file name */
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = j2k_error_callback;
+	event_mgr.warning_handler = j2k_warning_callback;
+	event_mgr.info_handler = j2k_info_callback;
+
+	/* set encoding parameters to default values */
+	opj_set_default_encoder_parameters(&parameters);
+
+	/* load parameters */
+	parameters.cp_cinema = OFF;
+
+	/* subsampling */
+	if (sscanf(m_subsampling.ToAscii(), "%d,%d", &(parameters.subsampling_dx), &(parameters.subsampling_dy)) != 2) {
+		wxLogError(wxT("Wrong sub-sampling encoder setting: dx,dy"));
+		return false;
+	}
+
+	/* compression rates */
+	if ((m_rates != wxT("")) && (!m_enablequality)) {
+		const char *s1 = m_rates.ToAscii();
+		wxLogMessage(wxT("rates %s"), s1);
+		while (sscanf(s1, "%f", &(parameters.tcp_rates[parameters.tcp_numlayers])) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s1 && *s1 != ',') {
+				s1++;
+			}
+			if (!*s1)
+				break;
+			s1++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* image quality, dB */
+	if ((m_quality != wxT("")) && (m_enablequality)) {
+		const char *s2 = m_quality.ToAscii();
+		wxLogMessage(wxT("qualities %s"), s2);
+		while (sscanf(s2, "%f", &parameters.tcp_distoratio[parameters.tcp_numlayers]) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s2 && *s2 != ',') {
+				s2++;
+			}
+			if (!*s2)
+				break;
+			s2++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_fixed_quality = 1;
+	}
+
+	/* image origin */
+	if (sscanf(m_origin.ToAscii(), "%d,%d", &parameters.image_offset_x0, &parameters.image_offset_y0) != 2) {
+		wxLogError(wxT("bad coordinate of the image origin: x0,y0"));
+		return false;
+	}
+				
+	/* Create comment for codestream */
+	if(m_enablecomm) {
+		parameters.cp_comment = (char *) malloc(strlen(m_comment.ToAscii()) + 1);
+		if(parameters.cp_comment) {
+			strcpy(parameters.cp_comment, m_comment.ToAscii());
+		}
+	} else {
+		parameters.cp_comment = NULL;
+	}
+
+	/* indexing file */
+	if (m_enableidx) {
+		strncpy(indexfilename, m_index.ToAscii(), OPJ_PATH_LEN);
+		wxLogMessage(wxT("index file is %s"), indexfilename);
+	}
+
+	/* if no rate entered, lossless by default */
+	if (parameters.tcp_numlayers == 0) {
+		parameters.tcp_rates[0] = 0;	/* MOD antonin : losslessbug */
+		parameters.tcp_numlayers++;
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* irreversible transform */
+	parameters.irreversible = (m_irreversible == true) ? 1 : 0;
+
+	/* resolutions */
+	parameters.numresolution = m_resolutions;
+
+	/* codeblocks size */
+	if (m_cbsize != wxT("")) {
+		int cblockw_init = 0, cblockh_init = 0;
+		sscanf(m_cbsize.ToAscii(), "%d,%d", &cblockw_init, &cblockh_init);
+		if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024 || cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+			wxLogError(wxT("!! Size of code_block error !! Restrictions:\n  width*height<=4096\n  4<=width,height<= 1024"));
+			return false;
+		}
+		parameters.cblockw_init = cblockw_init;
+		parameters.cblockh_init = cblockh_init;
+	}
+
+	/* precincts size */
+	if (m_prsize != wxT("")) {
+		char sep;
+		int res_spec = 0;
+		char *s = (char *) m_prsize.c_str();
+		do {
+			sep = 0;
+			sscanf(s, "[%d,%d]%c", &parameters.prcw_init[res_spec], &parameters.prch_init[res_spec], &sep);
+			parameters.csty |= 0x01;
+			res_spec++;
+			s = strpbrk(s, "]") + 2;
+		} while (sep == ',');
+		parameters.res_spec = res_spec;
+	}
+
+	/* tiles */
+	if (m_tsize != wxT("")) {
+		sscanf(m_tsize.ToAscii(), "%d,%d", &parameters.cp_tdx, &parameters.cp_tdy);
+		parameters.tile_size_on = true;
+	}
+
+	/* tile origin */
+	if (sscanf(m_torigin.ToAscii(), "%d,%d", &parameters.cp_tx0, &parameters.cp_ty0) != 2) {
+		wxLogError(wxT("tile offset setting error: X0,Y0"));
+		return false;
+	}
+
+	/* use SOP */
+	if (m_enablesop)
+		parameters.csty |= 0x02;
+
+	/* use EPH */
+	if (m_enableeph)
+		parameters.csty |= 0x04;
+
+	/* multiple component transform */
+	if (m_multicomp)
+		parameters.tcp_mct = 1;
+	else
+		parameters.tcp_mct = 0;
+
+	/* mode switch */
+	parameters.mode = (m_enablebypass ? 1 : 0) + (m_enablereset ? 2 : 0)
+		+ (m_enablerestart ? 4 : 0) + (m_enablevsc ? 8 : 0)
+		+ (m_enableerterm ? 16 : 0) + (m_enablesegmark ? 32 : 0);
+
+	/* progression order */
+	switch (m_progression) {
+
+		/* LRCP */
+	case 0:
+		parameters.prog_order = LRCP;
+		break;
+
+		/* RLCP */
+	case 1:
+		parameters.prog_order = RLCP;
+		break;
+
+		/* RPCL */
+	case 2:
+		parameters.prog_order = RPCL;
+		break;
+
+		/* PCRL */
+	case 3:
+		parameters.prog_order = PCRL;
+		break;
+
+		/* CPRL */
+	case 4:
+		parameters.prog_order = CPRL;
+		break;
+
+		/* DCI2K24 */
+	case 5:
+		parameters.cp_cinema = CINEMA2K_24;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI2K48 */
+	case 6:
+		parameters.cp_cinema = CINEMA2K_48;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI4K */
+	case 7:
+		parameters.cp_cinema = CINEMA4K_24;
+		parameters.cp_rsiz = CINEMA4K;
+		break;
+
+	default:
+		break;
+	}
+
+	/* check cinema */
+	if (parameters.cp_cinema) {
+
+		/* set up */
+		parameters.tile_size_on = false;
+		parameters.cp_tdx=1;
+		parameters.cp_tdy=1;
+		
+		/*Tile part*/
+		parameters.tp_flag = 'C';
+		parameters.tp_on = 1;
+
+		/*Tile and Image shall be at (0,0)*/
+		parameters.cp_tx0 = 0;
+		parameters.cp_ty0 = 0;
+		parameters.image_offset_x0 = 0;
+		parameters.image_offset_y0 = 0;
+
+		/*Codeblock size= 32*32*/
+		parameters.cblockw_init = 32;	
+		parameters.cblockh_init = 32;
+		parameters.csty |= 0x01;
+
+		/*The progression order shall be CPRL*/
+		parameters.prog_order = CPRL;
+
+		/* No ROI */
+		parameters.roi_compno = -1;
+
+		parameters.subsampling_dx = 1;
+		parameters.subsampling_dy = 1;
+
+		/* 9-7 transform */
+		parameters.irreversible = 1;
+
+	}				
+
+	/* convert wx image into opj image */
+	cmptparm = (opj_image_cmptparm_t*) malloc(3 * sizeof(opj_image_cmptparm_t));
+
+	/* initialize opj image components */	
+	memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < 3; i++) {		
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = false;
+		cmptparm[i].dx = parameters.subsampling_dx;
+		cmptparm[i].dy = parameters.subsampling_dy;
+		cmptparm[i].w = wimage->GetWidth();
+		cmptparm[i].h = wimage->GetHeight();
+	}
+
+	/* create the image */
+	oimage = opj_image_create(3, &cmptparm[0], CLRSPC_SRGB);
+	if(!oimage) {
+		if (cmptparm)
+			free(cmptparm);
+		return false;
+	}
+
+	/* set image offset and reference grid */
+	oimage->x0 = parameters.image_offset_x0;
+	oimage->y0 = parameters.image_offset_y0;
+	oimage->x1 = parameters.image_offset_x0 + (wimage->GetWidth() - 1) * 1 + 1;
+	oimage->y1 = parameters.image_offset_y0 + (wimage->GetHeight() - 1) * 1 + 1;
+
+	/* load image data */
+	unsigned char *value = wimage->GetData(); 
+	int area = wimage->GetWidth() * wimage->GetHeight();
+	for (i = 0; i < area; i++) {
+			oimage->comps[0].data[i] = *(value++);
+			oimage->comps[1].data[i] = *(value++);
+			oimage->comps[2].data[i] = *(value++);
+	}
+
+	/* check cinema again */
+	if (parameters.cp_cinema) {
+		int i;
+		float temp_rate;
+		opj_poc_t *POC = NULL;
+
+		switch (parameters.cp_cinema) {
+
+		case CINEMA2K_24:
+		case CINEMA2K_48:
+			if (parameters.numresolution > 6) {
+				parameters.numresolution = 6;
+			}
+			if (!((oimage->comps[0].w == 2048) | (oimage->comps[0].h == 1080))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 2K compliant. JPEG Digital Cinema Profile-3 "
+					"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+		break;
+		
+		case CINEMA4K_24:
+			if (parameters.numresolution < 1) {
+					parameters.numresolution = 1;
+			} else if (parameters.numresolution > 7) {
+					parameters.numresolution = 7;
+			}
+			if (!((oimage->comps[0].w == 4096) | (oimage->comps[0].h == 2160))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 4K compliant. JPEG Digital Cinema Profile-4" 
+					"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+			parameters.POC[0].tile  = 1; 
+			parameters.POC[0].resno0  = 0; 
+			parameters.POC[0].compno0 = 0;
+			parameters.POC[0].layno1  = 1;
+			parameters.POC[0].resno1  = parameters.numresolution - 1;
+			parameters.POC[0].compno1 = 3;
+			parameters.POC[0].prg1 = CPRL;
+			parameters.POC[1].tile  = 1;
+			parameters.POC[1].resno0  = parameters.numresolution - 1; 
+			parameters.POC[1].compno0 = 0;
+			parameters.POC[1].layno1  = 1;
+			parameters.POC[1].resno1  = parameters.numresolution;
+			parameters.POC[1].compno1 = 3;
+			parameters.POC[1].prg1 = CPRL;
+			parameters.numpocs = 2;
+			break;
+		}
+
+		switch (parameters.cp_cinema) {
+		case CINEMA2K_24:
+		case CINEMA4K_24:
+			for (i = 0 ; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_24_CS ) {
+						parameters.tcp_rates[i]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					} else {
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_24_CS;
+			break;
+			
+		case CINEMA2K_48:
+			for (i = 0; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0 ;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate =((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_48_CS ){
+						parameters.tcp_rates[0]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					}else{
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_48_CS;
+			break;
+		}
+
+		parameters.cp_disto_alloc = 1;
+	}
+	
+	/* get a J2K compressor handle */
+	opj_cinfo_t* cinfo = opj_create_compress(CODEC_J2K);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+
+	/* setup the encoder parameters using the current image and user parameters */
+	opj_setup_encoder(cinfo, &parameters, oimage);
+
+	/* open a byte stream for writing */
+	/* allocate memory for all tiles */
+	cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+	/* encode the image */
+	bSuccess = opj_encode_with_info(cinfo, cio, oimage, &cstr_info);
+	if (!bSuccess) {
+
+		opj_cio_close(cio);
+		opj_destroy_compress(cinfo);
+		opj_image_destroy(oimage);
+		if (cmptparm)
+			free(cmptparm);
+		if(parameters.cp_comment)
+			free(parameters.cp_comment);
+		if(parameters.cp_matrice)
+			free(parameters.cp_matrice);
+
 #ifndef __WXGTK__ 
     wxMutexGuiEnter();
 #endif /* __WXGTK__ */
-    wxLogError(wxT("J2K: Couldn't save image -> not implemented."));
+
+		wxLogError(wxT("failed to encode image"));
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+		return false;
+	}
+	codestream_length = cio_tell(cio);
+	wxLogMessage(wxT("Codestream: %d bytes"), codestream_length);
+
+	/* write the buffer to stream */
+	stream.Write(cio->buffer, codestream_length);
+
+	/* close and free the byte stream */
+	opj_cio_close(cio);
+
+	/* Write the index to disk */
+	if (*indexfilename) {
+		if (write_index_file(&cstr_info, indexfilename)) {
+			wxLogError(wxT("Failed to output index file"));
+		}
+	}
+
+	/* free remaining compression structures */
+	opj_destroy_compress(cinfo);
+
+	/* free image data */
+	opj_image_destroy(oimage);
+
+	if (cmptparm)
+		free(cmptparm);
+	if(parameters.cp_comment)
+		free(parameters.cp_comment);
+	if(parameters.cp_matrice)
+		free(parameters.cp_matrice);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+
+    wxLogMessage(wxT("J2K: Image encoded!"));
+
 #ifndef __WXGTK__ 
     wxMutexGuiLeave();
 #endif /* __WXGTK__ */
 
-    return false;
+    return true;
 }
 
 #ifdef __VISUALC__
diff -urN -xdebian -x.svn ./OPJViewer/source/imagj2k.h /usr/src/openjpeg/trunk/OPJViewer/source/imagj2k.h
--- ./OPJViewer/source/imagj2k.h	2007-12-01 19:19:39.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/imagj2k.h	2007-12-01 18:40:47.000000000 +0000
@@ -45,6 +45,7 @@
 
 #include "wx/image.h"
 #include "libopenjpeg/openjpeg.h"
+#include "codec/index.h"
 
 #define wxBITMAP_TYPE_J2K	47
 
@@ -67,6 +68,7 @@
         m_type = wxBITMAP_TYPE_J2K;
         m_mime = wxT("image/j2k");
 
+		/* decoding */
 		m_reducefactor = 0;
 		m_qualitylayers = 0;
 		m_components = 0;
@@ -75,15 +77,97 @@
 		m_expcomps = JPWL_EXPECTED_COMPONENTS;
 		m_maxtiles = JPWL_MAXIMUM_TILES;
 #endif // USE_JPWL
+
+		/* encoding */
+		m_subsampling = wxT("1,1");
+		m_origin = wxT("0,0");
+		m_rates = wxT("20,10,5");
+		m_quality = wxT("30,35,40");
+		m_enablequality = false;
+		m_multicomp = false;
+		m_irreversible = false;
+		m_resolutions = 6;
+		m_progression = 0;
+		m_cbsize = wxT("32,32");
+		m_prsize = wxT("[128,128],[128,128]");
+		m_tsize = wxT("");
+		m_torigin = wxT("0,0");
+		/*m_progression
+		m_resilience*/
+		m_enablesop = false;
+		m_enableeph = false;
+		m_enablereset = false;
+		m_enablesegmark = false;
+		m_enablevsc = false;
+		m_enablerestart = false;
+		m_enableerterm = false;
+		m_enablebypass = false;
+		/*m_roicompo
+		m_roiup
+		m_indexfname*/
+		m_enableidx = false;
+		m_index = wxT("index.txt");
+		m_enablepoc = false;
+		m_poc = wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL");
+		m_enablecomm = true;
+
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+
     }
 
-		// decoding engine parameters
-		int m_reducefactor, m_qualitylayers, m_components;
+	// decoding engine parameters
+	int m_reducefactor, m_qualitylayers, m_components;
 #ifdef USE_JPWL
-		bool m_enablejpwl;
-		int m_expcomps, m_maxtiles;
+	bool m_enablejpwl;
+	int m_expcomps, m_maxtiles;
 #endif // USE_JPWL
 
+	// encoding engine parameters
+	wxString m_subsampling;
+	wxString m_origin;
+	wxString m_rates;
+	wxString m_quality;
+	bool m_enablequality;
+	bool m_multicomp;
+	bool m_irreversible;
+	int m_resolutions;
+	int m_progression;
+	wxString m_cbsize;
+	wxString m_prsize;
+	wxString m_tsize;
+	wxString m_torigin;
+	/*m_progression
+	m_resilience*/
+	bool m_enablesop;
+	bool m_enableeph;
+	bool m_enablebypass;
+	bool m_enableerterm;
+	bool m_enablerestart;
+	bool m_enablereset;
+	bool m_enablesegmark;
+	bool m_enablevsc;
+	/*m_roicompo
+	m_roiup
+	m_indexfname*/
+	bool m_enableidx;
+	wxString m_index;
+	bool m_enablecomm;
+	wxString m_comment;
+	bool m_enablepoc;
+	wxString m_poc;
+
 #if wxUSE_STREAMS
     virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
     virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
@@ -92,6 +176,7 @@
 #endif
 
 private:
+	OPJ_PROG_ORDER give_progression(char progression[4]);
     DECLARE_DYNAMIC_CLASS(wxJ2KHandler)
 };
 
diff -urN -xdebian -x.svn ./OPJViewer/source/imagjp2.cpp /usr/src/openjpeg/trunk/OPJViewer/source/imagjp2.cpp
--- ./OPJViewer/source/imagjp2.cpp	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/imagjp2.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -135,6 +135,7 @@
 	unsigned char *src = NULL;
     unsigned char *ptr;
 	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -193,7 +194,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 #ifndef __WXGTK__ 
 		wxMutexGuiEnter();
diff -urN -xdebian -x.svn ./OPJViewer/source/imagjpeg2000.cpp /usr/src/openjpeg/trunk/OPJViewer/source/imagjpeg2000.cpp
--- ./OPJViewer/source/imagjpeg2000.cpp	2007-11-29 18:27:29.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/imagjpeg2000.cpp	2007-09-28 11:33:50.000000000 +0100
@@ -183,4 +183,4 @@
 	}
 
 
-}
\ No newline at end of file
+}
diff -urN -xdebian -x.svn ./OPJViewer/source/imagmj2.cpp /usr/src/openjpeg/trunk/OPJViewer/source/imagmj2.cpp
--- ./OPJViewer/source/imagmj2.cpp	2007-12-01 19:16:46.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/imagmj2.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -130,10 +130,18 @@
 /* From little endian to big endian, 2 and 4 bytes */
 #define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
 #define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
 #define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
                         ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
 						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
 						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
 
 /* From codestream to int values */
 #define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
@@ -610,6 +618,7 @@
     unsigned char *ptr;
 	int file_length, jp2c_point, jp2h_point;
 	unsigned long int jp2hboxlen, jp2cboxlen;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -691,7 +700,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, my_jPheadSIZE + jp2hboxlen + jp2cboxlen);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 		wxMutexGuiEnter();
 		wxLogError(wxT("MJ2: failed to decode image!"));
diff -urN -xdebian -x.svn ./OPJViewer/source/OPJViewer.cpp /usr/src/openjpeg/trunk/OPJViewer/source/OPJViewer.cpp
--- ./OPJViewer/source/OPJViewer.cpp	2007-12-01 19:19:39.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/OPJViewer.cpp	2007-12-01 18:40:47.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Digital Signal Processing Laboratory, UniversitÃ  degli studi di Perugia (UPG), Italy
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita' degli studi di Perugia (UPG), Italy
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -132,11 +132,11 @@
 // Initialise this in OnInit, not statically
 bool OPJViewerApp::OnInit(void)
 {
+	int n;
 #if wxUSE_UNICODE
 
     wxChar **wxArgv = new wxChar *[argc + 1];
 
-	int n;
     for (n = 0; n < argc; n++ ) {
         wxMB2WXbuf warg = wxConvertMB2WX((char *) argv[n]);
         wxArgv[n] = wxStrdup(warg);
@@ -189,6 +189,9 @@
 #if wxUSE_LIBJPEG
   wxImage::AddHandler( new wxJPEGHandler );
 #endif
+#if USE_MXF
+  wxImage::AddHandler( new wxMXFHandler );
+#endif // USE_MXF
 #if wxUSE_LIBOPENJPEG
   wxImage::AddHandler( new wxJ2KHandler );
   wxImage::AddHandler( new wxJP2Handler );
@@ -207,8 +210,80 @@
 	// memory file system
     wxFileSystem::AddHandler(new wxMemoryFSHandler);
 
+#ifdef OPJ_INICONFIG
+	//load decoding engine parameters
+	OPJconfig = new wxConfig(OPJ_APPLICATION, OPJ_APPLICATION_VENDOR);
+
+	OPJconfig->Read(wxT("decode/enabledeco"), &m_enabledeco, (bool) true);
+	OPJconfig->Read(wxT("decode/enableparse"), &m_enableparse, (bool) true);
+	OPJconfig->Read(wxT("decode/resizemethod"), &m_resizemethod, (long) 0);
+	OPJconfig->Read(wxT("decode/xxxreducefactor"), &m_reducefactor, (long) 0);
+	OPJconfig->Read(wxT("decode/xxxqualitylayers"), &m_qualitylayers, (long) 0);
+	OPJconfig->Read(wxT("decode/xxxcomponents"), &m_components, (long) 0);
+	OPJconfig->Read(wxT("decode/xxxframenum"), &m_framenum, (long) 0);
+#ifdef USE_JPWL
+	OPJconfig->Read(wxT("decode/enablejpwl"), &m_enablejpwl, (bool) true);
+	OPJconfig->Read(wxT("decode/expcomps"), &m_expcomps, (long) JPWL_EXPECTED_COMPONENTS);
+	OPJconfig->Read(wxT("decode/maxtiles"), &m_maxtiles, (long) JPWL_MAXIMUM_TILES);
+#endif // USE_JPWL
+
+	OPJconfig->Write(wxT("teststring"), wxT("This is a test value"));
+	OPJconfig->Write(wxT("testbool"), (bool) true);
+	OPJconfig->Write(wxT("testlong"), (long) 245);
+
+	OPJconfig->Read(wxT("showtoolbar"), &m_showtoolbar, (bool) true);
+	OPJconfig->Read(wxT("showbrowser"), &m_showbrowser, (bool) true);
+	OPJconfig->Read(wxT("showpeeker"), &m_showpeeker, (bool) true);
+	OPJconfig->Read(wxT("browserwidth"), &m_browserwidth, (long) OPJ_BROWSER_WIDTH);
+	OPJconfig->Read(wxT("peekerheight"), &m_peekerheight, (long) OPJ_PEEKER_HEIGHT);
+	OPJconfig->Read(wxT("framewidth"), &m_framewidth, (long) OPJ_FRAME_WIDTH);
+	OPJconfig->Read(wxT("frameheight"), &m_frameheight, (long) OPJ_FRAME_HEIGHT);
+
+	// load encoding engine parameters
+	OPJconfig->Read(wxT("encode/subsampling"), &m_subsampling, (wxString) wxT("1,1"));
+	OPJconfig->Read(wxT("encode/origin"), &m_origin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("encode/rates"), &m_rates, (wxString) wxT("20,10,5"));
+	OPJconfig->Read(wxT("encode/quality"), &m_quality, (wxString) wxT("30,35,40"));
+	OPJconfig->Read(wxT("encode/enablequality"), &m_enablequality, (bool) false);
+	OPJconfig->Read(wxT("encode/multicomp"), &m_multicomp, (bool) false);	
+	OPJconfig->Read(wxT("encode/irreversible"), &m_irreversible, (bool) false);	
+	OPJconfig->Read(wxT("encode/resolutions"), &m_resolutions, (int) 6);	
+	OPJconfig->Read(wxT("encode/progression"), &m_progression, (int) 0);	
+	OPJconfig->Read(wxT("encode/cbsize"), &m_cbsize, (wxString) wxT("32,32"));
+	OPJconfig->Read(wxT("encode/prsize"), &m_prsize, (wxString) wxT("[128,128],[128,128]"));
+	OPJconfig->Read(wxT("encode/tsize"), &m_tsize, (wxString) wxT(""));
+	OPJconfig->Read(wxT("encode/torigin"), &m_torigin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("encode/enablesop"), &m_enablesop, (bool) false);	
+	OPJconfig->Read(wxT("encode/enableeph"), &m_enableeph, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablebypass"), &m_enablebypass, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablereset"), &m_enablereset, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablerestart"), &m_enablerestart, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablevsc"), &m_enablevsc, (bool) false);	
+	OPJconfig->Read(wxT("encode/enableerterm"), &m_enableerterm, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablesegmark"), &m_enablesegmark, (bool) false);	
+	OPJconfig->Read(wxT("encode/enablecomm"), &m_enablecomm, (bool) true);	
+	OPJconfig->Read(wxT("encode/enablepoc"), &m_enablepoc, (bool) false);	
+	OPJconfig->Read(wxT("encode/comment"), &m_comment, (wxString) wxT(""));
+	OPJconfig->Read(wxT("encode/poc"), &m_poc, (wxString) wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL"));
+	OPJconfig->Read(wxT("encode/enableidx"), &m_enableidx, (bool) false);	
+	OPJconfig->Read(wxT("encode/index"), &m_index, (wxString) wxT("index.txt"));
+#ifdef USE_JPWL
+	OPJconfig->Read(wxT("encode/enablejpwl"), &m_enablejpwle, (bool) true);
+	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
+		OPJconfig->Read(wxT("encode/jpwl/hprotsel") + wxString::Format(wxT("%02d"), n), &m_hprotsel[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/htileval") + wxString::Format(wxT("%02d"), n), &m_htileval[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/pprotsel") + wxString::Format(wxT("%02d"), n), &m_pprotsel[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/ptileval") + wxString::Format(wxT("%02d"), n), &m_ptileval[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/ppackval") + wxString::Format(wxT("%02d"), n), &m_ppackval[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/sensisel") + wxString::Format(wxT("%02d"), n), &m_sensisel[n], 0);
+		OPJconfig->Read(wxT("encode/jpwl/stileval") + wxString::Format(wxT("%02d"), n), &m_stileval[n], 0);
+	}
+#endif // USE_JPWL
+
+#else
 	// set decoding engine parameters
 	m_enabledeco = true;
+	m_enableparse = true;
 	m_resizemethod = 0;
 	m_reducefactor = 0;
 	m_qualitylayers = 0;
@@ -219,10 +294,75 @@
 	m_expcomps = JPWL_EXPECTED_COMPONENTS;
 	m_maxtiles = JPWL_MAXIMUM_TILES;
 #endif // USE_JPWL
+	m_showtoolbar = true;
+	m_showbrowser = true;
+	m_showpeeker = true;
+	m_browserwidth = OPJ_BROWSER_WIDTH;
+	m_peekerheight = OPJ_PEEKER_HEIGHT;
+	m_framewidth = OPJ_FRAME_WIDTH;
+	m_frameheight = OPJ_FRAME_HEIGHT;
+
+	// set encoding engine parameters
+	m_subsampling = wxT("1,1");
+	m_origin = wxT("0,0");
+	m_rates = wxT("20,10,5");
+	m_quality = wxT("30,35,40");
+	m_enablequality = false;
+	m_multicomp = false;
+	m_irreversible = false;
+	m_resolutions = 6;
+	m_progression = 0;
+	m_cbsize= wxT("32,32");
+	m_prsize= wxT("[128,128],[128,128]");
+	m_tsize = wxT("");
+	m_torigin = wxT("0,0");
+	m_enablesop = false;
+	m_enableeph = false;
+	m_enablebypass = false;
+	m_enablereset = false;
+	m_enablerestart = false;
+	m_enablevsc = false;
+	m_enableerterm = false;
+	m_enablesegmark = false;
+	m_enableidx = false;
+	m_index = wxT("index.txt");
+	m_enablecomm = true;
+	m_comment = wxT("");
+	m_enablepoc = false;
+	m_poc = wxT("T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL");
+#ifdef USE_JPWL
+	m_enablejpwle = true;
+	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
+		m_hprotsel[n] = 0;
+		m_htileval[n] = 0;
+		m_pprotsel[n] = 0;
+		m_ptileval[n] = 0;
+		m_sensisel[n] = 0;
+		m_stileval[n] = 0;
+	}
+#endif // USE_JPWL
+
+#endif // OPJ_INICONFIG
+
+	if (m_comment == wxT("")) {
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+	}
 
 	// Create the main frame window
   OPJFrame *frame = new OPJFrame(NULL, wxID_ANY, OPJ_APPLICATION_TITLEBAR,
-					  wxDefaultPosition, wxSize(800, 600),
+					  wxDefaultPosition, wxSize(wxGetApp().m_framewidth, wxGetApp().m_frameheight),
                       wxDEFAULT_FRAME_STYLE | wxNO_FULL_REPAINT_ON_RESIZE |
                       wxHSCROLL | wxVSCROLL);
 
@@ -250,6 +390,76 @@
   return true;
 }
 
+int OPJViewerApp::OnExit()
+{
+	int n;
+
+#ifdef OPJ_INICONFIG
+	OPJconfig->Write(wxT("decode/enabledeco"), m_enabledeco);
+	OPJconfig->Write(wxT("decode/enableparse"), m_enableparse);
+	OPJconfig->Write(wxT("decode/resizemethod"), m_resizemethod);
+	OPJconfig->Write(wxT("decode/reducefactor"), m_reducefactor);
+	OPJconfig->Write(wxT("decode/qualitylayers"), m_qualitylayers);
+	OPJconfig->Write(wxT("decode/components"), m_components);
+	OPJconfig->Write(wxT("decode/framenum"), m_framenum);
+#ifdef USE_JPWL
+	OPJconfig->Write(wxT("decode/enablejpwl"), m_enablejpwl);
+	OPJconfig->Write(wxT("decode/expcomps"), m_expcomps);
+	OPJconfig->Write(wxT("decode/maxtiles"), m_maxtiles);
+#endif // USE_JPWL
+	OPJconfig->Write(wxT("showtoolbar"), m_showtoolbar);
+	OPJconfig->Write(wxT("showbrowser"), m_showbrowser);
+	OPJconfig->Write(wxT("showpeeker"), m_showpeeker);
+	OPJconfig->Write(wxT("browserwidth"), m_browserwidth);
+	OPJconfig->Write(wxT("peekerheight"), m_peekerheight);
+	OPJconfig->Write(wxT("framewidth"), m_framewidth);
+	OPJconfig->Write(wxT("frameheight"), m_frameheight);
+
+	OPJconfig->Write(wxT("encode/subsampling"), m_subsampling);
+	OPJconfig->Write(wxT("encode/origin"), m_origin);
+	OPJconfig->Write(wxT("encode/rates"), m_rates);
+	OPJconfig->Write(wxT("encode/quality"), m_quality);
+	OPJconfig->Write(wxT("encode/enablequality"), m_enablequality);
+	OPJconfig->Write(wxT("encode/multicomp"), m_multicomp);
+	OPJconfig->Write(wxT("encode/irreversible"), m_irreversible);
+	OPJconfig->Write(wxT("encode/resolutions"), m_resolutions);
+	OPJconfig->Write(wxT("encode/progression"), m_progression);
+	OPJconfig->Write(wxT("encode/cbsize"), m_cbsize);
+	OPJconfig->Write(wxT("encode/prsize"), m_prsize);
+	OPJconfig->Write(wxT("encode/tiles"), m_tsize);
+	OPJconfig->Write(wxT("encode/torigin"), m_torigin);
+	OPJconfig->Write(wxT("encode/enablesop"), m_enablesop);
+	OPJconfig->Write(wxT("encode/enableeph"), m_enableeph);
+	OPJconfig->Write(wxT("encode/enablebypass"), m_enablebypass);
+	OPJconfig->Write(wxT("encode/enablereset"), m_enablereset);
+	OPJconfig->Write(wxT("encode/enablerestart"), m_enablerestart);
+	OPJconfig->Write(wxT("encode/enablevsc"), m_enablevsc);
+	OPJconfig->Write(wxT("encode/enableerterm"), m_enableerterm);
+	OPJconfig->Write(wxT("encode/enablesegmark"), m_enablesegmark);
+	OPJconfig->Write(wxT("encode/enableidx"), m_enableidx);
+	OPJconfig->Write(wxT("encode/index"), m_index);
+	OPJconfig->Write(wxT("encode/enablecomm"), m_enablecomm);
+	OPJconfig->Write(wxT("encode/comment"), m_comment);
+	OPJconfig->Write(wxT("encode/enablepoc"), m_enablepoc);
+	OPJconfig->Write(wxT("encode/poc"), m_poc);
+#ifdef USE_JPWL
+	OPJconfig->Write(wxT("encode/enablejpwl"), m_enablejpwle);
+	for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
+		OPJconfig->Write(wxT("encode/jpwl/hprotsel") + wxString::Format(wxT("%02d"), n), m_hprotsel[n]);
+		OPJconfig->Write(wxT("encode/jpwl/htileval") + wxString::Format(wxT("%02d"), n), m_htileval[n]);
+		OPJconfig->Write(wxT("encode/jpwl/pprotsel") + wxString::Format(wxT("%02d"), n), m_pprotsel[n]);
+		OPJconfig->Write(wxT("encode/jpwl/ptileval") + wxString::Format(wxT("%02d"), n), m_ptileval[n]);
+		OPJconfig->Write(wxT("encode/jpwl/ppackval") + wxString::Format(wxT("%02d"), n), m_ppackval[n]);
+		OPJconfig->Write(wxT("encode/jpwl/sensisel") + wxString::Format(wxT("%02d"), n), m_sensisel[n]);
+		OPJconfig->Write(wxT("encode/jpwl/stileval") + wxString::Format(wxT("%02d"), n), m_stileval[n]);
+	}
+#endif // USE_JPWL
+
+#endif // OPJ_INICONFIG
+
+	return 1;
+}
+
 void OPJViewerApp::ShowCmdLine(const wxCmdLineParser& parser)
 {
     wxString s = wxT("Command line parsed successfully:\nInput files: ");
@@ -267,14 +477,29 @@
 BEGIN_EVENT_TABLE(OPJFrame, wxMDIParentFrame)
     EVT_MENU(OPJFRAME_HELPABOUT, OPJFrame::OnAbout)
     EVT_MENU(OPJFRAME_FILEOPEN, OPJFrame::OnFileOpen)
+    EVT_MENU(OPJFRAME_FILESAVEAS, OPJFrame::OnFileSaveAs)
+    EVT_MENU(OPJFRAME_MEMORYOPEN, OPJFrame::OnMemoryOpen)
     EVT_SIZE(OPJFrame::OnSize)
     EVT_MENU(OPJFRAME_FILEEXIT, OPJFrame::OnQuit)
     EVT_MENU(OPJFRAME_FILECLOSE, OPJFrame::OnClose)
     EVT_MENU(OPJFRAME_VIEWZOOM, OPJFrame::OnZoom)
     EVT_MENU(OPJFRAME_VIEWFIT, OPJFrame::OnFit)
     EVT_MENU(OPJFRAME_VIEWRELOAD, OPJFrame::OnReload)
+    EVT_MENU(OPJFRAME_VIEWPREVFRAME, OPJFrame::OnPrevFrame)
+    EVT_MENU(OPJFRAME_VIEWHOMEFRAME, OPJFrame::OnHomeFrame)
+    EVT_MENU(OPJFRAME_VIEWNEXTFRAME, OPJFrame::OnNextFrame)
+    EVT_MENU(OPJFRAME_VIEWLESSLAYERS, OPJFrame::OnLessLayers)
+    EVT_MENU(OPJFRAME_VIEWALLLAYERS, OPJFrame::OnAllLayers)
+    EVT_MENU(OPJFRAME_VIEWMORELAYERS, OPJFrame::OnMoreLayers)
+    EVT_MENU(OPJFRAME_VIEWLESSRES, OPJFrame::OnLessRes)
+    EVT_MENU(OPJFRAME_VIEWFULLRES, OPJFrame::OnFullRes)
+    EVT_MENU(OPJFRAME_VIEWMORERES, OPJFrame::OnMoreRes)
+    EVT_MENU(OPJFRAME_VIEWPREVCOMP, OPJFrame::OnPrevComp)
+    EVT_MENU(OPJFRAME_VIEWALLCOMPS, OPJFrame::OnAllComps)
+    EVT_MENU(OPJFRAME_VIEWNEXTCOMP, OPJFrame::OnNextComp)
     EVT_MENU(OPJFRAME_FILETOGGLEB, OPJFrame::OnToggleBrowser)
     EVT_MENU(OPJFRAME_FILETOGGLEP, OPJFrame::OnTogglePeeker)
+    EVT_MENU(OPJFRAME_FILETOGGLET, OPJFrame::OnToggleToolbar)
     EVT_MENU(OPJFRAME_SETSENCO, OPJFrame::OnSetsEnco)
     EVT_MENU(OPJFRAME_SETSDECO, OPJFrame::OnSetsDeco)
     EVT_SASH_DRAGGED_RANGE(OPJFRAME_BROWSEWIN, OPJFRAME_LOGWIN, OPJFrame::OnSashDrag)
@@ -292,14 +517,30 @@
 	file_menu->Append(OPJFRAME_FILEOPEN, wxT("&Open\tCtrl+O"));
 	file_menu->SetHelpString(OPJFRAME_FILEOPEN, wxT("Open one or more files"));
 
+	file_menu->Append(OPJFRAME_MEMORYOPEN, wxT("&Memory\tCtrl+M"));
+	file_menu->SetHelpString(OPJFRAME_MEMORYOPEN, wxT("Open a memory buffer"));
+
+	file_menu->Append(OPJFRAME_FILECLOSE, wxT("&Close\tCtrl+C"));
+	file_menu->SetHelpString(OPJFRAME_FILECLOSE, wxT("Close current image"));
+
+	file_menu->AppendSeparator();
+
+	file_menu->Append(OPJFRAME_FILESAVEAS, wxT("&Save as\tCtrl+S"));
+	file_menu->SetHelpString(OPJFRAME_FILESAVEAS, wxT("Save the current image"));
+	//file_menu->Enable(OPJFRAME_FILESAVEAS, false);
+
+	file_menu->AppendSeparator();
+
 	file_menu->Append(OPJFRAME_FILETOGGLEB, wxT("Toggle &browser\tCtrl+B"));
 	file_menu->SetHelpString(OPJFRAME_FILETOGGLEB, wxT("Toggle the left browsing pane"));
 
 	file_menu->Append(OPJFRAME_FILETOGGLEP, wxT("Toggle &peeker\tCtrl+P"));
 	file_menu->SetHelpString(OPJFRAME_FILETOGGLEP, wxT("Toggle the bottom peeking pane"));
 
-	file_menu->Append(OPJFRAME_FILECLOSE, wxT("&Close\tCtrl+C"));
-	file_menu->SetHelpString(OPJFRAME_FILECLOSE, wxT("Close current image"));
+	file_menu->Append(OPJFRAME_FILETOGGLET, wxT("Toggle &toolbar\tCtrl+T"));
+	file_menu->SetHelpString(OPJFRAME_FILETOGGLET, wxT("Toggle the toolbar"));
+
+	file_menu->AppendSeparator();
 
 	file_menu->Append(OPJFRAME_FILEEXIT, wxT("&Exit\tCtrl+Q"));
 	file_menu->SetHelpString(OPJFRAME_FILEEXIT, wxT("Quit this program"));
@@ -316,6 +557,51 @@
 	view_menu->Append(OPJFRAME_VIEWRELOAD, wxT("&Reload image\tCtrl+R"));
 	view_menu->SetHelpString(OPJFRAME_VIEWRELOAD, wxT("Reload the current image"));
 
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVFRAME, wxT("&Prev frame\tLeft"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVFRAME, wxT("View previous frame"));
+
+	view_menu->Append(OPJFRAME_VIEWHOMEFRAME, wxT("&Start frame\tHome"));
+	view_menu->SetHelpString(OPJFRAME_VIEWHOMEFRAME, wxT("View starting frame"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTFRAME, wxT("&Next frame\tRight"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTFRAME, wxT("View next frame"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSLAYERS, wxT("&Less layers\t-"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSLAYERS, wxT("Remove a layer"));
+
+	view_menu->Append(OPJFRAME_VIEWALLLAYERS, wxT("&All layers\t0"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLLAYERS, wxT("Show all layers"));
+
+	view_menu->Append(OPJFRAME_VIEWMORELAYERS, wxT("&More layers\t+"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORELAYERS, wxT("Add a layer"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSRES, wxT("&Less resolution\t<"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSRES, wxT("Reduce the resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWFULLRES, wxT("&Full resolution\tf"));
+	view_menu->SetHelpString(OPJFRAME_VIEWFULLRES, wxT("Full resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWMORERES, wxT("&More resolution\t>"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORERES, wxT("Increase the resolution"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVCOMP, wxT("&Prev component\tDown"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVCOMP, wxT("View previous component"));
+
+	view_menu->Append(OPJFRAME_VIEWALLCOMPS, wxT("&All components\ta"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLCOMPS, wxT("View all components"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTCOMP, wxT("&Next component\tUp"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTCOMP, wxT("View next component"));
+
+
 	// settings menu and its items
 	wxMenu *sets_menu = new wxMenu;
 
@@ -344,17 +630,97 @@
 	// the status bar
 	CreateStatusBar();
 
+	// the toolbar
+	tool_bar = new wxToolBar(this, OPJFRAME_TOOLBAR,
+								wxDefaultPosition, wxDefaultSize,
+								wxTB_HORIZONTAL | wxNO_BORDER);
+	wxBitmap bmpOpen = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpSaveAs = wxArtProvider::GetBitmap(wxART_FILE_SAVE_AS, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpZoom = wxArtProvider::GetBitmap(wxART_FIND, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpFit = wxArtProvider::GetBitmap(wxART_FIND_AND_REPLACE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpReload = wxArtProvider::GetBitmap(wxART_EXECUTABLE_FILE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpDecosettings = wxArtProvider::GetBitmap(wxART_REPORT_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpEncosettings = wxArtProvider::GetBitmap(wxART_LIST_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpPrevframe = wxArtProvider::GetBitmap(wxART_GO_BACK, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpHomeframe = wxArtProvider::GetBitmap(wxART_GO_HOME, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextframe = wxArtProvider::GetBitmap(wxART_GO_FORWARD, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpLesslayers = bmpPrevframe;
+	wxBitmap bmpAlllayers = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMorelayers = bmpNextframe;
+	wxBitmap bmpLessres = bmpPrevframe;
+	wxBitmap bmpFullres = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMoreres = bmpNextframe;
+	wxBitmap bmpPrevcomp = bmpPrevframe;
+	wxBitmap bmpAllcomps = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextcomp = bmpNextframe;
+
+	tool_bar->AddTool(OPJFRAME_FILEOPEN, bmpOpen, wxT("Open"));
+	tool_bar->AddTool(OPJFRAME_FILESAVEAS, bmpSaveAs, wxT("Save as "));
+	//tool_bar->EnableTool(OPJFRAME_FILESAVEAS, false);
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWZOOM, bmpZoom, wxT("Zoom"));
+	tool_bar->AddTool(OPJFRAME_VIEWFIT, bmpFit, wxT("Zoom to fit"));
+	tool_bar->AddTool(OPJFRAME_VIEWRELOAD, bmpReload, wxT("Reload"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_SETSDECO, bmpDecosettings, wxT("Decoder settings"));
+	tool_bar->AddTool(OPJFRAME_SETSENCO, bmpEncosettings, wxT("Encoder settings"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVFRAME, bmpPrevframe, wxT("Previous frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWHOMEFRAME, bmpHomeframe, wxT("Starting frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTFRAME, bmpNextframe, wxT("Next frame"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSLAYERS, bmpLesslayers, wxT("Remove a layer"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLLAYERS, bmpAlllayers, wxT("Show all layers"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORELAYERS, bmpMorelayers, wxT("Add a layer"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSRES, bmpLessres, wxT("Reduce the resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWFULLRES, bmpFullres, wxT("Full resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORERES, bmpMoreres, wxT("Increase the resolution"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVCOMP, bmpPrevcomp, wxT("Previous component"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLCOMPS, bmpAllcomps, wxT("All components"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTCOMP, bmpNextcomp, wxT("Next component"));
+	tool_bar->Realize();
+	
+	// associate the toolbar with the frame
+	SetToolBar(tool_bar);
+
+	// show the toolbar?
+	if (!wxGetApp().m_showtoolbar)
+		tool_bar->Show(false);
+	else
+		tool_bar->Show(true);
+
 	// the logging window
 	loggingWindow = new wxSashLayoutWindow(this, OPJFRAME_LOGWIN,
-											wxDefaultPosition, wxSize(400, 130),
+											wxDefaultPosition, wxSize(400, wxGetApp().m_peekerheight),
 											wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
 											);
-	loggingWindow->SetDefaultSize(wxSize(1000, 130));
+	loggingWindow->SetDefaultSize(wxSize(1000, wxGetApp().m_peekerheight));
 	loggingWindow->SetOrientation(wxLAYOUT_HORIZONTAL);
 	loggingWindow->SetAlignment(wxLAYOUT_BOTTOM);
 	//loggingWindow->SetBackgroundColour(wxColour(0, 0, 255));
 	loggingWindow->SetSashVisible(wxSASH_TOP, true);
 
+	// show the logging?
+	if (!wxGetApp().m_showpeeker)
+		loggingWindow->Show(false);
+	else
+		loggingWindow->Show(true);
+
 	// create the bottom notebook
 	m_bookCtrlbottom = new wxNotebook(loggingWindow, BOTTOM_NOTEBOOK_ID,
 								wxDefaultPosition, wxDefaultSize,
@@ -385,10 +751,10 @@
 
 	// the browser window
 	markerTreeWindow = new wxSashLayoutWindow(this, OPJFRAME_BROWSEWIN,
-											  wxDefaultPosition, wxSize(300, 30),
+											  wxDefaultPosition, wxSize(wxGetApp().m_browserwidth, 30),
 											  wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
 											  );
-	markerTreeWindow->SetDefaultSize(wxSize(300, 1000));
+	markerTreeWindow->SetDefaultSize(wxSize(wxGetApp().m_browserwidth, 1000));
 	markerTreeWindow->SetOrientation(wxLAYOUT_VERTICAL);
 	markerTreeWindow->SetAlignment(wxLAYOUT_LEFT);
 	//markerTreeWindow->SetBackgroundColour(wxColour(0, 255, 0));
@@ -400,6 +766,12 @@
 								wxDefaultPosition, wxDefaultSize,
 								wxBK_TOP);
 
+	// show the browser?
+	if (!wxGetApp().m_showbrowser)
+		markerTreeWindow->Show(false);
+	else
+		markerTreeWindow->Show(true);
+
 #ifdef __WXMOTIF__
 	// For some reason, we get a memcpy crash in wxLogStream::DoLogStream
 	// on gcc/wxMotif, if we use wxLogTextCtl. Maybe it's just gcc?
@@ -418,6 +790,9 @@
 // this is the frame destructor
 OPJFrame::~OPJFrame(void)
 {
+	// save size settings
+	GetSize(&(wxGetApp().m_framewidth), &(wxGetApp().m_frameheight));
+
 	// delete all possible things
 	delete m_bookCtrl;
 	m_bookCtrl = NULL;
@@ -457,10 +832,52 @@
 
 void OPJFrame::OnSetsEnco(wxCommandEvent& event)
 {
+	int n;
+
     OPJEncoderDialog dialog(this, event.GetId());
 
     if (dialog.ShowModal() == wxID_OK) {
 
+		// load settings
+		wxGetApp().m_subsampling = dialog.m_subsamplingCtrl->GetValue();
+		wxGetApp().m_origin = dialog.m_originCtrl->GetValue();
+		wxGetApp().m_rates = dialog.m_rateCtrl->GetValue();
+		wxGetApp().m_quality = dialog.m_qualityCtrl->GetValue();
+		wxGetApp().m_enablequality = dialog.m_qualityRadio->GetValue();
+		wxGetApp().m_multicomp = dialog.m_mctCheck->GetValue();
+		wxGetApp().m_irreversible = dialog.m_irrevCheck->GetValue();
+		wxGetApp().m_resolutions = dialog.m_resolutionsCtrl->GetValue();
+		wxGetApp().m_cbsize = dialog.m_cbsizeCtrl->GetValue();
+		wxGetApp().m_prsize = dialog.m_prsizeCtrl->GetValue();
+		wxGetApp().m_tsize = dialog.m_tsizeCtrl->GetValue();
+		wxGetApp().m_torigin = dialog.m_toriginCtrl->GetValue();
+		wxGetApp().m_progression = dialog.progressionBox->GetSelection();
+		wxGetApp().m_enablesop = dialog.m_sopCheck->GetValue();
+		wxGetApp().m_enableeph = dialog.m_ephCheck->GetValue();
+		wxGetApp().m_enablebypass = dialog.m_enablebypassCheck->GetValue();
+		wxGetApp().m_enablereset = dialog.m_enableresetCheck->GetValue();
+		wxGetApp().m_enablerestart = dialog.m_enablerestartCheck->GetValue();
+		wxGetApp().m_enablevsc = dialog.m_enablevscCheck->GetValue();
+		wxGetApp().m_enableerterm = dialog.m_enableertermCheck->GetValue();
+		wxGetApp().m_enablesegmark = dialog.m_enablesegmarkCheck->GetValue();
+		wxGetApp().m_enableidx = dialog.m_enableidxCheck->GetValue();
+		wxGetApp().m_index = dialog.m_indexCtrl->GetValue();
+		wxGetApp().m_enablecomm = dialog.m_enablecommCheck->GetValue();
+		wxGetApp().m_comment = dialog.m_commentCtrl->GetValue();
+		wxGetApp().m_enablepoc = dialog.m_enablepocCheck->GetValue();
+		wxGetApp().m_poc = dialog.m_pocCtrl->GetValue();
+#ifdef USE_JPWL
+		wxGetApp().m_enablejpwle = dialog.m_enablejpwlCheck->GetValue();
+		for (n = 0; n < MYJPWL_MAX_NO_TILESPECS; n++) {
+			wxGetApp().m_hprotsel[n] = dialog.m_hprotChoice[n]->GetSelection();
+			wxGetApp().m_htileval[n] = dialog.m_htileCtrl[n]->GetValue();
+			wxGetApp().m_pprotsel[n] = dialog.m_pprotChoice[n]->GetSelection();
+			wxGetApp().m_ptileval[n] = dialog.m_ptileCtrl[n]->GetValue();
+			wxGetApp().m_ppackval[n] = dialog.m_ppackCtrl[n]->GetValue();
+			wxGetApp().m_sensisel[n] = dialog.m_sensiChoice[n]->GetSelection();
+			wxGetApp().m_stileval[n] = dialog.m_stileCtrl[n]->GetValue();
+		}
+#endif // USE_JPWL
 	};
 }
 
@@ -472,7 +889,8 @@
 
 		// load settings
 		wxGetApp().m_enabledeco = dialog.m_enabledecoCheck->GetValue();
-		wxGetApp().m_resizemethod = dialog.m_resizeBox->GetSelection();
+		wxGetApp().m_enableparse = dialog.m_enableparseCheck->GetValue();
+		wxGetApp().m_resizemethod = dialog.m_resizeBox->GetSelection() - 1;
 		wxGetApp().m_reducefactor = dialog.m_reduceCtrl->GetValue();
 		wxGetApp().m_qualitylayers = dialog.m_layerCtrl->GetValue();
 		wxGetApp().m_components = dialog.m_numcompsCtrl->GetValue();
@@ -548,16 +966,23 @@
 void OPJFrame::Rescale(int zooml, OPJChildFrame *currframe)
 {
 	wxImage new_image = currframe->m_canvas->m_image100.ConvertToImage();
+
+	// resizing enabled?
+	if (wxGetApp().m_resizemethod == -1) {
+		zooml = 100;
+	}
+
 	if (zooml != 100)
 		new_image.Rescale((int) ((double) zooml * (double) new_image.GetWidth() / 100.0),
 			(int) ((double) zooml * (double) new_image.GetHeight() / 100.0),
 			wxGetApp().m_resizemethod ? wxIMAGE_QUALITY_HIGH : wxIMAGE_QUALITY_NORMAL);
-    currframe->m_canvas->m_image = wxBitmap(new_image);
+	currframe->m_canvas->m_image = wxBitmap(new_image);
 	currframe->m_canvas->SetScrollbars(20,
 										20,
 										(int)(0.5 + (double) new_image.GetWidth() / 20.0),
 										(int)(0.5 + (double) new_image.GetHeight() / 20.0)
 										);
+
 	currframe->m_canvas->Refresh();
 
 	// update zoom
@@ -569,75 +994,119 @@
 {
 	OPJChildFrame *currframe = (OPJChildFrame *) GetActiveChild();
 
-    OPJDecoThread *dthread = currframe->m_canvas->CreateDecoThread();
+	if (currframe) {
+		OPJDecoThread *dthread = currframe->m_canvas->CreateDecoThread();
 
-    if (dthread->Run() != wxTHREAD_NO_ERROR)
-        wxLogMessage(wxT("Can't start deco thread!"));
-    else
-		wxLogMessage(wxT("New deco thread started."));
+		if (dthread->Run() != wxTHREAD_NO_ERROR)
+			wxLogMessage(wxT("Can't start deco thread!"));
+		else
+			wxLogMessage(wxT("New deco thread started."));
 
-	currframe->m_canvas->Refresh();
+		currframe->m_canvas->Refresh();
 
-	// update zoom
-	//currframe->m_canvas->m_zooml = zooml;
+		// update zoom
+		//currframe->m_canvas->m_zooml = zooml;
+	}
+}
+
+void OPJFrame::OnPrevFrame(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_framenum < 0)
+		wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnHomeFrame(wxCommandEvent& event)
+{
+	wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnNextFrame(wxCommandEvent& event)
+{
+	++wxGetApp().m_framenum;
+
+	wxCommandEvent e;
+	OnReload(e);
 }
 
+void OPJFrame::OnLessLayers(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_qualitylayers < 1)
+		wxGetApp().m_qualitylayers = 1;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-// about window for the frame
-void OPJFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+void OPJFrame::OnAllLayers(wxCommandEvent& event)
 {
-#ifdef OPJ_HTMLABOUT
-#include "about_htm.h"
-#include "opj_logo.xpm"
+	wxGetApp().m_qualitylayers = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-    wxBoxSizer *topsizer;
-    wxHtmlWindow *html;
-    wxDialog dlg(this, wxID_ANY, wxString(_("About")));
+void OPJFrame::OnMoreLayers(wxCommandEvent& event)
+{
+	++wxGetApp().m_qualitylayers;
 
-    wxMemoryFSHandler::AddFile(wxT("opj_logo.xpm"), wxBitmap(opj_logo), wxBITMAP_TYPE_XPM);
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-    topsizer = new wxBoxSizer(wxVERTICAL);
+void OPJFrame::OnLessRes(wxCommandEvent& event)
+{
+	++wxGetApp().m_reducefactor;
 
-    html = new wxHtmlWindow(&dlg, wxID_ANY, wxDefaultPosition, wxSize(320, 250), wxHW_SCROLLBAR_NEVER);
-    html->SetBorders(0);
-    //html->LoadPage(wxT("about/about.htm"));
-	//html->SetPage("<html><body>Hello, world!</body></html>");
-	html->SetPage(htmlaboutpage);
-    html->SetSize(html->GetInternalRepresentation()->GetWidth(),
-                    html->GetInternalRepresentation()->GetHeight());
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-    topsizer->Add(html, 1, wxALL, 10);
+void OPJFrame::OnFullRes(wxCommandEvent& event)
+{
+	wxGetApp().m_reducefactor = 0;
 
-    topsizer->Add(new wxStaticLine(&dlg, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 10);
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-    wxButton *bu1 = new wxButton(&dlg, wxID_OK, wxT("OK"));
-    bu1->SetDefault();
+void OPJFrame::OnMoreRes(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_reducefactor < 0)
+		wxGetApp().m_reducefactor = 0;
 
-    topsizer->Add(bu1, 0, wxALL | wxALIGN_RIGHT, 15);
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-    dlg.SetSizer(topsizer);
-    topsizer->Fit(&dlg);
+void OPJFrame::OnPrevComp(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_components < 1)
+		wxGetApp().m_components = 1;
 
-    dlg.ShowModal();
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-#else
+void OPJFrame::OnAllComps(wxCommandEvent& event)
+{
+	wxGetApp().m_components = 0;
 
-	wxMessageBox(wxString::Format(OPJ_APPLICATION_TITLEBAR
-								  wxT("\n\n")
-								  wxT("Built with %s and OpenJPEG ")
-								  wxT(OPENJPEG_VERSION)
-								  wxT("\non ") wxT(__DATE__) wxT(", ") wxT(__TIME__)
-								  wxT("\nRunning under %s\n\n")
-								  OPJ_APPLICATION_COPYRIGHT,
-								  wxVERSION_STRING,
-								  wxGetOsDescription().c_str()),
-				 wxT("About ") OPJ_APPLICATION_NAME,
-				 wxOK | wxICON_INFORMATION,
-				 this
-				 );
+	wxCommandEvent e;
+	OnReload(e);
+}
 
-#endif
+void OPJFrame::OnNextComp(wxCommandEvent& event)
+{
+	++wxGetApp().m_components;
 
+	wxCommandEvent e;
+	OnReload(e);
 }
 
 void OPJFrame::OnToggleBrowser(wxCommandEvent& WXUNUSED(event))
@@ -649,6 +1118,11 @@
 
     wxLayoutAlgorithm layout;
     layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showbrowser = markerTreeWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
 }
 
 void OPJFrame::OnTogglePeeker(wxCommandEvent& WXUNUSED(event))
@@ -660,10 +1134,33 @@
 
     wxLayoutAlgorithm layout;
     layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showpeeker = loggingWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+}
+
+void OPJFrame::OnToggleToolbar(wxCommandEvent& WXUNUSED(event))
+{
+    if (tool_bar->IsShown())
+        tool_bar->Show(false);
+    else
+        tool_bar->Show(true);
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showtoolbar = tool_bar->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
 }
 
 void OPJFrame::OnSashDrag(wxSashEvent& event)
 {
+	int wid, hei;
+
     if (event.GetDragStatus() == wxSASH_STATUS_OUT_OF_RANGE)
         return;
 
@@ -685,6 +1182,49 @@
 
     // Leaves bits of itself behind sometimes
     GetClientWindow()->Refresh();
+
+	// update dimensions
+	markerTreeWindow->GetSize(&wid, &hei);
+	wxGetApp().m_browserwidth = wid;
+
+	loggingWindow->GetSize(&wid, &hei);
+	wxGetApp().m_peekerheight = hei;
+
+}
+
+// physically save the file
+void OPJFrame::SaveFile(wxArrayString paths, wxArrayString filenames)
+{
+	size_t count = paths.GetCount();
+	wxString msg, s;
+
+	if (wxFile::Exists(paths[0].c_str())) {
+
+		s.Printf(wxT("File %s already exists. Do you want to overwrite it?\n"), filenames[0].c_str());
+		wxMessageDialog dialog3(this, s, _T("File exists"), wxYES_NO);
+		if (dialog3.ShowModal() == wxID_NO)
+			return;
+	}
+
+	/*s.Printf(_T("File %d: %s (%s)\n"), (int)0, paths[0].c_str(), filenames[0].c_str());
+	msg += s;
+
+	wxMessageDialog dialog2(this, msg, _T("Selected files"));
+	dialog2.ShowModal();*/
+
+	if (!GetActiveChild())
+		return;
+
+	((OPJChildFrame *) GetActiveChild())->m_canvas->m_savename = paths[0];
+
+	OPJEncoThread *ethread = ((OPJChildFrame *) GetActiveChild())->m_canvas->CreateEncoThread();
+
+    if (ethread->Run() != wxTHREAD_NO_ERROR)
+        wxLogMessage(wxT("Can't start enco thread!"));
+    else
+		wxLogMessage(wxT("New enco thread started."));
+
+
 }
 
 // physically open the files
@@ -740,6 +1280,9 @@
 #if wxUSE_LIBOPENJPEG
 	wxT("JPEG 2000 files (*.jp2,*.j2k,*.j2c,*.mj2)|*.jp2;*.j2k;*.j2c;*.mj2")
 #endif
+#if USE_MXF
+	wxT("|MXF JPEG 2000 video (*.mxf)|*.mxf")
+#endif // USE_MXF
 #if wxUSE_LIBJPEG
 		wxT("|JPEG files (*.jpg)|*.jpg")
 #endif
@@ -767,6 +1310,51 @@
 
 }
 
+void OPJFrame::OnFileSaveAs(wxCommandEvent& WXUNUSED(event))
+{
+    wxString wildcards =
+#ifdef wxUSE_LIBOPENJPEG
+#ifdef __WXMOTIF__
+	wxT("JPEG 2000 codestream (*.j2k)|*.*j*2*");
+#else
+	wxT("JPEG 2000 codestream (*.j2k)|*.j2k")
+	wxT("|JPEG 2000 file format (*.jp2)|*.jp2");
+#endif
+#endif
+
+    wxFileDialog dialog(this, _T("Save image file"),
+                        wxEmptyString, wxEmptyString, wildcards,
+                        wxFD_SAVE);
+
+    if (dialog.ShowModal() == wxID_OK) {
+        wxArrayString paths, filenames;
+
+        dialog.GetPaths(paths);
+        dialog.GetFilenames(filenames);
+
+		SaveFile(paths, filenames);
+    }
+
+
+}
+
+void OPJFrame::OnMemoryOpen(wxCommandEvent& WXUNUSED(event))
+{
+	// do nothing
+	return;
+	
+	wxTextEntryDialog dialog(this, wxT("Memory HEX address range: start_address-stop_address"),
+							wxT("Decode a memory buffer"),
+							wxT("0x-0x"),
+							wxOK | wxCANCEL | wxCENTRE,
+							wxDefaultPosition);
+
+	if (dialog.ShowModal() == wxID_OK) {
+
+	}
+
+}
+
 BEGIN_EVENT_TABLE(OPJCanvas, wxScrolledWindow)
     EVT_MOUSE_EVENTS(OPJCanvas::OnEvent)
 END_EVENT_TABLE()
@@ -809,6 +1397,19 @@
     return dthread;
 }
 
+OPJEncoThread *OPJCanvas::CreateEncoThread(void)
+{
+    OPJEncoThread *ethread = new OPJEncoThread(this);
+
+    if (ethread->Create() != wxTHREAD_NO_ERROR)
+		wxLogError(wxT("Can't create enco thread!"));
+
+    wxCriticalSectionLocker enter(wxGetApp().m_enco_critsect);
+    wxGetApp().m_enco_threads.Add(ethread);
+
+    return ethread;
+}
+
 #define activeoverlay 0
 // Define the repainting behaviour
 void OPJCanvas::OnDraw(wxDC& dc)
@@ -828,7 +1429,11 @@
 	} else {
 		dc.SetFont(*wxSWISS_FONT);
 		dc.SetPen(*wxBLACK_PEN);
+#ifdef __WXGTK__
+		dc.DrawText(_T("Decoding image, please wait... (press \"Zoom to Fit\" to show the image)"), 40, 50);
+#else
 		dc.DrawText(_T("Decoding image, please wait..."), 40, 50);
+#endif
 	}
 }
 
@@ -954,2016 +1559,22 @@
 	//wxLogMessage(wxT("Lost focus: %d (%x)"), m_winnumber, event.GetWindow());
 }
 
-#if USE_GENERIC_TREECTRL
-BEGIN_EVENT_TABLE(OPJMarkerTree, wxGenericTreeCtrl)
-#else
-BEGIN_EVENT_TABLE(OPJMarkerTree, wxTreeCtrl)
-#endif
-    /*EVT_TREE_BEGIN_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginDrag)
-    EVT_TREE_BEGIN_RDRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginRDrag)
-    EVT_TREE_END_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnEndDrag)*/
-    /*EVT_TREE_BEGIN_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnBeginLabelEdit)
-    EVT_TREE_END_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnEndLabelEdit)*/
-    /*EVT_TREE_DELETE_ITEM(TreeTest_Ctrl, OPJMarkerTree::OnDeleteItem)*/
-#if 0       // there are so many of those that logging them causes flicker
-    /*EVT_TREE_GET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnGetInfo)*/
-#endif
-    /*EVT_TREE_SET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnSetInfo)
-    EVT_TREE_ITEM_EXPANDED(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanded)*/
-    EVT_TREE_ITEM_EXPANDING(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanding)
-    /*EVT_TREE_ITEM_COLLAPSED(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsed)
-    EVT_TREE_ITEM_COLLAPSING(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsing)*/
-
-    EVT_TREE_SEL_CHANGED(TreeTest_Ctrl, OPJMarkerTree::OnSelChanged)
-    /*EVT_TREE_SEL_CHANGING(TreeTest_Ctrl, OPJMarkerTree::OnSelChanging)*/
-    /*EVT_TREE_KEY_DOWN(TreeTest_Ctrl, OPJMarkerTree::OnTreeKeyDown)*/
-    /*EVT_TREE_ITEM_ACTIVATED(TreeTest_Ctrl, OPJMarkerTree::OnItemActivated)*/
-
-    // so many differents ways to handle right mouse button clicks...
-    /*EVT_CONTEXT_MENU(OPJMarkerTree::OnContextMenu)*/
-    // EVT_TREE_ITEM_MENU is the preferred event for creating context menus
-    // on a tree control, because it includes the point of the click or item,
-    // meaning that no additional placement calculations are required.
-    EVT_TREE_ITEM_MENU(TreeTest_Ctrl, OPJMarkerTree::OnItemMenu)
-    /*EVT_TREE_ITEM_RIGHT_CLICK(TreeTest_Ctrl, OPJMarkerTree::OnItemRClick)*/
-
-    /*EVT_RIGHT_DOWN(OPJMarkerTree::OnRMouseDown)
-    EVT_RIGHT_UP(OPJMarkerTree::OnRMouseUp)
-    EVT_RIGHT_DCLICK(OPJMarkerTree::OnRMouseDClick)*/
-END_EVENT_TABLE()
-
-// OPJMarkerTree implementation
-#if USE_GENERIC_TREECTRL
-IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxGenericTreeCtrl)
-#else
-IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxTreeCtrl)
-#endif
-
-OPJMarkerTree::OPJMarkerTree(wxWindow *parent, OPJChildFrame *subframe, wxFileName fname, wxString name, const wxWindowID id,
-           const wxPoint& pos, const wxSize& size, long style)
-          : wxTreeCtrl(parent, id, pos, size, style)
-{
-    m_reverseSort = false;
-	m_fname = fname;
-
-	m_peektextCtrl = ((OPJFrame *) (parent->GetParent()->GetParent()))->m_textCtrlbrowse;
-    CreateImageList();
-
-    // Add some items to the tree
-    //AddTestItemsToTree(5, 5);
-    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
-    wxTreeItemId rootId = AddRoot(name,
-                                  image, image,
-                                  new OPJMarkerData(name));
-
-    OPJParseThread *pthread = CreateParseThread(0x00, subframe);
-    if (pthread->Run() != wxTHREAD_NO_ERROR)
-        wxLogMessage(wxT("Can't start parse thread!"));
-    else
-		wxLogMessage(wxT("New parse thread started."));
-
-	m_childframe = subframe;
-}
-
-void OPJMarkerTree::CreateImageList(int size)
-{
-    if (size == -1) {
-        SetImageList(NULL);
-        return;
-    }
-    if (size == 0)
-        size = m_imageSize;
-    else
-        m_imageSize = size;
-
-    // Make an image list containing small icons
-    wxImageList *images = new wxImageList(size, size, true);
-
-    // should correspond to TreeCtrlIcon_xxx enum
-    wxBusyCursor wait;
-    wxIcon icons[5];
-    icons[0] = wxIcon(icon1_xpm);
-    icons[1] = wxIcon(icon2_xpm);
-    icons[2] = wxIcon(icon3_xpm);
-    icons[3] = wxIcon(icon4_xpm);
-    icons[4] = wxIcon(icon5_xpm);
-
-    int sizeOrig = icons[0].GetWidth();
-    for (size_t i = 0; i < WXSIZEOF(icons); i++) {
-        if (size == sizeOrig) {
-            images->Add(icons[i]);
-        } else {
-            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
-        }
-    }
 
-    AssignImageList(images);
-}
+////////////////////////////////
+// drag and drop 
+////////////////////////////////
 
-#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
-void OPJMarkerTree::CreateButtonsImageList(int size)
+bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
 {
-    if ( size == -1 ) {
-        SetButtonsImageList(NULL);
-        return;
-    }
-
-    // Make an image list containing small icons
-    wxImageList *images = new wxImageList(size, size, true);
-
-    // should correspond to TreeCtrlIcon_xxx enum
-    wxBusyCursor wait;
-    wxIcon icons[4];
-    icons[0] = wxIcon(icon3_xpm);   // closed
-    icons[1] = wxIcon(icon3_xpm);   // closed, selected
-    icons[2] = wxIcon(icon5_xpm);   // open
-    icons[3] = wxIcon(icon5_xpm);   // open, selected
-
-    for ( size_t i = 0; i < WXSIZEOF(icons); i++ ) {
-        int sizeOrig = icons[i].GetWidth();
-        if ( size == sizeOrig ) {
-            images->Add(icons[i]);
-        } else {
-            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
-        }
+    /*size_t nFiles = filenames.GetCount();
+    wxString str;
+    str.Printf( _T("%d files dropped\n"), (int)nFiles);
+    for ( size_t n = 0; n < nFiles; n++ ) {
+        str << filenames[n] << wxT("\n");
     }
+    wxLogMessage(str);*/
+	m_pOwner->OpenFiles(filenames, filenames);
 
-    AssignButtonsImageList(images);
-#else
-void OPJMarkerTree::CreateButtonsImageList(int WXUNUSED(size))
-{
-#endif
+    return true;
 }
 
-void OPJParseThread::LoadFile(wxFileName fname)
-{
-	wxTreeItemId rootid;
-
-	// this is the root node
-	int image = wxGetApp().ShowImages() ? m_tree->TreeCtrlIcon_Folder : -1;
-
-	if (this->m_parentid) {
-		// leaf of a tree
-		rootid = m_parentid;
-		m_tree->SetItemText(rootid, wxT("Parsing..."));
-
-	} else {
-
-		// delete the existing tree hierarchy
-		m_tree->DeleteAllItems();
-
-		// new tree
-		rootid = m_tree->AddRoot(wxT("Parsing..."),
-			image,
-			image,
-			new OPJMarkerData(fname.GetFullPath())
-			);
-		//m_tree->SetItemFont(rootid, *wxITALIC_FONT);
-		m_tree->SetItemBold(rootid);
-	}
-
-	// open the file
-	wxFile m_file(fname.GetFullPath().c_str(), wxFile::read);
-
-	// what is the extension?
-	if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
-
-		// parse the file
-		ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
-
-	} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
-
-		// parse the file
-		if (this->m_parentid) {
-			//WriteText(wxT("Only a subsection of jp2"));
-			OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
-			ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
-			m_tree->Expand(rootid);
-
-		} else
-			// as usual
-			ParseJP2File(&m_file, 0, m_file.Length(), rootid);
-
-	} else {
-
-		// unknown extension
-		WriteText(wxT("Unknown file format!"));
-
-	}
-
-	// this is the root node
-	if (this->m_parentid)
-		m_tree->SetItemText(rootid, wxT("Codestream"));
-	else
-		//m_tree->SetItemText(rootid, wxString::Format(wxT("%s (%d B)"), fname.GetFullName(), m_file.Length()));
-		m_tree->SetItemText(rootid, fname.GetFullName());
-
-	// close the file
-	m_file.Close();
-
-	WriteText(wxT("Parsing finished!"));
-}
-
-/*int OPJMarkerTree::OnCompareItems(const wxTreeItemId& item1,
-                               const wxTreeItemId& item2)
-{
-    if ( m_reverseSort )
-    {
-        // just exchange 1st and 2nd items
-        return wxTreeCtrl::OnCompareItems(item2, item1);
-    }
-    else
-    {
-        return wxTreeCtrl::OnCompareItems(item1, item2);
-    }
-}*/
-
-/*void OPJMarkerTree::AddItemsRecursively(const wxTreeItemId& idParent,
-                                     size_t numChildren,
-                                     size_t depth,
-                                     size_t folder)
-{
-    if ( depth > 0 )
-    {
-        bool hasChildren = depth > 1;
-
-        wxString str;
-        for ( size_t n = 0; n < numChildren; n++ )
-        {
-            // at depth 1 elements won't have any more children
-            if ( hasChildren )
-                str.Printf(wxT("%s child %u"), wxT("Folder"), unsigned(n + 1));
-            else
-                str.Printf(wxT("%s child %u.%u"), wxT("File"), unsigned(folder), unsigned(n + 1));
-
-            // here we pass to AppendItem() normal and selected item images (we
-            // suppose that selected image follows the normal one in the enum)
-            int image, imageSel;
-            if ( wxGetApp().ShowImages() )
-            {
-                image = depth == 1 ? TreeCtrlIcon_File : TreeCtrlIcon_Folder;
-                imageSel = image + 1;
-            }
-            else
-            {
-                image = imageSel = -1;
-            }
-            wxTreeItemId id = AppendItem(idParent, str, image, imageSel,
-                                         new OPJMarkerData(str));
-
-            // and now we also set the expanded one (only for the folders)
-            if ( hasChildren && wxGetApp().ShowImages() )
-            {
-                SetItemImage(id, TreeCtrlIcon_FolderOpened,
-                             wxTreeItemIcon_Expanded);
-            }
-
-            // remember the last child for OnEnsureVisible()
-            if ( !hasChildren && n == numChildren - 1 )
-            {
-                m_lastItem = id;
-            }
-
-            AddItemsRecursively(id, numChildren, depth - 1, n + 1);
-        }
-    }
-    //else: done!
-}*/
-
-/*void OPJMarkerTree::AddTestItemsToTree(size_t numChildren,
-                                    size_t depth)
-{
-    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
-    wxTreeItemId rootId = AddRoot(wxT("Root"),
-                                  image, image,
-                                  new OPJMarkerData(wxT("Root item")));
-    if ( image != -1 )
-    {
-        SetItemImage(rootId, TreeCtrlIcon_FolderOpened, wxTreeItemIcon_Expanded);
-    }
-
-    AddItemsRecursively(rootId, numChildren, depth, 0);
-
-    // set some colours/fonts for testing
-    SetItemFont(rootId, *wxITALIC_FONT);
-
-    wxTreeItemIdValue cookie;
-    wxTreeItemId id = GetFirstChild(rootId, cookie);
-    SetItemTextColour(id, *wxBLUE);
-
-    id = GetNextChild(rootId, cookie);
-    id = GetNextChild(rootId, cookie);
-    SetItemTextColour(id, *wxRED);
-    SetItemBackgroundColour(id, *wxLIGHT_GREY);
-}*/
-
-/*void OPJMarkerTree::GetItemsRecursively(const wxTreeItemId& idParent,
-                                     wxTreeItemIdValue cookie)
-{
-    wxTreeItemId id;
-
-    if ( !cookie )
-        id = GetFirstChild(idParent, cookie);
-    else
-        id = GetNextChild(idParent, cookie);
-
-    if ( !id.IsOk() )
-        return;
-
-    wxString text = GetItemText(id);
-    wxLogMessage(text);
-
-    if (ItemHasChildren(id))
-        GetItemsRecursively(id);
-
-    GetItemsRecursively(idParent, cookie);
-}*/
-
-/*void OPJMarkerTree::DoToggleIcon(const wxTreeItemId& item)
-{
-    int image = (GetItemImage(item) == TreeCtrlIcon_Folder)
-                    ? TreeCtrlIcon_File
-                    : TreeCtrlIcon_Folder;
-    SetItemImage(item, image, wxTreeItemIcon_Normal);
-
-    image = (GetItemImage(item) == TreeCtrlIcon_FolderSelected)
-                    ? TreeCtrlIcon_FileSelected
-                    : TreeCtrlIcon_FolderSelected;
-    SetItemImage(item, image, wxTreeItemIcon_Selected);
-}*/
-
-void OPJMarkerTree::LogEvent(const wxChar *name, const wxTreeEvent& event)
-{
-    wxTreeItemId item = event.GetItem();
-    wxString text;
-    if ( item.IsOk() )
-        text << wxT('"') << GetItemText(item).c_str() << wxT('"');
-    else
-        text = wxT("invalid item");
-    wxLogMessage(wxT("%s(%s)"), name, text.c_str());
-}
-
-OPJParseThread *OPJMarkerTree::CreateParseThread(wxTreeItemId parentid, OPJChildFrame *subframe)
-{
-    OPJParseThread *pthread = new OPJParseThread(this, parentid);
-
-    if (pthread->Create() != wxTHREAD_NO_ERROR)
-		wxLogError(wxT("Can't create parse thread!"));
-
-    wxCriticalSectionLocker enter(wxGetApp().m_parse_critsect);
-    wxGetApp().m_parse_threads.Add(pthread);
-
-    return pthread;
-}
-
-
-/*// avoid repetition
-#define TREE_EVENT_HANDLER(name)                                 \
-void OPJMarkerTree::name(wxTreeEvent& event)                        \
-{                                                                \
-    LogEvent(_T(#name), event);                                  \
-    SetLastItem(wxTreeItemId());                                 \
-    event.Skip();                                                \
-}*/
-
-/*TREE_EVENT_HANDLER(OnBeginRDrag)*/
-/*TREE_EVENT_HANDLER(OnDeleteItem)*/
-/*TREE_EVENT_HANDLER(OnGetInfo)
-TREE_EVENT_HANDLER(OnSetInfo)*/
-/*TREE_EVENT_HANDLER(OnItemExpanded)
-TREE_EVENT_HANDLER(OnItemExpanding)*/
-/*TREE_EVENT_HANDLER(OnItemCollapsed)*/
-/*TREE_EVENT_HANDLER(OnSelChanged)
-TREE_EVENT_HANDLER(OnSelChanging)*/
-
-/*#undef TREE_EVENT_HANDLER*/
-
-void OPJMarkerTree::OnItemExpanding(wxTreeEvent& event)
-{
-	wxTreeItemId item = event.GetItem();
-	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
-	wxString text;
-
-	if (item.IsOk())
-		text << wxT('"') << GetItemText(item).c_str() << wxT('"');
-	else
-		text = wxT("invalid item");
-
-	if (wxStrcmp(data->GetDesc1(), wxT("INFO-CSTREAM")))
-		return;
-
-	wxLogMessage(wxT("Expanding... (%s -> %s, %s, %d, %d)"),
-		text.c_str(), data->GetDesc1(), data->GetDesc2(),
-		data->m_start, data->m_length);
-
-	// the codestream box is being asked for expansion
-	wxTreeItemIdValue cookie;
-	if (!GetFirstChild(item, cookie).IsOk()) {
-		OPJParseThread *pthread = CreateParseThread(item);
-		if (pthread->Run() != wxTHREAD_NO_ERROR)
-			wxLogMessage(wxT("Can't start parse thread!"));
-		else
-			wxLogMessage(wxT("New parse thread started."));
-	}
-}
-
-void OPJMarkerTree::OnSelChanged(wxTreeEvent& event)
-{
-#define BUNCH_LINESIZE	16
-#define BUNCH_NUMLINES	7
-
-	wxTreeItemId item = event.GetItem();
-	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
-	wxString text;
-	int l, c, pos = 0, pre_pos;
-	unsigned char buffer[BUNCH_LINESIZE * BUNCH_NUMLINES];
-
-	m_peektextCtrl->Clear();
-
-	/*text << wxString::Format(wxT("Selected... (%s -> %s, %s, %d, %d)"),
-		text.c_str(), data->GetDesc1(), data->GetDesc2(),
-		data->m_start, data->m_length) << wxT("\n");*/
-
-	// open the file and browse a little
-	wxFile *fp = new wxFile(m_fname.GetFullPath().c_str(), wxFile::read);
-
-	// go to position claimed
-	fp->Seek(data->m_start, wxFromStart);
-
-	// read a bunch
-	int max_read = wxMin(wxFileOffset(WXSIZEOF(buffer)), data->m_length - data->m_start + 1);
-	fp->Read(buffer, max_read);
-
-	// write the file data between start and stop
-	pos = 0;
-	for (l = 0; l < BUNCH_NUMLINES; l++) {
-
-		text << wxString::Format(wxT("%010d:"), data->m_start + pos);
-
-		pre_pos = pos;
-
-		// add hex browsing text
-		for (c = 0; c < BUNCH_LINESIZE; c++) {
-
-			if (!(c % 8))
-				text << wxT(" ");
-
-			if (pos < max_read) {
-				text << wxString::Format(wxT("%02X "), buffer[pos]);
-			} else
-				text << wxT("   ");
-			pos++;
-		}
-
-		text << wxT("    ");
-
-		// add char browsing text
-		for (c = 0; c < BUNCH_LINESIZE; c++) {
-
-			if (pre_pos < max_read) {
-				if ((buffer[pre_pos] == '\n') ||
-					(buffer[pre_pos] == '\t') ||
-					(buffer[pre_pos] == '\0') ||
-					(buffer[pre_pos] == 0x0D) ||
-					(buffer[pre_pos] == 0x0B))
-					buffer[pre_pos] = ' ';
-				text << wxString::Format(wxT("%c."), wxChar(buffer[pre_pos]));
-			} else
-				text << wxT("  ");
-			pre_pos++;
-		}
-
-		text << wxT("\n");
-
-	}
-
-	// close the file
-	fp->Close();
-
-	m_peektextCtrl->WriteText(text);
-}
-
-/*void LogKeyEvent(const wxChar *name, const wxKeyEvent& event)
-{
-    wxString key;
-    long keycode = event.GetKeyCode();
-    {
-        switch ( keycode )
-        {
-            case WXK_BACK: key = wxT("BACK"); break;
-            case WXK_TAB: key = wxT("TAB"); break;
-            case WXK_RETURN: key = wxT("RETURN"); break;
-            case WXK_ESCAPE: key = wxT("ESCAPE"); break;
-            case WXK_SPACE: key = wxT("SPACE"); break;
-            case WXK_DELETE: key = wxT("DELETE"); break;
-            case WXK_START: key = wxT("START"); break;
-            case WXK_LBUTTON: key = wxT("LBUTTON"); break;
-            case WXK_RBUTTON: key = wxT("RBUTTON"); break;
-            case WXK_CANCEL: key = wxT("CANCEL"); break;
-            case WXK_MBUTTON: key = wxT("MBUTTON"); break;
-            case WXK_CLEAR: key = wxT("CLEAR"); break;
-            case WXK_SHIFT: key = wxT("SHIFT"); break;
-            case WXK_ALT: key = wxT("ALT"); break;
-            case WXK_CONTROL: key = wxT("CONTROL"); break;
-            case WXK_MENU: key = wxT("MENU"); break;
-            case WXK_PAUSE: key = wxT("PAUSE"); break;
-            case WXK_CAPITAL: key = wxT("CAPITAL"); break;
-            case WXK_END: key = wxT("END"); break;
-            case WXK_HOME: key = wxT("HOME"); break;
-            case WXK_LEFT: key = wxT("LEFT"); break;
-            case WXK_UP: key = wxT("UP"); break;
-            case WXK_RIGHT: key = wxT("RIGHT"); break;
-            case WXK_DOWN: key = wxT("DOWN"); break;
-            case WXK_SELECT: key = wxT("SELECT"); break;
-            case WXK_PRINT: key = wxT("PRINT"); break;
-            case WXK_EXECUTE: key = wxT("EXECUTE"); break;
-            case WXK_SNAPSHOT: key = wxT("SNAPSHOT"); break;
-            case WXK_INSERT: key = wxT("INSERT"); break;
-            case WXK_HELP: key = wxT("HELP"); break;
-            case WXK_NUMPAD0: key = wxT("NUMPAD0"); break;
-            case WXK_NUMPAD1: key = wxT("NUMPAD1"); break;
-            case WXK_NUMPAD2: key = wxT("NUMPAD2"); break;
-            case WXK_NUMPAD3: key = wxT("NUMPAD3"); break;
-            case WXK_NUMPAD4: key = wxT("NUMPAD4"); break;
-            case WXK_NUMPAD5: key = wxT("NUMPAD5"); break;
-            case WXK_NUMPAD6: key = wxT("NUMPAD6"); break;
-            case WXK_NUMPAD7: key = wxT("NUMPAD7"); break;
-            case WXK_NUMPAD8: key = wxT("NUMPAD8"); break;
-            case WXK_NUMPAD9: key = wxT("NUMPAD9"); break;
-            case WXK_MULTIPLY: key = wxT("MULTIPLY"); break;
-            case WXK_ADD: key = wxT("ADD"); break;
-            case WXK_SEPARATOR: key = wxT("SEPARATOR"); break;
-            case WXK_SUBTRACT: key = wxT("SUBTRACT"); break;
-            case WXK_DECIMAL: key = wxT("DECIMAL"); break;
-            case WXK_DIVIDE: key = wxT("DIVIDE"); break;
-            case WXK_F1: key = wxT("F1"); break;
-            case WXK_F2: key = wxT("F2"); break;
-            case WXK_F3: key = wxT("F3"); break;
-            case WXK_F4: key = wxT("F4"); break;
-            case WXK_F5: key = wxT("F5"); break;
-            case WXK_F6: key = wxT("F6"); break;
-            case WXK_F7: key = wxT("F7"); break;
-            case WXK_F8: key = wxT("F8"); break;
-            case WXK_F9: key = wxT("F9"); break;
-            case WXK_F10: key = wxT("F10"); break;
-            case WXK_F11: key = wxT("F11"); break;
-            case WXK_F12: key = wxT("F12"); break;
-            case WXK_F13: key = wxT("F13"); break;
-            case WXK_F14: key = wxT("F14"); break;
-            case WXK_F15: key = wxT("F15"); break;
-            case WXK_F16: key = wxT("F16"); break;
-            case WXK_F17: key = wxT("F17"); break;
-            case WXK_F18: key = wxT("F18"); break;
-            case WXK_F19: key = wxT("F19"); break;
-            case WXK_F20: key = wxT("F20"); break;
-            case WXK_F21: key = wxT("F21"); break;
-            case WXK_F22: key = wxT("F22"); break;
-            case WXK_F23: key = wxT("F23"); break;
-            case WXK_F24: key = wxT("F24"); break;
-            case WXK_NUMLOCK: key = wxT("NUMLOCK"); break;
-            case WXK_SCROLL: key = wxT("SCROLL"); break;
-            case WXK_PAGEUP: key = wxT("PAGEUP"); break;
-            case WXK_PAGEDOWN: key = wxT("PAGEDOWN"); break;
-            case WXK_NUMPAD_SPACE: key = wxT("NUMPAD_SPACE"); break;
-            case WXK_NUMPAD_TAB: key = wxT("NUMPAD_TAB"); break;
-            case WXK_NUMPAD_ENTER: key = wxT("NUMPAD_ENTER"); break;
-            case WXK_NUMPAD_F1: key = wxT("NUMPAD_F1"); break;
-            case WXK_NUMPAD_F2: key = wxT("NUMPAD_F2"); break;
-            case WXK_NUMPAD_F3: key = wxT("NUMPAD_F3"); break;
-            case WXK_NUMPAD_F4: key = wxT("NUMPAD_F4"); break;
-            case WXK_NUMPAD_HOME: key = wxT("NUMPAD_HOME"); break;
-            case WXK_NUMPAD_LEFT: key = wxT("NUMPAD_LEFT"); break;
-            case WXK_NUMPAD_UP: key = wxT("NUMPAD_UP"); break;
-            case WXK_NUMPAD_RIGHT: key = wxT("NUMPAD_RIGHT"); break;
-            case WXK_NUMPAD_DOWN: key = wxT("NUMPAD_DOWN"); break;
-            case WXK_NUMPAD_PAGEUP: key = wxT("NUMPAD_PAGEUP"); break;
-            case WXK_NUMPAD_PAGEDOWN: key = wxT("NUMPAD_PAGEDOWN"); break;
-            case WXK_NUMPAD_END: key = wxT("NUMPAD_END"); break;
-            case WXK_NUMPAD_BEGIN: key = wxT("NUMPAD_BEGIN"); break;
-            case WXK_NUMPAD_INSERT: key = wxT("NUMPAD_INSERT"); break;
-            case WXK_NUMPAD_DELETE: key = wxT("NUMPAD_DELETE"); break;
-            case WXK_NUMPAD_EQUAL: key = wxT("NUMPAD_EQUAL"); break;
-            case WXK_NUMPAD_MULTIPLY: key = wxT("NUMPAD_MULTIPLY"); break;
-            case WXK_NUMPAD_ADD: key = wxT("NUMPAD_ADD"); break;
-            case WXK_NUMPAD_SEPARATOR: key = wxT("NUMPAD_SEPARATOR"); break;
-            case WXK_NUMPAD_SUBTRACT: key = wxT("NUMPAD_SUBTRACT"); break;
-            case WXK_NUMPAD_DECIMAL: key = wxT("NUMPAD_DECIMAL"); break;
-
-            default:
-            {
-               if ( keycode < 128 && wxIsprint((int)keycode) )
-                   key.Printf(wxT("'%c'"), (char)keycode);
-               else if ( keycode > 0 && keycode < 27 )
-                   key.Printf(_("Ctrl-%c"), wxT('A') + keycode - 1);
-               else
-                   key.Printf(wxT("unknown (%ld)"), keycode);
-            }
-        }
-    }
-
-    wxLogMessage(wxT("%s event: %s (flags = %c%c%c%c)"),
-                  name,
-                  key.c_str(),
-                  event.ControlDown() ? wxT('C') : wxT('-'),
-                  event.AltDown() ? wxT('A') : wxT('-'),
-                  event.ShiftDown() ? wxT('S') : wxT('-'),
-                  event.MetaDown() ? wxT('M') : wxT('-'));
-}
-
-void OPJMarkerTree::OnTreeKeyDown(wxTreeEvent& event)
-{
-    LogKeyEvent(wxT("Tree key down "), event.GetKeyEvent());
-
-    event.Skip();
-}*/
-
-/*void OPJMarkerTree::OnBeginDrag(wxTreeEvent& event)
-{
-    // need to explicitly allow drag
-    if ( event.GetItem() != GetRootItem() )
-    {
-        m_draggedItem = event.GetItem();
-
-        wxLogMessage(wxT("OnBeginDrag: started dragging %s"),
-                     GetItemText(m_draggedItem).c_str());
-
-        event.Allow();
-    }
-    else
-    {
-        wxLogMessage(wxT("OnBeginDrag: this item can't be dragged."));
-    }
-}
-
-void OPJMarkerTree::OnEndDrag(wxTreeEvent& event)
-{
-    wxTreeItemId itemSrc = m_draggedItem,
-                 itemDst = event.GetItem();
-    m_draggedItem = (wxTreeItemId)0l;
-
-    // where to copy the item?
-    if ( itemDst.IsOk() && !ItemHasChildren(itemDst) )
-    {
-        // copy to the parent then
-        itemDst = GetItemParent(itemDst);
-    }
-
-    if ( !itemDst.IsOk() )
-    {
-        wxLogMessage(wxT("OnEndDrag: can't drop here."));
-
-        return;
-    }
-
-    wxString text = GetItemText(itemSrc);
-    wxLogMessage(wxT("OnEndDrag: '%s' copied to '%s'."),
-                 text.c_str(), GetItemText(itemDst).c_str());
-
-    // just do append here - we could also insert it just before/after the item
-    // on which it was dropped, but this requires slightly more work... we also
-    // completely ignore the client data and icon of the old item but could
-    // copy them as well.
-    //
-    // Finally, we only copy one item here but we might copy the entire tree if
-    // we were dragging a folder.
-    int image = wxGetApp().ShowImages() ? TreeCtrlIcon_File : -1;
-    AppendItem(itemDst, text, image);
-}*/
-
-/*void OPJMarkerTree::OnBeginLabelEdit(wxTreeEvent& event)
-{
-    wxLogMessage(wxT("OnBeginLabelEdit"));
-
-    // for testing, prevent this item's label editing
-    wxTreeItemId itemId = event.GetItem();
-    if ( IsTestItem(itemId) )
-    {
-        wxMessageBox(wxT("You can't edit this item."));
-
-        event.Veto();
-    }
-    else if ( itemId == GetRootItem() )
-    {
-        // test that it is possible to change the text of the item being edited
-        SetItemText(itemId, _T("Editing root item"));
-    }
-}
-
-void OPJMarkerTree::OnEndLabelEdit(wxTreeEvent& event)
-{
-    wxLogMessage(wxT("OnEndLabelEdit"));
-
-    // don't allow anything except letters in the labels
-    if ( !event.GetLabel().IsWord() )
-    {
-        wxMessageBox(wxT("The new label should be a single word."));
-
-        event.Veto();
-    }
-}*/
-
-/*void OPJMarkerTree::OnItemCollapsing(wxTreeEvent& event)
-{
-    wxLogMessage(wxT("OnItemCollapsing"));
-
-    // for testing, prevent the user from collapsing the first child folder
-    wxTreeItemId itemId = event.GetItem();
-    if ( IsTestItem(itemId) )
-    {
-        wxMessageBox(wxT("You can't collapse this item."));
-
-        event.Veto();
-    }
-}*/
-
-/*void OPJMarkerTree::OnItemActivated(wxTreeEvent& event)
-{
-    // show some info about this item
-    wxTreeItemId itemId = event.GetItem();
-    OPJMarkerData *item = (OPJMarkerData *)GetItemData(itemId);
-
-    if ( item != NULL )
-    {
-        item->ShowInfo(this);
-    }
-
-    wxLogMessage(wxT("OnItemActivated"));
-}*/
-
-void OPJMarkerTree::OnItemMenu(wxTreeEvent& event)
-{
-    /*wxTreeItemId itemId = event.GetItem();
-    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
-                                         : NULL;
-
-    wxLogMessage(wxT("OnItemMenu for item \"%s\""), item ? item->GetDesc()
-                                                         : _T(""));*/
-
-	//wxLogMessage(wxT("EEEEEEEEEE"));
-
-    //event.Skip();
-}
-
-/*void OPJMarkerTree::OnContextMenu(wxContextMenuEvent& event)
-{
-    wxPoint pt = event.GetPosition();
-    wxTreeItemId item;
-    wxLogMessage(wxT("OnContextMenu at screen coords (%i, %i)"), pt.x, pt.y);
-
-    // check if event was generated by keyboard (MSW-specific?)
-    if ( pt.x == -1 && pt.y == -1 ) //(this is how MSW indicates it)
-    {
-        if ( !HasFlag(wxTR_MULTIPLE) )
-            item = GetSelection();
-
-        // attempt to guess where to show the menu
-        if ( item.IsOk() )
-        {
-            // if an item was clicked, show menu to the right of it
-            wxRect rect;
-            GetBoundingRect(item, rect, true );// only the label
-            pt = wxPoint(rect.GetRight(), rect.GetTop());
-        }
-        else
-        {
-            pt = wxPoint(0, 0);
-        }
-    }
-    else // event was generated by mouse, use supplied coords
-    {
-        pt = ScreenToClient(pt);
-        item = HitTest(pt);
-    }
-
-    ShowMenu(item, pt);
-}*/
-
-/*void OPJMarkerTree::ShowMenu(wxTreeItemId id, const wxPoint& pt)
-{
-    wxString title;
-    if ( id.IsOk() )
-    {
-        title << wxT("Menu for ") << GetItemText(id);
-    }
-    else
-    {
-        title = wxT("Menu for no particular item");
-    }
-
-#if wxUSE_MENUS
-    wxMenu menu(title);
-    menu.Append(TreeTest_About, wxT("&About..."));
-    menu.AppendSeparator();
-    menu.Append(TreeTest_Highlight, wxT("&Highlight item"));
-    menu.Append(TreeTest_Dump, wxT("&Dump"));
-
-    PopupMenu(&menu, pt);
-#endif // wxUSE_MENUS
-}*/
-
-/*void OPJMarkerTree::OnItemRClick(wxTreeEvent& event)
-{
-    wxTreeItemId itemId = event.GetItem();
-    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
-                                         : NULL;
-
-    wxLogMessage(wxT("Item \"%s\" right clicked"), item ? item->GetDesc()
-                                                        : _T(""));
-
-    event.Skip();
-}*/
-
-/*
-void OPJMarkerTree::OnRMouseDown(wxMouseEvent& event)
-{
-    wxLogMessage(wxT("Right mouse button down"));
-
-    event.Skip();
-}
-
-void OPJMarkerTree::OnRMouseUp(wxMouseEvent& event)
-{
-    wxLogMessage(wxT("Right mouse button up"));
-
-    event.Skip();
-}
-
-void OPJMarkerTree::OnRMouseDClick(wxMouseEvent& event)
-{
-    wxTreeItemId id = HitTest(event.GetPosition());
-    if ( !id )
-        wxLogMessage(wxT("No item under mouse"));
-    else
-    {
-        OPJMarkerData *item = (OPJMarkerData *)GetItemData(id);
-        if ( item )
-            wxLogMessage(wxT("Item '%s' under mouse"), item->GetDesc());
-    }
-
-    event.Skip();
-}
-*/
-
-static inline const wxChar *Bool2String(bool b)
-{
-    return b ? wxT("") : wxT("not ");
-}
-
-void OPJMarkerData::ShowInfo(wxTreeCtrl *tree)
-{
-    wxLogMessage(wxT("Item '%s': %sselected, %sexpanded, %sbold,\n")
-                 wxT("%u children (%u immediately under this item)."),
-                 m_desc.c_str(),
-                 Bool2String(tree->IsSelected(GetId())),
-                 Bool2String(tree->IsExpanded(GetId())),
-                 Bool2String(tree->IsBold(GetId())),
-                 unsigned(tree->GetChildrenCount(GetId())),
-                 unsigned(tree->GetChildrenCount(GetId(), false)));
-}
-
-/////////////////////////////////////////////////////////////////////
-// Decoding thread class
-/////////////////////////////////////////////////////////////////////
-
-OPJDecoThread::OPJDecoThread(OPJCanvas *canvas)
-        : wxThread()
-{
-    m_count = 0;
-    m_canvas = canvas;
-}
-
-void OPJDecoThread::WriteText(const wxString& text)
-{
-    wxString msg;
-
-    // before doing any GUI calls we must ensure that this thread is the only
-    // one doing it!
-
-#ifndef __WXGTK__ 
-    wxMutexGuiEnter();
-#endif // __WXGTK__
-
-    msg << text;
-    m_canvas->WriteText(msg);
-
-#ifndef __WXGTK__ 
-    wxMutexGuiLeave();
-#endif // __WXGTK__
-}
-
-void OPJDecoThread::OnExit()
-{
-    wxCriticalSectionLocker locker(wxGetApp().m_deco_critsect);
-
-    wxArrayThread& dthreads = wxGetApp().m_deco_threads;
-    dthreads.Remove(this);
-
-    if (dthreads.IsEmpty() )
-    {
-        // signal the main thread that there are no more threads left if it is
-        // waiting for us
-        if (wxGetApp().m_deco_waitingUntilAllDone) {
-            wxGetApp().m_deco_waitingUntilAllDone = false;
-            wxGetApp().m_deco_semAllDone.Post();
-        }
-    }
-}
-
-void *OPJDecoThread::Entry()
-{
-
-    wxString text;
-
-	srand(GetId());
-	//int m_countnum = rand() % 9;
-    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
-    //            GetId(), GetPriority(), m_countnum);
-    text.Printf(wxT("Deco thread %d started"), m_canvas->m_childframe->m_winnumber);
-
-    WriteText(text);
-
-    wxBitmap bitmap(100, 100);
-    wxImage image(100, 100, true); //= bitmap.ConvertToImage();
-    image.Destroy();
-
-	WriteText(m_canvas->m_fname.GetFullPath());
-
-
-	// set handler properties
-	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
-	j2kkkhandler->m_reducefactor = wxGetApp().m_reducefactor;
-	j2kkkhandler->m_qualitylayers = wxGetApp().m_qualitylayers;
-	j2kkkhandler->m_components = wxGetApp().m_components;
-#ifdef USE_JPWL
-	j2kkkhandler->m_enablejpwl = wxGetApp().m_enablejpwl;
-	j2kkkhandler->m_expcomps = wxGetApp().m_expcomps;
-	j2kkkhandler->m_maxtiles = wxGetApp().m_maxtiles;
-#endif // USE_JPWL
-
-	wxJP2Handler *jp222handler = (wxJP2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_JP2);
-	jp222handler->m_reducefactor = wxGetApp().m_reducefactor;
-	jp222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
-	jp222handler->m_components = wxGetApp().m_components;
-#ifdef USE_JPWL
-	jp222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
-	jp222handler->m_expcomps = wxGetApp().m_expcomps;
-	jp222handler->m_maxtiles = wxGetApp().m_maxtiles;
-#endif // USE_JPWL
-
-	wxMJ2Handler *mj222handler = (wxMJ2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_MJ2);
-	mj222handler->m_reducefactor = wxGetApp().m_reducefactor;
-	mj222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
-	mj222handler->m_components = wxGetApp().m_components;
-	mj222handler->m_framenum = wxGetApp().m_framenum;
-#ifdef USE_JPWL
-	mj222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
-	mj222handler->m_expcomps = wxGetApp().m_expcomps;
-	mj222handler->m_maxtiles = wxGetApp().m_maxtiles;
-#endif // USE_JPWL
-
-	if (wxGetApp().m_enabledeco) {
-
-		// load the file
-		if (!image.LoadFile(m_canvas->m_fname.GetFullPath(), wxBITMAP_TYPE_ANY, 0)) {
-			WriteText(wxT("Can't load image"));
-			return NULL;
-		}
-
-	} else {
-
-		// display a macaron
-		if (!image.Create(300, 5, false)) {
-			WriteText(wxT("Can't create image"));
-			return NULL;
-		}
-
-	}
-
-	// assign 100% image
-    m_canvas->m_image100 = wxBitmap(image);
-
-	// find a fit-to-width zoom
-	int zooml, wzooml, hzooml;
-	wxSize clientsize = m_canvas->GetClientSize();
-	wzooml = (int) floor(100.0 * (double) clientsize.GetWidth() / (double) (2 * OPJ_CANVAS_BORDER + image.GetWidth()));
-	hzooml = (int) floor(100.0 * (double) clientsize.GetHeight() / (double) (2 * OPJ_CANVAS_BORDER + image.GetHeight()));
-	zooml = wxMin(100, wxMin(wzooml, hzooml));
-
-	// fit to width
-#ifndef __WXGTK__
-	m_canvas->m_childframe->m_frame->Rescale(zooml, m_canvas->m_childframe);
-#endif // __WXGTK__
-
-	//m_canvas->m_image = m_canvas->m_image100;
-	//m_canvas->Refresh();
-	//m_canvas->SetScrollbars(20, 20, (int)(0.5 + (double) image.GetWidth() / 20.0), (int)(0.5 + (double) image.GetHeight() / 20.0));
-
-    //text.Printf(wxT("Deco thread 0x%lx finished."), GetId());
-    text.Printf(wxT("Deco thread %d finished"), m_canvas->m_childframe->m_winnumber);
-    WriteText(text);
-    return NULL;
-
-}
-
-/////////////////////////////////////////////////////////////////////
-// Parsing thread class
-/////////////////////////////////////////////////////////////////////
-
-OPJParseThread::OPJParseThread(OPJMarkerTree *tree, wxTreeItemId parentid)
-        : wxThread()
-{
-    m_count = 0;
-    m_tree = tree;
-	m_parentid = parentid;
-}
-
-void OPJParseThread::WriteText(const wxString& text)
-{
-    wxString msg;
-
-    // before doing any GUI calls we must ensure that this thread is the only
-    // one doing it!
-
-#ifndef __WXGTK__ 
-    wxMutexGuiEnter();
-#endif // __WXGTK
-
-    msg << text;
-    m_tree->WriteText(msg);
-
-#ifndef __WXGTK__ 
-    wxMutexGuiLeave();
-#endif // __WXGTK
-}
-
-void OPJParseThread::OnExit()
-{
-    wxCriticalSectionLocker locker(wxGetApp().m_parse_critsect);
-
-    wxArrayThread& threads = wxGetApp().m_parse_threads;
-    threads.Remove(this);
-
-    if (threads.IsEmpty()) {
-        // signal the main thread that there are no more threads left if it is
-        // waiting for us
-        if (wxGetApp().m_parse_waitingUntilAllDone) {
-            wxGetApp().m_parse_waitingUntilAllDone = false;
-            wxGetApp().m_parse_semAllDone.Post();
-        }
-    }
-}
-
-void *OPJParseThread::Entry()
-{
-
-	printf("Entering\n\n");
-
-    wxString text;
-
-	srand(GetId());
-	int m_countnum = rand() % 9;
-    text.Printf(wxT("Parse thread 0x%lx started (priority = %u, time = %d)."),
-            GetId(), GetPriority(), m_countnum);
-    WriteText(text);
-    LoadFile(m_tree->m_fname);
-    text.Printf(wxT("Parse thread 0x%lx finished."), GetId());
-    WriteText(text);
-
-
-    //wxLogMessage(wxT("Entering\n")); //test wxLog thread safeness
-
-	//wxBusyCursor wait;
-	//wxBusyInfo wait(wxT("Decoding image ..."));
-
-
-    /*for ( m_count = 0; m_count < m_countnum; m_count++ )
-    {
-        // check if we were asked to exit
-        if ( TestDestroy() )
-            break;
-
-        text.Printf(wxT("[%u] Parse thread 0x%lx here."), m_count, GetId());
-        WriteText(text);
-
-        // wxSleep() can't be called from non-GUI thread!
-        wxThread::Sleep(10);
-    }*/
-
-    // wxLogMessage(text); -- test wxLog thread safeness
-
-	printf("Exiting\n\n");
-
-    return NULL;
-}
-
-
-
-
-
-
-
-// ----------------------------------------------------------------------------
-// OPJDecoderDialog
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
-
-BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
-#ifdef USE_JPWL
-	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
-	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
-#endif // USE_JPWL
-END_EVENT_TABLE()
-
-OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
-{
-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
-
-	Create(win, wxID_ANY, wxT("Decoder settings"),
-		wxDefaultPosition, wxDefaultSize,
-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
-		);
-
-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
-
-	m_settingsNotebook = GetBookCtrl();
-
-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
-	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpeg2000Settings->Enable(false);
-	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		mjpeg2000Settings->Enable(false);
-#ifdef USE_JPWL
-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpwlSettings->Enable(false);
-#endif // USE_JPWL
-
-	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
-	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
-	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
-#ifdef USE_JPWL
-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
-#endif // USE_JPWL
-
-	LayoutDialog();
-}
-
-OPJDecoderDialog::~OPJDecoderDialog()
-{
-}
-
-wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-		// add decoding enabling check box
-		subtopSizer->Add(
-			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
-			0, wxGROW | wxALL, 5);
-		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
-
-			// resize settings, column
-			wxString choices[] = {wxT("Low quality"), wxT("High quality")};
-			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
-				wxT("Resize method"),
-				wxDefaultPosition, wxDefaultSize,
-				WXSIZEOF(choices),
-				choices,
-				1,
-				wxRA_SPECIFY_ROWS);
-			m_resizeBox->SetSelection(wxGetApp().m_resizemethod);
-
-		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-			// frame settings, column
-			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
-			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
-
-				// selected frame number, row
-				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				framenumSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				framenumSizer->Add(
-					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
-								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_framenum),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-			// resolutions settings, column
-			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
-			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
-
-				// reduce factor sizer, row
-				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				reduceSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				reduceSizer->Add(
-					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
-					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 10000, wxGetApp().m_reducefactor),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
-
-			// quality layer settings, column
-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				qualitySizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				qualitySizer->Add(
-					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
-								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_qualitylayers),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
-
-			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				numcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				numcompsSizer->Add(
-					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_components),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_components),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_numcompsCtrl->Enable(true);
-
-			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-#ifdef USE_JPWL
-wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-		// add JPWL enabling check box
-		subtopSizer->Add(
-			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
-			0, wxGROW | wxALL, 5);
-		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
-
-			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// expected components sizer, row
-				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				expcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				expcompsSizer->Add(
-					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_expcomps),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
-
-			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-
-			// tiles settings, column
-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
-
-				// maximum tiles sizer, row
-				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				maxtileSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				maxtileSizer->Add(
-					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
-								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_maxtiles),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
-
-			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
-{
-	size_t pp;
-
-	if (event.IsChecked()) {
-		wxLogMessage(wxT("Decoding enabled"));
-		m_resizeBox->Enable(true);
-		// enable all tabs except ourselves
-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
-				m_settingsNotebook->GetPage(pp)->Enable(true);
-		}
-	} else {
-		wxLogMessage(wxT("Decoding disabled"));
-		m_resizeBox->Enable(false);
-		// disable all tabs except ourselves
-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
-				m_settingsNotebook->GetPage(pp)->Enable(false);
-		}
-	}
-
-}
-
-void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
-{
-	if (event.IsChecked()) {
-		wxLogMessage(wxT("JPWL enabled"));
-		m_expcompsCtrl->Enable(true);
-		m_maxtilesCtrl->Enable(true);
-	} else {
-		wxLogMessage(wxT("JPWL disabled"));
-		m_expcompsCtrl->Enable(false);
-		m_maxtilesCtrl->Enable(false);
-	}
-
-}
-
-#endif // USE_JPWL
-
-bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
-{
-    /*size_t nFiles = filenames.GetCount();
-    wxString str;
-    str.Printf( _T("%d files dropped\n"), (int)nFiles);
-    for ( size_t n = 0; n < nFiles; n++ ) {
-        str << filenames[n] << wxT("\n");
-    }
-    wxLogMessage(str);*/
-	m_pOwner->OpenFiles(filenames, filenames);
-
-    return true;
-}
-
-
-
-
-
-// ----------------------------------------------------------------------------
-// OPJEncoderDialog
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
-
-BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
-#ifdef USE_JPWL
-	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
-#endif // USE_JPWL
-END_EVENT_TABLE()
-
-OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
-{
-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
-
-	Create(win, wxID_ANY, wxT("Encoder settings"),
-		wxDefaultPosition, wxDefaultSize,
-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
-		);
-
-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
-
-	m_settingsNotebook = GetBookCtrl();
-
-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
-	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
-/*	if (!wxGetApp().m_enabledeco)
-		jpeg2000Settings->Enable(false);
-	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		mjpeg2000Settings->Enable(false);
-#ifdef USE_JPWL
-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpwlSettings->Enable(false);
-#endif // USE_JPWL
-*/
-
-	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
-	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
-/*	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
-#ifdef USE_JPWL
-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
-#endif // USE_JPWL
-*/
-	LayoutDialog();
-}
-
-OPJEncoderDialog::~OPJEncoderDialog()
-{
-}
-
-wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJEncoderDialog::CreatePart1SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
-
-			// image settings, column
-			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
-			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
-
-				// subsampling factor sizer, row
-				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				subsSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				subsSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
-								wxT("1,1"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
-
-				// origin sizer, row
-				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				imorigSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				imorigSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_IMORIG,
-								wxT("0,0"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
-
-			// layer settings, column
-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
-
-				// rate factor sizer, row
-				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				rateSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				rateSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
-								wxT("20,10,5"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
-
-				// quality factor sizer, row
-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				qualitySizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				qualitySizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
-								wxT("30,35,40"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
-
-			// wavelet settings, column
-			wxStaticBox* waveletBox = new wxStaticBox(panel, wxID_ANY, wxT("Transform"));
-			wxBoxSizer* waveletSizer = new wxStaticBoxSizer(waveletBox, wxVERTICAL);
-
-			// irreversible check box
-			waveletSizer->Add(
-				/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible"),
-				wxDefaultPosition, wxDefaultSize),
-				0, wxGROW | wxALL, 3);
-			/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// resolution number sizer, row
-				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				resnumSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				resnumSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
-								wxT("6"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 256, 6),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
-
-				// codeblock sizer, row
-				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				codeblockSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				codeblockSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
-								wxT("32,32"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
-
-				// precinct sizer, row
-				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				precinctSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				precinctSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
-								wxT("[128,128],[128,128]"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(waveletSizer, 0, wxGROW | wxALL, 3);
-
-			// tile settings, column
-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
-
-				// tile size sizer, row
-				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				tilesizeSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_TILESIZE,
-								wxT(""),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
-
-				// tile origin sizer, row
-				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				tilorigSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				tilorigSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_TILORIG,
-								wxT("0,0"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
-
-			// progression settings, column
-			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL")};
-			wxRadioBox *progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
-				wxT("Progression"),
-				wxDefaultPosition, wxDefaultSize,
-				WXSIZEOF(choices),
-				choices,
-				4,
-				wxRA_SPECIFY_COLS);
-			progressionBox->SetSelection(0);
-
-		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
-
-			// resilience settings, column
-			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Resilience"));
-			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
-
-				// resil2 sizer, row
-				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// SOP check box
-				resil2Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// EPH check box
-				resil2Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
-
-			// separation
-			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
-
-				// resil3 sizer, row
-				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
-
-				// BYPASS check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// RESET check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// RESTART check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// VSC check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// ERTERM check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// SEGMARK check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
-
-			// ROI settings, column
-			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("ROI"));
-			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
-
-				// component number sizer, row
-				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				roicompSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				roicompSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
-								wxT("0"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 256, 0),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
-
-				// upshift sizer, row
-				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				roishiftSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				roishiftSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
-								wxT("0"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 37, 0),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
-
-			// ROI settings, column
-			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
-			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
-
-			// indexing check box
-			indexSizer->Add(
-				/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
-				wxDefaultPosition, wxDefaultSize),
-				0, wxGROW | wxALL, 3);
-			/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// index file sizer, row
-				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				indexnameSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				indexnameSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_INDEXNAME,
-								wxT(""),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
-
-/*			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				numcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				numcompsSizer->Add(
-					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_components),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_components),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_numcompsCtrl->Enable(true);
-
-			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-*/
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-#ifdef USE_JPWL
-void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
-{
-	/*if (event.IsChecked()) {
-		wxLogMessage(wxT("JPWL enabled"));
-		m_expcompsCtrl->Enable(true);
-		m_maxtilesCtrl->Enable(true);
-	} else {
-		wxLogMessage(wxT("JPWL disabled"));
-		m_expcompsCtrl->Enable(false);
-		m_maxtilesCtrl->Enable(false);
-	}*/
-
-}
-#endif // USE_JPWL
diff -urN -xdebian -x.svn ./OPJViewer/source/OPJViewer.h /usr/src/openjpeg/trunk/OPJViewer/source/OPJViewer.h
--- ./OPJViewer/source/OPJViewer.h	2007-12-01 19:19:39.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/OPJViewer.h	2007-12-01 18:40:47.000000000 +0000
@@ -98,11 +98,17 @@
 
 #include <wx/imaglist.h>
 
+#include "wx/toolbar.h"
+#include "wx/artprov.h"
+
 #include "libopenjpeg/openjpeg.h"
 
 #include "imagj2k.h"
 #include "imagjp2.h"
 #include "imagmj2.h"
+#ifdef USE_MXF
+#include "imagmxf.h"
+#endif // USE_MXF
 
 #ifdef __WXMSW__
 typedef unsigned __int64 int8byte;
@@ -128,6 +134,7 @@
 #define OPJ_APPLICATION_VERSION		wxT("0.3 alpha")
 #define OPJ_APPLICATION_TITLEBAR	OPJ_APPLICATION_NAME wxT(" ") OPJ_APPLICATION_VERSION
 #define OPJ_APPLICATION_COPYRIGHT	wxT("(C) 2007, Giuseppe Baruffa")
+#define OPJ_APPLICATION_VENDOR      wxT("OpenJPEG")
 
 #ifdef __WXMSW__
 #define OPJ_APPLICATION_PLATFORM    wxT("Windows")
@@ -137,10 +144,27 @@
 #define OPJ_APPLICATION_PLATFORM    wxT("Linux")
 #endif
 
+#define OPJ_FRAME_WIDTH   800
+#define OPJ_FRAME_HEIGHT  600
+
+#define OPJ_BROWSER_WIDTH 300
+#define OPJ_PEEKER_HEIGHT 130
+
 #define OPJ_CANVAS_BORDER 10
 #define OPJ_CANVAS_COLOUR *wxWHITE
 
+
+
+#ifdef USE_JPWL
+
+//#define MYJPWL_MAX_NO_TILESPECS JPWL_MAX_NO_TILESPECS
+#define MYJPWL_MAX_NO_TILESPECS 4
+
+#endif // USE_JPWL
+
+
 class OPJDecoThread;
+class OPJEncoThread;
 class OPJParseThread;
 WX_DEFINE_ARRAY_PTR(wxThread *, wxArrayThread);
 class OPJChildFrame;
@@ -158,23 +182,24 @@
 
 		// other methods
 		bool OnInit(void);
+		int OnExit(void);
 		void SetShowImages(bool show) { m_showImages = show; }
 		bool ShowImages() const { return m_showImages; }
 		void ShowCmdLine(const wxCmdLineParser& parser);
 
 		// all the threads currently alive - as soon as the thread terminates, it's
 		// removed from the array
-		wxArrayThread m_deco_threads, m_parse_threads;
+		wxArrayThread m_deco_threads, m_parse_threads, m_enco_threads;
 
 		// crit section protects access to all of the arrays below
-		wxCriticalSection m_deco_critsect, m_parse_critsect;
+		wxCriticalSection m_deco_critsect, m_parse_critsect, m_enco_critsect;
 
 		// semaphore used to wait for the threads to exit, see OPJFrame::OnQuit()
-		wxSemaphore m_deco_semAllDone, m_parse_semAllDone;
+		wxSemaphore m_deco_semAllDone, m_parse_semAllDone, m_enco_semAllDone;
 
 		// the last exiting thread should post to m_semAllDone if this is true
 		// (protected by the same m_critsect)
-		bool m_deco_waitingUntilAllDone, m_parse_waitingUntilAllDone;
+		bool m_deco_waitingUntilAllDone, m_parse_waitingUntilAllDone, m_enco_waitingUntilAllDone;
 
 		// the list of all filenames written in the command line
 		wxArrayString m_filelist;
@@ -183,13 +208,36 @@
 		int m_resizemethod;
 
 		// decoding engine parameters
-		bool m_enabledeco;
+		bool m_enabledeco, m_enableparse;
 		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
 #ifdef USE_JPWL
-		bool m_enablejpwl;
+		bool m_enablejpwl, m_enablejpwle;
 		int m_expcomps, m_maxtiles;
+		int m_framewidth, m_frameheight;
 #endif // USE_JPWL
 
+		// encoding engine parameters
+		wxString m_subsampling, m_origin, m_rates, m_comment, m_index, m_quality;
+		wxString m_cbsize, m_prsize, m_tsize, m_torigin, m_poc;
+		bool m_enablecomm, m_enableidx, m_multicomp, m_irreversible, m_enablesop, m_enableeph;
+		bool m_enablebypass, m_enablereset, m_enablerestart, m_enablevsc, m_enableerterm;
+		bool m_enablesegmark, m_enablepoc;
+		bool m_enablequality;
+		int m_resolutions, m_progression;
+#ifdef USE_JPWL
+		int m_hprotsel[MYJPWL_MAX_NO_TILESPECS], m_pprotsel[MYJPWL_MAX_NO_TILESPECS];
+		int m_htileval[MYJPWL_MAX_NO_TILESPECS], m_ptileval[MYJPWL_MAX_NO_TILESPECS],
+			m_ppackval[MYJPWL_MAX_NO_TILESPECS];
+		int m_sensisel[MYJPWL_MAX_NO_TILESPECS], m_stileval[MYJPWL_MAX_NO_TILESPECS];
+#endif // USE_JPWL
+
+		// some layout settings
+		bool m_showtoolbar, m_showbrowser, m_showpeeker;
+		int m_browserwidth, m_peekerheight;
+
+		// application configuration
+		wxConfig *OPJconfig; 
+
 	// private methods and variables
 	private:
 		bool m_showImages, m_showButtons;
@@ -221,10 +269,11 @@
 #endif //__WXGTK__
 		}
 		OPJDecoThread *CreateDecoThread(void);
+		OPJEncoThread *CreateEncoThread(void);
 		OPJChildFrame *m_childframe;
 
 		wxBitmap  m_image, m_image100;
-		wxFileName m_fname;
+		wxFileName m_fname, m_savename;
 		long m_zooml;
 
 	DECLARE_EVENT_TABLE()
@@ -245,10 +294,10 @@
 		const wxChar *GetDesc1() const { return m_desc.c_str(); }
 		const wxChar *GetDesc2() const { return m_filestring.c_str(); }
 		wxFileOffset m_start, m_length;
+		wxString m_desc;
 
 	// private methods and variables
 	private:
-		wxString m_desc;
 		wxString m_filestring;
 };
 
@@ -364,17 +413,33 @@
 	void OnSize(wxSizeEvent& WXUNUSED(event));
     void OnAbout(wxCommandEvent& WXUNUSED(event));
     void OnFileOpen(wxCommandEvent& WXUNUSED(event));
+    void OnFileSaveAs(wxCommandEvent& WXUNUSED(event));
+    void OnMemoryOpen(wxCommandEvent& WXUNUSED(event));
     void OnQuit(wxCommandEvent& WXUNUSED(event));
     void OnClose(wxCommandEvent& WXUNUSED(event));
     void OnZoom(wxCommandEvent& WXUNUSED(event));
 	void OnFit(wxCommandEvent& WXUNUSED(event));
 	void OnToggleBrowser(wxCommandEvent& WXUNUSED(event));
 	void OnTogglePeeker(wxCommandEvent& WXUNUSED(event));
+	void OnToggleToolbar(wxCommandEvent& WXUNUSED(event));
 	void OnReload(wxCommandEvent& event);
+	void OnPrevFrame(wxCommandEvent& event);
+	void OnHomeFrame(wxCommandEvent& event);
+	void OnNextFrame(wxCommandEvent& event);
+	void OnLessLayers(wxCommandEvent& event);
+	void OnAllLayers(wxCommandEvent& event);
+	void OnMoreLayers(wxCommandEvent& event);
+	void OnLessRes(wxCommandEvent& event);
+	void OnFullRes(wxCommandEvent& event);
+	void OnMoreRes(wxCommandEvent& event);
+	void OnPrevComp(wxCommandEvent& event);
+	void OnAllComps(wxCommandEvent& event);
+	void OnNextComp(wxCommandEvent& event);
 	void OnSetsEnco(wxCommandEvent& event);
 	void OnSetsDeco(wxCommandEvent& event);
 	void OnSashDrag(wxSashEvent& event);
 	void OpenFiles(wxArrayString paths, wxArrayString filenames);
+	void SaveFile(wxArrayString paths, wxArrayString filenames);
 	void OnNotebook(wxNotebookEvent& event);
 	void Rescale(int scale, OPJChildFrame *child);
 
@@ -382,6 +447,7 @@
 	OPJChildFrameHash m_childhash;
     wxSashLayoutWindow* markerTreeWindow;
     wxSashLayoutWindow* loggingWindow;
+	wxToolBar* tool_bar;
     void Resize(int number);
 	wxNotebook *m_bookCtrl;
 	wxNotebook *m_bookCtrlbottom;
@@ -429,17 +495,33 @@
 	OPJFRAME_FILEEXIT = wxID_EXIT,
 	OPJFRAME_HELPABOUT = wxID_ABOUT,
 	OPJFRAME_FILEOPEN,
+	OPJFRAME_MEMORYOPEN,
+	OPJFRAME_FILESAVEAS,
 	OPJFRAME_FILETOGGLEB,
 	OPJFRAME_FILETOGGLEP,
+	OPJFRAME_FILETOGGLET,
 	OPJFRAME_VIEWZOOM,
 	OPJFRAME_VIEWFIT,
 	OPJFRAME_VIEWRELOAD,
+	OPJFRAME_VIEWPREVFRAME,
+	OPJFRAME_VIEWHOMEFRAME,
+	OPJFRAME_VIEWNEXTFRAME,
+	OPJFRAME_VIEWLESSLAYERS,
+	OPJFRAME_VIEWALLLAYERS,
+	OPJFRAME_VIEWMORELAYERS,
+	OPJFRAME_VIEWLESSRES,
+	OPJFRAME_VIEWFULLRES,
+	OPJFRAME_VIEWMORERES,
+	OPJFRAME_VIEWPREVCOMP,
+	OPJFRAME_VIEWALLCOMPS,
+	OPJFRAME_VIEWNEXTCOMP,
 	OPJFRAME_FILECLOSE,
 	OPJFRAME_SETSENCO,
 	OPJFRAME_SETSDECO,
 
 	OPJFRAME_BROWSEWIN = 10000,
-	OPJFRAME_LOGWIN
+	OPJFRAME_LOGWIN,
+	OPJFRAME_TOOLBAR
 };
 
 
@@ -494,6 +576,26 @@
 	LEFT_NOTEBOOK_ID
 };
 
+class OPJEncoThread : public wxThread
+{
+public:
+    OPJEncoThread(OPJCanvas *canvas);
+
+    // thread execution starts here
+    virtual void *Entry();
+
+    // called when the thread exits - whether it terminates normally or is
+    // stopped with Delete() (but not when it is Kill()ed!)
+    virtual void OnExit();
+
+    // write something to the text control
+    void WriteText(const wxString& text);
+
+public:
+    unsigned m_count;
+    OPJCanvas *m_canvas;
+};
+
 class OPJDecoThread : public wxThread
 {
 public:
@@ -569,21 +671,48 @@
 	wxBookCtrlBase* m_settingsNotebook;
 
     wxPanel* CreateMainSettingsPage(wxWindow* parent);
-    wxPanel* CreatePart1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_2SettingsPage(wxWindow* parent);
 /*    wxPanel* CreatePart3SettingsPage(wxWindow* parent);*/
+	void OnEnableComm(wxCommandEvent& event);
+	void OnEnableIdx(wxCommandEvent& event);
+	void OnEnablePoc(wxCommandEvent& event);
+	void OnRadioQualityRate(wxCommandEvent& event);
 #ifdef USE_JPWL
 	void OnEnableJPWL(wxCommandEvent& event);
-/*    wxPanel* CreatePart11SettingsPage(wxWindow* parent);
-	wxCheckBox *m_enablejpwlCheck;*/
+	wxPanel* CreatePart11SettingsPage(wxWindow* parent);
+	/*wxCheckBox *m_enablejpwlCheck;*/
+	wxChoice *m_hprotChoice[MYJPWL_MAX_NO_TILESPECS];
+	wxSpinCtrl *m_htileCtrl[MYJPWL_MAX_NO_TILESPECS];
+	wxChoice *m_pprotChoice[MYJPWL_MAX_NO_TILESPECS];
+	wxSpinCtrl *m_ptileCtrl[MYJPWL_MAX_NO_TILESPECS];
+	wxSpinCtrl *m_ppackCtrl[MYJPWL_MAX_NO_TILESPECS];
+	wxChoice *m_sensiChoice[MYJPWL_MAX_NO_TILESPECS];
+	wxSpinCtrl *m_stileCtrl[MYJPWL_MAX_NO_TILESPECS];
+	void OnHprotSelect(wxCommandEvent& event);
+	void OnPprotSelect(wxCommandEvent& event);
+	void OnSensiSelect(wxCommandEvent& event);
 #endif // USE_JPWL
 
+	wxTextCtrl *m_subsamplingCtrl, *m_originCtrl, *m_rateCtrl, *m_commentCtrl;
+	wxRadioButton *m_rateRadio, *m_qualityRadio;
+	wxTextCtrl *m_indexCtrl, *m_qualityCtrl, *m_cbsizeCtrl, *m_prsizeCtrl, *m_pocCtrl;
+	wxTextCtrl *m_tsizeCtrl, *m_toriginCtrl;
+	wxRadioBox *progressionBox;
+	wxCheckBox *m_enablecommCheck, *m_enableidxCheck, *m_mctCheck, *m_irrevCheck;
+	wxCheckBox *m_sopCheck, *m_ephCheck, *m_enablebypassCheck, *m_enableresetCheck,
+		*m_enablerestartCheck, *m_enablevscCheck, *m_enableertermCheck, *m_enablesegmarkCheck;
+	wxCheckBox *m_enablepocCheck, *m_enablejpwlCheck;
+	wxSpinCtrl *m_resolutionsCtrl;
 
 protected:
 
     enum {
 		OPJENCO_ENABLEJPWL = 100,
 		OPJENCO_RATEFACTOR,
+		OPJENCO_RATERADIO,
 		OPJENCO_QUALITYFACTOR,
+		OPJENCO_QUALITYRADIO,
 		OPJENCO_RESNUMBER,
 		OPJENCO_CODEBLOCKSIZE,
 		OPJENCO_PRECINCTSIZE,
@@ -598,13 +727,25 @@
 		OPJENCO_ENABLEVSC,
 		OPJENCO_ENABLEERTERM,
 		OPJENCO_ENABLESEGMARK,
+		OPJENCO_ENABLEPOC,
 		OPJENCO_ROICOMP,
 		OPJENCO_ROISHIFT,
 		OPJENCO_IMORIG,
 		OPJENCO_TILORIG,
+		OPJENCO_ENABLEMCT,
 		OPJENCO_ENABLEIRREV,
 		OPJENCO_ENABLEINDEX,
-		OPJENCO_INDEXNAME
+		OPJENCO_INDEXNAME,
+		OPJENCO_POCSPEC,
+		OPJENCO_ENABLECOMM,
+		OPJENCO_COMMENTTEXT,
+		OPJENCO_HPROT,
+		OPJENCO_HTILE,
+		OPJENCO_PPROT,
+		OPJENCO_PTILE,
+		OPJENCO_PPACK,
+		OPJENCO_SENSI,
+		OPJENCO_STILE
     };
 
 DECLARE_EVENT_TABLE()
@@ -619,7 +760,7 @@
     ~OPJDecoderDialog();
 
 	wxBookCtrlBase* m_settingsNotebook;
-	wxCheckBox *m_enabledecoCheck;
+	wxCheckBox *m_enabledecoCheck, *m_enableparseCheck;
 	wxSpinCtrl *m_reduceCtrl, *m_layerCtrl, *m_numcompsCtrl;
 	wxRadioBox* m_resizeBox;
 
@@ -644,6 +785,7 @@
 		OPJDECO_QUALITYLAYERS,
 		OPJDECO_NUMCOMPS,
 		OPJDECO_ENABLEDECO,
+		OPJDECO_ENABLEPARSE,
 		OPJDECO_ENABLEJPWL,
 		OPJDECO_EXPCOMPS,
 		OPJDECO_MAXTILES,
diff -urN -xdebian -x.svn ./OPJViewer/source/wxj2kparser.cpp /usr/src/openjpeg/trunk/OPJViewer/source/wxj2kparser.cpp
--- ./OPJViewer/source/wxj2kparser.cpp	2007-12-01 19:19:39.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/wxj2kparser.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -255,7 +255,8 @@
 			wxString::FromAscii(marker_name[m]) + 
 			wxString::Format(wxT(" (0x%04X)"), marker_val[m]),
 			image, imageSel,
-			new OPJMarkerData(wxT("MARK"), m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
+			new OPJMarkerData(wxT("MARK") + wxString::Format(wxT(" (%d)"), marker_val[m]),
+				m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
 			);
 
 		// append some info
@@ -303,6 +304,7 @@
 			};
 			break;
 
+#ifdef USE_JPWL
 		/////////
 		// RED //
 		/////////
@@ -550,6 +552,15 @@
 
 			}
 			break;
+#endif // USE_JPWL
+
+#ifdef USE_JPSEC
+		case SEC_VAL:
+			{
+
+			}
+			break;
+#endif // USE_JPSEC
 
 		/////////
 		// SIZ //
diff -urN -xdebian -x.svn ./OPJViewer/source/wxjp2parser.cpp /usr/src/openjpeg/trunk/OPJViewer/source/wxjp2parser.cpp
--- ./OPJViewer/source/wxjp2parser.cpp	2007-11-29 18:27:29.000000000 +0000
+++ /usr/src/openjpeg/trunk/OPJViewer/source/wxjp2parser.cpp	2007-09-28 11:33:50.000000000 +0100
@@ -60,6 +60,8 @@
 			TRAK_BOX,
 			TKHD_BOX,
 			MDIA_BOX,
+			MDHD_BOX,
+			HDLR_BOX,
 			MINF_BOX,
 			VMHD_BOX,
 			STBL_BOX,
@@ -102,6 +104,8 @@
 #define TRAK_SIGN           "trak"
 #define TKHD_SIGN           "tkhd"
 #define MDIA_SIGN           "mdia"
+#define MDHD_SIGN           "mdhd"
+#define HDLR_SIGN           "hdlr"
 #define MINF_SIGN           "minf"
 #define VMHD_SIGN           "vmhd"
 #define STBL_SIGN           "stbl"
@@ -231,6 +235,22 @@
 /* req */	{1, 1, 1},
 /* ins */	TRAK_BOX},
 
+/* sign */	{MDHD_SIGN,
+/* short */	"Media Header box",
+/* long */	"The media header declares overall information which is media-independent, and relevant to characteristics "
+			"of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{HDLR_SIGN,
+/* short */	"Handler Reference box",
+/* long */	"This box within a Media Box declares the process by which the media-data in the track may be presented, "
+			"and thus, the nature of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
 /* sign */	{MINF_SIGN,
 /* short */	"Media Information box",
 /* long */	"This box contains all the objects which declare characteristic information of the media in the track",
@@ -303,10 +323,18 @@
 /* From little endian to big endian, 2 and 4 bytes */
 #define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
 #define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
-#define	BYTE_SWAP8(X)	(((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
                         ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
 						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
-						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56))
+						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
 
 /* From codestream to int values */
 #define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
@@ -821,7 +849,114 @@
 		};
 		break;
 
+		/* Media Header box */
+	case (MDHD_BOX): {
+			unsigned long int version;
+			unsigned short int language;
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			if (version == 0) {
+				unsigned long int creation_time, modification_time, timescale, duration;
+				fileid->Read(&creation_time, sizeof(unsigned long int));
+				creation_time = BYTE_SWAP4(creation_time);
+				fileid->Read(&modification_time, sizeof(unsigned long int));
+				modification_time = BYTE_SWAP4(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(unsigned long int));
+				duration = BYTE_SWAP4(duration);
+				const long unix_time = creation_time - 2082844800L;
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u (%.24s)"), creation_time, ctime(&unix_time)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				const long unix_time1 = modification_time - 2082844800L;
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u (%.24s)"), modification_time, ctime(&unix_time1)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u (%.6fs)"), timescale, 1.0 / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u (%.3fs)"), duration, (float) duration / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			} else {
+				int8byte creation_time, modification_time, duration;
+				unsigned long int timescale;
+				fileid->Read(&creation_time, sizeof(int8byte));
+				creation_time = BYTE_SWAP8(creation_time);
+				fileid->Read(&modification_time, sizeof(int8byte));
+				modification_time = BYTE_SWAP8(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(int8byte));
+				duration = BYTE_SWAP8(duration);
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u"), creation_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u"), modification_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u"), timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u"), duration),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			}
+			fileid->Read(&language, sizeof(unsigned short int));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Language: %d (%c%c%c)"), language & 0xEFFF,
+				0x60 + (char) ((language >> 10) & 0x001F), 0x60 + (char) ((language >> 5) & 0x001F), 0x60 + (char) ((language >> 0) & 0x001F)),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+		};
+		break;
 		
+		/* Media Handler box */
+	case (HDLR_BOX): {
+			unsigned long int version, predefined, temp[3];
+			char handler[4], name[256];
+			int namelen = wxMin(256, (filelimit - filepoint - 24));
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			fileid->Read(&predefined, sizeof(unsigned long int));
+			fileid->Read(handler, 4 * sizeof(char));
+			fileid->Read(&temp, 3 * sizeof(unsigned long int));
+			fileid->Read(name, namelen * sizeof(char));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Handler: %.4s"), handler),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Name: %.255s"), name),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 				 
+		}
+		break;
+
 	/* not yet implemented */
 	default:
 		break;
diff -urN -xdebian -x.svn ./README.cmake /usr/src/openjpeg/trunk/README.cmake
--- ./README.cmake	2007-11-29 18:27:40.000000000 +0000
+++ /usr/src/openjpeg/trunk/README.cmake	2007-09-28 11:33:52.000000000 +0100
@@ -6,4 +6,4 @@
   cd bin
   cmake .. -DBUILD_EXAMPLES:BOOL=ON
   make
-  ./codec/j2k_to_image 
+  ./bin/j2k_to_image 
