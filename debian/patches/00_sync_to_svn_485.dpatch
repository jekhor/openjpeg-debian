#! /bin/sh /usr/share/dpatch/dpatch-run
## xx.dpatch by  <root@debian>
##
## All lines beginning with `## DP:' are a description of the patch.
## DP: xx

@DPATCH@

diff -urN /home/robin/sldeb/trunk/ChangeLog ./ChangeLog
--- /home/robin/sldeb/trunk/ChangeLog	2007-06-04 14:27:25.000000000 +0100
+++ ./ChangeLog	2007-11-27 22:39:51.000000000 +0000
@@ -5,6 +5,203 @@
 ! : changed
 + : added
 
+November 14, 2007
++ [FOD] Created the file index.c in the codec directory. This file handles the creation of index files, 
+		at encoding and decoding. 
+* [FOD] Fixed bugs during the creation of the index (PCRL progression order)
+* [FOD] Fixed the maximum number of resolutions a user can discard while decoding.
+		Added an error state in J2K_STATE (j2k.c)
+
+November 14, 2007
+! [FOD] - First Patch by Callum Lerwick. Instead of reinventing realloc, j2k_read_sod now just uses opj_realloc in j2k.c
+		- Second Patch by Callum Lerwick. This patch rearranges the largest memory allocations so they're allocated as 
+		late as possible, and freed as soon as possible. This cuts memory usage by about half on two large test images.
+		- Third Patch by Callum Lerwick. The opj_tcd_cblk array is one of the largest allocations, because it
+		contains a bunch of static buffers. This also makes it a major source of cache thrashing. This patch allocates 
+		the buffers from the heap, and dynamically sizes them in the decoder. I have not yet managed to dynamically size 
+		them in the encoder, getting the decoder to do it was tricky enough... I also split opj_tcd_cblk_t into separate 
+		encode and decode versions. A lot of fields were not used by both, so this cuts its size even further.
+
+* [FOD] Avoided ABI breakage
+
+November 13, 2007
+! [FOD] Patch by Dzonatas and Callum Lerwick.
+        Fp/vectorization patch which basically converts most of the irreversible decode codepath to floating point,
+        eliminating a few rounds of int/fp conversion, resulting in a vast performance improvement,
+	and an increase in accuracy.
+
+November 8, 2007
+! [FOD] In t1.c, small change to avoid calling twice t1_getwmsedec()
+        Patches from Callum Lewick:
+		- Basic gcc optimization flags in cmake and makefile match.
+		- Fixed some spelling errors in dwt.c.
+
+November 5, 2007
+*+ [GB] Fixed a bug which prevented JPWL from working on multi-tiled images; added some more fields in the interface info structures 
+(keep a list of markers, save start packet number for each tile)
+
+October 23, 2007
+* [GB] Improved success for the linux build; OPJViewer shows all the COM contents
+ 
+October 18, 2007
+* [FOD] Changed the ROI parameter in the image_to_j2k codec to make it correspond to the documentation (i.e. -ROI c=0,U=25)
+* [FOD] Patch from Callum Lewick. Memset patch. 
+		The main idea of the patch is that currently opj_malloc clears all allocations, which unnecessarily
+		dirties up the cache and eats bandwidth. This patch makes it no longer do so, and I've painstakingly determined which allocations actually need
+		to be cleared and changed them to use opj_calloc() instead. I previously tried to just get rid of the opj_*alloc wrappers but that
+		idea was nixed, so this time I'm trying it with macros. I also put in a gcc pragma that helps enforce their use. Which got messy.  :)  It caught a
+		few places they weren't used but it also revealed that the mj2 tools are not very cleanly separated from the library. It includes all the
+		internal headers, but it wasn't using the malloc wrappers. I figured the binaries should be "external" and have minimal knowledge of the
+		internals of the library. I patched them to not include opj_includes.h, and include only the internal headers they actually need. However,
+		they're using the opj_clock() function, which is in with the malloc wrappers. So I decided to move the malloc wrappers to their own header. 
+		But mj2.c seems to want to be "internal", so I patched it to use the wrappers. Note that this patch changes the semantics of opj_malloc, it no longer
+		clears the memory it allocates. If you need it to be cleared, you must use opj_calloc instead, or memset it yourself. It is also somewhat
+		invasive, please test it extensively. I've been pounding on it all summer with my test suite, Second Life, and valgrind, and it checks out clean.
+
+October 12, 2007
+* [FOD] Changed the way the image structure is allocated when the decoding parameters include some resolutions to discard. 
+        This should have a significant impact for the decoding of huge images when some resolutions are discarder (-r parameter)
+        Warning: The output image size is now reduced when discarding resolutions !
+
+October 10, 2007
+* [FOD] Patch from Callum Lewick. Clean up of j2klib.h for the aligned malloc stuff. 
+        It makes it work right with mingw, as _mm_malloc() isn't a macro, attempts to pave the way to using cmake 
+        to check for this stuff and combines a patch from Dana Fagerstrom at Sun that makes it use memalign() on Solaris
+        convert.c: Changed some error comments for TIFF images
+
+September 27, 2007
+* [FOD] Patch from Callum Lewick. Fixed dwt.c where an alignment in buffer was problematic under x86_64.
+
+September 25, 2007
+* [Mathieu Malaterre] BUG: Fix previous patch from Callum Lerwick. I have no
+    clue what CMAKE_INSTALL_LIBDIR refers too. Bump up cmake 2.2 restriction to
+    cmake 2.4 because of previous patch (not backward compatible). Properly set the SOVERSION in a cross plateform way (yes WIN32 is a platform)
+
+September 19, 2007
+* [Parvatha] Fixed issues with generation of SOP marker. 
+
+September 18, 2007
+* [Parvatha] Fixed issues with Reading and Writing TIF images in convert.c to avoid segmentation fault. 
+* [Parvatha] Fixed issues relating to using user specified rates for CINEMA option for multiple images.
+
+September 17, 2007
+* [FOD] Fixed issues with cstr_info when codestream has components with different number of resolutions. 
+! [FOD] OpenJPEG library interface modified to retain compatibility with version 1.2 
+
+September 12, 2007
+* [FOD] Patch from Callum Lerwick.
+		Fixed the library linking so it links with the soversion properly set. 
+		Fixes up the install targets so that it interacts properly with RPM. 
+		Install target for MJ2. Sets some necessary and useful CFLAGS if gcc is in use.		
+* [FOD] Updated the MJ2 codec to be compatible with the recent changes in the OpenJPEG library
+
+September 11, 2007
+* [GB] JPWL encoding is finalized correctly into the JP2 file format; added an additional structure in opj_codestream_info, to keep a record of the written markers
+
+September 8, 2007
+* [GB] Adapted the JPWL and OPJViewer code to new interface; fixed a samll bug in JPWL which created large EPBs even when null protection was specified
+
+September 7, 2007
++ [FOD] Indexes can now be generated when decoding J2K codestreams.
+* [Mathieu Malaterre] Upon failure, properly return error code (!=0).
+* [Mathieu Malaterre] CMake: Add cmake code to do testing if user has properly setup a testimages directory
+
+September 6, 2007
++ [Mathieu Malaterre] CMake: start compiling mj2, jpwl and jp3d
++ [Mathieu Malaterre] CMake: output all executable/libs into one single directory
++ [Mathieu Malaterre] CMake: start compiling index_create
++ [Mathieu Malaterre] OpenJPEG.rc update copyright year
++ [Mathieu Malaterre] CMake: add Java j2kviewer but do not compile it using cmake since cmake has too poor support for Java. Should create a custom command running ant instead.
++ [Mathieu Malaterre] CMake: Add doxygen output
++ [GB] One more field in the codestream_info struct for recording the number of packets per tile part; JPWL now distributes the EPBs in all the tile part headers
++ [Mathieu Malaterre] CMake: Add very simple tests (simply run command line with no option)
+* [Mathieu Malaterre] Fix unitialized read in img_fol (we may need a smarter initialize than memset)
+
+September 4, 2007
++ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. 
+		Changed also the write_index function in the codec, to reflect the presence of this new information.
+
+September 3, 2007
++ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: 
+		no real security function at this stage. Deprecated USE_JPSEC will be removed next
+
+August 31, 2007
+* [GB] Fixed save capabilities in OPJViewer due to recent code upgrade
+
+August 30, 2007
+* [FOD] Changed the OpenJPEG library interface to enable users to access information regarding the codestream (also called codestream index).
+		This index is usefull for all applications requiring to have a scalable acces to the codestream (like JPIP applications, ...)
+        Currently, this information is only available when encoding an image.       
++ [FOD] Added the information regarding the end of packet position in the index        
+
+August 28, 2007
+* [FOD] Fixed wrong destructors called in openjpeg.c
+* [FOD] Fixed bug in j2k_decode_jpt_stream
+
+August 24, 2007
+* [Parvatha] The end of main header is calculated after TLM and POC marker for Dcinema.
+
+August 21, 2007
++ [FOD] Added support for Visual Studio 2005
+* [FOD] Robustified MJ2 codecs
+* [Parvatha] Solved problems with codec reading from image file directory when filename had more than one "." in name
+* [Callum Lerwick] Minor cleanup patch, that gets rid of a bunch of "old style declaration" warnings from Intel's compiler
+* [Callum Lerwick] Aligned malloc using Intel's _mm_malloc(). Cleanup on the t1 memory allocation, getting rid of some leftover debug code
+* [Callum Lerwick] Memory leaks fixed
+* [Callum Lerwick] Reworks of t1_updateflags to get rid of the shift operation
+* [Callum Lerwick] mqc_setcurctx moved to the header to allow it to be inlined into the t1.
+* [Callum Lerwick] Consolidated some calls to mqc_setcurctx.
+* [Callum Lerwick] Cleaned up t1_generate_luts to output the proper types.
+* [Callum Lerwick] Replaced the large ctxno_mag lookup table with a small bit of inline-able branchless code
+* [Callum Lerwick] Moved the orient flipping into the ctxno_zc table.
+
+August 20, 2007
++ [FOD] Added support for the TGA file format in the codec
+
+August 08, 2007
+* [Parvatha] Fixed the DCinema filesize allocation. It now includes the SOT marker size
+
+August 02, 2007
++ [GB] Added a basic saving capability to OPJViewer
+
+July 18, 2007
+! [FOD] Updated libtiff library version to 3.8.2 (for WIN32)
+* [FOD] Updated BMP and PxM truncation when decoding J2K files with more than 8 bits
+
+July 17, 2007
+* [FOD] Fixed raw option for images with more than three components
+
+July 17, 2007
++ [FOD] Added support for RAW images. This module has been developped by the University of Perugia team. Thanks to them ! [image_to_j2k.c j2k_to_image.c convert.c convert.h]
+
+July 13, 2007
+! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, 
+		leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
+! [FOD] Modified old comments about the ability to decode mega-images and comments about the disk size necessary to do this. [image_to_j2k.c and frames_to_mj2.c]
+* [FOD] Added 2000 bytes for the memory allocation in cio.c for the minimum size of headers (useful in case of very small images) [cio.c]
+
+July 12, 2007
+* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, 
+		even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension 
+		is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
+
+July 8, 2007
+* [ANTONIN] fixed the size of the memory allocation in cio.c (confusion between bits and bytes)
+
+June 21, 2007
+* [FOD] Output image color space set when decoding a JP2 file in jp2.c
++ [GB] Previous, home, and next frame buttons for exploring MJ2 files in OPJViewer
+
+June 18, 2007
+* [GB] Reload image doesn't crash in OPJViewer; more settings saved to registry
+ 
+June 16, 2007
++ [GB] Possibility to disable parsing in OPJViewer; also, saves common settings to the registry
+
+June 15, 2007
+* [FOD] Fixed the generation of index files 
+
+
 ----------------------
 MAY 4, 2007
 VERSION 1.2.0 RELEASED
@@ -21,13 +218,16 @@
 * [FOD] Fixed the parameters used for cinema compression (9-7 transform used instead of 5-3). Modified "image_to_j2k.c"
 
 May 24, 2007
-* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker the value of numlayers and numresolution.
+* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker 
+		the value of numlayers and numresolution.
 
 May 23, 2007
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This makes the t1 data arrays dynamic, which greatly reduces cache thrashing. Also, some minor cleanup to prevent unnecessary casts"
 
 May 22, 2007
-! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, 
+		so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix 
+		increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This changes the flag code in t1 to use a flag_t type, which can then be changed to reduce RAM usage. It is now typedef to a short."
 ! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This patch makes the t1 LUTs static. I actually intend this as a prelude to possibly eliminating some or all of the LUTs entirely."
 
@@ -76,14 +276,17 @@
 * [Parvatha] Equation to check multiple tile precincts. Modification pi.c
 ! [Parvatha] array size generation of pi->include in pi_initialise_encode().Modification in pi.c
 * [Parvatha] modification in pi_create_encode for tile part generation.Modification in pi.c
-+ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
++ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. 
+			 This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
 
 March 28, 2007
 * [FOD] Fixed an historical bug in t1.c that leaded to the inclusion of useless 0xFF in the codestream. Thanks to Sylvain, Pascal and Parvatha !
 
 March 27, 2007
-+ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
-* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
++ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; 
+		can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
+* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, 
+		have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
 + [GB] Added linking to TIFF library in the JPWL VC6 workspaces
 
 March 23, 2007
@@ -129,7 +332,8 @@
 ----------------------
 
 February 23, 2007
-* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
+* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. 
+		As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
 + [GB] Linux makefile for the JPWL module; newlines at end of JPWL files
 
 February 22, 2007
diff -urN /home/robin/sldeb/trunk/CMakeLists.txt ./CMakeLists.txt
--- /home/robin/sldeb/trunk/CMakeLists.txt	2006-07-22 04:47:02.000000000 +0100
+++ ./CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
@@ -7,8 +7,7 @@
 # For this purpose you can define a CMake var: OPENJPEG_NAMESPACE to whatever you like
 # e.g.:
 # SET(OPENJPEG_NAMESPACE "GDCMOPENJPEG")
-PROJECT(OPENJPEG C)
-CMAKE_MINIMUM_REQUIRED(VERSION 2.2)
+CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
 
 IF(NOT OPENJPEG_NAMESPACE)
   SET(OPENJPEG_NAMESPACE "OPENJPEG")
@@ -17,24 +16,38 @@
 # In all cases:
 STRING(TOLOWER ${OPENJPEG_NAMESPACE} OPENJPEG_LIBRARY_NAME)
 
-PROJECT(${JPEG_NAMESPACE} C)
+PROJECT(${OPENJPEG_NAMESPACE} C)
 
 # Do full dependency headers.
 INCLUDE_REGULAR_EXPRESSION("^.*$")
 
 #-----------------------------------------------------------------------------
-# OPENJPEG version number, usefull for packaging and doxygen doc:
-SET(OPENJPEG_MAJOR_VERSION 1)
-SET(OPENJPEG_MINOR_VERSION 0)
-SET(OPENJPEG_BUILD_VERSION 0)
+# OPENJPEG version number, useful for packaging and doxygen doc:
+SET(OPENJPEG_VERSION_MAJOR 1)
+SET(OPENJPEG_VERSION_MINOR 2)
+SET(OPENJPEG_VERSION_BUILD 0)
 SET(OPENJPEG_VERSION
-  "${OPENJPEG_MAJOR_VERSION}.${OPENJPEG_MINOR_VERSION}.${OPENJPEG_BUILD_VERSION}")
+  "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}")
+
+# This setting of SOVERSION assumes that any API change
+# will increment either the minor or major version number of openjpeg
+SET(OPENJPEG_LIBRARY_PROPERTIES
+  VERSION   "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}"
+  SOVERSION "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}"
+)
+
 
 #-----------------------------------------------------------------------------
 # OpenJPEG build configuration options.
 OPTION(BUILD_SHARED_LIBS "Build OpenJPEG with shared libraries." OFF)
 
 #-----------------------------------------------------------------------------
+SET (EXECUTABLE_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all executables.")
+SET (LIBRARY_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all libraries.")
+MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH)
+
+
+#-----------------------------------------------------------------------------
 # For the codec...
 OPTION(BUILD_EXAMPLES "Build the Examples (codec...)." OFF)
 
@@ -53,7 +66,19 @@
 INCLUDE_DIRECTORIES(BEFORE ${CMAKE_CURRENT_BINARY_DIR})
 SUBDIRS(
   libopenjpeg
+  mj2
+  # cmake 2.4.5 has poor java support
+  #j2kviewer/src
   )
+
+IF(NOT UNIX)
+SUBDIRS(
+  jpwl
+  jp3d
+  indexer_JPIP
+  )
+ENDIF(NOT UNIX)
+
 #-----------------------------------------------------------------------------
 # Build example only if requested
 IF(BUILD_EXAMPLES)
@@ -61,8 +86,15 @@
 ENDIF(BUILD_EXAMPLES)
 
 #-----------------------------------------------------------------------------
+# For the documentation
+OPTION(BUILD_DOCUMENTATION "Build the doxygen documentation" OFF)
+IF(BUILD_DOCUMENTATION)
+  SUBDIRS(doc)
+ENDIF(BUILD_DOCUMENTATION)
+
+#-----------------------------------------------------------------------------
 # For openjpeg team if they ever want Dart+CMake
-IF(OPJ_STANDALONE)
+IF(OPENJPEG_STANDALONE)
   INCLUDE(Dart)
   MARK_AS_ADVANCED(BUILD_TESTING DART_ROOT TCL_TCLSH)
   IF(BUILD_TESTING)
@@ -70,8 +102,25 @@
     SET(BUILDNAME "OpenJPEG-${CMAKE_SYSTEM}-${CMAKE_C_COMPILER}" CACHE STRING "Name of build on the dashboard")
     MARK_AS_ADVANCED(BUILDNAME)
   ENDIF(BUILD_TESTING)
-ENDIF(OPJ_STANDALONE)
+ENDIF(OPENJPEG_STANDALONE)
 
-# TODO, technically we should add tests, e.g:
+# Adding test with dataset from:
 # http://www.crc.ricoh.com/~gormish/jpeg2000conformance/
+# http://www.jpeg.org/jpeg2000guide/testimages/testimages.html
+
+#-----------------------------------------------------------------------------
+# Adding JPEG2000_CONFORMANCE_DATA_ROOT
+FIND_PATH(JPEG2000_CONFORMANCE_DATA_ROOT testimages.html
+  ${OPENJPEG_SOURCE_DIR}/../jpeg2000testimages
+  $ENV{JPEG2000_CONFORMANCE_DATA_ROOT}
+)
+
+#-----------------------------------------------------------------------------
+# Compiler specific flags:
+IF(CMAKE_COMPILER_IS_GNUCC)
+  # For all builds, make sure openjpeg is std99 compliant:
+  SET(CMAKE_C_FLAGS "-Wall -std=c99 ${CMAKE_C_FLAGS}")
+  # Do not use ffast-math for all build, it would produce incorrect results, only set for release:
+  SET(CMAKE_C_FLAGS_RELEASE "-ffast-math ${CMAKE_C_FLAGS_RELEASE}")
+ENDIF(CMAKE_COMPILER_IS_GNUCC)
 
diff -urN /home/robin/sldeb/trunk/codec/CMakeLists.txt ./codec/CMakeLists.txt
--- /home/robin/sldeb/trunk/codec/CMakeLists.txt	2007-03-01 14:39:31.000000000 +0000
+++ ./codec/CMakeLists.txt	2007-11-27 22:39:51.000000000 +0000
@@ -3,7 +3,9 @@
 # First thing define the common source:
 SET(common_SRCS
   convert.c
-  )
+  index.c
+)
+
 # Then check if getopt is present:
 INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
 SET(DONT_HAVE_GETOPT 1)
@@ -24,7 +26,6 @@
   )
 ENDIF(DONT_HAVE_GETOPT)
 
-
 # Headers file are located here:
 INCLUDE_DIRECTORIES(
   ${OPENJPEG_SOURCE_DIR}/libopenjpeg
@@ -42,12 +43,26 @@
 FOREACH(exe j2k_to_image image_to_j2k)
   ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
   TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjpeg ${TIFF_LIBRARIES})
+  ADD_TEST(${exe} ${EXECUTABLE_OUTPUT_PATH}/${exe})
+  # calling those exe without option will make them fail always:
+  SET_TESTS_PROPERTIES(${exe} PROPERTIES WILL_FAIL TRUE)
   # On unix you need to link to the math library:
   IF(UNIX)
-    TARGET_LINK_LIBRARIES(${exe} -lm)
+    TARGET_LINK_LIBRARIES(${exe} m)
   ENDIF(UNIX)
   # Install exe
   INSTALL_TARGETS(/bin/ ${exe})
 ENDFOREACH(exe)
 
+# Do testing here, once we know the examples are being built:
+FILE(GLOB_RECURSE OPENJPEG_DATA_IMAGES_GLOB
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2k"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2c"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.jp2"
+  )
+
+FOREACH(filename ${OPENJPEG_DATA_IMAGES_GLOB})
+  GET_FILENAME_COMPONENT(filename_temp ${filename} NAME)
+  ADD_TEST(j2i-${filename_temp} ${EXECUTABLE_OUTPUT_PATH}/j2k_to_image -i ${filename} -o ${filename_temp}.tif)
+ENDFOREACH(filename)
 
diff -urN /home/robin/sldeb/trunk/codec/compat/getopt.c ./codec/compat/getopt.c
--- /home/robin/sldeb/trunk/codec/compat/getopt.c	2007-06-04 14:23:26.000000000 +0100
+++ ./codec/compat/getopt.c	2007-09-28 11:33:51.000000000 +0100
@@ -251,7 +251,7 @@
 		
 		}// end of single character
 	}//end '-'
-	fprintf(stderr,"Invalid option %s\n");
+	fprintf(stderr,"Invalid option\n");
 	++optind;
 	return (BADCH);;
 }//end function
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/all-wcprops ./codec/compat/.svn/all-wcprops
--- /home/robin/sldeb/trunk/codec/compat/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/all-wcprops	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,17 @@
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/412/trunk/codec/compat
+END
+getopt.c
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/412/trunk/codec/compat/getopt.c
+END
+getopt.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/368/trunk/codec/compat/getopt.h
+END
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/entries ./codec/compat/.svn/entries
--- /home/robin/sldeb/trunk/codec/compat/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,54 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/codec/compat
+http://www.openjpeg.org/svn
+
+
+
+2007-08-20T15:20:42.837462Z
+412
+devaux
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+getopt.c
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+46ed3ca229572286c9d3165b4309f2cc
+2007-08-20T15:20:42.837462Z
+412
+devaux
+has-props
+
+getopt.h
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+29fbdbaf30390463db77bab55f1fab00
+2007-03-29T14:15:14.171533Z
+368
+elangovan
+has-props
+
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/format ./codec/compat/.svn/format
--- /home/robin/sldeb/trunk/codec/compat/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/format	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/prop-base/getopt.c.svn-base ./codec/compat/.svn/prop-base/getopt.c.svn-base
--- /home/robin/sldeb/trunk/codec/compat/.svn/prop-base/getopt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/prop-base/getopt.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/prop-base/getopt.h.svn-base ./codec/compat/.svn/prop-base/getopt.h.svn-base
--- /home/robin/sldeb/trunk/codec/compat/.svn/prop-base/getopt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/prop-base/getopt.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/text-base/getopt.c.svn-base ./codec/compat/.svn/text-base/getopt.c.svn-base
--- /home/robin/sldeb/trunk/codec/compat/.svn/text-base/getopt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/text-base/getopt.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,257 @@
+/*
+ * Copyright (c) 1987, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* last review : october 29th, 2002 */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
+#endif				/* LIBC_SCCS and not lint */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int opterr = 1,			/* if error message should be printed */
+ optind = 1,			/* index into parent argv vector */
+ optopt,			/* character checked for validity */
+ optreset;			/* reset getopt */
+const char *optarg;			/* argument associated with option */
+
+typedef struct option
+{
+	char *name;
+	int has_arg;
+	int *flag;
+	int val;
+}option_t;
+
+#define	BADCH	(int)'?'
+#define	BADARG	(int)':'
+#define	EMSG	""
+
+
+
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ */
+int getopt(int nargc, char *const *nargv, const char *ostr) {
+#  define __progname nargv[0]
+  static const char *place = EMSG;	/* option letter processing */
+  char *oli;			/* option letter list index */
+
+  if (optreset || !*place) {	/* update scanning pointer */
+    optreset = 0;
+    if (optind >= nargc || *(place = nargv[optind]) != '-') {
+      place = EMSG;
+      return (-1);
+    }
+    if (place[1] && *++place == '-') {	/* found "--" */
+      ++optind;
+      place = EMSG;
+      return (-1);
+    }
+  }				/* option letter okay? */
+  if ((optopt = (int) *place++) == (int) ':' ||
+      !(oli = strchr(ostr, optopt))) {
+    /*
+     * if the user didn't specify '-' as an option,
+     * assume it means -1.
+     */
+    if (optopt == (int) '-')
+      return (-1);
+    if (!*place)
+      ++optind;
+		if (opterr && *ostr != ':') {
+      fprintf(stderr,
+		     "%s: illegal option -- %c\n", __progname, optopt);
+			return (BADCH);
+		}
+  }
+  if (*++oli != ':') {		/* don't need argument */
+    optarg = NULL;
+    if (!*place)
+      ++optind;
+  } else {			/* need an argument */
+    if (*place)			/* no white space */
+      optarg = place;
+    else if (nargc <= ++optind) {	/* no arg */
+      place = EMSG;
+      if (*ostr == ':')
+	return (BADARG);
+			if (opterr) {
+				fprintf(stderr,
+		       "%s: option requires an argument -- %c\n",
+		       __progname, optopt);
+				return (BADCH);
+			}
+    } else			/* white space */
+      optarg = nargv[optind];
+    place = EMSG;
+    ++optind;
+  }
+  return (optopt);		/* dump back option letter */
+}
+
+
+int getopt_long(int argc, char * const argv[], const char *optstring,
+struct option *longopts, int totlen) {
+	static int lastidx,lastofs;
+	char *tmp;
+	int i,len;
+	char param = 1;
+
+again:
+	if (optind>argc || !argv[optind] || *argv[optind]!='-')
+		return -1;
+
+	if (argv[optind][0]=='-' && argv[optind][1]==0) {
+		if(optind >= (argc - 1)){ /* no more input parameters */
+			param = 0;
+		}
+		else{ /* more input parameters */
+			if(argv[optind + 1][0] == '-'){
+				param = 0; /* Missing parameter after '-' */
+			}
+			else{
+				param = 2;
+			}
+		}
+	}
+
+	if (param == 0) {
+		++optind;
+		return (BADCH);
+	}
+
+	if (argv[optind][0]=='-') {	/* long option */
+		char* arg=argv[optind]+1;
+		const struct option* o;
+		o=longopts;
+		len=sizeof(longopts[0]);
+
+		if (param > 1){
+			arg = argv[optind+1];
+			optind++;
+		}
+		else
+			arg = argv[optind]+1;
+
+		if(strlen(arg)>1){
+			for (i=0;i<totlen;i=i+len,o++) {
+				if (!strcmp(o->name,arg)) {	/* match */
+					if (o->has_arg == 0) {
+						if ((argv[optind+1])&&(!(argv[optind+1][0]=='-'))){
+							fprintf(stderr,"%s: option does not require an argument. Ignoring %s\n",arg,argv[optind+1]);
+							++optind;
+						}
+					}else{ 
+						optarg=argv[optind+1];
+						if(optarg){
+							if (optarg[0] == '-'){ /* Has read next input parameter: No arg for current parameter */								
+								if (opterr) {
+									fprintf(stderr,"%s: option requires an argument\n",arg);
+									return (BADCH);
+								}
+							}
+						}
+						if (!optarg && o->has_arg==1) {	/* no argument there */
+							if (opterr) {
+								fprintf(stderr,"%s: option requires an argument \n",arg);
+								return (BADCH);
+							}
+						}
+						++optind;
+					}
+					++optind;
+					if (o->flag)
+						*(o->flag)=o->val;
+					else
+						return o->val;
+					return 0;
+				}
+			}//(end for)String not found in the list
+			fprintf(stderr,"Invalid option %s\n",arg);
+			++optind;
+			return (BADCH);
+		}else{ /*Single character input parameter*/
+			if (*optstring==':') return ':';
+			if (lastidx!=optind) {
+				lastidx=optind; lastofs=0;
+			}
+			optopt=argv[optind][lastofs+1];
+			if ((tmp=strchr(optstring,optopt))) {/*Found input parameter in list*/
+				if (*tmp==0) {	/* apparently, we looked for \0, i.e. end of argument */
+					++optind;
+					goto again;
+				}
+				if (tmp[1]==':') {	/* argument expected */
+					if (tmp[2]==':' || argv[optind][lastofs+2]) {	/* "-foo", return "oo" as optarg */
+						if (!*(optarg=argv[optind]+lastofs+2)) optarg=0;
+						goto found;
+					}
+					optarg=argv[optind+1];
+					if(optarg){
+						if (optarg[0] == '-'){ /* Has read next input parameter: No arg for current parameter */
+							if (opterr) {
+								fprintf(stderr,"%s: option requires an argument\n",arg);
+								return (BADCH);
+							}
+						}
+					}
+					if (!optarg) {	/* missing argument */
+						if (opterr) {
+							fprintf(stderr,"%s: option requires an argument\n",arg);
+							return (BADCH);
+						}
+					}
+					++optind;
+				}else {/*Argument not expected*/
+					++lastofs;
+					return optopt;
+				}
+found:
+				++optind;
+				return optopt;
+			}	else {	/* not found */
+				fprintf(stderr,"Invalid option %s\n",arg);
+				++optind;
+				return (BADCH);
+			}//end of not found
+		
+		}// end of single character
+	}//end '-'
+	fprintf(stderr,"Invalid option\n");
+	++optind;
+	return (BADCH);;
+}//end function
diff -urN /home/robin/sldeb/trunk/codec/compat/.svn/text-base/getopt.h.svn-base ./codec/compat/.svn/text-base/getopt.h.svn-base
--- /home/robin/sldeb/trunk/codec/compat/.svn/text-base/getopt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/compat/.svn/text-base/getopt.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,29 @@
+/* last review : october 29th, 2002 */
+
+#ifndef _GETOPT_H_
+#define _GETOPT_H_
+
+typedef struct option
+{
+	char *name;
+	int has_arg;
+	int *flag;
+	int val;
+}option_t;
+
+#define	NO_ARG	0
+#define REQ_ARG	1
+#define OPT_ARG	2
+
+extern int opterr;
+extern int optind;
+extern int optopt;
+extern int optreset;
+extern char *optarg;
+
+extern int getopt(int nargc, char *const *nargv, const char *ostr);
+extern int getopt_long(int argc, char * const argv[], const char *optstring,
+			const struct option *longopts, int totlen);
+
+
+#endif				/* _GETOPT_H_ */
diff -urN /home/robin/sldeb/trunk/codec/convert.c ./codec/convert.c
--- /home/robin/sldeb/trunk/codec/convert.c	2007-06-04 14:23:26.000000000 +0100
+++ ./codec/convert.c	2007-11-27 22:39:51.000000000 +0000
@@ -34,6 +34,7 @@
 #include <string.h>
 #include "openjpeg.h"
 #include "../libs/libtiff/tiffio.h"
+#include "convert.h"
 
 /*
  * Get logarithm of an integer and round downwards.
@@ -66,6 +67,300 @@
 	return (a + b - 1) / b;
 }
 
+
+/* -->> -->> -->> -->>
+
+  TGA IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+// TGA header definition.
+#pragma pack(push,1) // Pack structure byte aligned
+typedef struct tga_header
+{                           
+    uint8   id_length;              /* Image id field length    */
+    uint8   colour_map_type;        /* Colour map type          */
+    uint8   image_type;             /* Image type               */
+    /*
+    ** Colour map specification
+    */
+    uint16  colour_map_index;       /* First entry index        */
+    uint16  colour_map_length;      /* Colour map length        */
+    uint8   colour_map_entry_size;  /* Colour map entry size    */
+    /*
+    ** Image specification
+    */
+    uint16  x_origin;               /* x origin of image        */
+    uint16  y_origin;               /* u origin of image        */
+    uint16  image_width;            /* Image width              */
+    uint16  image_height;           /* Image height             */
+    uint8   pixel_depth;            /* Pixel depth              */
+    uint8   image_desc;             /* Image descriptor         */
+} tga_header;
+#pragma pack(pop) // Return to normal structure packing alignment.
+
+int tga_readheader(FILE *fp, int *bits_per_pixel, int *width, int *height, int *flip_image)
+{
+	int palette_size;
+	tga_header tga ;
+
+	if (!bits_per_pixel || !width || !height || !flip_image)
+		return 0;
+	
+	// Read TGA header
+	fread((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	*bits_per_pixel = tga.pixel_depth;
+	
+	*width  = tga.image_width;
+	*height = tga.image_height ;
+
+	// Ignore tga identifier, if present ...
+	if (tga.id_length)
+	{
+		uint8 *id = (uint8 *) malloc(tga.id_length);
+		fread(id, tga.id_length, 1, fp);
+		free(id);  
+	}
+
+	// Test for compressed formats ... not yet supported ...
+	// Note :-  9 - RLE encoded palettized.
+	//	  	   10 - RLE encoded RGB.
+	if (tga.image_type > 8)
+	{
+		fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
+		return 0 ;
+	}
+
+	*flip_image = !(tga.image_desc & 32);
+
+	// Palettized formats are not yet supported, skip over the palette, if present ... 
+	palette_size = tga.colour_map_length * (tga.colour_map_entry_size/8);
+	
+	if (palette_size>0)
+	{
+		fprintf(stderr, "File contains a palette - not yet supported.");
+		fseek(fp, palette_size, SEEK_CUR);
+	}
+	return 1;
+}
+
+int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height, bool flip_image)
+{
+	tga_header tga;
+
+	if (!bits_per_pixel || !width || !height)
+		return 0;
+
+	memset(&tga, 0, sizeof(tga_header));
+
+	tga.pixel_depth = bits_per_pixel;
+	tga.image_width  = width;
+	tga.image_height = height;
+	tga.image_type = 2; // Uncompressed.
+	tga.image_desc = 8; // 8 bits per component.
+
+	if (flip_image)
+		tga.image_desc |= 32;
+
+	// Write TGA header
+	fwrite((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	return 1;
+}
+
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters) {
+	FILE *f;
+	opj_image_t *image;
+	uint32 image_width, image_height, pixel_bit_depth;
+	uint32 x, y;
+	int flip_image=0;
+	opj_image_cmptparm_t cmptparm[4];	/* maximum 4 components */
+	int numcomps;
+	OPJ_COLOR_SPACE color_space;
+	bool mono ;
+	bool save_alpha;
+	int subsampling_dx, subsampling_dy;
+	int i;	
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+
+	if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height, &flip_image))
+		return NULL;
+
+	// We currently only support 24 & 32 bit tga's ...
+	if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32)))
+		return NULL;
+
+	/* initialize image components */   
+	memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));
+
+	mono = (pixel_bit_depth == 8) || (pixel_bit_depth == 16);  // Mono with & without alpha.
+	save_alpha = (pixel_bit_depth == 16) || (pixel_bit_depth == 32); // Mono with alpha, or RGB with alpha
+
+	if (mono) {
+		color_space = CLRSPC_GRAY;
+		numcomps = save_alpha ? 2 : 1;
+	}	
+	else {
+		numcomps = save_alpha ? 4 : 3;
+		color_space = CLRSPC_SRGB;
+	}
+
+	subsampling_dx = parameters->subsampling_dx;
+	subsampling_dy = parameters->subsampling_dy;
+
+	for (i = 0; i < numcomps; i++) {
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = 0;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = image_width;
+		cmptparm[i].h = image_height;
+	}
+
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+
+	if (!image)
+		return NULL;
+
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 =	!image->x0 ? (image_width - 1) * subsampling_dx + 1 : image->x0 + (image_width - 1) * subsampling_dx + 1;
+	image->y1 =	!image->y0 ? (image_height - 1) * subsampling_dy + 1 : image->y0 + (image_height - 1) * subsampling_dy + 1;
+
+	/* set image data */
+	for (y=0; y < image_height; y++) 
+	{
+		int index;
+
+		if (flip_image)
+			index = (image_height-y-1)*image_width;
+		else
+			index = y*image_width;
+
+		if (numcomps==3)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				index++;
+			}
+		}
+		else if (numcomps==4)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b,a;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+				fread(&a, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				image->comps[3].data[index]=a;
+				index++;
+			}
+		}
+		else {
+			fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
+		}
+	}	
+	return image;
+}
+
+int imagetotga(opj_image_t * image, const char *outfile) {
+	int width, height, bpp, x, y;
+	bool write_alpha;
+	int i;
+	uint32 alpha_channel;
+	float r,g,b,a;
+	uint8 value;
+	float scale;
+	FILE *fdest;
+
+	fdest = fopen(outfile, "wb");
+	if (!fdest) {
+		fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+		return 1;
+	}
+
+	for (i = 0; i < image->numcomps-1; i++)	{
+		if ((image->comps[0].dx != image->comps[i+1].dx) 
+			||(image->comps[0].dy != image->comps[i+1].dy) 
+			||(image->comps[0].prec != image->comps[i+1].prec))	{
+      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
+      return 1;
+   }
+	}
+
+	width = image->comps[0].w;
+	height = image->comps[0].h; 
+
+	// Mono with alpha, or RGB with alpha.
+	write_alpha = (image->numcomps==2) || (image->numcomps==4);   
+
+	// Write TGA header 
+	bpp = write_alpha ? 32 : 24;
+	if (!tga_writeheader(fdest, bpp, width , height, true))
+		return 1;
+
+	alpha_channel = image->numcomps-1; 
+
+	scale = 255.0f / (float)((1<<image->comps[0].prec)-1);
+
+	for (y=0; y < height; y++) {
+		uint32 index=y*width;
+
+		for (x=0; x < width; x++, index++)	{
+			r = (float)(image->comps[0].data[index]);
+
+			if (image->numcomps>2) {
+				g = (float)(image->comps[1].data[index]);
+				b = (float)(image->comps[2].data[index]);
+			}
+			else  {// Greyscale ...
+				g = r;
+				b = r;
+			}
+
+			// TGA format writes BGR ...
+			value = (uint8)(b*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(g*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(r*scale);
+			fwrite(&value,1,1,fdest);
+
+			if (write_alpha) {
+				a = (float)(image->comps[alpha_channel].data[index]);
+				value = (uint8)(a*scale);
+				fwrite(&value,1,1,fdest);
+			}
+		}
+	}
+
+	return 0;
+}
+
 /* -->> -->> -->> -->>
 
   BMP IMAGE FORMAT
@@ -469,9 +764,10 @@
 }
 
 int imagetobmp(opj_image_t * image, const char *outfile) {
-	int w, wr, h, hr;
+	int w, h;
 	int i, pad;
 	FILE *fdest = NULL;
+	int adjustR, adjustG, adjustB;
 
 	if (image->numcomps == 3 && image->comps[0].dx == image->comps[1].dx
 		&& image->comps[1].dx == image->comps[2].dx
@@ -490,64 +786,81 @@
 			return 1;
 		}
 	    
-		/* w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), image->comps[0].dx); */
-		w = image->comps[0].w;
-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
+		w = image->comps[0].w;	    
 		h = image->comps[0].h;
-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		fprintf(fdest, "BM");
 	    
 		/* FILE HEADER */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c",
-			(unsigned char) (hr * wr * 3 + 3 * hr * (wr % 2) + 54) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 8) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 16) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)	>> 24) & 0xff);
+			(unsigned char) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
 	    
 		/* INFO HEADER   */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
-			(unsigned char) ((wr) >> 8) & 0xff,
-			(unsigned char) ((wr) >> 16) & 0xff,
-			(unsigned char) ((wr) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
-			(unsigned char) ((hr) >> 8) & 0xff,
-			(unsigned char) ((hr) >> 16) & 0xff,
-			(unsigned char) ((hr) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
 		fprintf(fdest, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * hr * wr + 3 * hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 8) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 16) & 0xff,
-			(unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * h * w + 3 * h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 	    
-		for (i = 0; i < wr * hr; i++) {
-			unsigned char R, G, B;
-			/* a modifier */
-			/* R = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			R = image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			/* G = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			G = image->comps[1].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			/* B = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]; */
-			B = image->comps[2].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
-			fprintf(fdest, "%c%c%c", B, G, R);
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc, gc, bc;
+			int r, g, b;
+							
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+			b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+
+			fprintf(fdest, "%c%c%c", bc, gc, rc);
 			
-			if ((i + 1) % wr == 0) {
-				for (pad = (3 * wr) % 4 ? 4 - (3 * wr) % 4 : 0; pad > 0; pad--)	/* ADD */
+			if ((i + 1) % w == 0) {
+				for (pad = (3 * w) % 4 ? 4 - (3 * w) % 4 : 0; pad > 0; pad--)	/* ADD */
 					fprintf(fdest, "%c", 0);
 			}
 		}
@@ -559,24 +872,17 @@
 		<<-- <<-- <<-- <<-- */
 
 		fdest = fopen(outfile, "wb");
-		/* w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), image->comps[0].dx); */
-		w = image->comps[0].w;
-		wr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
+		w = image->comps[0].w;	    
 		h = image->comps[0].h;
-		hr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		fprintf(fdest, "BM");
 	    
 		/* FILE HEADER */
 		/* ------------- */
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + 54 + 1024 + hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 8) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + hr * (wr % 2)) >> 16) & 0xff,
-			(unsigned char) ((hr * wr + 54 + 1024 + wr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, 
 			((54 + 1024) >> 16) & 0xff,
@@ -585,38 +891,47 @@
 		/* INFO HEADER */
 		/* ------------- */
 		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
-			(unsigned char) ((wr) >> 8) & 0xff,
-			(unsigned char) ((wr) >> 16) & 0xff,
-			(unsigned char) ((wr) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
-			(unsigned char) ((hr) >> 8) & 0xff,
-			(unsigned char) ((hr) >> 16) & 0xff,
-			(unsigned char) ((hr) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
 		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
 		fprintf(fdest, "%c%c", (8) & 0xff, ((8) >> 8) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
-		fprintf(fdest, "%c%c%c%c", (unsigned char) (hr * wr + hr * (wr % 2)) & 0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 8) &	0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 16) &	0xff,
-			(unsigned char) ((hr * wr + hr * (wr % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 8) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 16) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
 		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
 
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+
 		for (i = 0; i < 256; i++) {
 			fprintf(fdest, "%c%c%c%c", i, i, i, 0);
 		}
 
-		for (i = 0; i < wr * hr; i++) {
-			/* a modifier !! */
-			/* fprintf(fdest, "%c", image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)]); */
-			fprintf(fdest, "%c", image->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)]);
-			/*if (((i + 1) % w == 0 && w % 2))
-			fprintf(fdest, "%c", 0); */
-			if ((i + 1) % wr == 0) {
-				for (pad = wr % 4 ? 4 - wr % 4 : 0; pad > 0; pad--)	/* ADD */
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc;
+			int r;
+			
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			
+			fprintf(fdest, "%c", rc);
+
+			if ((i + 1) % w == 0) {
+				for (pad = w % 4 ? 4 - w % 4 : 0; pad > 0; pad--)	/* ADD */
 					fprintf(fdest, "%c", 0);
 			}
 		}
@@ -777,7 +1092,7 @@
 }
 
 int imagetopgx(opj_image_t * image, const char *outfile) {
-	int w, wr, h, hr;
+	int w, h;
 	int i, j, compno;
 	FILE *fdest = NULL;
 
@@ -812,17 +1127,11 @@
     if( total > 256 ) {
       free(name);
       }
-		/* w = int_ceildiv(image->x1 - image->x0, comp->dx); */
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor), comp->dx); */
+
 		w = image->comps[compno].w;
-		wr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
-	    
-		/* h = int_ceildiv(image->y1 - image->y0, comp->dy); */
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), comp->dy); */
 		h = image->comps[compno].h;
-		hr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
 	    
-		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, wr, hr);
+		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, w, h);
 		if (comp->prec <= 8) {
 			nbytes = 1;
 		} else if (comp->prec <= 16) {
@@ -830,8 +1139,8 @@
 		} else {
 			nbytes = 4;
 		}
-		for (i = 0; i < wr * hr; i++) {
-			int v = image->comps[compno].data[i / wr * w + i % wr];
+		for (i = 0; i < w * h; i++) {
+			int v = image->comps[compno].data[i];
 			for (j = nbytes - 1; j >= 0; j--) {
 				char byte = (char) (v >> (j * 8));
 				fwrite(&byte, 1, 1, fdest);
@@ -949,9 +1258,9 @@
 }
 
 int imagetopnm(opj_image_t * image, const char *outfile) {
-	int w, wr, wrr, h, hr, hrr, max;
+	int w, wr, h, hr, max;
 	int i, compno;
-	int adjust;
+	int adjustR, adjustG, adjustB, adjustX;
 	FILE *fdest = NULL;
 	char S2;
 	const char *tmp = outfile;
@@ -978,43 +1287,60 @@
 		}
 
 		w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
-		/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor),image->comps[0].dx); */
 		wr = image->comps[0].w;
-		wrr = int_ceildivpow2(image->comps[0].w, image->comps[0].factor);
         
 		h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
-		/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[0].dy); */
 		hr = image->comps[0].h;
-		hrr = int_ceildivpow2(image->comps[0].h, image->comps[0].factor);
 	    
 		max = image->comps[0].prec > 8 ? 255 : (1 << image->comps[0].prec) - 1;
 	    
 		image->comps[0].x0 = int_ceildivpow2(image->comps[0].x0 - int_ceildiv(image->x0, image->comps[0].dx), image->comps[0].factor);
 		image->comps[0].y0 = int_ceildivpow2(image->comps[0].y0 -	int_ceildiv(image->y0, image->comps[0].dy), image->comps[0].factor);
 
-		fprintf(fdest, "P6\n%d %d\n%d\n", wrr, hrr, max);
-		adjust = image->comps[0].prec > 8 ? image->comps[0].prec - 8 : 0;
-		for (i = 0; i < wrr * hrr; i++) {
+		fprintf(fdest, "P6\n%d %d\n%d\n", wr, hr, max);
+
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("PNM CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("PNM CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("PNM CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+
+		for (i = 0; i < wr * hr; i++) {
 			int r, g, b;
 			unsigned char rc,gc,bc;
-			r = image->comps[0].data[i / wrr * wr + i % wrr];
+			r = image->comps[0].data[i];
 			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
-			rc = (unsigned char) ((r >> adjust)+((r >> (adjust-1))%2));
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
 
-			g = image->comps[1].data[i / wrr * wr + i % wrr];
+			g = image->comps[1].data[i];
 			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
-			gc = (unsigned char) ((g >> adjust)+((g >> (adjust-1))%2));
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
 			
-			b = image->comps[2].data[i / wrr * wr + i % wrr];
+			b = image->comps[2].data[i];
 			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
-			bc = (unsigned char) ((b >> adjust)+((b >> (adjust-1))%2));
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
 			
 			fprintf(fdest, "%c%c%c", rc, gc, bc);
 		}
 		fclose(fdest);
+
 	} else {
 		int ncomp=(S2=='g' || S2=='G')?1:image->numcomps;
-		if (image->numcomps>ncomp) {
+		if (image->numcomps > ncomp) {
 			fprintf(stderr,"WARNING -> [PGM files] Only the first component\n");
 			fprintf(stderr,"           is written to the file\n");
 		}
@@ -1033,29 +1359,31 @@
 			}
             
 			w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
-			/* wr = int_ceildiv(int_ceildivpow2(image->x1 - image->x0,image->factor),image->comps[compno].dx); */
 			wr = image->comps[compno].w;
-			wrr = int_ceildivpow2(image->comps[compno].w, image->comps[compno].factor);
 			
 			h = int_ceildiv(image->y1 - image->y0, image->comps[compno].dy);
-			/* hr = int_ceildiv(int_ceildivpow2(image->y1 - image->y0,image->factor), image->comps[compno].dy); */
 			hr = image->comps[compno].h;
-			hrr = int_ceildivpow2(image->comps[compno].h, image->comps[compno].factor);
 			
 			max = image->comps[compno].prec > 8 ? 255 : (1 << image->comps[compno].prec) - 1;
 			
 			image->comps[compno].x0 = int_ceildivpow2(image->comps[compno].x0 - int_ceildiv(image->x0, image->comps[compno].dx), image->comps[compno].factor);
 			image->comps[compno].y0 = int_ceildivpow2(image->comps[compno].y0 - int_ceildiv(image->y0, image->comps[compno].dy), image->comps[compno].factor);
 			
-			fprintf(fdest, "P5\n%d %d\n%d\n", wrr, hrr, max);
-			adjust = image->comps[compno].prec > 8 ? image->comps[compno].prec - 8 : 0;
-
-			for (i = 0; i < wrr * hrr; i++) {
+			fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
+			
+			if (image->comps[compno].prec > 8) {
+				adjustX = image->comps[0].prec - 8;
+				printf("PNM CONVERSION: Truncating component %d from %d bits to 8 bits\n",compno, image->comps[compno].prec);
+			}
+			else 
+				adjustX = 0;
+			
+			for (i = 0; i < wr * hr; i++) {
 				int l;
 				unsigned char lc;
-				l = image->comps[compno].data[i / wrr * wr + i % wrr];
+				l = image->comps[compno].data[i];
 				l += (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);
-				lc = (unsigned char) ((l >> adjust)+((l >> (adjust-1))%2));
+				lc = (unsigned char) ((l >> adjustX)+((l >> (adjustX-1))%2));
 				fprintf(fdest, "%c", lc);
 			}
 			fclose(fdest);
@@ -1082,8 +1410,9 @@
 }tiff_infoheader_t;
 
 int imagetotif(opj_image_t * image, const char *outfile) {
-	int width, height;
-	int bps,index;
+	int width, height, imgsize;
+	int bps,index,adjust = 0;
+	int last_i=0;
 	TIFF *tif;
 	tdata_t buf;
 	tstrip_t strip;
@@ -1107,7 +1436,8 @@
 			}
 
 			width	= image->comps[0].w;
-			height= image->comps[0].h;
+			height	= image->comps[0].h;
+			imgsize = width * height ;
 			bps		= image->comps[0].prec;
 			/* Set tags */
 			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
@@ -1120,43 +1450,166 @@
 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
 
 			/* Get a buffer for the data */
-			buf = _TIFFmalloc(TIFFStripSize(tif));
-			index=0;
-			strip_size=0;
 			strip_size=TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index=0;		
+			adjust = image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0;
 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 				unsigned char *dat8;
-				int i;
+				int i, ssize;
+				ssize = TIFFStripSize(tif);
 				dat8 = buf;
 				if (image->comps[0].prec == 8){
-					for (i=0; i<TIFFStripSize(tif); i+=3) {	// 8 bits per pixel 
-						dat8[i+0] = image->comps[0].data[index] ;	// R 
-						dat8[i+1] = image->comps[1].data[index] ;	// G 
-						dat8[i+2] = image->comps[2].data[index] ;	// B 
-						index++;
+					for (i=0; i<ssize-2; i+=3) {	// 8 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){			
+								r += adjust;
+								g += adjust;
+								b += adjust;
+							}
+							dat8[i+0] = r ;	// R 
+							dat8[i+1] = g ;	// G 
+							dat8[i+2] = b ;	// B 
+							index++;
+							last_i = i+3;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i=last_i; i<ssize; i+=3) {	// 8 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){			
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] = r ;	// R 
+								if(i+1 <ssize) dat8[i+1] = g ;	else break;// G 
+								if(i+2 <ssize) dat8[i+2] = b ;	else break;// B 
+								index++;
+							}else
+								break;
+						}
 					}
 				}else if (image->comps[0].prec == 12){
-					for (i=0; i<TIFFStripSize(tif); i+=9) {	// 12 bits per pixel 
-						dat8[i+0] = (image->comps[0].data[index]>>8)<<4 | (image->comps[0].data[index]>>4);
-						dat8[i+1] = (image->comps[0].data[index]<<4)|((image->comps[1].data[index]>>8)& 0x0f);
-						dat8[i+2] = (image->comps[1].data[index]);
-						dat8[i+3] = (image->comps[2].data[index]>>8)<<4 | (image->comps[2].data[index]>>4);
-						dat8[i+4] = (image->comps[2].data[index]<<4)|((image->comps[1].data[index+1]>>8)& 0x0f);
-						dat8[i+5] = (image->comps[0].data[index+1]);
-						dat8[i+6] = (image->comps[1].data[index+1]>>8)<<4 | (image->comps[1].data[index+1]>>4);
-						dat8[i+7] = (image->comps[1].data[index+1]<<4)|((image->comps[2].data[index+1]>>8)& 0x0f);
-						dat8[i+8] = (image->comps[2].data[index+1]);
-						index+=2;
+					for (i=0; i<ssize-8; i+=9) {	// 12 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						int r1 = 0,g1 = 0,b1 = 0;
+						if((index < imgsize)&(index+1 < imgsize)){
+							r  = image->comps[0].data[index];
+							g  = image->comps[1].data[index];
+							b  = image->comps[2].data[index];
+							r1 = image->comps[0].data[index+1];
+							g1 = image->comps[1].data[index+1];
+							b1 = image->comps[2].data[index+1];
+							if (image->comps[0].sgnd){														
+								r  += adjust;
+								g  += adjust;
+								b  += adjust;
+								r1 += adjust;
+								g1 += adjust;
+								b1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f);
+							dat8[i+2] = g ;		
+							dat8[i+3] = (b >> 4);
+							dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+5] = r1;		
+							dat8[i+6] = (g1 >> 4);
+							dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);
+							dat8[i+8] = b1;
+							index+=2;
+							last_i = i+9;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i= last_i; i<ssize; i+=9) {	// 12 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							int r1 = 0,g1 = 0,b1 = 0;
+							if((index < imgsize)&(index+1 < imgsize)){
+								r  = image->comps[0].data[index];
+								g  = image->comps[1].data[index];
+								b  = image->comps[2].data[index];
+								r1 = image->comps[0].data[index+1];
+								g1 = image->comps[1].data[index+1];
+								b1 = image->comps[2].data[index+1];
+								if (image->comps[0].sgnd){														
+									r  += adjust;
+									g  += adjust;
+									b  += adjust;
+									r1 += adjust;
+									g1 += adjust;
+									b1 += adjust;
+								}
+								dat8[i+0] = (r >> 4);
+								if(i+1 <ssize) dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f); else break;
+								if(i+2 <ssize) dat8[i+2] = g ;			else break;
+								if(i+3 <ssize) dat8[i+3] = (b >> 4);	else break;
+								if(i+4 <ssize) dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);else break;
+								if(i+5 <ssize) dat8[i+5] = r1;			else break;
+								if(i+6 <ssize) dat8[i+6] = (g1 >> 4);	else break;
+								if(i+7 <ssize) dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);else break;
+								if(i+8 <ssize) dat8[i+8] = b1;			else break;
+								index+=2;
+							}else
+								break;
+						}
 					}
 				}else if (image->comps[0].prec == 16){
-					for (i=0; i<TIFFStripSize(tif); i+=6) {	// 16 bits per pixel 
-						dat8[i+0] =  image->comps[0].data[index];//LSB
-						dat8[i+1] = (image->comps[0].data[index]>> 8);//MSB	 
-						dat8[i+2] =  image->comps[1].data[index]; 
-						dat8[i+3] = (image->comps[1].data[index]>> 8);	
-						dat8[i+4] =  image->comps[2].data[index];	 
-						dat8[i+5] = (image->comps[2].data[index]>> 8); 
-						index++;
+					for (i=0 ; i<ssize-5 ; i+=6) {	// 16 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){
+							r += adjust;
+							g += adjust;
+							b += adjust;
+							}
+							dat8[i+0] =  r;//LSB
+							dat8[i+1] = (r >> 8);//MSB	 
+							dat8[i+2] =  g;		
+							dat8[i+3] = (g >> 8);
+							dat8[i+4] =  b;	
+							dat8[i+5] = (b >> 8);
+							index++;
+							last_i = i+6;
+						}else
+							break; 
+					}
+					if(last_i < ssize){
+						for (i=0 ; i<ssize ; i+=6) {	// 16 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] =  r;//LSB
+								if(i+1 <ssize) dat8[i+1] = (r >> 8);else break;//MSB	 
+								if(i+2 <ssize) dat8[i+2] =  g;		else break;
+								if(i+3 <ssize) dat8[i+3] = (g >> 8);else break;
+								if(i+4 <ssize) dat8[i+4] =  b;		else break;
+								if(i+5 <ssize) dat8[i+5] = (b >> 8);else break;
+								index++;
+							}else
+								break; 
+						}						
 					}
 				}else{
 					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
@@ -1179,7 +1632,8 @@
 			}
 
 			width	= image->comps[0].w;
-			height= image->comps[0].h;
+			height	= image->comps[0].h;
+			imgsize = width * height;
 			bps		= image->comps[0].prec;
 
 			/* Set tags */
@@ -1193,34 +1647,59 @@
 			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
 
 			/* Get a buffer for the data */
-			buf = _TIFFmalloc(TIFFStripSize(tif));
-			index = 0;
-			strip_size = 0;
 			strip_size = TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index = 0;			
 			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 				unsigned char *dat8;
 				int i;
 				dat8 = buf;
 				if (image->comps[0].prec == 8){
 					for (i=0; i<TIFFStripSize(tif); i+=1) {	// 8 bits per pixel 
-						dat8[i+0] = image->comps[0].data[index] ;
-						index++;
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							index++;
+						}else
+							break; 
 					}
 				}else if (image->comps[0].prec == 12){
 					for (i = 0; i<TIFFStripSize(tif); i+=3) {	// 12 bits per pixel 
-						dat8[i+0] = (image->comps[0].data[index]>>8)<<4 | (image->comps[0].data[index]>>4);
-						dat8[i+1] = (image->comps[0].data[index]<<4)|((image->comps[0].data[index+1]>>8)& 0x0f);
-						dat8[i+2] = (image->comps[0].data[index+1]);
-						index+=2;
+						if(index < imgsize){
+							int r = 0, r1 = 0;
+							r  = image->comps[0].data[index];
+							r1 = image->comps[0].data[index+1];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+								r1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+2] = r1 ;
+							index+=2;
+						}else
+							break; 
 					}
 				}else if (image->comps[0].prec == 16){
 					for (i=0; i<TIFFStripSize(tif); i+=2) {	// 16 bits per pixel 
-						dat8[i+0] =  image->comps[0].data[index];
-						dat8[i+1] = (image->comps[0].data[index]>> 8);
-						index++;
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							dat8[i+1] = r >> 8;
+							index++;
+						}else
+							break; 
 					}
 				}else{
-					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+					fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
 					fprintf(stderr,"Aborting\n");
 					return 1;
 				}
@@ -1229,14 +1708,14 @@
 			_TIFFfree(buf);
 			TIFFClose(tif);
 		}else{
-			fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+			fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
 			fprintf(stderr,"Aborting\n");
 			return 1;
 		}
 		return 0;
 }
 
-opj_image_t* tiftoimage(char *filename, opj_cparameters_t *parameters)
+opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters)
 {
 	int subsampling_dx = parameters->subsampling_dx;
 	int subsampling_dy = parameters->subsampling_dy;
@@ -1249,6 +1728,7 @@
 	OPJ_COLOR_SPACE color_space;
 	opj_image_cmptparm_t cmptparm[3];
 	opj_image_t * image = NULL;
+	int imgsize = 0;
 
 	tif = TIFFOpen(filename, "r");
 
@@ -1308,6 +1788,7 @@
 		strip_size=0;
 		strip_size=TIFFStripSize(tif);
 		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
 		/* Read the Image components*/
 		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 			unsigned char *dat8;
@@ -1317,43 +1798,52 @@
 
 			if (Info.tiBps==12){
 				for (i=0; i<ssize; i+=9) {	/*12 bits per pixel*/
-					image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4);
-					image->comps[1].data[index]   = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
-					image->comps[2].data[index]   = ( dat8[i+3]<<4)			|(dat8[i+4]>>4);
-					image->comps[0].data[index+1] = ((dat8[i+4]& 0x0f)<< 8)	| dat8[i+5];
-					image->comps[1].data[index+1] = ( dat8[i+6] <<4)		|(dat8[i+7]>>4);
-					image->comps[2].data[index+1] = ((dat8[i+7]& 0x0f)<< 8)	| dat8[i+8];
-					index+=2;
+					if((index < imgsize)&(index+1 < imgsize)){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4);
+						image->comps[1].data[index]   = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						image->comps[2].data[index]   = ( dat8[i+3]<<4)			|(dat8[i+4]>>4);
+						image->comps[0].data[index+1] = ((dat8[i+4]& 0x0f)<< 8)	| dat8[i+5];
+						image->comps[1].data[index+1] = ( dat8[i+6] <<4)		|(dat8[i+7]>>4);
+						image->comps[2].data[index+1] = ((dat8[i+7]& 0x0f)<< 8)	| dat8[i+8];
+						index+=2;
+					}else
+						break;
 				}
 			}
 			else if( Info.tiBps==16){
 				for (i=0; i<ssize; i+=6) {	/* 16 bits per pixel */
-					image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];	// R 
-					image->comps[1].data[index] = ( dat8[i+3] << 8 ) | dat8[i+2];	// G 
-					image->comps[2].data[index] = ( dat8[i+5] << 8 ) | dat8[i+4];	// B 
-					if(parameters->cp_cinema){/* Rounding to 12 bits*/
-						image->comps[0].data[index] = (image->comps[0].data[index] + 0x08) >> 4 ;
-						image->comps[1].data[index] = (image->comps[1].data[index] + 0x08) >> 4 ;
-						image->comps[2].data[index] = (image->comps[2].data[index] + 0x08) >> 4 ;
-					}
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0]; // R 
+						image->comps[1].data[index] = ( dat8[i+3] << 8 ) | dat8[i+2]; // G 
+						image->comps[2].data[index] = ( dat8[i+5] << 8 ) | dat8[i+4]; // B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = (image->comps[0].data[index] + 0x08) >> 4 ;
+							image->comps[1].data[index] = (image->comps[1].data[index] + 0x08) >> 4 ;
+							image->comps[2].data[index] = (image->comps[2].data[index] + 0x08) >> 4 ;
+						}
+						index++;
+					}else
+						break;
 				}
 			}
 			else if ( Info.tiBps==8){
 				for (i=0; i<ssize; i+=3) {	/* 8 bits per pixel */
-					image->comps[0].data[index] = dat8[i+0];	// R 
-					image->comps[1].data[index] = dat8[i+1];	// G 
-					image->comps[2].data[index] = dat8[i+2];	// B 
-					if(parameters->cp_cinema){/* Rounding to 12 bits*/
-						image->comps[0].data[index] = image->comps[0].data[index] << 4 ;
-						image->comps[1].data[index] = image->comps[1].data[index] << 4 ;
-						image->comps[2].data[index] = image->comps[2].data[index] << 4 ;
-					}
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];// R 
+						image->comps[1].data[index] = dat8[i+1];// G 
+						image->comps[2].data[index] = dat8[i+2];// B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = image->comps[0].data[index] << 4 ;
+							image->comps[1].data[index] = image->comps[1].data[index] << 4 ;
+							image->comps[2].data[index] = image->comps[2].data[index] << 4 ;
+						}
+						index++;
+					}else
+						break;
 				}
 			}
 			else{
-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
 				fprintf(stderr,"Aborting\n");
 				return NULL;
 			}
@@ -1394,6 +1884,7 @@
 		strip_size = 0;
 		strip_size = TIFFStripSize(tif);
 		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
 		/* Read the Image components*/
 		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
 			unsigned char *dat8;
@@ -1403,25 +1894,34 @@
 
 			if (Info.tiBps==12){
 				for (i=0; i<ssize; i+=3) {	/* 12 bits per pixel*/
-					image->comps[0].data[index] = ( dat8[i+0]<<4 )				|(dat8[i+1]>>4) ;
-					image->comps[0].data[index] = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
-					index+=2;
+					if(index < imgsize){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4) ;
+						image->comps[0].data[index+1] = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						index+=2;
+					}else
+						break;
 				}
 			}
 			else if( Info.tiBps==16){
 				for (i=0; i<ssize; i+=2) {	/* 16 bits per pixel */
-					image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];
+						index++;
+					}else
+						break;
 				}
 			}
 			else if ( Info.tiBps==8){
 				for (i=0; i<ssize; i+=1) {	/* 8 bits per pixel */
-					image->comps[0].data[index] = dat8[i+0];
-					index++;
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];
+						index++;
+					}else
+						break;
 				}
 			}
 			else{
-				fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
 				fprintf(stderr,"Aborting\n");
 				return NULL;
 			}
@@ -1430,9 +1930,209 @@
 		_TIFFfree(buf);
 		TIFFClose(tif);
 	}else{
-		fprintf(stderr,"False color format. Only RGB & Grayscale has been implemented\n");
+		fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+	return image;
+}
+
+/* -->> -->> -->> -->>
+
+	RAW IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	FILE *f = NULL;
+	int i, compno, numcomps, w, h;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_image_t * image = NULL;
+	unsigned short ch;
+	
+	if((! (raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp & raw_cp->rawBitDepth)) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		fprintf(stderr,"Please use the Format option -F:\n");
+		fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+		fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
 		fprintf(stderr,"Aborting\n");
 		return NULL;
 	}
+	numcomps = raw_cp->rawComp;
+	color_space = CLRSPC_SRGB;
+	w = raw_cp->rawWidth;
+	h = raw_cp->rawHeight;
+	cmptparm = (opj_image_cmptparm_t*) malloc(numcomps * sizeof(opj_image_cmptparm_t));
+	
+	/* initialize image components */	
+	memset(&cmptparm[0], 0, numcomps * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < numcomps; i++) {		
+		cmptparm[i].prec = raw_cp->rawBitDepth;
+		cmptparm[i].bpp = raw_cp->rawBitDepth;
+		cmptparm[i].sgnd = raw_cp->rawSigned;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = w;
+		cmptparm[i].h = h;
+	}
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+	if(!image) {
+		fclose(f);
+		return NULL;
+	}
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 = parameters->image_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	image->y1 = parameters->image_offset_y0 + (h - 1) *	subsampling_dy + 1;
+
+	if(raw_cp->rawBitDepth <= 8)
+	{
+		unsigned char value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 1, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(char)value:value;
+			}
+		}
+	}
+	else
+	{
+		unsigned short value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 2, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(short)value:value;
+			}
+		}
+	}
+
+	if (fread(&ch, 1, 1, f)) {
+		fprintf(stderr,"Warning. End of raw file not reached... processing anyway\n");
+	}
+	fclose(f);
+
 	return image;
 }
+
+int imagetoraw(opj_image_t * image, const char *outfile)
+{
+	FILE *rawFile = NULL;
+	int compno;
+	int w, h;
+	int line, row;
+	int *ptr;
+
+	if((image->numcomps * image->x1 * image->y1) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		return 1;
+	}
+
+	rawFile = fopen(outfile, "wb");
+	if (!rawFile) {
+		fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
+		return 1;
+	}
+
+	fprintf(stdout,"Raw image characteristics: %d components\n", image->numcomps);
+
+	for(compno = 0; compno < image->numcomps; compno++)
+	{
+		fprintf(stdout,"Component %d characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
+			image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
+
+		w = image->comps[compno].w;
+		h = image->comps[compno].h;
+
+		if(image->comps[compno].prec <= 8)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (signed char) (*ptr & mask);
+						fwrite(&curr, sizeof(signed char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{	
+						curr = (unsigned char) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if(image->comps[compno].prec <= 16)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{					
+						curr = (signed short int) (*ptr & mask);
+						fwrite(&curr, sizeof(signed short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (unsigned short int) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if (image->comps[compno].prec <= 32)
+		{
+			fprintf(stderr,"More than 16 bits per component no handled yet\n");
+			return 1;
+		}
+		else
+		{
+			fprintf(stderr,"Error: invalid precision: %d\n", image->comps[compno].prec);
+			return 1;
+		}
+	}
+	fclose(rawFile);
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/codec/convert.h ./codec/convert.h
--- /home/robin/sldeb/trunk/codec/convert.h	2007-02-28 15:31:56.000000000 +0000
+++ ./codec/convert.h	2007-09-28 11:33:52.000000000 +0100
@@ -31,8 +31,28 @@
 #ifndef __J2K_CONVERT_H
 #define __J2K_CONVERT_H
 
-opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters);
+/**@name RAW image encoding parameters */
+/*@{*/
+typedef struct raw_cparameters {
+	/** width of the raw image */
+	int rawWidth;
+	/** height of the raw image */
+	int rawHeight;
+	/** components of the raw image */
+	int rawComp;
+	/** bit depth of the raw image */
+	int rawBitDepth;
+	/** signed/unsigned raw image */
+	bool rawSigned;
+	/*@}*/
+} raw_cparameters_t;
+
+/* TGA conversion */
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetotga(opj_image_t * image, const char *outfile);
 
+/* BMP conversion */
+opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters);
 int imagetobmp(opj_image_t *image, const char *outfile);
 
 /* TIFF to image conversion*/
@@ -45,12 +65,14 @@
 @return Returns a greyscale image if successful, returns NULL otherwise
 */
 opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters);
-
 int imagetopgx(opj_image_t *image, const char *outfile);
 
 opj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters);
-
 int imagetopnm(opj_image_t *image, const char *outfile);
 
+/* RAW conversion */
+int imagetoraw(opj_image_t * image, const char *outfile);
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp);
+
 #endif /* __J2K_CONVERT_H */
 
diff -urN /home/robin/sldeb/trunk/codec/image_to_j2k.c ./codec/image_to_j2k.c
--- /home/robin/sldeb/trunk/codec/image_to_j2k.c	2007-06-04 14:32:25.000000000 +0100
+++ ./codec/image_to_j2k.c	2007-11-27 22:39:51.000000000 +0000
@@ -32,11 +32,13 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <math.h>
 
 #include "openjpeg.h"
 #include "compat/getopt.h"
 #include "convert.h"
 #include "dirent.h"
+#include "index.h"
 
 #ifndef WIN32
 #define stricmp strcasecmp
@@ -54,6 +56,8 @@
 #define BMP_DFMT 12
 #define YUV_DFMT 13
 #define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
 
 /* ----------------------------------------------------------------------- */
 #define CINEMA_24_CS 1302083	/*Codestream length for 24fps*/
@@ -77,7 +81,8 @@
 	char set_imgdir;
 	/** Enable Cod Format for output*/
 	char set_out_format;
-
+	/** User specified rate stored in case of cinema option*/
+	float *rates;
 }img_fol_t;
 
 void encode_help_display() {
@@ -98,10 +103,6 @@
 	fprintf(stdout,"The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
 	fprintf(stdout,"COD and QCD never appear in the tile_header.\n");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"- This coder can encode a mega image, a test was made on a 24000x24000 pixels \n");
-	fprintf(stdout,"color image.  You need enough disk space memory (twice the original) to encode \n");
-	fprintf(stdout,"the image,i.e. for a 1.5 GB image you need a minimum of 3GB of disk memory)\n");
-	fprintf(stdout,"\n");
 	fprintf(stdout,"By default:\n");
 	fprintf(stdout,"------------\n");
 	fprintf(stdout,"\n");
@@ -138,9 +139,9 @@
 	fprintf(stdout,"-OutFor \n");
 	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
 	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
-	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP format\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-i           : source file  (-i source.pnm also *.pgm, *.ppm) \n");
+	fprintf(stdout,"-i           : source file  (-i source.pnm also *.pgm, *.ppm, *.bmp, *.tif, *.raw, *.tga) \n");
 	fprintf(stdout,"    When using this option -o must be used\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-o           : destination file (-o dest.j2k or .jp2) \n");
@@ -149,10 +150,10 @@
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-h           : display the help information \n ");
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-cinema2k    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
+	fprintf(stdout,"-cinema2K    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
   fprintf(stdout,"	  Need to specify the frames per second for a 2K resolution. Only 24 or 48 fps is allowed\n"); 
 	fprintf(stdout,"\n");
-	fprintf(stdout,"-cinema4k    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
+	fprintf(stdout,"-cinema4K    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
 	fprintf(stdout,"	  Frames per second not required. Default value is 24fps\n"); 
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-r           : different compression ratios for successive layers (-r 20,10,5)\n ");
@@ -199,7 +200,7 @@
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
 	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
-	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
+	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
 	fprintf(stdout,"\n");
@@ -211,31 +212,31 @@
 #ifdef USE_JPWL
 	fprintf(stdout,"-W           : adoption of JPWL (Part 11) capabilities (-W params)\n");
 	fprintf(stdout,"               The parameters can be written and repeated in any order:\n");
-	fprintf(stdout,"               [h<tile><=type>,s<tile><=method>,a=<addr>,z=<size>,g=<range>,...\n");
-	fprintf(stdout,"                ...,p<tile:pack><=type>]\n");
+	fprintf(stdout,"               [h<tilepart><=type>,s<tilepart><=method>,a=<addr>,...\n");
+	fprintf(stdout,"                ...,z=<size>,g=<range>,p<tilepart:pack><=type>]\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 h selects the header error protection (EPB): 'type' can be\n");
 	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
-	fprintf(stdout,"                   if 'tile' is absent, it applies to main and tile headers\n");
-	fprintf(stdout,"                   if 'tile' is present, it applies from that tile\n");
-	fprintf(stdout,"                     onwards, up to the next h<tile> spec, or to the last tile\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main and tile headers\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next h<> spec, or to the last tilepart\n");
 	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 p selects the packet error protection (EEP/UEP with EPBs)\n");
 	fprintf(stdout,"                  to be applied to raw data: 'type' can be\n");
 	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
-	fprintf(stdout,"                   if 'tile:pack' is absent, it starts from tile 0, packet 0\n");
-	fprintf(stdout,"                   if 'tile:pack' is present, it applies from that tile\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is absent, it is from tile 0, packet 0\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is present, it applies from that tile\n");
 	fprintf(stdout,"                     and that packet onwards, up to the next packet spec\n");
-	fprintf(stdout,"                     or to the last packet in the last tile in the codestream\n");
+	fprintf(stdout,"                     or to the last packet in the last tilepart in the stream\n");
 	fprintf(stdout,"                     (max. %d specs)\n", JPWL_MAX_NO_PACKSPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 s enables sensitivity data insertion (ESD): 'method' can be\n");
 	fprintf(stdout,"                   [-1=NO ESD 0=RELATIVE ERROR 1=MSE 2=MSE REDUCTION 3=PSNR\n");
 	fprintf(stdout,"                    4=PSNR INCREMENT 5=MAXERR 6=TSE 7=RESERVED]\n");
-	fprintf(stdout,"                   if 'tile' is absent, it applies to main header only\n");
-	fprintf(stdout,"                   if 'tile' is present, it applies from that tile\n");
-	fprintf(stdout,"                     onwards, up to the next s<tile> spec, or to the last tile\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main header only\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next s<> spec, or to the last tilepart\n");
 	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 g determines the addressing mode: <range> can be\n");
@@ -248,15 +249,16 @@
 	fprintf(stdout,"                   1/2 bytes, for the transformed pseudo-floating point value\n");
 	fprintf(stdout,"\n");
 	fprintf(stdout,"                 ex.:\n");
-	fprintf(stdout," h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,s0=6,s3=-1,a=0,g=1,z=1\n");
+	fprintf(stdout,"                   h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,\n");
+	fprintf(stdout,"                     s0=6,s3=-1,a=0,g=1,z=1\n");
 	fprintf(stdout,"                 means\n");
 	fprintf(stdout,"                   predefined EPB in MH, rs(64,32) from TPH 0 to TPH 2,\n");
 	fprintf(stdout,"                   CRC-16 in TPH 3 and TPH 4, CRC-32 in remaining TPHs,\n");
 	fprintf(stdout,"                   UEP rs(78,32) for packets 0 to 23 of tile 0,\n");
-	fprintf(stdout,"                   UEP rs(56,32) for packets 24 to the last of tile 0,\n");
-	fprintf(stdout,"                   UEP rs default for packets of tile 1,\n");
-	fprintf(stdout,"                   no UEP for packets 0 to 19 of tile 3,\n");
-	fprintf(stdout,"                   UEP CRC-32 for packets 20 of tile 3 to last tile,\n");
+	fprintf(stdout,"                   UEP rs(56,32) for packs. 24 to the last of tilepart 0,\n");
+	fprintf(stdout,"                   UEP rs default for packets of tilepart 1,\n");
+	fprintf(stdout,"                   no UEP for packets 0 to 19 of tilepart 3,\n");
+	fprintf(stdout,"                   UEP CRC-32 for packs. 20 of tilepart 3 to last tilepart,\n");
 	fprintf(stdout,"                   relative sensitivity ESD for MH,\n");
 	fprintf(stdout,"                   TSE ESD from TPH 0 to TPH 2, byte range with automatic\n");
 	fprintf(stdout,"                   size of addresses and 1 byte for each sensitivity value\n");
@@ -282,20 +284,28 @@
 	fprintf(stdout,"Image_height Image_width\n");
 	fprintf(stdout,"progression order\n");
 	fprintf(stdout,"Tiles_size_X Tiles_size_Y\n");
-/* UniPG>> */
 	fprintf(stdout,"Tiles_nb_X Tiles_nb_Y\n");
-/* <<UniPG */
 	fprintf(stdout,"Components_nb\n");
 	fprintf(stdout,"Layers_nb\n");
 	fprintf(stdout,"decomposition_levels\n");
 	fprintf(stdout,"[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
 	fprintf(stdout,"   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
+	fprintf(stdout,"Main_header_start_position\n");
 	fprintf(stdout,"Main_header_end_position\n");
 	fprintf(stdout,"Codestream_size\n");
-	fprintf(stdout,"Tile_0 start_pos end_Theader end_pos TotalDisto NumPix MaxMSE\n");
-	fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"INFO ON TILES\n");
+	fprintf(stdout,"tileno start_pos end_hd end_tile nbparts disto nbpix disto/nbpix\n");
+	fprintf(stdout,"Tile_0 start_pos end_Theader end_pos NumParts TotalDisto NumPix MaxMSE\n");
+	fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''      ''\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''     ''\n");
 	fprintf(stdout,"...\n");
-	fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''\n");
+	fprintf(stdout,"TILE 0 DETAILS\n");
+	fprintf(stdout,"part_nb tileno num_packs start_pos end_tph_pos end_pos\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Progression_string\n");
+	fprintf(stdout,"pack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
 	fprintf(stdout,"Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
 	fprintf(stdout,"...\n");
 	fprintf(stdout,"Tpacket_Np ''   ''    ''   ''    ''       ''       ''     ''\n");
@@ -375,10 +385,10 @@
 int get_file_format(char *filename) {
 	unsigned int i;
 	static const char *extension[] = {
-    "pgx", "pnm", "pgm", "ppm", "bmp","tif", "j2k", "jp2", "j2c"
+    "pgx", "pnm", "pgm", "ppm", "bmp", "tif", "raw", "tga", "j2k", "jp2", "j2c"
     };
 	static const int format[] = {
-    PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT,TIF_DFMT, J2K_CFMT, JP2_CFMT, J2K_CFMT
+    PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, J2K_CFMT
     };
 	char * ext = strrchr(filename, '.');
 	if (ext == NULL)
@@ -389,7 +399,6 @@
 			return format[i];
 		}
 	}
-
 	return -1;
 }
 
@@ -402,6 +411,7 @@
 
 char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_cparameters_t *parameters){
 	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+  char *temp_p, temp1[OPJ_PATH_LEN]="";
 
 	strcpy(image_filename,dirptr->filename[imageno]);
 	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
@@ -413,6 +423,10 @@
 
 	//Set output file
 	strcpy(temp_ofname,get_file_name(image_filename));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
 	if(img_fol->set_out_format==1){
 		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
 		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
@@ -471,7 +485,7 @@
 
 }
 
-void cinema_setup_encoder(opj_cparameters_t *parameters,opj_image_t *image){
+void cinema_setup_encoder(opj_cparameters_t *parameters,opj_image_t *image, img_fol_t *img_fol){
 	int i;
 	float temp_rate;
 	opj_poc_t *POC = NULL;
@@ -483,7 +497,9 @@
 			parameters->numresolution = 6;
 		}
 		if (!((image->comps[0].w == 2048) | (image->comps[0].h == 1080))){
-			fprintf(stdout,"Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 (2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",image->comps[0].w,image->comps[0].h);
+			fprintf(stdout,"Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 "
+				"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
+				image->comps[0].w,image->comps[0].h);
 			parameters->cp_rsiz = STD_RSIZ;
 		}
 	break;
@@ -495,7 +511,9 @@
 				parameters->numresolution = 7;
 			}
 		if (!((image->comps[0].w == 4096) | (image->comps[0].h == 2160))){
-			fprintf(stdout,"Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4 (4K profile) compliance requires that atleast one of coordinates match 4096 x 2160\n",image->comps[0].w,image->comps[0].h);
+			fprintf(stdout,"Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4" 
+				"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
+				image->comps[0].w,image->comps[0].h);
 			parameters->cp_rsiz = STD_RSIZ;
 		}
 		parameters->numpocs = initialise_4K_poc(parameters->POC,parameters->numresolution);
@@ -505,17 +523,19 @@
 	switch (parameters->cp_cinema){
 		case CINEMA2K_24:
 		case CINEMA4K_24:
-			for(i=0;i<parameters->tcp_numlayers;i++){
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
 				temp_rate = 0 ;
-				if (parameters->tcp_rates[i]== 0){
+				if (img_fol->rates[i]== 0){
 					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
 					(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
 				}else{
 					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-						(parameters->tcp_rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
 					if (temp_rate > CINEMA_24_CS ){
 						parameters->tcp_rates[i]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-																				(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+						(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
 					}
 				}
 			}
@@ -523,17 +543,19 @@
 			break;
 		
 		case CINEMA2K_48:
-     	for(i=0;i<parameters->tcp_numlayers;i++){
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
 				temp_rate = 0 ;
-				if (parameters->tcp_rates[i]== 0){
+				if (img_fol->rates[i]== 0){
 					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
 					(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
 				}else{
 					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-						(parameters->tcp_rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
 					if (temp_rate > CINEMA_48_CS ){
 						parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
-																				(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+						(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
 					}
 				}
 			}
@@ -545,7 +567,8 @@
 
 /* ------------------------------------------------------------------------------------ */
 
-int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,img_fol_t *img_fol) {
+int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,
+													img_fol_t *img_fol, raw_cparameters_t *raw_cp, char *indexfilename) {
 	int i, j,totlen;
 	option_t long_option[]={
 		{"cinema2K",REQ_ARG, NULL ,'w'},
@@ -556,11 +579,11 @@
 		{"EPH",NO_ARG, NULL ,'E'},
 		{"OutFor",REQ_ARG, NULL ,'O'},
 		{"POC",REQ_ARG, NULL ,'P'},
+		{"ROI",REQ_ARG, NULL ,'R'},
 	};
 
 	/* parse the command line */
-/* UniPG>> */
-	const char optlist[] = "i:o:hr:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:"
+	const char optlist[] = "i:o:hr:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:F:"
 #ifdef USE_JPWL
 		"W:"
 #endif /* USE_JPWL */
@@ -568,10 +591,10 @@
 
 	totlen=sizeof(long_option);
 	img_fol->set_out_format=0;
+	raw_cp->rawWidth = 0;
 
 	while (1) {
     int c = getopt_long(argc, argv, optlist,long_option,totlen);
-/* <<UniPG */
 		if (c == -1)
 			break;
 		switch (c) {
@@ -584,11 +607,13 @@
 					case PXM_DFMT:
 					case BMP_DFMT:
 					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
 						break;
 					default:
 						fprintf(stderr,
 							"!! Unrecognized format for infile : %s "
-              "[accept only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp or *.tif] !!\n\n", 
+              "[accept only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga] !!\n\n", 
 							infile);
 						return 1;
 				}
@@ -607,7 +632,7 @@
 					case JP2_CFMT:
 						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.j2k, *.jp2]!! \n", outfile);
+						fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n", outfile);
 						return 1;
 				}
 				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
@@ -628,7 +653,7 @@
 							img_fol->out_format = optarg;
 							break;
 						default:
-							fprintf(stderr, "Unknown output format image [only j2k, jp2]!! \n");
+							fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
 							return 1;
 					}
 				}
@@ -656,6 +681,41 @@
 
 				/* ----------------------------------------------------- */
 
+			
+			case 'F':			/* Raw image format parameters */
+			{
+				char signo;
+				char *s = optarg;
+				if (sscanf(s, "%d,%d,%d,%d,%c", &raw_cp->rawWidth, &raw_cp->rawHeight, &raw_cp->rawComp, &raw_cp->rawBitDepth, &signo) == 5) {
+					if (signo == 's') {
+						raw_cp->rawSigned = true;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Signed\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else if (signo == 'u') {
+						raw_cp->rawSigned = false;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Unsigned\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else {
+						fprintf(stderr,"\nError: invalid raw image parameters: Unknown sign of raw file\n");
+						fprintf(stderr,"Please use the Format option -F:\n");
+						fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+						fprintf(stderr,"Aborting\n");
+					}					
+				}
+				else {
+					fprintf(stderr,"\nError: invalid raw image parameters\n");
+					fprintf(stderr,"Please use the Format option -F:\n");
+					fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+					fprintf(stderr,"Aborting\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
 			case 'q':			/* add fixed_quality */
 			{
 				char *s = optarg;
@@ -780,8 +840,7 @@
 			case 'x':			/* creation of index file */
 			{
 				char *index = optarg;
-				strncpy(parameters->index, index, sizeof(parameters->index)-1);
-				parameters->index_on = 1;
+				strncpy(indexfilename, index, OPJ_PATH_LEN);
 			}
 			break;
 
@@ -895,9 +954,9 @@
 
 			case 'R':			/* ROI */
 			{
-				if (sscanf(optarg, "OI:c=%d,U=%d", &parameters->roi_compno,
+				if (sscanf(optarg, "c=%d,U=%d", &parameters->roi_compno,
                                            &parameters->roi_shift) != 2) {
-					fprintf(stderr, "ROI error !! [-ROI:c='compno',U='shift']\n");
+					fprintf(stderr, "ROI error !! [-ROI c='compno',U='shift']\n");
 					return 1;
 				}
 			}
@@ -995,9 +1054,8 @@
 				int hprot, pprot, sens, addr, size, range;
 
 				/* we need to enable indexing */
-				if (!parameters->index_on) {
-					strncpy(parameters->index, JPWL_PRIVATEINDEX_NAME, sizeof(parameters->index)-1);
-					parameters->index_on = 1;
+				if (!indexfilename) {
+					strncpy(indexfilename, JPWL_PRIVATEINDEX_NAME, OPJ_PATH_LEN);
 				}
 
 				/* search for different protection methods */
@@ -1026,11 +1084,11 @@
 							/* Tile part header, specified */
 							if (!((hprot == 0) || (hprot == 1) || (hprot == 16) || (hprot == 32) ||
 								((hprot >= 37) && (hprot <= 128)))) {
-								fprintf(stderr, "ERROR -> invalid tile header protection method h = %d\n", hprot);
+								fprintf(stderr, "ERROR -> invalid tile part header protection method h = %d\n", hprot);
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1041,7 +1099,7 @@
 						} else if(sscanf(token, "h%d", &tile) == 1) {
 							/* Tile part header, unspecified */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1087,7 +1145,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (packspec < JPWL_MAX_NO_PACKSPECS) {
@@ -1104,7 +1162,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (pack < 0) {
@@ -1125,7 +1183,7 @@
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (pack < 0) {
@@ -1141,7 +1199,7 @@
 						} else if (sscanf(token, "p%d", &tile) == 1) {
 							/* default from a tile on */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on protection method p = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
 								return 1;
 							}
 							if (packspec < JPWL_MAX_NO_PACKSPECS) {
@@ -1182,11 +1240,11 @@
 						} else if(sscanf(token, "s%d=%d", &tile, &sens) == 2) {
 							/* Tile part header, specified */
 							if ((sens < -1) || (sens > 7)) {
-								fprintf(stderr, "ERROR -> invalid tile header sensitivity method s = %d\n", sens);
+								fprintf(stderr, "ERROR -> invalid tile part header sensitivity method s = %d\n", sens);
 								return 1;
 							}
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on sensitivity method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1197,7 +1255,7 @@
 						} else if(sscanf(token, "s%d", &tile) == 1) {
 							/* Tile part header, unspecified */
 							if (tile < 0) {
-								fprintf(stderr, "ERROR -> invalid tile number on sensitivity method t = %d\n", tile);
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
 								return 1;
 							}
 							if (tilespec < JPWL_MAX_NO_TILESPECS) {
@@ -1348,6 +1406,15 @@
 		}
 	}
 
+	if (parameters->decod_format == RAW_DFMT && raw_cp->rawWidth == 0) {
+			fprintf(stderr,"\nError: invalid raw image parameters\n");
+			fprintf(stderr,"Please use the Format option -F:\n");
+			fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+			fprintf(stderr,"Aborting\n");
+			return 1;
+	}
+
 	if ((parameters->cp_disto_alloc || parameters->cp_fixed_alloc || parameters->cp_fixed_quality)
 		&& (!(parameters->cp_disto_alloc ^ parameters->cp_fixed_alloc ^ parameters->cp_fixed_quality))) {
 		fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
@@ -1414,6 +1481,9 @@
 	int i,num_images;
 	int imageno;
 	dircnt_t *dirptr;
+	raw_cparameters_t raw_cp;
+	opj_codestream_info_t cstr_info;		/* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
 
 	/*
 	configure the event callbacks (not required)
@@ -1427,15 +1497,22 @@
 	/* set encoding parameters to default values */
 	opj_set_default_encoder_parameters(&parameters);
 
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
+
 	/* parse input and get user encoding parameters */
-	if(parse_cmdline_encoder(argc, argv, &parameters,&img_fol) == 1) {
-		return 0;
+	if(parse_cmdline_encoder(argc, argv, &parameters,&img_fol, &raw_cp, indexfilename) == 1) {
+		return 1;
 	}
 	
 	if (parameters.cp_cinema){
+		img_fol.rates = (float*)malloc(parameters.tcp_numlayers * sizeof(float));
+		for(i=0; i< parameters.tcp_numlayers; i++){
+			img_fol.rates[i] = parameters.tcp_rates[i];
+		}
 		cinema_parameters(&parameters);
-	}
-				
+	}				
 
 	/* Create comment for codestream */
 	if(parameters.cp_comment == NULL) {
@@ -1451,19 +1528,15 @@
 		sprintf(parameters.cp_comment,"%s%s", comment, version);
 #endif
 /* <<UniPG */
-
 	}
 
 	/* Read directory if necessary */
-
 	if(img_fol.set_imgdir==1){
 		num_images=get_num_images(img_fol.imgdirpath);
-
 		dirptr=(dircnt_t*)malloc(sizeof(dircnt_t));
 		if(dirptr){
 			dirptr->filename_buf = (char*)malloc(num_images*OPJ_PATH_LEN*sizeof(char));	// Stores at max 10 image file names
 			dirptr->filename = (char**) malloc(num_images*sizeof(char*));
-
 			if(!dirptr->filename_buf){
 				return 0;
 			}
@@ -1482,13 +1555,10 @@
 		num_images=1;
 	}
 	/*Encoding image one by one*/
-	for(imageno=0;imageno<num_images;imageno++)
-	{
-
+	for(imageno=0;imageno<num_images;imageno++)	{
 		image = NULL;
 		fprintf(stderr,"\n");
 		
-
 		if(img_fol.set_imgdir==1){
 			if (get_next_file(imageno, dirptr,&img_fol, &parameters)) {
 				fprintf(stderr,"skipping file...\n");
@@ -1504,7 +1574,10 @@
 				break;
 			case TIF_DFMT:
 				break;
-		
+			case RAW_DFMT:
+				break;
+			case TGA_DFMT:
+				break;
 			default:
 				fprintf(stderr,"skipping file...\n");
 				continue;			
@@ -1545,12 +1618,28 @@
 						return 1;
 					}
 				break;
+
+				case RAW_DFMT:
+					image = rawtoimage(parameters.infile, &parameters, &raw_cp);
+					if (!image) {
+						fprintf(stderr, "Unable to load raw file\n");
+						return 1;
+					}
+				break;
+
+				case TGA_DFMT:
+					image = tgatoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load tga file\n");
+						return 1;
+					}
+				break;
 		}
 			/* Decide if MCT should be used */
 			parameters.tcp_mct = image->numcomps == 3 ? 1 : 0;
 
 			if(parameters.cp_cinema){
-				cinema_setup_encoder(&parameters,image);
+				cinema_setup_encoder(&parameters,image,&img_fol);
 			}
 
 			/* encode the destination image */
@@ -1575,7 +1664,10 @@
 				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, image, parameters.index);
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -1596,9 +1688,18 @@
 				/* close and free the byte stream */
 				opj_cio_close(cio);
 
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
+
 				/* free remaining compression structures */
 				opj_destroy_compress(cinfo);
-
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
 			} else {			/* JP2 format output */
 				int codestream_length;
 				opj_cio_t *cio = NULL;
@@ -1618,7 +1719,10 @@
 				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, image, parameters.index);
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -1637,10 +1741,19 @@
 				fprintf(stderr,"Generated outfile %s\n",parameters.outfile);
 				/* close and free the byte stream */
 				opj_cio_close(cio);
+				
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
 
 				/* free remaining compression structures */
 				opj_destroy_compress(cinfo);
-
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
 			}
 	
 			/* free image data */
@@ -1653,4 +1766,3 @@
 
 	return 0;
 }
-
diff -urN /home/robin/sldeb/trunk/codec/image_to_j2k.dsp ./codec/image_to_j2k.dsp
--- /home/robin/sldeb/trunk/codec/image_to_j2k.dsp	2007-03-01 16:12:17.000000000 +0000
+++ ./codec/image_to_j2k.dsp	2007-09-28 11:33:52.000000000 +0100
@@ -51,7 +51,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libc"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"LIBC"
 # SUBTRACT LINK32 /pdb:none
 
 !ELSEIF  "$(CFG)" == "image_to_j2k - Win32 Debug"
@@ -77,7 +77,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"LIBC" /nodefaultlib:"LIBCMT" /pdbtype:sept
 # SUBTRACT LINK32 /pdb:none
 
 !ENDIF 
Binary files /home/robin/sldeb/trunk/codec/image_to_j2k.sln and ./codec/image_to_j2k.sln differ
diff -urN /home/robin/sldeb/trunk/codec/image_to_j2k.vcproj ./codec/image_to_j2k.vcproj
--- /home/robin/sldeb/trunk/codec/image_to_j2k.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/image_to_j2k.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,292 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="image_to_j2k"
+	ProjectGUID="{81FBE6CF-1DFB-413F-8215-0851F8E2D252}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/image_to_j2k.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/image_to_j2k.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/image_to_j2k.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/image_to_j2k.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath="image_to_j2k.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/codec/index.c ./codec/index.c
--- /home/robin/sldeb/trunk/codec/index.c	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/index.c	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,390 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <math.h>
+#include "openjpeg.h"
+#include "index.h"
+
+/* ------------------------------------------------------------------------------------ */
+
+/**
+Write a structured index to a file
+@param cstr_info Codestream information 
+@param index Index filename
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+	FILE *stream = NULL;
+	double total_disto = 0;
+/* UniPG>> */
+	int tilepartno;
+	char disto_on, numpix_on;
+
+#ifdef USE_JPWL
+	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+		return 0;
+#endif /* USE_JPWL */
+/* <<UniPG */
+
+	if (!cstr_info)		
+		return 1;
+
+	stream = fopen(index, "w");
+	if (!stream) {
+		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+		return 1;
+	}
+	
+	if (cstr_info->tile[0].distotile)
+		disto_on = 1;
+	else 
+		disto_on = 0;
+
+	if (cstr_info->tile[0].numpix)
+		numpix_on = 1;
+	else 
+		numpix_on = 0;
+
+	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+	fprintf(stream, "%d\n", cstr_info->prog);
+	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+	fprintf(stream, "%d\n", cstr_info->numcomps);
+	fprintf(stream, "%d\n", cstr_info->numlayers);
+	fprintf(stream, "%d\n", cstr_info->numdecompos);
+
+	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+		fprintf(stream, "[%d,%d] ", 
+			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+	}
+
+	fprintf(stream, "\n");
+/* UniPG>> */
+	fprintf(stream, "%d\n", cstr_info->main_head_start);
+/* <<UniPG */
+	fprintf(stream, "%d\n", cstr_info->main_head_end);
+	fprintf(stream, "%d\n", cstr_info->codestream_size);
+	
+	fprintf(stream, "\nINFO ON TILES\n");
+	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
+	if (disto_on)
+		fprintf(stream,"         disto");
+	if (numpix_on)
+		fprintf(stream,"     nbpix");
+	if (disto_on && numpix_on)
+		fprintf(stream,"  disto/nbpix");
+	fprintf(stream, "\n");
+
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		fprintf(stream, "%4d %9d %9d %9d %9d", 
+			cstr_info->tile[tileno].tileno,
+			cstr_info->tile[tileno].start_pos,
+			cstr_info->tile[tileno].end_header,
+			cstr_info->tile[tileno].end_pos,
+			cstr_info->tile[tileno].num_tps);
+		if (disto_on)
+			fprintf(stream," %9e", cstr_info->tile[tileno].distotile);
+		if (numpix_on)
+			fprintf(stream," %9d", cstr_info->tile[tileno].numpix);
+		if (disto_on && numpix_on)
+			fprintf(stream," %9e", cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+		fprintf(stream, "\n");
+	}
+		
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		int start_pos, end_ph_pos, end_pos;
+		double disto = 0;
+		int max_numdecompos = 0;
+		pack_nb = 0;
+
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			if (max_numdecompos < cstr_info->numdecompos[compno])
+				max_numdecompos = cstr_info->numdecompos[compno];
+		}	
+
+		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
+		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
+				tilepartno, tileno,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
+				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+				);
+
+		if (cstr_info->prog == LRCP) {	/* LRCP */
+			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max;
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d",
+								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
+							if (disto_on)
+								fprintf(stream, " %8e", disto);
+							fprintf(stream, "\n");
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* LRCP */
+
+		else if (cstr_info->prog == RLCP) {	/* RLCP */			
+			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max; 
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d",
+								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
+							if (disto_on)
+								fprintf(stream, " %8e", disto);
+							fprintf(stream, "\n");
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* RLCP */
+
+		else if (cstr_info->prog == RPCL) {	/* RPCL */
+
+			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				for (precno = 0; precno < numprec; precno++) {								
+					/* I suppose components have same XRsiz, YRsiz */
+					int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+					int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+					int x1 = x0 + cstr_info->tile_x;
+					int y1 = y0 + cstr_info->tile_y;
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {					
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d",
+												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* compno */
+			} /* resno */
+		} /* RPCL */
+
+		else if (cstr_info->prog == PCRL) {	/* PCRL */
+			/* I suppose components have same XRsiz, YRsiz */
+			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+			int x1 = x0 + cstr_info->tile_x;
+			int y1 = y0 + cstr_info->tile_y;
+
+			// Count the maximum number of precincts 
+			int max_numprec = 0;
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				if (numprec > max_numprec)
+					max_numprec = numprec;
+			}
+
+			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (precno = 0; precno < max_numprec; precno++) {
+				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (precno >= numprec)
+							continue;
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* resno */
+				} /* compno */
+			} /* precno */
+		} /* PCRL */
+
+		else {	/* CPRL */
+			// Count the maximum number of precincts 
+			int max_numprec = 0;
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				if (numprec > max_numprec)
+					max_numprec = numprec;
+			}
+
+			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+
+				for (precno = 0; precno < max_numprec; precno++) {
+					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (precno >= numprec)
+							continue;
+
+						for(y = y0; y < y1; y++) {
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							}
+						} /* y = y0..y1 */
+					} /* resno */
+				} /* precno */
+			} /* compno */
+		} /* CPRL */   
+	} /* tileno */
+	
+	if (disto_on) {
+		fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */	
+		fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+	}
+/* UniPG>> */
+	/* print the markers' list */
+	if (cstr_info->marknum) {
+		fprintf(stream, "\nMARKER LIST\n");
+		fprintf(stream, "%d\n", cstr_info->marknum);
+		fprintf(stream, "type\tstart_pos    length\n");
+		for (x = 0; x < cstr_info->marknum; x++)
+			fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
+	}
+/* <<UniPG */
+	fclose(stream);
+
+	fprintf(stderr,"Generated index file %s\n", index);
+
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/codec/index.h ./codec/index.h
--- /home/robin/sldeb/trunk/codec/index.h	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/index.h	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __J2K_INDEX_H
+#define __J2K_INDEX_H
+
+/**
+Write a structured index to a file
+@param cstr_info Codestream information 
+@param index Index filename
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int write_index_file(opj_codestream_info_t *cstr_info, char *index);
+
+#endif /* __J2K_INDEX_H */
+
diff -urN /home/robin/sldeb/trunk/codec/j2k_to_image.c ./codec/j2k_to_image.c
--- /home/robin/sldeb/trunk/codec/j2k_to_image.c	2007-04-10 17:23:48.000000000 +0100
+++ ./codec/j2k_to_image.c	2007-11-27 22:39:51.000000000 +0000
@@ -32,11 +32,13 @@
 #include <stdio.h>
 #include <string.h>
 #include <stdlib.h>
+#include <math.h>
 
 #include "openjpeg.h"
 #include "compat/getopt.h"
 #include "convert.h"
 #include "dirent.h"
+#include "index.h"
 
 #ifndef WIN32
 #define stricmp strcasecmp
@@ -54,6 +56,8 @@
 #define BMP_DFMT 12
 #define YUV_DFMT 13
 #define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
 
 /* ----------------------------------------------------------------------- */
 
@@ -95,15 +99,15 @@
 	fprintf(stdout,"  -OutFor \n");
 	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
 	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
-	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP format\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
 	fprintf(stdout,"  -i <compressed file>\n");
 	fprintf(stdout,"    REQUIRED only if an Input image directory not specified\n");
 	fprintf(stdout,"    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n");
 	fprintf(stdout,"    is identified based on its suffix.\n");
 	fprintf(stdout,"  -o <decompressed file>\n");
 	fprintf(stdout,"    REQUIRED\n");
-	fprintf(stdout,"    Currently accepts PGM-files, PPM-files, PNM-files, PGX-files and\n");
-	fprintf(stdout,"    BMP-files. Binary data is written to the file (not ascii). If a PGX\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA files\n");
+	fprintf(stdout,"    Binary data is written to the file (not ascii). If a PGX\n");
 	fprintf(stdout,"    filename is given, there will be as many output files as there are\n");
 	fprintf(stdout,"    components: an indice starting from 0 will then be appended to the\n");
 	fprintf(stdout,"    output filename, just before the \"pgx\" extension. If a PGM filename\n");
@@ -118,6 +122,9 @@
 	fprintf(stdout,"    Set the maximum number of quality layers to decode. If there are\n");
 	fprintf(stdout,"    less quality layers than the specified number, all the quality layers\n");
 	fprintf(stdout,"    are decoded.\n");
+	fprintf(stdout,"  -x  \n"); 
+	fprintf(stdout,"    Create an index file *.Idx (-x index_name.Idx) \n");
+	fprintf(stdout,"\n");
 /* UniPG>> */
 #ifdef USE_JPWL
 	fprintf(stdout,"  -W <options>\n");
@@ -181,8 +188,8 @@
 
 int get_file_format(char *filename) {
 	unsigned int i;
-	static const char *extension[] = {"pgx", "pnm", "pgm", "ppm", "bmp","tif", "j2k", "jp2", "jpt", "j2c" };
-	static const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT };
+	static const char *extension[] = {"pgx", "pnm", "pgm", "ppm", "bmp","tif", "raw", "tga", "j2k", "jp2", "jpt", "j2c" };
+	static const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT };
 	char * ext = strrchr(filename, '.');
 	if (ext == NULL)
 		return -1;
@@ -200,6 +207,7 @@
 
 char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_dparameters_t *parameters){
 	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+	char *temp_p, temp1[OPJ_PATH_LEN]="";
 
 	strcpy(image_filename,dirptr->filename[imageno]);
 	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
@@ -211,6 +219,10 @@
 
 	//Set output file
 	strcpy(temp_ofname,strtok(image_filename,"."));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
 	if(img_fol->set_out_format==1){
 		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
 		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
@@ -218,10 +230,8 @@
 	return 0;
 }
 
-
 /* -------------------------------------------------------------------------- */
-
-int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol) {
+int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol, char *indexfilename) {
 	/* parse the command line */
 	int totlen;
 	option_t long_option[]={
@@ -229,14 +239,14 @@
 		{"OutFor",REQ_ARG, NULL ,'O'},
 	};
 
-/* UniPG>> */
-	const char optlist[] = "i:o:r:l:h"
+	const char optlist[] = "i:o:r:l:hx:"
 
+/* UniPG>> */
 #ifdef USE_JPWL
 					"W:"
 #endif /* USE_JPWL */
-					;
 /* <<UniPG */
+					;
 	totlen=sizeof(long_option);
 	img_fol->set_out_format = 0;
 	while (1) {
@@ -274,9 +284,11 @@
 					case PXM_DFMT:
 					case BMP_DFMT:
 					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
 						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx or *.bmp]!! \n", outfile);
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outfile);
 						return 1;
 				}
 				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
@@ -305,8 +317,14 @@
 					case TIF_DFMT:
 						img_fol->out_format = "tif";
 						break;
+					case RAW_DFMT:
+						img_fol->out_format = "raw";
+						break;
+					case TGA_DFMT:
+						img_fol->out_format = "raw";
+						break;
 					default:
-						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx or *.bmp]!! \n");
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outformat);
 						return 1;
 						break;
 				}
@@ -346,8 +364,15 @@
 					img_fol->set_imgdir=1;
 				}
 				break;
+				/* ----------------------------------------------------- */								
+			case 'x':			/* Creation of index file */
+				{
+					char *index = optarg;
+					strncpy(indexfilename, index, OPJ_PATH_LEN);
+				}
+				break;
 				/* ----------------------------------------------------- */
-/* UniPG>> */
+				/* UniPG>> */
 #ifdef USE_JPWL
 			
 			case 'W': 			/* activate JPWL correction */
@@ -434,7 +459,7 @@
 		}
 		if(img_fol->set_out_format == 0){
 			fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
-			fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX,BMP!!\n");
+			fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
 			return 1;
 		}
 		if(!((parameters->outfile[0] == 0))){
@@ -443,9 +468,9 @@
 		}
 	}else{
 		if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
-			fprintf(stderr, "Error: One of option; -i or -ImgDir must be specified\n");
-			fprintf(stderr, "Error: When using -i; -o must be used\n");
-			fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2 -o *.pgm/ppm/pnm/pgx/bmp(+ options)\n");
+			fprintf(stderr, "Error: One of the options -i or -ImgDir must be specified\n");
+			fprintf(stderr, "Error: When using -i, -o must be used\n");
+			fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2/j2c -o *.pgm/ppm/pnm/pgx/bmp/tif/raw/tga(+ options)\n");
 			return 1;
 		}
 	}
@@ -492,6 +517,8 @@
 	dircnt_t *dirptr;
 	opj_dinfo_t* dinfo = NULL;	/* handle to a decompressor */
 	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
 
 	/* configure the event callbacks (not required) */
 	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
@@ -502,12 +529,16 @@
 	/* set decoding parameters to default values */
 	opj_set_default_decoder_parameters(&parameters);
 
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
 
 	/* parse input and get user encoding parameters */
-	if(parse_cmdline_decoder(argc, argv, &parameters,&img_fol) == 1) {
-		return 0;
+	if(parse_cmdline_decoder(argc, argv, &parameters,&img_fol, indexfilename) == 1) {
+		return 1;
 	}
 
+	/* Initialize reading of directory */
 	if(img_fol.set_imgdir==1){	
 		num_images=get_num_images(img_fol.imgdirpath);
 
@@ -535,9 +566,7 @@
 	}
 
 	/*Encoding image one by one*/
-	for(imageno = 0; imageno < num_images ; imageno++)
-	{
-
+	for(imageno = 0; imageno < num_images ; imageno++)	{
 		image = NULL;
 		fprintf(stderr,"\n");
 
@@ -546,10 +575,8 @@
 				fprintf(stderr,"skipping file...\n");
 				continue;
 			}
-
 		}
 
-
 		/* read the input file and put it in memory */
 		/* ---------------------------------------- */
 		fsrc = fopen(parameters.infile, "rb");
@@ -564,8 +591,6 @@
 		fread(src, 1, file_length, fsrc);
 		fclose(fsrc);
 
-
-
 		/* decode the code-stream */
 		/* ---------------------- */
 
@@ -587,7 +612,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -597,6 +625,15 @@
 
 			/* close the byte stream */
 			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -617,7 +654,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);			
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -628,6 +668,14 @@
 			/* close the byte stream */
 			opj_cio_close(cio);
 
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -648,7 +696,10 @@
 			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 			/* decode the stream and fill the image structure */
-			image = opj_decode(dinfo, cio);
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
 			if(!image) {
 				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
 				opj_destroy_decompress(dinfo);
@@ -658,6 +709,15 @@
 
 			/* close the byte stream */
 			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
 		}
 		break;
 
@@ -708,12 +768,33 @@
 				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
 			}
 			break;
+
+		case RAW_DFMT:			/* RAW */
+			if(imagetoraw(image, parameters.outfile)){
+				fprintf(stdout,"Error generating raw file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case TGA_DFMT:			/* TGA */
+			if(imagetotga(image, parameters.outfile)){
+				fprintf(stdout,"Error generating tga file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
 		}
 
 		/* free remaining structures */
 		if(dinfo) {
 			opj_destroy_decompress(dinfo);
 		}
+		/* free codestream information structure */
+		if (*indexfilename)	
+			opj_destroy_cstr_info(&cstr_info);
 		/* free image data structure */
 		opj_image_destroy(image);
 
@@ -722,3 +803,6 @@
 }
 //end main
 
+
+
+
diff -urN /home/robin/sldeb/trunk/codec/j2k_to_image.dsp ./codec/j2k_to_image.dsp
--- /home/robin/sldeb/trunk/codec/j2k_to_image.dsp	2007-03-01 16:12:17.000000000 +0000
+++ ./codec/j2k_to_image.dsp	2007-09-28 11:33:52.000000000 +0100
@@ -76,7 +76,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /nodefaultlib:"libcmt" /pdbtype:sept
 # SUBTRACT LINK32 /pdb:none
 
 !ENDIF 
Binary files /home/robin/sldeb/trunk/codec/j2k_to_image.sln and ./codec/j2k_to_image.sln differ
diff -urN /home/robin/sldeb/trunk/codec/j2k_to_image.vcproj ./codec/j2k_to_image.vcproj
--- /home/robin/sldeb/trunk/codec/j2k_to_image.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/j2k_to_image.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,291 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="j2k_to_image"
+	ProjectGUID="{28931669-81A2-4B90-8981-CD707C4E76E6}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/j2k_to_image.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/j2k_to_image.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc,libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/j2k_to_image.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/j2k_to_image.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+		<File
+			RelativePath="j2k_to_image.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/codec/Makefile ./codec/Makefile
--- /home/robin/sldeb/trunk/codec/Makefile	2007-03-01 16:12:17.000000000 +0000
+++ ./codec/Makefile	2007-11-27 22:39:51.000000000 +0000
@@ -5,10 +5,10 @@
 all: j2k_to_image image_to_j2k
 
 j2k_to_image: j2k_to_image.c ../libopenjpeg.a
-	gcc $(CFLAGS) compat/getopt.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
 
 image_to_j2k: image_to_j2k.c ../libopenjpeg.a
-	gcc $(CFLAGS) compat/getopt.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
 
 clean:
 	rm -f j2k_to_image image_to_j2k
diff -urN /home/robin/sldeb/trunk/codec/.svn/all-wcprops ./codec/.svn/all-wcprops
--- /home/robin/sldeb/trunk/codec/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/all-wcprops	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,107 @@
+K 25
+svn:wc:ra_dav:version-url
+V 29
+/svn/!svn/ver/481/trunk/codec
+END
+j2k_to_image.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/407/trunk/codec/j2k_to_image.dsp
+END
+image_to_j2k.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/407/trunk/codec/image_to_j2k.dsp
+END
+j2k_to_image.sln
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/415/trunk/codec/j2k_to_image.sln
+END
+image_to_j2k.sln
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/481/trunk/codec/image_to_j2k.sln
+END
+j2k_to_image.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/316/trunk/codec/j2k_to_image.dsw
+END
+image_to_j2k.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/316/trunk/codec/image_to_j2k.dsw
+END
+index.c
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/481/trunk/codec/index.c
+END
+j2k_to_image.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/481/trunk/codec/j2k_to_image.vcproj
+END
+image_to_j2k.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/481/trunk/codec/image_to_j2k.vcproj
+END
+index.h
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/481/trunk/codec/index.h
+END
+convert.c
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/465/trunk/codec/convert.c
+END
+convert.h
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/412/trunk/codec/convert.h
+END
+j2k_to_image.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/481/trunk/codec/j2k_to_image.c
+END
+image_to_j2k.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/481/trunk/codec/image_to_j2k.c
+END
+dirent.h
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/349/trunk/codec/dirent.h
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/481/trunk/codec/Makefile
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/481/trunk/codec/CMakeLists.txt
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/dir-prop-base ./codec/.svn/dir-prop-base
--- /home/robin/sldeb/trunk/codec/.svn/dir-prop-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/dir-prop-base	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,10 @@
+K 10
+svn:ignore
+V 35
+obj
+obj.w32
+bin
+bin.w32
+lib
+lib.w32
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/entries ./codec/.svn/entries
--- /home/robin/sldeb/trunk/codec/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,244 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/codec
+http://www.openjpeg.org/svn
+
+
+
+2007-11-27T12:38:52.855913Z
+481
+devaux
+has-props
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+j2k_to_image.dsp
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+efe7dd8919734e577cbe4c01b5c0202c
+2007-07-19T13:44:04.294274Z
+407
+devaux
+has-props
+
+image_to_j2k.dsp
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+f44cf11e021df01f118385030ce0f084
+2007-07-19T13:44:04.294274Z
+407
+devaux
+has-props
+
+compat
+dir
+
+j2k_to_image.sln
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+09dfa114321e75c4a2b16e5eeb3fb990
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+image_to_j2k.sln
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+69dee99e4059c2581c10287b1bb478a4
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+j2k_to_image.dsw
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+1cdb816b56cf71de48ddea6b6fb05344
+2006-12-04T16:20:36.252195Z
+316
+devaux
+has-props
+
+image_to_j2k.dsw
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+66a36bb7901a689f6af944cc29229c75
+2006-12-04T16:20:36.252195Z
+316
+devaux
+has-props
+
+index.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+9812b0855e423e81d1d2ad64df0c5832
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+j2k_to_image.vcproj
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+e303200257ed8bec5fb2c40c86585e5e
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+image_to_j2k.vcproj
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+4beb546b1c6e5cba50ec1985714ca946
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+index.h
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+01f9ccfd6202e3c14e1fff8a0ea40deb
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+convert.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+e033a3643c75fe6c2ae03048e7bed706
+2007-10-12T15:04:34.693199Z
+465
+devaux
+has-props
+
+convert.h
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+54564acb511accb16181e952bab11112
+2007-08-20T15:20:42.837462Z
+412
+devaux
+has-props
+
+j2k_to_image.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+9772a698b30eef061cc9b38df348c705
+2007-11-27T12:38:52.855913Z
+481
+devaux
+has-props
+
+image_to_j2k.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+b1092561f52543a5ea0a4ce6d51f9ee7
+2007-11-27T12:38:52.855913Z
+481
+devaux
+has-props
+
+dirent.h
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+62f4d3bc13cac772b4df5deee0434006
+2007-02-27T08:54:56.647526Z
+349
+elangovan
+
+Makefile
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+e05c6181134cccaeeb1524511c209e26
+2007-11-27T12:38:52.855913Z
+481
+devaux
+
+CMakeLists.txt
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+58142234b3060b01228af8adb79e52be
+2007-11-27T12:38:52.855913Z
+481
+devaux
+has-props
+
diff -urN /home/robin/sldeb/trunk/codec/.svn/format ./codec/.svn/format
--- /home/robin/sldeb/trunk/codec/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/format	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/CMakeLists.txt.svn-base ./codec/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/CMakeLists.txt.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/convert.c.svn-base ./codec/.svn/prop-base/convert.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/convert.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/convert.h.svn-base ./codec/.svn/prop-base/convert.h.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/convert.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.c.svn-base ./codec/.svn/prop-base/image_to_j2k.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/image_to_j2k.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.dsp.svn-base ./codec/.svn/prop-base/image_to_j2k.dsp.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/image_to_j2k.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.dsw.svn-base ./codec/.svn/prop-base/image_to_j2k.dsw.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/image_to_j2k.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/image_to_j2k.dsw.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.c.svn-base ./codec/.svn/prop-base/j2k_to_image.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/j2k_to_image.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.dsp.svn-base ./codec/.svn/prop-base/j2k_to_image.dsp.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/j2k_to_image.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.dsw.svn-base ./codec/.svn/prop-base/j2k_to_image.dsw.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/prop-base/j2k_to_image.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/prop-base/j2k_to_image.dsw.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/CMakeLists.txt.svn-base ./codec/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/CMakeLists.txt.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,68 @@
+# Build the demo app, small examples
+
+# First thing define the common source:
+SET(common_SRCS
+  convert.c
+  index.c
+)
+
+# Then check if getopt is present:
+INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
+SET(DONT_HAVE_GETOPT 1)
+IF(UNIX) #I am pretty sure only *nix sys have this anyway
+  CHECK_INCLUDE_FILE("getopt.h" CMAKE_HAVE_GETOPT_H)
+  # Seems like we need the contrary:
+  IF(CMAKE_HAVE_GETOPT_H)
+    SET(DONT_HAVE_GETOPT 0)
+  ENDIF(CMAKE_HAVE_GETOPT_H)
+ENDIF(UNIX)
+
+# If not getopt was found then add it to the lib:
+IF(DONT_HAVE_GETOPT)
+  ADD_DEFINITIONS(-DDONT_HAVE_GETOPT)
+  SET(common_SRCS
+    ${common_SRCS}
+    compat/getopt.c
+  )
+ENDIF(DONT_HAVE_GETOPT)
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+IF(NOT BUILD_SHARED_LIBS)
+  ADD_DEFINITIONS(-DOPJ_STATIC)
+ENDIF(NOT BUILD_SHARED_LIBS)
+
+FIND_PACKAGE(TIFF REQUIRED)
+
+# Loop over all executables:
+FOREACH(exe j2k_to_image image_to_j2k)
+  ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
+  TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjpeg ${TIFF_LIBRARIES})
+  ADD_TEST(${exe} ${EXECUTABLE_OUTPUT_PATH}/${exe})
+  # calling those exe without option will make them fail always:
+  SET_TESTS_PROPERTIES(${exe} PROPERTIES WILL_FAIL TRUE)
+  # On unix you need to link to the math library:
+  IF(UNIX)
+    TARGET_LINK_LIBRARIES(${exe} m)
+  ENDIF(UNIX)
+  # Install exe
+  INSTALL_TARGETS(/bin/ ${exe})
+ENDFOREACH(exe)
+
+# Do testing here, once we know the examples are being built:
+FILE(GLOB_RECURSE OPENJPEG_DATA_IMAGES_GLOB
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2k"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.j2c"
+  "${JPEG2000_CONFORMANCE_DATA_ROOT}/*.jp2"
+  )
+
+FOREACH(filename ${OPENJPEG_DATA_IMAGES_GLOB})
+  GET_FILENAME_COMPONENT(filename_temp ${filename} NAME)
+  ADD_TEST(j2i-${filename_temp} ${EXECUTABLE_OUTPUT_PATH}/j2k_to_image -i ${filename} -o ${filename_temp}.tif)
+ENDFOREACH(filename)
+
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/convert.c.svn-base ./codec/.svn/text-base/convert.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/convert.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,2138 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "openjpeg.h"
+#include "../libs/libtiff/tiffio.h"
+#include "convert.h"
+
+/*
+ * Get logarithm of an integer and round downwards.
+ *
+ * log2(a)
+ */
+static int int_floorlog2(int a) {
+	int l;
+	for (l = 0; a > 1; l++) {
+		a >>= 1;
+	}
+	return l;
+}
+
+/*
+ * Divide an integer by a power of 2 and round upwards.
+ *
+ * a divided by 2^b
+ */
+static int int_ceildivpow2(int a, int b) {
+	return (a + (1 << b) - 1) >> b;
+}
+
+/*
+ * Divide an integer and round upwards.
+ *
+ * a divided by b
+ */
+static int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+
+
+/* -->> -->> -->> -->>
+
+  TGA IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+// TGA header definition.
+#pragma pack(push,1) // Pack structure byte aligned
+typedef struct tga_header
+{                           
+    uint8   id_length;              /* Image id field length    */
+    uint8   colour_map_type;        /* Colour map type          */
+    uint8   image_type;             /* Image type               */
+    /*
+    ** Colour map specification
+    */
+    uint16  colour_map_index;       /* First entry index        */
+    uint16  colour_map_length;      /* Colour map length        */
+    uint8   colour_map_entry_size;  /* Colour map entry size    */
+    /*
+    ** Image specification
+    */
+    uint16  x_origin;               /* x origin of image        */
+    uint16  y_origin;               /* u origin of image        */
+    uint16  image_width;            /* Image width              */
+    uint16  image_height;           /* Image height             */
+    uint8   pixel_depth;            /* Pixel depth              */
+    uint8   image_desc;             /* Image descriptor         */
+} tga_header;
+#pragma pack(pop) // Return to normal structure packing alignment.
+
+int tga_readheader(FILE *fp, int *bits_per_pixel, int *width, int *height, int *flip_image)
+{
+	int palette_size;
+	tga_header tga ;
+
+	if (!bits_per_pixel || !width || !height || !flip_image)
+		return 0;
+	
+	// Read TGA header
+	fread((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	*bits_per_pixel = tga.pixel_depth;
+	
+	*width  = tga.image_width;
+	*height = tga.image_height ;
+
+	// Ignore tga identifier, if present ...
+	if (tga.id_length)
+	{
+		uint8 *id = (uint8 *) malloc(tga.id_length);
+		fread(id, tga.id_length, 1, fp);
+		free(id);  
+	}
+
+	// Test for compressed formats ... not yet supported ...
+	// Note :-  9 - RLE encoded palettized.
+	//	  	   10 - RLE encoded RGB.
+	if (tga.image_type > 8)
+	{
+		fprintf(stderr, "Sorry, compressed tga files are not currently supported.\n");
+		return 0 ;
+	}
+
+	*flip_image = !(tga.image_desc & 32);
+
+	// Palettized formats are not yet supported, skip over the palette, if present ... 
+	palette_size = tga.colour_map_length * (tga.colour_map_entry_size/8);
+	
+	if (palette_size>0)
+	{
+		fprintf(stderr, "File contains a palette - not yet supported.");
+		fseek(fp, palette_size, SEEK_CUR);
+	}
+	return 1;
+}
+
+int tga_writeheader(FILE *fp, int bits_per_pixel, int width, int height, bool flip_image)
+{
+	tga_header tga;
+
+	if (!bits_per_pixel || !width || !height)
+		return 0;
+
+	memset(&tga, 0, sizeof(tga_header));
+
+	tga.pixel_depth = bits_per_pixel;
+	tga.image_width  = width;
+	tga.image_height = height;
+	tga.image_type = 2; // Uncompressed.
+	tga.image_desc = 8; // 8 bits per component.
+
+	if (flip_image)
+		tga.image_desc |= 32;
+
+	// Write TGA header
+	fwrite((uint8*)&tga, sizeof(tga_header), 1, fp);
+
+	return 1;
+}
+
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters) {
+	FILE *f;
+	opj_image_t *image;
+	uint32 image_width, image_height, pixel_bit_depth;
+	uint32 x, y;
+	int flip_image=0;
+	opj_image_cmptparm_t cmptparm[4];	/* maximum 4 components */
+	int numcomps;
+	OPJ_COLOR_SPACE color_space;
+	bool mono ;
+	bool save_alpha;
+	int subsampling_dx, subsampling_dy;
+	int i;	
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+
+	if (!tga_readheader(f, &pixel_bit_depth, &image_width, &image_height, &flip_image))
+		return NULL;
+
+	// We currently only support 24 & 32 bit tga's ...
+	if (!((pixel_bit_depth == 24) || (pixel_bit_depth == 32)))
+		return NULL;
+
+	/* initialize image components */   
+	memset(&cmptparm[0], 0, 4 * sizeof(opj_image_cmptparm_t));
+
+	mono = (pixel_bit_depth == 8) || (pixel_bit_depth == 16);  // Mono with & without alpha.
+	save_alpha = (pixel_bit_depth == 16) || (pixel_bit_depth == 32); // Mono with alpha, or RGB with alpha
+
+	if (mono) {
+		color_space = CLRSPC_GRAY;
+		numcomps = save_alpha ? 2 : 1;
+	}	
+	else {
+		numcomps = save_alpha ? 4 : 3;
+		color_space = CLRSPC_SRGB;
+	}
+
+	subsampling_dx = parameters->subsampling_dx;
+	subsampling_dy = parameters->subsampling_dy;
+
+	for (i = 0; i < numcomps; i++) {
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = 0;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = image_width;
+		cmptparm[i].h = image_height;
+	}
+
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+
+	if (!image)
+		return NULL;
+
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 =	!image->x0 ? (image_width - 1) * subsampling_dx + 1 : image->x0 + (image_width - 1) * subsampling_dx + 1;
+	image->y1 =	!image->y0 ? (image_height - 1) * subsampling_dy + 1 : image->y0 + (image_height - 1) * subsampling_dy + 1;
+
+	/* set image data */
+	for (y=0; y < image_height; y++) 
+	{
+		int index;
+
+		if (flip_image)
+			index = (image_height-y-1)*image_width;
+		else
+			index = y*image_width;
+
+		if (numcomps==3)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				index++;
+			}
+		}
+		else if (numcomps==4)
+		{
+			for (x=0;x<image_width;x++) 
+			{
+				uint8 r,g,b,a;
+				fread(&b, 1, 1, f);
+				fread(&g, 1, 1, f);
+				fread(&r, 1, 1, f);
+				fread(&a, 1, 1, f);
+
+				image->comps[0].data[index]=r;
+				image->comps[1].data[index]=g;
+				image->comps[2].data[index]=b;
+				image->comps[3].data[index]=a;
+				index++;
+			}
+		}
+		else {
+			fprintf(stderr, "Currently unsupported bit depth : %s\n", filename);
+		}
+	}	
+	return image;
+}
+
+int imagetotga(opj_image_t * image, const char *outfile) {
+	int width, height, bpp, x, y;
+	bool write_alpha;
+	int i;
+	uint32 alpha_channel;
+	float r,g,b,a;
+	uint8 value;
+	float scale;
+	FILE *fdest;
+
+	fdest = fopen(outfile, "wb");
+	if (!fdest) {
+		fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+		return 1;
+	}
+
+	for (i = 0; i < image->numcomps-1; i++)	{
+		if ((image->comps[0].dx != image->comps[i+1].dx) 
+			||(image->comps[0].dy != image->comps[i+1].dy) 
+			||(image->comps[0].prec != image->comps[i+1].prec))	{
+      fprintf(stderr, "Unable to create a tga file with such J2K image charateristics.");
+      return 1;
+   }
+	}
+
+	width = image->comps[0].w;
+	height = image->comps[0].h; 
+
+	// Mono with alpha, or RGB with alpha.
+	write_alpha = (image->numcomps==2) || (image->numcomps==4);   
+
+	// Write TGA header 
+	bpp = write_alpha ? 32 : 24;
+	if (!tga_writeheader(fdest, bpp, width , height, true))
+		return 1;
+
+	alpha_channel = image->numcomps-1; 
+
+	scale = 255.0f / (float)((1<<image->comps[0].prec)-1);
+
+	for (y=0; y < height; y++) {
+		uint32 index=y*width;
+
+		for (x=0; x < width; x++, index++)	{
+			r = (float)(image->comps[0].data[index]);
+
+			if (image->numcomps>2) {
+				g = (float)(image->comps[1].data[index]);
+				b = (float)(image->comps[2].data[index]);
+			}
+			else  {// Greyscale ...
+				g = r;
+				b = r;
+			}
+
+			// TGA format writes BGR ...
+			value = (uint8)(b*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(g*scale);
+			fwrite(&value,1,1,fdest);
+
+			value = (uint8)(r*scale);
+			fwrite(&value,1,1,fdest);
+
+			if (write_alpha) {
+				a = (float)(image->comps[alpha_channel].data[index]);
+				value = (uint8)(a*scale);
+				fwrite(&value,1,1,fdest);
+			}
+		}
+	}
+
+	return 0;
+}
+
+/* -->> -->> -->> -->>
+
+  BMP IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+/* WORD defines a two byte word */
+typedef unsigned short int WORD;
+
+/* DWORD defines a four byte word */
+typedef unsigned long int DWORD;
+
+typedef struct {
+  WORD bfType;			/* 'BM' for Bitmap (19776) */
+  DWORD bfSize;			/* Size of the file        */
+  WORD bfReserved1;		/* Reserved : 0            */
+  WORD bfReserved2;		/* Reserved : 0            */
+  DWORD bfOffBits;		/* Offset                  */
+} BITMAPFILEHEADER_t;
+
+typedef struct {
+  DWORD biSize;			/* Size of the structure in bytes */
+  DWORD biWidth;		/* Width of the image in pixels */
+  DWORD biHeight;		/* Heigth of the image in pixels */
+  WORD biPlanes;		/* 1 */
+  WORD biBitCount;		/* Number of color bits by pixels */
+  DWORD biCompression;		/* Type of encoding 0: none 1: RLE8 2: RLE4 */
+  DWORD biSizeImage;		/* Size of the image in bytes */
+  DWORD biXpelsPerMeter;	/* Horizontal (X) resolution in pixels/meter */
+  DWORD biYpelsPerMeter;	/* Vertical (Y) resolution in pixels/meter */
+  DWORD biClrUsed;		/* Number of color used in the image (0: ALL) */
+  DWORD biClrImportant;		/* Number of important color (0: ALL) */
+} BITMAPINFOHEADER_t;
+
+opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters) {
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	int i, numcomps, w, h;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t cmptparm[3];	/* maximum of 3 components */
+	opj_image_t * image = NULL;
+
+	FILE *IN;
+	BITMAPFILEHEADER_t File_h;
+	BITMAPINFOHEADER_t Info_h;
+	unsigned char *RGB;
+	unsigned char *table_R, *table_G, *table_B;
+	unsigned int j, PAD = 0;
+
+	int x, y, index;
+	int gray_scale = 1, not_end_file = 1; 
+
+	unsigned int line = 0, col = 0;
+	unsigned char v, v2;
+	DWORD W, H;
+  
+	IN = fopen(filename, "rb");
+	if (!IN) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+	
+	File_h.bfType = getc(IN);
+	File_h.bfType = (getc(IN) << 8) + File_h.bfType;
+	
+	if (File_h.bfType != 19778) {
+		fprintf(stderr,"Error, not a BMP file!\n");
+		return 0;
+	} else {
+		/* FILE HEADER */
+		/* ------------- */
+		File_h.bfSize = getc(IN);
+		File_h.bfSize = (getc(IN) << 8) + File_h.bfSize;
+		File_h.bfSize = (getc(IN) << 16) + File_h.bfSize;
+		File_h.bfSize = (getc(IN) << 24) + File_h.bfSize;
+
+		File_h.bfReserved1 = getc(IN);
+		File_h.bfReserved1 = (getc(IN) << 8) + File_h.bfReserved1;
+
+		File_h.bfReserved2 = getc(IN);
+		File_h.bfReserved2 = (getc(IN) << 8) + File_h.bfReserved2;
+
+		File_h.bfOffBits = getc(IN);
+		File_h.bfOffBits = (getc(IN) << 8) + File_h.bfOffBits;
+		File_h.bfOffBits = (getc(IN) << 16) + File_h.bfOffBits;
+		File_h.bfOffBits = (getc(IN) << 24) + File_h.bfOffBits;
+
+		/* INFO HEADER */
+		/* ------------- */
+
+		Info_h.biSize = getc(IN);
+		Info_h.biSize = (getc(IN) << 8) + Info_h.biSize;
+		Info_h.biSize = (getc(IN) << 16) + Info_h.biSize;
+		Info_h.biSize = (getc(IN) << 24) + Info_h.biSize;
+
+		Info_h.biWidth = getc(IN);
+		Info_h.biWidth = (getc(IN) << 8) + Info_h.biWidth;
+		Info_h.biWidth = (getc(IN) << 16) + Info_h.biWidth;
+		Info_h.biWidth = (getc(IN) << 24) + Info_h.biWidth;
+		w = Info_h.biWidth;
+
+		Info_h.biHeight = getc(IN);
+		Info_h.biHeight = (getc(IN) << 8) + Info_h.biHeight;
+		Info_h.biHeight = (getc(IN) << 16) + Info_h.biHeight;
+		Info_h.biHeight = (getc(IN) << 24) + Info_h.biHeight;
+		h = Info_h.biHeight;
+
+		Info_h.biPlanes = getc(IN);
+		Info_h.biPlanes = (getc(IN) << 8) + Info_h.biPlanes;
+
+		Info_h.biBitCount = getc(IN);
+		Info_h.biBitCount = (getc(IN) << 8) + Info_h.biBitCount;
+
+		Info_h.biCompression = getc(IN);
+		Info_h.biCompression = (getc(IN) << 8) + Info_h.biCompression;
+		Info_h.biCompression = (getc(IN) << 16) + Info_h.biCompression;
+		Info_h.biCompression = (getc(IN) << 24) + Info_h.biCompression;
+
+		Info_h.biSizeImage = getc(IN);
+		Info_h.biSizeImage = (getc(IN) << 8) + Info_h.biSizeImage;
+		Info_h.biSizeImage = (getc(IN) << 16) + Info_h.biSizeImage;
+		Info_h.biSizeImage = (getc(IN) << 24) + Info_h.biSizeImage;
+
+		Info_h.biXpelsPerMeter = getc(IN);
+		Info_h.biXpelsPerMeter = (getc(IN) << 8) + Info_h.biXpelsPerMeter;
+		Info_h.biXpelsPerMeter = (getc(IN) << 16) + Info_h.biXpelsPerMeter;
+		Info_h.biXpelsPerMeter = (getc(IN) << 24) + Info_h.biXpelsPerMeter;
+
+		Info_h.biYpelsPerMeter = getc(IN);
+		Info_h.biYpelsPerMeter = (getc(IN) << 8) + Info_h.biYpelsPerMeter;
+		Info_h.biYpelsPerMeter = (getc(IN) << 16) + Info_h.biYpelsPerMeter;
+		Info_h.biYpelsPerMeter = (getc(IN) << 24) + Info_h.biYpelsPerMeter;
+
+		Info_h.biClrUsed = getc(IN);
+		Info_h.biClrUsed = (getc(IN) << 8) + Info_h.biClrUsed;
+		Info_h.biClrUsed = (getc(IN) << 16) + Info_h.biClrUsed;
+		Info_h.biClrUsed = (getc(IN) << 24) + Info_h.biClrUsed;
+
+		Info_h.biClrImportant = getc(IN);
+		Info_h.biClrImportant = (getc(IN) << 8) + Info_h.biClrImportant;
+		Info_h.biClrImportant = (getc(IN) << 16) + Info_h.biClrImportant;
+		Info_h.biClrImportant = (getc(IN) << 24) + Info_h.biClrImportant;
+
+		/* Read the data and store them in the OUT file */
+    
+		if (Info_h.biBitCount == 24) {
+			numcomps = 3;
+			color_space = CLRSPC_SRGB;
+			/* initialize image components */
+			memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+			for(i = 0; i < numcomps; i++) {
+				cmptparm[i].prec = 8;
+				cmptparm[i].bpp = 8;
+				cmptparm[i].sgnd = 0;
+				cmptparm[i].dx = subsampling_dx;
+				cmptparm[i].dy = subsampling_dy;
+				cmptparm[i].w = w;
+				cmptparm[i].h = h;
+			}
+			/* create the image */
+			image = opj_image_create(numcomps, &cmptparm[0], color_space);
+			if(!image) {
+				fclose(IN);
+				return NULL;
+			}
+
+			/* set image offset and reference grid */
+			image->x0 = parameters->image_offset_x0;
+			image->y0 = parameters->image_offset_y0;
+			image->x1 =	!image->x0 ? (w - 1) * subsampling_dx + 1 : image->x0 + (w - 1) * subsampling_dx + 1;
+			image->y1 =	!image->y0 ? (h - 1) * subsampling_dy + 1 : image->y0 + (h - 1) * subsampling_dy + 1;
+
+			/* set image data */
+
+			/* Place the cursor at the beginning of the image information */
+			fseek(IN, 0, SEEK_SET);
+			fseek(IN, File_h.bfOffBits, SEEK_SET);
+			
+			W = Info_h.biWidth;
+			H = Info_h.biHeight;
+
+			/* PAD = 4 - (3 * W) % 4; */
+			/* PAD = (PAD == 4) ? 0 : PAD; */
+			PAD = (3 * W) % 4 ? 4 - (3 * W) % 4 : 0;
+			
+			RGB = (unsigned char *) malloc((3 * W + PAD) * H * sizeof(unsigned char));
+			
+			fread(RGB, sizeof(unsigned char), (3 * W + PAD) * H, IN);
+			
+			index = 0;
+
+			for(y = 0; y < (int)H; y++) {
+				unsigned char *scanline = RGB + (3 * W + PAD) * (H - 1 - y);
+				for(x = 0; x < (int)W; x++) {
+					unsigned char *pixel = &scanline[3 * x];
+					image->comps[0].data[index] = pixel[2];	/* R */
+					image->comps[1].data[index] = pixel[1];	/* G */
+					image->comps[2].data[index] = pixel[0];	/* B */
+					index++;
+				}
+			}
+
+			free(RGB);
+
+		} else if (Info_h.biBitCount == 8 && Info_h.biCompression == 0) {
+			table_R = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			table_G = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			table_B = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			
+			for (j = 0; j < Info_h.biClrUsed; j++) {
+				table_B[j] = getc(IN);
+				table_G[j] = getc(IN);
+				table_R[j] = getc(IN);
+				getc(IN);
+				if (table_R[j] != table_G[j] && table_R[j] != table_B[j] && table_G[j] != table_B[j])
+					gray_scale = 0;
+			}
+			
+			/* Place the cursor at the beginning of the image information */
+			fseek(IN, 0, SEEK_SET);
+			fseek(IN, File_h.bfOffBits, SEEK_SET);
+			
+			W = Info_h.biWidth;
+			H = Info_h.biHeight;
+			if (Info_h.biWidth % 2)
+				W++;
+			
+			numcomps = gray_scale ? 1 : 3;
+			color_space = gray_scale ? CLRSPC_GRAY : CLRSPC_SRGB;
+			/* initialize image components */
+			memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+			for(i = 0; i < numcomps; i++) {
+				cmptparm[i].prec = 8;
+				cmptparm[i].bpp = 8;
+				cmptparm[i].sgnd = 0;
+				cmptparm[i].dx = subsampling_dx;
+				cmptparm[i].dy = subsampling_dy;
+				cmptparm[i].w = w;
+				cmptparm[i].h = h;
+			}
+			/* create the image */
+			image = opj_image_create(numcomps, &cmptparm[0], color_space);
+			if(!image) {
+				fclose(IN);
+				return NULL;
+			}
+
+			/* set image offset and reference grid */
+			image->x0 = parameters->image_offset_x0;
+			image->y0 = parameters->image_offset_y0;
+			image->x1 =	!image->x0 ? (w - 1) * subsampling_dx + 1 : image->x0 + (w - 1) * subsampling_dx + 1;
+			image->y1 =	!image->y0 ? (h - 1) * subsampling_dy + 1 : image->y0 + (h - 1) * subsampling_dy + 1;
+
+			/* set image data */
+
+			RGB = (unsigned char *) malloc(W * H * sizeof(unsigned char));
+			
+			fread(RGB, sizeof(unsigned char), W * H, IN);
+			if (gray_scale) {
+				index = 0;
+				for (j = 0; j < W * H; j++) {
+					if ((j % W < W - 1 && Info_h.biWidth % 2) || !(Info_h.biWidth % 2)) {
+						image->comps[0].data[index] = table_R[RGB[W * H - ((j) / (W) + 1) * W + (j) % (W)]];
+						index++;
+					}
+				}
+
+			} else {		
+				index = 0;
+				for (j = 0; j < W * H; j++) {
+					if ((j % W < W - 1 && Info_h.biWidth % 2) || !(Info_h.biWidth % 2)) {
+						unsigned char pixel_index = RGB[W * H - ((j) / (W) + 1) * W + (j) % (W)];
+						image->comps[0].data[index] = table_R[pixel_index];
+						image->comps[1].data[index] = table_G[pixel_index];
+						image->comps[2].data[index] = table_B[pixel_index];
+						index++;
+					}
+				}
+			}
+			free(RGB);
+      free(table_R);
+      free(table_G);
+      free(table_B);
+		} else if (Info_h.biBitCount == 8 && Info_h.biCompression == 1) {				
+			table_R = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			table_G = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			table_B = (unsigned char *) malloc(256 * sizeof(unsigned char));
+			
+			for (j = 0; j < Info_h.biClrUsed; j++) {
+				table_B[j] = getc(IN);
+				table_G[j] = getc(IN);
+				table_R[j] = getc(IN);
+				getc(IN);
+				if (table_R[j] != table_G[j] && table_R[j] != table_B[j] && table_G[j] != table_B[j])
+					gray_scale = 0;
+			}
+
+			numcomps = gray_scale ? 1 : 3;
+			color_space = gray_scale ? CLRSPC_GRAY : CLRSPC_SRGB;
+			/* initialize image components */
+			memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+			for(i = 0; i < numcomps; i++) {
+				cmptparm[i].prec = 8;
+				cmptparm[i].bpp = 8;
+				cmptparm[i].sgnd = 0;
+				cmptparm[i].dx = subsampling_dx;
+				cmptparm[i].dy = subsampling_dy;
+				cmptparm[i].w = w;
+				cmptparm[i].h = h;
+			}
+			/* create the image */
+			image = opj_image_create(numcomps, &cmptparm[0], color_space);
+			if(!image) {
+				fclose(IN);
+				return NULL;
+			}
+
+			/* set image offset and reference grid */
+			image->x0 = parameters->image_offset_x0;
+			image->y0 = parameters->image_offset_y0;
+			image->x1 =	!image->x0 ? (w - 1) * subsampling_dx + 1 : image->x0 + (w - 1) * subsampling_dx + 1;
+			image->y1 =	!image->y0 ? (h - 1) * subsampling_dy + 1 : image->y0 + (h - 1) * subsampling_dy + 1;
+
+			/* set image data */
+			
+			/* Place the cursor at the beginning of the image information */
+			fseek(IN, 0, SEEK_SET);
+			fseek(IN, File_h.bfOffBits, SEEK_SET);
+			
+			RGB = (unsigned char *) malloc(Info_h.biWidth * Info_h.biHeight * sizeof(unsigned char));
+            
+			while (not_end_file) {
+				v = getc(IN);
+				if (v) {
+					v2 = getc(IN);
+					for (i = 0; i < (int) v; i++) {
+						RGB[line * Info_h.biWidth + col] = v2;
+						col++;
+					}
+				} else {
+					v = getc(IN);
+					switch (v) {
+						case 0:
+							col = 0;
+							line++;
+							break;
+						case 1:
+							line++;
+							not_end_file = 0;
+							break;
+						case 2:
+							fprintf(stderr,"No Delta supported\n");
+							opj_image_destroy(image);
+							fclose(IN);
+							return NULL;
+						default:
+							for (i = 0; i < v; i++) {
+								v2 = getc(IN);
+								RGB[line * Info_h.biWidth + col] = v2;
+								col++;
+							}
+							if (v % 2)
+								v2 = getc(IN);
+							break;
+					}
+				}
+			}
+			if (gray_scale) {
+				index = 0;
+				for (line = 0; line < Info_h.biHeight; line++) {
+					for (col = 0; col < Info_h.biWidth; col++) {
+						image->comps[0].data[index] = table_R[(int)RGB[(Info_h.biHeight - line - 1) * Info_h.biWidth + col]];
+						index++;
+					}
+				}
+			} else {
+				index = 0;
+				for (line = 0; line < Info_h.biHeight; line++) {
+					for (col = 0; col < Info_h.biWidth; col++) {
+						unsigned char pixel_index = (int)RGB[(Info_h.biHeight - line - 1) * Info_h.biWidth + col];
+						image->comps[0].data[index] = table_R[pixel_index];
+						image->comps[1].data[index] = table_G[pixel_index];
+						image->comps[2].data[index] = table_B[pixel_index];
+						index++;
+					}
+				}
+			}
+			free(RGB);
+      free(table_R);
+      free(table_G);
+      free(table_B);
+	} else {
+		fprintf(stderr, 
+			"Other system than 24 bits/pixels or 8 bits (no RLE coding) is not yet implemented [%d]\n", Info_h.biBitCount);
+	}
+	fclose(IN);
+ }
+ 
+ return image;
+}
+
+int imagetobmp(opj_image_t * image, const char *outfile) {
+	int w, h;
+	int i, pad;
+	FILE *fdest = NULL;
+	int adjustR, adjustG, adjustB;
+
+	if (image->numcomps == 3 && image->comps[0].dx == image->comps[1].dx
+		&& image->comps[1].dx == image->comps[2].dx
+		&& image->comps[0].dy == image->comps[1].dy
+		&& image->comps[1].dy == image->comps[2].dy
+		&& image->comps[0].prec == image->comps[1].prec
+		&& image->comps[1].prec == image->comps[2].prec) {
+		
+		/* -->> -->> -->> -->>    
+		24 bits color	    
+		<<-- <<-- <<-- <<-- */
+	    
+		fdest = fopen(outfile, "wb");
+		if (!fdest) {
+			fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+			return 1;
+		}
+	    
+		w = image->comps[0].w;	    
+		h = image->comps[0].h;
+	    
+		fprintf(fdest, "BM");
+	    
+		/* FILE HEADER */
+		/* ------------- */
+		fprintf(fdest, "%c%c%c%c",
+			(unsigned char) (h * w * 3 + 3 * h * (w % 2) + 54) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2) + 54)	>> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
+	    
+		/* INFO HEADER   */
+		/* ------------- */
+		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
+		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
+		fprintf(fdest, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (3 * h * w + 3 * h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w * 3 + 3 * h * (w % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff, ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+	    
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("BMP CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("BMP CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc, gc, bc;
+			int r, g, b;
+							
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			g = image->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+			b = image->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+
+			fprintf(fdest, "%c%c%c", bc, gc, rc);
+			
+			if ((i + 1) % w == 0) {
+				for (pad = (3 * w) % 4 ? 4 - (3 * w) % 4 : 0; pad > 0; pad--)	/* ADD */
+					fprintf(fdest, "%c", 0);
+			}
+		}
+		fclose(fdest);
+	} else {			/* Gray-scale */
+
+		/* -->> -->> -->> -->>
+		8 bits non code (Gray scale)
+		<<-- <<-- <<-- <<-- */
+
+		fdest = fopen(outfile, "wb");
+		w = image->comps[0].w;	    
+		h = image->comps[0].h;
+	    
+		fprintf(fdest, "BM");
+	    
+		/* FILE HEADER */
+		/* ------------- */
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + 54 + 1024 + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 8) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + h * (w % 2)) >> 16) & 0xff,
+			(unsigned char) ((h * w + 54 + 1024 + w * (w % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (54 + 1024) & 0xff, ((54 + 1024) >> 8) & 0xff, 
+			((54 + 1024) >> 16) & 0xff,
+			((54 + 1024) >> 24) & 0xff);
+	    
+		/* INFO HEADER */
+		/* ------------- */
+		fprintf(fdest, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,	((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((w) & 0xff),
+			(unsigned char) ((w) >> 8) & 0xff,
+			(unsigned char) ((w) >> 16) & 0xff,
+			(unsigned char) ((w) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) ((h) & 0xff),
+			(unsigned char) ((h) >> 8) & 0xff,
+			(unsigned char) ((h) >> 16) & 0xff,
+			(unsigned char) ((h) >> 24) & 0xff);
+		fprintf(fdest, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
+		fprintf(fdest, "%c%c", (8) & 0xff, ((8) >> 8) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff, ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (unsigned char) (h * w + h * (w % 2)) & 0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 8) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 16) &	0xff,
+			(unsigned char) ((h * w + h * (w % 2)) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,	((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
+		fprintf(fdest, "%c%c%c%c", (256) & 0xff, ((256) >> 8) & 0xff, ((256) >> 16) & 0xff, ((256) >> 24) & 0xff);
+
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("BMP CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+
+		for (i = 0; i < 256; i++) {
+			fprintf(fdest, "%c%c%c%c", i, i, i, 0);
+		}
+
+		for (i = 0; i < w * h; i++) {
+			unsigned char rc;
+			int r;
+			
+			r = image->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+			
+			fprintf(fdest, "%c", rc);
+
+			if ((i + 1) % w == 0) {
+				for (pad = w % 4 ? 4 - w % 4 : 0; pad > 0; pad--)	/* ADD */
+					fprintf(fdest, "%c", 0);
+			}
+		}
+		fclose(fdest);
+	}
+
+	return 0;
+}
+
+/* -->> -->> -->> -->>
+
+PGX IMAGE FORMAT
+
+<<-- <<-- <<-- <<-- */
+
+
+unsigned char readuchar(FILE * f)
+{
+  unsigned char c1;
+  fread(&c1, 1, 1, f);
+  return c1;
+}
+
+unsigned short readushort(FILE * f, int bigendian)
+{
+  unsigned char c1, c2;
+  fread(&c1, 1, 1, f);
+  fread(&c2, 1, 1, f);
+  if (bigendian)
+    return (c1 << 8) + c2;
+  else
+    return (c2 << 8) + c1;
+}
+
+unsigned int readuint(FILE * f, int bigendian)
+{
+  unsigned char c1, c2, c3, c4;
+  fread(&c1, 1, 1, f);
+  fread(&c2, 1, 1, f);
+  fread(&c3, 1, 1, f);
+  fread(&c4, 1, 1, f);
+  if (bigendian)
+    return (c1 << 24) + (c2 << 16) + (c3 << 8) + c4;
+  else
+    return (c4 << 24) + (c3 << 16) + (c2 << 8) + c1;
+}
+
+opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters) {
+	FILE *f = NULL;
+	int w, h, prec;
+	int i, numcomps, max;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t cmptparm;	/* maximum of 1 component  */
+	opj_image_t * image = NULL;
+
+	char endian1,endian2,sign;
+	char signtmp[32];
+
+	char temp[32];
+	int bigendian;
+	opj_image_comp_t *comp = NULL;
+
+	numcomps = 1;
+	color_space = CLRSPC_GRAY;
+
+	memset(&cmptparm, 0, sizeof(opj_image_cmptparm_t));
+
+	max = 0;
+
+	f = fopen(filename, "rb");
+	if (!f) {
+	  fprintf(stderr, "Failed to open %s for reading !\n", filename);
+	  return NULL;
+	}
+
+	fseek(f, 0, SEEK_SET);
+	fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d",temp,&endian1,&endian2,signtmp,&prec,temp,&w,temp,&h);
+	
+	i=0;
+	sign='+';		
+	while (signtmp[i]!='\0') {
+		if (signtmp[i]=='-') sign='-';
+		i++;
+	}
+	
+	fgetc(f);
+	if (endian1=='M' && endian2=='L') {
+		bigendian = 1;
+	} else if (endian2=='M' && endian1=='L') {
+		bigendian = 0;
+	} else {
+		fprintf(stderr, "Bad pgx header, please check input file\n");
+		return NULL;
+	}
+
+	/* initialize image component */
+
+	cmptparm.x0 = parameters->image_offset_x0;
+	cmptparm.y0 = parameters->image_offset_y0;
+	cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 : cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;
+	cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 : cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;
+	
+	if (sign == '-') {
+		cmptparm.sgnd = 1;
+	} else {
+		cmptparm.sgnd = 0;
+	}
+	cmptparm.prec = prec;
+	cmptparm.bpp = prec;
+	cmptparm.dx = parameters->subsampling_dx;
+	cmptparm.dy = parameters->subsampling_dy;
+	
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm, color_space);
+	if(!image) {
+		fclose(f);
+		return NULL;
+	}
+	/* set image offset and reference grid */
+	image->x0 = cmptparm.x0;
+	image->y0 = cmptparm.x0;
+	image->x1 = cmptparm.w;
+	image->y1 = cmptparm.h;
+
+	/* set image data */
+
+	comp = &image->comps[0];
+
+	for (i = 0; i < w * h; i++) {
+		int v;
+		if (comp->prec <= 8) {
+			if (!comp->sgnd) {
+				v = readuchar(f);
+			} else {
+				v = (char) readuchar(f);
+			}
+		} else if (comp->prec <= 16) {
+			if (!comp->sgnd) {
+				v = readushort(f, bigendian);
+			} else {
+				v = (short) readushort(f, bigendian);
+			}
+		} else {
+			if (!comp->sgnd) {
+				v = readuint(f, bigendian);
+			} else {
+				v = (int) readuint(f, bigendian);
+			}
+		}
+		if (v > max)
+			max = v;
+		comp->data[i] = v;
+	}
+	fclose(f);
+	comp->bpp = int_floorlog2(max) + 1;
+
+	return image;
+}
+
+int imagetopgx(opj_image_t * image, const char *outfile) {
+	int w, h;
+	int i, j, compno;
+	FILE *fdest = NULL;
+
+	for (compno = 0; compno < image->numcomps; compno++) {
+		opj_image_comp_t *comp = &image->comps[compno];
+		char bname[256]; /* buffer for name */
+    char *name = bname; /* pointer */
+    int nbytes = 0;
+    const size_t olen = strlen(outfile);
+    const size_t dotpos = olen - 4;
+    const size_t total = dotpos + 1 + 1 + 4; /* '-' + '[1-3]' + '.pgx' */
+    if( outfile[dotpos] != '.' ) {
+      /* `pgx` was recognized but there is no dot at expected position */
+      fprintf(stderr, "ERROR -> Impossible happen." );
+      return 1;
+      }
+    if( total > 256 ) {
+      name = (char*)malloc(total+1);
+      }
+    strncpy(name, outfile, dotpos);
+		if (image->numcomps > 1) {
+			sprintf(name+dotpos, "-%d.pgx", compno);
+		} else {
+			strcpy(name+dotpos, ".pgx");
+		}
+		fdest = fopen(name, "wb");
+		if (!fdest) {
+			fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
+			return 1;
+		}
+    /* dont need name anymore */
+    if( total > 256 ) {
+      free(name);
+      }
+
+		w = image->comps[compno].w;
+		h = image->comps[compno].h;
+	    
+		fprintf(fdest, "PG ML %c %d %d %d\n", comp->sgnd ? '-' : '+', comp->prec, w, h);
+		if (comp->prec <= 8) {
+			nbytes = 1;
+		} else if (comp->prec <= 16) {
+			nbytes = 2;
+		} else {
+			nbytes = 4;
+		}
+		for (i = 0; i < w * h; i++) {
+			int v = image->comps[compno].data[i];
+			for (j = nbytes - 1; j >= 0; j--) {
+				char byte = (char) (v >> (j * 8));
+				fwrite(&byte, 1, 1, fdest);
+			}
+		}
+		fclose(fdest);
+	}
+
+	return 0;
+}
+
+/* -->> -->> -->> -->>
+
+PNM IMAGE FORMAT
+
+<<-- <<-- <<-- <<-- */
+
+opj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters) {
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	FILE *f = NULL;
+	int i, compno, numcomps, w, h;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t cmptparm[3];	/* maximum of 3 components */
+	opj_image_t * image = NULL;
+	char value;
+	
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+
+	if (fgetc(f) != 'P')
+		return 0;
+	value = fgetc(f);
+
+		switch(value) {
+			case '2':	/* greyscale image type */
+			case '5':
+				numcomps = 1;
+				color_space = CLRSPC_GRAY;
+				break;
+				
+			case '3':	/* RGB image type */
+			case '6':
+				numcomps = 3;
+				color_space = CLRSPC_SRGB;
+				break;
+				
+			default:
+				fclose(f);
+				return NULL;
+		}
+		
+		fgetc(f);
+		
+		/* skip comments */
+		while(fgetc(f) == '#') while(fgetc(f) != '\n');
+		
+		fseek(f, -1, SEEK_CUR);
+		fscanf(f, "%d %d\n255", &w, &h);			
+		fgetc(f);	/* <cr><lf> */
+		
+	/* initialize image components */
+	memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < numcomps; i++) {
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = 0;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = w;
+		cmptparm[i].h = h;
+	}
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+	if(!image) {
+		fclose(f);
+		return NULL;
+	}
+
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 = parameters->image_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	image->y1 = parameters->image_offset_y0 + (h - 1) *	subsampling_dy + 1;
+
+	/* set image data */
+
+	if ((value == '2') || (value == '3')) {	/* ASCII */
+		for (i = 0; i < w * h; i++) {
+			for(compno = 0; compno < numcomps; compno++) {
+				unsigned int index = 0;
+				fscanf(f, "%u", &index);
+				/* compno : 0 = GREY, (0, 1, 2) = (R, G, B) */
+				image->comps[compno].data[i] = index;
+			}
+		}
+	} else if ((value == '5') || (value == '6')) {	/* BINARY */
+		for (i = 0; i < w * h; i++) {
+			for(compno = 0; compno < numcomps; compno++) {
+				unsigned char index = 0;
+				fread(&index, 1, 1, f);
+				/* compno : 0 = GREY, (0, 1, 2) = (R, G, B) */
+				image->comps[compno].data[i] = index;
+			}
+		}
+	}
+
+	fclose(f);
+
+	return image;
+}
+
+int imagetopnm(opj_image_t * image, const char *outfile) {
+	int w, wr, h, hr, max;
+	int i, compno;
+	int adjustR, adjustG, adjustB, adjustX;
+	FILE *fdest = NULL;
+	char S2;
+	const char *tmp = outfile;
+
+	while (*tmp) {
+		tmp++;
+	}
+	tmp--;
+	tmp--;
+	S2 = *tmp;
+
+	if (image->numcomps == 3 && image->comps[0].dx == image->comps[1].dx
+		&& image->comps[1].dx == image->comps[2].dx
+		&& image->comps[0].dy == image->comps[1].dy
+		&& image->comps[1].dy == image->comps[2].dy
+		&& image->comps[0].prec == image->comps[1].prec
+		&& image->comps[1].prec == image->comps[2].prec
+		&& S2 !='g' && S2 !='G') {
+
+		fdest = fopen(outfile, "wb");
+		if (!fdest) {
+			fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+			return 1;
+		}
+
+		w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
+		wr = image->comps[0].w;
+        
+		h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
+		hr = image->comps[0].h;
+	    
+		max = image->comps[0].prec > 8 ? 255 : (1 << image->comps[0].prec) - 1;
+	    
+		image->comps[0].x0 = int_ceildivpow2(image->comps[0].x0 - int_ceildiv(image->x0, image->comps[0].dx), image->comps[0].factor);
+		image->comps[0].y0 = int_ceildivpow2(image->comps[0].y0 -	int_ceildiv(image->y0, image->comps[0].dy), image->comps[0].factor);
+
+		fprintf(fdest, "P6\n%d %d\n%d\n", wr, hr, max);
+
+		if (image->comps[0].prec > 8) {
+			adjustR = image->comps[0].prec - 8;
+			printf("PNM CONVERSION: Truncating component 0 from %d bits to 8 bits\n", image->comps[0].prec);
+		}
+		else 
+			adjustR = 0;
+		if (image->comps[1].prec > 8) {
+			adjustG = image->comps[1].prec - 8;
+			printf("PNM CONVERSION: Truncating component 1 from %d bits to 8 bits\n", image->comps[1].prec);
+		}
+		else 
+			adjustG = 0;
+		if (image->comps[2].prec > 8) {
+			adjustB = image->comps[2].prec - 8;
+			printf("PNM CONVERSION: Truncating component 2 from %d bits to 8 bits\n", image->comps[2].prec);
+		}
+		else 
+			adjustB = 0;
+
+
+		for (i = 0; i < wr * hr; i++) {
+			int r, g, b;
+			unsigned char rc,gc,bc;
+			r = image->comps[0].data[i];
+			r += (image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0);
+			rc = (unsigned char) ((r >> adjustR)+((r >> (adjustR-1))%2));
+
+			g = image->comps[1].data[i];
+			g += (image->comps[1].sgnd ? 1 << (image->comps[1].prec - 1) : 0);
+			gc = (unsigned char) ((g >> adjustG)+((g >> (adjustG-1))%2));
+			
+			b = image->comps[2].data[i];
+			b += (image->comps[2].sgnd ? 1 << (image->comps[2].prec - 1) : 0);
+			bc = (unsigned char) ((b >> adjustB)+((b >> (adjustB-1))%2));
+			
+			fprintf(fdest, "%c%c%c", rc, gc, bc);
+		}
+		fclose(fdest);
+
+	} else {
+		int ncomp=(S2=='g' || S2=='G')?1:image->numcomps;
+		if (image->numcomps > ncomp) {
+			fprintf(stderr,"WARNING -> [PGM files] Only the first component\n");
+			fprintf(stderr,"           is written to the file\n");
+		}
+		for (compno = 0; compno < ncomp; compno++) {
+			char name[256];
+			if (ncomp > 1) {
+				sprintf(name, "%d.%s", compno, outfile);
+			} else {
+				sprintf(name, "%s", outfile);
+			}
+			
+			fdest = fopen(name, "wb");
+			if (!fdest) {
+				fprintf(stderr, "ERROR -> failed to open %s for writing\n", name);
+				return 1;
+			}
+            
+			w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
+			wr = image->comps[compno].w;
+			
+			h = int_ceildiv(image->y1 - image->y0, image->comps[compno].dy);
+			hr = image->comps[compno].h;
+			
+			max = image->comps[compno].prec > 8 ? 255 : (1 << image->comps[compno].prec) - 1;
+			
+			image->comps[compno].x0 = int_ceildivpow2(image->comps[compno].x0 - int_ceildiv(image->x0, image->comps[compno].dx), image->comps[compno].factor);
+			image->comps[compno].y0 = int_ceildivpow2(image->comps[compno].y0 - int_ceildiv(image->y0, image->comps[compno].dy), image->comps[compno].factor);
+			
+			fprintf(fdest, "P5\n%d %d\n%d\n", wr, hr, max);
+			
+			if (image->comps[compno].prec > 8) {
+				adjustX = image->comps[0].prec - 8;
+				printf("PNM CONVERSION: Truncating component %d from %d bits to 8 bits\n",compno, image->comps[compno].prec);
+			}
+			else 
+				adjustX = 0;
+			
+			for (i = 0; i < wr * hr; i++) {
+				int l;
+				unsigned char lc;
+				l = image->comps[compno].data[i];
+				l += (image->comps[compno].sgnd ? 1 << (image->comps[compno].prec - 1) : 0);
+				lc = (unsigned char) ((l >> adjustX)+((l >> (adjustX-1))%2));
+				fprintf(fdest, "%c", lc);
+			}
+			fclose(fdest);
+		}
+	}
+
+	return 0;
+}
+
+/* -->> -->> -->> -->>
+
+	TIFF IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+typedef struct tiff_infoheader{
+	DWORD tiWidth;  // Width of Image in pixel
+	DWORD tiHeight; // Height of Image in pixel
+	DWORD tiPhoto;	// Photometric
+	WORD  tiBps;	// Bits per sample
+	WORD  tiSf;		// Sample Format
+	WORD  tiSpp;	// Sample per pixel 1-bilevel,gray scale , 2- RGB
+	WORD  tiPC;	// Planar config (1-Interleaved, 2-Planarcomp)
+}tiff_infoheader_t;
+
+int imagetotif(opj_image_t * image, const char *outfile) {
+	int width, height, imgsize;
+	int bps,index,adjust = 0;
+	int last_i=0;
+	TIFF *tif;
+	tdata_t buf;
+	tstrip_t strip;
+	tsize_t strip_size;
+
+	if (image->numcomps == 3 && image->comps[0].dx == image->comps[1].dx
+		&& image->comps[1].dx == image->comps[2].dx
+		&& image->comps[0].dy == image->comps[1].dy
+		&& image->comps[1].dy == image->comps[2].dy
+		&& image->comps[0].prec == image->comps[1].prec
+		&& image->comps[1].prec == image->comps[2].prec) {
+
+			/* -->> -->> -->>    
+			RGB color	    
+			<<-- <<-- <<-- */
+
+			tif = TIFFOpen(outfile, "wb"); 
+			if (!tif) {
+				fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+				return 1;
+			}
+
+			width	= image->comps[0].w;
+			height	= image->comps[0].h;
+			imgsize = width * height ;
+			bps		= image->comps[0].prec;
+			/* Set tags */
+			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
+			TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);
+			TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 3);
+			TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);
+			TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
+			TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
+			TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_RGB);
+			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
+
+			/* Get a buffer for the data */
+			strip_size=TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index=0;		
+			adjust = image->comps[0].sgnd ? 1 << (image->comps[0].prec - 1) : 0;
+			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+				unsigned char *dat8;
+				int i, ssize;
+				ssize = TIFFStripSize(tif);
+				dat8 = buf;
+				if (image->comps[0].prec == 8){
+					for (i=0; i<ssize-2; i+=3) {	// 8 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){			
+								r += adjust;
+								g += adjust;
+								b += adjust;
+							}
+							dat8[i+0] = r ;	// R 
+							dat8[i+1] = g ;	// G 
+							dat8[i+2] = b ;	// B 
+							index++;
+							last_i = i+3;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i=last_i; i<ssize; i+=3) {	// 8 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){			
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] = r ;	// R 
+								if(i+1 <ssize) dat8[i+1] = g ;	else break;// G 
+								if(i+2 <ssize) dat8[i+2] = b ;	else break;// B 
+								index++;
+							}else
+								break;
+						}
+					}
+				}else if (image->comps[0].prec == 12){
+					for (i=0; i<ssize-8; i+=9) {	// 12 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						int r1 = 0,g1 = 0,b1 = 0;
+						if((index < imgsize)&(index+1 < imgsize)){
+							r  = image->comps[0].data[index];
+							g  = image->comps[1].data[index];
+							b  = image->comps[2].data[index];
+							r1 = image->comps[0].data[index+1];
+							g1 = image->comps[1].data[index+1];
+							b1 = image->comps[2].data[index+1];
+							if (image->comps[0].sgnd){														
+								r  += adjust;
+								g  += adjust;
+								b  += adjust;
+								r1 += adjust;
+								g1 += adjust;
+								b1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f);
+							dat8[i+2] = g ;		
+							dat8[i+3] = (b >> 4);
+							dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+5] = r1;		
+							dat8[i+6] = (g1 >> 4);
+							dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);
+							dat8[i+8] = b1;
+							index+=2;
+							last_i = i+9;
+						}else
+							break;
+					}
+					if(last_i < ssize){
+						for (i= last_i; i<ssize; i+=9) {	// 12 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							int r1 = 0,g1 = 0,b1 = 0;
+							if((index < imgsize)&(index+1 < imgsize)){
+								r  = image->comps[0].data[index];
+								g  = image->comps[1].data[index];
+								b  = image->comps[2].data[index];
+								r1 = image->comps[0].data[index+1];
+								g1 = image->comps[1].data[index+1];
+								b1 = image->comps[2].data[index+1];
+								if (image->comps[0].sgnd){														
+									r  += adjust;
+									g  += adjust;
+									b  += adjust;
+									r1 += adjust;
+									g1 += adjust;
+									b1 += adjust;
+								}
+								dat8[i+0] = (r >> 4);
+								if(i+1 <ssize) dat8[i+1] = ((r & 0x0f) << 4 )|((g >> 8)& 0x0f); else break;
+								if(i+2 <ssize) dat8[i+2] = g ;			else break;
+								if(i+3 <ssize) dat8[i+3] = (b >> 4);	else break;
+								if(i+4 <ssize) dat8[i+4] = ((b & 0x0f) << 4 )|((r1 >> 8)& 0x0f);else break;
+								if(i+5 <ssize) dat8[i+5] = r1;			else break;
+								if(i+6 <ssize) dat8[i+6] = (g1 >> 4);	else break;
+								if(i+7 <ssize) dat8[i+7] = ((g1 & 0x0f)<< 4 )|((b1 >> 8)& 0x0f);else break;
+								if(i+8 <ssize) dat8[i+8] = b1;			else break;
+								index+=2;
+							}else
+								break;
+						}
+					}
+				}else if (image->comps[0].prec == 16){
+					for (i=0 ; i<ssize-5 ; i+=6) {	// 16 bits per pixel 
+						int r = 0,g = 0,b = 0;
+						if(index < imgsize){
+							r = image->comps[0].data[index];
+							g = image->comps[1].data[index];
+							b = image->comps[2].data[index];
+							if (image->comps[0].sgnd){
+							r += adjust;
+							g += adjust;
+							b += adjust;
+							}
+							dat8[i+0] =  r;//LSB
+							dat8[i+1] = (r >> 8);//MSB	 
+							dat8[i+2] =  g;		
+							dat8[i+3] = (g >> 8);
+							dat8[i+4] =  b;	
+							dat8[i+5] = (b >> 8);
+							index++;
+							last_i = i+6;
+						}else
+							break; 
+					}
+					if(last_i < ssize){
+						for (i=0 ; i<ssize ; i+=6) {	// 16 bits per pixel 
+							int r = 0,g = 0,b = 0;
+							if(index < imgsize){
+								r = image->comps[0].data[index];
+								g = image->comps[1].data[index];
+								b = image->comps[2].data[index];
+								if (image->comps[0].sgnd){
+									r += adjust;
+									g += adjust;
+									b += adjust;
+								}
+								dat8[i+0] =  r;//LSB
+								if(i+1 <ssize) dat8[i+1] = (r >> 8);else break;//MSB	 
+								if(i+2 <ssize) dat8[i+2] =  g;		else break;
+								if(i+3 <ssize) dat8[i+3] = (g >> 8);else break;
+								if(i+4 <ssize) dat8[i+4] =  b;		else break;
+								if(i+5 <ssize) dat8[i+5] = (b >> 8);else break;
+								index++;
+							}else
+								break; 
+						}						
+					}
+				}else{
+					fprintf(stderr,"Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+					fprintf(stderr,"Aborting\n");
+					return 1;
+				}
+				TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
+			}
+			_TIFFfree(buf);
+			TIFFClose(tif);
+		}else if (image->numcomps == 1){
+			/* -->> -->> -->>    
+			Black and White	    
+			<<-- <<-- <<-- */
+
+			tif = TIFFOpen(outfile, "wb"); 
+			if (!tif) {
+				fprintf(stderr, "ERROR -> failed to open %s for writing\n", outfile);
+				return 1;
+			}
+
+			width	= image->comps[0].w;
+			height	= image->comps[0].h;
+			imgsize = width * height;
+			bps		= image->comps[0].prec;
+
+			/* Set tags */
+			TIFFSetField(tif, TIFFTAG_IMAGEWIDTH, width);
+			TIFFSetField(tif, TIFFTAG_IMAGELENGTH, height);
+			TIFFSetField(tif, TIFFTAG_SAMPLESPERPIXEL, 1);
+			TIFFSetField(tif, TIFFTAG_BITSPERSAMPLE, bps);
+			TIFFSetField(tif, TIFFTAG_ORIENTATION, ORIENTATION_TOPLEFT);
+			TIFFSetField(tif, TIFFTAG_PLANARCONFIG, PLANARCONFIG_CONTIG);
+			TIFFSetField(tif, TIFFTAG_PHOTOMETRIC, PHOTOMETRIC_MINISBLACK);
+			TIFFSetField(tif, TIFFTAG_ROWSPERSTRIP, 1);
+
+			/* Get a buffer for the data */
+			strip_size = TIFFStripSize(tif);
+			buf = _TIFFmalloc(strip_size);
+			index = 0;			
+			for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+				unsigned char *dat8;
+				int i;
+				dat8 = buf;
+				if (image->comps[0].prec == 8){
+					for (i=0; i<TIFFStripSize(tif); i+=1) {	// 8 bits per pixel 
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							index++;
+						}else
+							break; 
+					}
+				}else if (image->comps[0].prec == 12){
+					for (i = 0; i<TIFFStripSize(tif); i+=3) {	// 12 bits per pixel 
+						if(index < imgsize){
+							int r = 0, r1 = 0;
+							r  = image->comps[0].data[index];
+							r1 = image->comps[0].data[index+1];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+								r1 += adjust;
+							}
+							dat8[i+0] = (r >> 4);
+							dat8[i+1] = ((r & 0x0f) << 4 )|((r1 >> 8)& 0x0f);
+							dat8[i+2] = r1 ;
+							index+=2;
+						}else
+							break; 
+					}
+				}else if (image->comps[0].prec == 16){
+					for (i=0; i<TIFFStripSize(tif); i+=2) {	// 16 bits per pixel 
+						if(index < imgsize){
+							int r = 0;
+							r = image->comps[0].data[index];
+							if (image->comps[0].sgnd){
+								r  += adjust;
+							}
+							dat8[i+0] = r;
+							dat8[i+1] = r >> 8;
+							index++;
+						}else
+							break; 
+					}
+				}else{
+					fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",image->comps[0].prec);
+					fprintf(stderr,"Aborting\n");
+					return 1;
+				}
+				TIFFWriteEncodedStrip(tif, strip, buf, strip_size);
+			}
+			_TIFFfree(buf);
+			TIFFClose(tif);
+		}else{
+			fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+			fprintf(stderr,"Aborting\n");
+			return 1;
+		}
+		return 0;
+}
+
+opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters)
+{
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+	TIFF *tif;
+	tiff_infoheader_t Info;
+	tdata_t buf;
+	tstrip_t strip;
+	tsize_t strip_size;
+	int j, numcomps, w, h,index;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t cmptparm[3];
+	opj_image_t * image = NULL;
+	int imgsize = 0;
+
+	tif = TIFFOpen(filename, "r");
+
+	if (!tif) {
+		fprintf(stderr, "Failed to open %s for reading\n", filename);
+		return 0;
+	}
+
+	TIFFGetField(tif, TIFFTAG_IMAGEWIDTH, &Info.tiWidth);
+	TIFFGetField(tif, TIFFTAG_IMAGELENGTH, &Info.tiHeight);
+	TIFFGetField(tif, TIFFTAG_BITSPERSAMPLE, &Info.tiBps);
+	TIFFGetField(tif, TIFFTAG_SAMPLEFORMAT, &Info.tiSf);
+	TIFFGetField(tif, TIFFTAG_SAMPLESPERPIXEL, &Info.tiSpp);
+	Info.tiPhoto = 0;
+	TIFFGetField(tif, TIFFTAG_PHOTOMETRIC, &Info.tiPhoto);
+	TIFFGetField(tif, TIFFTAG_PLANARCONFIG, &Info.tiPC);
+	w= Info.tiWidth;
+	h= Info.tiHeight;
+	
+	if (Info.tiPhoto == 2) { 
+		/* -->> -->> -->>    
+		RGB color	    
+		<<-- <<-- <<-- */
+
+		numcomps = 3;
+		color_space = CLRSPC_SRGB;
+		/* initialize image components*/ 
+		memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+		for(j = 0; j < numcomps; j++) {
+			if (parameters->cp_cinema) {
+				cmptparm[j].prec = 12;
+				cmptparm[j].bpp = 12;
+			}else{
+				cmptparm[j].prec = Info.tiBps;
+				cmptparm[j].bpp = Info.tiBps;
+			}
+			cmptparm[j].sgnd = 0;
+			cmptparm[j].dx = subsampling_dx;
+			cmptparm[j].dy = subsampling_dy;
+			cmptparm[j].w = w;
+			cmptparm[j].h = h;
+		}
+		/* create the image*/ 
+		image = opj_image_create(numcomps, &cmptparm[0], color_space);
+		if(!image) {
+			TIFFClose(tif);
+			return NULL;
+		}
+
+		/* set image offset and reference grid */
+		image->x0 = parameters->image_offset_x0;
+		image->y0 = parameters->image_offset_y0;
+		image->x1 =	!image->x0 ? (w - 1) * subsampling_dx + 1 : image->x0 + (w - 1) * subsampling_dx + 1;
+		image->y1 =	!image->y0 ? (h - 1) * subsampling_dy + 1 : image->y0 + (h - 1) * subsampling_dy + 1;
+
+		buf = _TIFFmalloc(TIFFStripSize(tif));
+		strip_size=0;
+		strip_size=TIFFStripSize(tif);
+		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
+		/* Read the Image components*/
+		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+			unsigned char *dat8;
+			int i, ssize;
+			ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
+			dat8 = buf;
+
+			if (Info.tiBps==12){
+				for (i=0; i<ssize; i+=9) {	/*12 bits per pixel*/
+					if((index < imgsize)&(index+1 < imgsize)){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4);
+						image->comps[1].data[index]   = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						image->comps[2].data[index]   = ( dat8[i+3]<<4)			|(dat8[i+4]>>4);
+						image->comps[0].data[index+1] = ((dat8[i+4]& 0x0f)<< 8)	| dat8[i+5];
+						image->comps[1].data[index+1] = ( dat8[i+6] <<4)		|(dat8[i+7]>>4);
+						image->comps[2].data[index+1] = ((dat8[i+7]& 0x0f)<< 8)	| dat8[i+8];
+						index+=2;
+					}else
+						break;
+				}
+			}
+			else if( Info.tiBps==16){
+				for (i=0; i<ssize; i+=6) {	/* 16 bits per pixel */
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0]; // R 
+						image->comps[1].data[index] = ( dat8[i+3] << 8 ) | dat8[i+2]; // G 
+						image->comps[2].data[index] = ( dat8[i+5] << 8 ) | dat8[i+4]; // B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = (image->comps[0].data[index] + 0x08) >> 4 ;
+							image->comps[1].data[index] = (image->comps[1].data[index] + 0x08) >> 4 ;
+							image->comps[2].data[index] = (image->comps[2].data[index] + 0x08) >> 4 ;
+						}
+						index++;
+					}else
+						break;
+				}
+			}
+			else if ( Info.tiBps==8){
+				for (i=0; i<ssize; i+=3) {	/* 8 bits per pixel */
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];// R 
+						image->comps[1].data[index] = dat8[i+1];// G 
+						image->comps[2].data[index] = dat8[i+2];// B 
+						if(parameters->cp_cinema){/* Rounding to 12 bits*/
+							image->comps[0].data[index] = image->comps[0].data[index] << 4 ;
+							image->comps[1].data[index] = image->comps[1].data[index] << 4 ;
+							image->comps[2].data[index] = image->comps[2].data[index] << 4 ;
+						}
+						index++;
+					}else
+						break;
+				}
+			}
+			else{
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"Aborting\n");
+				return NULL;
+			}
+		}
+
+		_TIFFfree(buf);
+		TIFFClose(tif);
+	}else if(Info.tiPhoto == 1) { 
+		/* -->> -->> -->>    
+		Black and White
+		<<-- <<-- <<-- */
+
+		numcomps = 1;
+		color_space = CLRSPC_GRAY;
+		/* initialize image components*/ 
+		memset(&cmptparm[0], 0, sizeof(opj_image_cmptparm_t));
+		cmptparm[0].prec = Info.tiBps;
+		cmptparm[0].bpp = Info.tiBps;
+		cmptparm[0].sgnd = 0;
+		cmptparm[0].dx = subsampling_dx;
+		cmptparm[0].dy = subsampling_dy;
+		cmptparm[0].w = w;
+		cmptparm[0].h = h;
+
+		/* create the image*/ 
+		image = opj_image_create(numcomps, &cmptparm[0], color_space);
+		if(!image) {
+			TIFFClose(tif);
+			return NULL;
+		}
+		/* set image offset and reference grid */
+		image->x0 = parameters->image_offset_x0;
+		image->y0 = parameters->image_offset_y0;
+		image->x1 =	!image->x0 ? (w - 1) * subsampling_dx + 1 : image->x0 + (w - 1) * subsampling_dx + 1;
+		image->y1 =	!image->y0 ? (h - 1) * subsampling_dy + 1 : image->y0 + (h - 1) * subsampling_dy + 1;
+
+		buf = _TIFFmalloc(TIFFStripSize(tif));
+		strip_size = 0;
+		strip_size = TIFFStripSize(tif);
+		index = 0;
+		imgsize = image->comps[0].w * image->comps[0].h ;
+		/* Read the Image components*/
+		for (strip = 0; strip < TIFFNumberOfStrips(tif); strip++) {
+			unsigned char *dat8;
+			int i, ssize;
+			ssize = TIFFReadEncodedStrip(tif, strip, buf, strip_size);
+			dat8 = buf;
+
+			if (Info.tiBps==12){
+				for (i=0; i<ssize; i+=3) {	/* 12 bits per pixel*/
+					if(index < imgsize){
+						image->comps[0].data[index]   = ( dat8[i+0]<<4 )		|(dat8[i+1]>>4) ;
+						image->comps[0].data[index+1] = ((dat8[i+1]& 0x0f)<< 8)	| dat8[i+2];
+						index+=2;
+					}else
+						break;
+				}
+			}
+			else if( Info.tiBps==16){
+				for (i=0; i<ssize; i+=2) {	/* 16 bits per pixel */
+					if(index < imgsize){
+						image->comps[0].data[index] = ( dat8[i+1] << 8 ) | dat8[i+0];
+						index++;
+					}else
+						break;
+				}
+			}
+			else if ( Info.tiBps==8){
+				for (i=0; i<ssize; i+=1) {	/* 8 bits per pixel */
+					if(index < imgsize){
+						image->comps[0].data[index] = dat8[i+0];
+						index++;
+					}else
+						break;
+				}
+			}
+			else{
+				fprintf(stderr,"TIFF file creation. Bits=%d, Only 8,12,16 bits implemented\n",Info.tiBps);
+				fprintf(stderr,"Aborting\n");
+				return NULL;
+			}
+		}
+
+		_TIFFfree(buf);
+		TIFFClose(tif);
+	}else{
+		fprintf(stderr,"TIFF file creation. Bad color format. Only RGB & Grayscale has been implemented\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+	return image;
+}
+
+/* -->> -->> -->> -->>
+
+	RAW IMAGE FORMAT
+
+ <<-- <<-- <<-- <<-- */
+
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp) {
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	FILE *f = NULL;
+	int i, compno, numcomps, w, h;
+	OPJ_COLOR_SPACE color_space;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_image_t * image = NULL;
+	unsigned short ch;
+	
+	if((! (raw_cp->rawWidth & raw_cp->rawHeight & raw_cp->rawComp & raw_cp->rawBitDepth)) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		fprintf(stderr,"Please use the Format option -F:\n");
+		fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+		fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "Failed to open %s for reading !!\n", filename);
+		fprintf(stderr,"Aborting\n");
+		return NULL;
+	}
+	numcomps = raw_cp->rawComp;
+	color_space = CLRSPC_SRGB;
+	w = raw_cp->rawWidth;
+	h = raw_cp->rawHeight;
+	cmptparm = (opj_image_cmptparm_t*) malloc(numcomps * sizeof(opj_image_cmptparm_t));
+	
+	/* initialize image components */	
+	memset(&cmptparm[0], 0, numcomps * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < numcomps; i++) {		
+		cmptparm[i].prec = raw_cp->rawBitDepth;
+		cmptparm[i].bpp = raw_cp->rawBitDepth;
+		cmptparm[i].sgnd = raw_cp->rawSigned;
+		cmptparm[i].dx = subsampling_dx;
+		cmptparm[i].dy = subsampling_dy;
+		cmptparm[i].w = w;
+		cmptparm[i].h = h;
+	}
+	/* create the image */
+	image = opj_image_create(numcomps, &cmptparm[0], color_space);
+	if(!image) {
+		fclose(f);
+		return NULL;
+	}
+	/* set image offset and reference grid */
+	image->x0 = parameters->image_offset_x0;
+	image->y0 = parameters->image_offset_y0;
+	image->x1 = parameters->image_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	image->y1 = parameters->image_offset_y0 + (h - 1) *	subsampling_dy + 1;
+
+	if(raw_cp->rawBitDepth <= 8)
+	{
+		unsigned char value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 1, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(char)value:value;
+			}
+		}
+	}
+	else
+	{
+		unsigned short value = 0;
+		for(compno = 0; compno < numcomps; compno++) {
+			for (i = 0; i < w * h; i++) {
+				if (!fread(&value, 2, 1, f)) {
+					fprintf(stderr,"Error reading raw file. End of file probably reached.\n");
+					return NULL;
+				}
+				image->comps[compno].data[i] = raw_cp->rawSigned?(short)value:value;
+			}
+		}
+	}
+
+	if (fread(&ch, 1, 1, f)) {
+		fprintf(stderr,"Warning. End of raw file not reached... processing anyway\n");
+	}
+	fclose(f);
+
+	return image;
+}
+
+int imagetoraw(opj_image_t * image, const char *outfile)
+{
+	FILE *rawFile = NULL;
+	int compno;
+	int w, h;
+	int line, row;
+	int *ptr;
+
+	if((image->numcomps * image->x1 * image->y1) == 0)
+	{
+		fprintf(stderr,"\nError: invalid raw image parameters\n");
+		return 1;
+	}
+
+	rawFile = fopen(outfile, "wb");
+	if (!rawFile) {
+		fprintf(stderr, "Failed to open %s for writing !!\n", outfile);
+		return 1;
+	}
+
+	fprintf(stdout,"Raw image characteristics: %d components\n", image->numcomps);
+
+	for(compno = 0; compno < image->numcomps; compno++)
+	{
+		fprintf(stdout,"Component %d characteristics: %dx%dx%d %s\n", compno, image->comps[compno].w,
+			image->comps[compno].h, image->comps[compno].prec, image->comps[compno].sgnd==1 ? "signed": "unsigned");
+
+		w = image->comps[compno].w;
+		h = image->comps[compno].h;
+
+		if(image->comps[compno].prec <= 8)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (signed char) (*ptr & mask);
+						fwrite(&curr, sizeof(signed char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned char curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{	
+						curr = (unsigned char) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned char), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if(image->comps[compno].prec <= 16)
+		{
+			if(image->comps[compno].sgnd == 1)
+			{
+				signed short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{					
+						curr = (signed short int) (*ptr & mask);
+						fwrite(&curr, sizeof(signed short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+			else if(image->comps[compno].sgnd == 0)
+			{
+				unsigned short int curr;
+				int mask = (1 << image->comps[compno].prec) - 1;
+				ptr = image->comps[compno].data;
+				for (line = 0; line < h; line++) {
+					for(row = 0; row < w; row++)	{				
+						curr = (unsigned short int) (*ptr & mask);
+						fwrite(&curr, sizeof(unsigned short int), 1, rawFile);
+						ptr++;
+					}
+				}
+			}
+		}
+		else if (image->comps[compno].prec <= 32)
+		{
+			fprintf(stderr,"More than 16 bits per component no handled yet\n");
+			return 1;
+		}
+		else
+		{
+			fprintf(stderr,"Error: invalid precision: %d\n", image->comps[compno].prec);
+			return 1;
+		}
+	}
+	fclose(rawFile);
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/convert.h.svn-base ./codec/.svn/text-base/convert.h.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/convert.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,78 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __J2K_CONVERT_H
+#define __J2K_CONVERT_H
+
+/**@name RAW image encoding parameters */
+/*@{*/
+typedef struct raw_cparameters {
+	/** width of the raw image */
+	int rawWidth;
+	/** height of the raw image */
+	int rawHeight;
+	/** components of the raw image */
+	int rawComp;
+	/** bit depth of the raw image */
+	int rawBitDepth;
+	/** signed/unsigned raw image */
+	bool rawSigned;
+	/*@}*/
+} raw_cparameters_t;
+
+/* TGA conversion */
+opj_image_t* tgatoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetotga(opj_image_t * image, const char *outfile);
+
+/* BMP conversion */
+opj_image_t* bmptoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetobmp(opj_image_t *image, const char *outfile);
+
+/* TIFF to image conversion*/
+opj_image_t* tiftoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetotif(opj_image_t *image, const char *outfile);
+/**
+Load a single image component encoded in PGX file format
+@param filename Name of the PGX file to load
+@param parameters *List ?*
+@return Returns a greyscale image if successful, returns NULL otherwise
+*/
+opj_image_t* pgxtoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetopgx(opj_image_t *image, const char *outfile);
+
+opj_image_t* pnmtoimage(const char *filename, opj_cparameters_t *parameters);
+int imagetopnm(opj_image_t *image, const char *outfile);
+
+/* RAW conversion */
+int imagetoraw(opj_image_t * image, const char *outfile);
+opj_image_t* rawtoimage(const char *filename, opj_cparameters_t *parameters, raw_cparameters_t *raw_cp);
+
+#endif /* __J2K_CONVERT_H */
+
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/dirent.h.svn-base ./codec/.svn/text-base/dirent.h.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/dirent.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/dirent.h.svn-base	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,677 @@
+
+/*
+ * uce-dirent.h - operating system independent dirent implementation
+ * 
+ * Copyright (C) 1998-2002  Toni Ronkko
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * 
+ * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
+ *
+ * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
+ *
+ * $Log: uce-dirent.h,v $
+ * Revision 1.7  2002/05/13 10:48:35  tr
+ * embedded some source code directly to the header so that no source
+ * modules need to be included in the MS Visual C project using the
+ * interface, removed all the dependencies to other headers of the `uce'
+ * library so that the header can be made public
+ *
+ * Revision 1.6  2002/04/12 16:22:04  tr
+ * Unified Compiling Environment (UCE) replaced `std' library
+ *
+ * Revision 1.5  2001/07/20 16:33:40  tr
+ * moved to `std' library and re-named defines accordingly
+ *
+ * Revision 1.4  2001/07/10 16:47:18  tronkko
+ * revised comments
+ *
+ * Revision 1.3  2001/01/11 13:16:43  tr
+ * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
+ *
+ * Revision 1.2  2000/10/08 16:00:41  tr
+ * copy of FreeBSD man page
+ *
+ * Revision 1.1  2000/07/10 05:53:16  tr
+ * Initial revision
+ *
+ * Revision 1.2  1998/07/19 18:29:14  tr
+ * Added error reporting capabilities and some asserts.
+ *
+ * Revision 1.1  1998/07/04 16:27:51  tr
+ * Initial revision
+ *
+ * 
+ * MSVC 1.0 scans automatic dependencies incorrectly when your project
+ * contains this very header.  The problem is that MSVC cannot handle
+ * include directives inside #if..#endif block those are never entered.
+ * Since this header ought to compile in many different operating systems,
+ * there had to be several conditional blocks that are compiled only in
+ * operating systems for what they were designed for.  MSVC 1.0 cannot
+ * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
+ * operating system.  To fix the problem you need to insert DIR.H into
+ * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
+ * Consult manuals for more informaton about the problem.
+ *
+ * Since many UNIX systems have dirent.h we assume to have one also.
+ * However, if your UNIX system does not have dirent.h you can download one
+ * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
+ * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
+ * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
+ * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
+ * HAVE_SYS_NDIR_H according to the files found.
+ */
+#ifndef DIRENT_H
+#define DIRENT_H
+#define DIRENT_H_INCLUDED
+
+/* find out platform */
+#if defined(MSDOS)                             /* MS-DOS */
+#elif defined(__MSDOS__)                       /* Turbo C/Borland */
+# define MSDOS
+#elif defined(__DOS__)                         /* Watcom */
+# define MSDOS
+#endif
+
+#if defined(WIN32)                             /* MS-Windows */
+#elif defined(__NT__)                          /* Watcom */
+# define WIN32
+#elif defined(_WIN32)                          /* Microsoft */
+# define WIN32
+#elif defined(__WIN32__)                       /* Borland */
+# define WIN32
+#endif
+
+/*
+ * See what kind of dirent interface we have unless autoconf has already
+ * determinated that.
+ */
+#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
+# if defined(_MSC_VER)                         /* Microsoft C/C++ */
+    /* no dirent.h */
+# elif defined(__BORLANDC__)                   /* Borland C/C++ */
+#   define HAVE_DIRENT_H
+#   define VOID_CLOSEDIR
+# elif defined(__TURBOC__)                     /* Borland Turbo C */
+    /* no dirent.h */
+# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
+#   define HAVE_DIRECT_H
+# elif defined(__apollo)                       /* Apollo */
+#   define HAVE_SYS_DIR_H
+# elif defined(__hpux)                         /* HP-UX */
+#   define HAVE_DIRENT_H
+# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
+#   error "not implemented"
+# elif defined(__sgi)                          /* Silicon Graphics */
+#   define HAVE_DIRENT_H
+# elif defined(sun) || defined(_sun)           /* Sun Solaris */
+#   define HAVE_DIRENT_H
+# elif defined(__FreeBSD__)                    /* FreeBSD */
+#   define HAVE_DIRENT_H
+# elif defined(__linux__)                      /* Linux */
+#   define HAVE_DIRENT_H
+# elif defined(__GNUC__)                       /* GNU C/C++ */
+#   define HAVE_DIRENT_H
+# else
+#   error "not implemented"
+# endif
+#endif
+
+/* include proper interface headers */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+# ifdef FREEBSD
+#   define NAMLEN(dp) ((int)((dp)->d_namlen))
+# else
+#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+# endif
+
+#elif defined(HAVE_NDIR_H)
+# include <ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_NDIR_H)
+# include <sys/ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIRECT_H)
+# include <direct.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIR_H)
+# include <dir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_DIR_H)
+# include <sys/types.h>
+# include <sys/dir.h>
+# ifndef dirent
+#   define dirent direct
+# endif
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(MSDOS) || defined(WIN32)
+
+  /* figure out type of underlaying directory interface to be used */
+# if defined(WIN32)
+#   define DIRENT_WIN32_INTERFACE
+# elif defined(MSDOS)
+#   define DIRENT_MSDOS_INTERFACE
+# else
+#   error "missing native dirent interface"
+# endif
+
+  /*** WIN32 specifics ***/
+# if defined(DIRENT_WIN32_INTERFACE)
+#   include <windows.h>
+#   if !defined(DIRENT_MAXNAMLEN)
+#     define DIRENT_MAXNAMLEN (MAX_PATH)
+#   endif
+
+
+  /*** MS-DOS specifics ***/
+# elif defined(DIRENT_MSDOS_INTERFACE)
+#   include <dos.h>
+
+    /* Borland defines file length macros in dir.h */
+#   if defined(__BORLANDC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     if !defined(_find_t)
+#       define _find_t find_t
+#     endif
+
+    /* Turbo C defines ffblk structure in dir.h */
+#   elif defined(__TURBOC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     define DIRENT_USE_FFBLK
+
+    /* MSVC */
+#   elif defined(_MSC_VER)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN (12)
+#     endif
+
+    /* Watcom */
+#   elif defined(__WATCOMC__)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       if defined(__OS2__) || defined(__NT__)
+#         define DIRENT_MAXNAMLEN (255)
+#       else
+#         define DIRENT_MAXNAMLEN (12)
+#       endif
+#     endif
+
+#   endif
+# endif
+
+  /*** generic MS-DOS and MS-Windows stuff ***/
+# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
+#   define NAME_MAX DIRENT_MAXNAMLEN
+# endif
+# if NAME_MAX < DIRENT_MAXNAMLEN
+#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
+# endif
+
+
+  /*
+   * Substitute for real dirent structure.  Note that `d_name' field is a
+   * true character array although we have it copied in the implementation
+   * dependent data.  We could save some memory if we had declared `d_name'
+   * as a pointer refering the name within implementation dependent data.
+   * We have not done that since some code may rely on sizeof(d_name) to be
+   * something other than four.  Besides, directory entries are typically so
+   * small that it takes virtually no time to copy them from place to place.
+   */
+  typedef struct dirent {
+    char d_name[NAME_MAX + 1];
+
+    /*** Operating system specific part ***/
+# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
+    WIN32_FIND_DATA data;
+# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
+#   if defined(DIRENT_USE_FFBLK)
+    struct ffblk data;
+#   else
+    struct _find_t data;
+#   endif
+# endif
+  } dirent;
+
+  /* DIR substitute structure containing directory name.  The name is
+   * essential for the operation of ``rewinndir'' function. */
+  typedef struct DIR {
+    char          *dirname;                    /* directory being scanned */
+    dirent        current;                     /* current entry */
+    int           dirent_filled;               /* is current un-processed? */
+
+  /*** Operating system specific part ***/
+#  if defined(DIRENT_WIN32_INTERFACE)
+    HANDLE        search_handle;
+#  elif defined(DIRENT_MSDOS_INTERFACE)
+#  endif
+  } DIR;
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/* supply prototypes for dirent functions */
+static DIR *opendir (const char *dirname);
+static struct dirent *readdir (DIR *dirp);
+static int closedir (DIR *dirp);
+static void rewinddir (DIR *dirp);
+
+/*
+ * Implement dirent interface as static functions so that the user does not
+ * need to change his project in any way to use dirent function.  With this
+ * it is sufficient to include this very header from source modules using
+ * dirent functions and the functions will be pulled in automatically.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+/* use ffblk instead of _find_t if requested */
+#if defined(DIRENT_USE_FFBLK)
+# define _A_ARCH   (FA_ARCH)
+# define _A_HIDDEN (FA_HIDDEN)
+# define _A_NORMAL (0)
+# define _A_RDONLY (FA_RDONLY)
+# define _A_SUBDIR (FA_DIREC)
+# define _A_SYSTEM (FA_SYSTEM)
+# define _A_VOLID  (FA_LABEL)
+# define _dos_findnext(dest) findnext(dest)
+# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
+#endif
+
+static int _initdir (DIR *p);
+static const char *_getdirname (const struct dirent *dp);
+static void _setdirname (struct DIR *dirp);
+
+/*
+ * <function name="opendir">
+ * <intro>open directory stream for reading
+ * <syntax>DIR *opendir (const char *dirname);
+ *
+ * <desc>Open named directory stream for read and return pointer to the
+ * internal working area that is used for retrieving individual directory
+ * entries.  The internal working area has no fields of your interest.
+ *
+ * <ret>Returns a pointer to the internal working area or NULL in case the 
+ * directory stream could not be opened.  Global `errno' variable will set
+ * in case of error as follows:
+ *
+ * <table>
+ * [EACESS  |Permission denied.
+ * [EMFILE  |Too many open files used by the process.
+ * [ENFILE  |Too many open files in system.
+ * [ENOENT  |Directory does not exist.
+ * [ENOMEM  |Insufficient memory.
+ * [ENOTDIR |dirname does not refer to directory.  This value is not
+ *           reliable on MS-DOS and MS-Windows platforms.  Many
+ *           implementations return ENOENT even when the name refers to a
+ *           file.]
+ * </table>
+ * </function>
+ */
+static DIR *opendir(const char *dirname)
+{
+  DIR *dirp;
+  assert (dirname != NULL);
+  
+  dirp = (DIR*)malloc (sizeof (struct DIR));
+  if (dirp != NULL) {
+    char *p;
+    
+    /* allocate room for directory name */
+    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
+    if (dirp->dirname == NULL) {
+      /* failed to duplicate directory name.  errno set by malloc() */
+      free (dirp);
+      return NULL;
+    }
+    /* Copy directory name while appending directory separator and "*.*".
+     * Directory separator is not appended if the name already ends with
+     * drive or directory separator.  Directory separator is assumed to be
+     * '/' or '\' and drive separator is assumed to be ':'. */
+    strcpy (dirp->dirname, dirname);
+    p = strchr (dirp->dirname, '\0');
+    if (dirp->dirname < p  &&
+        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
+    {
+      strcpy (p++, "\\");
+    }
+# ifdef DIRENT_WIN32_INTERFACE
+    strcpy (p, "*"); /*scan files with and without extension in win32*/
+# else
+    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
+# endif
+
+    /* open stream */
+    if (_initdir (dirp) == 0) {
+      /* initialization failed */
+      free (dirp->dirname);
+      free (dirp);
+      return NULL;
+    }
+  }
+  return dirp;
+}
+
+
+/*
+ * <function name="readdir">
+ * <intro>read a directory entry
+ * <syntax>struct dirent *readdir (DIR *dirp);
+ *
+ * <desc>Read individual directory entry and return pointer to a structure
+ * containing the name of the entry.  Individual directory entries returned
+ * include normal files, sub-directories, pseudo-directories "." and ".."
+ * and also volume labels, hidden files and system files in MS-DOS and
+ * MS-Windows.   You might want to use stat(2) function to determinate which
+ * one are you dealing with.  Many dirent implementations already contain
+ * equivalent information in dirent structure but you cannot depend on
+ * this.
+ *
+ * The dirent structure contains several system dependent fields that
+ * generally have no interest to you.  The only interesting one is char
+ * d_name[] that is also portable across different systems.  The d_name
+ * field contains the name of the directory entry without leading path.
+ * While d_name is portable across different systems the actual storage
+ * capacity of d_name varies from system to system and there is no portable
+ * way to find out it at compile time as different systems define the
+ * capacity of d_name with different macros and some systems do not define
+ * capacity at all (besides actual declaration of the field). If you really
+ * need to find out storage capacity of d_name then you might want to try
+ * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
+ * there are many MS-DOS and MS-Windows implementations those do not define
+ * it.  There are also systems that declare d_name as "char d_name[1]" and
+ * then allocate suitable amount of memory at run-time.  Thanks to Alain
+ * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
+ *
+ * This all leads to the fact that it is difficult to allocate space
+ * for the directory names when the very same program is being compiled on
+ * number of operating systems.  Therefore I suggest that you always
+ * allocate space for directory names dynamically.
+ *
+ * <ret>
+ * Returns a pointer to a structure containing name of the directory entry
+ * in `d_name' field or NULL if there was an error.  In case of an error the
+ * global `errno' variable will set as follows:
+ *
+ * <table>
+ * [EBADF  |dir parameter refers to an invalid directory stream.  This value
+ *          is not set reliably on all implementations.]
+ * </table>
+ * </function>
+ */
+static struct dirent *
+readdir (DIR *dirp)
+{
+  assert(dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return NULL;
+  }
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* directory stream was opened/rewound incorrectly or it ended normally */
+    errno = EBADF;
+    return NULL;
+  }
+#endif
+
+  if (dirp->dirent_filled != 0) {
+    /*
+     * Directory entry has already been retrieved and there is no need to
+     * retrieve a new one.  Directory entry will be retrieved in advance
+     * when the user calls readdir function for the first time.  This is so
+     * because real dirent has separate functions for opening and reading
+     * the stream whereas Win32 and DOS dirents open the stream
+     * automatically when we retrieve the first file.  Therefore, we have to
+     * save the first file when opening the stream and later we have to
+     * return the saved entry when the user tries to read the first entry.
+     */
+    dirp->dirent_filled = 0;
+  } else {
+    /* fill in entry and return that */
+#if defined(DIRENT_WIN32_INTERFACE)
+    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
+      /* Last file has been processed or an error occured */
+      FindClose (dirp->search_handle);
+      dirp->search_handle = INVALID_HANDLE_VALUE;
+      errno = ENOENT;
+      return NULL;
+    }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+    if (_dos_findnext (&dirp->current.data) != 0) {
+      /* _dos_findnext and findnext will set errno to ENOENT when no
+       * more entries could be retrieved. */
+      return NULL;
+    }
+# endif
+
+    _setdirname (dirp);
+    assert (dirp->dirent_filled == 0);
+  }
+  return &dirp->current;
+}
+
+
+/*
+ * <function name="closedir">
+ * <intro>close directory stream.
+ * <syntax>int closedir (DIR *dirp);
+ *
+ * <desc>Close directory stream opened by the `opendir' function.  Close of
+ * directory stream invalidates the DIR structure as well as previously read
+ * dirent entry.
+ *
+ * <ret>The function typically returns 0 on success and -1 on failure but
+ * the function may be declared to return void on same systems.  At least
+ * Borland C/C++ and some UNIX implementations use void as a return type.
+ * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
+ * known to return nothing.  The very same definition is made by the GNU
+ * autoconf if you happen to use it.
+ *
+ * The global `errno' variable will set to EBADF in case of error.
+ * </function>
+ */
+static int
+closedir (DIR *dirp)
+{   
+  int retcode = 0;
+
+  /* make sure that dirp points to legal structure */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+ 
+  /* free directory name and search handles */
+  if (dirp->dirname != NULL) free (dirp->dirname);
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      retcode = -1;
+      errno = EBADF;
+    }
+  }
+#endif                     
+
+  /* clear dirp structure to make sure that it cannot be used anymore*/
+  memset (dirp, 0, sizeof (*dirp));
+# if defined(DIRENT_WIN32_INTERFACE)
+  dirp->search_handle = INVALID_HANDLE_VALUE;
+# endif
+
+  free (dirp);
+  return retcode;
+}
+
+
+/*
+ * <function name="rewinddir">
+ * <intro>rewind directory stream to the beginning
+ * <syntax>void rewinddir (DIR *dirp);
+ *
+ * <desc>Rewind directory stream to the beginning so that the next call of
+ * readdir() returns the very first directory entry again.  However, note
+ * that next call of readdir() may not return the same directory entry as it
+ * did in first time.  The directory stream may have been affected by newly
+ * created files.
+ *
+ * Almost every dirent implementation ensure that rewinddir will update
+ * the directory stream to reflect any changes made to the directory entries
+ * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
+ * this if your program depends on the feature.  I know at least one dirent
+ * implementation where you are required to close and re-open the stream to
+ * see the changes.
+ *
+ * <ret>Returns nothing.  If something went wrong while rewinding, you will
+ * notice it later when you try to retrieve the first directory entry.
+ */
+static void
+rewinddir (DIR *dirp)
+{   
+  /* make sure that dirp is legal */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return;
+  }
+  assert (dirp->dirname != NULL);
+  
+  /* close previous stream */
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      errno = EBADF;
+    }
+  }
+#endif
+
+  /* re-open previous stream */
+  if (_initdir (dirp) == 0) {
+    /* initialization failed but we cannot deal with error.  User will notice
+     * error later when she tries to retrieve first directory enty. */
+    /*EMPTY*/;
+  }
+}
+
+
+/*
+ * Open native directory stream object and retrieve first file.
+ * Be sure to close previous stream before opening new one.
+ */
+static int
+_initdir (DIR *dirp)
+{ 
+  assert (dirp != NULL);
+  assert (dirp->dirname != NULL);
+  dirp->dirent_filled = 0;
+
+# if defined(DIRENT_WIN32_INTERFACE)
+  /* Open stream and retrieve first file */
+  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* something went wrong but we don't know what.  GetLastError() could
+     * give us more information about the error, but then we should map
+     * the error code into errno. */
+    errno = ENOENT;
+    return 0;
+  }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+  if (_dos_findfirst (dirp->dirname,
+          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
+          &dirp->current.data) != 0)
+  {
+    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
+     * more entries could be retrieved. */
+    return 0;
+  }
+# endif
+
+  /* initialize DIR and it's first entry */
+  _setdirname (dirp);
+  dirp->dirent_filled = 1;
+  return 1;
+}
+
+
+/*
+ * Return implementation dependent name of the current directory entry.
+ */
+static const char *
+_getdirname (const struct dirent *dp)
+{
+#if defined(DIRENT_WIN32_INTERFACE)
+  return dp->data.cFileName;
+  
+#elif defined(DIRENT_USE_FFBLK)
+  return dp->data.ff_name;
+  
+#else
+  return dp->data.name;
+#endif  
+}
+
+
+/*
+ * Copy name of implementation dependent directory entry to the d_name field.
+ */
+static void
+_setdirname (struct DIR *dirp) {
+  /* make sure that d_name is long enough */
+  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
+  
+  strncpy (dirp->current.d_name,
+      _getdirname (&dirp->current),
+      NAME_MAX);
+  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
+}
+  
+# ifdef __cplusplus
+}
+# endif
+# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+
+#else
+# error "missing dirent interface"
+#endif
+
+
+#endif /*DIRENT_H*/
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.c.svn-base ./codec/.svn/text-base/image_to_j2k.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/image_to_j2k.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,1768 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team 
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "openjpeg.h"
+#include "compat/getopt.h"
+#include "convert.h"
+#include "dirent.h"
+#include "index.h"
+
+#ifndef WIN32
+#define stricmp strcasecmp
+#define strnicmp strncasecmp
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+#define J2K_CFMT 0
+#define JP2_CFMT 1
+#define JPT_CFMT 2
+
+#define PXM_DFMT 10
+#define PGX_DFMT 11
+#define BMP_DFMT 12
+#define YUV_DFMT 13
+#define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
+
+/* ----------------------------------------------------------------------- */
+#define CINEMA_24_CS 1302083	/*Codestream length for 24fps*/
+#define CINEMA_48_CS 651041		/*Codestream length for 48fps*/
+#define COMP_24_CS 1041666		/*Maximum size per color component for 2K & 4K @ 24fps*/
+#define COMP_48_CS 520833		/*Maximum size per color component for 2K @ 48fps*/
+
+typedef struct dircnt{
+	/** Buffer for holding images read from Directory*/
+	char *filename_buf;
+	/** Pointer to the buffer*/
+	char **filename;
+}dircnt_t;
+
+typedef struct img_folder{
+	/** The directory path of the folder containing input images*/
+	char *imgdirpath;
+	/** Output format*/
+	char *out_format;
+	/** Enable option*/
+	char set_imgdir;
+	/** Enable Cod Format for output*/
+	char set_out_format;
+	/** User specified rate stored in case of cinema option*/
+	float *rates;
+}img_fol_t;
+
+void encode_help_display() {
+	fprintf(stdout,"HELP\n----\n\n");
+	fprintf(stdout,"- the -h option displays this help information on screen\n\n");
+
+/* UniPG>> */
+	fprintf(stdout,"List of parameters for the JPEG 2000 "
+#ifdef USE_JPWL
+		"+ JPWL "
+#endif /* USE_JPWL */
+		"encoder:\n");
+/* <<UniPG */
+	fprintf(stdout,"\n");
+	fprintf(stdout,"REMARKS:\n");
+	fprintf(stdout,"---------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
+	fprintf(stdout,"COD and QCD never appear in the tile_header.\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"By default:\n");
+	fprintf(stdout,"------------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout," * Lossless\n");
+	fprintf(stdout," * 1 tile\n");
+	fprintf(stdout," * Size of precinct : 2^15 x 2^15 (means 1 precinct)\n");
+	fprintf(stdout," * Size of code-block : 64 x 64\n");
+	fprintf(stdout," * Number of resolutions: 6\n");
+	fprintf(stdout," * No SOP marker in the codestream\n");
+	fprintf(stdout," * No EPH marker in the codestream\n");
+	fprintf(stdout," * No sub-sampling in x or y direction\n");
+	fprintf(stdout," * No mode switch activated\n");
+	fprintf(stdout," * Progression order: LRCP\n");
+	fprintf(stdout," * No index file\n");
+	fprintf(stdout," * No ROI upshifted\n");
+	fprintf(stdout," * No offset of the origin of the image\n");
+	fprintf(stdout," * No offset of the origin of the tiles\n");
+	fprintf(stdout," * Reversible DWT 5-3\n");
+/* UniPG>> */
+#ifdef USE_JPWL
+	fprintf(stdout," * No JPWL protection\n");
+#endif /* USE_JPWL */
+/* <<UniPG */
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Parameters:\n");
+	fprintf(stdout,"------------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Required Parameters (except with -h):\n");
+	fprintf(stdout,"One of the two options -ImgDir or -i must be used\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-ImgDir      : Image file Directory path (example ../Images) \n");
+	fprintf(stdout,"    When using this option -OutFor must be used\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-OutFor \n");
+	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
+	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-i           : source file  (-i source.pnm also *.pgm, *.ppm, *.bmp, *.tif, *.raw, *.tga) \n");
+	fprintf(stdout,"    When using this option -o must be used\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-o           : destination file (-o dest.j2k or .jp2) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Optional Parameters:\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-h           : display the help information \n ");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-cinema2K    : Digital Cinema 2K profile compliant codestream for 2K resolution.(-cinema2k 24 or 48) \n");
+  fprintf(stdout,"	  Need to specify the frames per second for a 2K resolution. Only 24 or 48 fps is allowed\n"); 
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-cinema4K    : Digital Cinema 4K profile compliant codestream for 4K resolution \n");
+	fprintf(stdout,"	  Frames per second not required. Default value is 24fps\n"); 
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-r           : different compression ratios for successive layers (-r 20,10,5)\n ");
+	fprintf(stdout,"	         - The rate specified for each quality level is the desired \n");
+	fprintf(stdout,"	           compression factor.\n");
+	fprintf(stdout,"		   Example: -r 20,10,1 means quality 1: compress 20x, \n");
+	fprintf(stdout,"		     quality 2: compress 10x and quality 3: compress lossless\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+	fprintf(stdout,"\n");
+
+	fprintf(stdout,"-q           : different psnr for successive layers (-q 30,40,50) \n ");
+
+	fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-n           : number of resolutions (-n 3) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-b           : size of code block (-b 32,32) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-c           : size of precinct (-c 128,128) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-t           : size of tile (-t 512,512) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-p           : progression order (-p LRCP) [LRCP, RLCP, RPCL, PCRL, CPRL] \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-s           : subsampling factor (-s 2,2) [-s X,Y] \n");
+	fprintf(stdout,"	     Remark: subsampling bigger than 2 can produce error\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-POC         : Progression order change (-POC T1=0,0,1,5,3,CPRL/T1=5,0,1,6,3,CPRL) \n");
+	fprintf(stdout,"      Example: T1=0,0,1,5,3,CPRL \n");
+	fprintf(stdout,"			 : Ttilenumber=Resolution num start,Component num start,Layer num end,Resolution num end,Component num end,Progression order\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-SOP         : write SOP marker before each packet \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-EPH         : write EPH marker after each header packet \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-M           : mode switch (-M 3) [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
+	fprintf(stdout,"                 8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)] \n");
+	fprintf(stdout,"                 Indicate multiple modes by adding their values. \n");
+	fprintf(stdout,"                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-x           : create an index file *.Idx (-x index_name.Idx) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
+	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
+	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI c=0,U=25) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-T           : offset of the origin of the tiles (-T 100,75) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-I           : use the irreversible DWT 9-7 (-I) \n");
+	fprintf(stdout,"\n");
+/* UniPG>> */
+#ifdef USE_JPWL
+	fprintf(stdout,"-W           : adoption of JPWL (Part 11) capabilities (-W params)\n");
+	fprintf(stdout,"               The parameters can be written and repeated in any order:\n");
+	fprintf(stdout,"               [h<tilepart><=type>,s<tilepart><=method>,a=<addr>,...\n");
+	fprintf(stdout,"                ...,z=<size>,g=<range>,p<tilepart:pack><=type>]\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 h selects the header error protection (EPB): 'type' can be\n");
+	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main and tile headers\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next h<> spec, or to the last tilepart\n");
+	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 p selects the packet error protection (EEP/UEP with EPBs)\n");
+	fprintf(stdout,"                  to be applied to raw data: 'type' can be\n");
+	fprintf(stdout,"                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is absent, it is from tile 0, packet 0\n");
+	fprintf(stdout,"                   if 'tilepart:pack' is present, it applies from that tile\n");
+	fprintf(stdout,"                     and that packet onwards, up to the next packet spec\n");
+	fprintf(stdout,"                     or to the last packet in the last tilepart in the stream\n");
+	fprintf(stdout,"                     (max. %d specs)\n", JPWL_MAX_NO_PACKSPECS);
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 s enables sensitivity data insertion (ESD): 'method' can be\n");
+	fprintf(stdout,"                   [-1=NO ESD 0=RELATIVE ERROR 1=MSE 2=MSE REDUCTION 3=PSNR\n");
+	fprintf(stdout,"                    4=PSNR INCREMENT 5=MAXERR 6=TSE 7=RESERVED]\n");
+	fprintf(stdout,"                   if 'tilepart' is absent, it is for main header only\n");
+	fprintf(stdout,"                   if 'tilepart' is present, it applies from that tile\n");
+	fprintf(stdout,"                     onwards, up to the next s<> spec, or to the last tilepart\n");
+	fprintf(stdout,"                     in the codestream (max. %d specs)\n", JPWL_MAX_NO_TILESPECS);
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 g determines the addressing mode: <range> can be\n");
+	fprintf(stdout,"                   [0=PACKET 1=BYTE RANGE 2=PACKET RANGE]\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 a determines the size of data addressing: <addr> can be\n");
+	fprintf(stdout,"                   2/4 bytes (small/large codestreams). If not set, auto-mode\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 z determines the size of sensitivity values: <size> can be\n");
+	fprintf(stdout,"                   1/2 bytes, for the transformed pseudo-floating point value\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 ex.:\n");
+	fprintf(stdout,"                   h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,\n");
+	fprintf(stdout,"                     s0=6,s3=-1,a=0,g=1,z=1\n");
+	fprintf(stdout,"                 means\n");
+	fprintf(stdout,"                   predefined EPB in MH, rs(64,32) from TPH 0 to TPH 2,\n");
+	fprintf(stdout,"                   CRC-16 in TPH 3 and TPH 4, CRC-32 in remaining TPHs,\n");
+	fprintf(stdout,"                   UEP rs(78,32) for packets 0 to 23 of tile 0,\n");
+	fprintf(stdout,"                   UEP rs(56,32) for packs. 24 to the last of tilepart 0,\n");
+	fprintf(stdout,"                   UEP rs default for packets of tilepart 1,\n");
+	fprintf(stdout,"                   no UEP for packets 0 to 19 of tilepart 3,\n");
+	fprintf(stdout,"                   UEP CRC-32 for packs. 20 of tilepart 3 to last tilepart,\n");
+	fprintf(stdout,"                   relative sensitivity ESD for MH,\n");
+	fprintf(stdout,"                   TSE ESD from TPH 0 to TPH 2, byte range with automatic\n");
+	fprintf(stdout,"                   size of addresses and 1 byte for each sensitivity value\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 ex.:\n");
+	fprintf(stdout,"                       h,s,p\n");
+	fprintf(stdout,"                 means\n");
+	fprintf(stdout,"                   default protection to headers (MH and TPHs) as well as\n");
+	fprintf(stdout,"                   data packets, one ESD in MH\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"                 N.B.: use the following recommendations when specifying\n");
+	fprintf(stdout,"                       the JPWL parameters list\n");
+	fprintf(stdout,"                   - when you use UEP, always pair the 'p' option with 'h'\n");
+	fprintf(stdout,"                 \n");
+#endif /* USE_JPWL */
+/* <<UniPG */
+	fprintf(stdout,"IMPORTANT:\n");
+	fprintf(stdout,"-----------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"The index file has the structure below:\n");
+	fprintf(stdout,"---------------------------------------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Image_height Image_width\n");
+	fprintf(stdout,"progression order\n");
+	fprintf(stdout,"Tiles_size_X Tiles_size_Y\n");
+	fprintf(stdout,"Tiles_nb_X Tiles_nb_Y\n");
+	fprintf(stdout,"Components_nb\n");
+	fprintf(stdout,"Layers_nb\n");
+	fprintf(stdout,"decomposition_levels\n");
+	fprintf(stdout,"[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
+	fprintf(stdout,"   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
+	fprintf(stdout,"Main_header_start_position\n");
+	fprintf(stdout,"Main_header_end_position\n");
+	fprintf(stdout,"Codestream_size\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"INFO ON TILES\n");
+	fprintf(stdout,"tileno start_pos end_hd end_tile nbparts disto nbpix disto/nbpix\n");
+	fprintf(stdout,"Tile_0 start_pos end_Theader end_pos NumParts TotalDisto NumPix MaxMSE\n");
+	fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''      ''\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''     ''\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"TILE 0 DETAILS\n");
+	fprintf(stdout,"part_nb tileno num_packs start_pos end_tph_pos end_pos\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Progression_string\n");
+	fprintf(stdout,"pack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
+	fprintf(stdout,"Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
+	fprintf(stdout,"...\n");
+	fprintf(stdout,"Tpacket_Np ''   ''    ''   ''    ''       ''       ''     ''\n");
+
+	fprintf(stdout,"MaxDisto\n");
+
+	fprintf(stdout,"TotalDisto\n\n");
+}
+
+OPJ_PROG_ORDER give_progression(char progression[4]) {
+	if(strncmp(progression, "LRCP", 4) == 0) {
+		return LRCP;
+	}
+	if(strncmp(progression, "RLCP", 4) == 0) {
+		return RLCP;
+	}
+	if(strncmp(progression, "RPCL", 4) == 0) {
+		return RPCL;
+	}
+	if(strncmp(progression, "PCRL", 4) == 0) {
+		return PCRL;
+	}
+	if(strncmp(progression, "CPRL", 4) == 0) {
+		return CPRL;
+	}
+
+	return PROG_UNKNOWN;
+}
+
+int get_num_images(char *imgdirpath){
+	DIR *dir;
+	struct dirent* content;	
+	int num_images = 0;
+
+	/*Reading the input images from given input directory*/
+
+	dir= opendir(imgdirpath);
+	if(!dir){
+		fprintf(stderr,"Could not open Folder %s\n",imgdirpath);
+		return 0;
+	}
+
+	num_images=0;
+	while((content=readdir(dir))!=NULL){
+		if(strcmp(".",content->d_name)==0 || strcmp("..",content->d_name)==0 )
+			continue;
+		num_images++;
+	}
+	return num_images;
+}
+
+int load_images(dircnt_t *dirptr, char *imgdirpath){
+	DIR *dir;
+	struct dirent* content;	
+	int i = 0;
+
+	/*Reading the input images from given input directory*/
+
+	dir= opendir(imgdirpath);
+	if(!dir){
+		fprintf(stderr,"Could not open Folder %s\n",imgdirpath);
+		return 1;
+	}else	{
+		fprintf(stderr,"Folder opened successfully\n");
+	}
+
+	while((content=readdir(dir))!=NULL){
+		if(strcmp(".",content->d_name)==0 || strcmp("..",content->d_name)==0 )
+			continue;
+
+		strcpy(dirptr->filename[i],content->d_name);
+		i++;
+	}
+	return 0;	
+}
+
+int get_file_format(char *filename) {
+	unsigned int i;
+	static const char *extension[] = {
+    "pgx", "pnm", "pgm", "ppm", "bmp", "tif", "raw", "tga", "j2k", "jp2", "j2c"
+    };
+	static const int format[] = {
+    PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, J2K_CFMT
+    };
+	char * ext = strrchr(filename, '.');
+	if (ext == NULL)
+		return -1;
+	ext++;
+	for(i = 0; i < sizeof(format)/sizeof(*format); i++) {
+		if(strnicmp(ext, extension[i], 3) == 0) {
+			return format[i];
+		}
+	}
+	return -1;
+}
+
+char * get_file_name(char *name){
+	char *fname;
+	fname= (char*)malloc(OPJ_PATH_LEN*sizeof(char));
+	fname= strtok(name,".");
+	return fname;
+}
+
+char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_cparameters_t *parameters){
+	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+  char *temp_p, temp1[OPJ_PATH_LEN]="";
+
+	strcpy(image_filename,dirptr->filename[imageno]);
+	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
+	parameters->decod_format = get_file_format(image_filename);
+	if (parameters->decod_format == -1)
+		return 1;
+	sprintf(infilename,"%s/%s",img_fol->imgdirpath,image_filename);
+	strncpy(parameters->infile, infilename, sizeof(infilename));
+
+	//Set output file
+	strcpy(temp_ofname,get_file_name(image_filename));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
+	if(img_fol->set_out_format==1){
+		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
+		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
+	}
+ return 0;
+}
+
+static int initialise_4K_poc(opj_poc_t *POC, int numres){
+	POC[0].tile  = 1; 
+	POC[0].resno0  = 0; 
+	POC[0].compno0 = 0;
+	POC[0].layno1  = 1;
+	POC[0].resno1  = numres-1;
+	POC[0].compno1 = 3;
+	POC[0].prg1 = CPRL;
+	POC[1].tile  = 1;
+	POC[1].resno0  = numres-1; 
+	POC[1].compno0 = 0;
+	POC[1].layno1  = 1;
+	POC[1].resno1  = numres;
+	POC[1].compno1 = 3;
+	POC[1].prg1 = CPRL;
+	return 2;
+}
+
+void cinema_parameters(opj_cparameters_t *parameters){
+	parameters->tile_size_on = false;
+	parameters->cp_tdx=1;
+	parameters->cp_tdy=1;
+	
+	/*Tile part*/
+	parameters->tp_flag = 'C';
+	parameters->tp_on = 1;
+
+	/*Tile and Image shall be at (0,0)*/
+	parameters->cp_tx0 = 0;
+	parameters->cp_ty0 = 0;
+	parameters->image_offset_x0 = 0;
+	parameters->image_offset_y0 = 0;
+
+	/*Codeblock size= 32*32*/
+	parameters->cblockw_init = 32;	
+	parameters->cblockh_init = 32;
+	parameters->csty |= 0x01;
+
+	/*The progression order shall be CPRL*/
+	parameters->prog_order = CPRL;
+
+	/* No ROI */
+	parameters->roi_compno = -1;
+
+	parameters->subsampling_dx = 1;		parameters->subsampling_dy = 1;
+
+	/* 9-7 transform */
+	parameters->irreversible = 1;
+
+}
+
+void cinema_setup_encoder(opj_cparameters_t *parameters,opj_image_t *image, img_fol_t *img_fol){
+	int i;
+	float temp_rate;
+	opj_poc_t *POC = NULL;
+
+	switch (parameters->cp_cinema){
+	case CINEMA2K_24:
+	case CINEMA2K_48:
+		if(parameters->numresolution > 6){
+			parameters->numresolution = 6;
+		}
+		if (!((image->comps[0].w == 2048) | (image->comps[0].h == 1080))){
+			fprintf(stdout,"Image coordinates %d x %d is not 2K compliant.\nJPEG Digital Cinema Profile-3 "
+				"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080\n",
+				image->comps[0].w,image->comps[0].h);
+			parameters->cp_rsiz = STD_RSIZ;
+		}
+	break;
+	
+	case CINEMA4K_24:
+		if(parameters->numresolution < 1){
+				parameters->numresolution = 1;
+			}else if(parameters->numresolution > 7){
+				parameters->numresolution = 7;
+			}
+		if (!((image->comps[0].w == 4096) | (image->comps[0].h == 2160))){
+			fprintf(stdout,"Image coordinates %d x %d is not 4K compliant.\nJPEG Digital Cinema Profile-4" 
+				"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160\n",
+				image->comps[0].w,image->comps[0].h);
+			parameters->cp_rsiz = STD_RSIZ;
+		}
+		parameters->numpocs = initialise_4K_poc(parameters->POC,parameters->numresolution);
+		break;
+	}
+
+	switch (parameters->cp_cinema){
+		case CINEMA2K_24:
+		case CINEMA4K_24:
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
+				temp_rate = 0 ;
+				if (img_fol->rates[i]== 0){
+					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+					(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+				}else{
+					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+					if (temp_rate > CINEMA_24_CS ){
+						parameters->tcp_rates[i]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+						(CINEMA_24_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
+					}
+				}
+			}
+			parameters->max_comp_size = COMP_24_CS;
+			break;
+		
+		case CINEMA2K_48:
+			for(i=0 ; i<parameters->tcp_numlayers ; i++){
+				temp_rate = 0 ;
+				if (img_fol->rates[i]== 0){
+					parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+					(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+				}else{
+					temp_rate =((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+						(img_fol->rates[i] * 8 * image->comps[0].dx * image->comps[0].dy);
+					if (temp_rate > CINEMA_48_CS ){
+						parameters->tcp_rates[0]= ((float) (image->numcomps * image->comps[0].w * image->comps[0].h * image->comps[0].prec))/ 
+						(CINEMA_48_CS * 8 * image->comps[0].dx * image->comps[0].dy);
+					}else{
+						parameters->tcp_rates[i]= img_fol->rates[i];
+					}
+				}
+			}
+			parameters->max_comp_size = COMP_48_CS;
+			break;
+	}
+	parameters->cp_disto_alloc = 1;
+}
+
+/* ------------------------------------------------------------------------------------ */
+
+int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters,
+													img_fol_t *img_fol, raw_cparameters_t *raw_cp, char *indexfilename) {
+	int i, j,totlen;
+	option_t long_option[]={
+		{"cinema2K",REQ_ARG, NULL ,'w'},
+		{"cinema4K",NO_ARG, NULL ,'y'},
+		{"ImgDir",REQ_ARG, NULL ,'z'},
+		{"TP",REQ_ARG, NULL ,'v'},
+		{"SOP",NO_ARG, NULL ,'S'},
+		{"EPH",NO_ARG, NULL ,'E'},
+		{"OutFor",REQ_ARG, NULL ,'O'},
+		{"POC",REQ_ARG, NULL ,'P'},
+		{"ROI",REQ_ARG, NULL ,'R'},
+	};
+
+	/* parse the command line */
+	const char optlist[] = "i:o:hr:q:n:b:c:t:p:s:SEM:x:R:d:T:If:P:C:F:"
+#ifdef USE_JPWL
+		"W:"
+#endif /* USE_JPWL */
+		;
+
+	totlen=sizeof(long_option);
+	img_fol->set_out_format=0;
+	raw_cp->rawWidth = 0;
+
+	while (1) {
+    int c = getopt_long(argc, argv, optlist,long_option,totlen);
+		if (c == -1)
+			break;
+		switch (c) {
+			case 'i':			/* input file */
+			{
+				char *infile = optarg;
+				parameters->decod_format = get_file_format(infile);
+				switch(parameters->decod_format) {
+					case PGX_DFMT:
+					case PXM_DFMT:
+					case BMP_DFMT:
+					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
+						break;
+					default:
+						fprintf(stderr,
+							"!! Unrecognized format for infile : %s "
+              "[accept only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga] !!\n\n", 
+							infile);
+						return 1;
+				}
+				strncpy(parameters->infile, infile, sizeof(parameters->infile)-1);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'o':			/* output file */
+			{
+				char *outfile = optarg;
+				parameters->cod_format = get_file_format(outfile);
+				switch(parameters->cod_format) {
+					case J2K_CFMT:
+					case JP2_CFMT:
+						break;
+					default:
+						fprintf(stderr, "Unknown output format image %s [only *.j2k, *.j2c or *.jp2]!! \n", outfile);
+						return 1;
+				}
+				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+			case 'O':			/* output format */
+				{
+					char outformat[50];
+					char *of = optarg;
+					sprintf(outformat,".%s",of);
+					img_fol->set_out_format = 1;
+					parameters->cod_format = get_file_format(outformat);
+					switch(parameters->cod_format) {
+						case J2K_CFMT:
+						case JP2_CFMT:
+							img_fol->out_format = optarg;
+							break;
+						default:
+							fprintf(stderr, "Unknown output format image [only j2k, j2c, jp2]!! \n");
+							return 1;
+					}
+				}
+				break;
+
+
+				/* ----------------------------------------------------- */
+
+
+			case 'r':			/* rates rates/distorsion */
+			{
+				char *s = optarg;
+				while (sscanf(s, "%f", &parameters->tcp_rates[parameters->tcp_numlayers]) == 1) {
+					parameters->tcp_numlayers++;
+					while (*s && *s != ',') {
+						s++;
+					}
+					if (!*s)
+						break;
+					s++;
+				}
+				parameters->cp_disto_alloc = 1;
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			
+			case 'F':			/* Raw image format parameters */
+			{
+				char signo;
+				char *s = optarg;
+				if (sscanf(s, "%d,%d,%d,%d,%c", &raw_cp->rawWidth, &raw_cp->rawHeight, &raw_cp->rawComp, &raw_cp->rawBitDepth, &signo) == 5) {
+					if (signo == 's') {
+						raw_cp->rawSigned = true;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Signed\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else if (signo == 'u') {
+						raw_cp->rawSigned = false;
+						fprintf(stdout,"\nRaw file parameters: %d,%d,%d,%d Unsigned\n", raw_cp->rawWidth, raw_cp->rawHeight, raw_cp->rawComp, raw_cp->rawBitDepth);
+					}
+					else {
+						fprintf(stderr,"\nError: invalid raw image parameters: Unknown sign of raw file\n");
+						fprintf(stderr,"Please use the Format option -F:\n");
+						fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+						fprintf(stderr,"Aborting\n");
+					}					
+				}
+				else {
+					fprintf(stderr,"\nError: invalid raw image parameters\n");
+					fprintf(stderr,"Please use the Format option -F:\n");
+					fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+					fprintf(stderr,"Aborting\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'q':			/* add fixed_quality */
+			{
+				char *s = optarg;
+				while (sscanf(s, "%f", &parameters->tcp_distoratio[parameters->tcp_numlayers]) == 1) {
+					parameters->tcp_numlayers++;
+					while (*s && *s != ',') {
+						s++;
+					}
+					if (!*s)
+						break;
+					s++;
+				}
+				parameters->cp_fixed_quality = 1;
+			}
+			break;
+
+				/* dda */
+				/* ----------------------------------------------------- */
+
+			case 'f':			/* mod fixed_quality (before : -q) */
+			{
+				int *row = NULL, *col = NULL;
+				int numlayers = 0, numresolution = 0, matrix_width = 0;
+
+				char *s = optarg;
+				sscanf(s, "%d", &numlayers);
+				s++;
+				if (numlayers > 9)
+					s++;
+
+				parameters->tcp_numlayers = numlayers;
+				numresolution = parameters->numresolution;
+				matrix_width = numresolution * 3;
+				parameters->cp_matrice = (int *) malloc(numlayers * matrix_width * sizeof(int));
+				s = s + 2;
+
+				for (i = 0; i < numlayers; i++) {
+					row = &parameters->cp_matrice[i * matrix_width];
+					col = row;
+					parameters->tcp_rates[i] = 1;
+					sscanf(s, "%d,", &col[0]);
+					s += 2;
+					if (col[0] > 9)
+						s++;
+					col[1] = 0;
+					col[2] = 0;
+					for (j = 1; j < numresolution; j++) {
+						col += 3;
+						sscanf(s, "%d,%d,%d", &col[0], &col[1], &col[2]);
+						s += 6;
+						if (col[0] > 9)
+							s++;
+						if (col[1] > 9)
+							s++;
+						if (col[2] > 9)
+							s++;
+					}
+					if (i < numlayers - 1)
+						s++;
+				}
+				parameters->cp_fixed_alloc = 1;
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 't':			/* tiles */
+			{
+				sscanf(optarg, "%d,%d", &parameters->cp_tdx, &parameters->cp_tdy);
+				parameters->tile_size_on = true;
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'n':			/* resolution */
+			{
+				sscanf(optarg, "%d", &parameters->numresolution);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+			case 'c':			/* precinct dimension */
+			{
+				char sep;
+				int res_spec = 0;
+
+				char *s = optarg;
+				do {
+					sep = 0;
+					sscanf(s, "[%d,%d]%c", &parameters->prcw_init[res_spec],
+                                 &parameters->prch_init[res_spec], &sep);
+					parameters->csty |= 0x01;
+					res_spec++;
+					s = strpbrk(s, "]") + 2;
+				}
+				while (sep == ',');
+				parameters->res_spec = res_spec;
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'b':			/* code-block dimension */
+			{
+				int cblockw_init = 0, cblockh_init = 0;
+				sscanf(optarg, "%d,%d", &cblockw_init, &cblockh_init);
+				if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024
+					|| cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+					fprintf(stderr,
+						"!! Size of code_block error (option -b) !!\n\nRestriction :\n"
+            "    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
+					return 1;
+				}
+				parameters->cblockw_init = cblockw_init;
+				parameters->cblockh_init = cblockh_init;
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'x':			/* creation of index file */
+			{
+				char *index = optarg;
+				strncpy(indexfilename, index, OPJ_PATH_LEN);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'p':			/* progression order */
+			{
+				char progression[4];
+
+				strncpy(progression, optarg, 4);
+				parameters->prog_order = give_progression(progression);
+				if (parameters->prog_order == -1) {
+					fprintf(stderr, "Unrecognized progression order "
+            "[LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 's':			/* subsampling factor */
+			{
+				if (sscanf(optarg, "%d,%d", &parameters->subsampling_dx,
+                                    &parameters->subsampling_dy) != 2) {
+					fprintf(stderr,	"'-s' sub-sampling argument error !  [-s dx,dy]\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'd':			/* coordonnate of the reference grid */
+			{
+				if (sscanf(optarg, "%d,%d", &parameters->image_offset_x0,
+                                    &parameters->image_offset_y0) != 2) {
+					fprintf(stderr,	"-d 'coordonnate of the reference grid' argument "
+            "error !! [-d x0,y0]\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'h':			/* display an help description */
+				encode_help_display();
+				return 1;
+
+				/* ----------------------------------------------------- */
+
+			case 'P':			/* POC */
+			{
+				int numpocs = 0;		/* number of progression order change (POC) default 0 */
+				opj_poc_t *POC = NULL;	/* POC : used in case of Progression order change */
+
+				char *s = optarg;
+				POC = parameters->POC;
+
+				while (sscanf(s, "T%d=%d,%d,%d,%d,%d,%4s", &POC[numpocs].tile,
+					&POC[numpocs].resno0, &POC[numpocs].compno0,
+					&POC[numpocs].layno1, &POC[numpocs].resno1,
+					&POC[numpocs].compno1, &POC[numpocs].progorder) == 7) {
+					POC[numpocs].prg1 = give_progression(POC[numpocs].progorder);
+					numpocs++;
+					while (*s && *s != '/') {
+						s++;
+					}
+					if (!*s) {
+						break;
+					}
+					s++;
+				}
+				parameters->numpocs = numpocs;
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'S':			/* SOP marker */
+			{
+				parameters->csty |= 0x02;
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'E':			/* EPH marker */
+			{
+				parameters->csty |= 0x04;
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'M':			/* Mode switch pas tous au point !! */
+			{
+				int value = 0;
+				if (sscanf(optarg, "%d", &value) == 1) {
+					for (i = 0; i <= 5; i++) {
+						int cache = value & (1 << i);
+						if (cache)
+							parameters->mode |= (1 << i);
+					}
+				}
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'R':			/* ROI */
+			{
+				if (sscanf(optarg, "c=%d,U=%d", &parameters->roi_compno,
+                                           &parameters->roi_shift) != 2) {
+					fprintf(stderr, "ROI error !! [-ROI c='compno',U='shift']\n");
+					return 1;
+				}
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'T':			/* Tile offset */
+			{
+				if (sscanf(optarg, "%d,%d", &parameters->cp_tx0, &parameters->cp_ty0) != 2) {
+					fprintf(stderr, "-T 'tile offset' argument error !! [-T X0,Y0]");
+					return 1;
+				}
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+
+			case 'C':			/* add a comment */
+			{
+				parameters->cp_comment = (char*)malloc(strlen(optarg) + 1);
+				if(parameters->cp_comment) {
+					strcpy(parameters->cp_comment, optarg);
+				}
+			}
+			break;
+
+
+				/* ------------------------------------------------------ */
+
+			case 'I':			/* reversible or not */
+			{
+				parameters->irreversible = 1;
+			}
+			break;
+
+			/* ------------------------------------------------------ */
+			
+			case 'v':			/* Tile part generation*/
+			{
+				parameters->tp_flag = optarg[0];
+				parameters->tp_on = 1;
+			}
+			break;	
+
+				/* ------------------------------------------------------ */
+			
+			case 'z':			/* Image Directory path */
+			{
+				img_fol->imgdirpath = (char*)malloc(strlen(optarg) + 1);
+				strcpy(img_fol->imgdirpath,optarg);
+				img_fol->set_imgdir=1;
+			}
+			break;
+
+				/* ------------------------------------------------------ */
+			
+			case 'w':			/* Digital Cinema 2K profile compliance*/
+			{
+				int fps=0;
+				sscanf(optarg,"%d",&fps);
+				if(fps == 24){
+					parameters->cp_cinema = CINEMA2K_24;
+				}else if(fps == 48 ){
+					parameters->cp_cinema = CINEMA2K_48;
+				}else {
+					fprintf(stderr,"Incorrect value!! must be 24 or 48\n");
+					return 1;
+				}
+				fprintf(stdout,"CINEMA 2K compliant codestream\n");
+				parameters->cp_rsiz = CINEMA2K;
+				
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'y':			/* Digital Cinema 4K profile compliance*/
+			{
+				parameters->cp_cinema = CINEMA4K_24;
+				fprintf(stdout,"CINEMA 4K compliant codestream\n");
+				parameters->cp_rsiz = CINEMA4K;
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+
+/* UniPG>> */
+#ifdef USE_JPWL
+				/* ------------------------------------------------------ */
+			
+			case 'W':			/* JPWL capabilities switched on */
+			{
+				char *token = NULL;
+				int hprot, pprot, sens, addr, size, range;
+
+				/* we need to enable indexing */
+				if (!indexfilename) {
+					strncpy(indexfilename, JPWL_PRIVATEINDEX_NAME, OPJ_PATH_LEN);
+				}
+
+				/* search for different protection methods */
+
+				/* break the option in comma points and parse the result */
+				token = strtok(optarg, ",");
+				while(token != NULL) {
+
+					/* search header error protection method */
+					if (*token == 'h') {
+
+						static int tile = 0, tilespec = 0, lasttileno = 0;
+
+						hprot = 1; /* predefined method */
+
+						if(sscanf(token, "h=%d", &hprot) == 1) {
+							/* Main header, specified */
+							if (!((hprot == 0) || (hprot == 1) || (hprot == 16) || (hprot == 32) ||
+								((hprot >= 37) && (hprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid main header protection method h = %d\n", hprot);
+								return 1;
+							}
+							parameters->jpwl_hprot_MH = hprot;
+
+						} else if(sscanf(token, "h%d=%d", &tile, &hprot) == 2) {
+							/* Tile part header, specified */
+							if (!((hprot == 0) || (hprot == 1) || (hprot == 16) || (hprot == 32) ||
+								((hprot >= 37) && (hprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid tile part header protection method h = %d\n", hprot);
+								return 1;
+							}
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
+								return 1;
+							}
+							if (tilespec < JPWL_MAX_NO_TILESPECS) {
+								parameters->jpwl_hprot_TPH_tileno[tilespec] = lasttileno = tile;
+								parameters->jpwl_hprot_TPH[tilespec++] = hprot;
+							}
+
+						} else if(sscanf(token, "h%d", &tile) == 1) {
+							/* Tile part header, unspecified */
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method t = %d\n", tile);
+								return 1;
+							}
+							if (tilespec < JPWL_MAX_NO_TILESPECS) {
+								parameters->jpwl_hprot_TPH_tileno[tilespec] = lasttileno = tile;
+								parameters->jpwl_hprot_TPH[tilespec++] = hprot;
+							}
+
+
+						} else if (!strcmp(token, "h")) {
+							/* Main header, unspecified */
+							parameters->jpwl_hprot_MH = hprot;
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid protection method selection = %s\n", token);
+							return 1;
+						};
+
+					}
+
+					/* search packet error protection method */
+					if (*token == 'p') {
+
+						static int pack = 0, tile = 0, packspec = 0, lastpackno = 0;
+
+						pprot = 1; /* predefined method */
+
+						if (sscanf(token, "p=%d", &pprot) == 1) {
+							/* Method for all tiles and all packets */
+							if (!((pprot == 0) || (pprot == 1) || (pprot == 16) || (pprot == 32) ||
+								((pprot >= 37) && (pprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid default packet protection method p = %d\n", pprot);
+								return 1;
+							}
+							parameters->jpwl_pprot_tileno[0] = 0;
+							parameters->jpwl_pprot_packno[0] = 0;
+							parameters->jpwl_pprot[0] = pprot;
+
+						} else if (sscanf(token, "p%d=%d", &tile, &pprot) == 2) {
+							/* method specified from that tile on */
+							if (!((pprot == 0) || (pprot == 1) || (pprot == 16) || (pprot == 32) ||
+								((pprot >= 37) && (pprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid packet protection method p = %d\n", pprot);
+								return 1;
+							}
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
+								return 1;
+							}
+							if (packspec < JPWL_MAX_NO_PACKSPECS) {
+								parameters->jpwl_pprot_tileno[packspec] = tile;
+								parameters->jpwl_pprot_packno[packspec] = 0;
+								parameters->jpwl_pprot[packspec++] = pprot;
+							}
+
+						} else if (sscanf(token, "p%d:%d=%d", &tile, &pack, &pprot) == 3) {
+							/* method fully specified from that tile and that packet on */
+							if (!((pprot == 0) || (pprot == 1) || (pprot == 16) || (pprot == 32) ||
+								((pprot >= 37) && (pprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid packet protection method p = %d\n", pprot);
+								return 1;
+							}
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
+								return 1;
+							}
+							if (pack < 0) {
+								fprintf(stderr, "ERROR -> invalid packet number on protection method p = %d\n", pack);
+								return 1;
+							}
+							if (packspec < JPWL_MAX_NO_PACKSPECS) {
+								parameters->jpwl_pprot_tileno[packspec] = tile;
+								parameters->jpwl_pprot_packno[packspec] = pack;
+								parameters->jpwl_pprot[packspec++] = pprot;
+							}
+
+						} else if (sscanf(token, "p%d:%d", &tile, &pack) == 2) {
+							/* default method from that tile and that packet on */
+							if (!((pprot == 0) || (pprot == 1) || (pprot == 16) || (pprot == 32) ||
+								((pprot >= 37) && (pprot <= 128)))) {
+								fprintf(stderr, "ERROR -> invalid packet protection method p = %d\n", pprot);
+								return 1;
+							}
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
+								return 1;
+							}
+							if (pack < 0) {
+								fprintf(stderr, "ERROR -> invalid packet number on protection method p = %d\n", pack);
+								return 1;
+							}
+							if (packspec < JPWL_MAX_NO_PACKSPECS) {
+								parameters->jpwl_pprot_tileno[packspec] = tile;
+								parameters->jpwl_pprot_packno[packspec] = pack;
+								parameters->jpwl_pprot[packspec++] = pprot;
+							}
+
+						} else if (sscanf(token, "p%d", &tile) == 1) {
+							/* default from a tile on */
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on protection method p = %d\n", tile);
+								return 1;
+							}
+							if (packspec < JPWL_MAX_NO_PACKSPECS) {
+								parameters->jpwl_pprot_tileno[packspec] = tile;
+								parameters->jpwl_pprot_packno[packspec] = 0;
+								parameters->jpwl_pprot[packspec++] = pprot;
+							}
+
+
+						} else if (!strcmp(token, "p")) {
+							/* all default */
+							parameters->jpwl_pprot_tileno[0] = 0;
+							parameters->jpwl_pprot_packno[0] = 0;
+							parameters->jpwl_pprot[0] = pprot;
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid protection method selection = %s\n", token);
+							return 1;
+						};
+
+					}
+
+					/* search sensitivity method */
+					if (*token == 's') {
+
+						static int tile = 0, tilespec = 0, lasttileno = 0;
+
+						sens = 0; /* predefined: relative error */
+
+						if(sscanf(token, "s=%d", &sens) == 1) {
+							/* Main header, specified */
+							if ((sens < -1) || (sens > 7)) {
+								fprintf(stderr, "ERROR -> invalid main header sensitivity method s = %d\n", sens);
+								return 1;
+							}
+							parameters->jpwl_sens_MH = sens;
+
+						} else if(sscanf(token, "s%d=%d", &tile, &sens) == 2) {
+							/* Tile part header, specified */
+							if ((sens < -1) || (sens > 7)) {
+								fprintf(stderr, "ERROR -> invalid tile part header sensitivity method s = %d\n", sens);
+								return 1;
+							}
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
+								return 1;
+							}
+							if (tilespec < JPWL_MAX_NO_TILESPECS) {
+								parameters->jpwl_sens_TPH_tileno[tilespec] = lasttileno = tile;
+								parameters->jpwl_sens_TPH[tilespec++] = sens;
+							}
+
+						} else if(sscanf(token, "s%d", &tile) == 1) {
+							/* Tile part header, unspecified */
+							if (tile < 0) {
+								fprintf(stderr, "ERROR -> invalid tile part number on sensitivity method t = %d\n", tile);
+								return 1;
+							}
+							if (tilespec < JPWL_MAX_NO_TILESPECS) {
+								parameters->jpwl_sens_TPH_tileno[tilespec] = lasttileno = tile;
+								parameters->jpwl_sens_TPH[tilespec++] = hprot;
+							}
+
+						} else if (!strcmp(token, "s")) {
+							/* Main header, unspecified */
+							parameters->jpwl_sens_MH = sens;
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid sensitivity method selection = %s\n", token);
+							return 1;
+						};
+						
+						parameters->jpwl_sens_size = 2; /* 2 bytes for default size */
+					}
+
+					/* search addressing size */
+					if (*token == 'a') {
+
+						static int tile = 0, tilespec = 0, lasttileno = 0;
+
+						addr = 0; /* predefined: auto */
+
+						if(sscanf(token, "a=%d", &addr) == 1) {
+							/* Specified */
+							if ((addr != 0) && (addr != 2) && (addr != 4)) {
+								fprintf(stderr, "ERROR -> invalid addressing size a = %d\n", addr);
+								return 1;
+							}
+							parameters->jpwl_sens_addr = addr;
+
+						} else if (!strcmp(token, "a")) {
+							/* default */
+							parameters->jpwl_sens_addr = addr; /* auto for default size */
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid addressing selection = %s\n", token);
+							return 1;
+						};
+						
+					}
+
+					/* search sensitivity size */
+					if (*token == 'z') {
+
+						static int tile = 0, tilespec = 0, lasttileno = 0;
+
+						size = 1; /* predefined: 1 byte */
+
+						if(sscanf(token, "z=%d", &size) == 1) {
+							/* Specified */
+							if ((size != 0) && (size != 1) && (size != 2)) {
+								fprintf(stderr, "ERROR -> invalid sensitivity size z = %d\n", size);
+								return 1;
+							}
+							parameters->jpwl_sens_size = size;
+
+						} else if (!strcmp(token, "a")) {
+							/* default */
+							parameters->jpwl_sens_size = size; /* 1 for default size */
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid size selection = %s\n", token);
+							return 1;
+						};
+						
+					}
+
+					/* search range method */
+					if (*token == 'g') {
+
+						static int tile = 0, tilespec = 0, lasttileno = 0;
+
+						range = 0; /* predefined: 0 (packet) */
+
+						if(sscanf(token, "g=%d", &range) == 1) {
+							/* Specified */
+							if ((range < 0) || (range > 3)) {
+								fprintf(stderr, "ERROR -> invalid sensitivity range method g = %d\n", range);
+								return 1;
+							}
+							parameters->jpwl_sens_range = range;
+
+						} else if (!strcmp(token, "g")) {
+							/* default */
+							parameters->jpwl_sens_range = range;
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid range selection = %s\n", token);
+							return 1;
+						};
+						
+					}
+
+					/* next token or bust */
+					token = strtok(NULL, ",");
+				};
+
+
+				/* some info */
+				fprintf(stdout, "Info: JPWL capabilities enabled\n");
+				parameters->jpwl_epc_on = true;
+
+			}
+			break;
+#endif /* USE_JPWL */
+/* <<UniPG */
+
+				/* ------------------------------------------------------ */
+
+			default:
+				fprintf(stderr, "ERROR -> Command line not valid\n");
+				return 1;
+		}
+	}
+
+	/* check for possible errors */
+	if (parameters->cp_cinema){
+		if(parameters->tcp_numlayers > 1){
+			parameters->cp_rsiz = STD_RSIZ;
+     	fprintf(stdout,"Warning: DC profiles do not allow more than one quality layer. The codestream created will not be compliant with the DC profile\n");
+		}
+	}
+	if(img_fol->set_imgdir == 1){
+		if(!(parameters->infile[0] == 0)){
+			fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
+			return 1;
+		}
+		if(img_fol->set_out_format == 0){
+			fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
+			fprintf(stderr, "Only one format allowed! Valid formats are j2k and jp2!!\n");
+			return 1;
+		}
+		if(!((parameters->outfile[0] == 0))){
+			fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
+			fprintf(stderr, "Specify OutputFormat using -OutFor<FORMAT> !!\n");
+			return 1;
+		}
+	}else{
+		if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
+			fprintf(stderr, "Error: One of the options; -i or -ImgDir must be specified\n");
+			fprintf(stderr, "Error: When using -i; -o must be used\n");
+			fprintf(stderr, "usage: image_to_j2k -i image-file -o j2k/jp2-file (+ options)\n");
+			return 1;
+		}
+	}
+
+	if (parameters->decod_format == RAW_DFMT && raw_cp->rawWidth == 0) {
+			fprintf(stderr,"\nError: invalid raw image parameters\n");
+			fprintf(stderr,"Please use the Format option -F:\n");
+			fprintf(stderr,"-F rawWidth,rawHeight,rawComp,rawBitDepth,s/u (Signed/Unsigned)\n");
+						fprintf(stderr,"Example: -i lena.raw -o lena.j2k -F 512,512,3,8,u\n");
+			fprintf(stderr,"Aborting\n");
+			return 1;
+	}
+
+	if ((parameters->cp_disto_alloc || parameters->cp_fixed_alloc || parameters->cp_fixed_quality)
+		&& (!(parameters->cp_disto_alloc ^ parameters->cp_fixed_alloc ^ parameters->cp_fixed_quality))) {
+		fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
+		return 1;
+	}				/* mod fixed_quality */
+
+	/* if no rate entered, lossless by default */
+	if (parameters->tcp_numlayers == 0) {
+		parameters->tcp_rates[0] = 0;	/* MOD antonin : losslessbug */
+		parameters->tcp_numlayers++;
+		parameters->cp_disto_alloc = 1;
+	}
+
+	if((parameters->cp_tx0 > parameters->image_offset_x0) || (parameters->cp_ty0 > parameters->image_offset_y0)) {
+		fprintf(stderr,
+			"Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
+			parameters->cp_tx0, parameters->image_offset_x0, parameters->cp_ty0, parameters->image_offset_y0);
+		return 1;
+	}
+
+	for (i = 0; i < parameters->numpocs; i++) {
+		if (parameters->POC[i].prg == -1) {
+			fprintf(stderr,
+				"Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",
+				i + 1);
+		}
+	}
+
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+int main(int argc, char **argv) {
+	bool bSuccess;
+	opj_cparameters_t parameters;	/* compression parameters */
+	img_fol_t img_fol;
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *image = NULL;
+	int i,num_images;
+	int imageno;
+	dircnt_t *dirptr;
+	raw_cparameters_t raw_cp;
+	opj_codestream_info_t cstr_info;		/* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* set encoding parameters to default values */
+	opj_set_default_encoder_parameters(&parameters);
+
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
+
+	/* parse input and get user encoding parameters */
+	if(parse_cmdline_encoder(argc, argv, &parameters,&img_fol, &raw_cp, indexfilename) == 1) {
+		return 1;
+	}
+	
+	if (parameters.cp_cinema){
+		img_fol.rates = (float*)malloc(parameters.tcp_numlayers * sizeof(float));
+		for(i=0; i< parameters.tcp_numlayers; i++){
+			img_fol.rates[i] = parameters.tcp_rates[i];
+		}
+		cinema_parameters(&parameters);
+	}				
+
+	/* Create comment for codestream */
+	if(parameters.cp_comment == NULL) {
+    const char comment[] = "Created by OpenJPEG version ";
+		const size_t clen = strlen(comment);
+    const char *version = opj_version();
+/* UniPG>> */
+#ifdef USE_JPWL
+		parameters.cp_comment = (char*)malloc(clen+strlen(version)+11);
+		sprintf(parameters.cp_comment,"%s%s with JPWL", comment, version);
+#else
+		parameters.cp_comment = (char*)malloc(clen+strlen(version)+1);
+		sprintf(parameters.cp_comment,"%s%s", comment, version);
+#endif
+/* <<UniPG */
+	}
+
+	/* Read directory if necessary */
+	if(img_fol.set_imgdir==1){
+		num_images=get_num_images(img_fol.imgdirpath);
+		dirptr=(dircnt_t*)malloc(sizeof(dircnt_t));
+		if(dirptr){
+			dirptr->filename_buf = (char*)malloc(num_images*OPJ_PATH_LEN*sizeof(char));	// Stores at max 10 image file names
+			dirptr->filename = (char**) malloc(num_images*sizeof(char*));
+			if(!dirptr->filename_buf){
+				return 0;
+			}
+			for(i=0;i<num_images;i++){
+				dirptr->filename[i] = dirptr->filename_buf + i*OPJ_PATH_LEN;
+			}
+		}
+		if(load_images(dirptr,img_fol.imgdirpath)==1){
+			return 0;
+		}
+		if (num_images==0){
+			fprintf(stdout,"Folder is empty\n");
+			return 0;
+		}
+	}else{
+		num_images=1;
+	}
+	/*Encoding image one by one*/
+	for(imageno=0;imageno<num_images;imageno++)	{
+		image = NULL;
+		fprintf(stderr,"\n");
+		
+		if(img_fol.set_imgdir==1){
+			if (get_next_file(imageno, dirptr,&img_fol, &parameters)) {
+				fprintf(stderr,"skipping file...\n");
+				continue;
+			}
+		}
+		switch(parameters.decod_format) {
+			case PGX_DFMT:
+				break;
+			case PXM_DFMT:
+				break;
+			case BMP_DFMT:
+				break;
+			case TIF_DFMT:
+				break;
+			case RAW_DFMT:
+				break;
+			case TGA_DFMT:
+				break;
+			default:
+				fprintf(stderr,"skipping file...\n");
+				continue;			
+		}
+
+			/* decode the source image */
+			/* ----------------------- */
+
+			switch (parameters.decod_format) {
+				case PGX_DFMT:
+					image = pgxtoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load pgx file\n");
+						return 1; 
+					}
+					break;
+
+				case PXM_DFMT:
+					image = pnmtoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load pnm file\n");
+						return 1;
+					}
+					break;
+
+				case BMP_DFMT:
+					image = bmptoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load bmp file\n");
+						return 1;
+					}
+					break;
+			
+				case TIF_DFMT:
+					image = tiftoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load tiff file\n");
+						return 1;
+					}
+				break;
+
+				case RAW_DFMT:
+					image = rawtoimage(parameters.infile, &parameters, &raw_cp);
+					if (!image) {
+						fprintf(stderr, "Unable to load raw file\n");
+						return 1;
+					}
+				break;
+
+				case TGA_DFMT:
+					image = tgatoimage(parameters.infile, &parameters);
+					if (!image) {
+						fprintf(stderr, "Unable to load tga file\n");
+						return 1;
+					}
+				break;
+		}
+			/* Decide if MCT should be used */
+			parameters.tcp_mct = image->numcomps == 3 ? 1 : 0;
+
+			if(parameters.cp_cinema){
+				cinema_setup_encoder(&parameters,image,&img_fol);
+			}
+
+			/* encode the destination image */
+			/* ---------------------------- */
+
+			if (parameters.cod_format == J2K_CFMT) {	/* J2K format output */
+				int codestream_length;
+				opj_cio_t *cio = NULL;
+				FILE *f = NULL;
+
+				/* get a J2K compressor handle */
+				opj_cinfo_t* cinfo = opj_create_compress(CODEC_J2K);
+
+				/* catch events using our callbacks and give a local context */
+				opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+
+				/* setup the encoder parameters using the current image and user parameters */
+				opj_setup_encoder(cinfo, &parameters, image);
+
+				/* open a byte stream for writing */
+				/* allocate memory for all tiles */
+				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+				/* encode the image */
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
+				if (!bSuccess) {
+					opj_cio_close(cio);
+					fprintf(stderr, "failed to encode image\n");
+					return 1;
+				}
+				codestream_length = cio_tell(cio);
+
+				/* write the buffer to disk */
+				f = fopen(parameters.outfile, "wb");
+				if (!f) {
+					fprintf(stderr, "failed to open %s for writing\n", parameters.outfile);
+					return 1;
+				}
+				fwrite(cio->buffer, 1, codestream_length, f);
+				fclose(f);
+
+				fprintf(stderr,"Generated outfile %s\n",parameters.outfile);
+				/* close and free the byte stream */
+				opj_cio_close(cio);
+
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
+
+				/* free remaining compression structures */
+				opj_destroy_compress(cinfo);
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
+			} else {			/* JP2 format output */
+				int codestream_length;
+				opj_cio_t *cio = NULL;
+				FILE *f = NULL;
+
+				/* get a JP2 compressor handle */
+				opj_cinfo_t* cinfo = opj_create_compress(CODEC_JP2);
+
+				/* catch events using our callbacks and give a local context */
+				opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);			
+
+				/* setup the encoder parameters using the current image and using user parameters */
+				opj_setup_encoder(cinfo, &parameters, image);
+
+				/* open a byte stream for writing */
+				/* allocate memory for all tiles */
+				cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+				/* encode the image */
+				if (*indexfilename)					// If need to extract codestream information
+					bSuccess = opj_encode_with_info(cinfo, cio, image, &cstr_info);
+				else
+					bSuccess = opj_encode(cinfo, cio, image, NULL);
+				if (!bSuccess) {
+					opj_cio_close(cio);
+					fprintf(stderr, "failed to encode image\n");
+					return 1;
+				}
+				codestream_length = cio_tell(cio);
+
+				/* write the buffer to disk */
+				f = fopen(parameters.outfile, "wb");
+				if (!f) {
+					fprintf(stderr, "failed to open %s for writing\n", parameters.outfile);
+					return 1;
+				}
+				fwrite(cio->buffer, 1, codestream_length, f);
+				fclose(f);
+				fprintf(stderr,"Generated outfile %s\n",parameters.outfile);
+				/* close and free the byte stream */
+				opj_cio_close(cio);
+				
+				/* Write the index to disk */
+				if (*indexfilename) {
+					bSuccess = write_index_file(&cstr_info, indexfilename);
+					if (bSuccess) {
+						fprintf(stderr, "Failed to output index file\n");
+					}
+				}
+
+				/* free remaining compression structures */
+				opj_destroy_compress(cinfo);
+				if (*indexfilename)
+					opj_destroy_cstr_info(&cstr_info);
+			}
+	
+			/* free image data */
+			opj_image_destroy(image);
+	}
+
+	/* free user parameters structure */
+  if(parameters.cp_comment) free(parameters.cp_comment);
+	if(parameters.cp_matrice) free(parameters.cp_matrice);
+
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.dsp.svn-base ./codec/.svn/text-base/image_to_j2k.dsp.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/image_to_j2k.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,110 @@
+# Microsoft Developer Studio Project File - Name="image_to_j2k" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=image_to_j2k - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "image_to_j2k.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "image_to_j2k.mak" CFG="image_to_j2k - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "image_to_j2k - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "image_to_j2k - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "image_to_j2k - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"LIBC"
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "image_to_j2k - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"LIBC" /nodefaultlib:"LIBCMT" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "image_to_j2k - Win32 Release"
+# Name "image_to_j2k - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\convert.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\convert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\image_to_j2k.c
+# End Source File
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.dsw.svn-base ./codec/.svn/text-base/image_to_j2k.dsw.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/image_to_j2k.dsw.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"=..\LibOpenJPEG.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "image_to_j2k"=.\image_to_j2k.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
Binary files /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.sln.svn-base and ./codec/.svn/text-base/image_to_j2k.sln.svn-base differ
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.vcproj.svn-base ./codec/.svn/text-base/image_to_j2k.vcproj.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/image_to_j2k.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/image_to_j2k.vcproj.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,292 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="image_to_j2k"
+	ProjectGUID="{81FBE6CF-1DFB-413F-8215-0851F8E2D252}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/image_to_j2k.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/image_to_j2k.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/image_to_j2k.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/image_to_j2k.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/image_to_j2k.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/image_to_j2k.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/image_to_j2k.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath="image_to_j2k.c"
+			>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/index.c.svn-base ./codec/.svn/text-base/index.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/index.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/index.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,390 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <math.h>
+#include "openjpeg.h"
+#include "index.h"
+
+/* ------------------------------------------------------------------------------------ */
+
+/**
+Write a structured index to a file
+@param cstr_info Codestream information 
+@param index Index filename
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+	FILE *stream = NULL;
+	double total_disto = 0;
+/* UniPG>> */
+	int tilepartno;
+	char disto_on, numpix_on;
+
+#ifdef USE_JPWL
+	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+		return 0;
+#endif /* USE_JPWL */
+/* <<UniPG */
+
+	if (!cstr_info)		
+		return 1;
+
+	stream = fopen(index, "w");
+	if (!stream) {
+		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+		return 1;
+	}
+	
+	if (cstr_info->tile[0].distotile)
+		disto_on = 1;
+	else 
+		disto_on = 0;
+
+	if (cstr_info->tile[0].numpix)
+		numpix_on = 1;
+	else 
+		numpix_on = 0;
+
+	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+	fprintf(stream, "%d\n", cstr_info->prog);
+	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+	fprintf(stream, "%d\n", cstr_info->numcomps);
+	fprintf(stream, "%d\n", cstr_info->numlayers);
+	fprintf(stream, "%d\n", cstr_info->numdecompos);
+
+	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+		fprintf(stream, "[%d,%d] ", 
+			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+	}
+
+	fprintf(stream, "\n");
+/* UniPG>> */
+	fprintf(stream, "%d\n", cstr_info->main_head_start);
+/* <<UniPG */
+	fprintf(stream, "%d\n", cstr_info->main_head_end);
+	fprintf(stream, "%d\n", cstr_info->codestream_size);
+	
+	fprintf(stream, "\nINFO ON TILES\n");
+	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts");
+	if (disto_on)
+		fprintf(stream,"         disto");
+	if (numpix_on)
+		fprintf(stream,"     nbpix");
+	if (disto_on && numpix_on)
+		fprintf(stream,"  disto/nbpix");
+	fprintf(stream, "\n");
+
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		fprintf(stream, "%4d %9d %9d %9d %9d", 
+			cstr_info->tile[tileno].tileno,
+			cstr_info->tile[tileno].start_pos,
+			cstr_info->tile[tileno].end_header,
+			cstr_info->tile[tileno].end_pos,
+			cstr_info->tile[tileno].num_tps);
+		if (disto_on)
+			fprintf(stream," %9e", cstr_info->tile[tileno].distotile);
+		if (numpix_on)
+			fprintf(stream," %9d", cstr_info->tile[tileno].numpix);
+		if (disto_on && numpix_on)
+			fprintf(stream," %9e", cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+		fprintf(stream, "\n");
+	}
+		
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		int start_pos, end_ph_pos, end_pos;
+		double disto = 0;
+		int max_numdecompos = 0;
+		pack_nb = 0;
+
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			if (max_numdecompos < cstr_info->numdecompos[compno])
+				max_numdecompos = cstr_info->numdecompos[compno];
+		}	
+
+		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
+		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
+				tilepartno, tileno,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
+				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+				);
+
+		if (cstr_info->prog == LRCP) {	/* LRCP */
+			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos");
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max;
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d",
+								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos);
+							if (disto_on)
+								fprintf(stream, " %8e", disto);
+							fprintf(stream, "\n");
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* LRCP */
+
+		else if (cstr_info->prog == RLCP) {	/* RLCP */			
+			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos\n");
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max; 
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d",
+								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos);
+							if (disto_on)
+								fprintf(stream, " %8e", disto);
+							fprintf(stream, "\n");
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* RLCP */
+
+		else if (cstr_info->prog == RPCL) {	/* RPCL */
+
+			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				for (precno = 0; precno < numprec; precno++) {								
+					/* I suppose components have same XRsiz, YRsiz */
+					int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+					int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+					int x1 = x0 + cstr_info->tile_x;
+					int y1 = y0 + cstr_info->tile_y;
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {					
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d",
+												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* compno */
+			} /* resno */
+		} /* RPCL */
+
+		else if (cstr_info->prog == PCRL) {	/* PCRL */
+			/* I suppose components have same XRsiz, YRsiz */
+			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+			int x1 = x0 + cstr_info->tile_x;
+			int y1 = y0 + cstr_info->tile_y;
+
+			// Count the maximum number of precincts 
+			int max_numprec = 0;
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				if (numprec > max_numprec)
+					max_numprec = numprec;
+			}
+
+			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (precno = 0; precno < max_numprec; precno++) {
+				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (precno >= numprec)
+							continue;
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* resno */
+				} /* compno */
+			} /* precno */
+		} /* PCRL */
+
+		else {	/* CPRL */
+			// Count the maximum number of precincts 
+			int max_numprec = 0;
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+				if (numprec > max_numprec)
+					max_numprec = numprec;
+			}
+
+			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos"); 
+			if (disto_on)
+				fprintf(stream, " disto");
+			fprintf(stream,"\n");
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+
+				for (precno = 0; precno < max_numprec; precno++) {
+					for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+						int numprec = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						if (precno >= numprec)
+							continue;
+
+						for(y = y0; y < y1; y++) {
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d",
+												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos); 
+											if (disto_on)
+												fprintf(stream, " %8e", disto);
+											fprintf(stream, "\n");
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							}
+						} /* y = y0..y1 */
+					} /* resno */
+				} /* precno */
+			} /* compno */
+		} /* CPRL */   
+	} /* tileno */
+	
+	if (disto_on) {
+		fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */	
+		fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+	}
+/* UniPG>> */
+	/* print the markers' list */
+	if (cstr_info->marknum) {
+		fprintf(stream, "\nMARKER LIST\n");
+		fprintf(stream, "%d\n", cstr_info->marknum);
+		fprintf(stream, "type\tstart_pos    length\n");
+		for (x = 0; x < cstr_info->marknum; x++)
+			fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
+	}
+/* <<UniPG */
+	fclose(stream);
+
+	fprintf(stderr,"Generated index file %s\n", index);
+
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/index.h.svn-base ./codec/.svn/text-base/index.h.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/index.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/index.h.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __J2K_INDEX_H
+#define __J2K_INDEX_H
+
+/**
+Write a structured index to a file
+@param cstr_info Codestream information 
+@param index Index filename
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int write_index_file(opj_codestream_info_t *cstr_info, char *index);
+
+#endif /* __J2K_INDEX_H */
+
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.c.svn-base ./codec/.svn/text-base/j2k_to_image.c.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/j2k_to_image.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,808 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "openjpeg.h"
+#include "compat/getopt.h"
+#include "convert.h"
+#include "dirent.h"
+#include "index.h"
+
+#ifndef WIN32
+#define stricmp strcasecmp
+#define strnicmp strncasecmp
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+#define J2K_CFMT 0
+#define JP2_CFMT 1
+#define JPT_CFMT 2
+
+#define PXM_DFMT 10
+#define PGX_DFMT 11
+#define BMP_DFMT 12
+#define YUV_DFMT 13
+#define TIF_DFMT 14
+#define RAW_DFMT 15
+#define TGA_DFMT 16
+
+/* ----------------------------------------------------------------------- */
+
+typedef struct dircnt{
+	/** Buffer for holding images read from Directory*/
+	char *filename_buf;
+	/** Pointer to the buffer*/
+	char **filename;
+}dircnt_t;
+
+
+typedef struct img_folder{
+	/** The directory path of the folder containing input images*/
+	char *imgdirpath;
+	/** Output format*/
+	char *out_format;
+	/** Enable option*/
+	char set_imgdir;
+	/** Enable Cod Format for output*/
+	char set_out_format;
+
+}img_fol_t;
+
+void decode_help_display() {
+	fprintf(stdout,"HELP\n----\n\n");
+	fprintf(stdout,"- the -h option displays this help information on screen\n\n");
+
+/* UniPG>> */
+	fprintf(stdout,"List of parameters for the JPEG 2000 "
+#ifdef USE_JPWL
+		"+ JPWL "
+#endif /* USE_JPWL */
+		"decoder:\n");
+/* <<UniPG */
+	fprintf(stdout,"\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"  -ImgDir \n");
+	fprintf(stdout,"	Image file Directory path \n");
+	fprintf(stdout,"  -OutFor \n");
+	fprintf(stdout,"    REQUIRED only if -ImgDir is used\n");
+	fprintf(stdout,"	  Need to specify only format without filename <BMP>  \n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA formats\n");
+	fprintf(stdout,"  -i <compressed file>\n");
+	fprintf(stdout,"    REQUIRED only if an Input image directory not specified\n");
+	fprintf(stdout,"    Currently accepts J2K-files, JP2-files and JPT-files. The file type\n");
+	fprintf(stdout,"    is identified based on its suffix.\n");
+	fprintf(stdout,"  -o <decompressed file>\n");
+	fprintf(stdout,"    REQUIRED\n");
+	fprintf(stdout,"    Currently accepts PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA files\n");
+	fprintf(stdout,"    Binary data is written to the file (not ascii). If a PGX\n");
+	fprintf(stdout,"    filename is given, there will be as many output files as there are\n");
+	fprintf(stdout,"    components: an indice starting from 0 will then be appended to the\n");
+	fprintf(stdout,"    output filename, just before the \"pgx\" extension. If a PGM filename\n");
+	fprintf(stdout,"    is given and there are more than one component, only the first component\n");
+	fprintf(stdout,"    will be written to the file.\n");
+	fprintf(stdout,"  -r <reduce factor>\n");
+	fprintf(stdout,"    Set the number of highest resolution levels to be discarded. The\n");
+	fprintf(stdout,"    image resolution is effectively divided by 2 to the power of the\n");
+	fprintf(stdout,"    number of discarded levels. The reduce factor is limited by the\n");
+	fprintf(stdout,"    smallest total number of decomposition levels among tiles.\n");
+	fprintf(stdout,"  -l <number of quality layers to decode>\n");
+	fprintf(stdout,"    Set the maximum number of quality layers to decode. If there are\n");
+	fprintf(stdout,"    less quality layers than the specified number, all the quality layers\n");
+	fprintf(stdout,"    are decoded.\n");
+	fprintf(stdout,"  -x  \n"); 
+	fprintf(stdout,"    Create an index file *.Idx (-x index_name.Idx) \n");
+	fprintf(stdout,"\n");
+/* UniPG>> */
+#ifdef USE_JPWL
+	fprintf(stdout,"  -W <options>\n");
+	fprintf(stdout,"    Activates the JPWL correction capability, if the codestream complies.\n");
+	fprintf(stdout,"    Options can be a comma separated list of <param=val> tokens:\n");
+	fprintf(stdout,"    c, c=numcomps\n");
+	fprintf(stdout,"       numcomps is the number of expected components in the codestream\n");
+	fprintf(stdout,"       (search of first EPB rely upon this, default is %d)\n", JPWL_EXPECTED_COMPONENTS);
+#endif /* USE_JPWL */
+/* <<UniPG */
+	fprintf(stdout,"\n");
+}
+
+/* -------------------------------------------------------------------------- */
+
+int get_num_images(char *imgdirpath){
+	DIR *dir;
+	struct dirent* content;	
+	int num_images = 0;
+
+	/*Reading the input images from given input directory*/
+
+	dir= opendir(imgdirpath);
+	if(!dir){
+		fprintf(stderr,"Could not open Folder %s\n",imgdirpath);
+		return 0;
+	}
+	
+	while((content=readdir(dir))!=NULL){
+		if(strcmp(".",content->d_name)==0 || strcmp("..",content->d_name)==0 )
+			continue;
+		num_images++;
+	}
+	return num_images;
+}
+
+int load_images(dircnt_t *dirptr, char *imgdirpath){
+	DIR *dir;
+	struct dirent* content;	
+	int i = 0;
+
+	/*Reading the input images from given input directory*/
+
+	dir= opendir(imgdirpath);
+	if(!dir){
+		fprintf(stderr,"Could not open Folder %s\n",imgdirpath);
+		return 1;
+	}else	{
+		fprintf(stderr,"Folder opened successfully\n");
+	}
+	
+	while((content=readdir(dir))!=NULL){
+		if(strcmp(".",content->d_name)==0 || strcmp("..",content->d_name)==0 )
+			continue;
+
+		strcpy(dirptr->filename[i],content->d_name);
+		i++;
+	}
+	return 0;	
+}
+
+int get_file_format(char *filename) {
+	unsigned int i;
+	static const char *extension[] = {"pgx", "pnm", "pgm", "ppm", "bmp","tif", "raw", "tga", "j2k", "jp2", "jpt", "j2c" };
+	static const int format[] = { PGX_DFMT, PXM_DFMT, PXM_DFMT, PXM_DFMT, BMP_DFMT, TIF_DFMT, RAW_DFMT, TGA_DFMT, J2K_CFMT, JP2_CFMT, JPT_CFMT, J2K_CFMT };
+	char * ext = strrchr(filename, '.');
+	if (ext == NULL)
+		return -1;
+	ext++;
+	if(ext) {
+		for(i = 0; i < sizeof(format)/sizeof(*format); i++) {
+			if(strnicmp(ext, extension[i], 3) == 0) {
+				return format[i];
+			}
+		}
+	}
+
+	return -1;
+}
+
+char get_next_file(int imageno,dircnt_t *dirptr,img_fol_t *img_fol, opj_dparameters_t *parameters){
+	char image_filename[OPJ_PATH_LEN], infilename[OPJ_PATH_LEN],outfilename[OPJ_PATH_LEN],temp_ofname[OPJ_PATH_LEN];
+	char *temp_p, temp1[OPJ_PATH_LEN]="";
+
+	strcpy(image_filename,dirptr->filename[imageno]);
+	fprintf(stderr,"File Number %d \"%s\"\n",imageno,image_filename);
+	parameters->decod_format = get_file_format(image_filename);
+	if (parameters->decod_format == -1)
+		return 1;
+	sprintf(infilename,"%s/%s",img_fol->imgdirpath,image_filename);
+	strncpy(parameters->infile, infilename, sizeof(infilename));
+
+	//Set output file
+	strcpy(temp_ofname,strtok(image_filename,"."));
+	while((temp_p = strtok(NULL,".")) != NULL){
+		strcat(temp_ofname,temp1);
+		sprintf(temp1,".%s",temp_p);
+	}
+	if(img_fol->set_out_format==1){
+		sprintf(outfilename,"%s/%s.%s",img_fol->imgdirpath,temp_ofname,img_fol->out_format);
+		strncpy(parameters->outfile, outfilename, sizeof(outfilename));
+	}
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters,img_fol_t *img_fol, char *indexfilename) {
+	/* parse the command line */
+	int totlen;
+	option_t long_option[]={
+		{"ImgDir",REQ_ARG, NULL ,'y'},
+		{"OutFor",REQ_ARG, NULL ,'O'},
+	};
+
+	const char optlist[] = "i:o:r:l:hx:"
+
+/* UniPG>> */
+#ifdef USE_JPWL
+					"W:"
+#endif /* USE_JPWL */
+/* <<UniPG */
+					;
+	totlen=sizeof(long_option);
+	img_fol->set_out_format = 0;
+	while (1) {
+		int c = getopt_long(argc, argv,optlist,long_option,totlen);
+		if (c == -1)
+			break;
+		switch (c) {
+			case 'i':			/* input file */
+			{
+				char *infile = optarg;
+				parameters->decod_format = get_file_format(infile);
+				switch(parameters->decod_format) {
+					case J2K_CFMT:
+					case JP2_CFMT:
+					case JPT_CFMT:
+						break;
+					default:
+						fprintf(stderr, 
+							"!! Unrecognized format for infile : %s [accept only *.j2k, *.jp2, *.jpc or *.jpt] !!\n\n", 
+							infile);
+						return 1;
+				}
+				strncpy(parameters->infile, infile, sizeof(parameters->infile)-1);
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+
+			case 'o':			/* output file */
+			{
+				char *outfile = optarg;
+				parameters->cod_format = get_file_format(outfile);
+				switch(parameters->cod_format) {
+					case PGX_DFMT:
+					case PXM_DFMT:
+					case BMP_DFMT:
+					case TIF_DFMT:
+					case RAW_DFMT:
+					case TGA_DFMT:
+						break;
+					default:
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outfile);
+						return 1;
+				}
+				strncpy(parameters->outfile, outfile, sizeof(parameters->outfile)-1);
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+
+			case 'O':			/* output format */
+			{
+				char outformat[50];
+				char *of = optarg;
+				sprintf(outformat,".%s",of);
+				img_fol->set_out_format = 1;
+				parameters->cod_format = get_file_format(outformat);
+				switch(parameters->cod_format) {
+					case PGX_DFMT:
+						img_fol->out_format = "pgx";
+						break;
+					case PXM_DFMT:
+						img_fol->out_format = "ppm";
+						break;
+					case BMP_DFMT:
+						img_fol->out_format = "bmp";
+						break;
+					case TIF_DFMT:
+						img_fol->out_format = "tif";
+						break;
+					case RAW_DFMT:
+						img_fol->out_format = "raw";
+						break;
+					case TGA_DFMT:
+						img_fol->out_format = "raw";
+						break;
+					default:
+						fprintf(stderr, "Unknown output format image %s [only *.pnm, *.pgm, *.ppm, *.pgx, *.bmp, *.tif, *.raw or *.tga]!! \n", outformat);
+						return 1;
+						break;
+				}
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+
+			case 'r':		/* reduce option */
+			{
+				sscanf(optarg, "%d", &parameters->cp_reduce);
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+      
+
+			case 'l':		/* layering option */
+			{
+				sscanf(optarg, "%d", &parameters->cp_layer);
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+
+			case 'h': 			/* display an help description */
+				decode_help_display();
+				return 1;				
+
+				/* ------------------------------------------------------ */
+
+			case 'y':			/* Image Directory path */
+				{
+					img_fol->imgdirpath = (char*)malloc(strlen(optarg) + 1);
+					strcpy(img_fol->imgdirpath,optarg);
+					img_fol->set_imgdir=1;
+				}
+				break;
+				/* ----------------------------------------------------- */								
+			case 'x':			/* Creation of index file */
+				{
+					char *index = optarg;
+					strncpy(indexfilename, index, OPJ_PATH_LEN);
+				}
+				break;
+				/* ----------------------------------------------------- */
+				/* UniPG>> */
+#ifdef USE_JPWL
+			
+			case 'W': 			/* activate JPWL correction */
+			{
+				char *token = NULL;
+
+				token = strtok(optarg, ",");
+				while(token != NULL) {
+
+					/* search expected number of components */
+					if (*token == 'c') {
+
+						static int compno;
+
+						compno = JPWL_EXPECTED_COMPONENTS; /* predefined no. of components */
+
+						if(sscanf(token, "c=%d", &compno) == 1) {
+							/* Specified */
+							if ((compno < 1) || (compno > 256)) {
+								fprintf(stderr, "ERROR -> invalid number of components c = %d\n", compno);
+								return 1;
+							}
+							parameters->jpwl_exp_comps = compno;
+
+						} else if (!strcmp(token, "c")) {
+							/* default */
+							parameters->jpwl_exp_comps = compno; /* auto for default size */
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid components specified = %s\n", token);
+							return 1;
+						};
+					}
+
+					/* search maximum number of tiles */
+					if (*token == 't') {
+
+						static int tileno;
+
+						tileno = JPWL_MAXIMUM_TILES; /* maximum no. of tiles */
+
+						if(sscanf(token, "t=%d", &tileno) == 1) {
+							/* Specified */
+							if ((tileno < 1) || (tileno > JPWL_MAXIMUM_TILES)) {
+								fprintf(stderr, "ERROR -> invalid number of tiles t = %d\n", tileno);
+								return 1;
+							}
+							parameters->jpwl_max_tiles = tileno;
+
+						} else if (!strcmp(token, "t")) {
+							/* default */
+							parameters->jpwl_max_tiles = tileno; /* auto for default size */
+
+						} else {
+							fprintf(stderr, "ERROR -> invalid tiles specified = %s\n", token);
+							return 1;
+						};
+					}
+
+					/* next token or bust */
+					token = strtok(NULL, ",");
+				};
+				parameters->jpwl_correct = true;
+				fprintf(stdout, "JPWL correction capability activated\n");
+				fprintf(stdout, "- expecting %d components\n", parameters->jpwl_exp_comps);
+			}
+			break;	
+#endif /* USE_JPWL */
+/* <<UniPG */            
+
+				/* ----------------------------------------------------- */
+			
+			default:
+				fprintf(stderr,"WARNING -> this option is not valid \"-%c %s\"\n",c, optarg);
+				break;
+		}
+	}
+
+	/* check for possible errors */
+	if(img_fol->set_imgdir==1){
+		if(!(parameters->infile[0]==0)){
+			fprintf(stderr, "Error: options -ImgDir and -i cannot be used together !!\n");
+			return 1;
+		}
+		if(img_fol->set_out_format == 0){
+			fprintf(stderr, "Error: When -ImgDir is used, -OutFor <FORMAT> must be used !!\n");
+			fprintf(stderr, "Only one format allowed! Valid format PGM, PPM, PNM, PGX, BMP, TIF, RAW and TGA!!\n");
+			return 1;
+		}
+		if(!((parameters->outfile[0] == 0))){
+			fprintf(stderr, "Error: options -ImgDir and -o cannot be used together !!\n");
+			return 1;
+		}
+	}else{
+		if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
+			fprintf(stderr, "Error: One of the options -i or -ImgDir must be specified\n");
+			fprintf(stderr, "Error: When using -i, -o must be used\n");
+			fprintf(stderr, "usage: image_to_j2k -i *.j2k/jp2/j2c -o *.pgm/ppm/pnm/pgx/bmp/tif/raw/tga(+ options)\n");
+			return 1;
+		}
+	}
+
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting no client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	(void)client_data;
+	fprintf(stdout, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+int main(int argc, char **argv) {
+	opj_dparameters_t parameters;	/* decompression parameters */
+	img_fol_t img_fol;
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *image = NULL;
+	FILE *fsrc = NULL;
+	unsigned char *src = NULL;
+	int file_length;
+	int num_images;
+	int i,imageno;
+	dircnt_t *dirptr;
+	opj_dinfo_t* dinfo = NULL;	/* handle to a decompressor */
+	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+	char indexfilename[OPJ_PATH_LEN];	/* index file name */
+
+	/* configure the event callbacks (not required) */
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* set decoding parameters to default values */
+	opj_set_default_decoder_parameters(&parameters);
+
+	/* Initialize indexfilename and img_fol */
+	*indexfilename = 0;
+	memset(&img_fol,0,sizeof(img_fol_t));
+
+	/* parse input and get user encoding parameters */
+	if(parse_cmdline_decoder(argc, argv, &parameters,&img_fol, indexfilename) == 1) {
+		return 1;
+	}
+
+	/* Initialize reading of directory */
+	if(img_fol.set_imgdir==1){	
+		num_images=get_num_images(img_fol.imgdirpath);
+
+		dirptr=(dircnt_t*)malloc(sizeof(dircnt_t));
+		if(dirptr){
+			dirptr->filename_buf = (char*)malloc(num_images*OPJ_PATH_LEN*sizeof(char));	// Stores at max 10 image file names
+			dirptr->filename = (char**) malloc(num_images*sizeof(char*));
+
+			if(!dirptr->filename_buf){
+				return 0;
+			}
+			for(i=0;i<num_images;i++){
+				dirptr->filename[i] = dirptr->filename_buf + i*OPJ_PATH_LEN;
+			}
+		}
+		if(load_images(dirptr,img_fol.imgdirpath)==1){
+			return 0;
+		}
+		if (num_images==0){
+			fprintf(stdout,"Folder is empty\n");
+			return 0;
+		}
+	}else{
+		num_images=1;
+	}
+
+	/*Encoding image one by one*/
+	for(imageno = 0; imageno < num_images ; imageno++)	{
+		image = NULL;
+		fprintf(stderr,"\n");
+
+		if(img_fol.set_imgdir==1){
+			if (get_next_file(imageno, dirptr,&img_fol, &parameters)) {
+				fprintf(stderr,"skipping file...\n");
+				continue;
+			}
+		}
+
+		/* read the input file and put it in memory */
+		/* ---------------------------------------- */
+		fsrc = fopen(parameters.infile, "rb");
+		if (!fsrc) {
+			fprintf(stderr, "ERROR -> failed to open %s for reading\n", parameters.infile);
+			return 1;
+		}
+		fseek(fsrc, 0, SEEK_END);
+		file_length = ftell(fsrc);
+		fseek(fsrc, 0, SEEK_SET);
+		src = (unsigned char *) malloc(file_length);
+		fread(src, 1, file_length, fsrc);
+		fclose(fsrc);
+
+		/* decode the code-stream */
+		/* ---------------------- */
+
+		switch(parameters.decod_format) {
+		case J2K_CFMT:
+		{
+			/* JPEG-2000 codestream */
+
+			/* get a decoder handle */
+			dinfo = opj_create_decompress(CODEC_J2K);
+
+			/* catch events using our callbacks and give a local context */
+			opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+			/* setup the decoder decoding parameters using user parameters */
+			opj_setup_decoder(dinfo, &parameters);
+
+			/* open a byte stream */
+			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+			/* decode the stream and fill the image structure */
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
+			if(!image) {
+				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
+				opj_destroy_decompress(dinfo);
+				opj_cio_close(cio);
+				return 1;
+			}
+
+			/* close the byte stream */
+			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
+		}
+		break;
+
+		case JP2_CFMT:
+		{
+			/* JPEG 2000 compressed image data */
+
+			/* get a decoder handle */
+			dinfo = opj_create_decompress(CODEC_JP2);
+
+			/* catch events using our callbacks and give a local context */
+			opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+			/* setup the decoder decoding parameters using the current image and user parameters */
+			opj_setup_decoder(dinfo, &parameters);
+
+			/* open a byte stream */
+			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+			/* decode the stream and fill the image structure */
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);			
+			if(!image) {
+				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
+				opj_destroy_decompress(dinfo);
+				opj_cio_close(cio);
+				return 1;
+			}
+
+			/* close the byte stream */
+			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
+		}
+		break;
+
+		case JPT_CFMT:
+		{
+			/* JPEG 2000, JPIP */
+
+			/* get a decoder handle */
+			dinfo = opj_create_decompress(CODEC_JPT);
+
+			/* catch events using our callbacks and give a local context */
+			opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+			/* setup the decoder decoding parameters using user parameters */
+			opj_setup_decoder(dinfo, &parameters);
+
+			/* open a byte stream */
+			cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+			/* decode the stream and fill the image structure */
+			if (*indexfilename)				// If need to extract codestream information
+				image = opj_decode_with_info(dinfo, cio, &cstr_info);
+			else
+				image = opj_decode(dinfo, cio);
+			if(!image) {
+				fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
+				opj_destroy_decompress(dinfo);
+				opj_cio_close(cio);
+				return 1;
+			}
+
+			/* close the byte stream */
+			opj_cio_close(cio);
+
+			/* Write the index to disk */
+			if (*indexfilename) {
+				char bSuccess;
+				bSuccess = write_index_file(&cstr_info, indexfilename);
+				if (bSuccess) {
+					fprintf(stderr, "Failed to output index file\n");
+				}
+			}
+		}
+		break;
+
+		default:
+			fprintf(stderr, "skipping file..\n");
+			continue;
+	}
+
+		/* free the memory containing the code-stream */
+		free(src);
+		src = NULL;
+
+		/* create output image */
+		/* ------------------- */
+		switch (parameters.cod_format) {
+		case PXM_DFMT:			/* PNM PGM PPM */
+			if (imagetopnm(image, parameters.outfile)) {
+				fprintf(stdout,"Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case PGX_DFMT:			/* PGX */
+			if(imagetopgx(image, parameters.outfile)){
+				fprintf(stdout,"Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case BMP_DFMT:			/* BMP */
+			if(imagetobmp(image, parameters.outfile)){
+				fprintf(stdout,"Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case TIF_DFMT:			/* TIFF */
+			if(imagetotif(image, parameters.outfile)){
+				fprintf(stdout,"Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case RAW_DFMT:			/* RAW */
+			if(imagetoraw(image, parameters.outfile)){
+				fprintf(stdout,"Error generating raw file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+
+		case TGA_DFMT:			/* TGA */
+			if(imagetotga(image, parameters.outfile)){
+				fprintf(stdout,"Error generating tga file. Outfile %s not generated\n",parameters.outfile);
+			}
+			else {
+				fprintf(stdout,"Successfully generated Outfile %s\n",parameters.outfile);
+			}
+			break;
+		}
+
+		/* free remaining structures */
+		if(dinfo) {
+			opj_destroy_decompress(dinfo);
+		}
+		/* free codestream information structure */
+		if (*indexfilename)	
+			opj_destroy_cstr_info(&cstr_info);
+		/* free image data structure */
+		opj_image_destroy(image);
+
+	}
+	return 0;
+}
+//end main
+
+
+
+
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.dsp.svn-base ./codec/.svn/text-base/j2k_to_image.dsp.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/j2k_to_image.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,109 @@
+# Microsoft Developer Studio Project File - Name="j2k_to_image" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=j2k_to_image - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "j2k_to_image.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "j2k_to_image.mak" CFG="j2k_to_image - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "j2k_to_image - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "j2k_to_image - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "j2k_to_image - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libc"
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "j2k_to_image - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libc" /nodefaultlib:"libcmt" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "j2k_to_image - Win32 Release"
+# Name "j2k_to_image - Win32 Debug"
+# Begin Source File
+
+SOURCE=.\convert.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\convert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\j2k_to_image.c
+# End Source File
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.dsw.svn-base ./codec/.svn/text-base/j2k_to_image.dsw.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/j2k_to_image.dsw.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"=..\LibOpenJPEG.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "j2k_to_image"=.\j2k_to_image.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
Binary files /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.sln.svn-base and ./codec/.svn/text-base/j2k_to_image.sln.svn-base differ
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.vcproj.svn-base ./codec/.svn/text-base/j2k_to_image.vcproj.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/j2k_to_image.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/j2k_to_image.vcproj.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,291 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="j2k_to_image"
+	ProjectGUID="{28931669-81A2-4B90-8981-CD707C4E76E6}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/j2k_to_image.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Debug/j2k_to_image.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc,libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/j2k_to_image.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/j2k_to_image.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/j2k_to_image.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/j2k_to_image.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/j2k_to_image.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath="convert.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="convert.h"
+			>
+		</File>
+		<File
+			RelativePath="compat\getopt.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+		<File
+			RelativePath="compat\getopt.h"
+			>
+		</File>
+		<File
+			RelativePath=".\index.c"
+			>
+		</File>
+		<File
+			RelativePath=".\index.h"
+			>
+		</File>
+		<File
+			RelativePath="j2k_to_image.c"
+			>
+			<FileConfiguration
+				Name="Debug|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+			<FileConfiguration
+				Name="Release|Win32"
+				>
+				<Tool
+					Name="VCCLCompilerTool"
+					AdditionalIncludeDirectories=""
+					PreprocessorDefinitions=""
+				/>
+			</FileConfiguration>
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/codec/.svn/text-base/Makefile.svn-base ./codec/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/codec/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./codec/.svn/text-base/Makefile.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,14 @@
+# Makefile for the main OpenJPEG codecs: j2k_to_image and image_to_j2k
+
+CFLAGS = -O3 -lstdc++ # -g -p -pg
+
+all: j2k_to_image image_to_j2k
+
+j2k_to_image: j2k_to_image.c ../libopenjpeg.a
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c j2k_to_image.c -o j2k_to_image -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+
+image_to_j2k: image_to_j2k.c ../libopenjpeg.a
+	gcc $(CFLAGS) compat/getopt.c index.c convert.c image_to_j2k.c -o image_to_j2k -L.. -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+
+clean:
+	rm -f j2k_to_image image_to_j2k
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/all-wcprops ./CVSROOT/.svn/all-wcprops
--- /home/robin/sldeb/trunk/CVSROOT/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/all-wcprops	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,83 @@
+K 25
+svn:wc:ra_dav:version-url
+V 31
+/svn/!svn/ver/229/trunk/CVSROOT
+END
+checkCtrlM
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/229/trunk/CVSROOT/checkCtrlM
+END
+cvswrappers
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/3/trunk/CVSROOT/cvswrappers
+END
+checkoutlist
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/215/trunk/CVSROOT/checkoutlist
+END
+editinfo
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/3/trunk/CVSROOT/editinfo
+END
+rcsinfo
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/3/trunk/CVSROOT/rcsinfo
+END
+commitinfo
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/215/trunk/CVSROOT/commitinfo
+END
+config
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/3/trunk/CVSROOT/config
+END
+checkTabs
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/215/trunk/CVSROOT/checkTabs
+END
+taginfo
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/3/trunk/CVSROOT/taginfo
+END
+modules
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/206/trunk/CVSROOT/modules
+END
+notify
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/3/trunk/CVSROOT/notify
+END
+verifymsg
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/3/trunk/CVSROOT/verifymsg
+END
+loginfo
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/3/trunk/CVSROOT/loginfo
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/entries ./CVSROOT/.svn/entries
--- /home/robin/sldeb/trunk/CVSROOT/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,197 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/CVSROOT
+http://www.openjpeg.org/svn
+
+
+
+2006-01-25T15:54:10.000000Z
+229
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+checkCtrlM
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+740d4a289f155ef9f0663124d9d033cd
+2006-01-25T15:54:10.000000Z
+229
+gdcm
+has-props
+
+cvswrappers
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+7122042372bc989d1098c077df64a410
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+checkoutlist
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+e59d95ac27f0cdead019e9e086cb017d
+2006-01-22T19:19:19.000000Z
+215
+descampe
+has-props
+
+editinfo
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+c0245bd6cbece787af06cb3e1969ea78
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+rcsinfo
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+4ca72032cff35f7d200d0778ba93ab65
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+commitinfo
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+03702682418e01bdbd56d845ec3a9a4e
+2006-01-22T19:19:19.000000Z
+215
+descampe
+has-props
+
+config
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+0c30edbbeb4491a8937c4dcf49dc13d2
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+checkTabs
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+8fa266700735cb1f0dca97d9b6d39d21
+2006-01-22T19:19:19.000000Z
+215
+descampe
+has-props
+
+taginfo
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+6c6d903782cf3195ba68085654c8c5f3
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+modules
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+cb978cf5bf5c0531314f34ae838df65c
+2005-12-08T09:40:00.000000Z
+206
+descampe
+has-props
+
+notify
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+3634e43fc97171e3a3121f7b5f7c2686
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+verifymsg
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+0ad9fcdfc8f7bc24ba445a785fdd1bfc
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
+loginfo
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+d2a958f146de3e13b1d0935c0d319a88
+2003-11-27T10:07:24.000000Z
+3
+lugan
+has-props
+
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/format ./CVSROOT/.svn/format
--- /home/robin/sldeb/trunk/CVSROOT/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/format	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkCtrlM.svn-base ./CVSROOT/.svn/prop-base/checkCtrlM.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkCtrlM.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/checkCtrlM.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,13 @@
+K 13
+svn:eol-style
+V 6
+native
+K 14
+svn:executable
+V 1
+*
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkoutlist.svn-base ./CVSROOT/.svn/prop-base/checkoutlist.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkoutlist.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/checkoutlist.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkTabs.svn-base ./CVSROOT/.svn/prop-base/checkTabs.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/checkTabs.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/checkTabs.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,13 @@
+K 13
+svn:eol-style
+V 6
+native
+K 14
+svn:executable
+V 1
+*
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/commitinfo.svn-base ./CVSROOT/.svn/prop-base/commitinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/commitinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/commitinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/config.svn-base ./CVSROOT/.svn/prop-base/config.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/config.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/config.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/cvswrappers.svn-base ./CVSROOT/.svn/prop-base/cvswrappers.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/cvswrappers.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/cvswrappers.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/editinfo.svn-base ./CVSROOT/.svn/prop-base/editinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/editinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/editinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/loginfo.svn-base ./CVSROOT/.svn/prop-base/loginfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/loginfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/loginfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/modules.svn-base ./CVSROOT/.svn/prop-base/modules.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/modules.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/modules.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/notify.svn-base ./CVSROOT/.svn/prop-base/notify.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/notify.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/notify.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/rcsinfo.svn-base ./CVSROOT/.svn/prop-base/rcsinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/rcsinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/rcsinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/taginfo.svn-base ./CVSROOT/.svn/prop-base/taginfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/taginfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/taginfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/verifymsg.svn-base ./CVSROOT/.svn/prop-base/verifymsg.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/prop-base/verifymsg.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/prop-base/verifymsg.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkCtrlM.svn-base ./CVSROOT/.svn/text-base/checkCtrlM.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkCtrlM.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/checkCtrlM.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,39 @@
+#!/bin/sh
+#
+# checkCtrlM checks source code for explicit ctrl-M's
+#   checks only files with the following extensions: .c, .cxx, .txx, .html, .htm
+#   exits with 0, if all commited files pass the test.
+#   exits with 1, if any one of the tests fails
+#
+# checkCtrlM can be run as a cvs commitinfo command.
+# The following commitinfo line (without the #) will run the script
+# ALL	$CVSROOT/CVSROOT/checkCtrlM
+# 
+failed=0
+#
+# skip the first arg, the directory
+shift 1
+
+for file in "$@"; do
+  #
+  # select files with extentions .txx, .cxx, .h, .html, .htm, .c, .txt, .cmake
+  match=`echo $file | egrep \[\.\]txx\$\|\[\.\]cxx\$\|\[\.\]h\$\|\[\.\]html\$\|\[\.\]htm\$\|\[\.\]c\$\|\[\.\]txt\$\|\[\.\]cmake\$`
+  if [ "x$match" != "x" ] ; then
+    count=`grep -n 
+\$ /dev/null $file|wc -c`
+    results=`expr $count \| 0`
+    if [ "$results" != "0" ]; then
+      echo "=========================================================="
+      if [ $results -lt 200 ]; then
+        grep -n 
+\$ /dev/null $file
+      fi
+      echo ""
+      echo "$file has ^M's. They must be removed before you can commit."
+      echo "The problem count was $results"
+      echo "=========================================================="
+      failed=1
+    fi
+  fi
+done
+exit $failed
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkoutlist.svn-base ./CVSROOT/.svn/text-base/checkoutlist.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkoutlist.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/checkoutlist.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,15 @@
+# The "checkoutlist" file is used to support additional version controlled
+# administrative files in $CVSROOT/CVSROOT, such as template files.
+#
+# The first entry on a line is a filename which will be checked out from
+# the corresponding RCS file in the $CVSROOT/CVSROOT directory.
+# The remainder of the line is an error message to use if the file cannot
+# be checked out.
+#
+# File format:
+#
+#	[<whitespace>]<filename><whitespace><error message><end-of-line>
+#
+# comment lines begin with '#'
+checkCtrlM cannot check out checkCtrlM
+checkTabs cannot check out checkTabs
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkTabs.svn-base ./CVSROOT/.svn/text-base/checkTabs.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/checkTabs.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/checkTabs.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,32 @@
+#!/bin/tcsh
+#
+# checkTabs checks source code for explicit TABS
+#   checks only files with the following extensions: .c, .cxx, .txx,
+#   exits with 0, if all commited files pass the test.
+#   exits with 1, if any one of the tests fails
+#
+# checkTabs can be run as a cvs commitinfo command.
+# The following commitinfo line (without the #) will run the script
+# ALL	$CVSROOT/CVSROOT/checkTabs
+# 
+set failed=0
+#
+# skip the first arg, the directory
+foreach file ( $argv[2-] )
+#
+# select files with extentions .txx, .cxx, .h, .html, .htm
+set match=`echo $file | egrep \[\.\]txx\$\|\[\.\]cxx\$\|\[\.\]h\$\|\[\.\]cpp\$\|\[\.\]htm\$\|\[\.\]html\$\|\[\.\]c\$\|\[\.\]mm\$\|\[\.\]h.in\$\|\[\.\]hxx.in\$\|CMakeLists.txt\$\|\[\.\]cmake\$\|\[\.\]cmake.in\$`
+if ( $match == "" ) continue;
+set count=`grep -n "	" /dev/null $file|wc -c`
+set results=`expr $count \| 0`
+if ( "$results" != "0" ) then
+	echo "=========================================================="
+	grep -n "	" /dev/null $file
+	echo ""
+	echo "$file has explicit TABSs."
+	echo "They must be converted to SPACES(2 per TAB) before you can commit."
+	echo "=========================================================="
+	set failed=1
+endif
+end
+exit $failed
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/commitinfo.svn-base ./CVSROOT/.svn/text-base/commitinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/commitinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/commitinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,18 @@
+# The "commitinfo" file is used to control pre-commit checks.
+# The filter on the right is invoked with the repository and a list 
+# of files to check.  A non-zero exit of the filter program will 
+# cause the commit to be aborted.
+#
+# The first entry on a line is a regular expression which is tested
+# against the directory that the change is being committed to, relative
+# to the $CVSROOT.  For the first match that is found, then the remainder
+# of the line is the name of the filter to run.
+#
+# If the repository name does not match any of the regular expressions in this
+# file, the "DEFAULT" line is used, if it is specified.
+#
+# If the name "ALL" appears as a regular expression it is always used
+# in addition to the first matching regex or "DEFAULT".
+
+ALL	$CVSROOT/CVSROOT/checkCtrlM %r/%p %s
+# ALL	$CVSROOT/CVSROOT/checkTabs %r/%p %s
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/config.svn-base ./CVSROOT/.svn/text-base/config.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/config.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/config.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,14 @@
+# Set this to "no" if pserver shouldn't check system users/passwords
+#SystemAuth=no
+
+# Put CVS lock files in this directory rather than directly in the repository.
+#LockDir=/var/lock/cvs
+
+# Set `TopLevelAdmin' to `yes' to create a CVS directory at the top
+# level of the new working directory when using the `cvs checkout'
+# command.
+#TopLevelAdmin=no
+
+# Set `LogHistory' to `all' or `TOFEWGCMAR' to log all transactions to the
+# history file, or a subset as needed (ie `TMAR' logs all write operations)
+#LogHistory=TOFEWGCMAR
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/cvswrappers.svn-base ./CVSROOT/.svn/text-base/cvswrappers.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/cvswrappers.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/cvswrappers.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,23 @@
+# This file affects handling of files based on their names.
+#
+# The -t/-f options allow one to treat directories of files
+# as a single file, or to transform a file in other ways on
+# its way in and out of CVS.
+#
+# The -m option specifies whether CVS attempts to merge files.
+#
+# The -k option specifies keyword expansion (e.g. -kb for binary).
+#
+# Format of wrapper file ($CVSROOT/CVSROOT/cvswrappers or .cvswrappers)
+#
+#  wildcard	[option value][option value]...
+#
+#  where option is one of
+#  -f		from cvs filter		value: path to filter
+#  -t		to cvs filter		value: path to filter
+#  -m		update methodology	value: MERGE or COPY
+#  -k		expansion mode		value: b, o, kkv, &c
+#
+#  and value is a single-quote delimited value.
+# For example:
+#*.gif -k 'b'
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/editinfo.svn-base ./CVSROOT/.svn/text-base/editinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/editinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/editinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,21 @@
+# The "editinfo" file is used to allow verification of logging
+# information.  It works best when a template (as specified in the
+# rcsinfo file) is provided for the logging procedure.  Given a
+# template with locations for, a bug-id number, a list of people who
+# reviewed the code before it can be checked in, and an external
+# process to catalog the differences that were code reviewed, the
+# following test can be applied to the code:
+#
+#   Making sure that the entered bug-id number is correct.
+#   Validating that the code that was reviewed is indeed the code being
+#       checked in (using the bug-id number or a seperate review
+#       number to identify this particular code set.).
+#
+# If any of the above test failed, then the commit would be aborted.
+#
+# Actions such as mailing a copy of the report to each reviewer are
+# better handled by an entry in the loginfo file.
+#
+# One thing that should be noted is the the ALL keyword is not
+# supported.  There can be only one entry that matches a given
+# repository.
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/loginfo.svn-base ./CVSROOT/.svn/text-base/loginfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/loginfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/loginfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,26 @@
+# The "loginfo" file controls where "cvs commit" log information
+# is sent.  The first entry on a line is a regular expression which must match
+# the directory that the change is being made to, relative to the
+# $CVSROOT.  If a match is found, then the remainder of the line is a filter
+# program that should expect log information on its standard input.
+#
+# If the repository name does not match any of the regular expressions in this
+# file, the "DEFAULT" line is used, if it is specified.
+#
+# If the name ALL appears as a regular expression it is always used
+# in addition to the first matching regex or DEFAULT.
+#
+# You may specify a format string as part of the
+# filter.  The string is composed of a `%' followed
+# by a single format character, or followed by a set of format
+# characters surrounded by `{' and `}' as separators.  The format
+# characters are:
+#
+#   s = file name
+#   V = old version number (pre-checkin)
+#   v = new version number (post-checkin)
+#
+# For example:
+#DEFAULT (echo ""; id; echo %s; date; cat) >> $CVSROOT/CVSROOT/commitlog
+# or
+#DEFAULT (echo ""; id; echo %{sVv}; date; cat) >> $CVSROOT/CVSROOT/commitlog
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/modules.svn-base ./CVSROOT/.svn/text-base/modules.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/modules.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/modules.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,29 @@
+# Three different line formats are valid:
+#	key	-a    aliases...
+#	key [options] directory
+#	key [options] directory files...
+#
+# Where "options" are composed of:
+#	-i prog		Run "prog" on "cvs commit" from top-level of module.
+#	-o prog		Run "prog" on "cvs checkout" of module.
+#	-e prog		Run "prog" on "cvs export" of module.
+#	-t prog		Run "prog" on "cvs rtag" of module.
+#	-u prog		Run "prog" on "cvs update" of module.
+#	-d dir		Place module in directory "dir" instead of module name.
+#	-l		Top-level directory only -- do not recurse.
+#
+# NOTE:  If you change any of the "Run" options above, you'll have to
+# release and re-checkout any working directories of these modules.
+#
+# And "directory" is a path to a directory relative to $CVSROOT.
+#
+# The "-a" option specifies an alias.  An alias is interpreted as if
+# everything on the right of the "-a" had been typed on the command line.
+#
+# You can encode a module within a module by using the special '&'
+# character to interpose another module into the current module.  This
+# can be useful for creating a module that consists of many directories
+# spread out over the entire source repository.
+
+opj-base -l -d . . 
+openjpeg -a opj-base libopenjpeg codec doc
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/notify.svn-base ./CVSROOT/.svn/text-base/notify.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/notify.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/notify.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,12 @@
+# The "notify" file controls where notifications from watches set by
+# "cvs watch add" or "cvs edit" are sent.  The first entry on a line is
+# a regular expression which is tested against the directory that the
+# change is being made to, relative to the $CVSROOT.  If it matches,
+# then the remainder of the line is a filter program that should contain
+# one occurrence of %s for the user to notify, and information on its
+# standard input.
+#
+# "ALL" or "DEFAULT" can be used in place of the regular expression.
+#
+# For example:
+#ALL mail %s -s "CVS notification"
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/rcsinfo.svn-base ./CVSROOT/.svn/text-base/rcsinfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/rcsinfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/rcsinfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,13 @@
+# The "rcsinfo" file is used to control templates with which the editor
+# is invoked on commit and import.
+#
+# The first entry on a line is a regular expression which is tested
+# against the directory that the change is being made to, relative to the
+# $CVSROOT.  For the first match that is found, then the remainder of the
+# line is the name of the file that contains the template.
+#
+# If the repository name does not match any of the regular expressions in this
+# file, the "DEFAULT" line is used, if it is specified.
+#
+# If the name "ALL" appears as a regular expression it is always used
+# in addition to the first matching regex or "DEFAULT".
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/taginfo.svn-base ./CVSROOT/.svn/text-base/taginfo.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/taginfo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/taginfo.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,20 @@
+# The "taginfo" file is used to control pre-tag checks.
+# The filter on the right is invoked with the following arguments:
+#
+# $1 -- tagname
+# $2 -- operation "add" for tag, "mov" for tag -F, and "del" for tag -d
+# $3 -- repository
+# $4->  file revision [file revision ...]
+#
+# A non-zero exit of the filter program will cause the tag to be aborted.
+#
+# The first entry on a line is a regular expression which is tested
+# against the directory that the change is being committed to, relative
+# to the $CVSROOT.  For the first match that is found, then the remainder
+# of the line is the name of the filter to run.
+#
+# If the repository name does not match any of the regular expressions in this
+# file, the "DEFAULT" line is used, if it is specified.
+#
+# If the name "ALL" appears as a regular expression it is always used
+# in addition to the first matching regex or "DEFAULT".
diff -urN /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/verifymsg.svn-base ./CVSROOT/.svn/text-base/verifymsg.svn-base
--- /home/robin/sldeb/trunk/CVSROOT/.svn/text-base/verifymsg.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./CVSROOT/.svn/text-base/verifymsg.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,21 @@
+# The "verifymsg" file is used to allow verification of logging
+# information.  It works best when a template (as specified in the
+# rcsinfo file) is provided for the logging procedure.  Given a
+# template with locations for, a bug-id number, a list of people who
+# reviewed the code before it can be checked in, and an external
+# process to catalog the differences that were code reviewed, the
+# following test can be applied to the code:
+#
+#   Making sure that the entered bug-id number is correct.
+#   Validating that the code that was reviewed is indeed the code being
+#       checked in (using the bug-id number or a seperate review
+#       number to identify this particular code set.).
+#
+# If any of the above test failed, then the commit would be aborted.
+#
+# Actions such as mailing a copy of the report to each reviewer are
+# better handled by an entry in the loginfo file.
+#
+# One thing that should be noted is the the ALL keyword is not
+# supported.  There can be only one entry that matches a given
+# repository.
diff -urN /home/robin/sldeb/trunk/DllOpenJPEG.sln ./DllOpenJPEG.sln
--- /home/robin/sldeb/trunk/DllOpenJPEG.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./DllOpenJPEG.sln	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllOpenJPEG", "DllOpenJPEG.vcproj", "{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.ActiveCfg = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.Build.0 = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.ActiveCfg = Release|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/DllOpenJPEG.vcproj ./DllOpenJPEG.vcproj
--- /home/robin/sldeb/trunk/DllOpenJPEG.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./DllOpenJPEG.vcproj	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,670 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="DllOpenJPEG"
+	ProjectGUID="{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Release/OpenJPEG.dll"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/OpenJPEG.pdb"
+				LinkTimeCodeGeneration="0"
+				ImportLibrary=".\Release/OpenJPEG.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Release\OpenJPEG.dll dist&#x0D;&#x0A;copy Release\OpenJPEG.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Debug/OpenJPEGd.dll"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/OpenJPEGd.pdb"
+				ImportLibrary=".\Debug/OpenJPEGd.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Debug\OpenJPEGd.dll dist&#x0D;&#x0A;copy Debug\OpenJPEGd.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/doc/CMakeLists.txt ./doc/CMakeLists.txt
--- /home/robin/sldeb/trunk/doc/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,12 @@
+FIND_PACKAGE(Doxygen REQUIRED)
+
+# The Doxyfile.dox is poorly defined and produce output
+# in the source dir
+ADD_CUSTOM_TARGET(doxygen
+# By default doxygen target is added to the 'all' target. Project is small
+# thus running doxygen is not too time consuming
+  ALL
+  ${DOXYGEN}
+  ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.dox
+  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
+)
diff -urN /home/robin/sldeb/trunk/doc/Doxyfile.dox ./doc/Doxyfile.dox
--- /home/robin/sldeb/trunk/doc/Doxyfile.dox	2006-12-13 11:50:24.000000000 +0000
+++ ./doc/Doxyfile.dox	2007-09-28 11:33:49.000000000 +0100
@@ -190,7 +190,8 @@
 SEARCH_INCLUDES        = YES
 INCLUDE_PATH           = 
 INCLUDE_FILE_PATTERNS  = 
-PREDEFINED             = USE_JPWL
+PREDEFINED             = USE_JPWL \
+                         USE_JPSEC
 EXPAND_AS_DEFINED      = 
 SKIP_FUNCTION_MACROS   = YES
 #---------------------------------------------------------------------------
diff -urN /home/robin/sldeb/trunk/doc/.svn/all-wcprops ./doc/.svn/all-wcprops
--- /home/robin/sldeb/trunk/doc/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/all-wcprops	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,17 @@
+K 25
+svn:wc:ra_dav:version-url
+V 27
+/svn/!svn/ver/444/trunk/doc
+END
+Doxyfile.dox
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/432/trunk/doc/Doxyfile.dox
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/444/trunk/doc/CMakeLists.txt
+END
diff -urN /home/robin/sldeb/trunk/doc/.svn/entries ./doc/.svn/entries
--- /home/robin/sldeb/trunk/doc/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,54 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/doc
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T15:10:15.592485Z
+444
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+Doxyfile.dox
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+849c95bffe377cb4e4c9de583e440b95
+2007-09-03T13:30:59.661352Z
+432
+unipg
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+c11a292dac21c1d2565abbe6b2889187
+2007-09-06T15:10:15.592485Z
+444
+gdcm
+has-props
+
diff -urN /home/robin/sldeb/trunk/doc/.svn/format ./doc/.svn/format
--- /home/robin/sldeb/trunk/doc/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/format	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/doc/.svn/prop-base/CMakeLists.txt.svn-base ./doc/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/doc/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/doc/.svn/prop-base/Doxyfile.dox.svn-base ./doc/.svn/prop-base/Doxyfile.dox.svn-base
--- /home/robin/sldeb/trunk/doc/.svn/prop-base/Doxyfile.dox.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/prop-base/Doxyfile.dox.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/doc/.svn/text-base/CMakeLists.txt.svn-base ./doc/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/doc/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,12 @@
+FIND_PACKAGE(Doxygen REQUIRED)
+
+# The Doxyfile.dox is poorly defined and produce output
+# in the source dir
+ADD_CUSTOM_TARGET(doxygen
+# By default doxygen target is added to the 'all' target. Project is small
+# thus running doxygen is not too time consuming
+  ALL
+  ${DOXYGEN}
+  ${CMAKE_CURRENT_SOURCE_DIR}/Doxyfile.dox
+  WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR}
+)
diff -urN /home/robin/sldeb/trunk/doc/.svn/text-base/Doxyfile.dox.svn-base ./doc/.svn/text-base/Doxyfile.dox.svn-base
--- /home/robin/sldeb/trunk/doc/.svn/text-base/Doxyfile.dox.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./doc/.svn/text-base/Doxyfile.dox.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,234 @@
+# Doxyfile 1.4.2
+
+#---------------------------------------------------------------------------
+# Project related configuration options
+#---------------------------------------------------------------------------
+PROJECT_NAME           = OpenJPEG
+PROJECT_NUMBER         = 
+OUTPUT_DIRECTORY       = ../
+CREATE_SUBDIRS         = NO
+OUTPUT_LANGUAGE        = English
+USE_WINDOWS_ENCODING   = YES
+BRIEF_MEMBER_DESC      = YES
+REPEAT_BRIEF           = YES
+ABBREVIATE_BRIEF       = "The $name class" \
+                         "The $name widget" \
+                         "The $name file" \
+                         is \
+                         provides \
+                         specifies \
+                         contains \
+                         represents \
+                         a \
+                         an \
+                         the
+ALWAYS_DETAILED_SEC    = NO
+INLINE_INHERITED_MEMB  = NO
+FULL_PATH_NAMES        = NO
+STRIP_FROM_PATH        = C://
+STRIP_FROM_INC_PATH    = 
+SHORT_NAMES            = NO
+JAVADOC_AUTOBRIEF      = YES
+MULTILINE_CPP_IS_BRIEF = NO
+DETAILS_AT_TOP         = YES
+INHERIT_DOCS           = YES
+DISTRIBUTE_GROUP_DOC   = NO
+SEPARATE_MEMBER_PAGES  = NO
+TAB_SIZE               = 8
+ALIASES                = 
+OPTIMIZE_OUTPUT_FOR_C  = YES
+OPTIMIZE_OUTPUT_JAVA   = NO
+SUBGROUPING            = YES
+#---------------------------------------------------------------------------
+# Build related configuration options
+#---------------------------------------------------------------------------
+EXTRACT_ALL            = YES
+EXTRACT_PRIVATE        = YES
+EXTRACT_STATIC         = YES
+EXTRACT_LOCAL_CLASSES  = YES
+EXTRACT_LOCAL_METHODS  = NO
+HIDE_UNDOC_MEMBERS     = NO
+HIDE_UNDOC_CLASSES     = NO
+HIDE_FRIEND_COMPOUNDS  = NO
+HIDE_IN_BODY_DOCS      = NO
+INTERNAL_DOCS          = NO
+CASE_SENSE_NAMES       = NO
+HIDE_SCOPE_NAMES       = NO
+SHOW_INCLUDE_FILES     = YES
+INLINE_INFO            = YES
+SORT_MEMBER_DOCS       = YES
+SORT_BRIEF_DOCS        = NO
+SORT_BY_SCOPE_NAME     = NO
+GENERATE_TODOLIST      = YES
+GENERATE_TESTLIST      = YES
+GENERATE_BUGLIST       = YES
+GENERATE_DEPRECATEDLIST= YES
+ENABLED_SECTIONS       = 
+MAX_INITIALIZER_LINES  = 30
+SHOW_USED_FILES        = YES
+SHOW_DIRECTORIES       = NO
+FILE_VERSION_FILTER    = 
+#---------------------------------------------------------------------------
+# configuration options related to warning and progress messages
+#---------------------------------------------------------------------------
+QUIET                  = NO
+WARNINGS               = YES
+WARN_IF_UNDOCUMENTED   = YES
+WARN_IF_DOC_ERROR      = YES
+WARN_NO_PARAMDOC       = NO
+WARN_FORMAT            = "$file:$line: $text"
+WARN_LOGFILE           = 
+#---------------------------------------------------------------------------
+# configuration options related to the input files
+#---------------------------------------------------------------------------
+INPUT                  = ../libopenjpeg \
+						 ../jpwl
+FILE_PATTERNS          = *.h \
+                         *.c
+RECURSIVE              = NO
+EXCLUDE                = 
+EXCLUDE_SYMLINKS       = NO
+EXCLUDE_PATTERNS       = 
+EXAMPLE_PATH           = 
+EXAMPLE_PATTERNS       = *
+EXAMPLE_RECURSIVE      = NO
+IMAGE_PATH             = 
+INPUT_FILTER           = 
+FILTER_PATTERNS        = 
+FILTER_SOURCE_FILES    = NO
+#---------------------------------------------------------------------------
+# configuration options related to source browsing
+#---------------------------------------------------------------------------
+SOURCE_BROWSER         = NO
+INLINE_SOURCES         = NO
+STRIP_CODE_COMMENTS    = YES
+REFERENCED_BY_RELATION = YES
+REFERENCES_RELATION    = YES
+VERBATIM_HEADERS       = YES
+#---------------------------------------------------------------------------
+# configuration options related to the alphabetical class index
+#---------------------------------------------------------------------------
+ALPHABETICAL_INDEX     = NO
+COLS_IN_ALPHA_INDEX    = 5
+IGNORE_PREFIX          = 
+#---------------------------------------------------------------------------
+# configuration options related to the HTML output
+#---------------------------------------------------------------------------
+GENERATE_HTML          = YES
+HTML_OUTPUT            = ./html
+HTML_FILE_EXTENSION    = .html
+HTML_HEADER            = 
+HTML_FOOTER            = 
+HTML_STYLESHEET        = 
+HTML_ALIGN_MEMBERS     = YES
+GENERATE_HTMLHELP      = NO
+CHM_FILE               = 
+HHC_LOCATION           = 
+GENERATE_CHI           = NO
+BINARY_TOC             = NO
+TOC_EXPAND             = NO
+DISABLE_INDEX          = NO
+ENUM_VALUES_PER_LINE   = 4
+GENERATE_TREEVIEW      = NO
+TREEVIEW_WIDTH         = 250
+#---------------------------------------------------------------------------
+# configuration options related to the LaTeX output
+#---------------------------------------------------------------------------
+GENERATE_LATEX         = NO
+LATEX_OUTPUT           = latex
+LATEX_CMD_NAME         = latex
+MAKEINDEX_CMD_NAME     = makeindex
+COMPACT_LATEX          = NO
+PAPER_TYPE             = a4wide
+EXTRA_PACKAGES         = 
+LATEX_HEADER           = 
+PDF_HYPERLINKS         = NO
+USE_PDFLATEX           = NO
+LATEX_BATCHMODE        = NO
+LATEX_HIDE_INDICES     = NO
+#---------------------------------------------------------------------------
+# configuration options related to the RTF output
+#---------------------------------------------------------------------------
+GENERATE_RTF           = NO
+RTF_OUTPUT             = rtf
+COMPACT_RTF            = NO
+RTF_HYPERLINKS         = NO
+RTF_STYLESHEET_FILE    = 
+RTF_EXTENSIONS_FILE    = 
+#---------------------------------------------------------------------------
+# configuration options related to the man page output
+#---------------------------------------------------------------------------
+GENERATE_MAN           = NO
+MAN_OUTPUT             = man
+MAN_EXTENSION          = .3
+MAN_LINKS              = NO
+#---------------------------------------------------------------------------
+# configuration options related to the XML output
+#---------------------------------------------------------------------------
+GENERATE_XML           = NO
+XML_OUTPUT             = xml
+XML_SCHEMA             = 
+XML_DTD                = 
+XML_PROGRAMLISTING     = YES
+#---------------------------------------------------------------------------
+# configuration options for the AutoGen Definitions output
+#---------------------------------------------------------------------------
+GENERATE_AUTOGEN_DEF   = NO
+#---------------------------------------------------------------------------
+# configuration options related to the Perl module output
+#---------------------------------------------------------------------------
+GENERATE_PERLMOD       = NO
+PERLMOD_LATEX          = NO
+PERLMOD_PRETTY         = YES
+PERLMOD_MAKEVAR_PREFIX = 
+#---------------------------------------------------------------------------
+# Configuration options related to the preprocessor   
+#---------------------------------------------------------------------------
+ENABLE_PREPROCESSING   = YES
+MACRO_EXPANSION        = NO
+EXPAND_ONLY_PREDEF     = NO
+SEARCH_INCLUDES        = YES
+INCLUDE_PATH           = 
+INCLUDE_FILE_PATTERNS  = 
+PREDEFINED             = USE_JPWL \
+                         USE_JPSEC
+EXPAND_AS_DEFINED      = 
+SKIP_FUNCTION_MACROS   = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to external references   
+#---------------------------------------------------------------------------
+TAGFILES               = 
+GENERATE_TAGFILE       = 
+ALLEXTERNALS           = NO
+EXTERNAL_GROUPS        = YES
+PERL_PATH              = /usr/bin/perl
+#---------------------------------------------------------------------------
+# Configuration options related to the dot tool   
+#---------------------------------------------------------------------------
+CLASS_DIAGRAMS         = YES
+HIDE_UNDOC_RELATIONS   = YES
+HAVE_DOT               = NO
+CLASS_GRAPH            = YES
+COLLABORATION_GRAPH    = YES
+GROUP_GRAPHS           = YES
+UML_LOOK               = NO
+TEMPLATE_RELATIONS     = NO
+INCLUDE_GRAPH          = YES
+INCLUDED_BY_GRAPH      = YES
+CALL_GRAPH             = NO
+GRAPHICAL_HIERARCHY    = YES
+DIRECTORY_GRAPH        = YES
+DOT_IMAGE_FORMAT       = png
+DOT_PATH               = 
+DOTFILE_DIRS           = 
+MAX_DOT_GRAPH_WIDTH    = 1024
+MAX_DOT_GRAPH_HEIGHT   = 1024
+MAX_DOT_GRAPH_DEPTH    = 1000
+DOT_TRANSPARENT        = NO
+DOT_MULTI_TARGETS      = NO
+GENERATE_LEGEND        = YES
+DOT_CLEANUP            = YES
+#---------------------------------------------------------------------------
+# Configuration::additions related to the search engine   
+#---------------------------------------------------------------------------
+SEARCHENGINE           = NO
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/CMakeLists.txt ./indexer_JPIP/CMakeLists.txt
--- /home/robin/sldeb/trunk/indexer_JPIP/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/CMakeLists.txt	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,5 @@
+# index_create
+
+ADD_EXECUTABLE(index_create
+bio.c cio.c int.c pi.c t2.c tgt.c tcd.c index_create.c jpip.c jp2.c
+)
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/all-wcprops ./indexer_JPIP/.svn/all-wcprops
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/all-wcprops	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,149 @@
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/441/trunk/indexer_JPIP
+END
+tgt.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/tgt.c
+END
+int.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/int.h
+END
+jp2.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/jp2.h
+END
+jpip.c
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/28/trunk/indexer_JPIP/jpip.c
+END
+tgt.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/8/trunk/indexer_JPIP/tgt.h
+END
+jpip.h
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/15/trunk/indexer_JPIP/jpip.h
+END
+pi.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/16/trunk/indexer_JPIP/pi.c
+END
+bio.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/bio.c
+END
+tcd.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/tcd.c
+END
+cio.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/cio.c
+END
+pi.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/16/trunk/indexer_JPIP/pi.h
+END
+bio.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/bio.h
+END
+tcd.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/8/trunk/indexer_JPIP/tcd.h
+END
+cio.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/cio.h
+END
+t2.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/16/trunk/indexer_JPIP/t2.c
+END
+fix.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/8/trunk/indexer_JPIP/fix.c
+END
+int.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/int.c
+END
+index_create.c
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/66/trunk/indexer_JPIP/index_create.c
+END
+t2.h
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/8/trunk/indexer_JPIP/t2.h
+END
+jp2.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/16/trunk/indexer_JPIP/jp2.c
+END
+j2k.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/64/trunk/indexer_JPIP/j2k.h
+END
+fix.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/8/trunk/indexer_JPIP/fix.h
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/8/trunk/indexer_JPIP/Makefile
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/441/trunk/indexer_JPIP/CMakeLists.txt
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/entries ./indexer_JPIP/.svn/entries
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,340 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/indexer_JPIP
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T14:46:24.695057Z
+441
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+tgt.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+52d9a8def31acb19e256d255e466f55f
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+int.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+95743cfbf829d867dbfeb3aeca77c339
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+jp2.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+2f9dcfd7d957299761b18c6a8976e646
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+jpip.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+bdc7e1647175717a75ae363e582baf37
+2004-04-19T13:07:00.000000Z
+28
+yannick
+has-props
+
+tgt.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+e656af3aa38c54fbc641b6f59a373cd5
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+jpip.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+f73164fa30a18fbe614cc2be1bb03842
+2004-02-13T09:52:31.000000Z
+15
+yannick
+has-props
+
+pi.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+6467efce77c0722e482191b720ac4a5b
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+bio.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+411731d665898b91207bc1b1b5da05c7
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+cio.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+e4969985f35da7767634d37fa51c2cf1
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+tcd.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+1bcaaf36fad4f6c61f18fe20b43dbdbb
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+pi.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+a3d94cab5c2e32177891e89257c2d9c8
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+bio.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+ff7814d73b21d97984cd76c16f0119b6
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+cio.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+7c256af3c350356956800e7e908e2743
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+tcd.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+9a821b6b560b89c56b7c7f1b6286b8d6
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+t2.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+f002e07bd7392bacd9b10b6ffcb8f4fd
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+fix.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+60859a7e073e5dc8f6e2bd529ab7529c
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+int.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+4b2973c12d914f4d1ee292b9b312bac0
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+index_create.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+063e3d5fb58f453eec482d2d065bc13c
+2004-07-16T10:39:06.000000Z
+66
+descampe
+has-props
+
+t2.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+61b5ec07bb7be48ee405d6fe7903e7a7
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+jp2.c
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+eaf6d81ef9f8023e5619c60373e45929
+2004-02-13T09:54:31.000000Z
+16
+yannick
+has-props
+
+j2k.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+8524486b3a4db1ee3c2886dd4de83eb9
+2004-07-16T10:27:27.000000Z
+64
+descampe
+has-props
+
+fix.h
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+76b0db1d79d2951156bca60c90fe2e54
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+Makefile
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+fb0e0adad1c089d33f96af32dc33c6ef
+2003-11-27T14:55:16.000000Z
+8
+lugan
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:40.000000Z
+b1998e15e37e4035ac530923c7c17e69
+2007-09-06T14:46:24.695057Z
+441
+gdcm
+has-props
+
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/format ./indexer_JPIP/.svn/format
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/format	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/bio.c.svn-base ./indexer_JPIP/.svn/prop-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/bio.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/bio.h.svn-base ./indexer_JPIP/.svn/prop-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/bio.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/cio.c.svn-base ./indexer_JPIP/.svn/prop-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/cio.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/cio.h.svn-base ./indexer_JPIP/.svn/prop-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/cio.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/CMakeLists.txt.svn-base ./indexer_JPIP/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/fix.c.svn-base ./indexer_JPIP/.svn/prop-base/fix.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/fix.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/fix.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/fix.h.svn-base ./indexer_JPIP/.svn/prop-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/fix.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/index_create.c.svn-base ./indexer_JPIP/.svn/prop-base/index_create.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/index_create.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/index_create.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/int.c.svn-base ./indexer_JPIP/.svn/prop-base/int.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/int.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/int.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/int.h.svn-base ./indexer_JPIP/.svn/prop-base/int.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/int.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/j2k.h.svn-base ./indexer_JPIP/.svn/prop-base/j2k.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/j2k.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/j2k.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jp2.c.svn-base ./indexer_JPIP/.svn/prop-base/jp2.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jp2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/jp2.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jp2.h.svn-base ./indexer_JPIP/.svn/prop-base/jp2.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jp2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/jp2.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jpip.c.svn-base ./indexer_JPIP/.svn/prop-base/jpip.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jpip.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/jpip.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jpip.h.svn-base ./indexer_JPIP/.svn/prop-base/jpip.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/jpip.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/jpip.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/Makefile.svn-base ./indexer_JPIP/.svn/prop-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/Makefile.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/pi.c.svn-base ./indexer_JPIP/.svn/prop-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/pi.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/pi.h.svn-base ./indexer_JPIP/.svn/prop-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/pi.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/t2.c.svn-base ./indexer_JPIP/.svn/prop-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/t2.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/t2.h.svn-base ./indexer_JPIP/.svn/prop-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/t2.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tcd.c.svn-base ./indexer_JPIP/.svn/prop-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/tcd.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tcd.h.svn-base ./indexer_JPIP/.svn/prop-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/tcd.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tgt.c.svn-base ./indexer_JPIP/.svn/prop-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/tgt.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tgt.h.svn-base ./indexer_JPIP/.svn/prop-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/prop-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/prop-base/tgt.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/bio.c.svn-base ./indexer_JPIP/.svn/text-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/bio.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "bio.h"
+#include <setjmp.h>
+
+static unsigned char *bio_start, *bio_end, *bio_bp;
+static unsigned int bio_buf;
+static int bio_ct;
+
+extern jmp_buf j2k_error;
+
+/// <summary>
+/// Number of bytes written.
+/// </summary>
+int bio_numbytes() {
+    return bio_bp-bio_start;
+}
+
+/// <summary>
+/// Init decoder.
+/// </summary>
+/// <param name="bp">Input buffer</param>
+/// <param name="len">Input buffer length</param>
+void bio_init_dec(unsigned char *bp, int len) {
+    bio_start=bp;
+    bio_end=bp+len;
+    bio_bp=bp;
+    bio_buf=0;
+    bio_ct=0;
+}
+
+int bio_byteout()
+{
+	bio_buf = (bio_buf << 8) & 0xffff;
+	bio_ct = bio_buf == 0xff00 ? 7 : 8;
+	if (bio_bp >= bio_end)
+		return 1;
+	*bio_bp++ = bio_buf >> 8;
+	return 0;
+}
+
+/// <summary>
+/// Read byte. 
+/// </summary>
+int bio_bytein() {
+    bio_buf=(bio_buf<<8)&0xffff;
+    bio_ct=bio_buf==0xff00?7:8;
+    if (bio_bp>=bio_end) return 1; //longjmp(j2k_error, 1);
+    bio_buf|=*bio_bp++;
+    return 0;
+}
+
+/// <summary>
+/// Read bit.
+/// </summary>
+int bio_getbit() {
+    if (bio_ct==0) {
+        bio_bytein();
+    }
+    bio_ct--;
+    return (bio_buf>>bio_ct)&1;
+}
+
+/// <summary>
+/// Read bits.
+/// </summary>
+/// <param name="n">Number of bits to read</param>
+int bio_read(int n) {
+    int i, v;
+    v=0;
+    for (i=n-1; i>=0; i--) {
+        v+=bio_getbit()<<i;
+    }
+    return v;
+}
+
+/// <summary>
+/// Flush bits.
+/// </summary>
+int bio_flush() {
+    bio_ct=0;
+    bio_byteout();
+    if (bio_ct==7) {
+        bio_ct=0;
+       if ( bio_byteout()) return 1;;
+    }
+    return 0;
+}
+
+/// <summary>
+/// </summary>
+int bio_inalign() {
+    bio_ct=0;
+    if ((bio_buf&0xff)==0xff) {
+       if( bio_bytein()) return 1;
+        bio_ct=0;
+    }
+    return 0;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/bio.h.svn-base ./indexer_JPIP/.svn/text-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/bio.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,38 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __BIO_H
+#define __BIO_H
+
+int bio_numbytes();
+void bio_init_dec(unsigned char *bp, int len);
+int bio_read(int n);
+int bio_flush();
+int bio_inalign();
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/cio.c.svn-base ./indexer_JPIP/.svn/text-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/cio.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,129 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "cio.h"
+#include <setjmp.h>
+
+static unsigned char *cio_start, *cio_end, *cio_bp;
+
+extern jmp_buf j2k_error;
+
+/// <summary>
+/// Number of bytes written.
+/// </summary>
+int cio_numbytes() {
+    return cio_bp-cio_start;
+}
+
+/// <summary>
+/// Get position in byte stream.
+/// </summary>
+int cio_tell() {
+    return cio_bp-cio_start;
+}
+
+/// <summary>
+/// Set position in byte stream.
+/// </summary>
+void cio_seek(int pos) {
+    cio_bp=cio_start+pos;
+}
+
+/// <summary>
+/// Number of bytes left before the end of the stream.
+/// </summary>
+int cio_numbytesleft() {
+    return cio_end-cio_bp;
+}
+
+/// <summary>
+/// Get pointer to the current position in the stream.
+/// </summary>
+unsigned char *cio_getbp() {
+    return cio_bp;
+}
+
+/// <summary>
+/// Initialize byte IO.
+/// </summary>
+void cio_init(unsigned char *bp, int len) {
+    cio_start=bp;
+    cio_end=bp+len;
+    cio_bp=bp;
+}
+
+/// <summary>
+/// Write a byte.
+/// </summary>
+void cio_byteout(unsigned char v) {
+  if (cio_bp>=cio_end) longjmp(j2k_error, 1);
+  *cio_bp++=v;
+    
+}
+
+/// <summary>
+/// Read a byte.
+/// </summary>
+unsigned char cio_bytein() {
+    if (cio_bp>=cio_end) longjmp(j2k_error, 1);
+    return *cio_bp++;
+}
+
+/// <summary>
+/// Write a byte.
+/// </summary>
+//void cio_write(unsigned int v, int n) {
+void cio_write(long long v, int n) {
+    int i;
+    for (i=n-1; i>=0; i--) 
+      {
+	cio_byteout((unsigned char)((v>>(i<<3))&0xff));
+      }
+}
+
+/// <summary>
+/// Read some bytes.
+/// </summary>
+/* unsigned int cio_read(int n) { */
+long long cio_read(int n) {
+    int i;
+    /*unsigned int v;*/
+    long long v;
+    v=0;
+    for (i=n-1; i>=0; i--) {
+      v+=cio_bytein()<<(i<<3);
+    }
+    return v;
+}
+
+/// <summary>
+/// Write some bytes.
+/// </summary>
+void cio_skip(int n) {
+    cio_bp+=n;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/cio.h.svn-base ./indexer_JPIP/.svn/text-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/cio.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CIO_H
+#define __CIO_H
+
+int cio_tell();
+void cio_seek(int pos);
+int cio_numbytes();
+int cio_numbytesleft();
+unsigned char *cio_getbp();
+void cio_init(unsigned char *bp, int len);
+/* void cio_write(unsigned int v, int n); */
+void cio_write(long long v, int n);
+/* unsigned int cio_read(int n); */
+long long cio_read(int n);
+void cio_skip(int n);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/CMakeLists.txt.svn-base ./indexer_JPIP/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,5 @@
+# index_create
+
+ADD_EXECUTABLE(index_create
+bio.c cio.c int.c pi.c t2.c tgt.c tcd.c index_create.c jpip.c jp2.c
+)
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/fix.c.svn-base ./indexer_JPIP/.svn/text-base/fix.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/fix.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/fix.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "fix.h"
+
+#ifdef WIN32
+#define int64 __int64
+#else
+#define int64 long long
+#endif
+
+/// <summary>
+/// Multiply two fixed-precision rational numbers.
+/// </summary>
+int fix_mul(int a, int b) {
+    return (int)((int64)a*(int64)b>>13);
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/fix.h.svn-base ./indexer_JPIP/.svn/text-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/fix.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,34 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __FIX_H
+#define __FIX_H
+
+int fix_mul(int a, int b);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/index_create.c.svn-base ./indexer_JPIP/.svn/text-base/index_create.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/index_create.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/index_create.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,1218 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <setjmp.h>
+#include <math.h>
+
+#include "j2k.h"
+#include "cio.h"
+#include "tcd.h"
+#include "int.h"
+#include "jpip.h"
+#include "jp2.h"
+
+#define J2K_MS_SOC 0xff4f
+#define J2K_MS_SOT 0xff90
+#define J2K_MS_SOD 0xff93
+#define J2K_MS_EOC 0xffd9
+#define J2K_MS_SIZ 0xff51
+#define J2K_MS_COD 0xff52
+#define J2K_MS_COC 0xff53
+#define J2K_MS_RGN 0xff5e
+#define J2K_MS_QCD 0xff5c
+#define J2K_MS_QCC 0xff5d
+#define J2K_MS_POC 0xff5f
+#define J2K_MS_TLM 0xff55
+#define J2K_MS_PLM 0xff57
+#define J2K_MS_PLT 0xff58
+#define J2K_MS_PPM 0xff60
+#define J2K_MS_PPT 0xff61
+#define J2K_MS_SOP 0xff91
+#define J2K_MS_EPH 0xff92
+#define J2K_MS_CRG 0xff63
+#define J2K_MS_COM 0xff64
+
+#define J2K_STATE_MHSOC 0x0001
+#define J2K_STATE_MHSIZ 0x0002
+#define J2K_STATE_MH 0x0004
+#define J2K_STATE_TPHSOT 0x0008
+#define J2K_STATE_TPH 0x0010
+#define J2K_STATE_MT 0x0020
+
+#define START_NB 5
+#define INCREMENT 5
+
+jmp_buf j2k_error;
+
+static int j2k_state;
+static int j2k_curtileno;
+static j2k_tcp_t j2k_default_tcp;
+static unsigned char *j2k_eot;
+
+static j2k_image_t *j2k_img;
+static j2k_cp_t *j2k_cp;
+
+static unsigned char **j2k_tile_data;
+static int *j2k_tile_len;
+
+static info_image_t img;
+
+
+void j2k_clean() {
+  int tileno = 0;
+  int compno=0, resno=0, precno=0;
+
+  tcd_free(j2k_img, j2k_cp);
+  for (tileno = 0; tileno < j2k_cp->tw * j2k_cp->th; tileno++) {
+    info_tile_t *tile_Idx = &img.tile[tileno];
+    
+    for (compno = 0; compno < img.Comp; compno++)
+      {
+	info_compo_t *compo_Idx = &tile_Idx->compo[compno];
+	for(resno = 0; resno < img.Decomposition + 1; resno++)
+	  {
+	    info_reso_t *reso_Idx = &compo_Idx->reso[resno];
+	    for (precno = 0; precno < img.tile[tileno].pw * img.tile[tileno].ph; precno++)
+	      {
+		info_prec_t *prec_Idx = &reso_Idx->prec[precno];
+		free(prec_Idx->layer);
+	      }
+	    free(reso_Idx->prec);
+	  }
+	free(compo_Idx->reso);
+      }
+    free(tile_Idx->compo);
+    free(tile_Idx->marker);
+    free(tile_Idx->tile_parts);
+    free(tile_Idx->marker_mul.COC);
+    free(tile_Idx->marker_mul.RGN);
+    free(tile_Idx->marker_mul.QCC);
+    free(tile_Idx->marker_mul.PLT);
+    free(tile_Idx->marker_mul.PPT);
+    free(tile_Idx->marker_mul.COM);
+}
+  free(img.tile);
+  free(img.marker);
+  free(img.marker_mul.COC);
+  free(img.marker_mul.RGN);
+  free(img.marker_mul.QCC);
+  free(img.marker_mul.PLM);
+  free(img.marker_mul.PPM);
+  free(img.marker_mul.COM);
+}
+
+
+
+void j2k_read_soc() {
+  j2k_state=J2K_STATE_MHSIZ;
+}
+
+
+
+void j2k_read_siz() {
+    int len, i;
+    info_tile_t *tile;
+
+    len = cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    img.marker[img.num_marker].type = J2K_MS_SIZ;
+    img.marker[img.num_marker].start_pos = cio_tell()-2;
+    img.marker[img.num_marker].len = len;
+    img.num_marker++;
+    /* </INDEX> [MHIX BOX] */
+    
+    cio_read(2);                      /* Rsiz (capabilities) */
+    j2k_img->x1 = cio_read(4);        /* Xsiz                */
+    j2k_img->y1 = cio_read(4);        /* Ysiz                */
+    j2k_img->x0 = cio_read(4);        /* X0siz               */
+    j2k_img->y0 = cio_read(4);        /* Y0siz               */
+    j2k_cp->tdx = cio_read(4);        /* XTsiz               */
+    j2k_cp->tdy = cio_read(4);        /* YTsiz               */
+    j2k_cp->tx0 = cio_read(4);        /* XT0siz              */
+    j2k_cp->ty0 = cio_read(4);        /* YTOsiz              */
+
+    j2k_img->numcomps = cio_read(2);  /* Csiz                */
+    j2k_img->comps = (j2k_comp_t*)malloc(j2k_img->numcomps * sizeof(j2k_comp_t));
+    for (i = 0; i < j2k_img->numcomps; i++) {
+        int tmp, w, h;
+        tmp = cio_read(1);
+        j2k_img->comps[i].prec = (tmp & 0x7f) + 1;
+        j2k_img->comps[i].sgnd = tmp >> 7;
+        j2k_img->comps[i].dx = cio_read(1);
+        j2k_img->comps[i].dy = cio_read(1);
+        w = int_ceildiv(j2k_img->x1-j2k_img->x0, j2k_img->comps[i].dx);
+        h = int_ceildiv(j2k_img->y1-j2k_img->y0, j2k_img->comps[i].dy);
+        j2k_img->comps[i].data = (int*)malloc(sizeof(int) * w * h);
+    }
+    j2k_cp->tw = int_ceildiv(j2k_img->x1 - j2k_cp->tx0, j2k_cp->tdx);
+    j2k_cp->th = int_ceildiv(j2k_img->y1 - j2k_cp->ty0, j2k_cp->tdy);
+
+    j2k_cp->tcps = (j2k_tcp_t*)calloc((j2k_cp->tw * j2k_cp->th), sizeof(j2k_tcp_t));
+
+    for (i = 0; i < j2k_cp->tw * j2k_cp->th; i++)
+      {
+	j2k_cp->tcps[i].POC = 0;
+	j2k_cp->tcps[i].numpocs = 0;
+	// j2k_cp->tcps[i].first=1;
+      }
+
+    /* Initialization for PPM marker */
+    j2k_cp->ppm = 0;
+    j2k_cp->ppm_data = NULL;
+    j2k_cp->ppm_previous = 0;
+    j2k_cp->ppm_store = 0;
+
+    j2k_default_tcp.tccps = (j2k_tccp_t*)malloc(j2k_img->numcomps * sizeof(j2k_tccp_t));
+    for (i = 0; i < j2k_cp->tw * j2k_cp->th; i++) {
+	j2k_cp->tcps[i].tccps = (j2k_tccp_t*)malloc(j2k_img->numcomps * sizeof(j2k_tccp_t));
+    }
+    j2k_tile_data = (unsigned char**)calloc(j2k_cp->tw * j2k_cp->th, sizeof(char*));
+    j2k_tile_len = (int*)calloc(j2k_cp->tw * j2k_cp->th, sizeof(int));
+    j2k_state = J2K_STATE_MH;
+
+    /* <INDEX> */
+    img.Im_w = j2k_img->x1 - j2k_img->x0;
+    img.Im_h = j2k_img->y1 - j2k_img->y0;
+    img.Tile_x = j2k_cp->tdx;
+    img.Tile_y = j2k_cp->tdy;
+    img.Comp = j2k_img->numcomps;
+    img.tw = j2k_cp->tw;
+    img.th = j2k_cp->th;
+    img.tile = (info_tile_t*)malloc(img.tw * img.th * sizeof(info_tile_t));
+
+    for (i = 0; i < img.tw * img.th; i++)
+      {
+	tile = &img.tile[i];
+	tile->marker = (info_marker_t*)malloc(32 * sizeof(info_marker_t));
+	tile->num_marker = 0;
+	tile->marker_mul.num_COC = 0;
+	tile->marker_mul.CzCOC = START_NB;
+	tile->marker_mul.num_RGN = 0;
+	tile->marker_mul.CzRGN = START_NB;
+	tile->marker_mul.num_QCC = 0;
+	tile->marker_mul.CzQCC = START_NB;
+	tile->marker_mul.num_PLT = 0;
+	tile->marker_mul.CzPLT = START_NB;
+	tile->marker_mul.num_PPT = 0;
+	tile->marker_mul.CzPPT = START_NB;
+	tile->marker_mul.num_COM = 0;
+	tile->marker_mul.CzCOM = START_NB;
+      }
+    /* </INDEX> */
+
+
+ }
+
+void j2k_read_com() {
+    int len;
+    info_tile_t *tile;
+    info_marker_t *tmp;
+
+    len = cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    if (j2k_state == J2K_STATE_MH)
+      {
+	if (!img.marker_mul.num_COM) 
+	  img.marker_mul.COM = (info_marker_t*)malloc(img.marker_mul.CzCOM * sizeof(info_marker_t));
+	if (img.marker_mul.num_COM >= img.marker_mul.CzCOM)
+	  {
+	    tmp = (info_marker_t*)malloc(2 * img.marker_mul.CzCOM * sizeof(info_marker_t));
+	    memcpy(tmp,img.marker_mul.COM,img.marker_mul.CzCOM);
+	    img.marker_mul.CzCOM *= 2;
+	    free(img.marker_mul.COM);
+	    img.marker_mul.COM = tmp;
+	  }
+
+	img.marker_mul.COM[img.marker_mul.num_COM].type = J2K_MS_COM;
+	img.marker_mul.COM[img.marker_mul.num_COM].start_pos = cio_tell()-2;
+	img.marker_mul.COM[img.marker_mul.num_COM].len = len;
+	img.marker_mul.num_COM++;
+      } else
+	{
+	  tile = &img.tile[j2k_curtileno];
+	  if (!tile->marker_mul.num_COM)
+	    tile->marker_mul.COM = (info_marker_t*)calloc(START_NB, sizeof(info_marker_t));
+	  if (tile->marker_mul.num_COM >= tile->marker_mul.CzCOM)
+	    {
+	      tmp = (info_marker_t*)malloc(2 * tile->marker_mul.CzCOM * sizeof(info_marker_t));
+	      memcpy(tmp,tile->marker_mul.COM,tile->marker_mul.CzCOM);
+	      tile->marker_mul.CzCOM *= 2;
+	      free(tile->marker_mul.COM);
+	      tile->marker_mul.COM = tmp;
+	    }
+	  tile->marker_mul.COM[tile->marker_mul.num_COM].type = J2K_MS_COM;
+	  tile->marker_mul.COM[tile->marker_mul.num_COM].start_pos = cio_tell()-2;
+	  tile->marker_mul.COM[tile->marker_mul.num_COM].len = len;
+	  tile->marker_mul.num_COM++;
+	}
+    /* </INDEX> [MHIX BOX] */
+
+    cio_skip(len - 2);
+}
+
+
+
+
+void j2k_read_cox(int compno) {
+    int i;
+    j2k_tcp_t *tcp;
+    j2k_tccp_t *tccp;
+
+    tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+    tccp = &tcp->tccps[compno];
+    tccp->numresolutions = cio_read(1) + 1;
+
+    img.Decomposition = tccp->numresolutions - 1; /* <INDEX> */
+
+    tccp->cblkw = cio_read(1) + 2;
+    tccp->cblkh = cio_read(1) + 2;
+    tccp->cblksty = cio_read(1);
+    tccp->qmfbid = cio_read(1);
+    if (tccp->csty&J2K_CP_CSTY_PRT) {
+        for (i = 0; i < tccp->numresolutions; i++) {
+            int tmp = cio_read(1);
+            tccp->prcw[i] = tmp&0xf;
+            tccp->prch[i] = tmp>>4; 
+        }
+    }
+}
+
+
+
+
+void j2k_read_cod() {
+    int len, i, pos;
+    j2k_tcp_t *tcp;
+    info_tile_t *tile;
+
+    tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+    len = cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    if (j2k_state == J2K_STATE_MH)
+      {
+	img.marker[img.num_marker].type = J2K_MS_SIZ;
+	img.marker[img.num_marker].start_pos = cio_tell()-2;
+	img.marker[img.num_marker].len = len;
+	img.num_marker++;
+      }
+    else
+      {
+	tile = &img.tile[j2k_curtileno];
+	tile->marker[tile->num_marker].type = J2K_MS_SIZ;
+	tile->marker[tile->num_marker].start_pos = cio_tell()-2;
+	tile->marker[tile->num_marker].len = len;
+	tile->num_marker++;
+  }
+    /* </INDEX> [MHIX BOX] */
+    
+    tcp->csty = cio_read(1);
+    tcp->prg = cio_read(1);
+    tcp->numlayers = cio_read(2);
+    tcp->mct = cio_read(1);
+
+    pos = cio_tell();
+    for (i = 0; i < j2k_img->numcomps; i++) {
+        tcp->tccps[i].csty = tcp->csty&J2K_CP_CSTY_PRT;
+        cio_seek(pos);
+        j2k_read_cox(i);
+    }
+    
+    /* <INDEX> */
+    img.Prog = tcp->prg;
+    img.Layer = tcp->numlayers;
+    /* </INDEX> */
+}
+
+
+
+
+void j2k_read_coc() {
+    int len, compno;
+    j2k_tcp_t *tcp;
+    info_tile_t *tile;
+    info_marker_t *tmp;
+
+    tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+    len = cio_read(2);
+    
+    /* <INDEX> [MHIX BOX] */
+    if (j2k_state == J2K_STATE_MH)
+      {
+	if (!img.marker_mul.num_COC)
+	  img.marker_mul.COC = (info_marker_t*)malloc(img.marker_mul.CzCOC * sizeof(info_marker_t));
+	if (img.marker_mul.num_COC >= img.marker_mul.CzCOC)
+	  {
+	    tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzCOC) * sizeof(info_marker_t));
+	    memcpy(tmp,img.marker_mul.COC,img.marker_mul.CzCOC);
+	    img.marker_mul.CzCOC += INCREMENT;
+	    free(img.marker_mul.COC);
+	    img.marker_mul.COC = tmp;
+	  }
+	img.marker_mul.COC[img.marker_mul.num_COC].type = J2K_MS_COC;
+	img.marker_mul.COC[img.marker_mul.num_COC].start_pos = cio_tell()-2;
+	img.marker_mul.COC[img.marker_mul.num_COC].len = len;
+	img.marker_mul.num_COC++;
+      } else
+	{
+	  tile = &img.tile[j2k_curtileno];
+	  if (!tile->marker_mul.num_COC)
+	    tile->marker_mul.COC = (info_marker_t*)malloc(tile->marker_mul.CzCOC * sizeof(info_marker_t));
+	  if (tile->marker_mul.num_COC >= tile->marker_mul.CzCOC)
+	    {
+	      tmp = (info_marker_t*)malloc((INCREMENT + tile->marker_mul.CzCOC) * sizeof(info_marker_t));
+	      memcpy(tmp,tile->marker_mul.COC,tile->marker_mul.CzCOC);
+	      tile->marker_mul.CzCOC += INCREMENT;
+	      free(tile->marker_mul.COC);
+	      tile->marker_mul.COC = tmp;
+	    }
+	  tile->marker_mul.COC[tile->marker_mul.num_COC].type = J2K_MS_COC;
+	  tile->marker_mul.COC[tile->marker_mul.num_COC].start_pos = cio_tell() - 2;
+	  tile->marker_mul.COC[tile->marker_mul.num_COC].len = len;
+	  tile->marker_mul.num_COC++;
+	}
+    /* </INDEX> [MHIX BOX] */
+    
+    compno =cio_read(j2k_img->numcomps <= 256 ? 1 : 2);
+
+    tcp->tccps[compno].csty = cio_read(1);
+    j2k_read_cox(compno);
+}
+
+
+
+
+void j2k_read_qcx(int compno, int len) {
+    int tmp;
+    j2k_tcp_t *tcp;
+    j2k_tccp_t *tccp;
+    int bandno, numbands;
+
+    tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+    tccp = &tcp->tccps[compno];
+    tmp = cio_read(1);
+    tccp->qntsty = tmp & 0x1f;
+    tccp->numgbits = tmp >> 5;
+    numbands = tccp->qntsty == J2K_CCP_QNTSTY_SIQNT ? 1 : (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT ? len - 1 : (len - 1) / 2);
+    for (bandno = 0; bandno < numbands; bandno++) {
+        int expn, mant;
+        if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) { /* WHY STEPSIZES WHEN NOQNT ? */
+            expn = cio_read(1) >> 3;
+            mant = 0;
+        } else {
+            tmp = cio_read(2);
+            expn = tmp >> 11;
+            mant = tmp & 0x7ff;
+        }
+        tccp->stepsizes[bandno].expn = expn;
+        tccp->stepsizes[bandno].mant = mant;
+    }
+}
+
+
+
+
+void j2k_read_qcd() {
+    int len, i, pos;
+    info_tile_t *tile;
+
+    len = cio_read(2);    
+
+    /* <INDEX> [MHIX BOX] */
+    if (j2k_state == J2K_STATE_MH)
+      {
+	img.marker[img.num_marker].type = J2K_MS_QCD;
+	img.marker[img.num_marker].start_pos = cio_tell()-2;
+	img.marker[img.num_marker].len = len;
+	img.num_marker++;
+      }	 else
+	{
+	  tile = &img.tile[j2k_curtileno];
+	  tile->marker[tile->num_marker].type = J2K_MS_QCD;
+	  tile->marker[tile->num_marker].start_pos = cio_tell()-2;
+	  tile->marker[tile->num_marker].len = len;
+	  tile->num_marker++;
+	}
+    /* </INDEX> [MHIX BOX] */
+    
+    
+    pos=cio_tell();
+    for (i = 0; i < j2k_img->numcomps; i++) {
+        cio_seek(pos);
+        j2k_read_qcx(i, len - 2);
+    }
+}
+
+
+
+
+void j2k_read_qcc() {
+  int len, compno;
+  info_tile_t *tile;
+  info_marker_t *tmp;
+
+  len = cio_read(2);  
+  /* <INDEX> [MHIX BOX] */
+  if (j2k_state == J2K_STATE_MH)
+    {
+      if (!img.marker_mul.num_QCC)
+	img.marker_mul.QCC = (info_marker_t*)malloc(img.marker_mul.CzQCC * sizeof(info_marker_t));
+	if (img.marker_mul.num_QCC >= img.marker_mul.CzQCC)
+	  {
+	    tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzQCC) * sizeof(info_marker_t));
+	    memcpy(tmp,img.marker_mul.QCC,img.marker_mul.CzQCC);
+	    img.marker_mul.CzQCC += INCREMENT;
+	    free(img.marker_mul.QCC);
+	    img.marker_mul.QCC = tmp;
+	  }
+      img.marker_mul.QCC[img.marker_mul.num_QCC].type = J2K_MS_QCC;
+      img.marker_mul.QCC[img.marker_mul.num_QCC].start_pos = cio_tell() - 2;
+      img.marker_mul.QCC[img.marker_mul.num_QCC].len = len;
+      img.marker_mul.num_QCC++;
+    } else
+      {
+	tile = &img.tile[j2k_curtileno];
+	if (!tile->marker_mul.num_QCC)
+	  tile->marker_mul.QCC = (info_marker_t*)malloc(tile->marker_mul.CzQCC * sizeof(info_marker_t));
+	if (tile->marker_mul.num_QCC >= tile->marker_mul.CzQCC)
+	  {
+	    tmp = (info_marker_t*)malloc((INCREMENT + tile->marker_mul.CzQCC) * sizeof(info_marker_t));
+	    memcpy(tmp,tile->marker_mul.QCC,tile->marker_mul.CzQCC);
+	    tile->marker_mul.CzQCC += INCREMENT;
+	    free(tile->marker_mul.QCC);
+	    tile->marker_mul.QCC = tmp;
+	  }
+	tile->marker_mul.QCC[tile->marker_mul.num_QCC].type = J2K_MS_QCC;
+	tile->marker_mul.QCC[tile->marker_mul.num_QCC].start_pos = cio_tell()-2;
+	tile->marker_mul.QCC[tile->marker_mul.num_QCC].len = len;
+	tile->marker_mul.num_QCC++;
+      }
+  /* </INDEX> [MHIX BOX] */
+ 
+  compno = cio_read(j2k_img->numcomps <= 256 ? 1 : 2);
+  j2k_read_qcx(compno, len - 2 - (j2k_img->numcomps <= 256 ? 1 : 2));
+}
+
+
+
+
+void j2k_read_poc() {
+  int len, numpchgs, i, old_poc;
+  j2k_tcp_t *tcp;
+  j2k_tccp_t *tccp;
+  info_tile_t *tile;
+
+  tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+  old_poc = tcp->POC ? tcp->numpocs+1 : 0;
+  tcp->POC = 1;
+  tccp = &tcp->tccps[0];
+  len = cio_read(2);
+  
+  /* <INDEX> [MHIX BOX] */
+  if (j2k_state == J2K_STATE_MH)
+    {
+      img.marker[img.num_marker].type = J2K_MS_POC;
+      img.marker[img.num_marker].start_pos = cio_tell()-2;
+      img.marker[img.num_marker].len = len;
+      img.num_marker++;
+    } else
+      {
+	tile = &img.tile[j2k_curtileno];
+	tile->marker[tile->num_marker].type = J2K_MS_POC;
+	tile->marker[tile->num_marker].start_pos = cio_tell()-2;
+	tile->marker[tile->num_marker].len = len;
+	tile->num_marker++;
+      }
+  /* </INDEX> [MHIX BOX] */
+
+    numpchgs = (len - 2) / (5 + 2 * (j2k_img->numcomps <= 256 ? 1 : 2));
+    for (i = 0; i < numpchgs; i++) {
+      j2k_poc_t *poc;
+      poc = &tcp->pocs[i];
+      poc->resno0 = cio_read(1);
+      poc->compno0 = cio_read(j2k_img->numcomps <= 256 ? 1 : 2);
+      poc->layno1 = int_min(cio_read(2), tcp->numlayers);
+      poc->resno1 = int_min(cio_read(1), tccp->numresolutions);
+      poc->compno1 = int_min(cio_read(j2k_img->numcomps <= 256 ? 1 : 2), j2k_img->numcomps);
+      poc->prg = cio_read(1);
+    }
+
+    tcp->numpocs = numpchgs + old_poc - 1;
+}
+
+
+
+
+void j2k_read_crg() {
+    int len, i, Xcrg_i, Ycrg_i;
+
+    len = cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    img.marker[img.num_marker].type = J2K_MS_CRG;
+    img.marker[img.num_marker].start_pos = cio_tell()-2;
+    img.marker[img.num_marker].len = len;
+    img.num_marker++;
+    /* </INDEX> [MHIX BOX] */
+
+    for (i = 0; i < j2k_img->numcomps; i++)
+      {  
+	Xcrg_i = cio_read(2);
+	Ycrg_i = cio_read(2);
+      }
+}
+
+
+
+
+void j2k_read_tlm() {
+    int len, Ztlm, Stlm, ST, SP, tile_tlm, i;
+    long int Ttlm_i, Ptlm_i;
+    info_marker_t *tmp;
+
+    len = cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    if (!img.marker_mul.num_TLM)
+      img.marker_mul.TLM = (info_marker_t*)malloc(img.marker_mul.CzTLM * sizeof(info_marker_t));
+    if (img.marker_mul.num_TLM >= img.marker_mul.CzTLM)
+      {
+	tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzTLM) * sizeof(info_marker_t));
+	memcpy(tmp,img.marker_mul.TLM,img.marker_mul.CzTLM);
+	img.marker_mul.CzTLM += INCREMENT;
+	free(img.marker_mul.TLM);
+	img.marker_mul.TLM = tmp;
+      }
+    img.marker_mul.TLM[img.marker_mul.num_TLM].type = J2K_MS_TLM;
+    img.marker_mul.TLM[img.marker_mul.num_TLM].start_pos = cio_tell()-2;
+    img.marker_mul.TLM[img.marker_mul.num_TLM].len = len;
+    img.marker_mul.num_TLM++;
+    /* </INDEX> [MHIX BOX] */
+    
+    Ztlm = cio_read(1);
+    Stlm = cio_read(1);
+    ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);
+    SP = (Stlm >> 6) & 0x01;
+    tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
+    for (i = 0; i < tile_tlm; i++)
+      {
+	Ttlm_i = cio_read(ST);
+	Ptlm_i = cio_read(SP ? 4 : 2);
+      }
+}
+
+
+
+
+void j2k_read_plm() {
+    int len, i, Z_plm, N_plm, add, packet_len=0;
+    info_marker_t *tmp;
+
+    len=cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    if (!img.marker_mul.num_PLM)
+      img.marker_mul.PLM = (info_marker_t*)malloc(img.marker_mul.CzPLM * sizeof(info_marker_t));
+    if (img.marker_mul.num_PLM >= img.marker_mul.CzPLM)
+      {
+	tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzPLM) * sizeof(info_marker_t));
+	memcpy(tmp,img.marker_mul.PLM,img.marker_mul.CzPLM);
+	img.marker_mul.CzPLM += INCREMENT;
+	free(img.marker_mul.PLM);
+	img.marker_mul.PLM = tmp;
+      }
+    img.marker_mul.PLM[img.marker_mul.num_PLM].type = J2K_MS_PLM;
+    img.marker_mul.PLM[img.marker_mul.num_PLM].start_pos = cio_tell()-2;
+    img.marker_mul.PLM[img.marker_mul.num_PLM].len = len;
+    img.marker_mul.num_PLM++;
+    /* </INDEX> [MHIX BOX] */
+
+    Z_plm = cio_read(1);
+    len -= 3;
+    while (len > 0)
+      {
+	N_plm = cio_read(4);
+	len -= 4;
+	for (i = N_plm ; i > 0 ; i--)
+	  {
+	    add = cio_read(1);
+	    len--;
+	    packet_len = (packet_len << 7) + add;
+	    if ((add & 0x80) == 0)
+	      {
+		/* New packet */
+		packet_len = 0;
+	      }
+	    if (len <= 0) break;
+	  } 
+      }
+}
+
+
+
+
+void j2k_read_plt() {
+    int len, i, Zplt, packet_len=0, add;
+    info_tile_t *tile;
+    info_marker_t *tmp;
+;
+    len = cio_read(2);
+ 
+    /* <INDEX> [MHIX BOX] */
+    tile = &img.tile[j2k_curtileno];
+    if (!tile->marker_mul.num_PLT)
+      tile->marker_mul.PLT = (info_marker_t*)malloc(tile->marker_mul.CzPLT * sizeof(info_marker_t));
+    if (tile->marker_mul.num_PLT >= tile->marker_mul.CzPLT)
+      {
+	tmp = (info_marker_t*)malloc((INCREMENT + tile->marker_mul.CzPLT) * sizeof(info_marker_t));
+	memcpy(tmp,tile->marker_mul.PLT,tile->marker_mul.CzPLT);
+	tile->marker_mul.CzPLT += INCREMENT;
+	free(tile->marker_mul.PLT);
+	tile->marker_mul.PLT = tmp;
+      }
+
+    tile->marker_mul.PLT[tile->marker_mul.num_PLT].type = J2K_MS_PLT;
+    tile->marker_mul.PLT[tile->marker_mul.num_PLT].start_pos = cio_tell()-2;
+    tile->marker_mul.PLT[tile->marker_mul.num_PLT].len = len;
+    tile->marker_mul.num_PLT++;
+    /* </INDEX> [MHIX BOX] */
+    
+    Zplt = cio_read(1);
+    for (i = len-3; i > 0; i--)
+      {
+	add = cio_read(1);
+	packet_len = (packet_len << 7) + add;
+	if ((add & 0x80) == 0)
+	  {
+	    /* New packet */
+	    packet_len = 0;
+	  }
+      }
+}
+
+
+
+
+void j2k_read_ppm() {
+    int len, Z_ppm, i, j;
+    int N_ppm;
+    info_marker_t *tmp;
+
+    len = cio_read(2);
+    
+    /* <INDEX> [MHIX BOX] */
+    if (!img.marker_mul.num_PPM)
+      img.marker_mul.PPM = (info_marker_t*)malloc(img.marker_mul.CzPPM * sizeof(info_marker_t));
+    if (img.marker_mul.num_PPM >= img.marker_mul.CzPPM)
+      {
+	tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzPPM) * sizeof(info_marker_t));
+	memcpy(tmp,img.marker_mul.PPM,img.marker_mul.CzPPM);
+	img.marker_mul.CzPPM += INCREMENT;
+	free(img.marker_mul.PPM);
+	img.marker_mul.PPM = tmp;
+      }
+    img.marker_mul.PLM[img.marker_mul.num_PPM].type = J2K_MS_PPM;
+    img.marker_mul.PLM[img.marker_mul.num_PPM].start_pos = cio_tell()-2;
+    img.marker_mul.PLM[img.marker_mul.num_PPM].len = len;
+    img.marker_mul.num_PPM++;
+    /* </INDEX> [MHIX BOX] */
+    
+    j2k_cp->ppm = 1;
+    
+    Z_ppm = cio_read(1); /* Z_ppm */
+    len -= 3;
+    while (len > 0)
+      {
+	if (j2k_cp->ppm_previous == 0)
+	  {
+	    N_ppm = cio_read(4); /* N_ppm */
+	    len -= 4;
+	  } else
+	    {
+	      N_ppm = j2k_cp->ppm_previous;
+	    }
+	
+	j = j2k_cp->ppm_store;
+	if (Z_ppm == 0) /* First PPM marker */
+	  j2k_cp->ppm_data = (unsigned char*)calloc(N_ppm, sizeof(unsigned char));
+	else      /* NON-first PPM marker */
+	  j2k_cp->ppm_data = (unsigned char*)realloc(j2k_cp->ppm_data, (N_ppm + j2k_cp->ppm_store) * sizeof(unsigned char));
+	
+	for (i = N_ppm ; i > 0 ; i--) /* Read packet header */
+	  {
+	    j2k_cp->ppm_data[j] = cio_read(1);
+	    j++;
+	    len--;
+	    if (len == 0) break; /* Case of non-finished packet header in present marker but finished in next one */
+	  }
+	
+	j2k_cp->ppm_previous = i - 1;
+	j2k_cp->ppm_store = j;
+      }
+}
+
+
+
+
+void j2k_read_ppt() {
+    int len, Z_ppt, i, j = 0;
+    j2k_tcp_t *tcp;
+    info_tile_t *tile;
+    len=cio_read(2);
+
+    /* <INDEX> [MHIX BOX] */
+    tile = & img.tile[j2k_curtileno];
+    tile->marker[tile->num_marker].type = J2K_MS_PPT;
+    tile->marker[tile->num_marker].start_pos = cio_tell()-2;
+    tile->marker[tile->num_marker].len = len;
+    tile->num_marker++;
+    /* </INDEX> [MHIX BOX] */
+
+    Z_ppt = cio_read(1);
+    tcp = &j2k_cp->tcps[j2k_curtileno];
+    tcp->ppt = 1;
+    if (Z_ppt == 0) /* First PPT marker */
+      {
+	tcp->ppt_data = (unsigned char*)calloc(len - 3, sizeof(unsigned char));
+	tcp->ppt_store = 0;
+      }
+    else      /* NON-first PPT marker */
+      tcp->ppt_data = (unsigned char*)realloc(tcp->ppt_data, (len - 3 + tcp->ppt_store) * sizeof(unsigned char));
+    
+    j = tcp->ppt_store;
+    for (i = len - 3 ; i > 0 ; i--)
+      {
+	tcp->ppt_data[j] = cio_read(1);
+	j++;
+      }
+    tcp->ppt_store = j;
+}
+
+
+
+
+void j2k_read_sot() {
+    int len, tileno, totlen, partno, numparts, i;
+    j2k_tcp_t *tcp;
+    j2k_tccp_t *tmp;
+    info_tile_t *tile;
+    info_tile_part_t *tilepart_tmp;
+    
+ 
+    //fprintf(stderr,"SOT\n");
+    len = cio_read(2);
+    tileno = cio_read(2);
+    /* <INDEX> [MHIX BOX] */
+    tile = & img.tile[tileno];
+    tile->marker[tile->num_marker].type = J2K_MS_SOT;
+    tile->marker[tile->num_marker].start_pos = cio_tell() - 4;
+    tile->marker[tile->num_marker].len = len;
+    tile->num_marker++;
+    /* </INDEX> [MHIX BOX] */
+ 
+    totlen = cio_read(4);
+    if (!totlen) totlen = cio_numbytesleft() + 8;
+    partno = cio_read(1);
+    numparts = cio_read(1);
+
+    /* <INDEX> */
+    if (tileno == 0 && partno == 0 ) 
+      img.Main_head_end = cio_tell() - 7;  /* Correction End = First byte of first SOT */
+    
+    img.tile[tileno].num_tile = tileno;
+    /* </INDEX> */
+  
+    tile->numparts = partno + 1;                                               /* INDEX : Number of tile_parts for the tile */ 
+    img.num_max_tile_parts = int_max(tile->numparts, img.num_max_tile_parts);  /* INDEX : Maximum number of tile_part per tile */
+
+    if (partno == 0)
+    {
+      tile->tile_parts = (info_tile_part_t*)malloc(START_NB * sizeof(info_tile_part_t*));
+      tile->Cztile_parts = START_NB;
+    }
+    if (partno >= tile->Cztile_parts)
+      {
+	tilepart_tmp = (info_tile_part_t*)malloc((INCREMENT + tile->Cztile_parts) * sizeof(info_tile_part_t));
+	memcpy(tmp, tile->tile_parts, tile->Cztile_parts);
+	tile->Cztile_parts += INCREMENT;
+	free(tile->tile_parts);
+	tile->tile_parts = tilepart_tmp;
+      }
+
+    tile->tile_parts[partno].start_pos = cio_tell() - 12;        /* INDEX : start_pos of the tile_part       */
+    tile->tile_parts[partno].length = totlen;                    /* INDEX : length of the tile_part          */  
+    tile->tile_parts[partno].end_pos = totlen + cio_tell() - 12; /* INDEX : end position of the tile_part    */
+
+
+    j2k_curtileno = tileno;
+    j2k_eot = cio_getbp() - 12 + totlen;
+    j2k_state = J2K_STATE_TPH;
+    tcp = &j2k_cp->tcps[j2k_curtileno];
+    
+    tile->tile_parts[numparts].num_reso_AUX = tcp->tccps[0].numresolutions; /* INDEX : AUX value for TPIX       */
+
+     if (partno == 0)
+       //  if (tcp->first == 1) 
+      {
+	tmp = tcp->tccps;
+	*tcp = j2k_default_tcp;
+	/* Initialization PPT */
+	tcp->ppt = 0; 
+	tcp->ppt_data = NULL;
+	
+	tcp->tccps = tmp;
+	for (i = 0; i < j2k_img->numcomps; i++) {
+	  tcp->tccps[i] = j2k_default_tcp.tccps[i];
+	}
+	//j2k_cp->tcps[j2k_curtileno].first=0;
+      }
+}
+
+
+
+void j2k_read_rgn() {
+    int len, compno, roisty;
+    j2k_tcp_t *tcp;
+    info_tile_t *tile;
+    info_marker_t *tmp;
+    // fprintf(stderr,"RGN\n");
+    tcp = j2k_state == J2K_STATE_TPH ? &j2k_cp->tcps[j2k_curtileno] : &j2k_default_tcp;
+    len = cio_read(2);
+    
+    /* <INDEX> [MHIX BOX]*/
+    if (j2k_state == J2K_STATE_MH)
+      {
+	if (!img.marker_mul.num_RGN)
+	  img.marker_mul.RGN = (info_marker_t*)malloc(img.marker_mul.CzRGN * sizeof(info_marker_t));
+	if (img.marker_mul.num_RGN >= img.marker_mul.CzRGN)
+	  {
+	    tmp = (info_marker_t*)malloc((INCREMENT + img.marker_mul.CzRGN) * sizeof(info_marker_t));
+	    memcpy(tmp,img.marker_mul.RGN, img.marker_mul.CzRGN);
+	    img.marker_mul.CzRGN += INCREMENT;
+	    free(img.marker_mul.RGN);
+	    img.marker_mul.RGN = tmp;
+	  }
+	img.marker_mul.RGN[img.marker_mul.num_RGN].type = J2K_MS_RGN;
+	img.marker_mul.RGN[img.marker_mul.num_RGN].start_pos = cio_tell() - 2;
+	img.marker_mul.RGN[img.marker_mul.num_RGN].len = len;
+	img.marker_mul.num_RGN++;
+      } else
+      {
+	tile = &img.tile[j2k_curtileno];
+	if (!tile->marker_mul.num_RGN)
+	  tile->marker_mul.RGN = (info_marker_t*)malloc(tile->marker_mul.CzRGN * sizeof(info_marker_t));
+	if (tile->marker_mul.num_RGN >= tile->marker_mul.CzRGN)
+	  {
+	    tmp = (info_marker_t*)malloc((INCREMENT + tile->marker_mul.CzRGN) * sizeof(info_marker_t));
+	    memcpy(tmp,tile->marker_mul.RGN,tile->marker_mul.CzRGN);
+	    tile->marker_mul.CzRGN += INCREMENT;
+	    free(tile->marker_mul.RGN);
+	    tile->marker_mul.RGN = tmp;
+	  }
+
+	tile->marker_mul.RGN[tile->marker_mul.num_RGN].type = J2K_MS_RGN;
+	tile->marker_mul.RGN[tile->marker_mul.num_RGN].start_pos = cio_tell() - 2;
+        tile->marker_mul.RGN[tile->marker_mul.num_RGN].len = len;
+	tile->marker_mul.num_RGN++;
+      }
+    /* </INDEX> [MHIX BOX] */
+    
+    compno = cio_read(j2k_img->numcomps <= 256 ? 1 : 2);
+    roisty = cio_read(1);
+    tcp->tccps[compno].roishift = cio_read(1);
+}
+
+
+
+
+
+void j2k_read_sod() {
+    int len;
+    unsigned char *data;
+    info_tile_t *tile;
+    info_tile_part_t *tile_part;
+    // fprintf(stderr,"SOD\n");
+    /* <INDEX> [MHIX BOX] */
+    tile = &img.tile[j2k_curtileno];
+    tile->marker[tile->num_marker].type = J2K_MS_SOD;
+    tile->marker[tile->num_marker].start_pos = cio_tell();
+    tile->marker[tile->num_marker].len = 0;
+    tile->num_marker++;
+    /* </INDEX> [MHIX BOX] */
+
+    tile_part = &tile->tile_parts[tile->numparts - 1];                   /* INDEX : Current tilepart of a tile                  */
+    tile_part->length_header = cio_tell() - 1 - tile_part->start_pos;    /* INDEX : length of the tile-part header              */
+    tile_part->end_header = cio_tell() - 1;                              /* INDEX : end header position of the tile-part header */
+
+    len = int_min(j2k_eot - cio_getbp(), cio_numbytesleft());
+    
+    j2k_tile_len[j2k_curtileno] += len;
+    data = (unsigned char*)realloc(j2k_tile_data[j2k_curtileno], j2k_tile_len[j2k_curtileno]);   
+    memcpy(data, cio_getbp(), len);
+    j2k_tile_data[j2k_curtileno] = data;
+    cio_skip(len);
+    j2k_state = J2K_STATE_TPHSOT;
+}
+
+void j2k_read_eoc() {
+    int tileno;
+    tcd_init(j2k_img, j2k_cp, &img);
+    for (tileno = 0; tileno<j2k_cp->tw * j2k_cp->th; tileno++) {
+        tcd_decode_tile(j2k_tile_data[tileno], j2k_tile_len[tileno], tileno, &img);
+    }
+
+    j2k_state = J2K_STATE_MT;
+     longjmp(j2k_error, 1);
+}
+
+
+
+
+void j2k_read_unk() {
+    fprintf(stderr, "warning: unknown marker\n");
+}
+
+
+
+
+int j2k_index_JPIP(char *Idx_file, char *J2K_file, int len, int version){
+  FILE *dest;
+  char *index;
+  int pos_iptr, end_pos;
+  int len_cidx, pos_cidx;
+  int len_jp2c, pos_jp2c;
+  int len_fidx, pos_fidx;
+
+  dest=fopen(Idx_file, "wb");
+  if (!dest) {
+    fprintf(stderr, "Failed to open %s for reading !!\n", Idx_file);
+    return 0;
+  }
+
+  /* INDEX MODE JPIP */
+ index = (char*)malloc(len); 
+ cio_init(index, len);
+ jp2_write_jp();
+ jp2_write_ftyp();
+ 
+ jp2_write_jp2h(j2k_img);
+ jp2_write_dbtl(Idx_file);
+
+ pos_iptr=cio_tell();
+ cio_skip(24); /* IPTR further ! */
+ 
+ pos_jp2c = cio_tell();
+ len_jp2c = jp2_write_jp2c(J2K_file);
+
+ pos_cidx = cio_tell();
+ len_cidx = jpip_write_cidx(pos_jp2c + 8,img, j2k_cp, version); /* Correction len_jp2C --> pos_jp2c + 8 */  
+
+ 
+ pos_fidx = cio_tell();
+ len_fidx = jpip_write_fidx(pos_jp2c, len_jp2c, pos_cidx, len_cidx);
+
+end_pos = cio_tell();
+
+ cio_seek(pos_iptr);
+ jpip_write_iptr(pos_fidx,len_fidx);
+ cio_seek(end_pos);
+ 
+ fwrite(index, 1, cio_tell(), dest);
+ free(index);
+
+ fclose(dest);
+ return 1;
+}
+
+
+
+typedef struct {
+  int id;
+    int states;
+    void (*handler)();
+} j2k_dec_mstabent_t;
+
+j2k_dec_mstabent_t j2k_dec_mstab[]={
+    {J2K_MS_SOC, J2K_STATE_MHSOC, j2k_read_soc},
+    {J2K_MS_SOT, J2K_STATE_MH|J2K_STATE_TPHSOT, j2k_read_sot},
+    {J2K_MS_SOD, J2K_STATE_TPH, j2k_read_sod},
+    {J2K_MS_EOC, J2K_STATE_TPHSOT, j2k_read_eoc},
+    {J2K_MS_SIZ, J2K_STATE_MHSIZ, j2k_read_siz},
+    {J2K_MS_COD, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_cod},
+    {J2K_MS_COC, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_coc},
+    {J2K_MS_RGN, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_rgn},
+    {J2K_MS_QCD, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_qcd},
+    {J2K_MS_QCC, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_qcc},
+    {J2K_MS_POC, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_poc},
+    {J2K_MS_TLM, J2K_STATE_MH, j2k_read_tlm},
+    {J2K_MS_PLM, J2K_STATE_MH, j2k_read_plm},
+    {J2K_MS_PLT, J2K_STATE_TPH, j2k_read_plt},
+    {J2K_MS_PPM, J2K_STATE_MH, j2k_read_ppm},
+    {J2K_MS_PPT, J2K_STATE_TPH, j2k_read_ppt},
+    {J2K_MS_SOP, 0, 0},
+    {J2K_MS_CRG, J2K_STATE_MH, j2k_read_crg},
+    {J2K_MS_COM, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_com},
+    {0, J2K_STATE_MH|J2K_STATE_TPH, j2k_read_unk}
+};
+
+j2k_dec_mstabent_t *j2k_dec_mstab_lookup(int id) {
+  j2k_dec_mstabent_t *e;
+  for (e = j2k_dec_mstab; e->id != 0; e++) {
+    if (e->id == id) {
+      break;
+    }
+  }
+  return e;
+}
+
+int j2k_decode(unsigned char *src, int len, j2k_image_t **image, j2k_cp_t **cp) {
+    if (setjmp(j2k_error)) {
+        if (j2k_state != J2K_STATE_MT) {
+            fprintf(stderr, "WARNING: incomplete bitstream\n");
+            return 0;
+        }
+        return cio_numbytes();
+    }
+    j2k_img = (j2k_image_t*)calloc(1, sizeof(j2k_image_t));
+    j2k_cp = (j2k_cp_t*)calloc(1, sizeof(j2k_cp_t));
+    *image = j2k_img;
+    *cp = j2k_cp;
+    j2k_state = J2K_STATE_MHSOC;
+    cio_init(src, len);
+    for (;;) {
+        j2k_dec_mstabent_t *e;
+        int id = cio_read(2);
+        if (id >> 8 != 0xff) {
+            fprintf(stderr, "%.8x: expected a marker instead of %x\n", cio_tell() - 2, id);
+            return 0;
+        }
+        e = j2k_dec_mstab_lookup(id);
+        if (!(j2k_state & e->states)) {
+            fprintf(stderr, "%.8x: unexpected marker %x\n", cio_tell() - 2, id);
+            return 0;
+        }
+        if (e->handler) {
+            (*e->handler)();
+        }
+    }
+
+}
+
+
+#ifdef WIN32
+#include <windows.h>
+
+BOOL APIENTRY DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
+    switch (ul_reason_for_call) {
+		case DLL_PROCESS_ATTACH:
+		case DLL_THREAD_ATTACH:
+		case DLL_THREAD_DETACH:
+		case DLL_PROCESS_DETACH:
+			break;
+    }
+    return TRUE;
+}
+#endif
+
+int main(int argc, char **argv)
+{  
+  FILE *src;
+  int totlen;
+  char *j2kfile;
+  j2k_image_t *imgg;
+  j2k_cp_t *cp;
+  int version;
+
+  if (argc != 4)
+    {
+      fprintf(stderr,"\nUSAGE : ./index_create J2K-file JP2-file version\n\nVersion : 0, 1, 2 or 3\n  0 : [faix] 4-byte and no AUX fields\n  1 : [faix] 8-byte and no AUX fields\n  2 : [faix] 4-byte and AUX fields\n  3 : [faix] 8-byte and AUX fields\n\nReference Document : annex I from JPIP-FCD-version 2 (SC 29 N5727)\n\n");
+      return 1;
+    }
+
+  src=fopen(argv[1], "rb");
+  if (!src) {
+    fprintf(stderr, "Failed to open %s for reading !!\n", argv[1]);
+    return 1;
+  }
+
+  /* length of the codestream */
+  fseek(src, 0, SEEK_END);
+  totlen = ftell(src);
+  fseek(src, 0, SEEK_SET);
+  
+  j2kfile = (char*)malloc(totlen);
+  fread(j2kfile, 1, totlen, src);
+  fclose(src);
+
+  img.marker = (info_marker_t*)malloc(32 * sizeof(info_marker_t));
+  img.num_marker = 0;
+  img.num_max_tile_parts = 0;
+  img.marker_mul.num_COC = 0;
+  img.marker_mul.CzCOC = START_NB;
+  img.marker_mul.num_RGN = 0;
+  img.marker_mul.CzRGN = START_NB;
+  img.marker_mul.num_QCC = 0;
+  img.marker_mul.CzQCC = START_NB;
+  img.marker_mul.num_TLM = 0;
+  img.marker_mul.CzTLM = START_NB;
+  img.marker_mul.num_PLM = 0;
+  img.marker_mul.CzPLM = START_NB;
+  img.marker_mul.num_PPM = 0;
+  img.marker_mul.CzPPM = START_NB;
+  img.marker_mul.num_COM = 0;
+  img.marker_mul.CzCOM = START_NB;
+
+  /* decode */ 
+
+  if (!j2k_decode(j2kfile, totlen, &imgg, &cp)) {
+    fprintf(stderr, "Index_creator: failed to decode image!\n");
+    return 1;
+  }
+  free(j2kfile);
+  
+  // fseek(src, 0, SEEK_SET);
+  img.codestream_size = totlen;
+  sscanf(argv[3], "%d", &version);
+  if (version > 3)
+    {
+      fprintf(stderr,"Error : value of version unauthorized !!  Value accepted : 0, 1, 2 or 3 !!\n");
+      return 0;
+    }
+
+  j2k_index_JPIP(argv[2], argv[1], totlen * 2 > 60000 ? totlen * 2 : 60000, version);
+  
+  j2k_clean();
+  return 0;
+}
+ 
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/int.c.svn-base ./indexer_JPIP/.svn/text-base/int.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/int.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/int.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/// <summary>
+/// Get the minimum of two integers.
+/// </summary>
+int int_min(int a, int b) {
+    return a<b?a:b;
+}
+
+/// <summary>
+/// Get the maximum of two integers.
+/// </summary>
+int int_max(int a, int b) {
+    return a>b?a:b;
+}
+
+/// <summary>
+/// Clamp an integer inside an interval.
+/// </summary>
+int int_clamp(int a, int min, int max) {
+    if (a<min) return min;
+    if (a>max) return max;
+    return a;
+}
+
+/// <summary>
+/// Get absolute value of integer.
+/// </summary>
+int int_abs(int a) {
+    return a<0?-a:a;
+}
+
+/// <summary>
+/// Divide an integer and round upwards.
+/// </summary>
+int int_ceildiv(int a, int b) {
+    return (a+b-1)/b;
+}
+
+/// <summary>
+/// Divide an integer by a power of 2 and round upwards.
+/// </summary>
+int int_ceildivpow2(int a, int b) {
+    return (a+(1<<b)-1)>>b;
+}
+
+/// <summary>
+/// Divide an integer by a power of 2 and round downwards.
+/// </summary>
+int int_floordivpow2(int a, int b) {
+    return a>>b;
+}
+
+/// <summary>
+/// Get logarithm of an integer and round downwards.
+/// </summary>
+int int_floorlog2(int a) {
+    int l;
+    for (l=0; a>1; l++) {
+        a>>=1;
+    }
+    return l;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/int.h.svn-base ./indexer_JPIP/.svn/text-base/int.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/int.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,41 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __INT_H
+#define __INT_H
+
+int int_min(int a, int b);
+int int_max(int a, int b);
+int int_clamp(int a, int min, int max);
+int int_abs(int a);
+int int_ceildiv(int a, int b);
+int int_ceildivpow2(int a, int b);
+int int_floordivpow2(int a, int b);
+int int_floorlog2(int a);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/j2k.h.svn-base ./indexer_JPIP/.svn/text-base/j2k.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/j2k.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/j2k.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,288 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved. 
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#define VERSION "0.0.8"
+
+#ifdef WIN32
+#ifdef LIBJ2K_EXPORTS
+#define LIBJ2K_API __declspec(dllexport)
+#else
+#define LIBJ2K_API __declspec(dllimport)
+#endif
+#else
+#define LIBJ2K_API
+#endif
+
+#ifndef __J2K_H
+#define __J2K_H
+
+#define J2K_MAXRLVLS 33
+#define J2K_MAXBANDS (3*J2K_MAXRLVLS+1)
+
+#define J2K_CP_CSTY_PRT 0x01
+#define J2K_CP_CSTY_SOP 0x02
+#define J2K_CP_CSTY_EPH 0x04
+#define J2K_CCP_CSTY_PRT 0x01
+#define J2K_CCP_CBLKSTY_LAZY 0x01
+#define J2K_CCP_CBLKSTY_RESET 0x02
+#define J2K_CCP_CBLKSTY_TERMALL 0x04
+#define J2K_CCP_CBLKSTY_VSC 0x08
+#define J2K_CCP_CBLKSTY_PTERM 0x10
+#define J2K_CCP_CBLKSTY_SEGSYM 0x20
+#define J2K_CCP_QNTSTY_NOQNT 0
+#define J2K_CCP_QNTSTY_SIQNT 1
+#define J2K_CCP_QNTSTY_SEQNT 2
+
+typedef struct 
+{
+  int dx, dy;   /* XRsiz, YRsiz            */
+  int prec;     /* precision               */
+  int bpp;      /* deapth of image in bits */
+  int sgnd;     /* signed                  */
+  int *data;    /* image-component data    */
+} j2k_comp_t;
+
+typedef struct {
+  int version;
+  int x0, y0;          /* XOsiz, YOsiz              */
+  int x1, y1;          /* Xsiz, Ysiz                */ 
+  int numcomps;        /* number of components      */
+  int index_on;        /* 0 = no index || 1 = index */
+  j2k_comp_t *comps;   /* image-components          */
+} j2k_image_t;
+
+typedef struct {
+  int expn;     /* exponent */
+  int mant;     /* mantissa */
+} j2k_stepsize_t;
+
+typedef struct {
+  int csty;                                /* coding style                          */
+  int numresolutions;                      /* number of resolutions                 */
+  int cblkw;                               /* width of code-blocks                  */
+  int cblkh;                               /* height of code-blocks                 */
+  int cblksty;                             /* code-block coding style               */
+  int qmfbid;                              /* discrete wavelet transform identifier */
+  int qntsty;                              /* quantisation style                    */
+  j2k_stepsize_t stepsizes[J2K_MAXBANDS];  /* stepsizes used for quantisation       */
+  int numgbits;                            /* number of guard bits                  */
+  int roishift;                            /* Region of Interest shift              */
+  int prcw[J2K_MAXRLVLS];                  /* Precinct width                        */
+  int prch[J2K_MAXRLVLS];                  /* Precinct height                       */
+} j2k_tccp_t;
+
+typedef struct {
+    int resno0, compno0; 
+    int layno1, resno1, compno1;
+    int prg;
+    int tile;
+    char progorder[4];
+} j2k_poc_t;
+
+typedef struct {
+  int csty;                  /* coding style                                                            */  
+  int prg;                   /* progression order                                                       */
+  int numlayers;             /* number of layers                                                        */
+  int mct;                   /* multi-component transform identifier                                    */
+  int rates[100];            /* rates of layers                                                         */
+  int numpocs;               /* number of progression order changes                                     */
+  int POC;                   /* Precise if a POC marker has been used O:NO, 1:YES                       */
+  j2k_poc_t pocs[32];        /* progression order changes                                               */
+  unsigned char *ppt_data;   /* packet header store there for futur use in t2_decode_packet             */
+  int ppt;                   /* If ppt == 1 --> there was a PPT marker for the present tile             */
+  int ppt_store;             /* Use in case of multiple marker PPT (number of info already store)       */
+  j2k_tccp_t *tccps;         /* tile-component coding parameters                                        */
+} j2k_tcp_t;
+
+typedef struct {
+  int tx0, ty0;              /* XTOsiz, YTOsiz                                                          */
+  int tdx, tdy;              /* XTsiz, YTsiz                                                            */
+  int tw, th;
+  unsigned char *ppm_data;   /* packet header store there for futur use in t2_decode_packet             */
+  int ppm;                   /* If ppm == 1 --> there was a PPM marker for the present tile             */
+  int ppm_store;             /* Use in case of multiple marker PPM (number of info already store)       */
+  int ppm_previous;          /* Use in case of multiple marker PPM (case on non-finished previous info) */
+  j2k_tcp_t *tcps;           /* tile coding parameters                                                  */
+} j2k_cp_t;
+
+
+
+
+
+/* Packet information : Layer level */
+typedef struct {  
+  int len;               /* Length of the body of the packet   */
+  int len_header;        /* Length of the header of the packet */
+  int offset;            /* Offset of the body of the packet   */
+  int offset_header;     /* Offset of the header of the packet */
+} info_layer_t;
+
+
+/* Access to packet information : precinct level */
+typedef struct {  
+  info_layer_t *layer;
+} info_prec_t;
+
+
+/* Access to packet information : resolution level */
+typedef struct {  
+  info_prec_t *prec;
+} info_reso_t;
+
+
+/* Access to packet information : component level */
+typedef struct {  
+  info_reso_t *reso;
+} info_compo_t;
+
+
+/* Information about the marker */
+typedef struct {
+  int type;       /* type of marker [SIZ, QCD, POC, PPM, CRG, COD] appearing only once */
+  int start_pos;  /* Start position of the marker                                      */
+  int len;        /* Length of the marker                                              */
+} info_marker_t;
+
+
+/* Multiple marker in tile header */
+typedef struct{
+  info_marker_t *COC;    /* COC markers                    */
+  int num_COC;           /* Number of COC marker           */
+  int CzCOC;             /* Current size of the vector COC */
+  
+  info_marker_t *RGN;    /* RGN markers                    */
+  int num_RGN;           /* Number of RGN marker           */
+  int CzRGN;             /* Current size of the vector RGN */
+  
+  info_marker_t *QCC;    /* QCC markers                    */
+  int num_QCC;           /* Number of QCC marker           */
+  int CzQCC;             /* Current size of the vector QCC */
+  
+  info_marker_t *PLT;    /* PLT markers                    */
+  int num_PLT;           /* Number of PLT marker           */
+  int CzPLT;             /* Current size of the vector PLT */
+  
+  info_marker_t *PPT;    /* PPT markers                    */
+  int num_PPT;           /* Number of PPT marker           */
+  int CzPPT;             /* Current size of the vector PPT */
+  
+  info_marker_t *COM;    /* COM markers                    */
+  int num_COM;           /* Number of COM marker           */
+  int CzCOM;             /* Current size of the vector COC */
+} info_marker_mul_tile_t; 
+
+
+/* Information about each tile_part for a particulary tile */
+typedef struct{
+  int start_pos;                      /* Start position of the tile_part       */ 
+  int length;                         /* Length of the tile_part header + body */
+  int length_header;                  /* Length of the header                  */
+  int end_pos;                        /* End position of the tile part         */
+  int end_header;                     /* End position of the tile part header  */
+
+  int num_reso_AUX;                   /* Number of resolution level completed  */
+} info_tile_part_t;
+
+
+/* Information about each tile */
+typedef struct {
+  int num_tile;                       /* Number of Tile                                                    */
+  int pw, ph;                         /* number of precinct by tile                                        */
+  int num_packet;                     /* number of packet in the tile                                      */
+  info_compo_t *compo;                /* component [packet]                                                */
+  
+  info_marker_t *marker;              /* information concerning markers inside image [only one apparition] */
+  info_marker_mul_tile_t marker_mul;  /* information concerning markers inside image [multiple apparition] */ 
+  int num_marker;                     /* number of marker                                                  */
+  
+  int numparts;                       /* number of tile_part for this tile                                 */
+  info_tile_part_t *tile_parts;       /* Information about each tile_part                                  */
+  int Cztile_parts;                   /* Current size of the tile_parts vector                             */
+} info_tile_t;                        /* index struct                                                      */
+
+
+/* Multiple marker in main header */
+typedef struct{
+  info_marker_t *COC;    /* COC markers                    */
+  int num_COC;           /* Number of COC marker           */
+  int CzCOC;             /* Current size of the vector COC */
+ 
+  info_marker_t *RGN;    /* RGN markers                    */
+  int num_RGN;           /* Number of RGN marker           */
+  int CzRGN;             /* Current size of the vector RGN */
+  
+  info_marker_t *QCC;    /* QCC markers                    */
+  int num_QCC;           /* Number of QCC marker           */
+  int CzQCC;             /* Current size of the vector QCC */
+  
+  info_marker_t *TLM;    /* TLM markers                    */
+  int num_TLM;           /* Number of TLM marker           */
+  int CzTLM;             /* Current size of the vector TLM */
+  
+  info_marker_t *PLM;    /* PLM markers                    */
+  int num_PLM;           /* Number of PLM marker           */
+  int CzPLM;             /* Current size of the vector PLM */
+  
+  info_marker_t *PPM;    /* PPM markers                    */
+  int num_PPM;           /* Number of PPM marker           */
+  int CzPPM;             /* Current size of the vector PPM */
+  
+  info_marker_t *COM;    /* COM markers                    */
+  int num_COM;           /* Number of COM marker           */
+  int CzCOM;             /* Current size of the vector COM */
+} info_marker_mul_t; /* index struct */
+
+
+/* Information about image */
+typedef struct {
+  int Im_w, Im_h;                /* Image width and Height                                            */
+  int Tile_x, Tile_y;            /* Number of Tile in X and Y                                         */
+  int tw, th;
+  int pw, ph;                    /* nombre precinct in X and Y                                        */
+  int pdx, pdy;                  /* size of precinct in X and Y                                       */
+
+  int Prog;                      /* progression order                                                 */
+  int Comp;                      /* Component numbers                                                 */
+  int Layer;                     /* number of layer                                                   */
+  int Decomposition;             /* number of decomposition                                           */
+
+  int Main_head_end;             /* Main header position                                              */
+  int codestream_size;           /* codestream's size                                                 */
+
+  info_marker_t *marker;         /* information concerning markers inside image [only one apparition] */
+  info_marker_mul_t marker_mul;  /* information concerning markers inside image [multiple apparition] */ 
+  int num_marker;                /* number of marker                                                  */
+
+  int num_packet_max;            /* Maximum number of packet                                          */
+
+  int num_max_tile_parts;        /* Maximum number of tile-part                                       */
+  info_tile_t *tile;             /* information concerning tiles inside image                         */
+} info_image_t; /* index struct */
+
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jp2.c.svn-base ./indexer_JPIP/.svn/text-base/jp2.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jp2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/jp2.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,301 @@
+/*
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "j2k.h"
+#include "cio.h"
+#include "tcd.h"
+#include "int.h"
+
+#define JPIP_JPIP 0x6a706970
+
+#define JP2_JP   0x6a502020
+#define JP2_FTYP 0x66747970
+#define JP2_JP2H 0x6a703268
+#define JP2_IHDR 0x69686472
+#define JP2_COLR 0x636f6c72
+#define JP2_JP2C 0x6a703263
+#define JP2_URL  0x75726c20
+#define JP2_DBTL 0x6474626c
+#define JP2_BPCC 0x62706363
+#define JP2      0x6a703220
+
+
+void jp2_write_url(char *Idx_file)
+{
+  int len, lenp, i;
+  char str[256];
+
+  sprintf(str, "%s", Idx_file);
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_URL, 4);  // DBTL
+  cio_write(0,1);          // VERS
+  cio_write(0,3);          // FLAG
+
+  for (i=0; i<strlen(str); i++) {
+        cio_write(str[i], 1);
+    }
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+}
+
+void jp2_write_dbtl(char *Idx_file)
+{
+  int len, lenp;
+
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_DBTL, 4);  // DBTL
+  cio_write(1,2);           // NDR : Only 1
+  
+  jp2_write_url(Idx_file); // URL Box
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+}
+
+int jp2_write_ihdr(j2k_image_t *j2k_img)
+{
+  int len, lenp,i; 
+  int depth_0,depth, sign, BPC_ok=1;
+
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_IHDR, 4);  // IHDR
+
+  cio_write(j2k_img->y1-j2k_img->x0,4);   // HEIGHT
+  cio_write(j2k_img->x1-j2k_img->x0,4);   // WIDTH
+  cio_write(j2k_img->numcomps,2);   // NC
+
+  depth_0=j2k_img->comps[0].prec-1;
+  sign=j2k_img->comps[0].sgnd;
+
+  for(i=1;i<j2k_img->numcomps;i++)
+    {
+      depth=j2k_img->comps[i].prec-1;
+      sign=j2k_img->comps[i].sgnd;
+      if(depth_0!=depth) BPC_ok=0;
+    }
+  
+  if (BPC_ok)
+    cio_write(depth_0+(sign<<7),1);
+  else
+    cio_write(255,1);
+
+  cio_write(7,1);          // C : Always 7
+  cio_write(1,1);          // UnkC, colorspace unknow
+  cio_write(0,1);          // IPR, no intellectual property
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+
+  return BPC_ok;
+}
+
+void jp2_write_bpcc(j2k_image_t *j2k_img)
+{
+  int len, lenp, i;
+  
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_BPCC, 4);  // BPCC
+  
+  for(i=0;i<j2k_img->numcomps;i++)
+    cio_write(j2k_img->comps[i].prec-1+(j2k_img->comps[i].sgnd<<7),1);
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+}
+
+void jp2_write_colr(int BPC_ok, j2k_image_t *j2k_img)
+{
+  int len, lenp, meth;
+  
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_COLR, 4);  // COLR
+
+  if ((j2k_img->numcomps==1 || j2k_img->numcomps==3) && (BPC_ok && j2k_img->comps[0].prec==8))
+    meth=1;
+  else
+    meth=2;
+
+  cio_write(meth,1);       // METH
+  cio_write(0,1);          // PREC
+  cio_write(0,1);          // APPROX
+  
+  if (meth==1)
+    cio_write(j2k_img->numcomps>1?16:17,4);          // EnumCS
+
+  if (meth==2)
+    cio_write(0,1);        // PROFILE (??) 
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+}
+
+/*
+ * Write the JP2H box
+ *
+ * JP2 Header box
+ *
+ */
+void jp2_write_jp2h(j2k_image_t *j2k_img)
+{
+  int len, lenp, BPC_ok;
+  
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_JP2H, 4);           /* JP2H */
+
+  BPC_ok=jp2_write_ihdr(j2k_img);
+
+  if (!BPC_ok)
+    jp2_write_bpcc(j2k_img);
+  jp2_write_colr(BPC_ok, j2k_img);
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         /* L */
+  cio_seek(lenp+len);
+}
+
+/*
+ * Write the FTYP box
+ *
+ * File type box
+ *
+ */
+void jp2_write_ftyp()
+{
+  int len, lenp;
+  
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_FTYP, 4);   /* FTYP       */
+
+  cio_write(JP2,4);         /* BR         */
+  cio_write(0,4);           /* MinV       */
+  cio_write(JP2,4);         /* CL0 : JP2  */
+  cio_write(JPIP_JPIP,4);   /* CL1 : JPIP */
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         /* L          */
+  cio_seek(lenp+len);
+}
+
+/*
+ * Read the FTYP box
+ *
+ * File type box
+ *
+ */
+void jp2_read_ftyp(int length)
+{
+  int BR, MinV, type, i;
+
+  BR = cio_read(4);         /* BR              */
+  MinV = cio_read(4);       /* MinV            */
+  length-=8;
+  
+  for (i=length/4;i>0;i--)
+    type = cio_read(4);     /* CLi : JP2, JPIP */
+}
+
+int jp2_write_jp2c(char *J2K_file)
+{
+  int len, lenp, totlen, i;
+  FILE *src;
+  char *j2kfile;
+
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_JP2C, 4);  // JP2C
+
+  src=fopen(J2K_file, "rb");
+  fseek(src, 0, SEEK_END);
+  totlen=ftell(src);
+  fseek(src, 0, SEEK_SET);
+  
+  j2kfile=(char*)malloc(totlen);
+  fread(j2kfile, 1, totlen, src);
+  fclose(src);
+
+  for (i=0;i<totlen;i++)
+    cio_write(j2kfile[i],1);
+  
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+  return lenp;
+}
+
+void jp2_write_jp()
+{
+  int len, lenp;
+  
+  lenp=cio_tell();
+  cio_skip(4);
+  cio_write(JP2_JP, 4);  // JP
+  cio_write(0x0d0a870a,4);
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len,4);         // L
+  cio_seek(lenp+len);
+}
+
+/*
+ * Read the JP box
+ *
+ * JPEG 2000 signature
+ *
+ * return 1 if error else 0
+ */
+int jp2_read_jp()
+{
+  if (0x0d0a870a!=cio_read(4))
+    return 1;
+  else
+    return 0;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jp2.h.svn-base ./indexer_JPIP/.svn/text-base/jp2.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jp2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/jp2.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,44 @@
+/*
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __JP2_H
+#define __JP2_H
+
+#include "j2k.h"
+
+void jp2_write_url(char *Idx_file);
+
+void jp2_write_dbtl(char *Idx_file);
+
+void jp2_write_jp2h(j2k_image_t *j2k_img);
+
+void jp2_write_ftyp();
+
+int jp2_write_jp2c(char *J2K_file);
+
+void jp2_write_jp();
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jpip.c.svn-base ./indexer_JPIP/.svn/text-base/jpip.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jpip.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/jpip.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,768 @@
+/*
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <setjmp.h>
+#include <math.h>
+
+#include "j2k.h"
+#include "cio.h"
+#include "tcd.h"
+#include "int.h"
+
+#define JPIP_CIDX 0x63696478   /* Codestream index                */
+#define JPIP_CPTR 0x63707472   /* Codestream Finder Box           */
+#define JPIP_MANF 0x6d616e66   /* Manifest Box                    */
+#define JPIP_FAIX 0x66616978   /* Fragment array Index box        */
+#define JPIP_MHIX 0x6d686978   /* Main Header Index Table         */
+#define JPIP_TPIX 0x74706978   /* Tile-part Index Table box       */
+#define JPIP_THIX 0x74686978   /* Tile header Index Table box     */
+#define JPIP_PPIX 0x70706978   /* Precinct Packet Index Table box */
+#define JPIP_PHIX 0x70686978   /* Packet Header index Table       */
+#define JPIP_FIDX 0x66696478   /* File Index                      */
+#define JPIP_FPTR 0x66707472   /* File Finder                     */
+#define JPIP_PRXY 0x70727879   /* Proxy boxes                     */
+#define JPIP_IPTR 0x69707472   /* Index finder box                */
+#define JPIP_PHLD 0x70686c64   /* Place holder                    */
+
+#define JP2C      0x6a703263
+
+//static info_marker_t marker_jpip[32], marker_local_jpip[32];  /* SIZE to precise ! */
+//static int num_marker_jpip, num_marker_local_jpip;
+
+/* 
+ * Write the CPTR box
+ *
+ * Codestream finder box (box)
+ *
+ */
+void jpip_write_cptr(int offset, info_image_t img)
+{
+  int len, lenp;
+
+  lenp=cio_tell(); 
+  cio_skip(4);                       /* L [at the end]     */
+  cio_write(JPIP_CPTR,4);            /* T                  */
+  cio_write(0,2);                    /* DR  A PRECISER !!  */
+  cio_write(0,2);                    /* CONT               */
+  cio_write(offset,8);               /* COFF A PRECISER !! */
+  cio_write(img.codestream_size,8);  /* CLEN               */
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);                 /* L                  */
+  cio_seek(lenp+len);
+}
+
+/* 
+ * Read the CPTR box
+ *
+ * Codestream finder box (box)
+ *
+ */
+void jpip_read_cptr()
+{
+  int DR, CONT;
+  long long Coff, codestream_size;
+
+  DR = cio_read(2);               /* DR   */
+  CONT = cio_read(2);             /* CONT */
+  Coff = cio_read(8);             /* COFF */
+  codestream_size = cio_read(8);  /* CLEN */
+}
+
+/* 
+ * Write the MANF box
+ *
+ * Manifest box (box)
+ *
+ */
+void jpip_write_manf(int second, int v, info_marker_t *marker)
+{
+  int len, lenp, i;
+  lenp=cio_tell(); 
+  cio_skip(4);                         /* L [at the end]                    */
+  cio_write(JPIP_MANF,4);              /* T                                 */
+
+  if (second)                          /* Write only during the second pass */
+    {
+      for(i=0;i<v;i++)
+	{
+	  cio_write(marker[i].len,4);  /* Marker length                     */ 
+	  cio_write(marker[i].type,4); /* Marker type                       */
+	}
+    }
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);                   /* L                                 */
+  cio_seek(lenp+len);
+}
+
+/* 
+ * Read the MANF box
+ *
+ * Manifest box (box)
+ *
+ */
+void jpip_read_manf(int len)
+{
+  int i, v, marker_len, marker_type;
+  
+  v = (len - 8)/ 8;
+  
+  for(i=0;i<v;i++)
+    {
+      marker_len = cio_read(4);       /* Marker length */ 
+      marker_type = cio_read(4);      /* Marker type   */
+    }
+}
+
+/* 
+ * Write the MHIX box
+ *
+ * Main Header Index Table (box)
+ *
+ */
+int jpip_write_mhix(info_image_t img, int status, int tileno)
+{
+  int len, lenp, i;
+  info_tile_t *tile;
+  lenp=cio_tell();
+  cio_skip(4);                               /* L [at the end]                    */
+  cio_write(JPIP_MHIX, 4);                   /* MHIX                              */
+
+  if (status) /* MAIN HEADER */
+    {
+      cio_write(img.Main_head_end,8);        /* TLEN                              */
+      
+      for(i = 0; i < img.num_marker; i++)    /* Marker restricted to 1 apparition */
+	{
+	  cio_write(img.marker[i].type, 2);
+	  cio_write(0, 2);
+	  cio_write(img.marker[i].start_pos, 8);
+	  cio_write(img.marker[i].len, 2);
+	}
+      
+      /* Marker NOT restricted to 1 apparition */
+      for(i = img.marker_mul.num_COC - 1; i >= 0; i--) /* COC */
+	{
+	  cio_write(img.marker_mul.COC[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.COC[i].start_pos, 8);
+	  cio_write(img.marker_mul.COC[i].len, 2);
+	}
+      
+      for(i = img.marker_mul.num_RGN - 1; i >= 0; i--) /* RGN */
+	{
+	  cio_write(img.marker_mul.RGN[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.RGN[i].start_pos, 8);
+	  cio_write(img.marker_mul.RGN[i].len, 2);
+	}
+      
+      for(i = img.marker_mul.num_QCC - 1; i >= 0; i--) /* QCC */
+	{
+	  cio_write(img.marker_mul.QCC[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.QCC[i].start_pos, 8);
+	  cio_write(img.marker_mul.QCC[i].len, 2);
+	}
+      
+      for(i = img.marker_mul.num_TLM - 1; i >= 0; i--) /* TLM */
+	{
+	  cio_write(img.marker_mul.TLM[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.TLM[i].start_pos, 8);
+	  cio_write(img.marker_mul.TLM[i].len, 2);
+	}
+      
+      for(i = img.marker_mul.num_PLM - 1; i >= 0; i--) /* PLM */
+	{
+	  cio_write(img.marker_mul.PLM[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.PLM[i].start_pos, 8);
+	  cio_write(img.marker_mul.PLM[i].len, 2);
+	}
+      
+      for(i = img.marker_mul.num_PPM - 1; i >= 0; i--) /* PPM */
+	{
+	  cio_write(img.marker_mul.PPM[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.PPM[i].start_pos, 8);
+	  cio_write(img.marker_mul.PPM[i].len, 2);
+	}
+
+      for(i = img.marker_mul.num_COM - 1; i >= 0; i--) /* COM */
+	{
+	  cio_write(img.marker_mul.COM[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(img.marker_mul.COM[i].start_pos, 8);
+	  cio_write(img.marker_mul.COM[i].len, 2);
+	}
+    } 
+  else /* TILE HEADER */
+    {
+      tile = &img.tile[tileno];
+      cio_write(tile->tile_parts[0].length_header, 8);  /* TLEN                              */ 
+      
+      for(i = 0; i < tile->num_marker; i++)             /* Marker restricted to 1 apparition */
+	{
+	  cio_write(tile->marker[i].type, 2);
+	  cio_write(0, 2);
+	  cio_write(tile->marker[i].start_pos, 8);
+	  cio_write(tile->marker[i].len, 2);
+	}
+      
+      /* Marker NOT restricted to 1 apparition */
+      for(i = tile->marker_mul.num_COC - 1; i >= 0; i--) /* COC */
+	{
+	  cio_write(tile->marker_mul.COC[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(tile->marker_mul.COC[i].start_pos, 8);
+	  cio_write(tile->marker_mul.COC[i].len, 2);
+	}
+      
+      for(i = tile->marker_mul.num_RGN - 1; i >= 0; i--) /* RGN */
+	{
+	  cio_write(tile->marker_mul.RGN[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(tile->marker_mul.RGN[i].start_pos, 8);
+	  cio_write(tile->marker_mul.RGN[i].len, 2);
+	}
+      
+      for(i = tile->marker_mul.num_QCC - 1; i >= 0; i--) /* QCC */
+	{
+	  cio_write(tile->marker_mul.QCC[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(tile->marker_mul.QCC[i].start_pos, 8);
+	  cio_write(tile->marker_mul.QCC[i].len, 2);
+	}
+      
+      for(i = tile->marker_mul.num_PLT - 1; i >= 0; i--) /* PLT */
+	{
+	  cio_write(tile->marker_mul.PLT[i].type,2);
+	  cio_write(i,2);
+	  cio_write(tile->marker_mul.PLT[i].start_pos,8);
+	  cio_write(tile->marker_mul.PLT[i].len,2);
+	}
+      
+      for(i = tile->marker_mul.num_PPT - 1; i >= 0; i--) /* PPT */
+	{
+	  cio_write(tile->marker_mul.PPT[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(tile->marker_mul.PPT[i].start_pos, 8);
+	  cio_write(tile->marker_mul.PPT[i].len, 2);
+	}
+      
+      for(i = tile->marker_mul.num_COM - 1; i >= 0; i--) /* COM */
+	{
+	  cio_write(tile->marker_mul.COM[i].type, 2);
+	  cio_write(i, 2);
+	  cio_write(tile->marker_mul.COM[i].start_pos, 8);
+	  cio_write(tile->marker_mul.COM[i].len, 2);
+	} 
+    }      
+  
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L           */
+  cio_seek(lenp+len);
+  
+  return len;
+}
+
+/* 
+ * Read the MHIX box
+ *
+ * Main Header Index Table (box)
+ *
+ */
+void jpip_read_mhix(int len)
+{
+  int i, v, marker_type, marker_start_pos, marker_len, marker_remains;
+
+  v = (len - 8) / 14;
+
+  for (i=0; i<v ; i++)
+    {
+      marker_type = cio_read(2);       /* Type of the marker               */ 
+      marker_remains = cio_read(2);    /* Number of same markers following */
+      marker_start_pos = cio_read(2);  /* Start position of the marker     */
+      marker_len = cio_read(2);        /* Length of the marker             */
+    }
+}
+
+/* 
+ * Write the FAIX box
+ *
+ * Fragment array Index box (box)
+ *
+ */
+int jpip_write_faix(int v, int compno, info_image_t img, j2k_cp_t *j2k_cp, int version)
+{
+  int len, lenp, i, j;
+  /*int version = 0;*/
+  int tileno, resno, precno, layno, num_packet=0;
+
+  lenp=cio_tell();
+  cio_skip(4);              /* L [at the end]      */
+  cio_write(JPIP_FAIX, 4);  /* FAIX                */ 
+  cio_write(version,1);     /* Version 0 = 4 bytes */
+  
+  switch(v)
+    {
+    case 0:   /* TPIX */
+      cio_write(img.num_max_tile_parts,(version & 0x01)?8:4);                      /* NMAX           */
+      cio_write(img.tw*img.th,(version & 0x01)?8:4);                               /* M              */
+      for (i = 0; i < img.tw*img.th; i++)
+	{
+	  for (j = 0; j < img.tile[i].numparts ; j++)
+	    {
+	      cio_write(img.tile[i].tile_parts[j].start_pos,(version & 0x01)?8:4); /* start position */
+	      cio_write(img.tile[i].tile_parts[j].length,(version & 0x01)?8:4);    /* length         */
+	      if (version & 0x02)
+		cio_write(img.tile[i].tile_parts[j].num_reso_AUX,4); /* Aux_i,j : Auxiliary value */
+	      //cio_write(0,4);
+	    }
+	  /* PADDING */
+	  while (j < img.num_max_tile_parts)
+	    {
+	      cio_write(0,(version & 0x01)?8:4); /* start position            */
+	      cio_write(0,(version & 0x01)?8:4); /* length                    */
+	      if (version & 0x02)
+		cio_write(0,4);                  /* Aux_i,j : Auxiliary value */
+	      j++;
+	    }
+	}
+      break;
+      
+      /*   case 1: */   /* THIX */
+      /* cio_write(1,(version & 0x01)?8:4);  */           /* NMAX */
+      /* cio_write(img.tw*img.th,(version & 0x01)?8:4); */ /* M    */
+      /* for (i=0;i<img.tw*img.th;i++) */
+      /* { */
+      /* cio_write(img.tile[i].start_pos,(version & 0x01)?8:4); */                         /* start position */
+      /* cio_write(img.tile[i].end_header-img.tile[i].start_pos,(version & 0x01)?8:4); */  /* length         */
+      /* if (version & 0x02)*/
+      /* cio_write(0,4); */ /* Aux_i,j : Auxiliary value */
+      /* } */
+      /* break; */
+
+    case 2:  /* PPIX  NOT FINISHED !! */
+      cio_write(img.num_packet_max,(version & 0x01)?8:4); /* NMAX */
+      cio_write(img.tw*img.th,(version & 0x01)?8:4);      /* M    */
+      for(tileno=0;tileno<img.tw*img.th;tileno++)
+	{
+	  info_tile_t *tile_Idx = &img.tile[tileno];
+	  info_compo_t *compo_Idx = &tile_Idx->compo[compno];
+	  int correction;
+	  
+	  num_packet=0;
+	  
+	  if(j2k_cp->tcps[tileno].csty&J2K_CP_CSTY_EPH)
+	    correction=3;
+	  else
+	    correction=1;
+	  for(resno=0;resno<img.Decomposition+1;resno++)
+	    {
+	      info_reso_t *reso_Idx = &compo_Idx->reso[resno];
+	      for (precno=0;precno<img.tile[tileno].pw*img.tile[tileno].ph;precno++)
+		{
+		  info_prec_t *prec_Idx = &reso_Idx->prec[precno];
+		  for(layno=0;layno<img.Layer;layno++)
+		    {
+		      info_layer_t *layer_Idx = &prec_Idx->layer[layno];
+		      cio_write(layer_Idx->offset,(version & 0x01)?8:4);                                   /* start position */
+		      cio_write((layer_Idx->len_header-correction)?0:layer_Idx->len,(version & 0x01)?8:4); /* length         */
+		      if (version & 0x02)
+			cio_write(0,4); /* Aux_i,j : Auxiliary value */
+		      num_packet++;
+		    }
+		}
+	    }
+	  /* PADDING */
+	  while (num_packet < img.num_packet_max)
+	    {
+	      cio_write(0,(version & 0x01)?8:4); /* start position            */
+	      cio_write(0,(version & 0x01)?8:4); /* length                    */
+	      if (version & 0x02)
+		cio_write(0,4);                  /* Aux_i,j : Auxiliary value */
+	      num_packet++;
+	    }
+	}
+      
+      break;
+      
+    case 3:  /* PHIX NOT FINISHED !! */
+      cio_write(img.num_packet_max,(version & 0x01)?8:4); /* NMAX */
+      cio_write(img.tw*img.th,(version & 0x01)?8:4);      /* M    */
+      for(tileno=0;tileno<img.tw*img.th;tileno++)
+	{
+	  info_tile_t *tile_Idx = &img.tile[tileno];
+	  info_compo_t *compo_Idx = &tile_Idx->compo[compno];
+	  int correction;
+
+	  num_packet = 0;
+	  if(j2k_cp->tcps[tileno].csty&J2K_CP_CSTY_EPH)
+	    correction=3;
+	  else
+	    correction=1;
+	  for(resno=0;resno<img.Decomposition+1;resno++)
+	    {
+	      info_reso_t *reso_Idx = &compo_Idx->reso[resno];
+	      for (precno=0;precno<img.tile[tileno].pw*img.tile[tileno].ph;precno++)
+		{
+		  info_prec_t *prec_Idx = &reso_Idx->prec[precno];
+		  for(layno=0;layno<img.Layer;layno++)
+		    {
+		      info_layer_t *layer_Idx = &prec_Idx->layer[layno];
+		      cio_write(layer_Idx->offset_header,(version & 0x01)?8:4);                                   /* start position */
+		      cio_write((layer_Idx->len_header-correction)?0:layer_Idx->len_header,(version & 0x01)?8:4); /* length         */
+		      if (version & 0x02)
+			cio_write(0,4); /* Aux_i,j : Auxiliary value */
+		      num_packet++;
+		    }
+		}
+	    }
+	  /* PADDING */
+	  while (num_packet<img.num_packet_max)
+	    {
+	      cio_write(0,(version & 0x01)?8:4); /* start position            */
+	      cio_write(0,(version & 0x01)?8:4); /* length                    */
+	      if (version & 0x02)
+		cio_write(0,4);                  /* Aux_i,j : Auxiliary value */
+	      num_packet++;
+	    }
+	}
+      break;
+    }
+  
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L  */
+  cio_seek(lenp+len);
+
+  return len;
+}
+
+/* 
+ * Write the TPIX box
+ *
+ * Tile-part Index table box (superbox)
+ *
+ */
+int jpip_write_tpix(info_image_t img, j2k_cp_t *j2k_cp, int version)
+{
+  int len, lenp;
+  lenp=cio_tell();
+  cio_skip(4);              /* L [at the end] */
+  cio_write(JPIP_TPIX, 4);  /* TPIX           */
+  
+  jpip_write_faix(0,0,img, j2k_cp, version);
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L              */
+  cio_seek(lenp+len);
+
+  return len;
+}
+
+/* 
+ * Write the THIX box
+ *
+ * Tile header Index table box (superbox)
+ *
+ */
+//int jpip_write_thix(info_image_t img, j2k_cp_t *j2k_cp)
+//  {
+//  int len, lenp;
+//  lenp=cio_tell();
+//  cio_skip(4);              /* L [at the end] */
+//  cio_write(JPIP_THIX, 4);  /* THIX           */
+  
+//  jpip_write_faix(1,0,img, j2k_cp);
+
+//  len=cio_tell()-lenp;
+//  cio_seek(lenp);
+//  cio_write(len, 4);        /* L              */
+//  cio_seek(lenp+len);
+
+//  return len;
+//}
+
+int jpip_write_thix(info_image_t img, j2k_cp_t *j2k_cp)
+{
+  int len, lenp, i;
+  int tileno;
+  info_marker_t *marker;
+  int num_marker_local_jpip;
+
+  marker = (info_marker_t*)calloc(sizeof(info_marker_t), j2k_cp->tw*j2k_cp->th);
+
+  for ( i = 0; i < 2 ; i++ )
+    {
+      if (i) cio_seek(lenp);
+      
+      lenp = cio_tell();
+      cio_skip(4);              /* L [at the end] */
+      cio_write(JPIP_THIX, 4);  /* THIX           */
+      jpip_write_manf(i, j2k_cp->tw*j2k_cp->th, marker);
+      num_marker_local_jpip=img.Comp;
+      
+      for (tileno = 0; tileno < j2k_cp->tw*j2k_cp->th; tileno++)
+	{
+	  marker[tileno].len = jpip_write_mhix(img, 1, tileno);
+	  marker[tileno].type = JPIP_MHIX;
+	}
+      
+      len=cio_tell()-lenp;
+      cio_seek(lenp);
+      cio_write(len, 4);        /* L              */
+      cio_seek(lenp+len);
+    }
+
+  free(marker);
+
+  return len;
+}
+/* 
+ * Write the PPIX box
+ *
+ * Precinct Packet Index table box (superbox)
+ *
+ */
+int jpip_write_ppix(info_image_t img,j2k_cp_t *j2k_cp)
+{
+  int len, lenp, compno, i;
+  info_marker_t *marker;
+  int num_marker_local_jpip;
+  marker = (info_marker_t*)calloc(sizeof(info_marker_t), img.Comp);
+  
+  for (i=0;i<2;i++)
+    {
+      if (i) cio_seek(lenp);
+      
+      lenp=cio_tell();
+      cio_skip(4);              /* L [at the end] */
+      cio_write(JPIP_PPIX, 4);  /* PPIX           */
+      jpip_write_manf(i,img.Comp,marker);
+      num_marker_local_jpip=img.Comp;
+      
+      for (compno=0; compno<img.Comp; compno++)
+	{
+	  marker[compno].len=jpip_write_faix(2,compno,img, j2k_cp, 0);
+	  marker[compno].type=JPIP_FAIX;
+	}
+   
+      len=cio_tell()-lenp;
+      cio_seek(lenp);
+      cio_write(len, 4);        /* L              */
+      cio_seek(lenp+len);
+    }
+  
+  free(marker);
+
+  return len;
+}
+
+/* 
+ * Write the PHIX box
+ *
+ * Packet Header Index table box (superbox)
+ *
+ */
+int jpip_write_phix(info_image_t img, j2k_cp_t *j2k_cp)
+{
+  int len, lenp=0, compno, i;
+  info_marker_t *marker;
+
+  marker = (info_marker_t*)calloc(sizeof(info_marker_t), img.Comp);
+
+  for (i=0;i<2;i++)
+    {
+      if (i) cio_seek(lenp);
+      
+      lenp=cio_tell();
+      cio_skip(4);              /* L [at the end] */
+      cio_write(JPIP_PHIX, 4);  /* PHIX           */
+      
+      jpip_write_manf(i,img.Comp,marker);
+
+      for (compno=0; compno<img.Comp; compno++)
+	{	
+	  marker[compno].len=jpip_write_faix(3,compno,img, j2k_cp, 0);
+	  marker[compno].type=JPIP_FAIX;
+	}
+
+      len=cio_tell()-lenp;
+      cio_seek(lenp);
+      cio_write(len, 4);        /* L              */
+      cio_seek(lenp+len);
+    }
+
+  free(marker);
+
+  return len;
+}
+
+/* 
+ * Write the CIDX box
+ *
+ * Codestream Index box (superbox)
+ *
+ */
+int jpip_write_cidx(int offset, info_image_t img, j2k_cp_t *j2k_cp, int version)
+{
+  int len, lenp = 0, i;
+  info_marker_t *marker_jpip;
+  int num_marker_jpip = 0;
+
+  marker_jpip = (info_marker_t*)calloc(sizeof(info_marker_t), 32);
+
+  for (i=0;i<2;i++)
+    {
+      if(i)
+	cio_seek(lenp);
+
+      lenp=cio_tell();
+
+      cio_skip(4);              /* L [at the end] */
+      cio_write(JPIP_CIDX, 4);  /* CIDX           */
+      jpip_write_cptr(offset, img);
+
+      jpip_write_manf(i,num_marker_jpip, marker_jpip);
+
+      num_marker_jpip=0;
+      marker_jpip[num_marker_jpip].len=jpip_write_mhix(img, 0, 0);
+      marker_jpip[num_marker_jpip].type=JPIP_MHIX;
+      num_marker_jpip++;
+
+      marker_jpip[num_marker_jpip].len=jpip_write_tpix(img, j2k_cp, version);
+      marker_jpip[num_marker_jpip].type=JPIP_TPIX;
+      num_marker_jpip++;
+
+      marker_jpip[num_marker_jpip].len=jpip_write_thix(img, j2k_cp);
+      marker_jpip[num_marker_jpip].type=JPIP_THIX;
+      num_marker_jpip++;
+
+      marker_jpip[num_marker_jpip].len=jpip_write_ppix(img, j2k_cp);
+      marker_jpip[num_marker_jpip].type=JPIP_PPIX;
+      num_marker_jpip++;
+
+      marker_jpip[num_marker_jpip].len=jpip_write_phix(img, j2k_cp);
+      marker_jpip[num_marker_jpip].type=JPIP_PHIX;
+      num_marker_jpip++;
+
+      len=cio_tell()-lenp;
+      cio_seek(lenp);
+      cio_write(len, 4);        /* L             */
+      cio_seek(lenp+len);
+    }
+
+  free(marker_jpip);
+
+  return len;
+
+}
+
+/* 
+ * Write the IPTR box
+ *
+ * Index Finder box
+ *
+ */
+void jpip_write_iptr(int offset, int length)
+{
+  int len, lenp;
+  lenp=cio_tell();
+  cio_skip(4);              /* L [at the end] */
+  cio_write(JPIP_IPTR, 4);  /* IPTR           */
+  
+  cio_write(offset,8);
+  cio_write(length,8);
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L             */
+  cio_seek(lenp+len);
+}
+
+/* 
+ * Write the PRXY box
+ *
+ * proxy (box)
+ *
+ */
+void jpip_write_prxy(int offset_jp2c, int length_jp2c, int offset_idx, int length_idx)
+{
+  int len, lenp;
+  lenp=cio_tell();
+  cio_skip(4);              /* L [at the end] */
+  cio_write(JPIP_PRXY, 4);  /* IPTR           */
+  
+  cio_write(offset_jp2c,8); /* OOFF           */
+  cio_write(length_jp2c,4); /* OBH part 1     */
+  cio_write(JP2C,4);        /* OBH part 2     */
+  
+  cio_write(1,1);           /* NI             */
+
+  cio_write(offset_idx,8);  /* IOFF           */
+  cio_write(length_idx,4);  /* IBH part 1     */
+  cio_write(JPIP_CIDX,4);   /* IBH part 2     */
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L              */
+  cio_seek(lenp+len);
+}
+
+
+/* 
+ * Write the FIDX box
+ *
+ * File Index (superbox)
+ *
+ */
+int jpip_write_fidx(int offset_jp2c, int length_jp2c, int offset_idx, int length_idx)
+{
+  int len, lenp;
+  lenp=cio_tell();
+  cio_skip(4);              /* L [at the end] */
+  cio_write(JPIP_FIDX, 4);  /* IPTR           */
+  
+  jpip_write_prxy(offset_jp2c, length_jp2c, offset_idx, offset_jp2c);
+
+  len=cio_tell()-lenp;
+  cio_seek(lenp);
+  cio_write(len, 4);        /* L              */
+  cio_seek(lenp+len);
+
+  return len;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jpip.h.svn-base ./indexer_JPIP/.svn/text-base/jpip.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/jpip.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/jpip.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,42 @@
+/*
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __JPIP_H
+#define __JPIP_H
+
+#include "j2k.h"
+
+// Codestream index box (superbox)
+int jpip_write_cidx(int offset, info_image_t img, j2k_cp_t *j2k_cp, int version);
+
+// Index Finder Box
+void jpip_write_iptr(int offset, int length);
+
+// File Index Box
+int jpip_write_fidx(int offset_jp2c, int length_jp2c, int offset_idx, int length_idx);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/Makefile.svn-base ./indexer_JPIP/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/Makefile.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,23 @@
+CC = gcc
+
+LDFLAGS = -lm
+CFLAGS = -Wall
+
+all: index_create
+
+
+bio.o : bio.c bio.h
+cio.o : cio.c cio.h
+int.o : int.c
+pi.o  : pi.c pi.h int.h
+index_create.o : index_create.c j2k.h cio.h tcd.h int.h
+t2.o  : t2.c t2.h tcd.h bio.h j2k.h pi.h tgt.h int.h cio.h
+tgt.o : tgt.c bio.h tgt.h
+tcd.o : tcd.c tcd.h t2.h int.h
+jpip.o : jpip.c j2k.h cio.h tcd.h int.h
+jp2.o : jp2.c j2k.h cio.h tcd.h int.h
+
+index_create : bio.o cio.o int.o pi.o t2.o tgt.o tcd.o index_create.o jpip.o jp2.o
+
+clean:
+	rm -rf *.o *.*~ *~ core.*
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/pi.c.svn-base ./indexer_JPIP/.svn/text-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/pi.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,465 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003-2004, Yannick Verschueren
+ * Copyright (c) 2003-2004, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "pi.h"
+#include "int.h"
+#include <stdlib.h>
+#include <stdio.h>
+
+
+/* <summary> */
+/* Create a packet iterator.   */
+/* </summary> */
+pi_iterator_t *pi_create(j2k_image_t * img, j2k_cp_t * cp, int tileno)
+{
+	int p, q;
+	int compno, resno, pino;
+	int maxres = 0;
+	pi_iterator_t *pi;
+	j2k_tcp_t *tcp;
+	j2k_tccp_t *tccp;
+
+	tcp = &cp->tcps[tileno];
+	pi = (pi_iterator_t *) malloc((tcp->numpocs + 1) * sizeof(pi_iterator_t));
+
+	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
+		p = tileno % cp->tw;
+		q = tileno / cp->tw;
+
+		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, img->x0);
+		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, img->y0);
+		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, img->x1);
+		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, img->y1);
+		pi[pino].numcomps = img->numcomps;
+		pi[pino].comps = (pi_comp_t *) malloc(img->numcomps * sizeof(pi_comp_t));
+
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			int tcx0, tcy0, tcx1, tcy1;
+			pi_comp_t *comp = &pi[pino].comps[compno];
+			tccp = &tcp->tccps[compno];
+			comp->dx = img->comps[compno].dx;
+			comp->dy = img->comps[compno].dy;
+			comp->numresolutions = tccp->numresolutions;
+			comp->resolutions =
+				(pi_resolution_t *) malloc(comp->numresolutions *
+																	 sizeof(pi_resolution_t));
+			tcx0 = int_ceildiv(pi->tx0, comp->dx);
+			tcy0 = int_ceildiv(pi->ty0, comp->dy);
+			tcx1 = int_ceildiv(pi->tx1, comp->dx);
+			tcy1 = int_ceildiv(pi->ty1, comp->dy);
+			if (comp->numresolutions > maxres) {
+				maxres = comp->numresolutions;
+			}
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int levelno;
+				int rx0, ry0, rx1, ry1;
+				int px0, py0, px1, py1;
+				pi_resolution_t *res = &comp->resolutions[resno];
+				if (tccp->csty & J2K_CCP_CSTY_PRT) {
+					res->pdx = tccp->prcw[resno];
+					res->pdy = tccp->prch[resno];
+				} else {
+					res->pdx = 15;
+					res->pdy = 15;
+				}
+				levelno = comp->numresolutions - 1 - resno;
+				rx0 = int_ceildivpow2(tcx0, levelno);
+				ry0 = int_ceildivpow2(tcy0, levelno);
+				rx1 = int_ceildivpow2(tcx1, levelno);
+				ry1 = int_ceildivpow2(tcy1, levelno);
+				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
+				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
+				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
+				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
+				res->pw = (px1 - px0) >> res->pdx;
+				res->ph = (py1 - py0) >> res->pdy;
+			}
+		}
+		
+		tccp = &tcp->tccps[0];
+		pi[pino].step_p=1;
+		pi[pino].step_c=100*pi[pino].step_p;
+		pi[pino].step_r=img->numcomps*pi[pino].step_c;
+		pi[pino].step_l=maxres*pi[pino].step_r;
+		
+		if (pino==0)
+		  pi[pino].include=(short int*)calloc(img->numcomps*maxres*tcp->numlayers*100,sizeof(short int));
+		else
+		  pi[pino].include=pi[pino-1].include;
+
+		/*if (pino == tcp->numpocs) {*/
+		  if (tcp->POC == 0) {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = 0;
+			pi[pino].poc.compno0 = 0;
+			pi[pino].poc.layno1 = tcp->numlayers;
+			pi[pino].poc.resno1 = maxres;
+			pi[pino].poc.compno1 = img->numcomps;
+			pi[pino].poc.prg = tcp->prg;
+		} else {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = tcp->pocs[pino].resno0;
+			pi[pino].poc.compno0 = tcp->pocs[pino].compno0;
+			pi[pino].poc.layno1 = tcp->pocs[pino].layno1;
+			pi[pino].poc.resno1 = tcp->pocs[pino].resno1;
+			pi[pino].poc.compno1 = tcp->pocs[pino].compno1;
+			pi[pino].poc.prg = tcp->pocs[pino].prg;
+		}
+	}
+	return pi;
+}
+
+/* <summary> */
+/* Get next packet in layer=resolution-component-precinct order.   */
+/* </summary> */
+int pi_next_lrcp(pi_iterator_t * pi)
+{
+	pi_comp_t *comp;
+	pi_resolution_t *res;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto skip;
+	} else {
+		pi->first = 0;
+	}
+	for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+		for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;
+				 pi->resno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1;
+					 pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolutions) {
+
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				for (pi->precno = 0; pi->precno < res->pw * res->ph; pi->precno++) {
+				  if (!pi->include[pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p]){
+				    pi->include[pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p] = 1;
+				    return 1;
+					}
+				skip:;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* <summary> */
+/* Get next packet in resolution-layer-component-precinct order.   */
+/* </summary> */
+int pi_next_rlcp(pi_iterator_t * pi)
+{
+	pi_comp_t *comp;
+	pi_resolution_t *res;
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto skip;
+	} else {
+		pi->first = 0;
+	}
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1;
+					 pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolutions) {
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				for (pi->precno = 0; pi->precno < res->pw * res->ph; pi->precno++) {
+				  if (!pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p]){
+				    pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p] = 1;
+				    return 1;
+				  }
+				skip:;
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* <summary> */
+/* Get next packet in resolution-precinct-component-layer order.   */
+/* </summary> */
+int pi_next_rpcl(pi_iterator_t * pi)
+{
+	pi_comp_t *comp;
+	pi_resolution_t *res;
+	if (!pi->first) {
+		goto skip;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int dx, dy;
+				res = &comp->resolutions[resno];
+				dx =
+					comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+				dy =
+					comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			}
+		}
+	}
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->y = pi->ty0; pi->y < pi->ty1;
+				 pi->y += pi->dy - (pi->y % pi->dy)) {
+			for (pi->x = pi->tx0; pi->x < pi->tx1;
+					 pi->x += pi->dx - (pi->x % pi->dx)) {
+				for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1;
+						 pi->compno++) {
+					int levelno;
+					int trx0, try0;
+					int rpx, rpy;
+					int prci, prcj;
+					comp = &pi->comps[pi->compno];
+					if (pi->resno >= comp->numresolutions) {
+						continue;
+					}
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!
+							(pi->x % (comp->dx << rpx) == 0
+							 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					if (!
+							(pi->y % (comp->dy << rpy) == 0
+							 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					prci =
+						int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno),
+														 res->pdx) - int_floordivpow2(trx0, res->pdx);
+					prcj =
+						int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno),
+														 res->pdy) - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+					  if (!pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p]){
+					    pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p] = 1;
+					    return 1;
+						}
+					skip:;
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* <summary> */
+/* Get next packet in precinct-component-resolution-layer order.   */
+/* </summary> */
+int pi_next_pcrl(pi_iterator_t * pi)
+{
+	pi_comp_t *comp;
+	pi_resolution_t *res;
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto skip;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int dx, dy;
+				res = &comp->resolutions[resno];
+				dx =
+					comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+				dy =
+					comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			}
+		}
+	}
+	for (pi->y = pi->ty0; pi->y < pi->ty1;
+			 pi->y += pi->dy - (pi->y % pi->dy)) {
+		for (pi->x = pi->tx0; pi->x < pi->tx1;
+				 pi->x += pi->dx - (pi->x % pi->dx)) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1;
+					 pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				for (pi->resno = pi->poc.resno0;
+						 pi->resno < int_min(pi->poc.resno1, comp->numresolutions);
+						 pi->resno++) {
+					int levelno;
+					int trx0, try0;
+					int rpx, rpy;
+					int prci, prcj;
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!
+							(pi->x % (comp->dx << rpx) == 0
+							 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					if (!
+							(pi->y % (comp->dy << rpy) == 0
+							 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					prci =
+						int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno),
+														 res->pdx) - int_floordivpow2(trx0, res->pdx);
+					prcj =
+						int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno),
+														 res->pdy) - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+					  if (! pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p]){
+					    pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p] = 1;
+							return 1;
+						}
+					skip:;
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* <summary> */
+/* Get next packet in component-precinct-resolution-layer order.   */
+/* </summary> */
+int pi_next_cprl(pi_iterator_t * pi)
+{
+	pi_comp_t *comp;
+	pi_resolution_t *res;
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto skip;
+	} else {
+		pi->first = 0;
+	}
+	for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1;
+			 pi->compno++) {
+		int resno;
+		comp = &pi->comps[pi->compno];
+		pi->dx = 0;
+		pi->dy = 0;
+		for (resno = 0; resno < comp->numresolutions; resno++) {
+			int dx, dy;
+			res = &comp->resolutions[resno];
+			dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+			dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+			pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+			pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+		}
+		for (pi->y = pi->ty0; pi->y < pi->ty1;
+				 pi->y += pi->dy - (pi->y % pi->dy)) {
+			for (pi->x = pi->tx0; pi->x < pi->tx1;
+					 pi->x += pi->dx - (pi->x % pi->dx)) {
+				for (pi->resno = pi->poc.resno0;
+						 pi->resno < int_min(pi->poc.resno1, comp->numresolutions);
+						 pi->resno++) {
+					int levelno;
+					int trx0, try0;
+					int rpx, rpy;
+					int prci, prcj;
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!
+							(pi->x % (comp->dx << rpx) == 0
+							 || (pi->x == pi->tx0 && (trx0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					if (!
+							(pi->y % (comp->dy << rpy) == 0
+							 || (pi->y == pi->ty0 && (try0 << levelno) % (1 << rpx)))) {
+						continue;
+					}
+					prci =
+						int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno),
+														 res->pdx) - int_floordivpow2(trx0, res->pdx);
+					prcj =
+						int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno),
+														 res->pdy) - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+					  if (! pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p]){
+					    pi->include[pi->layno*pi->step_l+pi->resno*pi->step_r+pi->compno*pi->step_c+pi->precno*pi->step_p] = 1;
+					    return 1;
+						}
+					skip:;
+					}
+				}
+			}
+		}
+	}
+	return 0;
+}
+
+/* <summary> */
+/* Get next packet.   */
+/* </summary> */
+int pi_next(pi_iterator_t * pi)
+{
+	switch (pi->poc.prg) {
+	case 0:
+		return pi_next_lrcp(pi);
+	case 1:
+		return pi_next_rlcp(pi);
+	case 2:
+		return pi_next_rpcl(pi);
+	case 3:
+		return pi_next_pcrl(pi);
+	case 4:
+		return pi_next_cprl(pi);
+	}
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/pi.h.svn-base ./indexer_JPIP/.svn/text-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/pi.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,72 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PI_H
+#define __PI_H
+
+#include "j2k.h"
+#include "tcd.h"
+
+typedef struct {
+	int pdx, pdy;
+	int pw, ph;
+} pi_resolution_t;
+
+typedef struct {
+	int dx, dy;
+	int numresolutions;
+	pi_resolution_t *resolutions;
+} pi_comp_t;
+
+typedef struct {
+	short int *include;
+  int step_l, step_r, step_c, step_p; 
+	int compno, resno, precno, layno;	/* component, resolution, precinct and layer that indentify the packet */
+	int first;
+	j2k_poc_t poc;
+	int numcomps;
+	pi_comp_t *comps;
+	int tx0, ty0, tx1, ty1;
+	int x, y, dx, dy;
+} pi_iterator_t;								/* packet iterator */
+
+/*
+ * Create a packet iterator
+ * img: raw image for which the packets will be listed
+ * cp: coding paremeters
+ * tileno: number that identifies the tile for which to list the packets
+ * return value: returns a packet iterator that points to the first packet of the tile
+ */
+pi_iterator_t *pi_create(j2k_image_t * img, j2k_cp_t * cp, int tileno);
+
+/* 
+ * Modify the packet iterator to point to the next packet
+ * pi: packet iterator to modify
+ * return value: returns 0 if pi pointed to the last packet or else returns 1 
+ */
+int pi_next(pi_iterator_t * pi);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/t2.c.svn-base ./indexer_JPIP/.svn/text-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/t2.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "t2.h"
+#include "tcd.h"
+#include "bio.h"
+#include "j2k.h"
+#include "pi.h"
+#include "tgt.h"
+#include "int.h"
+#include "cio.h"
+#include <stdio.h>
+#include <setjmp.h>
+#include <string.h>
+#include <stdlib.h> 
+
+#define RESTART 0x04
+
+extern jmp_buf j2k_error;
+
+int t2_getcommacode() {
+    int n;
+    for (n=0; bio_read(1); n++) {}
+    return n;
+}
+
+int t2_getnumpasses()
+{
+    int n;
+    if (!bio_read(1)) return 1;
+    if (!bio_read(1)) return 2;
+    if ((n=bio_read(2))!=3) return 3+n;
+    if ((n=bio_read(5))!=31) return 6+n;
+    return 37+bio_read(7);
+}
+
+void t2_init_seg(tcd_seg_t *seg, int cblksty) {
+    seg->numpasses=0;
+    seg->len=0;
+    seg->maxpasses=cblksty&J2K_CCP_CBLKSTY_TERMALL?1:100;
+}
+
+int t2_decode_packet(unsigned char *src, int len, tcd_tile_t *tile, j2k_cp_t * cp, j2k_tcp_t *tcp, int compno, int resno, int precno, int layno, info_layer_t *layer_Idx) {
+    int bandno, cblkno;
+    tcd_tilecomp_t *tilec = &tile->comps[compno];
+    tcd_resolution_t *res = &tilec->resolutions[resno];
+    unsigned char *c = src;
+    unsigned char *d = c;
+    int e;
+    int present;
+
+    if (layno == 0) {
+        for (bandno = 0; bandno < res->numbands; bandno++) {
+            tcd_band_t *band = &res->bands[bandno];
+            tcd_precinct_t *prc = &band->precincts[precno];
+            tgt_reset(prc->incltree);
+            tgt_reset(prc->imsbtree);
+            for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+                tcd_cblk_t *cblk = &prc->cblks[cblkno];
+                cblk->numsegs = 0;
+            }
+        }  
+    }
+    /* INDEX */
+    layer_Idx->len_header = 0;
+
+    /* When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
+       This part deal with this caracteristic
+       step 1: Read packet header in the saved structure
+       step 2: (futher) return to codestream for decoding */
+    if (cp->ppm == 1) /* PPM */
+      {	    
+	c = cp->ppm_data;
+	d = c;
+	bio_init_dec(c, 1000);
+      } else 
+	{
+	  if (tcp->ppt == 1) /* PPT */
+	    {
+	      c = tcp->ppt_data;
+	      d = c;
+	      bio_init_dec(c, 1000);
+	    } else /* Normal Case */
+	      {
+		if (tcp->csty & J2K_CP_CSTY_SOP) 
+		  {
+		    if ((*c) != 255 || (*(c+1) != 145)) {printf("Error : expected SOP marker [1]!!!\n");}
+		    c += 6;
+		  }
+		bio_init_dec(c, src + len - c);
+		layer_Idx->len_header = -6;
+	      }
+	}
+    
+    present = bio_read(1);
+    
+    if (!present) 
+      {
+	bio_inalign();
+	/* Normal case */
+	c += bio_numbytes();
+	if (tcp->csty & J2K_CP_CSTY_EPH) 
+	  {
+	    if ((*c) != 255 || (*(c+1) != 146)) {printf("Error : expected EPH marker [1]!!!\n");}
+	    c += 2;
+	  }
+	/* INDEX */
+	layer_Idx->len_header += (c-d);
+
+	/* PPT and PPM dealing */
+	if (cp->ppm == 1) /* PPM */
+	  {	
+	    cp->ppm_data = c;	    
+	    return 0;
+	  }
+	if (tcp->ppt == 1) /* PPT */
+	  {
+	    tcp->ppt_data = c;
+	    return 0;
+	  }
+	return c - src;
+      }
+    
+    for (bandno=0; bandno<res->numbands; bandno++) {
+        tcd_band_t *band = &res->bands[bandno];
+        tcd_precinct_t *prc = &band->precincts[precno];
+        for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+            int included, increment, n;
+            tcd_cblk_t *cblk = &prc->cblks[cblkno];
+            tcd_seg_t *seg;
+            if (!cblk->numsegs) {
+                included = tgt_decode(prc->incltree, cblkno, layno+1);
+            } else {
+                included = bio_read(1);
+            }
+            if (!included) {
+                cblk->numnewpasses = 0;
+                continue;
+            }
+            if (!cblk->numsegs) {
+                int i, numimsbs;
+                for (i = 0; !tgt_decode(prc->imsbtree, cblkno, i); i++) {}
+                numimsbs = i-1;
+                cblk->numbps = band->numbps - numimsbs;
+                cblk->numlenbits = 3;
+            }
+            cblk->numnewpasses = t2_getnumpasses();
+            increment = t2_getcommacode();
+            cblk->numlenbits += increment;
+            if (!cblk->numsegs) {
+                seg = &cblk->segs[0];
+                t2_init_seg(seg, tcp->tccps[compno].cblksty);
+            } else {
+                seg = &cblk->segs[cblk->numsegs - 1];
+                if (seg->numpasses == seg->maxpasses) {
+                    t2_init_seg(++seg, tcp->tccps[compno].cblksty);
+                }
+            }
+            n = cblk->numnewpasses;
+            do {
+                seg->numnewpasses = int_min(seg->maxpasses-seg->numpasses, n);
+                seg->newlen = bio_read(cblk->numlenbits + int_floorlog2(seg->numnewpasses));
+                n -= seg->numnewpasses;
+                if (n > 0) {
+                    t2_init_seg(++seg, tcp->tccps[compno].cblksty);
+                }
+            } while (n > 0);
+        }
+    }
+    if(bio_inalign()) return -999;
+    c += bio_numbytes();
+
+    if (tcp->csty & J2K_CP_CSTY_EPH) { /* EPH marker */
+      if ((*c) != 255 || (*(c+1) != 146)) {printf("Error : expected EPH marker [2]!!!\n"); }
+      c += 2;
+    }
+    
+    /* INDEX */
+    layer_Idx->len_header += (c-d);
+
+    /* PPT Step 2 : see above for details */
+    if (cp->ppm == 1)
+      {
+	cp->ppm_data = c; /* Update pointer */
+
+	/* INDEX */
+	layer_Idx->len_header = c-d;
+
+	c = src;
+	d = c;
+	if (tcp->csty & J2K_CP_CSTY_SOP) 
+	  {
+	    if ((*c) != 255 || (*(c+1) != 145)) {printf("Error : expected SOP marker [2] !!!\n"); }
+	    c += 6;
+	  }
+	bio_init_dec(c, src + len - c);
+      } else 
+	{
+	  if (tcp->ppt == 1)
+	    { 
+	      tcp->ppt_data = c; /* Update pointer */
+	      /* INDEX */
+	      layer_Idx->len_header = c-d;
+
+	      c = src;
+	      d = c;
+	      if (tcp->csty & J2K_CP_CSTY_SOP) /* SOP marker */
+		{ 
+		  if ((*c) != 255 || (*(c+1) != 145)) {printf("Error : expected SOP marker [2] !!!\n"); }
+		  c += 6;
+		}
+	      bio_init_dec(c, src + len - c);
+	      
+	    }
+	}
+
+    for (bandno = 0; bandno < res->numbands; bandno++) {
+        tcd_band_t *band = &res->bands[bandno];
+        tcd_precinct_t *prc = &band->precincts[precno];
+        for (cblkno = 0; cblkno < prc->cw*prc->ch; cblkno++) {
+            tcd_cblk_t *cblk = &prc->cblks[cblkno];
+            tcd_seg_t *seg;
+            if (!cblk->numnewpasses) continue;
+            if (!cblk->numsegs) {
+                seg = &cblk->segs[cblk->numsegs++];
+                cblk->len = 0;
+            } else {
+                seg = &cblk->segs[cblk->numsegs-1];
+                if (seg->numpasses == seg->maxpasses) {
+                    seg++;
+                    cblk->numsegs++;
+                }
+            }
+            do {
+	      if (c + seg->newlen > src + len) return -999;
+                memcpy(cblk->data + cblk->len, c, seg->newlen);
+                if (seg->numpasses == 0) {
+                    seg->data = cblk->data + cblk->len;
+                }
+                c += seg->newlen;
+                cblk->len += seg->newlen;
+                seg->len += seg->newlen;
+                seg->numpasses += seg->numnewpasses;
+                cblk->numnewpasses -= seg->numnewpasses;
+                if (cblk->numnewpasses > 0) {
+                    seg++;
+                    cblk->numsegs++;
+                }
+            } while (cblk->numnewpasses > 0);
+        }
+    }
+    /* <INDEX> */
+    e = c-d;
+    layer_Idx->len = e;
+    /* </INDEX> */
+
+    return c-src;
+}
+
+void t2_init_info_packets(info_image_t *img, j2k_cp_t *cp)
+{
+  int compno, tileno, resno, precno, layno;
+
+  for(compno = 0; compno < img->Comp; compno++)
+    {
+      for(tileno = 0; tileno < img->tw*img->th; tileno++)
+	{
+	  info_tile_t *tile_Idx = &img->tile[tileno];
+	  info_compo_t *compo_Idx = &tile_Idx->compo[compno];
+	  for(resno = 0; resno < img->Decomposition + 1 ; resno++)
+	    {
+	      info_reso_t *reso_Idx = &compo_Idx->reso[resno];
+	      for (precno = 0; precno < img->tile[tileno].pw * img->tile[tileno].ph; precno++)
+		{
+		  info_prec_t *prec_Idx = &reso_Idx->prec[precno];
+		  for(layno = 0; layno < img->Layer ; layno++)
+		    {
+		      info_layer_t *layer_Idx = &prec_Idx->layer[layno];
+		      layer_Idx->offset = 0;        /* start position */
+		      layer_Idx->len_header = 0;    /* length         */
+		    }
+		}
+	    }
+	}
+    }
+}
+
+int t2_decode_packets(unsigned char *src, int len, j2k_image_t *img, j2k_cp_t *cp, int tileno, tcd_tile_t *tile, info_image_t *imgg) {
+    unsigned char *c = src;
+    pi_iterator_t *pi;
+    int pino, compno,e;
+    int partno;
+    info_tile_part_t *tile_part;
+    int position;
+    int length_read;
+    info_tile_t *tile_Idx;
+    info_compo_t *compo_Idx;
+    info_reso_t *reso_Idx;
+    info_prec_t *prec_Idx;
+    info_layer_t *layer_Idx;
+
+    t2_init_info_packets(imgg, cp); /* Initialize the packets information : LEN and OFFSET to 0 */
+
+    tile_Idx = &imgg->tile[tileno];
+    tile_Idx->num_packet = 0;
+    pi = pi_create(img, cp, tileno);
+    partno = 0;
+    tile_part = &tile_Idx->tile_parts[partno];
+    position = tile_part->end_header + 1;
+    length_read = 0;
+
+    for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++)
+      {
+	while (pi_next(&pi[pino])) 
+	  {   
+	    compo_Idx = &tile_Idx->compo[pi[pino].compno];
+	    reso_Idx = &compo_Idx->reso[pi[pino].resno];
+	    prec_Idx = &reso_Idx->prec[pi[pino].precno];
+	    layer_Idx = &prec_Idx->layer[pi[pino].layno];
+	    
+	    layer_Idx->offset = position;
+	    layer_Idx->offset_header = position;
+	    
+	    e = t2_decode_packet(c, src+len-c, tile, cp, &cp->tcps[tileno], pi[pino].compno, pi[pino].resno, pi[pino].precno, pi[pino].layno,layer_Idx);
+	    if (e == -999)
+	      {
+		break;
+	      } else
+		c += e;
+	    position += e;
+	    
+	    /* Update position in case of multiple tile-parts for a tile >> */
+	    length_read += e;
+	    if (length_read >= (tile_part->end_pos - tile_part->end_header))
+	      {
+		partno++;
+		tile_part = &tile_Idx->tile_parts[partno];
+		position = tile_part->end_header + 1;
+		length_read = 0;
+	      }
+	    /* << end_update */
+	    
+	    tile_Idx->num_packet++;
+	  }
+	
+	// FREE space memory taken by pi
+	for (compno = 0; compno < pi[pino].numcomps; compno++) 
+	  { 
+	    free(pi[pino].comps[compno].resolutions);
+	  } 
+	free(pi[pino].comps);
+      }
+    
+    free(pi[0].include);
+    free(pi);
+ 
+    if (e==-999)
+      return e;
+    else
+      {
+	imgg->num_packet_max=int_max(imgg->num_packet_max,tile_Idx->num_packet);
+	return c-src;
+      }
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/t2.h.svn-base ./indexer_JPIP/.svn/text-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/t2.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,46 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __T2_H
+#define __T2_H
+
+#include "tcd.h"
+#include "j2k.h"
+
+/*
+ * Decode the packets of a tile from a source buffer
+ * src: the source buffer
+ * len: length of the source buffer
+ * img: destination image
+ * cp: image coding parameters
+ * tileno: number that identifies the tile for which to decode the packets
+ * tile: tile for which to decode the packets
+ */
+int t2_decode_packets(unsigned char *src, int len, j2k_image_t *img, j2k_cp_t *cp, int tileno, tcd_tile_t *tile, info_image_t *imgg);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tcd.c.svn-base ./indexer_JPIP/.svn/text-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/tcd.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "tcd.h"
+#include "int.h"
+#include "t2.h"
+#include <setjmp.h>
+#include <float.h>
+#include <stdio.h>
+#include <time.h>
+#include <math.h>
+#include <stdlib.h>
+#include <string.h>
+
+static tcd_image_t tcd_image;
+
+static j2k_image_t *tcd_img;
+static j2k_cp_t *tcd_cp;
+
+extern jmp_buf j2k_error;
+
+void tcd_init(j2k_image_t *img, j2k_cp_t *cp, info_image_t *imgg) {
+    int tileno, compno, resno, bandno, precno, cblkno;
+    tcd_img=img;
+    tcd_cp=cp;
+    tcd_image.tw=cp->tw;
+    tcd_image.th=cp->th;
+    tcd_image.tiles=(tcd_tile_t*)malloc(cp->tw*cp->th*sizeof(tcd_tile_t));
+    for (tileno=0; tileno<cp->tw*cp->th; tileno++) {
+        j2k_tcp_t *tcp=&cp->tcps[tileno];
+        tcd_tile_t *tile=&tcd_image.tiles[tileno];
+        // cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000)
+        int p=tileno%cp->tw;  // si numerotation matricielle ..
+        int q=tileno/cp->tw;  // .. coordonnees de la tile (q,p) q pour ligne et p pour colonne
+	info_tile_t *tile_Idx=&imgg->tile[tileno]; // INDEX
+
+	// 4 borders of the tile rescale on the image if necessary
+        tile->x0=int_max(cp->tx0+p*cp->tdx, img->x0);
+        tile->y0=int_max(cp->ty0+q*cp->tdy, img->y0);
+        tile->x1=int_min(cp->tx0+(p+1)*cp->tdx, img->x1);
+        tile->y1=int_min(cp->ty0+(q+1)*cp->tdy, img->y1);
+	
+        tile->numcomps=img->numcomps;
+        tile->comps=(tcd_tilecomp_t*)malloc(img->numcomps*sizeof(tcd_tilecomp_t));
+        tile_Idx->compo=(info_compo_t*)malloc(img->numcomps*sizeof(info_compo_t)); // INDEX
+	for (compno=0; compno<tile->numcomps; compno++) {
+            j2k_tccp_t *tccp=&tcp->tccps[compno];
+            tcd_tilecomp_t *tilec=&tile->comps[compno];
+	    info_compo_t *compo_Idx=&tile_Idx->compo[compno]; // INDEX
+
+	    // border of each tile component (global)
+            tilec->x0=int_ceildiv(tile->x0, img->comps[compno].dx);
+            tilec->y0=int_ceildiv(tile->y0, img->comps[compno].dy);
+	    tilec->x1=int_ceildiv(tile->x1, img->comps[compno].dx);
+            tilec->y1=int_ceildiv(tile->y1, img->comps[compno].dy);
+	    
+            tilec->data=(int*)malloc(sizeof(int)*(tilec->x1-tilec->x0)*(tilec->y1-tilec->y0));
+            tilec->numresolutions=tccp->numresolutions;
+            tilec->resolutions=(tcd_resolution_t*)malloc(tilec->numresolutions*sizeof(tcd_resolution_t));
+	    compo_Idx->reso=(info_reso_t*)malloc(tilec->numresolutions*sizeof(info_reso_t)); // INDEX
+            for (resno=0; resno<tilec->numresolutions; resno++) {
+                int pdx, pdy;
+                int levelno=tilec->numresolutions-1-resno;
+                int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+                int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+                int cbgwidthexpn, cbgheightexpn;
+                int cblkwidthexpn, cblkheightexpn;
+                tcd_resolution_t *res=&tilec->resolutions[resno];
+		info_reso_t *res_Idx=&compo_Idx->reso[resno]; // INDEX
+		int precno_Idx; // INDEX
+
+		// border for each resolution level (global)
+                res->x0=int_ceildivpow2(tilec->x0, levelno);
+                res->y0=int_ceildivpow2(tilec->y0, levelno);
+                res->x1=int_ceildivpow2(tilec->x1, levelno);
+                res->y1=int_ceildivpow2(tilec->y1, levelno);
+		
+		res->numbands=resno==0?1:3;
+		// p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000)
+                if (tccp->csty&J2K_CCP_CSTY_PRT) {
+                    pdx=tccp->prcw[resno];
+                    pdy=tccp->prch[resno];
+		} else {
+                    pdx=15;
+                    pdy=15;
+                }
+		// p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000) 
+                tlprcxstart=int_floordivpow2(res->x0, pdx)<<pdx;
+                tlprcystart=int_floordivpow2(res->y0, pdy)<<pdy;
+                brprcxend=int_ceildivpow2(res->x1, pdx)<<pdx;
+                brprcyend=int_ceildivpow2(res->y1, pdy)<<pdy;
+                res->pw=(brprcxend-tlprcxstart)>>pdx;
+                res->ph=(brprcyend-tlprcystart)>>pdy;
+
+		// <INDEX>
+		imgg->tile[tileno].pw=res->pw;
+		imgg->tile[tileno].ph=res->ph;
+		
+		res_Idx->prec=(info_prec_t*)malloc(res->pw*res->ph*sizeof(info_prec_t));
+		for (precno_Idx=0;precno_Idx<res->pw*res->ph;precno_Idx++)
+		  {
+		    info_prec_t *prec_Idx = &res_Idx->prec[precno_Idx];
+		    prec_Idx->layer=(info_layer_t*)malloc(imgg->Layer*sizeof(info_layer_t));
+		  }
+		
+		imgg->pw=res->pw;  // old parser version
+		imgg->ph=res->ph;  // old parser version
+		imgg->pdx=1<<pdx;
+		imgg->pdy=1<<pdy;
+		// </INDEX>
+
+                if (resno==0) {
+                    tlcbgxstart=tlprcxstart;
+                    tlcbgystart=tlprcystart;
+                    brcbgxend=brprcxend;
+                    brcbgyend=brprcyend;
+                    cbgwidthexpn=pdx;
+                    cbgheightexpn=pdy;
+                } else {
+                    tlcbgxstart=int_ceildivpow2(tlprcxstart, 1);
+                    tlcbgystart=int_ceildivpow2(tlprcystart, 1);
+                    brcbgxend=int_ceildivpow2(brprcxend, 1);
+                    brcbgyend=int_ceildivpow2(brprcyend, 1);
+                    cbgwidthexpn=pdx-1;
+                    cbgheightexpn=pdy-1;
+                }
+
+                cblkwidthexpn=int_min(tccp->cblkw, cbgwidthexpn);
+                cblkheightexpn=int_min(tccp->cblkh, cbgheightexpn);
+
+                for (bandno=0; bandno<res->numbands; bandno++) {
+                    int x0b, y0b;
+                    tcd_band_t *band=&res->bands[bandno];
+                    band->bandno=resno==0?0:bandno+1;
+                    x0b=(band->bandno==1)||(band->bandno==3)?1:0;
+                    y0b=(band->bandno==2)||(band->bandno==3)?1:0;
+
+                    if (band->bandno==0) {
+		      // band border (global)
+		      band->x0=int_ceildivpow2(tilec->x0, levelno);
+		      band->y0=int_ceildivpow2(tilec->y0, levelno);
+		      band->x1=int_ceildivpow2(tilec->x1, levelno);
+		      band->y1=int_ceildivpow2(tilec->y1, levelno);
+                    } else {
+		      // band border (global)
+		      band->x0=int_ceildivpow2(tilec->x0-(1<<levelno)*x0b, levelno+1);
+		      band->y0=int_ceildivpow2(tilec->y0-(1<<levelno)*y0b, levelno+1);
+		      band->x1=int_ceildivpow2(tilec->x1-(1<<levelno)*x0b, levelno+1);
+		      band->y1=int_ceildivpow2(tilec->y1-(1<<levelno)*y0b, levelno+1);
+                    }
+
+                    band->precincts=(tcd_precinct_t*)malloc(res->pw*res->ph*sizeof(tcd_precinct_t));
+
+                    for (precno=0; precno<res->pw*res->ph; precno++) {
+                        int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+                        int cbgxstart=tlcbgxstart+(precno%res->pw)*(1<<cbgwidthexpn);
+                        int cbgystart=tlcbgystart+(precno/res->pw)*(1<<cbgheightexpn);
+                        int cbgxend=cbgxstart+(1<<cbgwidthexpn);
+                        int cbgyend=cbgystart+(1<<cbgheightexpn);
+                        tcd_precinct_t *prc=&band->precincts[precno];
+			// precinct size (global)
+                        prc->x0=int_max(cbgxstart, band->x0);
+                        prc->y0=int_max(cbgystart, band->y0);
+                        prc->x1=int_min(cbgxend, band->x1);
+                        prc->y1=int_min(cbgyend, band->y1);
+
+                        tlcblkxstart=int_floordivpow2(prc->x0, cblkwidthexpn)<<cblkwidthexpn;
+                        tlcblkystart=int_floordivpow2(prc->y0, cblkheightexpn)<<cblkheightexpn;
+                        brcblkxend=int_ceildivpow2(prc->x1, cblkwidthexpn)<<cblkwidthexpn;
+                        brcblkyend=int_ceildivpow2(prc->y1, cblkheightexpn)<<cblkheightexpn;
+                        prc->cw=(brcblkxend-tlcblkxstart)>>cblkwidthexpn;
+                        prc->ch=(brcblkyend-tlcblkystart)>>cblkheightexpn;
+
+                        prc->cblks=(tcd_cblk_t*)malloc(prc->cw*prc->ch*sizeof(tcd_cblk_t));
+
+                        prc->incltree=tgt_create(prc->cw, prc->ch);
+                        prc->imsbtree=tgt_create(prc->cw, prc->ch);
+
+                        for (cblkno=0; cblkno<prc->cw*prc->ch; cblkno++) {
+                            int cblkxstart=tlcblkxstart+(cblkno%prc->cw)*(1<<cblkwidthexpn);
+                            int cblkystart=tlcblkystart+(cblkno/prc->cw)*(1<<cblkheightexpn);
+                            int cblkxend=cblkxstart+(1<<cblkwidthexpn);
+                            int cblkyend=cblkystart+(1<<cblkheightexpn);
+                            tcd_cblk_t *cblk=&prc->cblks[cblkno];
+			    // code-block size (global)
+                            cblk->x0=int_max(cblkxstart, prc->x0);
+                            cblk->y0=int_max(cblkystart, prc->y0);
+                            cblk->x1=int_min(cblkxend, prc->x1);
+                            cblk->y1=int_min(cblkyend, prc->y1);
+                        }
+                    }
+                }
+            }
+        }
+    }
+}
+
+
+void tcd_free(j2k_image_t *img, j2k_cp_t *cp) {
+  int tileno, compno, resno, bandno, precno;
+  tcd_img=img;
+  tcd_cp=cp;
+  tcd_image.tw=cp->tw;
+  tcd_image.th=cp->th;
+  for (tileno=0; tileno<tcd_image.tw*tcd_image.th; tileno++) 
+    {
+      //  j2k_tcp_t *tcp=&cp->tcps[curtileno];
+      tcd_tile_t *tile=&tcd_image.tiles[tileno];
+      for (compno=0; compno<tile->numcomps; compno++) 
+	{
+	 tcd_tilecomp_t *tilec=&tile->comps[compno];
+	  for (resno=0; resno<tilec->numresolutions; resno++) 
+	    {
+	      tcd_resolution_t *res=&tilec->resolutions[resno];
+	      for (bandno=0; bandno<res->numbands; bandno++) 
+		{
+		 tcd_band_t *band=&res->bands[bandno];
+		  for (precno=0; precno<res->pw*res->ph; precno++) 
+		    {
+		     tcd_precinct_t *prc=&band->precincts[precno];
+		      
+		      if (prc->incltree!=NULL)
+			tgt_destroy(prc->incltree);
+		      if (prc->imsbtree!=NULL)
+			tgt_destroy(prc->imsbtree);
+		      free(prc->cblks);
+		    } // for (precno
+		  free(band->precincts);
+		} // for (bandno
+	    }	// for (resno
+	  free(tilec->resolutions);
+	}	// for (compno
+      free(tile->comps);
+    }	// for (tileno
+  free(tcd_image.tiles);
+}
+
+
+int tcd_decode_tile(unsigned char *src, int len, int tileno, info_image_t *imgg) {
+    int l;
+    int eof=0;
+    tcd_tile_t *tile;
+
+    tile = &tcd_image.tiles[tileno];
+
+    l = t2_decode_packets(src, len, tcd_img, tcd_cp, tileno, tile, imgg);
+
+    if (l==-999)
+      {
+	eof=1;
+	fprintf(stderr, "tcd_decode: incomplete bistream\n");
+      }
+    
+     if (eof) {
+       longjmp(j2k_error, 1);
+     }
+
+    l=1;
+    return l;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tcd.h.svn-base ./indexer_JPIP/.svn/text-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/tcd.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,137 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TCD_H
+#define __TCD_H
+
+#include "j2k.h"
+#include "tgt.h"
+
+typedef struct {
+    int numpasses;
+    int len;
+    unsigned char *data;
+    int maxpasses;
+    int numnewpasses;
+    int newlen;
+} tcd_seg_t;
+
+typedef struct {
+    int rate;
+    double distortiondec;
+} tcd_pass_t;
+
+typedef struct {
+    int numpasses;
+    int len;
+    unsigned char *data;
+} tcd_layer_t;
+
+typedef struct {
+    int x0, y0, x1, y1;
+    int numbps;
+    int numlenbits;
+    int len;
+    int numpasses;
+    int numnewpasses;
+    int numsegs;
+    tcd_seg_t segs[100];
+    unsigned char data[8192];
+    int numpassesinlayers;
+    tcd_layer_t layers[100];
+    int totalpasses;
+    tcd_pass_t passes[100];
+} tcd_cblk_t;
+
+typedef struct {
+    int x0, y0, x1, y1;
+    int cw, ch;
+    tcd_cblk_t *cblks;
+    tgt_tree_t *incltree;
+    tgt_tree_t *imsbtree;
+} tcd_precinct_t;
+
+typedef struct {
+    int x0, y0, x1, y1;
+    int bandno;
+    tcd_precinct_t *precincts;
+    int numbps;
+    int stepsize;
+} tcd_band_t;
+
+typedef struct {
+    int x0, y0, x1, y1;  
+  int previous_x0, previous_y0, previous_x1, previous_y1; // usefull for the DWT
+  int cas_col, cas_row; // usefull for the DWT
+    int pw, ph;
+    int numbands;
+    tcd_band_t bands[3];
+} tcd_resolution_t;
+
+typedef struct {
+    int x0, y0, x1, y1;
+  int previous_row, previous_col; // usefull for the DWT
+    int numresolutions;
+    tcd_resolution_t *resolutions;
+    int *data;
+} tcd_tilecomp_t;
+
+typedef struct {
+    int x0, y0, x1, y1;
+    int numcomps;
+  //int PPT;
+  //int len_ppt;
+    tcd_tilecomp_t *comps;
+} tcd_tile_t;
+
+typedef struct {
+    int tw, th;
+    tcd_tile_t *tiles;
+} tcd_image_t;
+
+/*
+ * Initialize the tile coder/decoder
+ * img: raw image
+ * cp: coding parameters
+ * imgg: creation of index file
+ */
+
+void tcd_init(j2k_image_t *img, j2k_cp_t *cp, info_image_t *imgg);
+
+void tcd_free(j2k_image_t *img, j2k_cp_t *cp);
+
+/*
+ * Decode a tile from a buffer into a raw image
+ * src: source buffer
+ * len: length of the source buffer
+ * tileno: number that identifies the tile that will be decoded
+ * imgg : Structure for index file
+ */
+int tcd_decode_tile(unsigned char *src, int len, int tileno, info_image_t *imgg);
+
+#endif
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tgt.c.svn-base ./indexer_JPIP/.svn/text-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/tgt.c.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,170 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "tgt.h"
+#include "bio.h"
+#include <stdlib.h>
+#include <stdio.h>
+
+/// <summary>
+/// Reset tag-tree.
+/// </summary>
+void tgt_reset(tgt_tree_t *tree)
+{
+    int i;
+    for (i=0; i<tree->numnodes; i++) {
+        tree->nodes[i].value=999;
+        tree->nodes[i].low=0;
+        tree->nodes[i].known=0;
+    }
+}
+
+/// <summary>
+/// Create tag-tree.
+/// </summary>
+tgt_tree_t *tgt_create(int numleafsh, int numleafsv)
+{
+    int nplh[32];
+    int nplv[32];
+    tgt_node_t *node;
+    tgt_node_t *parentnode;
+    tgt_node_t *parentnode0;
+    tgt_tree_t *tree;
+    int i, j, k;
+    int numlvls;
+    int n;
+
+    tree=(tgt_tree_t*)malloc(sizeof(tgt_tree_t));
+    tree->numleafsh=numleafsh;
+    tree->numleafsv=numleafsv;
+
+    numlvls=0;
+    nplh[0]=numleafsh;
+    nplv[0]=numleafsv;
+    tree->numnodes=0;
+    do {
+        n=nplh[numlvls]*nplv[numlvls];
+        nplh[numlvls+1]=(nplh[numlvls]+1)/2;
+        nplv[numlvls+1]=(nplv[numlvls]+1)/2;
+        tree->numnodes+=n;
+        ++numlvls;
+    } while (n>1);
+
+    tree->nodes=(tgt_node_t*)malloc(tree->numnodes*sizeof(tgt_node_t));
+
+    node=tree->nodes;
+    parentnode=&tree->nodes[tree->numleafsh*tree->numleafsv];
+    parentnode0=parentnode;
+
+    for (i=0; i<numlvls-1; ++i) {
+        for (j=0; j<nplv[i]; ++j) {
+            k=nplh[i];
+            while (--k>=0) {
+                node->parent=parentnode;
+                ++node;
+                if (--k >= 0) {
+                    node->parent=parentnode;
+                    ++node;
+                }
+                ++parentnode;
+            }
+            if ((j&1)||j==nplv[i]-1) {
+                parentnode0=parentnode;
+            } else {
+                parentnode=parentnode0;
+                parentnode0+=nplh[i];
+            }
+        }
+    }
+    node->parent=0;
+
+    tgt_reset(tree);
+
+    return tree;
+}
+
+/// <summary>
+/// Destroy tag-tree.
+/// </summary>
+void tgt_destroy(tgt_tree_t *t) {
+    free(t->nodes);
+    free(t);
+}
+
+/// <summary>
+/// Set the value of a leaf of the tag-tree.
+/// </summary>
+void tgt_setvalue(tgt_tree_t *tree, int leafno, int value) {
+    tgt_node_t *node;
+    node=&tree->nodes[leafno];
+    while (node && node->value>value) {
+        node->value=value;
+        node=node->parent;
+    }
+}
+
+/// <summary>
+/// Decode the value of a leaf of the tag-tree.
+/// </summary>
+int tgt_decode(tgt_tree_t *tree, int leafno, int threshold)
+{
+    tgt_node_t *stk[31];
+    tgt_node_t **stkptr;
+    tgt_node_t *node;
+    int low;
+
+    stkptr=stk;
+    node=&tree->nodes[leafno];
+    while (node->parent) {
+        *stkptr++=node;
+        node=node->parent;
+    }
+
+    low=0;
+    for (;;) {
+        if (low>node->low) {
+            node->low=low;
+        } else {
+            low=node->low;
+        }
+        while (low<threshold && low<node->value) {
+            if (bio_read(1)) {
+                node->value=low;
+            } else {
+                ++low;
+            }
+        }
+        node->low=low;
+        if (stkptr==stk) {
+            break;
+        }
+        node=*--stkptr;
+    }
+
+    return (node->value<threshold)?1:0;
+}
diff -urN /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tgt.h.svn-base ./indexer_JPIP/.svn/text-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/indexer_JPIP/.svn/text-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./indexer_JPIP/.svn/text-base/tgt.h.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,80 @@
+/*
+ * Copyright (c) 2001-2002, David Janssens
+ * Copyright (c) 2003, Yannick Verschueren
+ * Copyright (c) 2003,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TGT_H
+#define __TGT_H
+
+typedef struct tgt_node {
+	struct tgt_node *parent;
+	int value;
+	int low;
+	int known;
+} tgt_node_t;
+
+typedef struct {
+	int numleafsh;
+	int numleafsv;
+	int numnodes;
+	tgt_node_t *nodes;
+} tgt_tree_t;
+
+/*
+ * Create a tag-tree
+ * numleafsh: width of the array of leafs of the tree
+ * numleafsv: height of the array of leafs of the tree
+ */
+tgt_tree_t *tgt_create(int numleafsh, int numleafsv);
+
+/*
+ * Reset a tag-tree (set all leafs to 0)
+ * tree: tag-tree to reset
+ */
+void tgt_reset(tgt_tree_t *tree);
+
+/*
+ * Destroy a tag-tree, liberating memory
+ * tree: tag-tree to destroy
+ */
+void tgt_destroy(tgt_tree_t *tree);
+
+/*
+ * Set the value of a leaf of a tag-tree
+ * tree: tag-tree to modify
+ * leafno: number that identifies the leaf to modify
+ * value: new value of the leaf
+ */
+void tgt_setvalue(tgt_tree_t *tree, int leafno, int value);
+
+/*
+ * Decode the value of a leaf of the tag-tree up to a given threshold
+ * leafno: number that identifies the leaf to decode
+ * threshold: threshold to use when decoding value of the leaf
+ */
+int tgt_decode(tgt_tree_t *tree, int leafno, int threshold);
+
+#endif
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/CMakeLists.txt ./j2kviewer/src/CMakeLists.txt
--- /home/robin/sldeb/trunk/j2kviewer/src/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,8 @@
+PROJECT(j2kviewer Java)
+
+ADD_LIBRARY(j2kviewer
+  Exec.java
+  ImageViewer.java
+  MML.java
+  PgmImage.java
+)
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/all-wcprops ./j2kviewer/src/.svn/all-wcprops
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/all-wcprops	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,35 @@
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/442/trunk/j2kviewer/src
+END
+Exec.java
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/19/trunk/j2kviewer/src/Exec.java
+END
+ImageViewer.java
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/19/trunk/j2kviewer/src/ImageViewer.java
+END
+MML.java
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/19/trunk/j2kviewer/src/MML.java
+END
+PgmImage.java
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/19/trunk/j2kviewer/src/PgmImage.java
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/442/trunk/j2kviewer/src/CMakeLists.txt
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/entries ./j2kviewer/src/.svn/entries
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,93 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/j2kviewer/src
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T14:56:00.695046Z
+442
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+Exec.java
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+3005d1cac104f98258c2248d16a0de48
+2004-02-17T16:33:43.000000Z
+19
+lugan
+has-props
+
+ImageViewer.java
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+08edd1ffe532a8dad43f6d88c0a816fb
+2004-02-17T16:33:43.000000Z
+19
+lugan
+has-props
+
+MML.java
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+9f7ece72e69c71d0f910d61457dff4ac
+2004-02-17T16:33:43.000000Z
+19
+lugan
+has-props
+
+PgmImage.java
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+50c21a78a62cceb87004c4ca10aa99b6
+2004-02-17T16:33:43.000000Z
+19
+lugan
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+f4d4fd8d606e2781c252da81211787aa
+2007-09-06T14:56:00.695046Z
+442
+gdcm
+has-props
+
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/format ./j2kviewer/src/.svn/format
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/format	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/CMakeLists.txt.svn-base ./j2kviewer/src/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/Exec.java.svn-base ./j2kviewer/src/.svn/prop-base/Exec.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/Exec.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/prop-base/Exec.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/ImageViewer.java.svn-base ./j2kviewer/src/.svn/prop-base/ImageViewer.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/ImageViewer.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/prop-base/ImageViewer.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/MML.java.svn-base ./j2kviewer/src/.svn/prop-base/MML.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/MML.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/prop-base/MML.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/PgmImage.java.svn-base ./j2kviewer/src/.svn/prop-base/PgmImage.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/prop-base/PgmImage.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/prop-base/PgmImage.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/CMakeLists.txt.svn-base ./j2kviewer/src/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,8 @@
+PROJECT(j2kviewer Java)
+
+ADD_LIBRARY(j2kviewer
+  Exec.java
+  ImageViewer.java
+  MML.java
+  PgmImage.java
+)
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/Exec.java.svn-base ./j2kviewer/src/.svn/text-base/Exec.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/Exec.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/text-base/Exec.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,212 @@
+import java.io.*;
+
+// This appears in Core Web Programming from
+// Prentice Hall Publishers, and may be freely used
+// or adapted. 1997 Marty Hall, hall@apl.jhu.edu.
+
+/** A class that eases the pain of running external
+ *  processes from applications.
+ *  Lets you run a program three ways:
+ *  <OL>
+ *     <LI><B>exec</B>: Execute the command, returning
+ *         immediately even if the command is still
+ *         running. This would be appropriate
+ *         for printing a file.
+ *     <LI><B>execWait</B>: Execute the command, but
+ *         don't return until the command finishes.
+ *         This would be appropriate for
+ *         sequential commands where the first depends
+ *         on the second having finished (e.g.
+ *         <CODE>javac</CODE> followed by
+ *         <CODE>java</CODE>).
+ *     <LI><B>execPrint</B>: Execute the command and
+ *         print the output. This would be appropriate
+ *         for the UNIX command <CODE>ls</CODE>.
+ *  </OL>
+ *  Note that the PATH is not taken into account,
+ *  so  you must specify the <B>full</B> pathname to
+ *  the command, and shell builtin commands
+ *  will not work. For instance, on Unix the above
+ *  three examples might look like:
+ *  <OL>
+ *    <LI><PRE>Exec.exec("/usr/ucb/lpr Some-File");</PRE>
+ *    <LI><PRE>
+ *        Exec.execWait("/usr/local/bin/javac Foo.java");
+ *        Exec.execWait("/usr/local/bin/java Foo");
+ *        </PRE>
+ *    <LI><PRE>Exec.execPrint("/usr/bin/ls -al");</PRE>
+ *  </OL>
+ *
+ * @author Marty Hall
+ *  (<A HREF="mailto:hall@apl.jhu.edu">
+ *   hall@apl.jhu.edu</A>)
+ * @version 1.0 1997
+ */
+
+public class Exec {
+  //----------------------------------------------------
+  
+  private static boolean verbose = true;
+
+  /** Determines if the Exec class should print which
+   *  commands are being executed, and print error
+   *  messages if a problem is found. Default is true.
+   *
+   * @param verboseFlag true: print messages.
+   *        false: don't.
+   */
+  
+  public static void setVerbose(boolean verboseFlag) {
+    verbose = verboseFlag;
+  }
+
+  /** Will Exec print status messages? */
+  
+  public static boolean getVerbose() {
+    return(verbose);
+  }
+  
+  //----------------------------------------------------
+  /** Starts a process to execute the command. Returns
+   *  immediately, even if the new process is still
+   *  running.
+   *
+   * @param command The <B>full</B> pathname of the
+   *        command to be executed. No shell builtins
+   *        (e.g. "cd") or shell meta-chars (e.g. ">")
+   *        allowed.
+   * @return false if a problem is known to occur, but
+   *         since this returns immediately, problems
+   *         aren't usually found in time.
+   *         Returns true otherwise.
+   */
+  
+  public static boolean exec(String command) {
+    return(exec(command, false, false));
+  }
+  
+  //----------------------------------------------------
+  /** Starts a process to execute the command. Waits
+   *  for the process to finish before returning.
+   *
+   * @param command The <B>full</B> pathname of the
+   *        command to be executed. No shell builtins
+   *        or shell meta-chars allowed.
+   * @return false if a problem is known to occur,
+   *         either due to an exception or from the
+   *         subprocess returning a non-zero value.
+   *         Returns true otherwise.
+   */
+  
+  public static boolean execWait(String command) {
+    return(exec(command, false, true));
+  }
+  
+  //----------------------------------------------------
+  /** Starts a process to execute the command. Prints
+   *  all output the command gives.
+   *
+   * @param command The <B>full</B> pathname of the
+   *        command to be executed. No shell builtins
+   *        or shell meta-chars allowed.
+   * @return false if a problem is known to occur,
+   *         either due to an exception or from the
+   *         subprocess returning a non-zero value.
+   *         Returns true otherwise.
+   */
+  
+  public static boolean execPrint(String command) {
+    return(exec(command, true, false));
+  }
+  
+  //----------------------------------------------------
+  // This creates a Process object via
+  // Runtime.getRuntime.exec(). Depending on the
+  // flags, it may call waitFor on the process
+  // to avoid continuing until the process terminates,
+  // or open an input stream from the process to read
+  // the results.
+
+  private static boolean exec(String command,
+                              boolean printResults,
+                              boolean wait) {
+    if (verbose) {
+      printSeparator();
+      System.out.println("Executing '" + command + "'.");
+    }
+    try {
+      // Start running command, returning immediately.
+      Process p  = Runtime.getRuntime().exec(command);
+      
+      // Print the output. Since we read until
+      // there is no more input, this causes us
+      // to wait until the process is completed
+      if(printResults) {
+        BufferedInputStream buffer =
+          new BufferedInputStream(p.getInputStream());
+        DataInputStream commandResult =
+          new DataInputStream(buffer);
+        String s = null;
+        try {
+          while ((s = commandResult.readLine()) != null)
+            System.out.println("Output: " + s);
+          commandResult.close();
+          if (p.exitValue() != 0) {
+            if (verbose)
+              printError(command +
+                         " -- p.exitValue() != 0");
+            return(false);
+          }
+        // Ignore read errors; they mean process is done
+        } catch (Exception e) {}
+        
+      // If you don't print the results, then you
+      // need to call waitFor to stop until the process
+      // is completed
+      } else if (wait) {
+        try {
+          System.out.println(" ");
+          int returnVal = p.waitFor();
+          if (returnVal != 0) {
+            if (verbose)
+              printError(command);
+            return(false);
+          }
+        } catch (Exception e) {
+          if (verbose)
+            printError(command, e);
+          return(false);
+        }
+      }
+    } catch (Exception e) {
+      if (verbose)
+        printError(command, e);
+      return(false);
+    }
+    return(true);
+  }
+  
+  //----------------------------------------------------
+
+  private static void printError(String command,
+                                 Exception e) {
+    System.out.println("Error doing exec(" +
+                       command + "): " + e.getMessage());
+    System.out.println("Did you specify the full " +
+                       "pathname?");
+  }
+
+  private static void printError(String command) {
+    System.out.println("Error executing '" +
+                       command + "'.");
+  }
+    
+  //----------------------------------------------------
+
+  private static void printSeparator() {
+    System.out.println
+      ("==============================================");
+  }
+  
+  //----------------------------------------------------
+}
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/ImageViewer.java.svn-base ./j2kviewer/src/.svn/text-base/ImageViewer.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/ImageViewer.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/text-base/ImageViewer.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,222 @@
+import java.awt.*;
+import java.awt.event.*;
+import javax.swing.*;
+import java.awt.image.*;
+import java.awt.geom.*;
+import java.net.URL;
+import javax.swing.border.*;
+import java.util.*;
+import java.io.*;
+
+public class ImageViewer extends JApplet
+{
+  private class zoomLevel {
+    int x1, y1, x2, y2, zf;
+    
+    zoomLevel() {}
+    zoomLevel(zoomLevel zl)
+    {
+      x1 = zl.x1;
+      y1 = zl.y1;
+      x2 = zl.x2;
+      y2 = zl.y2;
+      zf = zl.zf;
+    }
+  }
+  
+  private BufferedImage bi;
+  private Graphics2D big;
+  private MML myMML;
+  private int iw, ih;
+  private int selected = 0, imgId;
+  private Image img;
+  private PgmImage pgm = new PgmImage();
+  private String cmdline = new String();
+  private static String hostname;
+  private static boolean isApplet = true;
+  private boolean fullRefresh = false;
+  private Point offset = new Point(0,0);
+  private zoomLevel zl = new zoomLevel();
+  private Rectangle rect = new Rectangle();
+  private Stack zoomStack = new Stack();
+  private static String j2kfilename;
+
+  public int getX()      { return offset.x; }
+  public int getY()      { return offset.y; }
+  public int getWidth()  { return iw; }
+  public int getHeight() { return ih; }
+  
+  public void destroy()
+  {
+  }
+  
+  public void zoomIn()
+  {
+    Dimension asz = this.getSize();
+    int maxzf = 3;
+    int coef = 1;
+    int r;
+    
+    cmdline = 
+      "/bin/sh get.sh " + j2kfilename + " " + iw
+      + " " + ih + " " + rect.x + " " + rect.y + " "
+      + rect.width + " " + rect.height;
+    Exec.execPrint(cmdline);
+
+    rect.x = rect.y = rect.width = rect.height = 0;
+
+    img = pgm.open("out.pgm");
+    
+    iw = img.getWidth(this);
+    ih = img.getHeight(this);
+    bi = new BufferedImage(iw, ih, BufferedImage.TYPE_INT_RGB);
+    big = bi.createGraphics();
+    selected = 0;
+    fullRefresh = true;
+    repaint();
+  }
+
+  public void zoomOut()
+  {
+  }
+
+  public void init()
+  {
+    String str;
+    int port;
+
+    imgId = 4;
+    if (isApplet && (((hostname = this.getParameter("hostname")) == null)
+		    || hostname.equals("")))
+      hostname = "localhost";
+    if (!isApplet || ((str = this.getParameter("cmdPort")) == null)) {
+      port = 3000;
+    } else {
+      port = new Integer(str).intValue();
+    }
+    
+    this.setSize(512, 512);
+    Dimension asz = this.getSize();
+    zl.x2 = asz.width;
+    zl.y2 = asz.height;
+    
+    cmdline = 
+      "/bin/sh get.sh " + j2kfilename + " " + asz.width
+      + " " + asz.height + " " + zl.x1 + " " + zl.y1 + " "
+      + zl.x2 + " " + zl.y2;
+    Exec.execPrint(cmdline);
+    img = pgm.open("out.pgm");
+    
+    iw = img.getWidth(this);
+    ih = img.getHeight(this);
+    
+    setBackground(Color.black);
+    bi = new BufferedImage(iw, ih, BufferedImage.TYPE_INT_RGB);
+    big = bi.createGraphics();
+    myMML = new MML(this);
+    addMouseListener(myMML);
+    addMouseMotionListener(myMML);
+  }
+  
+  public void setSelected(int state)
+  {
+    if (state != selected) {
+      selected = state;
+      repaint();
+    }
+  }
+  
+  public boolean isInsideRect(int x, int y)
+  {
+    return rect.contains(x - offset.x, y - offset.y);
+  }
+
+  public void setRGeom(int x1, int y1, int x2, int y2)
+  {
+    rect.x = Math.min(x1,x2) - offset.x;
+    rect.y = Math.min(y1,y2) - offset.y;
+    rect.width = Math.abs(x2-x1);
+    rect.height = Math.abs(y2-y1);
+  }
+
+  public void paint(Graphics g)
+  {
+    Graphics2D g2 = (Graphics2D) g;
+    Dimension asz = this.getSize();
+
+    if (fullRefresh) {
+      g2.clearRect(0, 0, asz.width, asz.height);
+      fullRefresh = false;
+    }
+    g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,
+                        RenderingHints.VALUE_ANTIALIAS_ON);
+    g2.setRenderingHint(RenderingHints.KEY_RENDERING,
+                        RenderingHints.VALUE_RENDER_QUALITY);
+    big.setColor(Color.black);
+    offset.x = (int) (asz.width  - iw) / 2;
+    offset.y = (int) (asz.height - ih) / 2;
+    big.drawImage(img, 0, 0, this);
+    big.setPaint(Color.red);
+    if ((rect.width > 0) && (rect.height > 0))
+      big.draw(rect);
+    if (selected == 1)
+      shadeExt(big, 0, 0, 0, 64);
+    else if (selected == 2) {
+      shadeExt(big, 0, 0, 0, 255);
+      selected = 1;
+    }
+    g2.drawImage(bi, offset.x, offset.y, this);
+  }
+
+  private void shadeRect(Graphics2D g2, int r, int g, int b, int a)
+  {
+    g2.setPaint(new Color(r, g, b, a));
+    g2.fillRect(rect.x + 1, rect.y + 1, rect.width - 1, rect.height - 1);
+  }
+  
+  private void shadeExt(Graphics2D g2, int r, int g, int b, int a)
+  {
+    g2.setPaint(new Color(r, g, b, a));
+    g2.fillRect(0, 0, iw, rect.y); /* _N_ */
+    g2.fillRect(rect.x + rect.width + 1, rect.y,
+    		iw - rect.x - rect.width - 1, rect.height + 1); /* E */
+    g2.fillRect(0, rect.y, rect.x, rect.height + 1); /* W */
+    g2.fillRect(0, rect.y + rect.height + 1,
+    		iw, ih - rect.y - rect.height - 1); /* _S_ */
+  }
+
+  protected URL getURL(String filename)
+  {
+    URL codeBase = this.getCodeBase();
+    URL url = null;
+
+    try {
+      url = new URL(codeBase, filename);
+    } catch (java.net.MalformedURLException e) {
+      System.out.println("Couldn't create image: badly specified URL");
+      return null;
+    }
+
+    return url;
+  }
+
+  public static void main(String s[])
+  {
+    if (s.length > 0)
+      j2kfilename = s[0];
+    else
+      j2kfilename = "girl";
+      System.out.println(j2kfilename);
+    isApplet = false;
+    JFrame f = new JFrame("ImageViewer");
+    f.addWindowListener(new WindowAdapter() {
+        public void windowClosing(WindowEvent e) {System.exit(0);}
+    });
+    JApplet applet = new ImageViewer();
+    f.getContentPane().add("Center", applet);
+    applet.init();
+    f.pack();
+    f.setSize(new Dimension(550,550));
+    f.show();
+  }
+}
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/MML.java.svn-base ./j2kviewer/src/.svn/text-base/MML.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/MML.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/text-base/MML.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,85 @@
+import java.awt.event.*;
+
+class MML implements MouseMotionListener, MouseListener
+{
+  public void mouseExited(MouseEvent e) {}
+  public void mouseEntered(MouseEvent e) {}
+  public void mouseClicked(MouseEvent e) {}
+  
+  private ImageViewer applet;
+  private int x1, y1, x2, y2, zf, btn;
+  private boolean zoomrq;
+  
+  public MML(ImageViewer iv)
+  {
+    x1 = y1 = -1;
+    applet = iv;
+    zoomrq = false;
+    zf = 0;
+  }
+  
+  private boolean isInside(int x, int y)
+  {
+    x -= applet.getX();
+    y -= applet.getY();
+    return (x >= 0) && (x < applet.getWidth())
+        && (y >= 0) && (y < applet.getHeight());
+  }
+
+  public void mousePressed(MouseEvent e)
+  {
+    btn = e.getButton();
+    if (applet.isInsideRect(e.getX(), e.getY())) {
+      applet.setSelected(2);
+      applet.repaint();
+      zoomrq = true;
+    } else {
+      applet.setRGeom(0, 0, 0, 0);
+      applet.setSelected(0);
+      applet.repaint();
+      x1 = y1 = -1;
+    }
+  }
+  
+  public void mouseReleased(MouseEvent e)
+  {
+    if (zoomrq && (e.getButton() == 1)) {
+      applet.zoomIn();
+      zoomrq = false;
+    } else if (e.getButton() == 3) {
+      applet.zoomOut();
+      zoomrq = false;
+    }
+  }
+
+  public void mouseMoved(MouseEvent e)
+  {
+    applet.setSelected(applet.isInsideRect(e.getX(), e.getY()) ? 1 : 0);
+  }
+  
+  public void mouseDragged(MouseEvent e)
+  {
+    String str;
+    
+    if (btn == 1) {
+      x2 = e.getX();
+      y2 = e.getY();
+
+      applet.setSelected(0);
+      zoomrq = false;
+
+      if (isInside(x2, y2)) {
+	str = "[IN ]";
+	if (x1 == -1) {
+          x1 = x2;
+	  y1 = y2;
+	} else {
+          applet.setRGeom(x1, y1, x2, y2);
+	  applet.repaint();
+	}
+      } else {
+	str = "[OUT]";
+      }
+    }    
+  }
+}
diff -urN /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/PgmImage.java.svn-base ./j2kviewer/src/.svn/text-base/PgmImage.java.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/src/.svn/text-base/PgmImage.java.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/src/.svn/text-base/PgmImage.java.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,93 @@
+import java.awt.*;
+import java.awt.image.*;
+import java.net.*;
+import java.io.*;
+import java.util.regex.*;
+
+class PgmImage extends Component
+{
+  private Socket s;
+  private BufferedReader in;
+  private int x, y;
+  
+  PgmImage()
+  {
+  }
+  
+  private String read()
+  {
+    try { return in.readLine(); }
+    catch (IOException e) {
+      e.printStackTrace();
+      return null;
+    }
+  }
+  
+  public Image open(String filename)
+  {
+    String  str;
+    Pattern pat;
+    Matcher mat;
+    int bytes, width, height, depth;
+    FileInputStream fis;
+    
+    try {
+      in  = new BufferedReader(
+              new InputStreamReader(
+	        fis = new FileInputStream(
+		  new File(filename))));
+
+      pat = Pattern.compile("^P5$");
+      mat = pat.matcher(str = read());
+      mat.matches();
+      pat = Pattern.compile("^(\\d+) (\\d+)$");
+      mat = pat.matcher(str = read());
+      mat.matches();
+      x = new Integer(mat.group(1)).intValue();
+      y = new Integer(mat.group(2)).intValue();
+      width  = x;
+      height = y;
+      depth  = 1;
+      pat = Pattern.compile("^255$");
+      mat = pat.matcher(str = read());
+      mat.matches();
+      bytes = x*y;
+      char[] buf = new char[bytes];
+      int r, offset = 0;
+      while (bytes > 0) {
+	try { r = in.read(buf, offset, bytes); offset += r; bytes -= r; }
+	catch (IOException e) { e.printStackTrace(); }
+      }
+      int[] buf2 = new int[buf.length];
+      if (depth == 3) {
+	for (int i = 0; i < buf.length/3; ++i)
+	  buf2[i] = 0xFF << 24 | buf[3*i] << 16 | buf[3*i+1] << 8 | buf[3*i+2];
+      } else {
+	for (int i = 0; i < buf.length; ++i)
+	  buf2[i] = 0xFF << 24 | buf[i] << 16 | buf[i] << 8 | buf[i];
+      }
+      fis.close();
+      return createImage(new MemoryImageSource(width, height, buf2, 0, width));
+    } catch (IOException e) { e.printStackTrace(); }
+    return null;
+  }
+
+  public void close()
+  {
+  }
+  
+  public boolean bye()
+  {
+    return true;
+  }
+  
+  public int getXOffset()
+  {
+    return x;
+  }
+  
+  public int getYOffset()
+  {
+    return y;
+  }
+}
diff -urN /home/robin/sldeb/trunk/j2kviewer/.svn/all-wcprops ./j2kviewer/.svn/all-wcprops
--- /home/robin/sldeb/trunk/j2kviewer/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/.svn/all-wcprops	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,11 @@
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/442/trunk/j2kviewer
+END
+build.xml
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/19/trunk/j2kviewer/build.xml
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/.svn/entries ./j2kviewer/.svn/entries
--- /home/robin/sldeb/trunk/j2kviewer/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,44 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/j2kviewer
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T14:56:00.695046Z
+442
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+src
+dir
+
+build.xml
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+1d91ee4b59a2d2ba8db153bd36120c9f
+2004-02-17T16:33:43.000000Z
+19
+lugan
+has-props
+
diff -urN /home/robin/sldeb/trunk/j2kviewer/.svn/format ./j2kviewer/.svn/format
--- /home/robin/sldeb/trunk/j2kviewer/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/.svn/format	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/j2kviewer/.svn/prop-base/build.xml.svn-base ./j2kviewer/.svn/prop-base/build.xml.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/.svn/prop-base/build.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/.svn/prop-base/build.xml.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/j2kviewer/.svn/text-base/build.xml.svn-base ./j2kviewer/.svn/text-base/build.xml.svn-base
--- /home/robin/sldeb/trunk/j2kviewer/.svn/text-base/build.xml.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./j2kviewer/.svn/text-base/build.xml.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,35 @@
+<project name="seb_j2kviewer" default="dist" basedir=".">
+  <description>Seb's J2K viewer</description>
+  <property name="src"   location="src"  />
+  <property name="build" location="build"/>
+  <property name="dist"  location="dist" />
+
+  <target name="init">
+    <tstamp/>
+    <mkdir dir="${build}"/>
+  </target>
+  <target name="compile" depends="init">
+    <javac srcdir="${src}" destdir="${build}"/>
+  </target>
+  <target name="dist" depends="compile">
+    <mkdir dir="${dist}"/>
+    <jar jarfile="${dist}/seb_j2kviewer-${DSTAMP}.jar"
+         basedir="${build}" manifest="${dist}/manifest.txt"/>
+    <exec dir="${dist}" executable="ln">
+      <arg line="-sf seb_j2kviewer-${DSTAMP}.jar seb_j2kviewer.jar"/>
+    </exec>
+  </target>
+  <target name="clean">
+    <delete dir="${build}"/>
+    <delete dir="${dist}"/>
+  </target>
+  <target name="test" depends="dist">
+    <exec executable="appletviewer"><arg line="dist.html"/></exec>
+  </target>
+  <target name="build_test" depends="compile">
+    <exec executable="appletviewer"><arg line="compile.html"/></exec>
+  </target>
+  <target name="build_testj" depends="compile">
+    <exec executable="java"><arg line="-classpath build ImageViewer girl"/></exec>
+  </target>
+</project>
diff -urN /home/robin/sldeb/trunk/jp3d/CMakeLists.txt ./jp3d/CMakeLists.txt
--- /home/robin/sldeb/trunk/jp3d/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,11 @@
+# Linux makefile for OpenJPEG
+
+#VER_MAJOR = 1
+#VER_MINOR = 0.0
+
+SUBDIRS(
+  libjp3dvm
+  codec
+)
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/CMakeLists.txt ./jp3d/codec/CMakeLists.txt
--- /home/robin/sldeb/trunk/jp3d/codec/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/CMakeLists.txt	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,53 @@
+# Build the demo app, small examples
+
+# First thing define the common source:
+SET(common_SRCS
+  convert.c
+  )
+# Then check if getopt is present:
+INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
+SET(DONT_HAVE_GETOPT 1)
+IF(UNIX) #I am pretty sure only *nix sys have this anyway
+  CHECK_INCLUDE_FILE("getopt.h" CMAKE_HAVE_GETOPT_H)
+  # Seems like we need the contrary:
+  IF(CMAKE_HAVE_GETOPT_H)
+    SET(DONT_HAVE_GETOPT 0)
+  ENDIF(CMAKE_HAVE_GETOPT_H)
+ENDIF(UNIX)
+
+# If not getopt was found then add it to the lib:
+IF(DONT_HAVE_GETOPT)
+  ADD_DEFINITIONS(-DDONT_HAVE_GETOPT)
+  SET(common_SRCS
+    ${common_SRCS}
+    compat/getopt.c
+  )
+ENDIF(DONT_HAVE_GETOPT)
+
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${CMAKE_CURRENT_SOURCE_DIR}/../libjp3dvm
+  )
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+#FIND_PACKAGE(TIFF REQUIRED)
+
+# Loop over all executables:
+FOREACH(exe jp3d_to_volume volume_to_jp3d)
+  ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
+  TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjp3dvm) # ${TIFF_LIBRARIES})
+  # On unix you need to link to the math library:
+  IF(UNIX)
+    TARGET_LINK_LIBRARIES(${exe} m)
+  ENDIF(UNIX)
+  # Install exe
+  INSTALL_TARGETS(/bin/ ${exe})
+ENDFOREACH(exe)
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/dirent.h ./jp3d/codec/dirent.h
--- /home/robin/sldeb/trunk/jp3d/codec/dirent.h	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/dirent.h	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,676 @@
+/*
+ * uce-dirent.h - operating system independent dirent implementation
+ * 
+ * Copyright (C) 1998-2002  Toni Ronkko
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * 
+ * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
+ *
+ * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
+ *
+ * $Log: uce-dirent.h,v $
+ * Revision 1.7  2002/05/13 10:48:35  tr
+ * embedded some source code directly to the header so that no source
+ * modules need to be included in the MS Visual C project using the
+ * interface, removed all the dependencies to other headers of the `uce'
+ * library so that the header can be made public
+ *
+ * Revision 1.6  2002/04/12 16:22:04  tr
+ * Unified Compiling Environment (UCE) replaced `std' library
+ *
+ * Revision 1.5  2001/07/20 16:33:40  tr
+ * moved to `std' library and re-named defines accordingly
+ *
+ * Revision 1.4  2001/07/10 16:47:18  tronkko
+ * revised comments
+ *
+ * Revision 1.3  2001/01/11 13:16:43  tr
+ * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
+ *
+ * Revision 1.2  2000/10/08 16:00:41  tr
+ * copy of FreeBSD man page
+ *
+ * Revision 1.1  2000/07/10 05:53:16  tr
+ * Initial revision
+ *
+ * Revision 1.2  1998/07/19 18:29:14  tr
+ * Added error reporting capabilities and some asserts.
+ *
+ * Revision 1.1  1998/07/04 16:27:51  tr
+ * Initial revision
+ *
+ * 
+ * MSVC 1.0 scans automatic dependencies incorrectly when your project
+ * contains this very header.  The problem is that MSVC cannot handle
+ * include directives inside #if..#endif block those are never entered.
+ * Since this header ought to compile in many different operating systems,
+ * there had to be several conditional blocks that are compiled only in
+ * operating systems for what they were designed for.  MSVC 1.0 cannot
+ * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
+ * operating system.  To fix the problem you need to insert DIR.H into
+ * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
+ * Consult manuals for more informaton about the problem.
+ *
+ * Since many UNIX systems have dirent.h we assume to have one also.
+ * However, if your UNIX system does not have dirent.h you can download one
+ * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
+ * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
+ * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
+ * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
+ * HAVE_SYS_NDIR_H according to the files found.
+ */
+#ifndef DIRENT_H
+#define DIRENT_H
+#define DIRENT_H_INCLUDED
+
+/* find out platform */
+#if defined(MSDOS)                             /* MS-DOS */
+#elif defined(__MSDOS__)                       /* Turbo C/Borland */
+# define MSDOS
+#elif defined(__DOS__)                         /* Watcom */
+# define MSDOS
+#endif
+
+#if defined(WIN32)                             /* MS-Windows */
+#elif defined(__NT__)                          /* Watcom */
+# define WIN32
+#elif defined(_WIN32)                          /* Microsoft */
+# define WIN32
+#elif defined(__WIN32__)                       /* Borland */
+# define WIN32
+#endif
+
+/*
+ * See what kind of dirent interface we have unless autoconf has already
+ * determinated that.
+ */
+#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
+# if defined(_MSC_VER)                         /* Microsoft C/C++ */
+    /* no dirent.h */
+# elif defined(__BORLANDC__)                   /* Borland C/C++ */
+#   define HAVE_DIRENT_H
+#   define VOID_CLOSEDIR
+# elif defined(__TURBOC__)                     /* Borland Turbo C */
+    /* no dirent.h */
+# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
+#   define HAVE_DIRECT_H
+# elif defined(__apollo)                       /* Apollo */
+#   define HAVE_SYS_DIR_H
+# elif defined(__hpux)                         /* HP-UX */
+#   define HAVE_DIRENT_H
+# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
+#   error "not implemented"
+# elif defined(__sgi)                          /* Silicon Graphics */
+#   define HAVE_DIRENT_H
+# elif defined(sun) || defined(_sun)           /* Sun Solaris */
+#   define HAVE_DIRENT_H
+# elif defined(__FreeBSD__)                    /* FreeBSD */
+#   define HAVE_DIRENT_H
+# elif defined(__linux__)                      /* Linux */
+#   define HAVE_DIRENT_H
+# elif defined(__GNUC__)                       /* GNU C/C++ */
+#   define HAVE_DIRENT_H
+# else
+#   error "not implemented"
+# endif
+#endif
+
+/* include proper interface headers */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+# ifdef FREEBSD
+#   define NAMLEN(dp) ((int)((dp)->d_namlen))
+# else
+#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+# endif
+
+#elif defined(HAVE_NDIR_H)
+# include <ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_NDIR_H)
+# include <sys/ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIRECT_H)
+# include <direct.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIR_H)
+# include <dir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_DIR_H)
+# include <sys/types.h>
+# include <sys/dir.h>
+# ifndef dirent
+#   define dirent direct
+# endif
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(MSDOS) || defined(WIN32)
+
+  /* figure out type of underlaying directory interface to be used */
+# if defined(WIN32)
+#   define DIRENT_WIN32_INTERFACE
+# elif defined(MSDOS)
+#   define DIRENT_MSDOS_INTERFACE
+# else
+#   error "missing native dirent interface"
+# endif
+
+  /*** WIN32 specifics ***/
+# if defined(DIRENT_WIN32_INTERFACE)
+#   include <windows.h>
+#   if !defined(DIRENT_MAXNAMLEN)
+#     define DIRENT_MAXNAMLEN (MAX_PATH)
+#   endif
+
+
+  /*** MS-DOS specifics ***/
+# elif defined(DIRENT_MSDOS_INTERFACE)
+#   include <dos.h>
+
+    /* Borland defines file length macros in dir.h */
+#   if defined(__BORLANDC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     if !defined(_find_t)
+#       define _find_t find_t
+#     endif
+
+    /* Turbo C defines ffblk structure in dir.h */
+#   elif defined(__TURBOC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     define DIRENT_USE_FFBLK
+
+    /* MSVC */
+#   elif defined(_MSC_VER)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN (12)
+#     endif
+
+    /* Watcom */
+#   elif defined(__WATCOMC__)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       if defined(__OS2__) || defined(__NT__)
+#         define DIRENT_MAXNAMLEN (255)
+#       else
+#         define DIRENT_MAXNAMLEN (12)
+#       endif
+#     endif
+
+#   endif
+# endif
+
+  /*** generic MS-DOS and MS-Windows stuff ***/
+# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
+#   define NAME_MAX DIRENT_MAXNAMLEN
+# endif
+# if NAME_MAX < DIRENT_MAXNAMLEN
+#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
+# endif
+
+
+  /*
+   * Substitute for real dirent structure.  Note that `d_name' field is a
+   * true character array although we have it copied in the implementation
+   * dependent data.  We could save some memory if we had declared `d_name'
+   * as a pointer refering the name within implementation dependent data.
+   * We have not done that since some code may rely on sizeof(d_name) to be
+   * something other than four.  Besides, directory entries are typically so
+   * small that it takes virtually no time to copy them from place to place.
+   */
+  typedef struct dirent {
+    char d_name[NAME_MAX + 1];
+
+    /*** Operating system specific part ***/
+# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
+    WIN32_FIND_DATA data;
+# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
+#   if defined(DIRENT_USE_FFBLK)
+    struct ffblk data;
+#   else
+    struct _find_t data;
+#   endif
+# endif
+  } dirent;
+
+  /* DIR substitute structure containing directory name.  The name is
+   * essential for the operation of ``rewinndir'' function. */
+  typedef struct DIR {
+    char          *dirname;                    /* directory being scanned */
+    dirent        current;                     /* current entry */
+    int           dirent_filled;               /* is current un-processed? */
+
+  /*** Operating system specific part ***/
+#  if defined(DIRENT_WIN32_INTERFACE)
+    HANDLE        search_handle;
+#  elif defined(DIRENT_MSDOS_INTERFACE)
+#  endif
+  } DIR;
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/* supply prototypes for dirent functions */
+static DIR *opendir (const char *dirname);
+static struct dirent *readdir (DIR *dirp);
+static int closedir (DIR *dirp);
+static void rewinddir (DIR *dirp);
+
+/*
+ * Implement dirent interface as static functions so that the user does not
+ * need to change his project in any way to use dirent function.  With this
+ * it is sufficient to include this very header from source modules using
+ * dirent functions and the functions will be pulled in automatically.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+/* use ffblk instead of _find_t if requested */
+#if defined(DIRENT_USE_FFBLK)
+# define _A_ARCH   (FA_ARCH)
+# define _A_HIDDEN (FA_HIDDEN)
+# define _A_NORMAL (0)
+# define _A_RDONLY (FA_RDONLY)
+# define _A_SUBDIR (FA_DIREC)
+# define _A_SYSTEM (FA_SYSTEM)
+# define _A_VOLID  (FA_LABEL)
+# define _dos_findnext(dest) findnext(dest)
+# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
+#endif
+
+static int _initdir (DIR *p);
+static const char *_getdirname (const struct dirent *dp);
+static void _setdirname (struct DIR *dirp);
+
+/*
+ * <function name="opendir">
+ * <intro>open directory stream for reading
+ * <syntax>DIR *opendir (const char *dirname);
+ *
+ * <desc>Open named directory stream for read and return pointer to the
+ * internal working area that is used for retrieving individual directory
+ * entries.  The internal working area has no fields of your interest.
+ *
+ * <ret>Returns a pointer to the internal working area or NULL in case the 
+ * directory stream could not be opened.  Global `errno' variable will set
+ * in case of error as follows:
+ *
+ * <table>
+ * [EACESS  |Permission denied.
+ * [EMFILE  |Too many open files used by the process.
+ * [ENFILE  |Too many open files in system.
+ * [ENOENT  |Directory does not exist.
+ * [ENOMEM  |Insufficient memory.
+ * [ENOTDIR |dirname does not refer to directory.  This value is not
+ *           reliable on MS-DOS and MS-Windows platforms.  Many
+ *           implementations return ENOENT even when the name refers to a
+ *           file.]
+ * </table>
+ * </function>
+ */
+static DIR *opendir(const char *dirname)
+{
+  DIR *dirp;
+  assert (dirname != NULL);
+  
+  dirp = (DIR*)malloc (sizeof (struct DIR));
+  if (dirp != NULL) {
+    char *p;
+    
+    /* allocate room for directory name */
+    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
+    if (dirp->dirname == NULL) {
+      /* failed to duplicate directory name.  errno set by malloc() */
+      free (dirp);
+      return NULL;
+    }
+    /* Copy directory name while appending directory separator and "*.*".
+     * Directory separator is not appended if the name already ends with
+     * drive or directory separator.  Directory separator is assumed to be
+     * '/' or '\' and drive separator is assumed to be ':'. */
+    strcpy (dirp->dirname, dirname);
+    p = strchr (dirp->dirname, '\0');
+    if (dirp->dirname < p  &&
+        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
+    {
+      strcpy (p++, "\\");
+    }
+# ifdef DIRENT_WIN32_INTERFACE
+    strcpy (p, "*"); /*scan files with and without extension in win32*/
+# else
+    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
+# endif
+
+    /* open stream */
+    if (_initdir (dirp) == 0) {
+      /* initialization failed */
+      free (dirp->dirname);
+      free (dirp);
+      return NULL;
+    }
+  }
+  return dirp;
+}
+
+
+/*
+ * <function name="readdir">
+ * <intro>read a directory entry
+ * <syntax>struct dirent *readdir (DIR *dirp);
+ *
+ * <desc>Read individual directory entry and return pointer to a structure
+ * containing the name of the entry.  Individual directory entries returned
+ * include normal files, sub-directories, pseudo-directories "." and ".."
+ * and also volume labels, hidden files and system files in MS-DOS and
+ * MS-Windows.   You might want to use stat(2) function to determinate which
+ * one are you dealing with.  Many dirent implementations already contain
+ * equivalent information in dirent structure but you cannot depend on
+ * this.
+ *
+ * The dirent structure contains several system dependent fields that
+ * generally have no interest to you.  The only interesting one is char
+ * d_name[] that is also portable across different systems.  The d_name
+ * field contains the name of the directory entry without leading path.
+ * While d_name is portable across different systems the actual storage
+ * capacity of d_name varies from system to system and there is no portable
+ * way to find out it at compile time as different systems define the
+ * capacity of d_name with different macros and some systems do not define
+ * capacity at all (besides actual declaration of the field). If you really
+ * need to find out storage capacity of d_name then you might want to try
+ * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
+ * there are many MS-DOS and MS-Windows implementations those do not define
+ * it.  There are also systems that declare d_name as "char d_name[1]" and
+ * then allocate suitable amount of memory at run-time.  Thanks to Alain
+ * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
+ *
+ * This all leads to the fact that it is difficult to allocate space
+ * for the directory names when the very same program is being compiled on
+ * number of operating systems.  Therefore I suggest that you always
+ * allocate space for directory names dynamically.
+ *
+ * <ret>
+ * Returns a pointer to a structure containing name of the directory entry
+ * in `d_name' field or NULL if there was an error.  In case of an error the
+ * global `errno' variable will set as follows:
+ *
+ * <table>
+ * [EBADF  |dir parameter refers to an invalid directory stream.  This value
+ *          is not set reliably on all implementations.]
+ * </table>
+ * </function>
+ */
+static struct dirent *
+readdir (DIR *dirp)
+{
+  assert(dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return NULL;
+  }
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* directory stream was opened/rewound incorrectly or it ended normally */
+    errno = EBADF;
+    return NULL;
+  }
+#endif
+
+  if (dirp->dirent_filled != 0) {
+    /*
+     * Directory entry has already been retrieved and there is no need to
+     * retrieve a new one.  Directory entry will be retrieved in advance
+     * when the user calls readdir function for the first time.  This is so
+     * because real dirent has separate functions for opening and reading
+     * the stream whereas Win32 and DOS dirents open the stream
+     * automatically when we retrieve the first file.  Therefore, we have to
+     * save the first file when opening the stream and later we have to
+     * return the saved entry when the user tries to read the first entry.
+     */
+    dirp->dirent_filled = 0;
+  } else {
+    /* fill in entry and return that */
+#if defined(DIRENT_WIN32_INTERFACE)
+    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
+      /* Last file has been processed or an error occured */
+      FindClose (dirp->search_handle);
+      dirp->search_handle = INVALID_HANDLE_VALUE;
+      errno = ENOENT;
+      return NULL;
+    }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+    if (_dos_findnext (&dirp->current.data) != 0) {
+      /* _dos_findnext and findnext will set errno to ENOENT when no
+       * more entries could be retrieved. */
+      return NULL;
+    }
+# endif
+
+    _setdirname (dirp);
+    assert (dirp->dirent_filled == 0);
+  }
+  return &dirp->current;
+}
+
+
+/*
+ * <function name="closedir">
+ * <intro>close directory stream.
+ * <syntax>int closedir (DIR *dirp);
+ *
+ * <desc>Close directory stream opened by the `opendir' function.  Close of
+ * directory stream invalidates the DIR structure as well as previously read
+ * dirent entry.
+ *
+ * <ret>The function typically returns 0 on success and -1 on failure but
+ * the function may be declared to return void on same systems.  At least
+ * Borland C/C++ and some UNIX implementations use void as a return type.
+ * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
+ * known to return nothing.  The very same definition is made by the GNU
+ * autoconf if you happen to use it.
+ *
+ * The global `errno' variable will set to EBADF in case of error.
+ * </function>
+ */
+static int
+closedir (DIR *dirp)
+{   
+  int retcode = 0;
+
+  /* make sure that dirp points to legal structure */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+ 
+  /* free directory name and search handles */
+  if (dirp->dirname != NULL) free (dirp->dirname);
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      retcode = -1;
+      errno = EBADF;
+    }
+  }
+#endif                     
+
+  /* clear dirp structure to make sure that it cannot be used anymore*/
+  memset (dirp, 0, sizeof (*dirp));
+# if defined(DIRENT_WIN32_INTERFACE)
+  dirp->search_handle = INVALID_HANDLE_VALUE;
+# endif
+
+  free (dirp);
+  return retcode;
+}
+
+
+/*
+ * <function name="rewinddir">
+ * <intro>rewind directory stream to the beginning
+ * <syntax>void rewinddir (DIR *dirp);
+ *
+ * <desc>Rewind directory stream to the beginning so that the next call of
+ * readdir() returns the very first directory entry again.  However, note
+ * that next call of readdir() may not return the same directory entry as it
+ * did in first time.  The directory stream may have been affected by newly
+ * created files.
+ *
+ * Almost every dirent implementation ensure that rewinddir will update
+ * the directory stream to reflect any changes made to the directory entries
+ * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
+ * this if your program depends on the feature.  I know at least one dirent
+ * implementation where you are required to close and re-open the stream to
+ * see the changes.
+ *
+ * <ret>Returns nothing.  If something went wrong while rewinding, you will
+ * notice it later when you try to retrieve the first directory entry.
+ */
+static void
+rewinddir (DIR *dirp)
+{   
+  /* make sure that dirp is legal */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return;
+  }
+  assert (dirp->dirname != NULL);
+  
+  /* close previous stream */
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      errno = EBADF;
+    }
+  }
+#endif
+
+  /* re-open previous stream */
+  if (_initdir (dirp) == 0) {
+    /* initialization failed but we cannot deal with error.  User will notice
+     * error later when she tries to retrieve first directory enty. */
+    /*EMPTY*/;
+  }
+}
+
+
+/*
+ * Open native directory stream object and retrieve first file.
+ * Be sure to close previous stream before opening new one.
+ */
+static int
+_initdir (DIR *dirp)
+{ 
+  assert (dirp != NULL);
+  assert (dirp->dirname != NULL);
+  dirp->dirent_filled = 0;
+
+# if defined(DIRENT_WIN32_INTERFACE)
+  /* Open stream and retrieve first file */
+  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* something went wrong but we don't know what.  GetLastError() could
+     * give us more information about the error, but then we should map
+     * the error code into errno. */
+    errno = ENOENT;
+    return 0;
+  }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+  if (_dos_findfirst (dirp->dirname,
+          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
+          &dirp->current.data) != 0)
+  {
+    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
+     * more entries could be retrieved. */
+    return 0;
+  }
+# endif
+
+  /* initialize DIR and it's first entry */
+  _setdirname (dirp);
+  dirp->dirent_filled = 1;
+  return 1;
+}
+
+
+/*
+ * Return implementation dependent name of the current directory entry.
+ */
+static const char *
+_getdirname (const struct dirent *dp)
+{
+#if defined(DIRENT_WIN32_INTERFACE)
+  return dp->data.cFileName;
+  
+#elif defined(DIRENT_USE_FFBLK)
+  return dp->data.ff_name;
+  
+#else
+  return dp->data.name;
+#endif  
+}
+
+
+/*
+ * Copy name of implementation dependent directory entry to the d_name field.
+ */
+static void
+_setdirname (struct DIR *dirp) {
+  /* make sure that d_name is long enough */
+  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
+  
+  strncpy (dirp->current.d_name,
+      _getdirname (&dirp->current),
+      NAME_MAX);
+  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
+}
+  
+# ifdef __cplusplus
+}
+# endif
+# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+
+#else
+# error "missing dirent interface"
+#endif
+
+
+#endif /*DIRENT_H*/
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/all-wcprops ./jp3d/codec/.svn/all-wcprops
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/all-wcprops	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,101 @@
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/437/trunk/jp3d/codec
+END
+jp3d_vm_dec.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_dec.vcproj
+END
+jp3d_vm_dec.suo
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_dec.suo
+END
+jp3d_vm_enc.sln
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_enc.sln
+END
+getopt.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/codec/getopt.c
+END
+getopt.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/codec/getopt.h
+END
+jp3d_vm_enc.ncb
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_enc.ncb
+END
+jp3d_vm_enc.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_enc.vcproj
+END
+jp3d_vm_enc.suo
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_enc.suo
+END
+convert.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/codec/convert.c
+END
+convert.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/codec/convert.h
+END
+jp3d_vm_dec.sln
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_dec.sln
+END
+jp3d_to_volume.c
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_to_volume.c
+END
+volume_to_jp3d.c
+K 25
+svn:wc:ra_dav:version-url
+V 51
+/svn/!svn/ver/289/trunk/jp3d/codec/volume_to_jp3d.c
+END
+dirent.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/436/trunk/jp3d/codec/dirent.h
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/437/trunk/jp3d/codec/CMakeLists.txt
+END
+jp3d_vm_dec.ncb
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/codec/jp3d_vm_dec.ncb
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/entries ./jp3d/codec/.svn/entries
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,236 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/jp3d/codec
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+jp3d_vm_dec.vcproj
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+cc1589cf4249e83cec88dd41eddd60d6
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_enc.sln
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+b2bbb42d89056da8396e7d4eccba17c8
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_dec.suo
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+b968cadcad8498a502a074babd286e17
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+getopt.c
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+793d77f6400347adefd36b7319354176
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_enc.ncb
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+af8ca51056b72e72057db1b4588ef2e8
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+getopt.h
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+15e166c974ee564380d3684a22c08cce
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_enc.vcproj
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+88bb5213be04ce7f93a68f2910e93140
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_enc.suo
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+ed49648d147d6ebd81498e7e1ff0bc92
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+convert.c
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+d3ba5f68b282a66bb91fdfe85548d40e
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+convert.h
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+9e77b475c23e7ba3a2376ab656016747
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_vm_dec.sln
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+302a4af1be4a90a7b9dc5c6bacee2d54
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+volume_to_jp3d.c
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+b01a9943e20eea1d4ff4ce167f4df90f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_to_volume.c
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+78a5f13b15d65c8c4cbcfda52964901f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+dirent.h
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+25b3e80349b8d082d5d4e5633f2c991e
+2007-09-06T10:49:19.934135Z
+436
+gdcm
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+b4112432a7d1cd0d935aa963df2722ce
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+has-props
+
+jp3d_vm_dec.ncb
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+97174ef0a754583e1f29c49f93210d67
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/format ./jp3d/codec/.svn/format
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/format	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/CMakeLists.txt.svn-base ./jp3d/codec/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/convert.c.svn-base ./jp3d/codec/.svn/prop-base/convert.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/convert.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/convert.h.svn-base ./jp3d/codec/.svn/prop-base/convert.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/convert.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/dirent.h.svn-base ./jp3d/codec/.svn/prop-base/dirent.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/dirent.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/dirent.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/getopt.c.svn-base ./jp3d/codec/.svn/prop-base/getopt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/getopt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/getopt.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/getopt.h.svn-base ./jp3d/codec/.svn/prop-base/getopt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/getopt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/getopt.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_to_volume.c.svn-base ./jp3d/codec/.svn/prop-base/jp3d_to_volume.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_to_volume.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_to_volume.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.ncb.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.ncb.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.ncb.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.ncb.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.sln.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.sln.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.suo.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.suo.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.suo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.suo.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.vcproj.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_dec.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_dec.vcproj.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.ncb.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.ncb.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.ncb.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.ncb.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.sln.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.sln.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.suo.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.suo.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.suo.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.suo.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.vcproj.svn-base ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/jp3d_vm_enc.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/jp3d_vm_enc.vcproj.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/volume_to_jp3d.c.svn-base ./jp3d/codec/.svn/prop-base/volume_to_jp3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/prop-base/volume_to_jp3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/prop-base/volume_to_jp3d.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/CMakeLists.txt.svn-base ./jp3d/codec/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,53 @@
+# Build the demo app, small examples
+
+# First thing define the common source:
+SET(common_SRCS
+  convert.c
+  )
+# Then check if getopt is present:
+INCLUDE (${CMAKE_ROOT}/Modules/CheckIncludeFile.cmake)
+SET(DONT_HAVE_GETOPT 1)
+IF(UNIX) #I am pretty sure only *nix sys have this anyway
+  CHECK_INCLUDE_FILE("getopt.h" CMAKE_HAVE_GETOPT_H)
+  # Seems like we need the contrary:
+  IF(CMAKE_HAVE_GETOPT_H)
+    SET(DONT_HAVE_GETOPT 0)
+  ENDIF(CMAKE_HAVE_GETOPT_H)
+ENDIF(UNIX)
+
+# If not getopt was found then add it to the lib:
+IF(DONT_HAVE_GETOPT)
+  ADD_DEFINITIONS(-DDONT_HAVE_GETOPT)
+  SET(common_SRCS
+    ${common_SRCS}
+    compat/getopt.c
+  )
+ENDIF(DONT_HAVE_GETOPT)
+
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${CMAKE_CURRENT_SOURCE_DIR}/../libjp3dvm
+  )
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+#FIND_PACKAGE(TIFF REQUIRED)
+
+# Loop over all executables:
+FOREACH(exe jp3d_to_volume volume_to_jp3d)
+  ADD_EXECUTABLE(${exe} ${exe}.c ${common_SRCS})
+  TARGET_LINK_LIBRARIES(${exe} ${OPJ_PREFIX}openjp3dvm) # ${TIFF_LIBRARIES})
+  # On unix you need to link to the math library:
+  IF(UNIX)
+    TARGET_LINK_LIBRARIES(${exe} m)
+  ENDIF(UNIX)
+  # Install exe
+  INSTALL_TARGETS(/bin/ ${exe})
+ENDFOREACH(exe)
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/convert.c.svn-base ./jp3d/codec/.svn/text-base/convert.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/convert.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,997 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include "openjpeg.h"
+#ifdef WIN32
+#include "dirent.h"
+#else
+#include <dirent.h>
+#endif /* WIN32 */
+
+
+
+void dump_volume(FILE *fd, opj_volume_t * vol) {
+	int compno;
+	fprintf(fd, "volume {\n");
+	fprintf(fd, "  x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d\n", vol->x0, vol->y0, vol->z0,vol->x1, vol->y1,  vol->z1);
+	fprintf(fd, "  numcomps=%d\n", vol->numcomps);
+	for (compno = 0; compno < vol->numcomps; compno++) {
+		opj_volume_comp_t *comp = &vol->comps[compno];
+		fprintf(fd, "  comp %d {\n", compno);
+		fprintf(fd, "    dx=%d, dy=%d, dz=%d\n", comp->dx, comp->dy, comp->dz);
+		fprintf(fd, "    prec=%d\n", comp->prec);
+		fprintf(fd, "    sgnd=%d\n", comp->sgnd);
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+/*
+ * Get logarithm of an integer and round downwards.
+ *
+ * log2(a)
+ */
+static int int_floorlog2(int a) {
+	int l;
+	for (l = 0; a > 1; l++) {
+		a >>= 1;
+	}
+	return l;
+}
+
+/*
+ * Divide an integer by a power of 2 and round upwards.
+ *
+ * a divided by 2^b
+ */
+static int int_ceildivpow2(int a, int b) {
+	return (a + (1 << b) - 1) >> b;
+}
+
+/*
+ * Divide an integer and round upwards.
+ *
+ * a divided by b
+ */
+static int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+
+
+/* -->> -->> -->> -->>
+
+PGX IMAGE FORMAT
+
+<<-- <<-- <<-- <<-- */
+
+
+unsigned char readuchar(FILE * f)
+{
+  unsigned char c1;
+  fread(&c1, 1, 1, f);
+  return c1;
+}
+
+unsigned short readushort(FILE * f, int bigendian)
+{
+  unsigned char c1, c2;
+  fread(&c1, 1, 1, f);
+  fread(&c2, 1, 1, f);
+  if (bigendian)
+    return (c1 << 8) + c2;
+  else
+    return (c2 << 8) + c1;
+}
+
+unsigned int readuint(FILE * f, int bigendian)
+{
+  unsigned char c1, c2, c3, c4;
+  fread(&c1, 1, 1, f);
+  fread(&c2, 1, 1, f);
+  fread(&c3, 1, 1, f);
+  fread(&c4, 1, 1, f);
+  if (bigendian)
+    return (c1 << 24) + (c2 << 16) + (c3 << 8) + c4;
+  else
+    return (c4 << 24) + (c3 << 16) + (c2 << 8) + c1;
+}
+/*****************************************/
+static unsigned short ShortSwap(unsigned short v)
+{
+  unsigned char c1, c2;
+  c1 = v & 0xff;
+  c2 = (v >> 8) & 0xff;
+  return (c1 << 8) + c2;
+}
+
+static unsigned int LongSwap (unsigned int i)
+{
+  unsigned char b1, b2, b3, b4;
+  b1 = i & 255;
+  b2 = ( i >> 8 ) & 255;
+  b3 = ( i>>16 ) & 255;
+  b4 = ( i>>24 ) & 255;
+  return ((int)b1 << 24) + ((int)b2 << 16) + ((int)b3 << 8) + b4;
+}
+/*****************************************/
+
+opj_volume_t* pgxtovolume(char *relpath, opj_cparameters_t *parameters) {
+	
+	FILE *f = NULL;
+	int w, h, prec;
+	unsigned long offset;
+	int i, s, numcomps, maxvalue, sliceno, slicepos, maxslice = 0;
+	
+	OPJ_COLOR_SPACE color_space;
+	opj_volume_cmptparm_t cmptparm;	// maximum of 1 component 
+	opj_volume_t * volume = NULL;
+
+	char endian1,endian2,sign;
+	char signtmp[32];
+	char temp[32];
+	opj_volume_comp_t *comp = NULL;
+
+		DIR *dirp;
+    struct dirent *direntp;
+	
+	char *tmp = NULL, *tmp2 = NULL,
+		*point = NULL, *pgx = NULL;
+	char tmpdirpath[MAX_PATH];
+	char dirpath[MAX_PATH];
+	char pattern[MAX_PATH];
+	char pgxfiles[MAX_SLICES][MAX_PATH];
+	int pgxslicepos[MAX_SLICES];
+	char tmpno[3];
+	
+	numcomps = 1;
+	color_space = CLRSPC_GRAY;
+	sliceno = 0;
+	maxvalue = 0;
+	memset(pgxfiles, 0, MAX_SLICES * MAX_PATH * sizeof(char));
+	memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));
+	
+	/* Separación del caso de un único slice frente al de muchos */
+	if ((tmp = strrchr(relpath,'-')) == NULL){ 
+		//fprintf(stdout,"[INFO] A volume of only one slice....\n");
+		sliceno = 1;
+		maxslice = 1;
+		strcpy(pgxfiles[0],relpath);
+	
+	} else {
+		//Fetch only the path 
+		strcpy(tmpdirpath,relpath);
+		if ((tmp = strrchr(tmpdirpath,'/')) != NULL){
+			tmp++; *tmp='\0';
+			strcpy(dirpath,tmpdirpath);
+		} else {
+			strcpy(dirpath,"./");
+		}
+
+		//Fetch the pattern of the volume slices
+		if ((tmp = strrchr (relpath,'/')) != NULL) 
+			tmp++;	
+		else 
+			tmp = relpath;
+        if ((tmp2 = strrchr(tmp,'-')) != NULL)
+            *tmp2='\0';
+		else{ 
+			fprintf(stdout, "[ERROR] tmp2 ha dado null. no ha encontrado el * %s %s",tmp,relpath);
+			return NULL;
+		}
+        strcpy(pattern,tmp);
+
+		dirp = opendir( dirpath );
+		if (dirp == NULL){
+			fprintf(stdout, "[ERROR] Infile must be a .pgx file or a directory that contain pgx files");
+			return NULL;
+		}
+
+		/*Read all .pgx files of directory */
+		while ( (direntp = readdir( dirp )) != NULL )
+		{
+			/* Found a directory, but ignore . and .. */
+			if(strcmp(".",direntp->d_name) == 0 || strcmp("..",direntp->d_name) == 0)
+					continue;
+			
+			if( ((pgx = strstr(direntp->d_name,pattern)) != NULL) && ((tmp2 = strstr(direntp->d_name,".pgx")) != NULL) ){
+			
+				strcpy(tmp,dirpath);
+				tmp = strcat(tmp,direntp->d_name);
+						
+				//Obtenemos el index de la secuencia de slices
+				if ((tmp2 = strpbrk (direntp->d_name, "0123456789")) == NULL) 
+					continue;
+				i = 0;
+				while (tmp2 != NULL) {					
+					tmpno[i++] = *tmp2;
+					point = tmp2;
+					tmp2 = strpbrk (tmp2+1,"0123456789");
+				}tmpno[i]='\0';
+
+				//Comprobamos que no estamos leyendo algo raro como pattern.jp3d
+				if ((point = strpbrk (point,".")) == NULL){
+					break;
+				}
+				//Slicepos --> index de slice; Sliceno --> no de slices hasta el momento
+				slicepos = atoi(tmpno);
+				pgxslicepos[sliceno] = slicepos - 1;
+				sliceno++;
+				if (slicepos>maxslice)
+					maxslice = slicepos;
+				
+				//Colocamos el slices en su posicion correspondiente
+				strcpy(pgxfiles[slicepos-1],tmp);
+			}
+		}
+	
+	}/* else if pattern*.pgx */
+
+	if (!sliceno) {
+		fprintf(stdout,"[ERROR] No slices with this pattern founded !! Please check input volume name\n");
+		return NULL;
+	}
+	/*if ( maxslice != sliceno) {
+		fprintf(stdout,"[ERROR] Slices are not sequentially numbered !! Please rename them accordingly\n");
+		return NULL;
+	}*/
+	
+	for (s=0;s<sliceno;s++)
+	{
+			int pos = maxslice == sliceno ? s: pgxslicepos[s];
+			f = fopen(pgxfiles[pos], "rb");
+			if (!f) {
+				fprintf(stdout, "[ERROR] Failed to open %s for reading !\n", pgxfiles[s]);
+				return NULL;
+			}
+			fprintf(stdout, "[INFO] Loading %s \n",pgxfiles[pos]);
+
+			fseek(f, 0, SEEK_SET);
+			fscanf(f, "PG%[ \t]%c%c%[ \t+-]%d%[ \t]%d%[ \t]%d",temp,&endian1,&endian2,signtmp,&prec,temp,&w,temp,&h);
+
+			i=0;
+			sign='+';		
+			while (signtmp[i]!='\0') {
+				if (signtmp[i]=='-') sign='-';
+				i++;
+			}
+		
+			fgetc(f);
+			if (endian1=='M' && endian2=='L') {
+				cmptparm.bigendian = 1;
+			} else if (endian2=='M' && endian1=='L') {
+				cmptparm.bigendian = 0;
+			} else {
+				fprintf(stdout, "[ERROR] Bad pgx header, please check input file\n");
+				return NULL;
+			}
+
+			if (s==0){
+				/* initialize volume component */
+
+				cmptparm.x0 = parameters->volume_offset_x0;
+				cmptparm.y0 = parameters->volume_offset_y0;
+				cmptparm.z0 = parameters->volume_offset_z0;
+				cmptparm.w = !cmptparm.x0 ? (w - 1) * parameters->subsampling_dx + 1 : cmptparm.x0 + (w - 1) * parameters->subsampling_dx + 1;
+				cmptparm.h = !cmptparm.y0 ? (h - 1) * parameters->subsampling_dy + 1 : cmptparm.y0 + (h - 1) * parameters->subsampling_dy + 1;
+				cmptparm.l = !cmptparm.z0 ? (sliceno - 1) * parameters->subsampling_dz + 1 : cmptparm.z0 + (sliceno - 1) * parameters->subsampling_dz + 1;
+				
+				if (sign == '-') {
+					cmptparm.sgnd = 1;
+				} else {
+					cmptparm.sgnd = 0;
+				}
+				cmptparm.prec = prec;
+				cmptparm.bpp = prec;
+				cmptparm.dcoffset = parameters->dcoffset;
+				cmptparm.dx = parameters->subsampling_dx;
+				cmptparm.dy = parameters->subsampling_dy;
+				cmptparm.dz = parameters->subsampling_dz;
+				
+				/* create the volume */
+				volume = opj_volume_create(numcomps, &cmptparm, color_space);
+				if(!volume) {
+					fclose(f);
+					return NULL;
+				}
+				/* set volume offset and reference grid */
+				volume->x0 = cmptparm.x0;
+				volume->y0 = cmptparm.y0;
+				volume->z0 = cmptparm.z0;
+				volume->x1 = cmptparm.w;
+				volume->y1 = cmptparm.h;
+				volume->z1 = cmptparm.l;
+				
+				/* set volume data :only one component, that is a volume*/
+				comp = &volume->comps[0];
+			
+			}//if sliceno==1
+			
+			offset = w * h * s;
+			
+			for (i = 0; i < w * h; i++) {
+				int v;
+				if (comp->prec <= 8) {
+					if (!comp->sgnd) {
+						v = readuchar(f);
+					} else {
+						v = (char) readuchar(f);
+					}
+				} else if (comp->prec <= 16) {
+					if (!comp->sgnd) {
+						v = readushort(f, cmptparm.bigendian);
+					} else {
+						v = (short) readushort(f, cmptparm.bigendian);
+					}
+				} else {
+					if (!comp->sgnd) {
+						v = readuint(f, cmptparm.bigendian);
+					} else {
+						v = (int) readuint(f, cmptparm.bigendian);
+					}
+				}				
+				if (v > maxvalue)
+					maxvalue = v;
+				comp->data[i + offset] = v;
+				
+			}
+			fclose(f);
+	} // for s --> sliceno
+	comp->bpp = int_floorlog2(maxvalue) + 1;
+	if (sliceno != 1)
+		closedir( dirp );
+	//dump_volume(stdout, volume);
+	return volume;
+}
+
+
+int volumetopgx(opj_volume_t * volume, char *outfile) {
+	int w, wr, wrr, h, hr, hrr, l, lr, lrr;
+	int i, j, compno, offset, sliceno;
+	FILE *fdest = NULL;
+
+	for (compno = 0; compno < volume->numcomps; compno++) {
+		opj_volume_comp_t *comp = &volume->comps[compno];
+		char name[256];
+		int nbytes = 0;
+		char *tmp = outfile;
+		while (*tmp) {
+			tmp++;
+		}
+		while (*tmp!='.') {
+			tmp--;
+		}
+		*tmp='\0';
+		for(sliceno = 0; sliceno < volume->z1 - volume->z0; sliceno++) {
+
+			if (volume->numcomps > 1) {
+				sprintf(name, "%s%d-%d.pgx", outfile, sliceno+1, compno);
+			} else if ((volume->z1 - volume->z0) > 1) {
+				sprintf(name, "%s%d.pgx", outfile, sliceno+1);
+			} else {
+				sprintf(name, "%s.pgx", outfile);
+			}
+
+			fdest = fopen(name, "wb");
+			if (!fdest) {
+				fprintf(stdout, "[ERROR] Failed to open %s for writing \n", name);
+				return 1;
+			}
+
+			fprintf(stdout,"[INFO] Writing in %s (%s)\n",name,volume->comps[0].bigendian ? "Bigendian" : "Little-endian");
+
+			w = int_ceildiv(volume->x1 - volume->x0, volume->comps[compno].dx);
+			wr = volume->comps[compno].w;
+			wrr = int_ceildivpow2(volume->comps[compno].w, volume->comps[compno].factor[0]);
+			
+			h = int_ceildiv(volume->y1 - volume->y0, volume->comps[compno].dy);
+			hr = volume->comps[compno].h;
+			hrr = int_ceildivpow2(volume->comps[compno].h, volume->comps[compno].factor[1]);
+			
+			l = int_ceildiv(volume->z1 - volume->z0, volume->comps[compno].dz);
+			lr = volume->comps[compno].l;
+			lrr = int_ceildivpow2(volume->comps[compno].l, volume->comps[compno].factor[2]);
+
+			fprintf(fdest, "PG %c%c %c%d %d %d\n", comp->bigendian ? 'M':'L', comp->bigendian ? 'L':'M',comp->sgnd ? '-' : '+', comp->prec, wr, hr);
+			if (comp->prec <= 8) {
+				nbytes = 1;
+			} else if (comp->prec <= 16) {
+				nbytes = 2;
+			} else {
+				nbytes = 4;
+			}
+
+			offset = (sliceno / lrr * l) + (sliceno % lrr);
+			offset = wrr * hrr * offset;
+			//fprintf(stdout,"%d %d %d %d\n",offset,wrr*hrr,wrr,w);
+			for (i = 0; i < wrr * hrr; i++) {
+				int v = volume->comps[0].data[(i / wrr * w) + (i % wrr) + offset];
+				if (volume->comps[0].bigendian) {
+					for (j = nbytes - 1; j >= 0; j--) {
+                        char byte = (char) ((v >> (j * 8)) & 0xff);
+                        fwrite(&byte, 1, 1, fdest);
+					}
+				} else {
+					for (j = 0; j <= nbytes - 1; j++) {
+                        char byte = (char) ((v >> (j * 8)) & 0xff);
+						fwrite(&byte, 1, 1, fdest);
+					}
+				}
+			}
+
+			fclose(fdest);
+		}//for sliceno
+	}//for compno
+
+	return 0;
+}
+
+/* -->> -->> -->> -->>
+
+BIN IMAGE FORMAT
+
+<<-- <<-- <<-- <<-- */
+
+opj_volume_t* bintovolume(char *filename, char *fileimg, opj_cparameters_t *parameters) {
+	int subsampling_dx =  parameters->subsampling_dx;
+	int subsampling_dy =  parameters->subsampling_dy;
+	int subsampling_dz =  parameters->subsampling_dz;
+	
+	int i, compno, w, h, l, numcomps = 1;
+	int prec, max = 0;
+
+//	char temp[32];
+	char line[100];
+	int bigendian;
+	
+	FILE *f = NULL;
+	FILE *fimg = NULL;
+	OPJ_COLOR_SPACE color_space;
+	opj_volume_cmptparm_t cmptparm;	/* maximum of 1 component */
+	opj_volume_t * volume = NULL;
+	opj_volume_comp_t *comp = NULL;
+
+	bigendian = 0;
+	color_space = CLRSPC_GRAY;
+
+	fimg = fopen(fileimg,"r");
+	if (!fimg) { 
+		fprintf(stdout, "[ERROR] Failed to open %s for reading !!\n", fileimg);
+		return 0;
+	}
+
+	fseek(fimg, 0, SEEK_SET);
+	while (!feof(fimg)) {
+        fgets(line,100,fimg);
+		//fprintf(stdout,"%s %d \n",line,feof(fimg));
+		if (strncmp(line,"Bpp",3) == 0){
+			sscanf(line,"%*s%*[ \t]%d",&prec);
+		} else if (strncmp(line,"Color",5) == 0){
+			sscanf(line, "%*s%*[ \t]%d",&color_space);
+		} else if (strncmp(line,"Dim",3) == 0){
+			sscanf(line, "%*s%*[ \t]%d%*[ \t]%d%*[ \t]%d",&w,&h,&l);
+		}
+	}
+	//fscanf(fimg, "Bpp%[ \t]%d%[ \t\n]",temp,&prec,temp);
+	//fscanf(fimg, "Color Map%[ \t]%d%[ \n\t]Dimensions%[ \t]%d%[ \t]%d%[ \t]%d%[ \n\t]",temp,&color_space,temp,temp,&w,temp,&h,temp,&l,temp);
+	//fscanf(fimg, "Resolution(mm)%[ \t]%d%[ \t]%d%[ \t]%d%[ \n\t]",temp,&subsampling_dx,temp,&subsampling_dy,temp,&subsampling_dz,temp);
+
+	#ifdef VERBOSE
+		fprintf(stdout, "[INFO] %d \t %d %d %d \t %3.2f %2.2f %2.2f \t %d \n",color_space,w,h,l,subsampling_dx,subsampling_dy,subsampling_dz,prec);
+	#endif
+	fclose(fimg);
+	
+	/* initialize volume components */
+	memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));
+	
+	cmptparm.prec = prec;
+	cmptparm.bpp = prec;
+	cmptparm.sgnd = 0;
+	cmptparm.bigendian = bigendian;
+	cmptparm.dcoffset = parameters->dcoffset;
+	cmptparm.dx = subsampling_dx;
+	cmptparm.dy = subsampling_dy;
+	cmptparm.dz = subsampling_dz;
+	cmptparm.w = w;
+	cmptparm.h = h;
+	cmptparm.l = l;
+	
+	/* create the volume */
+	volume = opj_volume_create(numcomps, &cmptparm, color_space);
+	if(!volume) {
+		fprintf(stdout,"[ERROR] Unable to create volume");	
+		fclose(f);
+		return NULL;
+	}
+	
+	/* set volume offset and reference grid */
+	volume->x0 = parameters->volume_offset_x0;
+	volume->y0 = parameters->volume_offset_y0;
+	volume->z0 = parameters->volume_offset_z0;
+	volume->x1 = parameters->volume_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	volume->y1 = parameters->volume_offset_y0 + (h - 1) *	subsampling_dy + 1;
+	volume->z1 = parameters->volume_offset_z0 + (l - 1) *	subsampling_dz + 1;
+	
+	/* set volume data */
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stdout, "[ERROR] Failed to open %s for reading !!\n", filename);
+		return 0;
+	}
+	
+	/* BINARY */
+	for (compno = 0; compno < volume->numcomps; compno++) {
+		int whl = w * h * l;
+		/* set volume data */
+		comp = &volume->comps[compno];
+		
+		/*if (comp->prec <= 8) {
+			if (!comp->sgnd) {
+                unsigned char *data = (unsigned char *) malloc(whl * sizeof(unsigned char));
+				fread(data, 1, whl, f);
+				for (i = 0; i < whl; i++) {
+					comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				char *data = (char *) malloc(whl);
+				fread(data, 1, whl, f);
+				for (i = 0; i < whl; i++) {
+					comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			}
+		} else if (comp->prec <= 16) {
+			if (!comp->sgnd) {
+                unsigned short *data = (unsigned short *) malloc(whl * sizeof(unsigned short));
+				int leido = fread(data, 2, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}
+				
+				for (i = 0; i < whl; i++) {
+					if (bigendian)	//(c1 << 8) + c2;
+						comp->data[i] = data[i];
+					else{			//(c2 << 8) + c1;
+						comp->data[i] = ShortSwap(data[i]);
+					}
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				short *data = (short *) malloc(whl);
+				int leido = fread(data, 2, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}
+				for (i = 0; i < whl; i++) {
+					if (bigendian){	//(c1 << 8) + c2;
+						comp->data[i] = data[i];
+					}else{			//(c2 << 8) + c1;
+						comp->data[i] = (short) ShortSwap((unsigned short) data[i]);
+					}
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			}
+		} else {
+			if (!comp->sgnd) {
+                unsigned int *data = (unsigned int *) malloc(whl * sizeof(unsigned int));
+				int leido = fread(data, 4, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}				for (i = 0; i < whl; i++) {
+					if (!bigendian)
+						comp->data[i] = LongSwap(data[i]);
+					else
+						comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				int leido = fread(comp->data, 4, whl, f);
+				if (!leido)	{
+					fclose(f);
+					return NULL;
+				}				
+				for (i = 0; i < whl; i++) {
+					if (!bigendian) 
+						comp->data[i] = (int) LongSwap((unsigned int) comp->data[i]);
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+			}
+		}*/
+		
+		for (i = 0; i < whl; i++) {
+			int v;
+			if (comp->prec <= 8) {
+				if (!comp->sgnd) {
+					v = readuchar(f);
+				} else {
+					v = (char) readuchar(f);
+				}
+			} else if (comp->prec <= 16) {
+				if (!comp->sgnd) {
+					v = readushort(f, bigendian);
+				} else {
+					v = (short) readushort(f, bigendian);
+				}
+			} else {
+				if (!comp->sgnd) {
+					v = readuint(f, bigendian);
+				} else {
+					v = (int) readuint(f, bigendian);
+				}
+			}
+			if (v > max)
+				max = v;
+			comp->data[i] = v;
+		}
+		comp->bpp = int_floorlog2(max) + 1;
+	}
+	fclose(f);
+	return volume;
+}
+
+int volumetobin(opj_volume_t * volume, char *outfile) {
+	int w, wr, wrr, h, hr, hrr, l, lr, lrr, max;
+	int i,j, compno, nbytes;
+	int offset, sliceno;
+	FILE *fdest = NULL;
+	FILE *fimgdest = NULL;
+//	char *imgtemp;
+	char name[256];
+
+	for (compno = 0; compno < 1; compno++) { //Only one component
+		
+		fdest = fopen(outfile, "wb");
+		if (!fdest) {
+			fprintf(stdout, "[ERROR] Failed to open %s for writing\n", outfile);
+			return 1;
+		}
+        fprintf(stdout,"[INFO] Writing outfile %s (%s) \n",outfile, volume->comps[0].bigendian ? "Bigendian" : "Little-endian");
+
+		w = int_ceildiv(volume->x1 - volume->x0, volume->comps[compno].dx);
+		wr = volume->comps[compno].w;
+		wrr = int_ceildivpow2(volume->comps[compno].w, volume->comps[compno].factor[0]);
+		
+		h = int_ceildiv(volume->y1 - volume->y0, volume->comps[compno].dy);
+		hr = volume->comps[compno].h;
+		hrr = int_ceildivpow2(volume->comps[compno].h, volume->comps[compno].factor[1]);
+		
+		l = int_ceildiv(volume->z1 - volume->z0, volume->comps[compno].dz);
+		lr = volume->comps[compno].l;
+		lrr = int_ceildivpow2(volume->comps[compno].l, volume->comps[compno].factor[2]);
+
+		max = (volume->comps[compno].prec <= 8) ? 255 : (1 << volume->comps[compno].prec) - 1;
+		
+		volume->comps[compno].x0 = int_ceildivpow2(volume->comps[compno].x0 - int_ceildiv(volume->x0, volume->comps[compno].dx), volume->comps[compno].factor[0]);
+		volume->comps[compno].y0 = int_ceildivpow2(volume->comps[compno].y0 - int_ceildiv(volume->y0, volume->comps[compno].dy), volume->comps[compno].factor[1]);
+		volume->comps[compno].z0 = int_ceildivpow2(volume->comps[compno].z0 - int_ceildiv(volume->z0, volume->comps[compno].dz), volume->comps[compno].factor[2]);
+		
+		if (volume->comps[0].prec <= 8) {
+			nbytes = 1;
+		} else if (volume->comps[0].prec <= 16) {
+			nbytes = 2;
+		} else {
+			nbytes = 4;
+		}
+
+		//fprintf(stdout,"w %d wr %d wrr %d h %d hr %d hrr %d l %d lr %d lrr %d max %d nbytes %d\n Factor %d %d %d",w,wr,wrr,h,hr,hrr,l,lr,lrr,max,nbytes,volume->comps[compno].factor[0],volume->comps[compno].factor[1],volume->comps[compno].factor[2]);
+
+		for(sliceno = 0; sliceno < lrr; sliceno++) {
+			offset = (sliceno / lrr * l) + (sliceno % lrr);
+            offset = wrr * hrr * offset;
+			for (i = 0; i < wrr * hrr; i++) {
+				int v = volume->comps[0].data[(i / wrr * w) + (i % wrr) + offset];
+				if (volume->comps[0].bigendian) {
+					for (j = nbytes - 1; j >= 0; j--) {
+                        char byte = (char) ((v >> (j * 8)) & 0xff);
+                        fwrite(&byte, 1, 1, fdest);
+					}
+				} else {
+					for (j = 0; j <= nbytes - 1; j++) {
+                        char byte = (char) ((v >> (j * 8)) & 0xff);
+						fwrite(&byte, 1, 1, fdest);
+					}
+				}
+			}
+		}
+	
+	}
+	
+	fclose(fdest);
+
+	sprintf(name,"%s.img",outfile);
+	fimgdest = fopen(name, "w");
+		if (!fimgdest) {
+			fprintf(stdout, "[ERROR] Failed to open %s for writing\n", name);
+			return 1;
+		}
+	fprintf(fimgdest, "Bpp\t%d\nColor Map\t2\nDimensions\t%d\t%d\t%d\nResolution(mm)\t%d\t%d\t%d\t\n",
+		volume->comps[0].prec,wrr,hrr,lrr,volume->comps[0].dx,volume->comps[0].dy,volume->comps[0].dz);
+
+	fclose(fimgdest);
+	return 0;
+}
+/* -->> -->> -->> -->>
+
+IMG IMAGE FORMAT
+
+<<-- <<-- <<-- <<-- */
+opj_volume_t* imgtovolume(char *fileimg, opj_cparameters_t *parameters) {
+	int subsampling_dx =  parameters->subsampling_dx;
+	int subsampling_dy =  parameters->subsampling_dy;
+	int subsampling_dz =  parameters->subsampling_dz;
+	
+	int i, compno, w, h, l, numcomps = 1;
+	int prec, max = 0, min = 0;
+	float dx, dy, dz;
+	char filename[100], tmpdirpath[100], dirpath[100], *tmp;
+	char line[100], datatype[100];
+	int bigendian;
+	
+	FILE *f = NULL;
+	FILE *fimg = NULL;
+	OPJ_COLOR_SPACE color_space;
+	opj_volume_cmptparm_t cmptparm;	/* maximum of 1 component */
+	opj_volume_t * volume = NULL;
+	opj_volume_comp_t *comp = NULL;
+
+	bigendian = 0;
+	color_space = CLRSPC_GRAY;
+
+	fimg = fopen(fileimg,"r");
+	if (!fimg) { 
+		fprintf(stderr, "[ERROR] Failed to open %s for reading !!\n", fileimg);
+		return 0;
+	}
+
+	//Fetch only the path 
+	strcpy(tmpdirpath,fileimg);
+	if ((tmp = strrchr(tmpdirpath,'/')) != NULL){
+		tmp++; *tmp='\0';
+		strcpy(dirpath,tmpdirpath);
+	} else {
+		strcpy(dirpath,"./");
+	}
+
+	fseek(fimg, 0, SEEK_SET);
+	while (!feof(fimg)) {
+        fgets(line,100,fimg);
+		//fprintf(stdout,"%s %d \n",line,feof(fimg));
+		if (strncmp(line,"Image",5) == 0){
+			sscanf(line,"%*s%*[ \t]%s",datatype);
+		} else if (strncmp(line,"File",4) == 0){
+			sscanf(line,"%*s %*s%*[ \t]%s",filename);
+			strcat(dirpath, filename);
+			strcpy(filename,dirpath);
+		} else if (strncmp(line,"Min",3) == 0){
+			sscanf(line,"%*s %*s%*[ \t]%d%*[ \t]%d",&min,&max);
+			prec = int_floorlog2(max - min + 1);
+		} else if (strncmp(line,"Bpp",3) == 0){
+			sscanf(line,"%*s%*[ \t]%d",&prec);
+		} else if (strncmp(line,"Color",5) == 0){
+			sscanf(line, "%*s %*s%*[ \t]%d",&color_space);
+		} else if (strncmp(line,"Dim",3) == 0){
+			sscanf(line, "%*s%*[ \t]%d%*[ \t]%d%*[ \t]%d",&w,&h,&l);
+		} else if (strncmp(line,"Res",3) == 0){
+			sscanf(line,"%*s%*[ \t]%f%*[ \t]%f%*[ \t]%f",&dx,&dy,&dz);
+		}
+
+	}
+	#ifdef VERBOSE
+		fprintf(stdout, "[INFO] %s %d \t %d %d %d \t %f %f %f \t %d %d %d \n",filename,color_space,w,h,l,dx,dy,dz,max,min,prec);
+	#endif
+	fclose(fimg);
+
+	/* error control */
+	if ( !prec || !w || !h || !l ){
+		fprintf(stderr,"[ERROR] Unable to read IMG file correctly. Found some null values.");	
+		return NULL;
+	}
+
+	/* initialize volume components */
+	memset(&cmptparm, 0, sizeof(opj_volume_cmptparm_t));
+	
+	cmptparm.prec = prec;
+	cmptparm.bpp = prec;
+	cmptparm.sgnd = 0;
+	cmptparm.bigendian = bigendian;
+	cmptparm.dcoffset = parameters->dcoffset;
+	cmptparm.dx = subsampling_dx;
+	cmptparm.dy = subsampling_dy;
+	cmptparm.dz = subsampling_dz;
+	cmptparm.w = w;
+	cmptparm.h = h;
+	cmptparm.l = l;
+	
+	/* create the volume */
+	volume = opj_volume_create(numcomps, &cmptparm, color_space);
+	if(!volume) {
+		fprintf(stdout,"[ERROR] Unable to create volume");	
+		return NULL;
+	}
+	
+	/* set volume offset and reference grid */
+	volume->x0 = parameters->volume_offset_x0;
+	volume->y0 = parameters->volume_offset_y0;
+	volume->z0 = parameters->volume_offset_z0;
+	volume->x1 = parameters->volume_offset_x0 + (w - 1) *	subsampling_dx + 1;
+	volume->y1 = parameters->volume_offset_y0 + (h - 1) *	subsampling_dy + 1;
+	volume->z1 = parameters->volume_offset_z0 + (l - 1) *	subsampling_dz + 1;
+	
+	max = 0;
+	/* set volume data */
+	f = fopen(filename, "rb");
+	if (!f) {
+		fprintf(stderr, "[ERROR] Failed to open %s for reading !!\n", filename);
+		fclose(f);
+		return 0;
+	}
+	
+	/* BINARY */
+	for (compno = 0; compno < volume->numcomps; compno++) {
+		int whl = w * h * l;
+		/* set volume data */
+		comp = &volume->comps[compno];
+		
+		/*if (comp->prec <= 8) {
+			if (!comp->sgnd) {
+                unsigned char *data = (unsigned char *) malloc(whl * sizeof(unsigned char));
+				fread(data, 1, whl, f);
+				for (i = 0; i < whl; i++) {
+					comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				char *data = (char *) malloc(whl);
+				fread(data, 1, whl, f);
+				for (i = 0; i < whl; i++) {
+					comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			}
+		} else if (comp->prec <= 16) {
+			if (!comp->sgnd) {
+                unsigned short *data = (unsigned short *) malloc(whl * sizeof(unsigned short));
+				int leido = fread(data, 2, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}
+				
+				for (i = 0; i < whl; i++) {
+					if (bigendian)	//(c1 << 8) + c2;
+						comp->data[i] = data[i];
+					else{			//(c2 << 8) + c1;
+						comp->data[i] = ShortSwap(data[i]);
+					}
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				short *data = (short *) malloc(whl);
+				int leido = fread(data, 2, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}
+				for (i = 0; i < whl; i++) {
+					if (bigendian){	//(c1 << 8) + c2;
+						comp->data[i] = data[i];
+					}else{			//(c2 << 8) + c1;
+						comp->data[i] = (short) ShortSwap((unsigned short) data[i]);
+					}
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			}
+		} else {
+			if (!comp->sgnd) {
+                unsigned int *data = (unsigned int *) malloc(whl * sizeof(unsigned int));
+				int leido = fread(data, 4, whl, f);
+				if (!leido)	{
+					free(data);	fclose(f);
+					return NULL;
+				}				for (i = 0; i < whl; i++) {
+					if (!bigendian)
+						comp->data[i] = LongSwap(data[i]);
+					else
+						comp->data[i] = data[i];
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+				free(data);
+			} else {
+				int leido = fread(comp->data, 4, whl, f);
+				if (!leido)	{
+					fclose(f);
+					return NULL;
+				}				
+				for (i = 0; i < whl; i++) {
+					if (!bigendian) 
+						comp->data[i] = (int) LongSwap((unsigned int) comp->data[i]);
+					if (comp->data[i] > max)
+						max = comp->data[i];
+				}
+			}
+		}*/
+		
+		for (i = 0; i < whl; i++) {
+			int v;
+			if (comp->prec <= 8) {
+				if (!comp->sgnd) {
+					v = readuchar(f);
+				} else {
+					v = (char) readuchar(f);
+				}
+			} else if (comp->prec <= 16) {
+				if (!comp->sgnd) {
+					v = readushort(f, bigendian);
+				} else {
+					v = (short) readushort(f, bigendian);
+				}
+			} else {
+				if (!comp->sgnd) {
+					v = readuint(f, bigendian);
+				} else {
+					v = (int) readuint(f, bigendian);
+				}
+			}
+			if (v > max)
+				max = v;
+			comp->data[i] = v;
+		}
+		comp->bpp = int_floorlog2(max) + 1;
+	}
+	fclose(f);
+	return volume;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/convert.h.svn-base ./jp3d/codec/.svn/text-base/convert.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/convert.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,51 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herv Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __JP3D_CONVERT_H
+#define __JP3D_CONVERT_H
+
+/**
+Load a single volume component encoded in PGX file format
+@param filename Name of the PGX file to load
+@param parameters *List ?*
+@return Returns a greyscale volume if successful, returns NULL otherwise
+*/
+opj_volume_t* pgxtovolume(char *filename, opj_cparameters_t *parameters);
+
+int volumetopgx(opj_volume_t *volume, char *outfile);
+
+opj_volume_t* bintovolume(char *filename,char *fileimg, opj_cparameters_t *parameters);
+
+int volumetobin(opj_volume_t *volume, char *outfile);
+
+opj_volume_t* imgtovolume(char *fileimg, opj_cparameters_t *parameters);
+
+#endif /* __J2K_CONVERT_H */
+
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/dirent.h.svn-base ./jp3d/codec/.svn/text-base/dirent.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/dirent.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/dirent.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,676 @@
+/*
+ * uce-dirent.h - operating system independent dirent implementation
+ * 
+ * Copyright (C) 1998-2002  Toni Ronkko
+ * 
+ * Permission is hereby granted, free of charge, to any person obtaining
+ * a copy of this software and associated documentation files (the
+ * ``Software''), to deal in the Software without restriction, including
+ * without limitation the rights to use, copy, modify, merge, publish,
+ * distribute, sublicense, and/or sell copies of the Software, and to
+ * permit persons to whom the Software is furnished to do so, subject to
+ * the following conditions:
+ * 
+ * The above copyright notice and this permission notice shall be included
+ * in all copies or substantial portions of the Software.
+ * 
+ * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ * 
+ * 
+ * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
+ *
+ * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
+ *
+ * $Log: uce-dirent.h,v $
+ * Revision 1.7  2002/05/13 10:48:35  tr
+ * embedded some source code directly to the header so that no source
+ * modules need to be included in the MS Visual C project using the
+ * interface, removed all the dependencies to other headers of the `uce'
+ * library so that the header can be made public
+ *
+ * Revision 1.6  2002/04/12 16:22:04  tr
+ * Unified Compiling Environment (UCE) replaced `std' library
+ *
+ * Revision 1.5  2001/07/20 16:33:40  tr
+ * moved to `std' library and re-named defines accordingly
+ *
+ * Revision 1.4  2001/07/10 16:47:18  tronkko
+ * revised comments
+ *
+ * Revision 1.3  2001/01/11 13:16:43  tr
+ * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
+ *
+ * Revision 1.2  2000/10/08 16:00:41  tr
+ * copy of FreeBSD man page
+ *
+ * Revision 1.1  2000/07/10 05:53:16  tr
+ * Initial revision
+ *
+ * Revision 1.2  1998/07/19 18:29:14  tr
+ * Added error reporting capabilities and some asserts.
+ *
+ * Revision 1.1  1998/07/04 16:27:51  tr
+ * Initial revision
+ *
+ * 
+ * MSVC 1.0 scans automatic dependencies incorrectly when your project
+ * contains this very header.  The problem is that MSVC cannot handle
+ * include directives inside #if..#endif block those are never entered.
+ * Since this header ought to compile in many different operating systems,
+ * there had to be several conditional blocks that are compiled only in
+ * operating systems for what they were designed for.  MSVC 1.0 cannot
+ * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
+ * operating system.  To fix the problem you need to insert DIR.H into
+ * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
+ * Consult manuals for more informaton about the problem.
+ *
+ * Since many UNIX systems have dirent.h we assume to have one also.
+ * However, if your UNIX system does not have dirent.h you can download one
+ * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
+ * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
+ * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
+ * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
+ * HAVE_SYS_NDIR_H according to the files found.
+ */
+#ifndef DIRENT_H
+#define DIRENT_H
+#define DIRENT_H_INCLUDED
+
+/* find out platform */
+#if defined(MSDOS)                             /* MS-DOS */
+#elif defined(__MSDOS__)                       /* Turbo C/Borland */
+# define MSDOS
+#elif defined(__DOS__)                         /* Watcom */
+# define MSDOS
+#endif
+
+#if defined(WIN32)                             /* MS-Windows */
+#elif defined(__NT__)                          /* Watcom */
+# define WIN32
+#elif defined(_WIN32)                          /* Microsoft */
+# define WIN32
+#elif defined(__WIN32__)                       /* Borland */
+# define WIN32
+#endif
+
+/*
+ * See what kind of dirent interface we have unless autoconf has already
+ * determinated that.
+ */
+#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
+# if defined(_MSC_VER)                         /* Microsoft C/C++ */
+    /* no dirent.h */
+# elif defined(__BORLANDC__)                   /* Borland C/C++ */
+#   define HAVE_DIRENT_H
+#   define VOID_CLOSEDIR
+# elif defined(__TURBOC__)                     /* Borland Turbo C */
+    /* no dirent.h */
+# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
+#   define HAVE_DIRECT_H
+# elif defined(__apollo)                       /* Apollo */
+#   define HAVE_SYS_DIR_H
+# elif defined(__hpux)                         /* HP-UX */
+#   define HAVE_DIRENT_H
+# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
+#   error "not implemented"
+# elif defined(__sgi)                          /* Silicon Graphics */
+#   define HAVE_DIRENT_H
+# elif defined(sun) || defined(_sun)           /* Sun Solaris */
+#   define HAVE_DIRENT_H
+# elif defined(__FreeBSD__)                    /* FreeBSD */
+#   define HAVE_DIRENT_H
+# elif defined(__linux__)                      /* Linux */
+#   define HAVE_DIRENT_H
+# elif defined(__GNUC__)                       /* GNU C/C++ */
+#   define HAVE_DIRENT_H
+# else
+#   error "not implemented"
+# endif
+#endif
+
+/* include proper interface headers */
+#if defined(HAVE_DIRENT_H)
+# include <dirent.h>
+# ifdef FREEBSD
+#   define NAMLEN(dp) ((int)((dp)->d_namlen))
+# else
+#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+# endif
+
+#elif defined(HAVE_NDIR_H)
+# include <ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_NDIR_H)
+# include <sys/ndir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIRECT_H)
+# include <direct.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_DIR_H)
+# include <dir.h>
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(HAVE_SYS_DIR_H)
+# include <sys/types.h>
+# include <sys/dir.h>
+# ifndef dirent
+#   define dirent direct
+# endif
+# define NAMLEN(dp) ((int)((dp)->d_namlen))
+
+#elif defined(MSDOS) || defined(WIN32)
+
+  /* figure out type of underlaying directory interface to be used */
+# if defined(WIN32)
+#   define DIRENT_WIN32_INTERFACE
+# elif defined(MSDOS)
+#   define DIRENT_MSDOS_INTERFACE
+# else
+#   error "missing native dirent interface"
+# endif
+
+  /*** WIN32 specifics ***/
+# if defined(DIRENT_WIN32_INTERFACE)
+#   include <windows.h>
+#   if !defined(DIRENT_MAXNAMLEN)
+#     define DIRENT_MAXNAMLEN (MAX_PATH)
+#   endif
+
+
+  /*** MS-DOS specifics ***/
+# elif defined(DIRENT_MSDOS_INTERFACE)
+#   include <dos.h>
+
+    /* Borland defines file length macros in dir.h */
+#   if defined(__BORLANDC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     if !defined(_find_t)
+#       define _find_t find_t
+#     endif
+
+    /* Turbo C defines ffblk structure in dir.h */
+#   elif defined(__TURBOC__)
+#     include <dir.h>
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
+#     endif
+#     define DIRENT_USE_FFBLK
+
+    /* MSVC */
+#   elif defined(_MSC_VER)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       define DIRENT_MAXNAMLEN (12)
+#     endif
+
+    /* Watcom */
+#   elif defined(__WATCOMC__)
+#     if !defined(DIRENT_MAXNAMLEN)
+#       if defined(__OS2__) || defined(__NT__)
+#         define DIRENT_MAXNAMLEN (255)
+#       else
+#         define DIRENT_MAXNAMLEN (12)
+#       endif
+#     endif
+
+#   endif
+# endif
+
+  /*** generic MS-DOS and MS-Windows stuff ***/
+# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
+#   define NAME_MAX DIRENT_MAXNAMLEN
+# endif
+# if NAME_MAX < DIRENT_MAXNAMLEN
+#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
+# endif
+
+
+  /*
+   * Substitute for real dirent structure.  Note that `d_name' field is a
+   * true character array although we have it copied in the implementation
+   * dependent data.  We could save some memory if we had declared `d_name'
+   * as a pointer refering the name within implementation dependent data.
+   * We have not done that since some code may rely on sizeof(d_name) to be
+   * something other than four.  Besides, directory entries are typically so
+   * small that it takes virtually no time to copy them from place to place.
+   */
+  typedef struct dirent {
+    char d_name[NAME_MAX + 1];
+
+    /*** Operating system specific part ***/
+# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
+    WIN32_FIND_DATA data;
+# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
+#   if defined(DIRENT_USE_FFBLK)
+    struct ffblk data;
+#   else
+    struct _find_t data;
+#   endif
+# endif
+  } dirent;
+
+  /* DIR substitute structure containing directory name.  The name is
+   * essential for the operation of ``rewinndir'' function. */
+  typedef struct DIR {
+    char          *dirname;                    /* directory being scanned */
+    dirent        current;                     /* current entry */
+    int           dirent_filled;               /* is current un-processed? */
+
+  /*** Operating system specific part ***/
+#  if defined(DIRENT_WIN32_INTERFACE)
+    HANDLE        search_handle;
+#  elif defined(DIRENT_MSDOS_INTERFACE)
+#  endif
+  } DIR;
+
+# ifdef __cplusplus
+extern "C" {
+# endif
+
+/* supply prototypes for dirent functions */
+static DIR *opendir (const char *dirname);
+static struct dirent *readdir (DIR *dirp);
+static int closedir (DIR *dirp);
+static void rewinddir (DIR *dirp);
+
+/*
+ * Implement dirent interface as static functions so that the user does not
+ * need to change his project in any way to use dirent function.  With this
+ * it is sufficient to include this very header from source modules using
+ * dirent functions and the functions will be pulled in automatically.
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+#include <assert.h>
+#include <errno.h>
+
+/* use ffblk instead of _find_t if requested */
+#if defined(DIRENT_USE_FFBLK)
+# define _A_ARCH   (FA_ARCH)
+# define _A_HIDDEN (FA_HIDDEN)
+# define _A_NORMAL (0)
+# define _A_RDONLY (FA_RDONLY)
+# define _A_SUBDIR (FA_DIREC)
+# define _A_SYSTEM (FA_SYSTEM)
+# define _A_VOLID  (FA_LABEL)
+# define _dos_findnext(dest) findnext(dest)
+# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
+#endif
+
+static int _initdir (DIR *p);
+static const char *_getdirname (const struct dirent *dp);
+static void _setdirname (struct DIR *dirp);
+
+/*
+ * <function name="opendir">
+ * <intro>open directory stream for reading
+ * <syntax>DIR *opendir (const char *dirname);
+ *
+ * <desc>Open named directory stream for read and return pointer to the
+ * internal working area that is used for retrieving individual directory
+ * entries.  The internal working area has no fields of your interest.
+ *
+ * <ret>Returns a pointer to the internal working area or NULL in case the 
+ * directory stream could not be opened.  Global `errno' variable will set
+ * in case of error as follows:
+ *
+ * <table>
+ * [EACESS  |Permission denied.
+ * [EMFILE  |Too many open files used by the process.
+ * [ENFILE  |Too many open files in system.
+ * [ENOENT  |Directory does not exist.
+ * [ENOMEM  |Insufficient memory.
+ * [ENOTDIR |dirname does not refer to directory.  This value is not
+ *           reliable on MS-DOS and MS-Windows platforms.  Many
+ *           implementations return ENOENT even when the name refers to a
+ *           file.]
+ * </table>
+ * </function>
+ */
+static DIR *opendir(const char *dirname)
+{
+  DIR *dirp;
+  assert (dirname != NULL);
+  
+  dirp = (DIR*)malloc (sizeof (struct DIR));
+  if (dirp != NULL) {
+    char *p;
+    
+    /* allocate room for directory name */
+    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
+    if (dirp->dirname == NULL) {
+      /* failed to duplicate directory name.  errno set by malloc() */
+      free (dirp);
+      return NULL;
+    }
+    /* Copy directory name while appending directory separator and "*.*".
+     * Directory separator is not appended if the name already ends with
+     * drive or directory separator.  Directory separator is assumed to be
+     * '/' or '\' and drive separator is assumed to be ':'. */
+    strcpy (dirp->dirname, dirname);
+    p = strchr (dirp->dirname, '\0');
+    if (dirp->dirname < p  &&
+        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
+    {
+      strcpy (p++, "\\");
+    }
+# ifdef DIRENT_WIN32_INTERFACE
+    strcpy (p, "*"); /*scan files with and without extension in win32*/
+# else
+    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
+# endif
+
+    /* open stream */
+    if (_initdir (dirp) == 0) {
+      /* initialization failed */
+      free (dirp->dirname);
+      free (dirp);
+      return NULL;
+    }
+  }
+  return dirp;
+}
+
+
+/*
+ * <function name="readdir">
+ * <intro>read a directory entry
+ * <syntax>struct dirent *readdir (DIR *dirp);
+ *
+ * <desc>Read individual directory entry and return pointer to a structure
+ * containing the name of the entry.  Individual directory entries returned
+ * include normal files, sub-directories, pseudo-directories "." and ".."
+ * and also volume labels, hidden files and system files in MS-DOS and
+ * MS-Windows.   You might want to use stat(2) function to determinate which
+ * one are you dealing with.  Many dirent implementations already contain
+ * equivalent information in dirent structure but you cannot depend on
+ * this.
+ *
+ * The dirent structure contains several system dependent fields that
+ * generally have no interest to you.  The only interesting one is char
+ * d_name[] that is also portable across different systems.  The d_name
+ * field contains the name of the directory entry without leading path.
+ * While d_name is portable across different systems the actual storage
+ * capacity of d_name varies from system to system and there is no portable
+ * way to find out it at compile time as different systems define the
+ * capacity of d_name with different macros and some systems do not define
+ * capacity at all (besides actual declaration of the field). If you really
+ * need to find out storage capacity of d_name then you might want to try
+ * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
+ * there are many MS-DOS and MS-Windows implementations those do not define
+ * it.  There are also systems that declare d_name as "char d_name[1]" and
+ * then allocate suitable amount of memory at run-time.  Thanks to Alain
+ * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
+ *
+ * This all leads to the fact that it is difficult to allocate space
+ * for the directory names when the very same program is being compiled on
+ * number of operating systems.  Therefore I suggest that you always
+ * allocate space for directory names dynamically.
+ *
+ * <ret>
+ * Returns a pointer to a structure containing name of the directory entry
+ * in `d_name' field or NULL if there was an error.  In case of an error the
+ * global `errno' variable will set as follows:
+ *
+ * <table>
+ * [EBADF  |dir parameter refers to an invalid directory stream.  This value
+ *          is not set reliably on all implementations.]
+ * </table>
+ * </function>
+ */
+static struct dirent *
+readdir (DIR *dirp)
+{
+  assert(dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return NULL;
+  }
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* directory stream was opened/rewound incorrectly or it ended normally */
+    errno = EBADF;
+    return NULL;
+  }
+#endif
+
+  if (dirp->dirent_filled != 0) {
+    /*
+     * Directory entry has already been retrieved and there is no need to
+     * retrieve a new one.  Directory entry will be retrieved in advance
+     * when the user calls readdir function for the first time.  This is so
+     * because real dirent has separate functions for opening and reading
+     * the stream whereas Win32 and DOS dirents open the stream
+     * automatically when we retrieve the first file.  Therefore, we have to
+     * save the first file when opening the stream and later we have to
+     * return the saved entry when the user tries to read the first entry.
+     */
+    dirp->dirent_filled = 0;
+  } else {
+    /* fill in entry and return that */
+#if defined(DIRENT_WIN32_INTERFACE)
+    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
+      /* Last file has been processed or an error occured */
+      FindClose (dirp->search_handle);
+      dirp->search_handle = INVALID_HANDLE_VALUE;
+      errno = ENOENT;
+      return NULL;
+    }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+    if (_dos_findnext (&dirp->current.data) != 0) {
+      /* _dos_findnext and findnext will set errno to ENOENT when no
+       * more entries could be retrieved. */
+      return NULL;
+    }
+# endif
+
+    _setdirname (dirp);
+    assert (dirp->dirent_filled == 0);
+  }
+  return &dirp->current;
+}
+
+
+/*
+ * <function name="closedir">
+ * <intro>close directory stream.
+ * <syntax>int closedir (DIR *dirp);
+ *
+ * <desc>Close directory stream opened by the `opendir' function.  Close of
+ * directory stream invalidates the DIR structure as well as previously read
+ * dirent entry.
+ *
+ * <ret>The function typically returns 0 on success and -1 on failure but
+ * the function may be declared to return void on same systems.  At least
+ * Borland C/C++ and some UNIX implementations use void as a return type.
+ * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
+ * known to return nothing.  The very same definition is made by the GNU
+ * autoconf if you happen to use it.
+ *
+ * The global `errno' variable will set to EBADF in case of error.
+ * </function>
+ */
+static int
+closedir (DIR *dirp)
+{   
+  int retcode = 0;
+
+  /* make sure that dirp points to legal structure */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return -1;
+  }
+ 
+  /* free directory name and search handles */
+  if (dirp->dirname != NULL) free (dirp->dirname);
+
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      retcode = -1;
+      errno = EBADF;
+    }
+  }
+#endif                     
+
+  /* clear dirp structure to make sure that it cannot be used anymore*/
+  memset (dirp, 0, sizeof (*dirp));
+# if defined(DIRENT_WIN32_INTERFACE)
+  dirp->search_handle = INVALID_HANDLE_VALUE;
+# endif
+
+  free (dirp);
+  return retcode;
+}
+
+
+/*
+ * <function name="rewinddir">
+ * <intro>rewind directory stream to the beginning
+ * <syntax>void rewinddir (DIR *dirp);
+ *
+ * <desc>Rewind directory stream to the beginning so that the next call of
+ * readdir() returns the very first directory entry again.  However, note
+ * that next call of readdir() may not return the same directory entry as it
+ * did in first time.  The directory stream may have been affected by newly
+ * created files.
+ *
+ * Almost every dirent implementation ensure that rewinddir will update
+ * the directory stream to reflect any changes made to the directory entries
+ * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
+ * this if your program depends on the feature.  I know at least one dirent
+ * implementation where you are required to close and re-open the stream to
+ * see the changes.
+ *
+ * <ret>Returns nothing.  If something went wrong while rewinding, you will
+ * notice it later when you try to retrieve the first directory entry.
+ */
+static void
+rewinddir (DIR *dirp)
+{   
+  /* make sure that dirp is legal */
+  assert (dirp != NULL);
+  if (dirp == NULL) {
+    errno = EBADF;
+    return;
+  }
+  assert (dirp->dirname != NULL);
+  
+  /* close previous stream */
+#if defined(DIRENT_WIN32_INTERFACE)
+  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
+    if (FindClose (dirp->search_handle) == FALSE) {
+      /* Unknown error */
+      errno = EBADF;
+    }
+  }
+#endif
+
+  /* re-open previous stream */
+  if (_initdir (dirp) == 0) {
+    /* initialization failed but we cannot deal with error.  User will notice
+     * error later when she tries to retrieve first directory enty. */
+    /*EMPTY*/;
+  }
+}
+
+
+/*
+ * Open native directory stream object and retrieve first file.
+ * Be sure to close previous stream before opening new one.
+ */
+static int
+_initdir (DIR *dirp)
+{ 
+  assert (dirp != NULL);
+  assert (dirp->dirname != NULL);
+  dirp->dirent_filled = 0;
+
+# if defined(DIRENT_WIN32_INTERFACE)
+  /* Open stream and retrieve first file */
+  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
+  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
+    /* something went wrong but we don't know what.  GetLastError() could
+     * give us more information about the error, but then we should map
+     * the error code into errno. */
+    errno = ENOENT;
+    return 0;
+  }
+
+# elif defined(DIRENT_MSDOS_INTERFACE)
+  if (_dos_findfirst (dirp->dirname,
+          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
+          &dirp->current.data) != 0)
+  {
+    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
+     * more entries could be retrieved. */
+    return 0;
+  }
+# endif
+
+  /* initialize DIR and it's first entry */
+  _setdirname (dirp);
+  dirp->dirent_filled = 1;
+  return 1;
+}
+
+
+/*
+ * Return implementation dependent name of the current directory entry.
+ */
+static const char *
+_getdirname (const struct dirent *dp)
+{
+#if defined(DIRENT_WIN32_INTERFACE)
+  return dp->data.cFileName;
+  
+#elif defined(DIRENT_USE_FFBLK)
+  return dp->data.ff_name;
+  
+#else
+  return dp->data.name;
+#endif  
+}
+
+
+/*
+ * Copy name of implementation dependent directory entry to the d_name field.
+ */
+static void
+_setdirname (struct DIR *dirp) {
+  /* make sure that d_name is long enough */
+  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
+  
+  strncpy (dirp->current.d_name,
+      _getdirname (&dirp->current),
+      NAME_MAX);
+  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
+}
+  
+# ifdef __cplusplus
+}
+# endif
+# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
+
+#else
+# error "missing dirent interface"
+#endif
+
+
+#endif /*DIRENT_H*/
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/getopt.c.svn-base ./jp3d/codec/.svn/text-base/getopt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/getopt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/getopt.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,109 @@
+/*
+ * Copyright (c) 1987, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* last review : october 29th, 2002 */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
+#endif				/* LIBC_SCCS and not lint */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int opterr = 1,			/* if error message should be printed */
+ optind = 1,			/* index into parent argv vector */
+ optopt,				/* character checked for validity */
+ optreset;				/* reset getopt */
+char *optarg;			/* argument associated with option */
+
+#define	BADCH	(int)'?'
+#define	BADARG	(int)':'
+#define	EMSG	""
+
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ */
+int getopt(int nargc, char *const *nargv, const char *ostr) {
+	
+  #  define __progname nargv[0] /* program name */
+	
+  static char *place = EMSG;	/* option letter processing */
+  char *oli;					/* option letter list index */
+
+  if (optreset || !*place) {	/* update scanning pointer */
+    optreset = 0;
+    if (optind >= nargc || *(place = nargv[optind]) != '-') {
+      place = EMSG;
+      return (-1);
+    }
+    if (place[1] && *++place == '-') {	/* found "--" */
+      ++optind;
+      place = EMSG;
+      return (-1);
+    }
+  }	/* option letter okay? */
+  
+  if ((optopt = (int) *place++) == (int) ':' || !(oli = strchr(ostr, optopt))) {
+    /* if the user didn't specify '-' as an option, assume it means -1. */
+    if (optopt == (int) '-')
+      return (-1);
+    if (!*place)
+      ++optind;
+    if (opterr && *ostr != ':')
+      (void) fprintf(stdout,"[ERROR] %s: illegal option -- %c\n", __progname, optopt);
+    return (BADCH);
+  }
+
+  if (*++oli != ':') {		/* don't need argument */
+    optarg = NULL;
+    if (!*place)
+      ++optind;
+  } else {					/* need an argument */
+    if (*place)						/* no white space */
+      optarg = place;
+    else if (nargc <= ++optind) {	/* no arg */
+      place = EMSG;
+      if (*ostr == ':')
+		return (BADARG);
+      if (opterr)
+		(void) fprintf(stdout, "[ERROR] %s: option requires an argument -- %c\n", __progname, optopt);
+      return (BADCH);
+    } else							/* white space */
+      optarg = nargv[optind];
+    place = EMSG;
+    ++optind;
+  }
+  return (optopt);		/* dump back option letter */
+}
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/getopt.h.svn-base ./jp3d/codec/.svn/text-base/getopt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/getopt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/getopt.h.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,14 @@
+/* last review : october 29th, 2002 */
+
+#ifndef _GETOPT_H_
+#define _GETOPT_H_
+
+extern int opterr;
+extern int optind;
+extern int optopt;
+extern int optreset;
+extern char *optarg;
+
+extern int getopt(int nargc, char *const *nargv, const char *ostr);
+
+#endif				/* _GETOPT_H_ */
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_to_volume.c.svn-base ./jp3d/codec/.svn/text-base/jp3d_to_volume.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_to_volume.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/jp3d_to_volume.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,535 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+#include <math.h>
+
+#include "openjpeg.h"
+#include "getopt.h"
+#include "convert.h"
+
+#ifndef WIN32
+#define stricmp strcasecmp
+#define strnicmp strncasecmp
+#endif
+
+/* ----------------------------------------------------------------------- */
+static double calc_PSNR(opj_volume_t *original, opj_volume_t *decoded)
+{
+	int max, i, k, compno = 0, size;
+	double sum, total = 0;
+	int global = 1;
+    
+	max = (original->comps[compno].prec <= 8) ? 255 : (1 << original->comps[compno].prec) - 1;
+	if (global) {
+		size = (original->x1 - original->x0) * (original->y1 - original->y0) * (original->z1 - original->z0);
+
+		for (compno = 0; compno < original->numcomps; compno++) {
+			for(sum = 0, i = 0; i < size; ++i) {
+				if ((decoded->comps[compno].data[i] < 0) || (decoded->comps[compno].data[i] > max))
+					fprintf(stdout,"[WARNING] Data out of range during PSNR computing...\n");
+				else
+					sum += (original->comps[compno].data[i] - decoded->comps[compno].data[i]) * (original->comps[compno].data[i] - decoded->comps[compno].data[i]);        
+			}
+		}
+		sum /= size;
+		total = ((sum==0.0) ? 0.0 : 10 * log10(max * max / sum));
+	} else {
+		size = (original->x1 - original->x0) * (original->y1 - original->y0);
+
+		for (k = 0; k < original->z1 - original->z0; k++) {
+			int offset = k * size;
+			for (sum = 0, compno = 0; compno < original->numcomps; compno++) {
+				for(i = 0; i < size; ++i) {
+					if ((decoded->comps[compno].data[i + offset] < 0) || (decoded->comps[compno].data[i + offset] > max))
+						fprintf(stdout,"[WARNING] Data out of range during PSNR computing...\n");
+					else
+						sum += (original->comps[compno].data[i + offset] - decoded->comps[compno].data[i + offset]) * (original->comps[compno].data[i + offset] - decoded->comps[compno].data[i + offset]);        
+				}
+			}
+			sum /= size;
+			total = total + ((sum==0.0) ? 0.0 : 10 * log10(max * max / sum));
+		}
+
+	}
+	if(total == 0) /* perfect reconstruction, PSNR should return infinity */
+		return -1.0;
+	
+	return total;
+	//return 20 * log10((max - 1) / sqrt(sum));
+}
+
+static double calc_SSIM(opj_volume_t *original, opj_volume_t *decoded)
+{
+	int max, i, compno = 0, size, sizeM;
+	double sum;
+	double mux = 0.0, muy = 0.0, sigmax = 0.0, sigmay = 0.0,
+		sigmaxy = 0.0, structx = 0.0, structy = 0.0;
+	double lcomp,ccomp,scomp;
+	double C1,C2,C3;
+
+	max = (original->comps[compno].prec <= 8) ? 255 : (1 << original->comps[compno].prec) - 1;
+	size = (original->x1 - original->x0) * (original->y1 - original->y0) * (original->z1 - original->z0);
+
+	//MSSIM
+
+//	sizeM = size / (original->z1 - original->z0);
+
+	sizeM = size;	
+	for(sum = 0, i = 0; i < sizeM; ++i) {
+		// First, the luminance of each signal is compared.
+		mux += original->comps[compno].data[i];
+		muy += decoded->comps[compno].data[i];
+	}
+	mux /= sizeM;
+	muy /= sizeM;
+	
+	//We use the standard deviation (the square root of variance) as an estimate of the signal contrast.
+    for(sum = 0, i = 0; i < sizeM; ++i) {
+		// First, the luminance of each signal is compared.
+		sigmax += (original->comps[compno].data[i] - mux) * (original->comps[compno].data[i] - mux);
+		sigmay += (decoded->comps[compno].data[i] - muy) * (decoded->comps[compno].data[i] - muy);
+		sigmaxy += (original->comps[compno].data[i] - mux) * (decoded->comps[compno].data[i] - muy);
+	}
+	sigmax /= sizeM - 1;
+	sigmay /= sizeM - 1;
+	sigmaxy /= sizeM - 1;
+	
+	sigmax = sqrt(sigmax);
+	sigmay = sqrt(sigmay);
+	sigmaxy = sqrt(sigmaxy);
+
+	//Third, the signal is normalized (divided) by its own standard deviation, 
+	//so that the two signals being compared have unit standard deviation.
+
+	//Luminance comparison
+	C1 = (0.01 * max) * (0.01 * max);
+	lcomp = ((2 * mux * muy) + C1)/((mux*mux) + (muy*mux) + C1);
+	//Constrast comparison
+	C2 = (0.03 * max) * (0.03 * max);
+	ccomp = ((2 * sigmax * sigmay) + C2)/((sigmax*sigmax) + (sigmay*sigmay) + C2);
+	//Structure comparison
+	C3 = C2 / 2;
+	scomp = (sigmaxy + C3) / (sigmax * sigmay + C3);
+	//Similarity measure
+
+	sum = lcomp * ccomp * scomp;
+	return sum;
+}
+
+void decode_help_display() {
+	fprintf(stdout,"HELP\n----\n\n");
+	fprintf(stdout,"- the -h option displays this help information on screen\n\n");
+
+	fprintf(stdout,"List of parameters for the JPEG 2000 encoder:\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout," Required arguments \n");
+	fprintf(stdout," ---------------------------- \n");
+	fprintf(stdout,"  -i <compressed file> ( *.jp3d, *.j3d )\n");
+	fprintf(stdout,"    Currently accepts J3D-files. The file type is identified based on its suffix.\n");
+	fprintf(stdout,"  -o <decompressed file> ( *.pgx, *.bin )\n");
+	fprintf(stdout,"    Currently accepts PGX-files and BIN-files. Binary data is written to the file (not ascii). \n");
+	fprintf(stdout,"    If a PGX filename is given, there will be as many output files as slices; \n");
+	fprintf(stdout,"    an indice starting from 0 will then be appended to the output filename,\n");
+	fprintf(stdout,"    just before the \"pgx\" extension.\n");
+	fprintf(stdout,"  -m <characteristics file> ( *.img ) \n");
+	fprintf(stdout,"    Required only for BIN-files. Ascii data of volume characteristics is written. \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout," Optional  \n");
+	fprintf(stdout," ---------------------------- \n");
+	fprintf(stdout,"  -h \n ");
+	fprintf(stdout,"    Display the help information\n");
+	fprintf(stdout,"  -r <RFx,RFy,RFz>\n");
+	fprintf(stdout,"    Set the number of highest resolution levels to be discarded on each dimension. \n");
+	fprintf(stdout,"    The volume resolution is effectively divided by 2 to the power of the\n");
+	fprintf(stdout,"    number of discarded levels. The reduce factor is limited by the\n");
+	fprintf(stdout,"    smallest total number of decomposition levels among tiles.\n");
+	fprintf(stdout,"  -l <number of quality layers to decode>\n");
+	fprintf(stdout,"    Set the maximum number of quality layers to decode. If there are\n");
+	fprintf(stdout,"    less quality layers than the specified number, all the quality layers\n");
+	fprintf(stdout,"    are decoded. \n");
+	fprintf(stdout,"  -O original-file \n");
+    fprintf(stdout,"    This option offers the possibility to compute some quality results  \n");
+	fprintf(stdout,"    for the decompressed volume, like the PSNR value achieved or the global SSIM value.  \n");
+	fprintf(stdout,"    Needs the original file in order to compare with the new one.\n");
+    fprintf(stdout,"    NOTE: Only valid when -r option is 0,0,0 (both original and decompressed volumes have same resolutions) \n");
+    fprintf(stdout,"    NOTE: If original file is .BIN file, the volume characteristics file shall be defined with the -m option. \n");
+	fprintf(stdout,"    (i.e. -O original-BIN-file -m original-IMG-file) \n");
+	fprintf(stdout,"  -BE \n");
+	fprintf(stdout,"    Define that the recovered volume data will be saved with big endian byte order.\n");
+	fprintf(stdout,"    By default, little endian byte order is used.\n");
+	fprintf(stdout,"\n");
+}
+
+/* -------------------------------------------------------------------------- */
+
+int get_file_format(char *filename) {
+	int i;
+	static const char *extension[] = {"pgx", "bin", "j3d", "jp3d", "j2k", "img"};
+	static const int format[] = { PGX_DFMT, BIN_DFMT, J3D_CFMT, J3D_CFMT, J2K_CFMT, IMG_DFMT};
+	char * ext = strrchr(filename, '.') + 1;
+	for(i = 0; i < sizeof(format); i++) {
+		if(strnicmp(ext, extension[i], 3) == 0) {
+			return format[i];
+		}
+	}
+
+	return -1;
+}
+
+/* -------------------------------------------------------------------------- */
+
+int parse_cmdline_decoder(int argc, char **argv, opj_dparameters_t *parameters) {
+	/* parse the command line */
+
+	while (1) {
+		int c = getopt(argc, argv, "i:o:O:r:l:B:m:h");
+		if (c == -1)			  
+			break;
+		switch (c) {
+			case 'i':			/* input file */
+			{
+				char *infile = optarg;
+				parameters->decod_format = get_file_format(infile);
+				switch(parameters->decod_format) {
+					case J3D_CFMT:
+					case J2K_CFMT:
+						break;
+					default:
+						fprintf(stdout, "[ERROR] Unknown format for infile %s [only *.j3d]!! \n", infile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->infile, infile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Infile: %s \n", parameters->infile);
+
+			}
+			break;
+
+			case 'm':			/* img file */
+			{
+				char *imgfile = optarg;
+				int imgformat = get_file_format(imgfile);
+				switch(imgformat) {
+					case IMG_DFMT:
+						break;
+					default:
+						fprintf(stdout,	"[ERROR] Unrecognized format for imgfile : %s [accept only *.img] !!\n\n", imgfile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->imgfile, imgfile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Imgfile: %s Format: %d\n", parameters->imgfile, imgformat);
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+
+			case 'o':			/* output file */
+			{
+				char *outfile = optarg;
+				parameters->cod_format = get_file_format(outfile);
+				switch(parameters->cod_format) {
+					case PGX_DFMT:
+					case BIN_DFMT:
+						break;
+					default:
+						fprintf(stdout,	"[ERROR] Unrecognized format for outfile : %s [accept only *.pgx or *.bin] !!\n\n", outfile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->outfile, outfile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Outfile: %s \n", parameters->outfile);
+
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+
+			case 'O':		/* Original image for PSNR computing */
+			{
+				char *original = optarg;
+				parameters->orig_format = get_file_format(original);
+				switch(parameters->orig_format) {
+					case PGX_DFMT:
+					case BIN_DFMT:
+						break;
+					default:
+						fprintf(stdout,	"[ERROR] Unrecognized format for original file : %s [accept only *.pgx or *.bin] !!\n\n", original);
+						return 1;
+						break;
+				}
+				strncpy(parameters->original, original, MAX_PATH);
+				fprintf(stdout,	"[INFO] Original file: %s \n", parameters->original);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+	    
+			case 'r':		/* reduce option */
+			{
+				//sscanf(optarg, "%d, %d, %d", &parameters->cp_reduce[0], &parameters->cp_reduce[1], &parameters->cp_reduce[2]);
+				int aux;
+				aux = sscanf(optarg, "%d,%d,%d", &parameters->cp_reduce[0], &parameters->cp_reduce[1], &parameters->cp_reduce[2]);
+				if (aux == 2) 
+					parameters->cp_reduce[2] = 0;
+				else if (aux == 1) {
+					parameters->cp_reduce[1] = parameters->cp_reduce[0];
+					parameters->cp_reduce[2] = 0;
+				}else if (aux == 0){
+					parameters->cp_reduce[0] = 0;
+					parameters->cp_reduce[1] = 0;
+					parameters->cp_reduce[2] = 0;
+				}
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+
+			case 'l':		/* layering option */
+			{
+				sscanf(optarg, "%d", &parameters->cp_layer);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+
+			case 'B':		/* BIGENDIAN vs. LITTLEENDIAN */
+			{
+				parameters->bigendian = 1;
+			}
+			break;
+			
+				/* ----------------------------------------------------- */
+
+			case 'L':		/* BIGENDIAN vs. LITTLEENDIAN */
+			{
+				parameters->decod_format = LSE_CFMT;
+			}
+			break;
+			
+			/* ----------------------------------------------------- */
+			
+			case 'h': 			/* display an help description */
+			{
+				decode_help_display();
+				return 1;
+			}
+			break;
+            
+				/* ----------------------------------------------------- */
+			
+			default:
+				fprintf(stdout,"[WARNING] This option is not valid \"-%c %s\"\n",c, optarg);
+				break;
+		}
+	}
+
+	/* check for possible errors */
+
+	if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
+		fprintf(stdout,"[ERROR] At least one required argument is missing\n Check jp3d_to_volume -help for usage information\n");
+		return 1;
+	}
+
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting no client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	fprintf(stdout, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+int main(int argc, char **argv) {
+
+	opj_dparameters_t parameters;	/* decompression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_volume_t *volume = NULL;
+
+	opj_volume_t *original = NULL;
+	opj_cparameters_t cparameters;	/* original parameters */
+
+	FILE *fsrc = NULL;
+	unsigned char *src = NULL; 
+	int file_length;
+	int decodeok;
+	double psnr, ssim;
+
+	opj_dinfo_t* dinfo = NULL;	/* handle to a decompressor */
+	opj_cio_t *cio = NULL;
+
+	/* configure the event callbacks (not required) */
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* set decoding parameters to default values */
+	opj_set_default_decoder_parameters(&parameters);
+
+    /* parse input and get user decoding parameters */
+	strcpy(parameters.original,"NULL");
+	strcpy(parameters.imgfile,"NULL");
+	if(parse_cmdline_decoder(argc, argv, &parameters) == 1) {
+		return 0;
+	}
+	
+	/* read the input file and put it in memory */
+	/* ---------------------------------------- */
+	fprintf(stdout, "[INFO] Loading %s file \n",parameters.decod_format==J3D_CFMT ? ".jp3d" : ".j2k");
+	fsrc = fopen(parameters.infile, "rb");
+	if (!fsrc) {
+		fprintf(stdout, "[ERROR] Failed to open %s for reading\n", parameters.infile);
+		return 1;
+	}  
+	fseek(fsrc, 0, SEEK_END);
+	file_length = ftell(fsrc);
+	fseek(fsrc, 0, SEEK_SET);
+	src = (unsigned char *) malloc(file_length);
+	fread(src, 1, file_length, fsrc);
+	fclose(fsrc);
+	
+	/* decode the code-stream */
+	/* ---------------------- */
+	if (parameters.decod_format == J3D_CFMT || parameters.decod_format == J2K_CFMT) {		
+		/* get a JP3D or J2K decoder handle */
+		if (parameters.decod_format == J3D_CFMT) 
+			dinfo = opj_create_decompress(CODEC_J3D);
+		else if (parameters.decod_format == J2K_CFMT) 
+			dinfo = opj_create_decompress(CODEC_J2K);
+
+		/* catch events using our callbacks and give a local context */
+		opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);			
+
+		/* setup the decoder decoding parameters using user parameters */
+		opj_setup_decoder(dinfo, &parameters);
+
+		/* open a byte stream */
+		cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+		/* decode the stream and fill the volume structure */
+		volume = opj_decode(dinfo, cio);
+		if(!volume) {
+			fprintf(stdout, "[ERROR] jp3d_to_volume: failed to decode volume!\n");				
+			opj_destroy_decompress(dinfo);
+			opj_cio_close(cio);
+			return 1;
+		}	
+
+		/* close the byte stream */
+		opj_cio_close(cio);
+	}
+  
+	/* free the memory containing the code-stream */
+	free(src);
+	src = NULL;
+
+	/* create output volume */
+	/* ------------------- */
+
+	switch (parameters.cod_format) {
+		case PGX_DFMT:			/* PGX */
+			decodeok = volumetopgx(volume, parameters.outfile);
+			if (decodeok)
+				fprintf(stdout,"[ERROR] Unable to write decoded volume into pgx files\n");
+			break;
+		
+		case BIN_DFMT:			/* BMP */
+			decodeok = volumetobin(volume, parameters.outfile);
+			if (decodeok)
+				fprintf(stdout,"[ERROR] Unable to write decoded volume into pgx files\n");
+			break;
+	}
+	switch (parameters.orig_format) {
+		case PGX_DFMT:			/* PGX */
+			if (strcmp("NULL",parameters.original) != 0){
+ 				fprintf(stdout,"Loading original file %s \n",parameters.original);
+				cparameters.subsampling_dx = 1;	cparameters.subsampling_dy = 1;	cparameters.subsampling_dz = 1;
+				cparameters.volume_offset_x0 = 0;cparameters.volume_offset_y0 = 0;cparameters.volume_offset_z0 = 0;
+				original = pgxtovolume(parameters.original,&cparameters);
+			}
+			break;
+		
+		case BIN_DFMT:			/* BMP */
+			if (strcmp("NULL",parameters.original) != 0 && strcmp("NULL",parameters.imgfile) != 0){
+				fprintf(stdout,"Loading original file %s %s\n",parameters.original,parameters.imgfile);
+				cparameters.subsampling_dx = 1;	cparameters.subsampling_dy = 1;	cparameters.subsampling_dz = 1;
+				cparameters.volume_offset_x0 = 0;cparameters.volume_offset_y0 = 0;cparameters.volume_offset_z0 = 0;
+				original = bintovolume(parameters.original,parameters.imgfile,&cparameters);
+			}
+			break;
+	}
+
+	fprintf(stdout, "[RESULT] Volume: %d x %d x %d (x %d bpv)\n ", 
+			 (volume->comps[0].w >> volume->comps[0].factor[0]),
+			 (volume->comps[0].h >> volume->comps[0].factor[1]),
+			 (volume->comps[0].l >> volume->comps[0].factor[2]),volume->comps[0].prec);
+
+	if(original){
+		psnr = calc_PSNR(original,volume);
+		ssim = calc_SSIM(original,volume);
+		if (psnr < 0.0)
+			fprintf(stdout, "  PSNR: Inf , SSMI %f -- Perfect reconstruction!\n",ssim);
+		else
+			fprintf(stdout, "  PSNR: %f , SSIM %f \n",psnr,ssim);
+	}
+	/* free remaining structures */
+	if(dinfo) {
+		opj_destroy_decompress(dinfo);
+	}
+
+	/* free volume data structure */
+	opj_volume_destroy(volume);
+   
+	return 0;
+}
+
Binary files /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.ncb.svn-base and ./jp3d/codec/.svn/text-base/jp3d_vm_dec.ncb.svn-base differ
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.sln.svn-base ./jp3d/codec/.svn/text-base/jp3d_vm_dec.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/jp3d_vm_dec.sln.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,30 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "jp3d_vm_dec", "jp3d_vm_dec.vcproj", "{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}"
+	ProjectSection(ProjectDependencies) = postProject
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibJp3dVM", "..\LibJp3dVM.vcproj", "{6F3FB035-8F4E-4794-B091-0F0A20223BE7}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}.Debug.ActiveCfg = Debug|Win32
+		{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}.Debug.Build.0 = Debug|Win32
+		{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}.Release.ActiveCfg = Release|Win32
+		{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}.Release.Build.0 = Release|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.ActiveCfg = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.Build.0 = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.ActiveCfg = Release|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
Binary files /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.suo.svn-base and ./jp3d/codec/.svn/text-base/jp3d_vm_dec.suo.svn-base differ
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.vcproj.svn-base ./jp3d/codec/.svn/text-base/jp3d_vm_dec.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_dec.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/jp3d_vm_dec.vcproj.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="jp3d_vm_dec"
+	ProjectGUID="{E0C1B905-5B10-4C9A-AF55-2D8144D518AB}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libjp3dvm"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				UsePrecompiledHeader="2"
+				PrecompiledHeaderFile=".\Debug/jp3d_vm_dec.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Debug/jp3d_vm_dec.exe"
+				LinkIncremental="0"
+				SuppressStartupBanner="TRUE"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/jp3d_vm_dec.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/j2k_to_image.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy Debug\jp3d_vm_dec.exe ..\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libjp3dvm"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/jp3d_vm_dec.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/jp3d_vm_dec.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				ProgramDatabaseFile=".\Release/jp3d_vm_dec.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/j2k_to_image.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy Release\jp3d_vm_dec.exe ..\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\convert.c">
+		</File>
+		<File
+			RelativePath=".\convert.h">
+		</File>
+		<File
+			RelativePath=".\getopt.c">
+		</File>
+		<File
+			RelativePath=".\getopt.h">
+		</File>
+		<File
+			RelativePath=".\jp3d_to_volume.c">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
Binary files /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.ncb.svn-base and ./jp3d/codec/.svn/text-base/jp3d_vm_enc.ncb.svn-base differ
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.sln.svn-base ./jp3d/codec/.svn/text-base/jp3d_vm_enc.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/jp3d_vm_enc.sln.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,35 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "jp3d_vm_enc", "jp3d_vm_enc.vcproj", "{A9704A2E-3B93-4BAA-9229-02FC93D27201}"
+	ProjectSection(ProjectDependencies) = postProject
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibJp3dVM", "..\LibJp3dVM.vcproj", "{6F3FB035-8F4E-4794-B091-0F0A20223BE7}"
+	ProjectSection(ProjectDependencies) = postProject
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7} = {6F3FB035-8F4E-4794-B091-0F0A20223BE7}
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{A9704A2E-3B93-4BAA-9229-02FC93D27201}.Debug.ActiveCfg = Debug|Win32
+		{A9704A2E-3B93-4BAA-9229-02FC93D27201}.Debug.Build.0 = Debug|Win32
+		{A9704A2E-3B93-4BAA-9229-02FC93D27201}.Release.ActiveCfg = Release|Win32
+		{A9704A2E-3B93-4BAA-9229-02FC93D27201}.Release.Build.0 = Release|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.ActiveCfg = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.Build.0 = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.ActiveCfg = Release|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
Binary files /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.suo.svn-base and ./jp3d/codec/.svn/text-base/jp3d_vm_enc.suo.svn-base differ
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.vcproj.svn-base ./jp3d/codec/.svn/text-base/jp3d_vm_enc.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/jp3d_vm_enc.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/jp3d_vm_enc.vcproj.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,157 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="jp3d_vm_enc"
+	ProjectGUID="{A9704A2E-3B93-4BAA-9229-02FC93D27201}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libjp3dvm"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/jp3d_vm_enc.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/jp3d_vm_enc.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				ProgramDatabaseFile=".\Release/jp3d_vm_enc.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/image_to_j2k.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy Release\jp3d_vm_enc.exe ..\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="1"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libjp3dvm"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/jp3d_vm_enc.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"
+				CompileAs="0"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Debug/jp3d_vm_enc.exe"
+				LinkIncremental="0"
+				SuppressStartupBanner="TRUE"
+				AdditionalLibraryDirectories=""
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/jp3d_vm_enc.pdb"
+				SubSystem="1"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Debug/image_to_j2k.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="copy Debug\jp3d_vm_enc.exe ..\bin"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<File
+			RelativePath=".\convert.c">
+		</File>
+		<File
+			RelativePath=".\convert.h">
+		</File>
+		<File
+			RelativePath=".\getopt.c">
+		</File>
+		<File
+			RelativePath=".\getopt.h">
+		</File>
+		<File
+			RelativePath=".\volume_to_jp3d.c">
+		</File>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/volume_to_jp3d.c.svn-base ./jp3d/codec/.svn/text-base/volume_to_jp3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/codec/.svn/text-base/volume_to_jp3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/codec/.svn/text-base/volume_to_jp3d.c.svn-base	2007-09-28 11:33:48.000000000 +0100
@@ -0,0 +1,903 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include <stdio.h>
+#include <string.h>
+#include <stdlib.h>
+
+#include "openjpeg.h"
+#include "getopt.h"
+#include "convert.h"
+
+#ifndef WIN32
+#define stricmp strcasecmp
+#define strnicmp strncasecmp
+#endif
+
+/* ----------------------------------------------------------------------- */
+
+void encode_help_display() {
+	fprintf(stdout,"List of parameters for the JPEG2000 Part 10 encoder:\n");
+	fprintf(stdout,"------------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Required Parameters (except with -h):\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-i           : source file  (-i source.bin or source*.pgx) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-m           : source characteristics file (-m imgfile.img) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-o           : destination file (-o dest.jp3d) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"Optional Parameters:\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-h           : display the help information \n ");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-n           : number of resolutions (-n 3,3,3) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-I           : use the irreversible transforms: ICT + DWT 9-7 (-I) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-C           : coding algorithm (-C 2EB) [2EB, 3EB] \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-r           : different compression ratios for successive layers (-r 20,10,5)\n ");
+	fprintf(stdout,"	         - The rate specified for each quality level is the desired compression factor.\n");
+	fprintf(stdout,"	         - Rate 1 means lossless compression\n");
+	fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-q           : different psnr for successive layers (-q 30,40,50) \n ");
+	fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-b           : size of code block (-b 32,32,32) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-c           : size of precinct (-c 128,128,128) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-t           : size of tile (-t 512,512,512) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-p           : progression order (-p LRCP) [LRCP, RLCP, RPCL, PCRL, CPRL] \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-s           : subsampling factor (-s 2,2,2) [-s X,Y,Z] \n");
+	fprintf(stdout,"			  - Remark: subsampling bigger than 2 can produce error\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-SOP         : write SOP marker before each packet \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-EPH         : write EPH marker after each header packet \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-M           : code-block style (-M 0) [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
+	fprintf(stdout,"                 8=VSC 16=PTERM 32=SEGSYM 64=3DCTXT] \n");
+	fprintf(stdout,"                 Indicate multiple modes by adding their values. \n");
+	fprintf(stdout,"                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-D           : define DC offset (-D 12) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-x           : create an index file *.Idx (-x index_name.Idx) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
+	fprintf(stdout,"               for component c=%%d [%%d = 0,1,2]\n");
+	fprintf(stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-d           : offset of the origin of the volume (-d 150,300,100) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"-l           : offset of the origin of the tiles (-l 100,75,25) \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"DEFAULT CODING:\n");
+	fprintf(stdout,"------------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout," * Lossless\n");
+	fprintf(stdout," * 1 tile\n");
+	fprintf(stdout," * Size of precinct : 2^15 x 2^15 x 2^15 (means 1 precinct)\n");
+	fprintf(stdout," * Size of code-block : 64 x 64 x 64\n");
+	fprintf(stdout," * Number of resolutions in x, y and z axis: 3\n");
+	fprintf(stdout," * No SOP marker in the codestream\n");
+	fprintf(stdout," * No EPH marker in the codestream\n");
+	fprintf(stdout," * No sub-sampling in x, y or z direction\n");
+	fprintf(stdout," * No mode switch activated\n");
+	fprintf(stdout," * Progression order: LRCP\n");
+	fprintf(stdout," * No index file\n");
+	fprintf(stdout," * No ROI upshifted\n");
+	fprintf(stdout," * No offset of the origin of the volume\n");
+	fprintf(stdout," * No offset of the origin of the tiles\n");
+	fprintf(stdout," * Reversible DWT 5-3 on each 2D slice\n");
+	fprintf(stdout," * Coding algorithm: 2D-EBCOT \n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"REMARKS:\n");
+	fprintf(stdout,"---------\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"- The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
+	fprintf(stdout,"- COD and QCD markers will never appear in the tile_header.\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"- You need enough disk space memory (twice the original) to encode \n");
+	fprintf(stdout,"the volume,i.e. for a 1.5 GB volume you need a minimum of 3GB of disk memory)\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"- When loading *.pgx files, a relative path to directory is needed for input argument \n");
+	fprintf(stdout," followed by the common prefix of the slices and a '*' character representing sequential numeration.\n");
+	fprintf(stdout,"( -i relativepath/slices*.pgx )\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout," - The index file has the structure below:\n");
+	fprintf(stdout,"\n");
+	fprintf(stdout,"\t	Image_height Image_width Image_depth\n");
+	fprintf(stdout,"\t	Progression order: 0 (LRCP)\n");
+	fprintf(stdout,"\t	Tiles_size_X Tiles_size_Y Tiles_size_Z\n");
+	fprintf(stdout,"\t	Components_nb\n");
+	fprintf(stdout,"\t	Layers_nb\n");
+	fprintf(stdout,"\t	Decomposition_levels\n");
+	fprintf(stdout,"\t	[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr Precincts_size_Z_res_Nr]\n\t  ...\n");
+	fprintf(stdout,"\t	[Precincts_size_X_res_0 Precincts_size_Y_res_0 Precincts_size_Z_res_0]\n");
+	fprintf(stdout,"\t	Main_header_end_position\n");
+	fprintf(stdout,"\t	Codestream_size\n");
+	fprintf(stdout,"\t	Tile_0 [start_pos end_header end_pos TotalDisto NumPix MaxMSE]\n");
+	fprintf(stdout,"\t	...\n");
+	fprintf(stdout,"\t	Tile_Nt [  ''         ''        ''        ''       ''    ''  ]\n");
+	fprintf(stdout,"\t  Tpacket_0 [Tile layer res. comp. prec. start_pos end_pos disto]\n");
+	fprintf(stdout,"\t  ...\n");
+	fprintf(stdout,"\t  Tpacket_Np [''   ''    ''   ''    ''       ''       ''     '' ]\n");
+	fprintf(stdout,"\t  MaxDisto\n");
+	fprintf(stdout,"\t  TotalDisto\n\n");
+	fprintf(stdout,"\n");
+
+}
+
+OPJ_PROG_ORDER give_progression(char progression[4]) {
+	if(strncmp(progression, "LRCP", 4) == 0) {
+		return LRCP;
+	}
+	if(strncmp(progression, "RLCP", 4) == 0) {
+		return RLCP;
+	}
+	if(strncmp(progression, "RPCL", 4) == 0) {
+		return RPCL;
+	}
+	if(strncmp(progression, "PCRL", 4) == 0) {
+		return PCRL;
+	}
+	if(strncmp(progression, "CPRL", 4) == 0) {
+		return CPRL;
+	}
+
+	return PROG_UNKNOWN;
+}
+
+OPJ_TRANSFORM give_transform(char transform[4]) {
+	if(strncmp(transform, "2DWT", 4) == 0) {
+		return TRF_2D_DWT;
+	}
+	if(strncmp(transform, "3DWT", 4) == 0) {
+		return TRF_3D_DWT;
+	}
+	return TRF_UNKNOWN;
+}
+
+OPJ_ENTROPY_CODING give_coding(char coding[3]) {
+
+	if(strncmp(coding, "2EB", 3) == 0) {
+		return ENCOD_2EB;
+	}
+	if(strncmp(coding, "3EB", 3) == 0) {
+		return ENCOD_3EB;
+	}
+	/*if(strncmp(coding, "2GR", 3) == 0) {
+		return ENCOD_2GR;
+	}
+	if(strncmp(coding, "3GR", 3) == 0) {
+		return ENCOD_3GR;
+	}*/
+
+	return ENCOD_UNKNOWN;
+}
+
+int get_file_format(char *filename) {
+	int i;
+	static const char *extension[] = {"pgx", "bin", "img", "j3d", "jp3d", "j2k"};
+	static const int format[] = { PGX_DFMT, BIN_DFMT, IMG_DFMT, J3D_CFMT, J3D_CFMT, J2K_CFMT};
+	char * ext = strrchr(filename, '.') + 1;
+	if (ext) {
+        for(i = 0; i < sizeof(format)/sizeof(*format); i++) {
+			if(strnicmp(ext, extension[i], 3) == 0) {
+                return format[i];
+			}
+		}
+	}
+
+	return -1;
+}
+
+/* ------------------------------------------------------------------------------------ */
+
+int parse_cmdline_encoder(int argc, char **argv, opj_cparameters_t *parameters) {
+	int i, value;
+
+	/* parse the command line */
+
+	while (1) {
+		int c = getopt(argc, argv, "i:m:o:r:q:f:t:n:c:b:x:p:s:d:hP:S:E:M:D:R:l:T:C:A:I");
+		if (c == -1)
+			break;
+		switch (c) {
+			case 'i':			/* input file */
+			{
+				char *infile = optarg;
+				parameters->decod_format = get_file_format(infile);
+				switch(parameters->decod_format) {
+					case PGX_DFMT:
+					case BIN_DFMT:
+					case IMG_DFMT:
+						break;
+					default:
+						fprintf(stdout,	"[ERROR] Unrecognized format for infile : %s [accept only *.pgx or *.bin] !!\n\n", infile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->infile, infile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Infile: %s \n", parameters->infile);
+
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			case 'm':			/* input IMG file */
+			{
+				char *imgfile = optarg;
+				int imgformat = get_file_format(imgfile);
+				switch(imgformat) {
+					case IMG_DFMT:
+						break;
+					default:
+						fprintf(stdout,	"[ERROR] Unrecognized format for imgfile : %s [accept only *.img] !!\n\n", imgfile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->imgfile, imgfile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Imgfile: %s Format: %d\n", parameters->imgfile, imgformat);
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			case 'o':			/* output file */
+			{
+				char *outfile = optarg;
+				parameters->cod_format = get_file_format(outfile);
+				switch(parameters->cod_format) {
+					case J3D_CFMT:
+					case J2K_CFMT:
+					case LSE_CFMT:
+						break;
+					default:
+						fprintf(stdout, "[ERROR] Unknown output format volume %s [only *.j2k, *.lse3d or *.jp3d]!! \n", outfile);
+						return 1;
+						break;
+				}
+				strncpy(parameters->outfile, outfile, MAX_PATH);
+				fprintf(stdout,	"[INFO] Outfile: %s \n", parameters->outfile);
+			}
+			break;
+
+				/* ----------------------------------------------------- */
+			
+			case 'r':			/* define compression rates for each layer */
+			{
+				char *s = optarg;
+				while (sscanf(s, "%f", &parameters->tcp_rates[parameters->tcp_numlayers]) == 1) {
+					parameters->tcp_numlayers++;
+					while (*s && *s != ',') {
+						s++;
+					}
+					if (!*s)
+						break;
+					s++;
+				}
+				parameters->cp_disto_alloc = 1;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'q':			/* define distorsion (PSNR) for each layer */
+			{
+				char *s = optarg;
+				while (sscanf(s, "%f", &parameters->tcp_distoratio[parameters->tcp_numlayers]) == 1) {
+					parameters->tcp_numlayers++;
+					while (*s && *s != ',') {
+						s++;
+					}
+					if (!*s)
+						break;
+					s++;
+				}
+				parameters->cp_fixed_quality = 1;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+
+			case 'f':	
+			{
+				fprintf(stdout, "/---------------------------------------------------\\\n");
+				fprintf(stdout, "|  Fixed layer allocation option not implemented !!  |\n");
+				fprintf(stdout, "\\---------------------------------------------------/\n");
+				/*int *row = NULL, *col = NULL;
+				int numlayers = 0, matrix_width = 0;
+
+				char *s = optarg;
+				sscanf(s, "%d", &numlayers);
+				s++;
+				if (numlayers > 9)
+					s++;
+
+				parameters->tcp_numlayers = numlayers;
+				matrix_width = parameters->numresolution[0] + parameters->numresolution[1] + parameters->numresolution[2];
+				parameters->cp_matrice = (int *) malloc(numlayers * matrix_width * sizeof(int));
+				s = s + 2;
+
+				for (i = 0; i < numlayers; i++) {
+					row = &parameters->cp_matrice[i * matrix_width];
+					col = row;
+					parameters->tcp_rates[i] = 1;
+					sscanf(s, "%d,", &col[0]);
+					s += 2;
+					if (col[0] > 9)
+						s++;
+					col[1] = 0;
+					col[2] = 0;
+					for (j = 1; j < matrix_width; j++) {
+						col += 3; j+=2;
+						sscanf(s, "%d,%d,%d", &col[0], &col[1], &col[2]);
+						s += 6;
+						if (col[0] > 9)
+							s++;
+						if (col[1] > 9)
+							s++;
+						if (col[2] > 9)
+							s++;
+					}
+					if (i < numlayers - 1)
+						s++;
+				}
+				parameters->cp_fixed_alloc = 1; */
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+
+			case 't':			/* tiles */
+			{
+				if (sscanf(optarg, "%d,%d,%d", &parameters->cp_tdx, &parameters->cp_tdy, &parameters->cp_tdz) !=3) {
+					fprintf(stdout,	"[ERROR] '-t' 'dimensions of tiles' argument error !  [-t tdx,tdy,tdz]\n");
+					return 1;
+				}
+				parameters->tile_size_on = true;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'n':			/* resolution */
+			{
+				int aux;
+				aux = sscanf(optarg, "%d,%d,%d", &parameters->numresolution[0], &parameters->numresolution[1], &parameters->numresolution[2]);
+				if (aux == 2) 
+					parameters->numresolution[2] = 1;
+				else if (aux == 1) {
+					parameters->numresolution[1] = parameters->numresolution[0];
+					parameters->numresolution[2] = 1;
+				}else if (aux == 0){
+					parameters->numresolution[0] = 1;
+					parameters->numresolution[1] = 1;
+					parameters->numresolution[2] = 1;
+				}
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			case 'c':			/* precinct dimension */
+			{
+				char sep;
+				int res_spec = 0;
+				int aux;
+				char *s = optarg;
+				do {
+					sep = 0;
+					aux = sscanf(s, "[%d,%d,%d]%c", &parameters->prct_init[0][res_spec], &parameters->prct_init[1][res_spec], &parameters->prct_init[2][res_spec], &sep);
+					if (sep == ',' && aux != 4) {
+						fprintf(stdout,	"[ERROR] '-c' 'dimensions of precincts' argument error !  [-c [prcx_res0,prcy_res0,prcz_res0],...,[prcx_resN,prcy_resN,prcz_resN]]\n");
+						return 1;
+					}
+					parameters->csty |= 0x01;
+					res_spec++;
+					s = strpbrk(s, "]") + 2;
+				}
+				while (sep == ',');
+				parameters->res_spec = res_spec; /* number of precinct size specifications */
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'b':			/* code-block dimension */
+			{
+				int cblockw_init = 0, cblockh_init = 0, cblockl_init = 0;
+				if (sscanf(optarg, "%d,%d,%d", &cblockw_init, &cblockh_init, &cblockl_init) != 3) {
+					fprintf(stdout,	"[ERROR] '-b' 'dimensions of codeblocks' argument error !  [-b cblkx,cblky,cblkz]\n");
+					return 1;
+				}
+				if (cblockw_init * cblockh_init * cblockl_init > (1<<18) || cblockw_init > 1024 || cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4 || cblockl_init > 1024 || cblockl_init < 4) {
+					fprintf(stdout,"[ERROR] Size of code_block error (option -b) !!\n\nRestriction :\n * width*height*length<=4096\n * 4<=width,height,length<= 1024\n\n");
+					return 1;
+				}
+				parameters->cblock_init[0] = cblockw_init;
+				parameters->cblock_init[1] = cblockh_init;
+				parameters->cblock_init[2] = cblockl_init;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'x':			/* creation of index file */
+			{
+				char *index = optarg;
+				strncpy(parameters->index, index, MAX_PATH);
+				parameters->index_on = 1;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'p':			/* progression order */
+			{
+				char progression[4];
+
+				strncpy(progression, optarg, 4);
+				parameters->prog_order = give_progression(progression);
+				if (parameters->prog_order == -1) {
+					fprintf(stdout, "[ERROR] Unrecognized progression order [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
+					return 1;
+				}
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 's':			/* subsampling factor */
+			{
+				if (sscanf(optarg, "%d,%d,%d", &parameters->subsampling_dx, &parameters->subsampling_dy, &parameters->subsampling_dz) != 2) {
+					fprintf(stdout,	"[ERROR] '-s' sub-sampling argument error !  [-s dx,dy,dz]\n");
+					return 1;
+				}
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'd':			/* coordonnate of the reference grid */
+			{
+				if (sscanf(optarg, "%d,%d,%d", &parameters->volume_offset_x0, &parameters->volume_offset_y0, &parameters->volume_offset_z0) != 3) {
+					fprintf(stdout,	"[ERROR] -d 'coordonnate of the reference grid' argument error !! [-d x0,y0,z0]\n");
+					return 1;
+				}
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+			
+			case 'h':			/* display an help description */
+			{
+				encode_help_display();
+				return 1;
+			}
+			break;
+				
+				/* ----------------------------------------------------- */
+
+			case 'P':			/* POC */
+			{
+				int numpocs = 0;		/* number of progression order change (POC) default 0 */
+				opj_poc_t *POC = NULL;	/* POC : used in case of Progression order change */
+
+				char *s = optarg;
+				POC = parameters->POC;
+
+				fprintf(stdout, "/----------------------------------\\\n");
+				fprintf(stdout, "|  POC option not fully tested !!  |\n");
+				fprintf(stdout, "\\----------------------------------/\n");
+				
+				while (sscanf(s, "T%d=%d,%d,%d,%d,%d,%s", &POC[numpocs].tile,
+														&POC[numpocs].resno0, &POC[numpocs].compno0,
+														&POC[numpocs].layno1, &POC[numpocs].resno1,
+														&POC[numpocs].compno1, POC[numpocs].progorder) == 7) {
+					POC[numpocs].prg = give_progression(POC[numpocs].progorder);
+					/* POC[numpocs].tile; */
+					numpocs++;
+					while (*s && *s != '/') {
+						s++;
+					}
+					if (!*s) {
+						break;
+					}
+					s++;
+				}
+				parameters->numpocs = numpocs;
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+				
+			case 'S':			/* SOP marker */
+			{
+				parameters->csty |= 0x02;
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'E':			/* EPH marker */
+			{
+				parameters->csty |= 0x04;
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'M':			/* Codification mode switch */
+			{
+				fprintf(stdout, "[INFO] Mode switch option not fully tested !!\n");
+				value = 0;
+				if (sscanf(optarg, "%d", &value) == 1) {
+					for (i = 0; i <= 6; i++) {
+						int cache = value & (1 << i);
+						if (cache)
+							parameters->mode |= (1 << i);
+					}
+				}
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'D':			/* DCO */
+			{
+				if (sscanf(optarg, "%d", &parameters->dcoffset) != 1) {
+					fprintf(stdout, "[ERROR] DC offset error !! [-D %d]\n",parameters->dcoffset);
+					return 1;
+				}
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'R':			/* ROI */
+			{
+				if (sscanf(optarg, "OI:c=%d,U=%d", &parameters->roi_compno, &parameters->roi_shift) != 2) {
+					fprintf(stdout, "[ERROR] ROI error !! [-ROI:c='compno',U='shift']\n");
+					return 1;
+				}
+			}
+			break;
+				
+				/* ------------------------------------------------------ */
+			
+			case 'l':			/* Tile offset */
+			{
+				if (sscanf(optarg, "%d,%d,%d", &parameters->cp_tx0, &parameters->cp_ty0, &parameters->cp_tz0) != 3) {
+					fprintf(stdout, "[ERROR] -l 'tile offset' argument error !! [-l X0,Y0,Z0]");
+					return 1;
+				}
+			}
+			break;
+				
+				/* ------------------------------------------------------ 
+				
+			case 'T':			// Tranformation of original data (2D-DWT/3D-DWT/3D-RLS/2D-DWT+1D-RLS) 
+			{
+				char transform[4];
+
+				strncpy(transform, optarg, 4);
+				parameters->transform_format = give_transform(transform);
+				if (parameters->transform_format == -1) {
+					fprintf(stdout, "[ERROR] -T 'Transform domain' argument error !! [-T 2DWT, 3DWT, 3RLS or 3LSE only]");
+                    return 1;
+				}
+			}
+			break;
+				
+				 ------------------------------------------------------ */
+			
+			case 'C':			/* Coding of transformed data */
+			{
+				char coding[3];
+
+				strncpy(coding, optarg, 3);
+				parameters->encoding_format = give_coding(coding);
+				if (parameters->encoding_format == -1) {
+					fprintf(stdout, "[ERROR] -C 'Coding algorithm' argument error !! [-C 2EB, 3EB, 2GR, 3GR or GRI only]");
+                    return 1;
+				}
+			}
+			break;
+			
+			/* ------------------------------------------------------ */
+			
+			case 'I':			/* reversible or not */
+			{
+				parameters->irreversible = 1;
+			}
+			break;
+				
+			default:
+				fprintf(stdout, "[ERROR] This option is not valid \"-%c %s\"\n", c, optarg);
+				return 1;
+		}
+	}
+
+	/* check for possible errors */
+
+	if((parameters->infile[0] == 0) || (parameters->outfile[0] == 0)) {
+		fprintf(stdout, "usage: jp3d_vm_enc -i volume-file -o jp3d-file (+ options)\n");
+		return 1;
+	}
+
+	if((parameters->decod_format == BIN_DFMT) && (parameters->imgfile[0] == 0)) {
+		fprintf(stdout, "usage: jp3d_vm_enc -i bin-volume-file -m img-file -o jp3d-file (+ options)\n");
+		return 1;
+	}
+
+	if((parameters->decod_format != BIN_DFMT) && (parameters->decod_format != PGX_DFMT) && (parameters->decod_format != IMG_DFMT)) {
+		fprintf(stdout, "usage: jp3d_vm_enc -i input-volume-file [*.bin,*.pgx,*.img] -o jp3d-file [*.jp3d,*.j2k] (+ options)\n");
+		return 1;
+	}
+	if((parameters->cod_format != J3D_CFMT) && (parameters->cod_format != J2K_CFMT)) {
+		fprintf(stdout, "usage: jp3d_vm_enc -i input-volume-file [*.bin,*.pgx,*.img] -o jp3d-file [*.jp3d,*.j2k] (+ options)\n");
+		return 1;
+	}
+
+	if((parameters->encoding_format == ENCOD_2GR || parameters->encoding_format == ENCOD_3GR) && parameters->transform_format != TRF_3D_LSE && parameters->transform_format != TRF_3D_RLS) {
+		fprintf(stdout, "[ERROR] Entropy coding options -C [2GR,3GR] are only compatible with predictive-based transform algorithms: -T [3RLS,3LSE].\n");
+		return 1;
+	}
+	if (parameters->encoding_format == ENCOD_3EB)
+		parameters->mode |= (1 << 6);
+
+	if ((parameters->mode >> 6) & 1) {
+		parameters->encoding_format = ENCOD_3EB;
+	}
+
+	if((parameters->numresolution[2] == 0 || (parameters->numresolution[1] == 0) || (parameters->numresolution[0] == 0))) {
+		fprintf(stdout, "[ERROR] -n 'resolution levels' argument error ! Resolutions must be greater than 1 in order to perform DWT.\n");
+		return 1;
+	}
+	if (parameters->numresolution[1] != parameters->numresolution[0]) {
+		fprintf(stdout, "[ERROR] -n 'resolution levels' argument error ! Resolutions in X and Y axis must be the same in this implementation.\n");
+		return 1;
+	}
+	
+	if (parameters->numresolution[2] > parameters->numresolution[0]) {
+		fprintf(stdout, "[ERROR] -n 'resolution levels' argument error ! Resolutions in Z axis must be lower than in X-Y axis.\n");
+		return 1;
+	}
+	
+	if (parameters->dcoffset >= 128 && parameters->dcoffset <= -128) {
+		fprintf(stdout, "[ERROR] -D 'DC offset' argument error ! Value must be -128<=DCO<=128.\n");
+		return 1;
+	}
+
+	if(parameters->numresolution[2] != 1) {
+		parameters->transform_format = TRF_3D_DWT;
+		//fprintf(stdout, "[Warning] Resolution level in axial dim > 1 : 3D-DWT will be performed... \n");
+	} else if (parameters->numresolution[2] == 1) {
+		parameters->transform_format = TRF_2D_DWT;
+		//fprintf(stdout, "[Warning] Resolution level in axial dim == 1 : 2D-DWT will be performed... \n");
+	}
+	
+	if ((parameters->cod_format == J2K_CFMT) && (parameters->transform_format != TRF_2D_DWT || parameters->encoding_format != ENCOD_2EB)) {
+		fprintf(stdout, "[WARNING] Incompatible options -o *.j2k and defined transform or encoding algorithm. Latter will be ignored\n");
+		parameters->transform_format = TRF_2D_DWT;
+		parameters->encoding_format = ENCOD_2EB;
+	}
+
+	if ((parameters->cp_disto_alloc || parameters->cp_fixed_alloc || parameters->cp_fixed_quality) && (!(parameters->cp_disto_alloc ^ parameters->cp_fixed_quality))) {
+		fprintf(stdout, "[ERROR] Options -r and -q cannot be used together !!\n");
+		return 1;
+	}				/* mod fixed_quality */
+
+	/* if no rate entered, lossless by default */
+	if (parameters->tcp_numlayers == 0) {
+		parameters->tcp_rates[0] = 0.0;	/* MOD antonin : losslessbug */
+		parameters->tcp_numlayers++;
+		parameters->cp_disto_alloc = 1;
+	}
+
+	if((parameters->cp_tx0 > parameters->volume_offset_x0) || (parameters->cp_ty0 > parameters->volume_offset_y0) || (parameters->cp_tz0 > parameters->volume_offset_z0)) {
+		fprintf(stdout,	"[ERROR] Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) TZO(%d)<=IMG_Z0(%d)\n",
+			parameters->cp_tx0, parameters->volume_offset_x0, parameters->cp_ty0, parameters->volume_offset_y0, 
+			parameters->cp_tz0, parameters->volume_offset_z0);
+		return 1;
+	}
+
+	for (i = 0; i < parameters->numpocs; i++) {
+		if (parameters->POC[i].prg == -1) {
+			fprintf(stdout,"[ERROR] Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",i + 1);
+		}
+	}
+	return 0;
+}
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+int main(int argc, char **argv) {
+	bool bSuccess;
+	bool delete_comment = true;
+	opj_cparameters_t parameters;	/* compression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_volume_t *volume = NULL;
+
+	/* 
+	configure the event callbacks (not required)
+	setting of each callback is optionnal 
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* set encoding parameters to default values */
+	opj_set_default_encoder_parameters(&parameters);
+
+	/* parse input and get user encoding parameters */
+	if(parse_cmdline_encoder(argc, argv, &parameters) == 1) {
+		return 0;
+	}
+
+	if(parameters.cp_comment == NULL) {
+		parameters.cp_comment = "Created by OpenJPEG version JP3D";
+		/* no need to delete parameters.cp_comment on exit */
+		delete_comment = false;
+	}
+	
+	/* encode the destination volume */
+	/* ---------------------------- */
+	if (parameters.cod_format == J3D_CFMT || parameters.cod_format == J2K_CFMT)	{
+		int codestream_length, pixels, bitsin;
+		opj_cio_t *cio = NULL;
+		FILE *f = NULL;
+		opj_cinfo_t* cinfo = NULL;
+		
+		/* decode the source volume */
+		/* ----------------------- */
+		switch (parameters.decod_format) {
+			case PGX_DFMT: 
+				fprintf(stdout, "[INFO] Loading pgx file(s)\n");
+				volume = pgxtovolume(parameters.infile, &parameters);
+				if (!volume) {
+					fprintf(stdout, "[ERROR] Unable to load pgx files\n");
+					return 1;
+				}
+				break;
+			
+			case BIN_DFMT:
+				fprintf(stdout, "[INFO] Loading bin file\n");
+				volume = bintovolume(parameters.infile, parameters.imgfile, &parameters);
+				if (!volume) {
+					fprintf(stdout, "[ERROR] Unable to load bin file\n");
+					return 1;
+				}
+				break;
+
+			case IMG_DFMT:
+				fprintf(stdout, "[INFO] Loading img file\n");
+				volume = imgtovolume(parameters.infile, &parameters);
+				if (!volume) {
+					fprintf(stderr, "[ERROR] Unable to load img file\n");
+					return 1;
+				}
+				break;
+		}
+		
+		/* get a JP3D or J2K compressor handle */
+		if (parameters.cod_format == J3D_CFMT) 
+            cinfo = opj_create_compress(CODEC_J3D);
+		else if (parameters.cod_format == J2K_CFMT) 
+            cinfo = opj_create_compress(CODEC_J2K);
+
+		/* catch events using our callbacks and give a local context */
+		opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stdout);			
+
+		/* setup the encoder parameters using the current volume and using user parameters */
+		opj_setup_encoder(cinfo, &parameters, volume);
+		
+		/* open a byte stream for writing */
+		/* allocate memory for all tiles */
+		cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+		/* encode the volume */
+		//fprintf(stdout, "[INFO] Encode the volume\n");
+		bSuccess = opj_encode(cinfo, cio, volume, parameters.index);
+		if (!bSuccess) {
+			opj_cio_close(cio);
+			fprintf(stdout, "[ERROR] Failed to encode volume\n");
+			return 1;
+		}
+		codestream_length = cio_tell(cio);
+		pixels =(volume->x1 - volume->x0) * (volume->y1 - volume->y0) * (volume->z1 - volume->z0);
+		bitsin = pixels * volume->comps[0].prec;
+		fprintf(stdout, "[RESULT] Volume: %d x %d x %d (x %d bpv)\n Codestream: %d B,  Ratio: %5.3f bpv,  (%5.3f : 1) \n", 
+			(volume->x1 - volume->x0),(volume->y1 - volume->y0),(volume->z1 - volume->z0),volume->comps[0].prec,
+			codestream_length, ((double)codestream_length * 8.0/(double)pixels), ((double)bitsin/(8.0*(double)codestream_length)));
+
+		/* write the buffer to disk */
+		f = fopen(parameters.outfile, "wb");
+		if (!f) {
+			fprintf(stdout, "[ERROR] Failed to open %s for writing\n", parameters.outfile);
+			return 1;
+		}
+		fwrite(cio->buffer, 1, codestream_length, f);
+		fclose(f);
+
+		/* close and free the byte stream */
+		opj_cio_close(cio);
+
+		/* free remaining compression structures */
+		opj_destroy_compress(cinfo);
+	} else {
+		fprintf(stdout, "[ERROR] Cod_format != JP3d !!! \n");
+		return 1;
+	}
+
+	/* free user parameters structure */
+	if(delete_comment) {
+		if(parameters.cp_comment) free(parameters.cp_comment);
+	}
+	if(parameters.cp_matrice) free(parameters.cp_matrice);
+
+	/* free volume data */
+	opj_volume_destroy(volume);
+	
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/CMakeLists.txt ./jp3d/libjp3dvm/CMakeLists.txt
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/CMakeLists.txt	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,24 @@
+INCLUDE_REGULAR_EXPRESSION("^.*$")
+# Defines the source code for the library
+SET(JP3DVM_SRCS
+bio.c  cio.c  dwt.c  event.c  jp3d.c  jp3d_lib.c  mct.c  mqc.c  openjpeg.c  pi.c  raw.c  t1.c  t1_3d.c  t2.c  tcd.c  tgt.c  volume.c
+)
+
+# Pass proper definition to preprocessor to generate shared lib
+IF(WIN32)
+  IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_EXPORTS)
+  ELSE(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_STATIC)
+  ENDIF(BUILD_SHARED_LIBS)
+ENDIF(WIN32)
+
+# Create the library
+#ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+ADD_LIBRARY(${OPJ_PREFIX}openjp3dvm ${JP3DVM_SRCS})
+
+# Install library
+INSTALL_TARGETS(/lib/ ${OPJ_PREFIX}openjp3dvm)
+
+# Install includes files
+INSTALL_FILES(/include .h)
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/dirent.h ./jp3d/libjp3dvm/dirent.h
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/dirent.h	2006-10-30 15:32:50.000000000 +0000
+++ ./jp3d/libjp3dvm/dirent.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,676 +0,0 @@
-/*
- * uce-dirent.h - operating system independent dirent implementation
- * 
- * Copyright (C) 1998-2002  Toni Ronkko
- * 
- * Permission is hereby granted, free of charge, to any person obtaining
- * a copy of this software and associated documentation files (the
- * ``Software''), to deal in the Software without restriction, including
- * without limitation the rights to use, copy, modify, merge, publish,
- * distribute, sublicense, and/or sell copies of the Software, and to
- * permit persons to whom the Software is furnished to do so, subject to
- * the following conditions:
- * 
- * The above copyright notice and this permission notice shall be included
- * in all copies or substantial portions of the Software.
- * 
- * THE SOFTWARE IS PROVIDED ``AS IS'', WITHOUT WARRANTY OF ANY KIND, EXPRESS
- * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
- * IN NO EVENT SHALL TONI RONKKO BE LIABLE FOR ANY CLAIM, DAMAGES OR
- * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
- * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
- * OTHER DEALINGS IN THE SOFTWARE.
- * 
- * 
- * May 28 1998, Toni Ronkko <tronkko@messi.uku.fi>
- *
- * $Id: uce-dirent.h,v 1.7 2002/05/13 10:48:35 tr Exp $
- *
- * $Log: uce-dirent.h,v $
- * Revision 1.7  2002/05/13 10:48:35  tr
- * embedded some source code directly to the header so that no source
- * modules need to be included in the MS Visual C project using the
- * interface, removed all the dependencies to other headers of the `uce'
- * library so that the header can be made public
- *
- * Revision 1.6  2002/04/12 16:22:04  tr
- * Unified Compiling Environment (UCE) replaced `std' library
- *
- * Revision 1.5  2001/07/20 16:33:40  tr
- * moved to `std' library and re-named defines accordingly
- *
- * Revision 1.4  2001/07/10 16:47:18  tronkko
- * revised comments
- *
- * Revision 1.3  2001/01/11 13:16:43  tr
- * using ``uce-machine.h'' for finding out defines such as `FREEBSD'
- *
- * Revision 1.2  2000/10/08 16:00:41  tr
- * copy of FreeBSD man page
- *
- * Revision 1.1  2000/07/10 05:53:16  tr
- * Initial revision
- *
- * Revision 1.2  1998/07/19 18:29:14  tr
- * Added error reporting capabilities and some asserts.
- *
- * Revision 1.1  1998/07/04 16:27:51  tr
- * Initial revision
- *
- * 
- * MSVC 1.0 scans automatic dependencies incorrectly when your project
- * contains this very header.  The problem is that MSVC cannot handle
- * include directives inside #if..#endif block those are never entered.
- * Since this header ought to compile in many different operating systems,
- * there had to be several conditional blocks that are compiled only in
- * operating systems for what they were designed for.  MSVC 1.0 cannot
- * handle inclusion of sys/dir.h in a part that is compiled only in Apollo
- * operating system.  To fix the problem you need to insert DIR.H into
- * SYSINCL.DAT located in MSVC\BIN directory and restart visual C++.
- * Consult manuals for more informaton about the problem.
- *
- * Since many UNIX systems have dirent.h we assume to have one also.
- * However, if your UNIX system does not have dirent.h you can download one
- * for example at: http://ftp.uni-mannheim.de/ftp/GNU/dirent/dirent.tar.gz.
- * You can also see if you have one of dirent.h, direct.h, dir.h, ndir.h,
- * sys/dir.h and sys/ndir.h somewhere.  Try defining HAVE_DIRENT_H,
- * HAVE_DIRECT_H, HAVE_DIR_H, HAVE_NDIR_H, HAVE_SYS_DIR_H and
- * HAVE_SYS_NDIR_H according to the files found.
- */
-#ifndef DIRENT_H
-#define DIRENT_H
-#define DIRENT_H_INCLUDED
-
-/* find out platform */
-#if defined(MSDOS)                             /* MS-DOS */
-#elif defined(__MSDOS__)                       /* Turbo C/Borland */
-# define MSDOS
-#elif defined(__DOS__)                         /* Watcom */
-# define MSDOS
-#endif
-
-#if defined(WIN32)                             /* MS-Windows */
-#elif defined(__NT__)                          /* Watcom */
-# define WIN32
-#elif defined(_WIN32)                          /* Microsoft */
-# define WIN32
-#elif defined(__WIN32__)                       /* Borland */
-# define WIN32
-#endif
-
-/*
- * See what kind of dirent interface we have unless autoconf has already
- * determinated that.
- */
-#if !defined(HAVE_DIRENT_H) && !defined(HAVE_DIRECT_H) && !defined(HAVE_SYS_DIR_H) && !defined(HAVE_NDIR_H) && !defined(HAVE_SYS_NDIR_H) && !defined(HAVE_DIR_H)
-# if defined(_MSC_VER)                         /* Microsoft C/C++ */
-    /* no dirent.h */
-# elif defined(__BORLANDC__)                   /* Borland C/C++ */
-#   define HAVE_DIRENT_H
-#   define VOID_CLOSEDIR
-# elif defined(__TURBOC__)                     /* Borland Turbo C */
-    /* no dirent.h */
-# elif defined(__WATCOMC__)                    /* Watcom C/C++ */
-#   define HAVE_DIRECT_H
-# elif defined(__apollo)                       /* Apollo */
-#   define HAVE_SYS_DIR_H
-# elif defined(__hpux)                         /* HP-UX */
-#   define HAVE_DIRENT_H
-# elif defined(__alpha) || defined(__alpha__)  /* Alpha OSF1 */
-#   error "not implemented"
-# elif defined(__sgi)                          /* Silicon Graphics */
-#   define HAVE_DIRENT_H
-# elif defined(sun) || defined(_sun)           /* Sun Solaris */
-#   define HAVE_DIRENT_H
-# elif defined(__FreeBSD__)                    /* FreeBSD */
-#   define HAVE_DIRENT_H
-# elif defined(__linux__)                      /* Linux */
-#   define HAVE_DIRENT_H
-# elif defined(__GNUC__)                       /* GNU C/C++ */
-#   define HAVE_DIRENT_H
-# else
-#   error "not implemented"
-# endif
-#endif
-
-/* include proper interface headers */
-#if defined(HAVE_DIRENT_H)
-# include <dirent.h>
-# ifdef FREEBSD
-#   define NAMLEN(dp) ((int)((dp)->d_namlen))
-# else
-#   define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
-# endif
-
-#elif defined(HAVE_NDIR_H)
-# include <ndir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_SYS_NDIR_H)
-# include <sys/ndir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_DIRECT_H)
-# include <direct.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_DIR_H)
-# include <dir.h>
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(HAVE_SYS_DIR_H)
-# include <sys/types.h>
-# include <sys/dir.h>
-# ifndef dirent
-#   define dirent direct
-# endif
-# define NAMLEN(dp) ((int)((dp)->d_namlen))
-
-#elif defined(MSDOS) || defined(WIN32)
-
-  /* figure out type of underlaying directory interface to be used */
-# if defined(WIN32)
-#   define DIRENT_WIN32_INTERFACE
-# elif defined(MSDOS)
-#   define DIRENT_MSDOS_INTERFACE
-# else
-#   error "missing native dirent interface"
-# endif
-
-  /*** WIN32 specifics ***/
-# if defined(DIRENT_WIN32_INTERFACE)
-#   include <windows.h>
-#   if !defined(DIRENT_MAXNAMLEN)
-#     define DIRENT_MAXNAMLEN (MAX_PATH)
-#   endif
-
-
-  /*** MS-DOS specifics ***/
-# elif defined(DIRENT_MSDOS_INTERFACE)
-#   include <dos.h>
-
-    /* Borland defines file length macros in dir.h */
-#   if defined(__BORLANDC__)
-#     include <dir.h>
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
-#     endif
-#     if !defined(_find_t)
-#       define _find_t find_t
-#     endif
-
-    /* Turbo C defines ffblk structure in dir.h */
-#   elif defined(__TURBOC__)
-#     include <dir.h>
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN ((MAXFILE)+(MAXEXT))
-#     endif
-#     define DIRENT_USE_FFBLK
-
-    /* MSVC */
-#   elif defined(_MSC_VER)
-#     if !defined(DIRENT_MAXNAMLEN)
-#       define DIRENT_MAXNAMLEN (12)
-#     endif
-
-    /* Watcom */
-#   elif defined(__WATCOMC__)
-#     if !defined(DIRENT_MAXNAMLEN)
-#       if defined(__OS2__) || defined(__NT__)
-#         define DIRENT_MAXNAMLEN (255)
-#       else
-#         define DIRENT_MAXNAMLEN (12)
-#       endif
-#     endif
-
-#   endif
-# endif
-
-  /*** generic MS-DOS and MS-Windows stuff ***/
-# if !defined(NAME_MAX) && defined(DIRENT_MAXNAMLEN)
-#   define NAME_MAX DIRENT_MAXNAMLEN
-# endif
-# if NAME_MAX < DIRENT_MAXNAMLEN
-#   error "assertion failed: NAME_MAX >= DIRENT_MAXNAMLEN"
-# endif
-
-
-  /*
-   * Substitute for real dirent structure.  Note that `d_name' field is a
-   * true character array although we have it copied in the implementation
-   * dependent data.  We could save some memory if we had declared `d_name'
-   * as a pointer refering the name within implementation dependent data.
-   * We have not done that since some code may rely on sizeof(d_name) to be
-   * something other than four.  Besides, directory entries are typically so
-   * small that it takes virtually no time to copy them from place to place.
-   */
-  typedef struct dirent {
-    char d_name[NAME_MAX + 1];
-
-    /*** Operating system specific part ***/
-# if defined(DIRENT_WIN32_INTERFACE)       /*WIN32*/
-    WIN32_FIND_DATA data;
-# elif defined(DIRENT_MSDOS_INTERFACE)     /*MSDOS*/
-#   if defined(DIRENT_USE_FFBLK)
-    struct ffblk data;
-#   else
-    struct _find_t data;
-#   endif
-# endif
-  } dirent;
-
-  /* DIR substitute structure containing directory name.  The name is
-   * essential for the operation of ``rewinndir'' function. */
-  typedef struct DIR {
-    char          *dirname;                    /* directory being scanned */
-    dirent        current;                     /* current entry */
-    int           dirent_filled;               /* is current un-processed? */
-
-  /*** Operating system specific part ***/
-#  if defined(DIRENT_WIN32_INTERFACE)
-    HANDLE        search_handle;
-#  elif defined(DIRENT_MSDOS_INTERFACE)
-#  endif
-  } DIR;
-
-# ifdef __cplusplus
-extern "C" {
-# endif
-
-/* supply prototypes for dirent functions */
-static DIR *opendir (const char *dirname);
-static struct dirent *readdir (DIR *dirp);
-static int closedir (DIR *dirp);
-static void rewinddir (DIR *dirp);
-
-/*
- * Implement dirent interface as static functions so that the user does not
- * need to change his project in any way to use dirent function.  With this
- * it is sufficient to include this very header from source modules using
- * dirent functions and the functions will be pulled in automatically.
- */
-#include <stdio.h>
-#include <stdlib.h>
-#include <string.h>
-#include <assert.h>
-#include <errno.h>
-
-/* use ffblk instead of _find_t if requested */
-#if defined(DIRENT_USE_FFBLK)
-# define _A_ARCH   (FA_ARCH)
-# define _A_HIDDEN (FA_HIDDEN)
-# define _A_NORMAL (0)
-# define _A_RDONLY (FA_RDONLY)
-# define _A_SUBDIR (FA_DIREC)
-# define _A_SYSTEM (FA_SYSTEM)
-# define _A_VOLID  (FA_LABEL)
-# define _dos_findnext(dest) findnext(dest)
-# define _dos_findfirst(name,flags,dest) findfirst(name,dest,flags)
-#endif
-
-static int _initdir (DIR *p);
-static const char *_getdirname (const struct dirent *dp);
-static void _setdirname (struct DIR *dirp);
-
-/*
- * <function name="opendir">
- * <intro>open directory stream for reading
- * <syntax>DIR *opendir (const char *dirname);
- *
- * <desc>Open named directory stream for read and return pointer to the
- * internal working area that is used for retrieving individual directory
- * entries.  The internal working area has no fields of your interest.
- *
- * <ret>Returns a pointer to the internal working area or NULL in case the 
- * directory stream could not be opened.  Global `errno' variable will set
- * in case of error as follows:
- *
- * <table>
- * [EACESS  |Permission denied.
- * [EMFILE  |Too many open files used by the process.
- * [ENFILE  |Too many open files in system.
- * [ENOENT  |Directory does not exist.
- * [ENOMEM  |Insufficient memory.
- * [ENOTDIR |dirname does not refer to directory.  This value is not
- *           reliable on MS-DOS and MS-Windows platforms.  Many
- *           implementations return ENOENT even when the name refers to a
- *           file.]
- * </table>
- * </function>
- */
-static DIR *opendir(const char *dirname)
-{
-  DIR *dirp;
-  assert (dirname != NULL);
-  
-  dirp = (DIR*)malloc (sizeof (struct DIR));
-  if (dirp != NULL) {
-    char *p;
-    
-    /* allocate room for directory name */
-    dirp->dirname = (char*) malloc (strlen (dirname) + 1 + strlen ("\\*.*"));
-    if (dirp->dirname == NULL) {
-      /* failed to duplicate directory name.  errno set by malloc() */
-      free (dirp);
-      return NULL;
-    }
-    /* Copy directory name while appending directory separator and "*.*".
-     * Directory separator is not appended if the name already ends with
-     * drive or directory separator.  Directory separator is assumed to be
-     * '/' or '\' and drive separator is assumed to be ':'. */
-    strcpy (dirp->dirname, dirname);
-    p = strchr (dirp->dirname, '\0');
-    if (dirp->dirname < p  &&
-        *(p - 1) != '\\'  &&  *(p - 1) != '/'  &&  *(p - 1) != ':')
-    {
-      strcpy (p++, "\\");
-    }
-# ifdef DIRENT_WIN32_INTERFACE
-    strcpy (p, "*"); /*scan files with and without extension in win32*/
-# else
-    strcpy (p, "*.*"); /*scan files with and without extension in DOS*/
-# endif
-
-    /* open stream */
-    if (_initdir (dirp) == 0) {
-      /* initialization failed */
-      free (dirp->dirname);
-      free (dirp);
-      return NULL;
-    }
-  }
-  return dirp;
-}
-
-
-/*
- * <function name="readdir">
- * <intro>read a directory entry
- * <syntax>struct dirent *readdir (DIR *dirp);
- *
- * <desc>Read individual directory entry and return pointer to a structure
- * containing the name of the entry.  Individual directory entries returned
- * include normal files, sub-directories, pseudo-directories "." and ".."
- * and also volume labels, hidden files and system files in MS-DOS and
- * MS-Windows.   You might want to use stat(2) function to determinate which
- * one are you dealing with.  Many dirent implementations already contain
- * equivalent information in dirent structure but you cannot depend on
- * this.
- *
- * The dirent structure contains several system dependent fields that
- * generally have no interest to you.  The only interesting one is char
- * d_name[] that is also portable across different systems.  The d_name
- * field contains the name of the directory entry without leading path.
- * While d_name is portable across different systems the actual storage
- * capacity of d_name varies from system to system and there is no portable
- * way to find out it at compile time as different systems define the
- * capacity of d_name with different macros and some systems do not define
- * capacity at all (besides actual declaration of the field). If you really
- * need to find out storage capacity of d_name then you might want to try
- * NAME_MAX macro. The NAME_MAX is defined in POSIX standard althought
- * there are many MS-DOS and MS-Windows implementations those do not define
- * it.  There are also systems that declare d_name as "char d_name[1]" and
- * then allocate suitable amount of memory at run-time.  Thanks to Alain
- * Decamps (Alain.Decamps@advalvas.be) for pointing it out to me.
- *
- * This all leads to the fact that it is difficult to allocate space
- * for the directory names when the very same program is being compiled on
- * number of operating systems.  Therefore I suggest that you always
- * allocate space for directory names dynamically.
- *
- * <ret>
- * Returns a pointer to a structure containing name of the directory entry
- * in `d_name' field or NULL if there was an error.  In case of an error the
- * global `errno' variable will set as follows:
- *
- * <table>
- * [EBADF  |dir parameter refers to an invalid directory stream.  This value
- *          is not set reliably on all implementations.]
- * </table>
- * </function>
- */
-static struct dirent *
-readdir (DIR *dirp)
-{
-  assert(dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return NULL;
-  }
-
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
-    /* directory stream was opened/rewound incorrectly or it ended normally */
-    errno = EBADF;
-    return NULL;
-  }
-#endif
-
-  if (dirp->dirent_filled != 0) {
-    /*
-     * Directory entry has already been retrieved and there is no need to
-     * retrieve a new one.  Directory entry will be retrieved in advance
-     * when the user calls readdir function for the first time.  This is so
-     * because real dirent has separate functions for opening and reading
-     * the stream whereas Win32 and DOS dirents open the stream
-     * automatically when we retrieve the first file.  Therefore, we have to
-     * save the first file when opening the stream and later we have to
-     * return the saved entry when the user tries to read the first entry.
-     */
-    dirp->dirent_filled = 0;
-  } else {
-    /* fill in entry and return that */
-#if defined(DIRENT_WIN32_INTERFACE)
-    if (FindNextFile (dirp->search_handle, &dirp->current.data) == FALSE) {
-      /* Last file has been processed or an error occured */
-      FindClose (dirp->search_handle);
-      dirp->search_handle = INVALID_HANDLE_VALUE;
-      errno = ENOENT;
-      return NULL;
-    }
-
-# elif defined(DIRENT_MSDOS_INTERFACE)
-    if (_dos_findnext (&dirp->current.data) != 0) {
-      /* _dos_findnext and findnext will set errno to ENOENT when no
-       * more entries could be retrieved. */
-      return NULL;
-    }
-# endif
-
-    _setdirname (dirp);
-    assert (dirp->dirent_filled == 0);
-  }
-  return &dirp->current;
-}
-
-
-/*
- * <function name="closedir">
- * <intro>close directory stream.
- * <syntax>int closedir (DIR *dirp);
- *
- * <desc>Close directory stream opened by the `opendir' function.  Close of
- * directory stream invalidates the DIR structure as well as previously read
- * dirent entry.
- *
- * <ret>The function typically returns 0 on success and -1 on failure but
- * the function may be declared to return void on same systems.  At least
- * Borland C/C++ and some UNIX implementations use void as a return type.
- * The dirent wrapper tries to define VOID_CLOSEDIR whenever closedir is
- * known to return nothing.  The very same definition is made by the GNU
- * autoconf if you happen to use it.
- *
- * The global `errno' variable will set to EBADF in case of error.
- * </function>
- */
-static int
-closedir (DIR *dirp)
-{   
-  int retcode = 0;
-
-  /* make sure that dirp points to legal structure */
-  assert (dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return -1;
-  }
- 
-  /* free directory name and search handles */
-  if (dirp->dirname != NULL) free (dirp->dirname);
-
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
-    if (FindClose (dirp->search_handle) == FALSE) {
-      /* Unknown error */
-      retcode = -1;
-      errno = EBADF;
-    }
-  }
-#endif                     
-
-  /* clear dirp structure to make sure that it cannot be used anymore*/
-  memset (dirp, 0, sizeof (*dirp));
-# if defined(DIRENT_WIN32_INTERFACE)
-  dirp->search_handle = INVALID_HANDLE_VALUE;
-# endif
-
-  free (dirp);
-  return retcode;
-}
-
-
-/*
- * <function name="rewinddir">
- * <intro>rewind directory stream to the beginning
- * <syntax>void rewinddir (DIR *dirp);
- *
- * <desc>Rewind directory stream to the beginning so that the next call of
- * readdir() returns the very first directory entry again.  However, note
- * that next call of readdir() may not return the same directory entry as it
- * did in first time.  The directory stream may have been affected by newly
- * created files.
- *
- * Almost every dirent implementation ensure that rewinddir will update
- * the directory stream to reflect any changes made to the directory entries
- * since the previous ``opendir'' or ``rewinddir'' call.  Keep an eye on
- * this if your program depends on the feature.  I know at least one dirent
- * implementation where you are required to close and re-open the stream to
- * see the changes.
- *
- * <ret>Returns nothing.  If something went wrong while rewinding, you will
- * notice it later when you try to retrieve the first directory entry.
- */
-static void
-rewinddir (DIR *dirp)
-{   
-  /* make sure that dirp is legal */
-  assert (dirp != NULL);
-  if (dirp == NULL) {
-    errno = EBADF;
-    return;
-  }
-  assert (dirp->dirname != NULL);
-  
-  /* close previous stream */
-#if defined(DIRENT_WIN32_INTERFACE)
-  if (dirp->search_handle != INVALID_HANDLE_VALUE) {
-    if (FindClose (dirp->search_handle) == FALSE) {
-      /* Unknown error */
-      errno = EBADF;
-    }
-  }
-#endif
-
-  /* re-open previous stream */
-  if (_initdir (dirp) == 0) {
-    /* initialization failed but we cannot deal with error.  User will notice
-     * error later when she tries to retrieve first directory enty. */
-    /*EMPTY*/;
-  }
-}
-
-
-/*
- * Open native directory stream object and retrieve first file.
- * Be sure to close previous stream before opening new one.
- */
-static int
-_initdir (DIR *dirp)
-{ 
-  assert (dirp != NULL);
-  assert (dirp->dirname != NULL);
-  dirp->dirent_filled = 0;
-
-# if defined(DIRENT_WIN32_INTERFACE)
-  /* Open stream and retrieve first file */
-  dirp->search_handle = FindFirstFile (dirp->dirname, &dirp->current.data);
-  if (dirp->search_handle == INVALID_HANDLE_VALUE) {
-    /* something went wrong but we don't know what.  GetLastError() could
-     * give us more information about the error, but then we should map
-     * the error code into errno. */
-    errno = ENOENT;
-    return 0;
-  }
-
-# elif defined(DIRENT_MSDOS_INTERFACE)
-  if (_dos_findfirst (dirp->dirname,
-          _A_SUBDIR | _A_RDONLY | _A_ARCH | _A_SYSTEM | _A_HIDDEN,
-          &dirp->current.data) != 0)
-  {
-    /* _dos_findfirst and findfirst will set errno to ENOENT when no 
-     * more entries could be retrieved. */
-    return 0;
-  }
-# endif
-
-  /* initialize DIR and it's first entry */
-  _setdirname (dirp);
-  dirp->dirent_filled = 1;
-  return 1;
-}
-
-
-/*
- * Return implementation dependent name of the current directory entry.
- */
-static const char *
-_getdirname (const struct dirent *dp)
-{
-#if defined(DIRENT_WIN32_INTERFACE)
-  return dp->data.cFileName;
-  
-#elif defined(DIRENT_USE_FFBLK)
-  return dp->data.ff_name;
-  
-#else
-  return dp->data.name;
-#endif  
-}
-
-
-/*
- * Copy name of implementation dependent directory entry to the d_name field.
- */
-static void
-_setdirname (struct DIR *dirp) {
-  /* make sure that d_name is long enough */
-  assert (strlen (_getdirname (&dirp->current)) <= NAME_MAX);
-  
-  strncpy (dirp->current.d_name,
-      _getdirname (&dirp->current),
-      NAME_MAX);
-  dirp->current.d_name[NAME_MAX] = '\0'; /*char d_name[NAME_MAX+1]*/
-}
-  
-# ifdef __cplusplus
-}
-# endif
-# define NAMLEN(dp) ((int)(strlen((dp)->d_name)))
-
-#else
-# error "missing dirent interface"
-#endif
-
-
-#endif /*DIRENT_H*/
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/all-wcprops ./jp3d/libjp3dvm/.svn/all-wcprops
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/all-wcprops	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,233 @@
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/437/trunk/jp3d/libjp3dvm
+END
+raw.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/raw.h
+END
+dwt.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/dwt.c
+END
+tgt.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/tgt.c
+END
+dwt.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/dwt.h
+END
+tgt.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/tgt.h
+END
+openjpeg.c
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/openjpeg.c
+END
+volume.c
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/volume.c
+END
+openjpeg.h
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/openjpeg.h
+END
+volume.h
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/volume.h
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/437/trunk/jp3d/libjp3dvm/CMakeLists.txt
+END
+int.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/int.h
+END
+jp3d.c
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/jp3d.c
+END
+jp3d.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/jp3d.h
+END
+pi.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/pi.c
+END
+bio.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/bio.c
+END
+tcd.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/tcd.c
+END
+cio.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/cio.c
+END
+t1_3d.c
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t1_3d.c
+END
+pi.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/pi.h
+END
+bio.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/bio.h
+END
+tcd.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/tcd.h
+END
+cio.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/cio.h
+END
+t1_3d.h
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t1_3d.h
+END
+mqc.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/mqc.c
+END
+event.c
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/event.c
+END
+mct.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/mct.c
+END
+opj_includes.h
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/opj_includes.h
+END
+t1.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t1.c
+END
+mqc.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/mqc.h
+END
+t2.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t2.c
+END
+jp3d_lib.c
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/jp3d_lib.c
+END
+event.h
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/event.h
+END
+mct.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/mct.h
+END
+t1.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t1.h
+END
+raw.c
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/raw.c
+END
+t2.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/t2.h
+END
+fix.h
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/fix.h
+END
+jp3d_lib.h
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/289/trunk/jp3d/libjp3dvm/jp3d_lib.h
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/entries ./jp3d/libjp3dvm/.svn/entries
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,522 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/jp3d/libjp3dvm
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+raw.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+273c5befcda2520ad90f3ed8d0e0a944
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+dwt.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+cef5197c0f2654bb35035a01ed1c6855
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+tgt.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+1629158f1ccc39bef7ad64be7b4adb75
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+dwt.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+945131312d1a758787168d68b7188a2e
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+tgt.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+12a71e998787555e71aa8e80dac75af2
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+openjpeg.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+5a4d768abeee0fda06f8cd9c532f191f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+volume.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+d182247696a75bfdbe6c5323ab95644a
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+openjpeg.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+164c3efe9bf92a9807dcc41b8f3df73f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+volume.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+efe7635561b5b5c0e591bff00c1c4531
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+08b8d148067c145eae076bcbd4f00eb6
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+has-props
+
+int.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+0b47fbfbc9addbfbe415c7a96baf1673
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+9dee2672f1bb95eb59bd843140d89c9c
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+be97a4a7382a8e96c8ef1578f837751e
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+pi.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+5cd0a59d1689041039c010fca771412c
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+bio.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+7725aec728ed78d1fe6d3bf7104871a8
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t1_3d.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+2deb72e9cbbd351bd1c1ccef5a7a4f37
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+cio.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+a297057c786b7104ae59762b4b320600
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+tcd.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+a477902ce1801d7da666ce328fb640fd
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+pi.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+5b42a07de3782a775cedefdd262ccd75
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+bio.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+c86ac924cc6ac4509f9d28cbb20e5d2e
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t1_3d.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+578447dfce903e00cfc1bad2eaa10ca3
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+cio.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+28d19e29c801586cdf66765d1140018b
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+tcd.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+5897667348a52f7f9e8845269c438e8f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+mqc.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+26aee64a01de77dfcdfd291712662d76
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+event.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+29ce7007ac38efd8862263f65ed28075
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+opj_includes.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+edb9251a1f856c19a8f75f00acf14073
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+mct.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+3c6a213faaf14c41905acf3317d5a84f
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t1.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+28c6455587fc6bd96ca9c3d56ce2fba5
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t2.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+f255534a97ad8d7b774195c1d7c2d024
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+mqc.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+1763b6cbd55614efacb46d5126a42ac3
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+event.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+f07c5aad690bd294ea5712900df1097d
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_lib.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+e886568bdd0b7af54cd5a2f50bc46682
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+mct.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+23f219f0a70be5647f853acd31c93ad8
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t1.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+a7f436a6a36c46fd0bc2fb5b4731d6b7
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+raw.c
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+661f78c4cfdc1dcbf1b7b1186acb930a
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+t2.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+12c89940af16b64e1f667631b6a913d3
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+fix.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+5eca09fdaa788e58a00cfa0dd8c8e827
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+jp3d_lib.h
+file
+
+
+
+
+2007-09-28T10:33:46.000000Z
+51c9384c91435e2d7a26eec61f30e7dd
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/format ./jp3d/libjp3dvm/.svn/format
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/format	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/bio.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/bio.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/bio.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/bio.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/cio.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/cio.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/cio.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/cio.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/CMakeLists.txt.svn-base ./jp3d/libjp3dvm/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/dwt.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/dwt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/dwt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/dwt.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/dwt.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/dwt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/dwt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/dwt.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/event.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/event.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/event.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/event.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/event.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/event.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/event.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/event.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/fix.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/fix.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/int.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/int.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/int.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/jp3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/jp3d.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/jp3d.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/jp3d.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/jp3d_lib.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mct.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/mct.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mct.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/mct.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mct.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/mct.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mct.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/mct.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mqc.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/mqc.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mqc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/mqc.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mqc.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/mqc.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/mqc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/mqc.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/openjpeg.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/openjpeg.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/openjpeg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/openjpeg.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/openjpeg.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/openjpeg.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/openjpeg.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/openjpeg.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/opj_includes.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/opj_includes.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/opj_includes.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/opj_includes.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/pi.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/pi.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/pi.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/pi.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/raw.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/raw.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/raw.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/raw.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/raw.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/raw.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/raw.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/raw.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1_3d.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t1_3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1_3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t1_3d.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1_3d.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t1_3d.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1_3d.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t1_3d.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t1.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t1.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t1.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t1.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t1.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t2.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t2.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t2.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/t2.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tcd.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/tcd.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tcd.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/tcd.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tgt.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/tgt.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tgt.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/tgt.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/volume.c.svn-base ./jp3d/libjp3dvm/.svn/prop-base/volume.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/volume.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/volume.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/volume.h.svn-base ./jp3d/libjp3dvm/.svn/prop-base/volume.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/prop-base/volume.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/prop-base/volume.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/bio.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/bio.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,189 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup BIO BIO - Individual bit input-output stream */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Write a bit
+@param bio BIO handle
+@param b Bit to write (0 or 1)
+*/
+static void bio_putbit(opj_bio_t *bio, int b);
+/**
+Read a bit
+@param bio BIO handle
+@return Returns the read bit
+*/
+static int bio_getbit(opj_bio_t *bio);
+/**
+Write a byte
+@param bio BIO handle
+@return Returns 0 if successful, returns 1 otherwise
+*/
+static int bio_byteout(opj_bio_t *bio);
+/**
+Read a byte
+@param bio BIO handle
+@return Returns 0 if successful, returns 1 otherwise
+*/
+static int bio_bytein(opj_bio_t *bio);
+
+/*@}*/
+
+/*@}*/
+
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static int bio_byteout(opj_bio_t *bio) {
+	bio->buf = (bio->buf << 8) & 0xffff;
+	bio->ct = bio->buf == 0xff00 ? 7 : 8;
+	if (bio->bp >= bio->end) {
+		return 1;
+	}
+	*bio->bp++ = bio->buf >> 8;
+	return 0;
+}
+
+static int bio_bytein(opj_bio_t *bio) {
+	bio->buf = (bio->buf << 8) & 0xffff;
+	bio->ct = bio->buf == 0xff00 ? 7 : 8;
+	if (bio->bp >= bio->end) {
+		return 1;
+	}
+	bio->buf |= *bio->bp++;
+	return 0;
+}
+
+static void bio_putbit(opj_bio_t *bio, int b) {
+	if (bio->ct == 0) {
+		bio_byteout(bio);
+	}
+	bio->ct--;
+	bio->buf |= b << bio->ct;
+}
+
+/* MOD antonin */
+static int bio_getbit(opj_bio_t *bio) {
+/* DOM */
+	if (bio->ct == 0) {
+		bio_bytein(bio);
+	}
+	bio->ct--;
+	return (bio->buf >> bio->ct) & 1;
+}
+
+/* 
+==========================================================
+   Bit Input/Output interface
+==========================================================
+*/
+
+opj_bio_t* bio_create() {
+	opj_bio_t *bio = (opj_bio_t*)opj_malloc(sizeof(opj_bio_t));
+	return bio;
+}
+
+void bio_destroy(opj_bio_t *bio) {
+	if(bio) {
+		opj_free(bio);
+	}
+}
+
+int bio_numbytes(opj_bio_t *bio) {
+	return (bio->bp - bio->start);
+}
+
+void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len) {
+	bio->start = bp;
+	bio->end = bp + len;
+	bio->bp = bp;
+	bio->buf = 0;
+	bio->ct = 8;
+}
+
+void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len) {
+	bio->start = bp;
+	bio->end = bp + len;
+	bio->bp = bp;
+	bio->buf = 0;
+	bio->ct = 0;
+}
+
+void bio_write(opj_bio_t *bio, int v, int n) {
+	int i;
+	for (i = n - 1; i >= 0; i--) {
+		bio_putbit(bio, (v >> i) & 1);
+	}
+}
+
+int bio_read(opj_bio_t *bio, int n) {
+	int i, v;
+	v = 0;
+	for (i = n - 1; i >= 0; i--) {
+		v += bio_getbit(bio) << i;
+	}
+	return v;
+}
+
+int bio_flush(opj_bio_t *bio) {
+	bio->ct = 0;
+	if (bio_byteout(bio)) {
+		return 1;
+	}
+	if (bio->ct == 7) {
+		bio->ct = 0;
+		if (bio_byteout(bio)) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int bio_inalign(opj_bio_t *bio) {
+	bio->ct = 0;
+	if ((bio->buf & 0xff) == 0xff) {
+		if (bio_bytein(bio)) {
+			return 1;
+		}
+		bio->ct = 0;
+	}
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/bio.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/bio.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __BIO_H
+#define __BIO_H
+/** 
+@file bio.h
+@brief Implementation of an individual bit input-output (BIO)
+
+The functions in BIO.C have for goal to realize an individual bit input - output.
+*/
+
+/** @defgroup BIO BIO - Individual bit input-output stream */
+/*@{*/
+
+/**
+Individual bit input-output stream (BIO)
+*/
+typedef struct opj_bio {
+/** pointer to the start of the buffer */
+	unsigned char *start;	
+/** pointer to the end of the buffer */
+	unsigned char *end;		
+/** pointer to the present position in the buffer */
+	unsigned char *bp;		
+/** temporary place where each byte is read or written */
+	unsigned int buf;		
+/** coder : number of bits free to write. decoder : number of bits read */
+	int ct;					
+} opj_bio_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new BIO handle 
+@return Returns a new BIO handle if successful, returns NULL otherwise
+*/
+opj_bio_t* bio_create();
+/**
+Destroy a previously created BIO handle
+@param bio BIO handle to destroy
+*/
+void bio_destroy(opj_bio_t *bio);
+/**
+Number of bytes written.
+@param bio BIO handle
+@return Returns the number of bytes written
+*/
+int bio_numbytes(opj_bio_t *bio);
+/**
+Init encoder
+@param bio BIO handle
+@param bp Output buffer
+@param len Output buffer length 
+*/
+void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len);
+/**
+Init decoder
+@param bio BIO handle
+@param bp Input buffer
+@param len Input buffer length 
+*/
+void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len);
+/**
+Write bits
+@param bio BIO handle
+@param v Value of bits
+@param n Number of bits to write
+*/
+void bio_write(opj_bio_t *bio, int v, int n);
+/**
+Read bits
+@param bio BIO handle
+@param n Number of bits to read 
+@return Returns the corresponding read number
+*/
+int bio_read(opj_bio_t *bio, int n);
+/**
+Flush bits
+@param bio BIO handle
+@return Returns 1 if successful, returns 0 otherwise
+*/
+int bio_flush(opj_bio_t *bio);
+/**
+Passes the ending bits (coming from flushing)
+@param bio BIO handle
+@return Returns 1 if successful, returns 0 otherwise
+*/
+int bio_inalign(opj_bio_t *bio);
+/**
+Read a bit
+@param bio BIO handle
+@return Returns the read bit
+*/
+/* MOD antonin */
+//int bio_getbit(opj_bio_t *bio);
+/* DOM */
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __BIO_H */
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/cio.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/cio.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,217 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* ----------------------------------------------------------------------- */
+
+opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length) {
+	opj_cp_t *cp = NULL;
+	opj_cio_t *cio = (opj_cio_t*)opj_malloc(sizeof(opj_cio_t));
+	if(!cio) return NULL;
+	cio->cinfo = cinfo;
+	if(buffer && length) {
+		/* wrap a user buffer containing the encoded image */
+		cio->openmode = OPJ_STREAM_READ;
+		cio->buffer = buffer;
+		cio->length = length;
+	}
+	else if(!buffer && !length && cinfo) {
+		/* allocate a buffer for the encoded image */
+		cio->openmode = OPJ_STREAM_WRITE;
+		switch(cinfo->codec_format) {
+			case CODEC_J3D:
+			case CODEC_J2K:
+				cp = ((opj_j3d_t*)cinfo->j3d_handle)->cp;
+				break;
+			default:
+				opj_free(cio);
+				return NULL;
+		}
+		cio->length = cp->tdx * cp->tdy * cp->tdz * cp->tw * cp->th * cp->tl * 4;
+		cio->buffer = (unsigned char *)opj_malloc(cio->length);
+		if(!cio->buffer) {
+			opj_free(cio);
+			return NULL;
+		}
+	}
+	else {
+		opj_free(cio);
+		return NULL;
+	}
+
+	/* Initialize byte IO */
+	cio->start = cio->buffer;
+	cio->end = cio->buffer + cio->length;
+	cio->bp = cio->buffer;
+
+	return cio;
+}
+
+void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio) {
+	if(cio) {
+		if(cio->openmode == OPJ_STREAM_WRITE) {
+			/* destroy the allocated buffer */
+			opj_free(cio->buffer);
+		}
+		/* destroy the cio */
+		opj_free(cio);
+	}
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+/*
+ * Get position in byte stream.
+ */
+int OPJ_CALLCONV cio_tell(opj_cio_t *cio) {
+	return cio->bp - cio->start;
+}
+
+/*
+ * Set position in byte stream.
+ *
+ * pos : position, in number of bytes, from the beginning of the stream
+ */
+void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos) {
+	cio->bp = cio->start + pos;
+}
+
+/*
+ * Number of bytes left before the end of the stream.
+ */
+int cio_numbytesleft(opj_cio_t *cio) {
+	return cio->end - cio->bp;
+}
+
+/*
+ * Get pointer to the current position in the stream.
+ */
+unsigned char *cio_getbp(opj_cio_t *cio) {
+	return cio->bp;
+}
+
+/*
+ * Write a byte.
+ */
+bool cio_byteout(opj_cio_t *cio, unsigned char v) {
+	if (cio->bp >= cio->end) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "write error\n");
+		return false;
+	}
+	*cio->bp++ = v;
+	return true;
+}
+
+/*
+ * Read a byte.
+ */
+unsigned char cio_bytein(opj_cio_t *cio) {
+	if (cio->bp >= cio->end) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "read error\n");
+		return 0;
+	}
+	return *cio->bp++;
+}
+
+/*
+ * Write some bytes.
+ *
+ * v : value to write
+ * n : number of bytes to write
+ */
+unsigned int cio_write(opj_cio_t *cio, unsigned int v, int n) {
+	int i;
+	for (i = n - 1; i >= 0; i--) {
+		if( !cio_byteout(cio, (unsigned char) ((v >> (i << 3)) & 0xff)) )
+			return 0;
+	}
+	return n;
+}
+
+/*
+ * Read some bytes.
+ *
+ * n : number of bytes to read
+ *
+ * return : value of the n bytes read
+ */
+unsigned int cio_read(opj_cio_t *cio, int n) {
+	int i;
+	unsigned int v;
+	v = 0;
+	for (i = n - 1; i >= 0; i--) {
+		v += cio_bytein(cio) << (i << 3);
+	}
+	return v;
+}
+
+/* 
+ * Skip some bytes.
+ *
+ * n : number of bytes to skip
+ */
+void cio_skip(opj_cio_t *cio, int n) {
+	cio->bp += n;
+}
+
+/*
+ * Write some bytes.
+ *
+ * v : value to write
+ * n : number of bytes to write
+ */
+int cio_write_int(opj_cio_t *cio, int v, int n) {
+	int i;
+	for (i = n - 1; i >= 0; i--) {
+		if( !cio_byteout(cio, (char) ((v >> (i << 3)) & 0xff)) )
+			return 0;
+	}
+	return n;
+}
+
+/*
+ * Read some bytes.
+ *
+ * n : number of bytes to read
+ *
+ * return : value of the n bytes read
+ */
+int cio_read_int(opj_cio_t *cio, int n) {
+	int i;
+	int v;
+	v = 0;
+	for (i = n - 1; i >= 0; i--) {
+		v += cio_bytein(cio) << (i << 3);
+	}
+	return v;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/cio.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/cio.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CIO_H
+#define __CIO_H
+/**
+@file cio.h
+@brief Implementation of a byte input-output process (CIO)
+
+The functions in CIO.C have for goal to realize a byte input / output process.
+*/
+
+/** @defgroup CIO CIO - byte input-output stream */
+/*@{*/
+
+/** @name Funciones generales (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Number of bytes left before the end of the stream
+@param cio CIO handle
+@return Returns the number of bytes before the end of the stream
+*/
+int cio_numbytesleft(opj_cio_t *cio);
+/**
+Get pointer to the current position in the stream
+@param cio CIO handle
+@return Returns a pointer to the current position
+*/
+unsigned char *cio_getbp(opj_cio_t *cio);
+/**
+Write some bytes
+@param cio CIO handle
+@param v Value to write
+@param n Number of bytes to write
+@return Returns the number of bytes written or 0 if an error occured
+*/
+unsigned int cio_write(opj_cio_t *cio, unsigned int v, int n);
+/**
+Read some bytes
+@param cio CIO handle
+@param n Number of bytes to read
+@return Returns the value of the n bytes read
+*/
+unsigned int cio_read(opj_cio_t *cio, int n);
+/**
+Skip some bytes
+@param cio CIO handle
+@param n Number of bytes to skip
+*/
+void cio_skip(opj_cio_t *cio, int n);
+/**
+Write some bytes
+@param cio CIO handle
+@param v Signed integer value to write
+@param n Number of bytes to write
+@return Returns the number of bytes written or 0 if an error occured
+*/
+int cio_write_int(opj_cio_t *cio, int v, int n);
+/**
+Read some bytes
+@param cio CIO handle
+@param n Number of bytes to read
+@return Returns the value of the n bytes read
+*/
+int cio_read_int(opj_cio_t *cio, int n);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __CIO_H */
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/CMakeLists.txt.svn-base ./jp3d/libjp3dvm/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,24 @@
+INCLUDE_REGULAR_EXPRESSION("^.*$")
+# Defines the source code for the library
+SET(JP3DVM_SRCS
+bio.c  cio.c  dwt.c  event.c  jp3d.c  jp3d_lib.c  mct.c  mqc.c  openjpeg.c  pi.c  raw.c  t1.c  t1_3d.c  t2.c  tcd.c  tgt.c  volume.c
+)
+
+# Pass proper definition to preprocessor to generate shared lib
+IF(WIN32)
+  IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_EXPORTS)
+  ELSE(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_STATIC)
+  ENDIF(BUILD_SHARED_LIBS)
+ENDIF(WIN32)
+
+# Create the library
+#ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+ADD_LIBRARY(${OPJ_PREFIX}openjp3dvm ${JP3DVM_SRCS})
+
+# Install library
+INSTALL_TARGETS(/lib/ ${OPJ_PREFIX}openjp3dvm)
+
+# Install includes files
+INSTALL_FILES(/include .h)
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/dwt.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/dwt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/dwt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/dwt.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,1016 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyrigth (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+/*
+ *  NOTE:
+ *  This is a modified version of the openjpeg dwt.c file.
+ *  Average speed improvement compared to the original file (measured on
+ *  my own machine, a P4 running at 3.0 GHz):
+ *  5x3 wavelets about 2 times faster
+ *  9x7 wavelets about 3 times faster
+ *  for both, encoding and decoding.
+ *
+ *  The better performance is caused by doing the 1-dimensional DWT
+ *  within a temporary buffer where the data can be accessed sequential
+ *  for both directions, horizontal and vertical. The 2d vertical DWT was
+ *  the major bottleneck in the former version.
+ *
+ *  I have also removed the "Add Patrick" part because it is not longer
+ *  needed.  
+ *
+ *  6/6/2005
+ *  -Ive (aka Reiner Wahler)
+ *  mail: ive@lilysoft.com
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup DWT DWT - Implementation of a discrete wavelet transform */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+unsigned int ops;
+/**
+Forward lazy transform (horizontal)
+*/
+static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas);
+/**
+Forward lazy transform (vertical)
+*/
+static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas);
+/**
+Forward lazy transform (axial)
+*/
+static void dwt_deinterleave_z(int *a, int *b, int dn, int sn, int xy, int cas);
+/**
+Inverse lazy transform (horizontal)
+*/
+static void dwt_interleave_h(int *a, int *b, int dn, int sn, int cas);
+/**
+Inverse lazy transform (vertical)
+*/
+static void dwt_interleave_v(int *a, int *b, int dn, int sn, int x, int cas);
+/**
+Inverse lazy transform (axial)
+*/
+static void dwt_interleave_z(int *a, int *b, int dn, int sn, int xy, int cas);
+/**
+Forward 5-3 wavelet tranform in 1-D
+*/
+static void dwt_encode_53(int *a, int dn, int sn, int cas);
+static void dwt_encode_97(int *a, int dn, int sn, int cas);
+/**
+Inverse 5-3 wavelet tranform in 1-D
+*/
+static void dwt_decode_53(int *a, int dn, int sn, int cas);
+static void dwt_decode_97(int *a, int dn, int sn, int cas);
+/**
+Computing of wavelet transform L2 norms for arbitrary transforms
+*/
+static double dwt_calc_wtnorms(int orient, int level[3], int dwtid[3], opj_wtfilt_t *wtfiltx, opj_wtfilt_t *wtfilty, opj_wtfilt_t *wtfiltz);
+/**
+Encoding of quantification stepsize
+*/
+static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
+/*@}*/
+
+/*@}*/
+
+#define S(i) a[(i)*2]
+#define D(i) a[(1+(i)*2)]
+#define S_(i) ((i)<0?S(0):((i)>=sn?S(sn-1):S(i)))
+#define D_(i) ((i)<0?D(0):((i)>=dn?D(dn-1):D(i)))
+/* new */
+#define SS_(i) ((i)<0?S(0):((i)>=dn?S(dn-1):S(i)))
+#define DD_(i) ((i)<0?D(0):((i)>=sn?D(sn-1):D(i)))
+
+/* <summary>                                                              */
+/* This table contains the norms of the 5-3 wavelets for different bands. */
+/* </summary>                                                             */
+static double dwt_norm[10][10][10][8];
+static int flagnorm[10][10][10][8];
+
+/*static const double dwt_norms[5][8][10] = {
+	{//ResZ=1
+		{1.000, 1.500, 2.750, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
+		{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{.7186, .9218, 1.586, 3.043, 6.019, 12.01, 24.00, 47.97, 95.93}
+	},{//ResZ=2
+		{1.000, 1.8371, 2.750, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
+		{1.2717, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{1.2717, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{.8803, .9218, 1.586, 3.043, 6.019, 12.01, 24.00, 47.97, 95.93},
+		{1.2717},
+		{.8803},
+		{.8803},
+		{.6093},
+	},{ //ResZ=3
+		{1.000, 1.8371, 4.5604, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
+		{1.2717, 2.6403, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{1.2717, 2.6403, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{.8803, 1.5286, 1.586, 3.043, 6.019, 12.01, 24.00, 47.97, 95.93},
+		{1.2717, 2.6403},
+		{.8803, 1.5286},
+		{.8803, 1.5286},
+		{.6093, 0.8850},
+	},{ //ResZ=4
+		{1.000, 1.8371, 4.5604, 12.4614, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
+		{1.2717, 2.6403, 6.7691 , 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{1.2717, 2.6403, 6.7691 , 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{.8803, 1.5286, 3.6770 , 3.043, 6.019, 12.01, 24.00, 47.97, 95.93},
+		{1.2717, 2.6403, 6.7691 },
+		{.8803, 1.5286, 3.6770 },
+		{.8803, 1.5286, 3.6770 },
+		{.6093, 0.8850, 1.9974 },
+	},{ //ResZ=5
+		{1.000, 1.8371, 4.5604, 12.4614, 34.9025, 21.34, 42.67, 85.33, 170.7, 341.3},
+		{1.2717, 2.6403, 6.7691 , 18.6304 , 11.33, 22.64, 45.25, 90.48, 180.9},
+		{1.2717, 2.6403, 6.7691 , 18.6304, 11.33, 22.64, 45.25, 90.48, 180.9},
+		{.8803, 1.5286, 3.6770 , 9.9446, 6.019, 12.01, 24.00, 47.97, 95.93},
+		{1.2717, 2.6403, 6.7691, 18.6304},
+		{.8803, 1.5286, 3.6770, 9.9446 },
+		{.8803, 1.5286, 3.6770, 9.9446 },
+		{.6093, 0.8850, 1.9974, 5.3083 },
+	}
+};*/
+
+/* <summary>                                                              */
+/* This table contains the norms of the 9-7 wavelets for different bands. */
+/* </summary>                                                             */
+/*static const double dwt_norms_real[5][8][10] = {
+	{//ResZ==1
+		{1.000, 1.9659, 4.1224, 8.4167, 16.9356, 33.9249, 67.8772, 135.7680, 271.5430, 543.0894},
+		{1.0113, 1.9968, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{1.0113, 1.9968, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{0.5202, 0.9672, 2.0793, 4.3005, 8.6867, 17.4188, 34.8608, 69.7332, 139.4722}
+	}, { //ResZ==2
+		{1.000, 2.7564, 4.1224, 8.4167, 16.9356, 33.9249, 67.8772, 135.7680, 271.5430, 543.0894},
+		{1.4179, 1.9968, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{1.4179, 1.9968, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{0.7294, 0.9672, 2.0793, 4.3005, 8.6867, 17.4188, 34.8608, 69.7332, 139.4722},
+		{1.4179},
+		{0.7294},
+		{0.7294},
+		{0.3752} //HHH
+	},{ //ResZ==3
+		{1.000, 2.7564, 8.3700, 8.4167, 16.9356, 33.9249, 67.8772, 135.7680, 271.5430, 543.0894},
+		{1.4179, 4.0543, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{1.4179, 4.0543, 4.1834, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{0.7294, 1.9638, 2.0793, 4.3005, 8.6867, 17.4188, 34.8608, 69.7332, 139.4722},
+		{1.4179, 4.0543},
+		{0.7294, 1.9638},
+		{0.7294, 1.9638},
+		{0.3752, 0.9512} //HHH
+	},{ //ResZ==4
+		{1.000, 2.7564, 8.3700, 24.4183, 16.9356, 33.9249, 67.8772, 135.7680, 271.5430, 543.0894},
+		{1.4179, 4.0543, 12.1366, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{1.4179, 4.0543, 12.1366, 8.5341, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{0.7294, 1.9638, 6.0323, 4.3005, 8.6867, 17.4188, 34.8608, 69.7332, 139.4722},
+		{1.4179, 4.0543, 12.1366},
+		{0.7294, 1.9638, 6.0323},
+		{0.7294, 1.9638, 6.0323},
+		{0.3752, 0.9512, 2.9982} //HHH
+	},{ //ResZ==5
+		{1.000, 2.7564, 8.3700, 24.4183, 69.6947, 33.9249, 67.8772, 135.7680, 271.5430, 543.0894},
+		{1.4179, 4.0543, 12.1366, 35.1203, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{1.4179, 4.0543, 12.1366, 35.1203, 17.1667, 34.3852, 68.7967, 137.6065, 275.2196},
+		{0.7294, 1.9638, 6.0323, 17.6977, 8.6867, 17.4188, 34.8608, 69.7332, 139.4722},
+		{1.4179, 4.0543, 12.1366, 35.1203},
+		{0.7294, 1.9638, 6.0323, 17.6977},
+		{0.7294, 1.9638, 6.0323, 17.6977},
+		{0.3752, 0.9512, 2.9982, 8.9182} //HHH
+	}
+};*/
+
+static opj_atk_t atk_info_wt[] = {
+	{0, 1, J3D_ATK_WS, J3D_ATK_IRR, 0, J3D_ATK_WS, 1.230174104, 4, {0}, {0}, {0}, {1,1,1,1}, {-1.586134342059924, -0.052980118572961, 0.882911075530934, 0.443506852043971}},/* WT 9-7 IRR*/
+	{1, 0, J3D_ATK_WS, J3D_ATK_REV, 0, J3D_ATK_WS, 0, 2, {0}, {1,2}, {1,2}, {1,1}, {-1,1}},/* WT 5-3 REV*/
+	{2, 0, J3D_ATK_ARB, J3D_ATK_REV, 0, J3D_ATK_CON, 0, 2, {0,0}, {0,1}, {0,1}, {1,1}, {{-1},{1}}}, /* WT 2-2 REV*/
+	{3, 0, J3D_ATK_ARB, J3D_ATK_REV, 1, J3D_ATK_CON, 0, 3, {0,0,-1}, {0,1,2}, {0,1,2}, {1,1,3}, {{-1},{1},{1,0,-1}}}, /* WT 2-6 REV*/
+	{4, 0, J3D_ATK_ARB, J3D_ATK_REV, 1, J3D_ATK_CON, 0, 3, {0,0,-2}, {0,1,6}, {0,1,32}, {1,1,5}, {{-1},{1},{-3,22,0,-22,3}}}, /* WT 2-10 REV*/
+	{5, 1, J3D_ATK_ARB, J3D_ATK_IRR, 1, J3D_ATK_WS, 1, 7, {0}, {0}, {0}, {1,1,2,1,2,1,3},{{-1},{1.58613434206},{-0.460348209828, 0.460348209828},{0.25},{0.374213867768,-0.374213867768},{-1.33613434206},{0.29306717103,0,-0.29306717103}}}, /* WT 6-10 IRR*/
+	{6, 1, J3D_ATK_ARB, J3D_ATK_IRR, 0, J3D_ATK_WS, 1, 11, {0}, {0}, {0}, {1,1,2,1,2,1,2,1,2,1,5},{{-1},{0,99715069105},{-1.00573127827, 1.00573127827},{-0.27040357631},{2.20509972343, -2.20509972343},{0.08059995736},
+		{-1.62682532350, 1.62682532350},{0.52040357631},{0.60404664250, -0.60404664250},{-0.82775064841},{-0.06615812964, 0.29402137720, 0, -0.29402137720, 0.06615812964}}}, /* WT 10-18 IRR*/
+	{7, 1, J3D_ATK_WS, J3D_ATK_IRR, 0, J3D_ATK_WS, 1, 2, {0}, {0}, {0}, {1,1}, {-0.5, 0.25}},	/* WT 5-3 IRR*/
+	{8, 0, J3D_ATK_WS, J3D_ATK_REV, 0, J3D_ATK_WS, 0, 2, {0}, {4,4}, {8,8}, {2,2}, {{-9,1},{5,-1}}}		/* WT 13-7 REV*/
+};
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+/* <summary>			                 */
+/* Forward lazy transform (horizontal).  */
+/* </summary>                            */ 
+static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas) {
+	int i;
+    for (i=0; i<sn; i++) b[i]=a[2*i+cas];
+    for (i=0; i<dn; i++) b[sn+i]=a[(2*i+1-cas)];
+}
+
+/* <summary>                             */  
+/* Forward lazy transform (vertical).    */
+/* </summary>                            */ 
+static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas) {
+    int i;
+    for (i=0; i<sn; i++) b[i*x]=a[2*i+cas];
+    for (i=0; i<dn; i++) b[(sn+i)*x]=a[(2*i+1-cas)];
+}
+
+/* <summary>                             */  
+/* Forward lazy transform (axial).       */
+/* </summary>                            */ 
+static void dwt_deinterleave_z(int *a, int *b, int dn, int sn, int xy, int cas) {
+    int i;
+    for (i=0; i<sn; i++) b[i*xy]=a[2*i+cas];
+    for (i=0; i<dn; i++) b[(sn+i)*xy]=a[(2*i+1-cas)];
+}
+
+/* <summary>                             */
+/* Inverse lazy transform (horizontal).  */
+/* </summary>                            */
+static void dwt_interleave_h(int *a, int *b, int dn, int sn, int cas) {
+    int i;
+    int *ai = NULL;
+    int *bi = NULL;
+    ai = a;
+    bi = b + cas;
+    for (i = 0; i < sn; i++) {
+      *bi = *ai;  
+	  bi += 2;  
+	  ai++;
+    }
+    ai = a + sn;
+    bi = b + 1 - cas;
+    for (i = 0; i < dn; i++) {
+      *bi = *ai;
+	  bi += 2;
+	  ai++;
+    }
+}
+
+/* <summary>                             */  
+/* Inverse lazy transform (vertical).    */
+/* </summary>                            */ 
+static void dwt_interleave_v(int *a, int *b, int dn, int sn, int x, int cas) {
+    int i;
+    int *ai = NULL;
+    int *bi = NULL;
+    ai = a;
+    bi = b + cas;
+    for (i = 0; i < sn; i++) {
+      *bi = *ai;
+	  bi += 2;
+	  ai += x;
+    }
+    ai = a + (sn * x);
+    bi = b + 1 - cas;
+    for (i = 0; i < dn; i++) {
+      *bi = *ai;
+	  bi += 2;  
+	  ai += x;
+    }
+}
+
+/* <summary>                             */
+/* Inverse lazy transform (axial).  */
+/* </summary>                            */
+static void dwt_interleave_z(int *a, int *b, int dn, int sn, int xy, int cas) {
+    int i;
+    int *ai = NULL;
+    int *bi = NULL;
+    ai = a;
+    bi = b + cas;
+    for (i = 0; i < sn; i++) {
+      *bi = *ai;  
+	  bi += 2;  
+	  ai += xy;
+    }
+    ai = a + (sn * xy);
+    bi = b + 1 - cas;
+    for (i = 0; i < dn; i++) {
+      *bi = *ai;
+	  bi += 2;
+	  ai += xy;
+    }
+}
+
+
+/* <summary>                            */
+/* Forward 5-3 or 9-7 wavelet tranform in 1-D. */
+/* </summary>                           */
+static void dwt_encode_53(int *a, int dn, int sn, int cas) {
+	int i;
+
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			//for (i = 0; i < dn; i++) D(i) -= (S_(i) + S_(i + 1)) >> 1;
+			//for (i = 0; i < sn; i++) S(i) += (D_(i - 1) + D_(i) + 2) >> 2;
+			for (i = 0; i < dn; i++){
+				D(i) -= (S_(i) + S_(i + 1)) >> 1;
+				//ops += 2;
+			}
+			for (i = 0; i < sn; i++){
+				S(i) += (D_(i - 1) + D_(i) + 2) >> 2;
+				//ops += 3;
+			}
+		}
+	} else {
+		/*if (!sn && dn == 1)
+			S(0) *= 2;
+		else {
+			for (i = 0; i < dn; i++) S(i) -= (DD_(i) + DD_(i - 1)) >> 1;
+			for (i = 0; i < sn; i++) D(i) += (SS_(i) + SS_(i + 1) + 2) >> 2;
+		}*/
+		if (!sn && dn == 1){
+			S(0) *= 2;
+			//ops++;
+		} else {
+			for (i = 0; i < dn; i++){
+				S(i) -= (DD_(i) + DD_(i - 1)) >> 1;
+			//	ops += 2;
+			}
+			for (i = 0; i < sn; i++){
+				D(i) += (SS_(i) + SS_(i + 1) + 2) >> 2;
+			//	ops += 3;
+			}
+		}
+	}
+}
+static void dwt_encode_97(int *a, int dn, int sn, int cas) {
+	int i;
+
+	if (!cas) {
+			if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+				for (i = 0; i < dn; i++)
+					D(i) -= fix_mul(S_(i) + S_(i + 1), 12993);
+				for (i = 0; i < sn; i++)
+					S(i) -= fix_mul(D_(i - 1) + D_(i), 434);
+				for (i = 0; i < dn; i++)
+					D(i) += fix_mul(S_(i) + S_(i + 1), 7233);
+				for (i = 0; i < sn; i++)
+					S(i) += fix_mul(D_(i - 1) + D_(i), 3633);
+				for (i = 0; i < dn; i++)
+					D(i) = fix_mul(D(i), 5038);	/*5038 */
+				for (i = 0; i < sn; i++)
+					S(i) = fix_mul(S(i), 6659);	/*6660 */
+			}
+		} else {
+			if ((sn > 0) || (dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+				for (i = 0; i < dn; i++)
+					S(i) -= fix_mul(DD_(i) + DD_(i - 1), 12993);
+				for (i = 0; i < sn; i++)
+					D(i) -= fix_mul(SS_(i) + SS_(i + 1), 434);
+				for (i = 0; i < dn; i++)
+					S(i) += fix_mul(DD_(i) + DD_(i - 1), 7233);
+				for (i = 0; i < sn; i++)
+					D(i) += fix_mul(SS_(i) + SS_(i + 1), 3633);
+				for (i = 0; i < dn; i++)
+					S(i) = fix_mul(S(i), 5038);	/*5038 */
+				for (i = 0; i < sn; i++)
+					D(i) = fix_mul(D(i), 6659);	/*6660 */
+			}
+		}
+}
+/* <summary>                            */
+/* Inverse 5-3 or 9-7 wavelet tranform in 1-D. */
+/* </summary>                           */ 
+static void dwt_decode_53(int *a, int dn, int sn, int cas) {
+	int i;
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) { /* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < sn; i++) S(i) -= (D_(i - 1) + D_(i) + 2) >> 2;
+			for (i = 0; i < dn; i++) D(i) += (S_(i) + S_(i + 1)) >> 1;
+		}
+	} else {
+		if (!sn  && dn == 1)          /* NEW :  CASE ONE ELEMENT */
+			S(0) /= 2;
+		else {
+			for (i = 0; i < sn; i++) D(i) -= (SS_(i) + SS_(i + 1) + 2) >> 2;
+			for (i = 0; i < dn; i++) S(i) += (DD_(i) + DD_(i - 1)) >> 1;
+		}
+	}
+}
+static void dwt_decode_97(int *a, int dn, int sn, int cas) {
+	int i;
+
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < sn; i++)
+				S(i) = fix_mul(S(i), 10078);	/* 10076 */
+			for (i = 0; i < dn; i++)
+				D(i) = fix_mul(D(i), 13318);	/* 13320 */
+			for (i = 0; i < sn; i++)
+				S(i) -= fix_mul(D_(i - 1) + D_(i), 3633);
+			for (i = 0; i < dn; i++)
+				D(i) -= fix_mul(S_(i) + S_(i + 1), 7233);
+			for (i = 0; i < sn; i++)
+				S(i) += fix_mul(D_(i - 1) + D_(i), 434);
+			for (i = 0; i < dn; i++)
+				D(i) += fix_mul(S_(i) + S_(i + 1), 12994);	/* 12993 */
+		}
+	} else {
+		if ((sn > 0) || (dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < sn; i++)
+				D(i) = fix_mul(D(i), 10078);	/* 10076 */
+			for (i = 0; i < dn; i++)
+				S(i) = fix_mul(S(i), 13318);	/* 13320 */
+			for (i = 0; i < sn; i++)
+				D(i) -= fix_mul(SS_(i) + SS_(i + 1), 3633);
+			for (i = 0; i < dn; i++)
+				S(i) -= fix_mul(DD_(i) + DD_(i - 1), 7233);
+			for (i = 0; i < sn; i++)
+				D(i) += fix_mul(SS_(i) + SS_(i + 1), 434);
+			for (i = 0; i < dn; i++)
+				S(i) += fix_mul(DD_(i) + DD_(i - 1), 12994);	/* 12993 */
+		}
+	}
+}
+
+
+/* <summary>                */
+/* Get norm of arbitrary wavelet transform. */
+/* </summary>               */
+static int upandconv(double *nXPS, double *LPS, int lenXPS, int lenLPS) {
+	/* Perform the convolution of the vectors. */
+	int i,j;
+	double *tmp = (double *)opj_malloc(2*lenXPS * sizeof(double));
+	//Upsample
+	memset(tmp, 0, 2*lenXPS*sizeof(double));
+	for (i = 0; i < lenXPS; i++) {
+		*(tmp + 2*i) = *(nXPS + i);
+		*(nXPS + i) = 0;
+	}
+	//Convolution
+	for (i = 0; i < 2*lenXPS; i++) {
+		for (j = 0; j < lenLPS; j++) {
+			*(nXPS+i+j) = *(nXPS+i+j) + *(tmp + i) * *(LPS + j);
+			//fprintf(stdout,"*(tmp + %d) * *(LPS + %d) = %f * %f \n",i,j,*(tmp + i),*(LPS + j));
+		}
+	}
+	free(tmp);
+	return 2*lenXPS+lenLPS-1;
+}
+
+static double dwt_calc_wtnorms(int orient, int level[3], int dwtid[3], opj_wtfilt_t *wtfiltX,  opj_wtfilt_t *wtfiltY,  opj_wtfilt_t *wtfiltZ) {
+	int i, lenLPS, lenHPS;
+	double	Lx = 0, Ly= 0, Hx= 0, Hy= 0, Lz= 0, Hz= 0;
+	double *nLPSx, *nHPSx,*nLPSy, *nHPSy,*nLPSz, *nHPSz;
+	int levelx, levely, levelz;
+	    
+	levelx = (orient == 0) ? level[0]-1 : level[0];
+	levely = (orient == 0) ? level[1]-1 : level[1];
+	levelz = (orient == 0) ? level[2]-1 : level[2];
+	
+	//X axis
+	lenLPS = wtfiltX->lenLPS;
+	lenHPS = wtfiltX->lenHPS;
+	for (i = 0; i < levelx; i++) {
+		lenLPS *= 2;
+		lenHPS *= 2;
+		lenLPS += wtfiltX->lenLPS - 1;
+		lenHPS += wtfiltX->lenLPS - 1;
+	}
+	nLPSx = (double *)opj_malloc(lenLPS * sizeof(double));
+	nHPSx = (double *)opj_malloc(lenHPS * sizeof(double));
+
+	memcpy(nLPSx, wtfiltX->LPS, wtfiltX->lenLPS * sizeof(double));
+	memcpy(nHPSx, wtfiltX->HPS, wtfiltX->lenHPS * sizeof(double));
+	lenLPS = wtfiltX->lenLPS;
+	lenHPS = wtfiltX->lenHPS;
+	for (i = 0; i < levelx; i++) {
+		lenLPS = upandconv(nLPSx, wtfiltX->LPS, lenLPS, wtfiltX->lenLPS);
+		lenHPS = upandconv(nHPSx, wtfiltX->LPS, lenHPS, wtfiltX->lenLPS);
+	}
+	for (i = 0; i < lenLPS; i++)
+		Lx += nLPSx[i] * nLPSx[i];
+	for (i = 0; i < lenHPS; i++)
+		Hx += nHPSx[i] * nHPSx[i];
+	Lx = sqrt(Lx);
+	Hx = sqrt(Hx);
+	free(nLPSx);
+	free(nHPSx);
+	
+	//Y axis
+	if (dwtid[0] != dwtid[1] || level[0] != level[1]){
+		lenLPS = wtfiltY->lenLPS;
+		lenHPS = wtfiltY->lenHPS;
+		for (i = 0; i < levely; i++) {
+			lenLPS *= 2;
+			lenHPS *= 2;
+			lenLPS += wtfiltY->lenLPS - 1;
+			lenHPS += wtfiltY->lenLPS - 1;
+		}
+		nLPSy = (double *)opj_malloc(lenLPS * sizeof(double));
+		nHPSy = (double *)opj_malloc(lenHPS * sizeof(double));
+
+		memcpy(nLPSy, wtfiltY->LPS, wtfiltY->lenLPS * sizeof(double));
+		memcpy(nHPSy, wtfiltY->HPS, wtfiltY->lenHPS * sizeof(double));
+		lenLPS = wtfiltY->lenLPS;
+		lenHPS = wtfiltY->lenHPS;
+		for (i = 0; i < levely; i++) {
+			lenLPS = upandconv(nLPSy, wtfiltY->LPS, lenLPS, wtfiltY->lenLPS);
+			lenHPS = upandconv(nHPSy, wtfiltY->LPS, lenHPS, wtfiltY->lenLPS);
+		}
+		for (i = 0; i < lenLPS; i++)
+			Ly += nLPSy[i] * nLPSy[i];
+		for (i = 0; i < lenHPS; i++)
+			Hy += nHPSy[i] * nHPSy[i];
+		Ly = sqrt(Ly);
+		Hy = sqrt(Hy);
+		free(nLPSy);
+		free(nHPSy);
+	} else { 
+		Ly = Lx;
+		Hy = Hx;
+	}
+	//Z axis
+	if (levelz >= 0) { 
+		lenLPS = wtfiltZ->lenLPS;
+		lenHPS = wtfiltZ->lenHPS;
+		for (i = 0; i < levelz; i++) {
+			lenLPS *= 2;
+			lenHPS *= 2;
+			lenLPS += wtfiltZ->lenLPS - 1;
+			lenHPS += wtfiltZ->lenLPS - 1;
+		}
+		nLPSz = (double *)opj_malloc(lenLPS * sizeof(double));
+		nHPSz = (double *)opj_malloc(lenHPS * sizeof(double));
+
+		memcpy(nLPSz, wtfiltZ->LPS, wtfiltZ->lenLPS * sizeof(double));
+		memcpy(nHPSz, wtfiltZ->HPS, wtfiltZ->lenHPS * sizeof(double));
+		lenLPS = wtfiltZ->lenLPS;
+		lenHPS = wtfiltZ->lenHPS;
+		for (i = 0; i < levelz; i++) {
+			lenLPS = upandconv(nLPSz, wtfiltZ->LPS, lenLPS, wtfiltZ->lenLPS);
+			lenHPS = upandconv(nHPSz, wtfiltZ->LPS, lenHPS, wtfiltZ->lenLPS);
+		}
+		for (i = 0; i < lenLPS; i++)
+			Lz += nLPSz[i] * nLPSz[i];
+		for (i = 0; i < lenHPS; i++)
+			Hz += nHPSz[i] * nHPSz[i];
+		Lz = sqrt(Lz);
+		Hz = sqrt(Hz);
+		free(nLPSz);
+		free(nHPSz);
+	} else {
+		Lz = 1.0; Hz = 1.0;
+	}
+	switch (orient) {
+		case 0: 
+			return Lx * Ly * Lz;
+		case 1:
+			return Lx * Hy * Lz;
+		case 2:
+			return Hx * Ly * Lz;
+		case 3:
+			return Hx * Hy * Lz;
+		case 4:
+			return Lx * Ly * Hz;
+		case 5:
+			return Lx * Hy * Hz;
+		case 6: 
+			return Hx * Ly * Hz;
+		case 7:
+			return Hx * Hy * Hz;
+		default:
+			return -1;
+	}
+	
+}
+static void dwt_getwtfilters(opj_wtfilt_t *wtfilt, int dwtid) {
+	if (dwtid == 0) { //DWT 9-7 
+			wtfilt->lenLPS = 7;		wtfilt->lenHPS = 9;
+			wtfilt->LPS = (double *)opj_malloc(wtfilt->lenLPS * sizeof(double));
+			wtfilt->HPS = (double *)opj_malloc(wtfilt->lenHPS * sizeof(double));
+			wtfilt->LPS[0] = -0.091271763114;	wtfilt->HPS[0] = 0.026748757411;
+			wtfilt->LPS[1] = -0.057543526228;	wtfilt->HPS[1] = 0.016864118443;
+			wtfilt->LPS[2] = 0.591271763114;	wtfilt->HPS[2] = -0.078223266529;
+			wtfilt->LPS[3] = 1.115087052457;	wtfilt->HPS[3] = -0.266864118443;
+			wtfilt->LPS[4] = 0.591271763114;	wtfilt->HPS[4] = 0.602949018236;
+			wtfilt->LPS[5] = -0.057543526228;	wtfilt->HPS[5] = -0.266864118443;
+			wtfilt->LPS[6] = -0.091271763114;	wtfilt->HPS[6] = -0.078223266529;
+												wtfilt->HPS[7] = 0.016864118443;
+												wtfilt->HPS[8] = 0.026748757411;			
+	} else if (dwtid == 1) { //DWT 5-3 
+			wtfilt->lenLPS = 3;		wtfilt->lenHPS = 5;
+			wtfilt->LPS = (double *)opj_malloc(wtfilt->lenLPS * sizeof(double));
+			wtfilt->HPS = (double *)opj_malloc(wtfilt->lenHPS * sizeof(double));
+			wtfilt->LPS[0] = 0.5;	wtfilt->HPS[0] = -0.125; 
+			wtfilt->LPS[1] = 1;		wtfilt->HPS[1] = -0.25; 
+			wtfilt->LPS[2] = 0.5;	wtfilt->HPS[2] = 0.75;
+									wtfilt->HPS[3] = -0.25; 
+									wtfilt->HPS[4] = -0.125;
+	} else {
+		fprintf(stdout,"[ERROR] Sorry, this wavelet hasn't been implemented so far ... Try another one :-)\n");
+		exit(1);
+	}
+}
+/* <summary>                            */
+/* Encoding of quantization stepsize for each subband. */
+/* </summary>                           */ 
+static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
+	int p, n;
+	p = int_floorlog2(stepsize) - 13;
+	n = 11 - int_floorlog2(stepsize);
+	bandno_stepsize->mant = (n < 0 ? stepsize >> -n : stepsize << n) & 0x7ff;
+	bandno_stepsize->expn = numbps - p;
+	//if J3D_CCP_QNTSTY_NOQNT --> stepsize = 8192.0 --> p = 0, n = -2 --> mant = 0; expn = (prec+gain)
+	//else --> bandno_stepsize = (1<<(numbps - expn)) + (1<<(numbps - expn - 11)) * Ub
+}
+
+/* 
+==========================================================
+   DWT interface
+==========================================================
+*/
+/* <summary>                            */
+/* Forward 5-3 wavelet tranform in 3-D. */
+/* </summary>                           */
+void dwt_encode(opj_tcd_tilecomp_t * tilec, int dwtid[3]) {
+	int i, j, k;
+	int x, y, z;
+	int w, h, wh, d;
+	int level,levelx,levely,levelz,diff;
+	int *a = NULL;
+	int *aj = NULL;
+	int *bj = NULL;
+	int *cj = NULL;
+	
+	ops = 0;
+
+	memset(flagnorm,0,8000*sizeof(int));
+	w = tilec->x1-tilec->x0;
+	h = tilec->y1-tilec->y0;
+	d = tilec->z1-tilec->z0;
+	wh = w * h;
+	levelx = tilec->numresolution[0]-1;
+	levely = tilec->numresolution[1]-1;
+	levelz = tilec->numresolution[2]-1;
+	level = int_max(levelx,int_max(levely,levelz));
+	diff = tilec->numresolution[0] - tilec->numresolution[2];
+
+	a = tilec->data;
+
+	for (x = 0, y = 0, z = 0; x < levelx, y < levely; x++, y++, z++) {
+		int rw;			/* width of the resolution level computed                                                           */
+		int rh;			/* heigth of the resolution level computed                                                          */
+		int rd;			/* depth of the resolution level computed                                                          */
+		int rw1;		/* width of the resolution level once lower than computed one                                       */
+		int rh1;		/* height of the resolution level once lower than computed one                                      */
+		int rd1;		/* depth of the resolution level once lower than computed one                                      */
+		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		int cas_axl;	/* 0 = non inversion on axial filtering 1 = inversion between low-pass and high-pass filtering   */
+		int dn, sn;
+		
+		rw = tilec->resolutions[level - x].x1 - tilec->resolutions[level - x].x0;
+		rh = tilec->resolutions[level - y].y1 - tilec->resolutions[level - y].y0;
+		rd = tilec->resolutions[level - z].z1 - tilec->resolutions[level - z].z0;
+		rw1= tilec->resolutions[level - x - 1].x1 - tilec->resolutions[level - x - 1].x0;
+		rh1= tilec->resolutions[level - y - 1].y1 - tilec->resolutions[level - y - 1].y0;
+		rd1= tilec->resolutions[level - z - 1].z1 - tilec->resolutions[level - z - 1].z0;
+		
+		cas_col = tilec->resolutions[level - x].x0 % 2; /* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		cas_row = tilec->resolutions[level - y].y0 % 2; /* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		cas_axl = tilec->resolutions[level - z].z0 % 2;
+	
+		/*fprintf(stdout," x %d y %d z %d \n",x,y,z);
+		fprintf(stdout," levelx %d levely %d levelz %d \n",levelx,levely,levelz);
+		fprintf(stdout," z1 %d z0 %d\n",tilec->resolutions[level - z].z1,tilec->resolutions[level - z].z0);
+		fprintf(stdout," rw %d rh %d rd %d \n rw1 %d rh1 %d rd1 %d \n",rw,rh,rd,rw1,rh1,rd1);*/
+
+		for (i = 0; i < rd; i++) {
+			
+			cj = a + (i * wh);
+			
+			//Horizontal
+			sn = rw1;
+			dn = rw - rw1;
+			bj = (int*)opj_malloc(rw * sizeof(int));
+			if (dwtid[0] == 0) {
+				for (j = 0; j < rh; j++) {
+					aj = cj + j * w;
+					for (k = 0; k < rw; k++)  bj[k] = aj[k];
+					dwt_encode_97(bj, dn, sn, cas_row);
+					dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
+				}
+			} else if (dwtid[0] == 1) {
+				for (j = 0; j < rh; j++) {
+					aj = cj + j * w;
+					for (k = 0; k < rw; k++)  bj[k] = aj[k];
+					dwt_encode_53(bj, dn, sn, cas_row);
+					dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
+				}
+			} 
+			opj_free(bj);
+
+			//Vertical
+			sn = rh1;
+			dn = rh - rh1;
+			bj = (int*)opj_malloc(rh * sizeof(int));
+			if (dwtid[1] == 0) { /*DWT 9-7*/
+				for (j = 0; j < rw; j++) {
+					aj = cj + j;
+					for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
+					dwt_encode_97(bj, dn, sn, cas_col);
+					dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
+				}
+            } else if (dwtid[1] == 1) { /*DWT 5-3*/
+				for (j = 0; j < rw; j++) {
+					aj = cj + j;
+					for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
+					dwt_encode_53(bj, dn, sn, cas_col);
+					dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
+				}
+			} 
+			opj_free(bj);
+		}
+
+		if (z < levelz){
+			//Axial fprintf(stdout,"Axial DWT Transform %d %d %d\n",z,rd,rd1);
+			sn = rd1;
+			dn = rd - rd1;
+			bj = (int*)opj_malloc(rd * sizeof(int));
+			if (dwtid[2] == 0) {
+                for (j = 0; j < (rw*rh); j++) {
+					aj = a + j;
+					for (k = 0; k < rd; k++)  bj[k] = aj[k*wh];
+					dwt_encode_97(bj, dn, sn, cas_axl);
+					dwt_deinterleave_z(bj, aj, dn, sn, wh, cas_axl);
+				}
+			} else if (dwtid[2] == 1) {
+				for (j = 0; j < (rw*rh); j++) {
+					aj = a + j;
+					for (k = 0; k < rd; k++)  bj[k] = aj[k*wh];
+					dwt_encode_53(bj, dn, sn, cas_axl);
+					dwt_deinterleave_z(bj, aj, dn, sn, wh, cas_axl);
+				}
+			} 
+			opj_free(bj);
+		}
+	}
+
+	//fprintf(stdout,"[INFO] Ops: %d \n",ops);
+}
+
+
+/* <summary>                            */
+/* Inverse 5-3 wavelet tranform in 3-D. */
+/* </summary>                           */
+void dwt_decode(opj_tcd_tilecomp_t * tilec, int stops[3], int dwtid[3]) {
+	int i, j, k;
+	int x, y, z;
+	int w, h, wh, d;
+	int level, levelx, levely, levelz, diff;
+	int *a = NULL;
+	int *aj = NULL;
+	int *bj = NULL;
+	int *cj = NULL;
+	
+	a = tilec->data;
+
+	w = tilec->x1-tilec->x0;
+	h = tilec->y1-tilec->y0;
+	d = tilec->z1-tilec->z0;
+	wh = w * h;
+	levelx = tilec->numresolution[0]-1;
+	levely = tilec->numresolution[1]-1;
+	levelz = tilec->numresolution[2]-1;
+	level = int_max(levelx,int_max(levely,levelz));
+	diff = tilec->numresolution[0] - tilec->numresolution[2];
+		
+/* General lifting framework -- DCCS-LIWT */
+	for (x = level - 1, y = level - 1, z = level - 1; x >= stops[0], y >= stops[1]; x--, y--, z--) {
+		int rw;			/* width of the resolution level computed                                                           */
+		int rh;			/* heigth of the resolution level computed                                                          */
+		int rd;			/* depth of the resolution level computed                                                          */
+		int rw1;		/* width of the resolution level once lower than computed one                                       */
+		int rh1;		/* height of the resolution level once lower than computed one                                      */
+		int rd1;		/* depth of the resolution level once lower than computed one                                      */
+		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		int cas_axl;	/* 0 = non inversion on axial filtering 1 = inversion between low-pass and high-pass filtering   */
+		int dn, sn;
+		
+		rw = tilec->resolutions[level - x].x1 - tilec->resolutions[level - x].x0;
+		rh = tilec->resolutions[level - y].y1 - tilec->resolutions[level - y].y0;
+		rd = tilec->resolutions[level - z].z1 - tilec->resolutions[level - z].z0;
+		rw1= tilec->resolutions[level - x - 1].x1 - tilec->resolutions[level - x - 1].x0;
+		rh1= tilec->resolutions[level - y - 1].y1 - tilec->resolutions[level - y - 1].y0;
+		rd1= tilec->resolutions[level - z - 1].z1 - tilec->resolutions[level - z - 1].z0;
+		
+		cas_col = tilec->resolutions[level - x].x0 % 2; /* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		cas_row = tilec->resolutions[level - y].y0 % 2; /* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		cas_axl = tilec->resolutions[level - z].z0 % 2;
+	
+		/*fprintf(stdout," x %d y %d z %d \n",x,y,z);
+		fprintf(stdout," levelx %d levely %d levelz %d \n",levelx,levely,levelz);
+		fprintf(stdout," dwtid[0] %d [1] %d [2] %d \n",dwtid[0],dwtid[1],dwtid[2]);
+		fprintf(stdout," rw %d rh %d rd %d \n rw1 %d rh1 %d rd1 %d \n",rw,rh,rd,rw1,rh1,rd1);
+		fprintf(stdout,"IDWT Transform %d %d %d %d\n",level, z, rd,rd1);*/
+
+		if (z >= stops[2] && rd != rd1) {
+			//fprintf(stdout,"Axial Transform %d %d %d %d\n",levelz, z, rd,rd1);
+			sn = rd1;
+			dn = rd - rd1;
+			bj = (int*)opj_malloc(rd * sizeof(int));
+			if (dwtid[2] == 0) {
+				for (j = 0; j < (rw*rh); j++) {
+					aj = a + j;
+					dwt_interleave_z(aj, bj, dn, sn, wh, cas_axl);
+					dwt_decode_97(bj, dn, sn, cas_axl);
+					for (k = 0; k < rd; k++)  aj[k * wh] = bj[k];
+				}
+			} else if (dwtid[2] == 1) {
+				for (j = 0; j < (rw*rh); j++) {
+					aj = a + j;
+					dwt_interleave_z(aj, bj, dn, sn, wh, cas_axl);
+					dwt_decode_53(bj, dn, sn, cas_axl);
+					for (k = 0; k < rd; k++)  aj[k * wh] = bj[k];
+				}
+			} 
+			opj_free(bj);
+		}
+
+		for (i = 0; i < rd; i++) {
+			//Fetch corresponding slice for doing DWT-2D
+ 			cj = tilec->data + (i * wh);
+			
+			//Vertical
+			sn = rh1;
+			dn = rh - rh1;
+			bj = (int*)opj_malloc(rh * sizeof(int));
+			if (dwtid[1] == 0) {
+				for (j = 0; j < rw; j++) {
+					aj = cj + j;
+					dwt_interleave_v(aj, bj, dn, sn, w, cas_col);
+					dwt_decode_97(bj, dn, sn, cas_col);
+					for (k = 0; k < rh; k++)  aj[k * w] = bj[k];
+				}
+			} else if (dwtid[1] == 1) {
+				for (j = 0; j < rw; j++) {
+					aj = cj + j;
+					dwt_interleave_v(aj, bj, dn, sn, w, cas_col);
+					dwt_decode_53(bj, dn, sn, cas_col);
+					for (k = 0; k < rh; k++)  aj[k * w] = bj[k];
+				}
+			} 
+			opj_free(bj);
+
+			//Horizontal
+			sn = rw1;
+			dn = rw - rw1;
+			bj = (int*)opj_malloc(rw * sizeof(int));
+			if (dwtid[0]==0) {
+				for (j = 0; j < rh; j++) {
+					aj = cj + j*w;
+					dwt_interleave_h(aj, bj, dn, sn, cas_row);
+					dwt_decode_97(bj, dn, sn, cas_row);
+					for (k = 0; k < rw; k++)  aj[k] = bj[k];
+				}
+			} else if (dwtid[0]==1) {
+				for (j = 0; j < rh; j++) {
+					aj = cj + j*w;
+					dwt_interleave_h(aj, bj, dn, sn, cas_row);
+					dwt_decode_53(bj, dn, sn, cas_row);
+					for (k = 0; k < rw; k++)  aj[k] = bj[k];
+				}
+			} 
+			opj_free(bj);
+			
+		}
+	
+	}
+
+}
+
+
+/* <summary>                          */
+/* Get gain of wavelet transform. */
+/* </summary>                         */
+int dwt_getgain(int orient, int reversible) {
+	if (reversible == 1) { 
+		if (orient == 0)
+			return 0;
+		else if (orient == 1 || orient == 2 || orient == 4 )
+			return 1;
+		else if (orient == 3 || orient == 5 || orient == 6 )
+			return 2;
+		else 
+			return 3;
+	}
+	//else if (reversible == 0){
+	return 0;
+}
+
+/* <summary>                */
+/* Get norm of wavelet transform. */
+/* </summary>               */
+double dwt_getnorm(int orient, int level[3], int dwtid[3]) {
+	int levelx = level[0];
+	int levely = level[1];
+	int levelz = (level[2] < 0) ? 0 : level[2];
+	double norm;
+
+	if (flagnorm[levelx][levely][levelz][orient] == 1) {
+		norm = dwt_norm[levelx][levely][levelz][orient];
+		//fprintf(stdout,"[INFO] Level: %d %d %d Orient %d Dwt_norm: %f \n",level[0],level[1],level[2],orient,norm);
+	} else {
+		opj_wtfilt_t *wtfiltx =(opj_wtfilt_t *) opj_malloc(sizeof(opj_wtfilt_t));
+		opj_wtfilt_t *wtfilty =(opj_wtfilt_t *) opj_malloc(sizeof(opj_wtfilt_t));
+		opj_wtfilt_t *wtfiltz =(opj_wtfilt_t *) opj_malloc(sizeof(opj_wtfilt_t));
+		//Fetch equivalent filters for each dimension
+		dwt_getwtfilters(wtfiltx, dwtid[0]);
+		dwt_getwtfilters(wtfilty, dwtid[1]);
+		dwt_getwtfilters(wtfiltz, dwtid[2]);
+		//Calculate the corresponding norm 
+		norm = dwt_calc_wtnorms(orient, level, dwtid, wtfiltx, wtfilty, wtfiltz);
+		//Save norm in array (no recalculation)
+		dwt_norm[levelx][levely][levelz][orient] = norm;
+		flagnorm[levelx][levely][levelz][orient] = 1;
+		//Free reserved space
+		opj_free(wtfiltx->LPS);	opj_free(wtfilty->LPS);	opj_free(wtfiltz->LPS);
+		opj_free(wtfiltx->HPS);	opj_free(wtfilty->HPS);	opj_free(wtfiltz->HPS);
+		opj_free(wtfiltx);		opj_free(wtfilty);		opj_free(wtfiltz);
+		//fprintf(stdout,"[INFO] Dwtid: %d %d %d Level: %d %d %d Orient %d Norm: %f \n",dwtid[0],dwtid[1],dwtid[2],level[0],level[1],level[2],orient,norm);
+	} 
+	return norm;
+}
+/* <summary>								*/
+/* Calculate explicit stepsizes for DWT.	*/
+/* </summary>								*/
+void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec) { 
+	int totnumbands, bandno, diff;
+	
+	assert(tccp->numresolution[0] >= tccp->numresolution[2]);	
+	diff = tccp->numresolution[0] - tccp->numresolution[2];		/*if RESx=RESy != RESz */
+	totnumbands = (7 * tccp->numresolution[0] - 6) - 4 * diff; /* 3-D */
+		
+	for (bandno = 0; bandno < totnumbands; bandno++) {
+		double stepsize;
+		int resno, level[3], orient, gain;
+
+		/* Bandno:	0 - LLL 	1 - LHL 
+					2 - HLL		3 - HHL
+					4 - LLH		5 - LHH
+					6 - HLH		7 - HHH	*/
+
+		resno = (bandno == 0) ? 0 : ( (bandno <= 3 * diff) ? ((bandno - 1) / 3 + 1) : ((bandno + 4*diff - 1) / 7 + 1));
+		orient = (bandno == 0) ? 0 : ( (bandno <= 3 * diff) ? ((bandno - 1) % 3 + 1) : ((bandno + 4*diff - 1) % 7 + 1));
+		level[0] = tccp->numresolution[0] - 1 - resno;
+		level[1] = tccp->numresolution[1] - 1 - resno;
+		level[2] = tccp->numresolution[2] - 1 - resno;
+	
+		/* Gain:	0 - LLL 	1 - LHL 
+					1 - HLL		2 - HHL
+					1 - LLH		2 - LHH
+					2 - HLH		3 - HHH		*/
+		gain = (tccp->reversible == 0) ? 0 : ( (orient == 0) ? 0 : 
+				( ((orient == 1) || (orient == 2) || (orient == 4)) ? 1 : 
+						(((orient == 3) || (orient == 5) || (orient == 6)) ? 2 : 3)) );
+				
+		if (tccp->qntsty == J3D_CCP_QNTSTY_NOQNT) {
+			stepsize = 1.0;
+		} else {
+			double norm = dwt_getnorm(orient,level,tccp->dwtid); //Fetch norms if irreversible transform (by the moment only I9.7)
+			stepsize = (1 << (gain + 1)) / norm;
+		}
+		//fprintf(stdout,"[INFO] Bandno: %d Orient: %d Level: %d %d %d Stepsize: %f\n",bandno,orient,level[0],level[1],level[2],stepsize);
+		dwt_encode_stepsize((int) floor(stepsize * 8192.0), prec + gain, &tccp->stepsizes[bandno]);
+	}
+}
+
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/dwt.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/dwt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/dwt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/dwt.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyrigth (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DWT_H
+#define __DWT_H
+/**
+@file dwt.h
+@brief Implementation of a discrete wavelet transform (DWT)
+
+The functions in DWT.C have for goal to realize forward and inverse discret wavelet
+transform with filter 5-3 (reversible) and filter 9-7 (irreversible). The functions in
+DWT.C are used by some function in TCD.C.
+*/
+
+/** @defgroup DWT DWT - Implementation of a discrete wavelet transform */
+/*@{*/
+
+/**
+DCCS-LIWT properties
+*/
+
+
+typedef struct opj_wtfilt {
+	double *LPS;
+	int lenLPS;
+	double *HPS;
+	int lenHPS;
+} opj_wtfilt_t;
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Forward 5-3 wavelet tranform in 3-D. 
+Apply a reversible DWT transform to a component of an volume.
+@param tilec Tile component information (current tile)
+@param dwtid Number of identification of wavelet kernel(s) used in DWT in each direction
+*/
+void dwt_encode(opj_tcd_tilecomp_t * tilec, int dwtid[3]);
+/**
+Inverse 5-3 wavelet tranform in 3-D.
+Apply a reversible inverse DWT transform to a component of an volume.
+@param tilec Tile component information (current tile)
+@param stops Number of decoded resolution levels in each dimension
+@param dwtid Number of identification of wavelet kernel(s) used in DWT in each dimension
+*/
+void dwt_decode(opj_tcd_tilecomp_t * tilec, int stops[3], int dwtid[3]);
+/* ----------------------------------------------------------------------- */
+/**
+Get the gain of a subband for the reversible 3-D DWT.
+@param orient Number that identifies the subband (0->LLL, 1->HLL, 2->LHL, 3->HHL, 4->LLH, 5->HLH, 6->LHH, 7->HHH)
+@param reversible Wavelet transformation type
+@return Returns 0 if orient = 0, returns 1 if orient = 1,2 or 4, returns 2 if orient = 3,5 or 6, returns 3 otherwise
+*/
+int dwt_getgain(int orient, int reversible);
+/**
+Get the norm of a wavelet function of a subband at a specified level for the reversible 5-3 DWT or irreversible 9-7 in 3-D.
+@param orient Band of the wavelet function
+@param level Levels of the wavelet function in X,Y,Z axis
+@param dwtid Wavelet transformation identifier
+@return Returns the norm of the wavelet function
+*/
+double dwt_getnorm(int orient, int level[3], int dwtid[3]);
+/* ----------------------------------------------------------------------- */
+/**
+Calcula el valor del escalón de cuantificación correspondiente a cada subbanda.
+@param tccp Tile component coding parameters
+@param prec Precision of data
+*/
+void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
+/*@}*/
+
+#endif /* __DWT_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/event.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/event.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/event.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/event.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,181 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+// ==========================================================
+//   Utility functions
+// ==========================================================
+
+#ifndef WIN32
+static char*
+i2a(unsigned i, char *a, unsigned r) {
+	if (i/r > 0) a = i2a(i/r,a,r);
+	*a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i%r];
+	return a+1;
+}
+
+/** 
+ Transforms integer i into an ascii string and stores the result in a; 
+ string is encoded in the base indicated by r.
+ @param i Number to be converted
+ @param a String result
+ @param r Base of value; must be in the range 2 - 36
+ @return Returns a
+*/
+static char *
+_itoa(int i, char *a, int r) {
+	r = ((r < 2) || (r > 36)) ? 10 : r;
+	if(i < 0) {
+		*a = '-';
+		*i2a(-i, a+1, r) = 0;
+	}
+	else *i2a(i, a, r) = 0;
+	return a;
+}
+
+#endif // !WIN32
+
+/* ----------------------------------------------------------------------- */
+
+opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context) {
+	if(cinfo) {
+		opj_event_mgr_t *previous = cinfo->event_mgr;
+		cinfo->event_mgr = event_mgr;
+		cinfo->client_data = context;
+		return previous;
+	}
+
+	return NULL;
+}
+
+bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...) {
+#define MSG_SIZE 512 /* 512 bytes should be more than enough for a short message */
+	opj_msg_callback msg_handler = NULL;
+
+	opj_event_mgr_t *event_mgr = cinfo->event_mgr;
+	if(event_mgr != NULL) {
+		switch(event_type) {
+			case EVT_ERROR:
+				msg_handler = event_mgr->error_handler;
+				break;
+			case EVT_WARNING:
+				msg_handler = event_mgr->warning_handler;
+				break;
+			case EVT_INFO:
+				msg_handler = event_mgr->info_handler;
+				break;
+			default:
+				break;
+		}
+		if(msg_handler == NULL) {
+			return false;
+		}
+	} else {
+		return false;
+	}
+
+	if ((fmt != NULL) && (event_mgr != NULL)) {
+		va_list arg;
+		int str_length, i, j;
+		char message[MSG_SIZE];
+		memset(message, 0, MSG_SIZE);
+		/* initialize the optional parameter list */
+		va_start(arg, fmt);
+		/* check the length of the format string */
+		str_length = (strlen(fmt) > MSG_SIZE) ? MSG_SIZE : strlen(fmt);
+		/* parse the format string and put the result in 'message' */
+		for (i = 0, j = 0; i < str_length; ++i) {
+			if (fmt[i] == '%') {
+				if (i + 1 < str_length) {
+					switch(tolower(fmt[i + 1])) {
+						case '%' :
+							message[j++] = '%';
+							break;
+						case 'o' : /* octal numbers */
+						{
+							char tmp[16];
+							_itoa(va_arg(arg, int), tmp, 8);
+							strcat(message, tmp);
+							j += strlen(tmp);
+							++i;
+							break;
+						}
+						case 'i' : /* decimal numbers */
+						case 'd' :
+						{
+							char tmp[16];
+							_itoa(va_arg(arg, int), tmp, 10);
+							strcat(message, tmp);
+							j += strlen(tmp);
+							++i;
+							break;
+						}
+						case 'x' : /* hexadecimal numbers */
+						{
+							char tmp[16];
+							_itoa(va_arg(arg, int), tmp, 16);
+							strcat(message, tmp);
+							j += strlen(tmp);
+							++i;
+							break;
+						}
+						case 's' : /* strings */
+						{
+							char *tmp = va_arg(arg, char*);
+							strcat(message, tmp);
+							j += strlen(tmp);
+							++i;
+							break;
+						}
+						case 'f' :	/* floats */
+						{
+							char tmp[16];
+							double value = va_arg(arg, double);
+							sprintf(tmp, "%f", value);
+							strcat(message, tmp);
+							j += strlen(tmp);
+							++i;
+							break;
+						}
+					};
+				} else {
+					message[j++] = fmt[i];
+				}
+			} else {
+				message[j++] = fmt[i];
+			};
+		}
+		/* deinitialize the optional parameter list */
+		va_end(arg);
+
+		/* output the message to the user program */
+		msg_handler(message, cinfo->client_data);
+	}
+
+	return true;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/event.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/event.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/event.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/event.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __EVENT_H
+#define __EVENT_H
+/**
+@file event.h
+@brief Implementation of a event callback system
+
+The functions in EVENT.C have for goal to send output messages (errors, warnings, debug) to the user.
+*/
+
+#define EVT_ERROR	1	/**< Error event type */
+#define EVT_WARNING	2	/**< Warning event type */
+#define EVT_INFO	4	/**< Debug event type */
+
+/** @defgroup EVENT EVENT - Implementation of a event callback system */
+/*@{*/
+
+/** @name Funciones generales (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Write formatted data to a string and send the string to a user callback. 
+@param cinfo Codec context info
+@param event_type Event type or callback to use to send the message
+@param fmt Format-control string (plus optionnal arguments)
+@return Returns true if successful, returns false otherwise
+*/
+bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __EVENT_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/fix.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/fix.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,62 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FIX_H
+#define __FIX_H
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+#define int64 __int64
+#else
+#define int64 long long
+#endif
+
+/**
+@file fix.h
+@brief Implementation of operations of specific multiplication (FIX)
+
+The functions in FIX.H have for goal to realize specific multiplication.
+*/
+
+/** @defgroup FIX FIX - Implementation of operations of specific multiplication */
+/*@{*/
+
+/**
+Multiply two fixed-precision rational numbers.
+@param a
+@param b
+@return Returns a * b
+*/
+static  int fix_mul(int a, int b) {
+    int64 temp = (int64) a * (int64) b >> 12;
+    return (int) ((temp >> 1) + (temp & 1)) ;
+}
+
+/*@}*/
+
+#endif /* __FIX_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/int.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/int.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/int.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,122 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __INT_H
+#define __INT_H
+/**
+@file int.h
+@brief Implementation of operations on integers (INT)
+
+The functions in INT.H have for goal to realize operations on integers.
+*/
+
+/** @defgroup INT INT - Implementation of operations on integers */
+/*@{*/
+
+/** @name Funciones generales (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Get the minimum of two integers
+@return Returns a if a < b else b
+*/
+static  int int_min(int a, int b) {
+	return a < b ? a : b;
+}
+/**
+Get the maximum of two integers
+@return Returns a if a > b else b
+*/
+static  int int_max(int a, int b) {
+	return (a > b) ? a : b;
+}
+/**
+Clamp an integer inside an interval
+@return
+<ul>
+<li>Returns a if (min < a < max)
+<li>Returns max if (a > max)
+<li>Returns min if (a < min) 
+</ul>
+*/
+static int int_clamp(int a, int min, int max) {
+	if (a < min)
+		return min;
+	if (a > max)
+		return max;
+	return a;
+}
+/**
+@return Get absolute value of integer
+*/
+static  int int_abs(int a) {
+	return a < 0 ? -a : a;
+}
+
+static double dbl_abs(double a) {
+	return a < 0 ? -a : a;
+}
+/**
+Divide an integer and round upwards
+@return Returns a divided by b
+*/
+static  int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+/**
+Divide an integer by a power of 2 and round upwards
+@return Returns a divided by 2^b
+*/
+static  int int_ceildivpow2(int a, int b) {
+	return (a + (1 << b) - 1) >> b;
+}
+/**
+Divide an integer by a power of 2 and round downwards
+@return Returns a divided by 2^b
+*/
+static  int int_floordivpow2(int a, int b) {
+	return a >> b;
+}
+/**
+Get logarithm of an integer and round downwards
+@return Returns log2(a)
+*/
+static  int int_floorlog2(int a) {
+	int l;
+	for (l = 0; a > 1; l++) {
+		a >>= 1;
+	}
+	return l;
+}
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/jp3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/jp3d.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,2328 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup J3D J3D - JPEG-2000 PART 10 codestream reader/writer */
+/*@{*/
+
+/** @name Funciones locales */
+/*@{*/
+
+/**
+Write the SOC marker (Start Of Codestream)
+@param j3d J3D handle
+*/
+static void j3d_write_soc(opj_j3d_t *j3d);
+/**
+Read the SOC marker (Start of Codestream)
+@param j3d J3D handle
+*/
+static void j3d_read_soc(opj_j3d_t *j3d);
+/**
+Write the SIZ marker (2D volume and tile size)
+@param j3d J3D handle
+*/
+static void j3d_write_siz(opj_j3d_t *j3d);
+/**
+Read the SIZ marker (2D volume and tile size)
+@param j3d J3D handle
+*/
+static void j3d_read_siz(opj_j3d_t *j3d);
+/**
+Write the ZSI marker (3rd volume and tile size)
+@param j3d J3D handle
+*/
+static void j3d_write_zsi(opj_j3d_t *j3d);
+/**
+Read the ZSI marker (3rd volume and tile size)
+@param j3d J3D handle
+*/
+static void j3d_read_zsi(opj_j3d_t *j3d);
+/**
+Write the COM marker (comment)
+@param j3d J3D handle
+*/
+static void j3d_write_com(opj_j3d_t *j3d);
+/**
+Read the COM marker (comment)
+@param j3d J3D handle
+*/
+static void j3d_read_com(opj_j3d_t *j3d);
+/**
+Write the value concerning the specified component in the marker COD and COC
+@param j3d J3D handle
+@param compno Number of the component concerned by the information written
+*/
+static void j3d_write_cox(opj_j3d_t *j3d, int compno);
+/**
+Read the value concerning the specified component in the marker COD and COC
+@param j3d J3D handle
+@param compno Number of the component concerned by the information read
+*/
+static void j3d_read_cox(opj_j3d_t *j3d, int compno);
+/**
+Write the COD marker (coding style default)
+@param j3d J3D handle
+*/
+static void j3d_write_cod(opj_j3d_t *j3d);
+/**
+Read the COD marker (coding style default)
+@param j3d J3D handle
+*/
+static void j3d_read_cod(opj_j3d_t *j3d);
+/**
+Write the COC marker (coding style component)
+@param j3d J3D handle
+@param compno Number of the component concerned by the information written
+*/
+static void j3d_write_coc(opj_j3d_t *j3d, int compno);
+/**
+Read the COC marker (coding style component)
+@param j3d J3D handle
+*/
+static void j3d_read_coc(opj_j3d_t *j3d);
+/**
+Write the value concerning the specified component in the marker QCD and QCC
+@param j3d J3D handle
+@param compno Number of the component concerned by the information written
+*/
+static void j3d_write_qcx(opj_j3d_t *j3d, int compno);
+/**
+Read the value concerning the specified component in the marker QCD and QCC
+@param j3d J3D handle
+@param compno Number of the component concern by the information read
+@param len Length of the information in the QCX part of the marker QCD/QCC
+*/
+static void j3d_read_qcx(opj_j3d_t *j3d, int compno, int len);
+/**
+Write the QCD marker (quantization default)
+@param j3d J3D handle
+*/
+static void j3d_write_qcd(opj_j3d_t *j3d);
+/**
+Read the QCD marker (quantization default)
+@param j3d J3D handle
+*/
+static void j3d_read_qcd(opj_j3d_t *j3d);
+/**
+Write the QCC marker (quantization component)
+@param j3d J3D handle
+@param compno Number of the component concerned by the information written
+*/
+static void j3d_write_qcc(opj_j3d_t *j3d, int compno);
+/**
+Read the QCC marker (quantization component)
+@param j3d J3D handle
+*/
+static void j3d_read_qcc(opj_j3d_t *j3d);
+/**
+Write the POC marker (progression order change)
+@param j3d J3D handle
+*/
+static void j3d_write_poc(opj_j3d_t *j3d);
+/**
+Read the POC marker (progression order change)
+@param j3d J3D handle
+*/
+static void j3d_read_poc(opj_j3d_t *j3d);
+/**
+Read the CRG marker (component registration)
+@param j3d J3D handle
+*/
+static void j3d_read_crg(opj_j3d_t *j3d);
+/**
+Read the TLM marker (tile-part lengths)
+@param j3d J3D handle
+*/
+static void j3d_read_tlm(opj_j3d_t *j3d);
+/**
+Read the PLM marker (packet length, main header)
+@param j3d J3D handle
+*/
+static void j3d_read_plm(opj_j3d_t *j3d);
+/**
+Read the PLT marker (packet length, tile-part header)
+@param j3d J3D handle
+*/
+static void j3d_read_plt(opj_j3d_t *j3d);
+/**
+Read the PPM marker (packet packet headers, main header)
+@param j3d J3D handle
+*/
+static void j3d_read_ppm(opj_j3d_t *j3d);
+/**
+Read the PPT marker (packet packet headers, tile-part header)
+@param j3d J3D handle
+*/
+static void j3d_read_ppt(opj_j3d_t *j3d);
+/**
+Write the SOT marker (start of tile-part)
+@param j3d J3D handle
+*/
+static void j3d_write_sot(opj_j3d_t *j3d);
+/**
+Read the SOT marker (start of tile-part)
+@param j3d J3D handle
+*/
+static void j3d_read_sot(opj_j3d_t *j3d);
+/**
+Write the SOD marker (start of data)
+@param j3d J3D handle
+@param tile_coder Pointer to a TCD handle
+*/
+static void j3d_write_sod(opj_j3d_t *j3d, void *tile_coder);
+/**
+Read the SOD marker (start of data)
+@param j3d J3D handle
+*/
+static void j3d_read_sod(opj_j3d_t *j3d);
+/**
+Write the RGN marker (region-of-interest)
+@param j3d J3D handle
+@param compno Number of the component concerned by the information written
+@param tileno Number of the tile concerned by the information written
+*/
+static void j3d_write_rgn(opj_j3d_t *j3d, int compno, int tileno);
+/**
+Read the RGN marker (region-of-interest)
+@param j3d J3D handle
+*/
+static void j3d_read_rgn(opj_j3d_t *j3d);
+/**
+Write the EOC marker (end of codestream)
+@param j3d J3D handle
+*/
+static void j3d_write_eoc(opj_j3d_t *j3d);
+/**
+Read the EOC marker (end of codestream)
+@param j3d J3D handle
+*/
+static void j3d_read_eoc(opj_j3d_t *j3d);
+/**
+Read an unknown marker
+@param j3d J3D handle
+*/
+static void j3d_read_unk(opj_j3d_t *j3d);
+/**
+Write the CAP marker (extended capabilities)
+@param j3d J3D handle
+*/
+static void j3d_write_cap(opj_j3d_t *j3d);
+/**
+Read the CAP marker (extended capabilities)
+@param j3d J3D handle
+*/
+static void j3d_read_cap(opj_j3d_t *j3d);
+/**
+Write the DCO marker (Variable DC offset)
+@param j3d J3D handle
+*/
+static void j3d_write_dco(opj_j3d_t *j3d);
+/**
+Read the DCO marker (Variable DC offset)
+@param j3d J3D handle
+*/
+static void j3d_read_dco(opj_j3d_t *j3d);
+/**
+Write the ATK marker (arbitrary transformation kernel)
+@param j3d J3D handle
+*/
+static void j3d_write_atk(opj_j3d_t *j3d);
+/**
+Read the ATK marker (arbitrary transformation kernel)
+@param j3d J3D handle
+*/
+static void j3d_read_atk(opj_j3d_t *j3d);
+/**
+Write the CBD marker (component bit depth definition)
+@param j3d J3D handle
+*/
+static void j3d_write_cbd(opj_j3d_t *j3d);
+/**
+Read the CBD marker (component bit depth definition)
+@param j3d J3D handle
+*/
+static void j3d_read_cbd(opj_j3d_t *j3d);
+/**
+Write the MCT marker (multiple component transfomation definition)
+@param j3d J3D handle
+*/
+static void j3d_write_mct(opj_j3d_t *j3d);
+/**
+Read the MCT marker (multiple component transfomation definition)
+@param j3d J3D handle
+*/
+static void j3d_read_mct(opj_j3d_t *j3d);
+/**
+Write the MCC marker (multiple component transfomation collection)
+@param j3d J3D handle
+*/
+static void j3d_write_mcc(opj_j3d_t *j3d);
+/**
+Read the MCC marker (multiple component transfomation collection)
+@param j3d J3D handle
+*/
+static void j3d_read_mcc(opj_j3d_t *j3d);
+/**
+Write the MCO marker (multiple component transfomation ordering)
+@param j3d J3D handle
+*/
+static void j3d_write_mco(opj_j3d_t *j3d);
+/**
+Read the MCO marker (multiple component transfomation ordering)
+@param j3d J3D handle
+*/
+static void j3d_read_mco(opj_j3d_t *j3d);
+/**
+Write the NLT marker (non-linearity point transformation)
+@param j3d J3D handle
+*/
+static void j3d_write_nlt(opj_j3d_t *j3d);
+/**
+Read the NLT marker (non-linearity point transformation)
+@param j3d J3D handle
+*/
+static void j3d_read_nlt(opj_j3d_t *j3d);
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+void j3d_dump_volume(FILE *fd, opj_volume_t * vol) {
+	int compno;
+	fprintf(fd, "volume {\n");
+	fprintf(fd, "  x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d\n", vol->x0, vol->y0, vol->z0,vol->x1, vol->y1,  vol->z1);
+	fprintf(fd, "  numcomps=%d\n", vol->numcomps);
+	for (compno = 0; compno < vol->numcomps; compno++) {
+		opj_volume_comp_t *comp = &vol->comps[compno];
+		fprintf(fd, "  comp %d {\n", compno);
+		fprintf(fd, "    dx=%d, dy=%d, dz=%d\n", comp->dx, comp->dy, comp->dz);
+		fprintf(fd, "    prec=%d\n", comp->prec);
+		fprintf(fd, "    sgnd=%d\n", comp->sgnd);
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+void j3d_dump_cp(FILE *fd, opj_volume_t * vol, opj_cp_t * cp) {
+	int tileno, compno, layno, bandno, resno, numbands;
+	fprintf(fd, "coding parameters {\n");
+	fprintf(fd, "  tx0=%d, ty0=%d, tz0=%d\n", cp->tx0, cp->ty0, cp->tz0);
+	fprintf(fd, "  tdx=%d, tdy=%d, tdz=%d\n", cp->tdx, cp->tdy, cp->tdz);
+	fprintf(fd, "  tw=%d, th=%d, tl=%d\n", cp->tw, cp->th, cp->tl);
+	fprintf(fd, "  transform format: %d\n", cp->transform_format);
+	fprintf(fd, "  encoding format: %d\n", cp->encoding_format);
+	for (tileno = 0; tileno < cp->tw * cp->th * cp->tl; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		fprintf(fd, "  tile %d {\n", tileno);
+		fprintf(fd, "    csty=%x\n", tcp->csty);
+		fprintf(fd, "    prg=%d\n", tcp->prg);
+		fprintf(fd, "    numlayers=%d\n", tcp->numlayers);
+		fprintf(fd, "    mct=%d\n", tcp->mct);
+		fprintf(fd, "    rates=");
+		for (layno = 0; layno < tcp->numlayers; layno++) {
+			fprintf(fd, "%f ", tcp->rates[layno]);
+		}
+		fprintf(fd, "\n");
+		fprintf(fd, "    first=%d\n", tcp->first);
+		for (compno = 0; compno < vol->numcomps; compno++) {
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			fprintf(fd, "    comp %d {\n", compno);
+			fprintf(fd, "      csty=%x\n", tccp->csty);
+			fprintf(fd, "      numresx=%d, numresy=%d, numresz=%d\n", tccp->numresolution[0], tccp->numresolution[1], tccp->numresolution[2]);
+			fprintf(fd, "      cblkw=%d, cblkh=%d, cblkl=%d\n", tccp->cblk[0], tccp->cblk[1], tccp->cblk[2]);
+			fprintf(fd, "      cblksty=%x\n", tccp->cblksty);
+			fprintf(fd, "      qntsty=%d\n", tccp->qntsty);
+			fprintf(fd, "      numgbits=%d\n", tccp->numgbits);
+			fprintf(fd, "      roishift=%d\n", tccp->roishift);
+			fprintf(fd, "      reversible=%d\n", tccp->reversible);
+			fprintf(fd, "      dwtidx=%d dwtidy=%d dwtidz=%d\n", tccp->dwtid[0], tccp->dwtid[1], tccp->dwtid[2]);
+			if (tccp->atk != NULL) {
+                fprintf(fd, "      atk.index=%d\n", tccp->atk->index);
+				fprintf(fd, "      atk.coeff_typ=%d\n", tccp->atk->coeff_typ);
+				fprintf(fd, "      atk.filt_cat=%d\n", tccp->atk->filt_cat);
+				fprintf(fd, "      atk.exten=%d\n", tccp->atk->exten);
+				fprintf(fd, "      atk.minit=%d\n", tccp->atk->minit);
+				fprintf(fd, "      atk.wt_typ=%d\n", tccp->atk->wt_typ);
+			}
+			fprintf(fd, "      stepsizes of bands=");
+            numbands = (tccp->qntsty == J3D_CCP_QNTSTY_SIQNT) ? 1 :
+			( (cp->transform_format == TRF_2D_DWT) ? (tccp->numresolution[0] * 3 - 2) :
+				(tccp->numresolution[0] * 7 - 6) - 4 *(tccp->numresolution[0] - tccp->numresolution[2]) );
+			for (bandno = 0; bandno < numbands; bandno++) {
+				fprintf(fd, "(%d,%d) ", tccp->stepsizes[bandno].mant,tccp->stepsizes[bandno].expn);
+			}
+			fprintf(fd, "\n");
+			
+			if (tccp->csty & J3D_CCP_CSTY_PRT) {
+				fprintf(fd, "      prcw=");
+				for (resno = 0; resno < tccp->numresolution[0]; resno++) {
+					fprintf(fd, "%d ", tccp->prctsiz[0][resno]);
+				}
+				fprintf(fd, "\n");
+				fprintf(fd, "      prch=");
+				for (resno = 0; resno < tccp->numresolution[0]; resno++) {
+					fprintf(fd, "%d ", tccp->prctsiz[1][resno]);
+				}
+				fprintf(fd, "\n");
+				fprintf(fd, "      prcl=");
+				for (resno = 0; resno < tccp->numresolution[0]; resno++) {
+					fprintf(fd, "%d ", tccp->prctsiz[2][resno]);
+				}
+				fprintf(fd, "\n");
+			}
+			fprintf(fd, "    }\n");
+		}
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+/* ----------------------------------------------------------------------- 
+Extended capabilities
+------------------------------------------------------------------------*/
+
+static void j3d_write_cap(opj_j3d_t *j3d){
+	int len,lenp;
+
+	opj_cio_t *cio = j3d->cio;
+	cio_write(cio, J3D_MS_CAP, 2);	/* CAP */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio,J3D_CAP_10, 4); 
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lsiz */
+	cio_seek(cio, lenp + len);
+
+}
+static void j3d_read_cap(opj_j3d_t *j3d){
+	int len, Cap;
+	opj_cio_t *cio = j3d->cio;
+	/*cio_read(cio, 2);	 CAP */
+	len = cio_read(cio, 2);
+	Cap = cio_read(cio, 4);
+}
+static void j3d_write_zsi(opj_j3d_t *j3d) {
+	int i;
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	cio_write(cio, J3D_MS_ZSI, 2);	/* ZSI */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, volume->z1, 4);	/* Zsiz */
+	cio_write(cio, volume->z0, 4);	/* Z0siz */
+	cio_write(cio, cp->tdz, 4);		/* ZTsiz */
+	cio_write(cio, cp->tz0, 4);		/* ZT0siz */
+	for (i = 0; i < volume->numcomps; i++) {
+		cio_write(cio, volume->comps[i].dz, 1);	/* ZRsiz_i */
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lsiz */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_zsi(opj_j3d_t *j3d) {
+	int len, i;
+	
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	len = cio_read(cio, 2);			/* Lsiz */
+	volume->z1 = cio_read(cio, 4);	/* Zsiz */
+	volume->z0 = cio_read(cio, 4);	/* Z0siz */
+	cp->tdz = cio_read(cio, 4);		/* ZTsiz */
+	cp->tz0 = cio_read(cio, 4);		/* ZT0siz */
+	for (i = 0; i < volume->numcomps; i++) {
+		volume->comps[i].dz = cio_read(cio, 1);	/* ZRsiz_i */
+	}
+	
+	//Initialization of volume
+	cp->tw = int_ceildiv(volume->x1 - cp->tx0, cp->tdx);
+	cp->th = int_ceildiv(volume->y1 - cp->ty0, cp->tdy);
+	cp->tl = int_ceildiv(volume->z1 - cp->tz0, cp->tdz);
+	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(opj_tcp_t));
+	cp->tileno = (int *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(int));
+	cp->tileno_size = 0;
+	
+	for (i = 0; i < cp->tw * cp->th * cp->tl ; i++) {
+		cp->tcps[i].POC = 0;
+		cp->tcps[i].numpocs = 0;
+		cp->tcps[i].first = 1;
+	}
+	
+	/* Initialization for PPM marker (Packets header)*/
+	cp->ppm = 0;
+	cp->ppm_data = NULL;
+	cp->ppm_data_first = NULL;
+	cp->ppm_previous = 0;
+	cp->ppm_store = 0;
+	
+	j3d->default_tcp->tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * volume->numcomps);
+	for (i = 0; i < cp->tw * cp->th * cp->tl ; i++) {
+		cp->tcps[i].tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * volume->numcomps);
+	}
+	j3d->tile_data = (unsigned char **) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(unsigned char *));
+	j3d->tile_len = (int *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(int));
+	j3d->state = J3D_STATE_MH;
+	
+}
+static void j3d_write_dco(opj_j3d_t *j3d){
+	int lenp, len, i;
+	int dcotype;	
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	dcotype = 1; /* Offsets are 16bit signed integers Table A21 15444-2 */
+	cio_write(cio, J3D_MS_DCO, 2);	/* DCO */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, dcotype, 1);	
+	if (dcotype == 0) {
+		for (i = 0; i < volume->numcomps; i++) 
+			cio_write(cio, volume->comps[i].dcoffset, 1);	/* SPdco_i */
+	} else if (dcotype == 1) {
+		for (i = 0; i < volume->numcomps; i++){ 
+			cio_write(cio, volume->comps[i].dcoffset, 1);	/* SPdco_i */
+			opj_event_msg(j3d->cinfo, EVT_INFO, "dcotype %d DCO %d \n",dcotype,volume->comps[i].dcoffset);
+		}
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Ldco */
+	cio_seek(cio, lenp + len);
+
+}
+static void j3d_read_dco(opj_j3d_t *j3d){
+	int len, i;
+	int dcotype;
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	len = cio_read(cio, 2);			/* Lsiz */
+	dcotype = cio_read(cio, 1); //offset 8bit unsigned / 16bit signed integers
+	if (dcotype == 0) {
+		for (i = 0; i < volume->numcomps; i++) {
+			volume->comps[i].dcoffset = cio_read(cio, 1);
+			if (volume->comps[i].dcoffset > 128) 
+				volume->comps[i].dcoffset = volume->comps[i].dcoffset - 256;
+		}
+	} else if (dcotype == 1) {
+		for (i = 0; i < volume->numcomps; i++) {
+			volume->comps[i].dcoffset = cio_read(cio, 1);
+			if (volume->comps[i].dcoffset > 128) 
+				volume->comps[i].dcoffset = volume->comps[i].dcoffset - 256;
+		}
+	}
+	
+}
+static void j3d_write_atk(opj_j3d_t *j3d){
+	int lenp, len, s, k;
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_atk_t *atk = j3d->cp->tcps->tccps->atk;
+	
+	cio_write(cio, J3D_MS_ATK, 2);	/* ATK */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);				
+	cio_write(cio, atk->index + (atk->coeff_typ << 8) + (atk->filt_cat << 11) 
+		+ (atk->wt_typ << 12) + (atk->minit << 13) + (atk->exten << 14), 2);			/* Satk */
+    if (atk->wt_typ == J3D_ATK_IRR) 
+		cio_write(cio,(unsigned int) (atk->Katk * 8192.0), 1 << atk->coeff_typ);
+	cio_write(cio, atk->Natk, 1);
+	for (s = 0; s < atk->Natk; s++){
+		if (atk->filt_cat == J3D_ATK_ARB) 
+			cio_write(cio, atk->Oatk[s], 1);
+		if (atk->wt_typ == J3D_ATK_REV){
+			cio_write(cio, atk->Eatk[s], 1);
+			cio_write(cio, atk->Batk[s], 1);
+		}
+		cio_write(cio, atk->LCatk[s], 1);
+		for (k = 0; k < atk->LCatk[s]; k++)
+			cio_write(cio,(unsigned int) (atk->Aatk[s][k] * 8192.0), 1 << atk->coeff_typ);
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Latk */
+	cio_seek(cio, lenp + len);
+}
+static void j3d_read_atk(opj_j3d_t *j3d){
+	int len, i, Satk, k;
+	
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	opj_atk_t *atk = cp->tcps->tccps->atk; 
+	
+	len = cio_read(cio, 2);			/* Latk */
+	Satk = cio_read(cio, 2); 
+	atk->index = Satk & 0x00ff;
+	atk->coeff_typ = Satk >> 8 & 0x0007;
+	atk->filt_cat = Satk >> 11 & 0x0001;
+	atk->wt_typ = Satk >> 12  & 0x0001;
+	atk->minit = Satk >> 13 & 0x0001;
+	atk->exten = Satk >> 14 & 0x0001;
+    if (atk->wt_typ == J3D_ATK_IRR) 
+		atk->Katk = ((double) cio_read(cio, 1 << atk->coeff_typ) / 8192.0);
+	atk->Natk = cio_read(cio, 1);
+	for (i = 0; i < atk->Natk; i++) {
+		if (atk->filt_cat == J3D_ATK_ARB) 
+			atk->Oatk[i] = cio_read(cio, 1);
+		if (atk->wt_typ == J3D_ATK_REV){
+			atk->Eatk[i] = cio_read(cio, 1);
+			atk->Batk[i] = cio_read(cio, 1);
+		}
+		atk->LCatk[i] = cio_read(cio, 1);
+		for (k = 0; k < atk->LCatk[i]; k++)
+			atk->Aatk[i][k] = ((double) cio_read(cio, 1 << atk->coeff_typ) / 8192.0);
+	}
+}
+static void j3d_write_cbd(opj_j3d_t *j3d){
+}
+static void j3d_read_cbd(opj_j3d_t *j3d){
+}
+static void j3d_write_mct(opj_j3d_t *j3d){
+}
+static void j3d_read_mct(opj_j3d_t *j3d){
+}
+static void j3d_write_mcc(opj_j3d_t *j3d){
+}
+static void j3d_read_mcc(opj_j3d_t *j3d){
+}
+static void j3d_write_mco(opj_j3d_t *j3d){
+}
+static void j3d_read_mco(opj_j3d_t *j3d){
+}
+static void j3d_write_nlt(opj_j3d_t *j3d){
+}
+static void j3d_read_nlt(opj_j3d_t *j3d){
+}
+/* ----------------------------------------------------------------------- 
+15444-1 codestream syntax
+------------------------------------------------------------------------*/
+static void j3d_write_soc(opj_j3d_t *j3d) {
+	opj_cio_t *cio = j3d->cio;
+	cio_write(cio, J3D_MS_SOC, 2);
+}
+
+static void j3d_read_soc(opj_j3d_t *j3d) {
+	j3d->state = J3D_STATE_MHSIZ;
+}
+
+static void j3d_write_siz(opj_j3d_t *j3d) {
+	int i;
+	int lenp, len;
+	int Rsiz;
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	cio_write(cio, J3D_MS_SIZ, 2);	/* SIZ */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	//cio_write(cio, 0, 2);			/* Rsiz (capabilities of 15444-1 only) */
+	Rsiz = J3D_RSIZ_DCO | J3D_RSIZ_ATK; /** | J3D_RSIZ_MCT | J3D_RSIZ_NONLT (not implemented yet)*/
+	cio_write(cio, Rsiz, 2); /* capabilities of WDv5.2*/
+	cio_write(cio, volume->x1, 4);	/* Xsiz */
+	cio_write(cio, volume->y1, 4);	/* Ysiz */
+	cio_write(cio, volume->x0, 4);	/* X0siz */
+	cio_write(cio, volume->y0, 4);	/* Y0siz */
+	cio_write(cio, cp->tdx, 4);		/* XTsiz */
+	cio_write(cio, cp->tdy, 4);		/* YTsiz */
+	cio_write(cio, cp->tx0, 4);		/* XT0siz */
+	cio_write(cio, cp->ty0, 4);		/* YT0siz */
+	cio_write(cio, volume->numcomps, 2);	/* Csiz */
+	for (i = 0; i < volume->numcomps; i++) {
+		cio_write(cio, volume->comps[i].prec - 1 + (volume->comps[i].sgnd << 7), 1);	/* Ssiz_i */
+		cio_write(cio, volume->comps[i].dx, 1);	/* XRsiz_i */
+		cio_write(cio, volume->comps[i].dy, 1);	/* YRsiz_i */
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lsiz */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_siz(opj_j3d_t *j3d) {
+	int len, i;
+	
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	opj_cp_t *cp = j3d->cp;
+	
+	len = cio_read(cio, 2);			/* Lsiz */
+	cp->rsiz = cio_read(cio, 2);	/* Rsiz (capabilities) */
+	volume->x1 = cio_read(cio, 4);	/* Xsiz */
+	volume->y1 = cio_read(cio, 4);	/* Ysiz */
+	volume->x0 = cio_read(cio, 4);	/* X0siz */
+	volume->y0 = cio_read(cio, 4);	/* Y0siz */
+	cp->tdx = cio_read(cio, 4);		/* XTsiz */
+	cp->tdy = cio_read(cio, 4);		/* YTsiz */
+	cp->tx0 = cio_read(cio, 4);		/* XT0siz */
+	cp->ty0 = cio_read(cio, 4);		/* YT0siz */
+	
+	volume->numcomps = cio_read(cio, 2);	/* Csiz */
+	volume->comps = (opj_volume_comp_t *) opj_malloc(volume->numcomps * sizeof(opj_volume_comp_t));
+	for (i = 0; i < volume->numcomps; i++) {
+		int tmp, j;
+		tmp = cio_read(cio, 1);		/* Ssiz_i */
+		volume->comps[i].prec = (tmp & 0x7f) + 1;
+		volume->comps[i].sgnd = tmp >> 7;
+		volume->comps[i].dx = cio_read(cio, 1);	/* XRsiz_i */
+		volume->comps[i].dy = cio_read(cio, 1);	/* YRsiz_i */
+		for (j = 0; j < 3; j++) {
+			volume->comps[i].resno_decoded[j] = 0;		/* number of resolution decoded */
+			volume->comps[i].factor[j] = 0;		/* reducing factor per component */
+		}
+	}
+
+	if (j3d->cinfo->codec_format == CODEC_J2K){
+		volume->z1 = 1;
+		volume->z0 = 0;
+		volume->numslices = 1;
+		cp->tdz = 1;
+		cp->tz0 = 0;
+		for (i = 0; i < volume->numcomps; i++) 
+			volume->comps[i].dz = 1;
+
+		//Initialization of volume
+		cp->tw = int_ceildiv(volume->x1 - cp->tx0, cp->tdx);
+		cp->th = int_ceildiv(volume->y1 - cp->ty0, cp->tdy);
+		cp->tl = int_ceildiv(volume->z1 - cp->tz0, cp->tdz);
+		cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(opj_tcp_t));
+		cp->tileno = (int *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(int));
+		cp->tileno_size = 0;
+		
+		for (i = 0; i < cp->tw * cp->th * cp->tl ; i++) {
+			cp->tcps[i].POC = 0;
+			cp->tcps[i].numpocs = 0;
+			cp->tcps[i].first = 1;
+		}
+		
+		/* Initialization for PPM marker (Packets header)*/
+		cp->ppm = 0;
+		cp->ppm_data = NULL;
+		cp->ppm_data_first = NULL;
+		cp->ppm_previous = 0;
+		cp->ppm_store = 0;
+		
+		j3d->default_tcp->tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * volume->numcomps);
+		for (i = 0; i < cp->tw * cp->th * cp->tl ; i++) {
+			cp->tcps[i].tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * volume->numcomps);
+		}
+		j3d->tile_data = (unsigned char **) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(unsigned char *));
+		j3d->tile_len = (int *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(int));
+		j3d->state = J3D_STATE_MH;
+	}
+}
+
+
+
+static void j3d_write_com(opj_j3d_t *j3d) {
+	unsigned int i;
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+
+	cio_write(cio, J3D_MS_COM, 2);
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	//cio_write(cio, 0, 2);
+	cio_write(cio, j3d->cp->transform_format,1);
+	cio_write(cio, j3d->cp->encoding_format,1);
+	//opj_event_msg(j3d->cinfo, EVT_INFO, "TRF %D ENCOD %d\n",j3d->cp->transform_format,j3d->cp->encoding_format);
+	if (j3d->cp->comment != NULL) {
+		char *comment = j3d->cp->comment;
+		for (i = 0; i < strlen(comment); i++) {
+            cio_write(cio, comment[i], 1);
+		}
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_com(opj_j3d_t *j3d) {
+	int len;
+	opj_cio_t *cio = j3d->cio;
+
+	len = cio_read(cio, 2);
+	
+	j3d->cp->transform_format = (OPJ_TRANSFORM) cio_read(cio, 1);
+	j3d->cp->encoding_format = (OPJ_ENTROPY_CODING) cio_read(cio, 1);
+	//opj_event_msg(j3d->cinfo, EVT_INFO, "TRF %D ENCOD %d\n",j3d->cp->transform_format,j3d->cp->encoding_format);
+
+	cio_skip(cio, len - 4);  //posible comments
+}
+
+static void j3d_write_cox(opj_j3d_t *j3d, int compno) {
+	int i;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = &cp->tcps[j3d->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, tccp->numresolution[0] - 1, 1);	/* SPcox (D) No of decomposition levels in x-axis*/
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		cio_write(cio, tccp->numresolution[1] - 1, 1);	/* SPcox (E) No of decomposition levels in y-axis*/
+		cio_write(cio, tccp->numresolution[2] - 1, 1);	/* SPcox (F) No of decomposition levels in z-axis*/
+	}
+	/* (cblkw - 2) + (cblkh - 2) + (cblkl - 2) <= 18*/
+	cio_write(cio, tccp->cblk[0] - 2, 1);				/* SPcox (G) Cblk width entre 10 y 2 (8 y 0)*/
+	cio_write(cio, tccp->cblk[1] - 2, 1);				/* SPcox (H) Cblk height*/
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		cio_write(cio, tccp->cblk[2] - 2, 1);			/* SPcox (I) Cblk depth*/
+	}
+	cio_write(cio, tccp->cblksty, 1);				/* SPcox (J) Cblk style*/
+	cio_write(cio, tccp->dwtid[0], 1);				/* SPcox (K) WT in x-axis 15444-2 Table A10*/
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		cio_write(cio, tccp->dwtid[1], 1);				/* SPcox (L) WT in y-axis 15444-2 Table A10*/
+		cio_write(cio, tccp->dwtid[2], 1);				/* SPcox (M) WT in z-axis 15444-2 Table A10*/
+	}
+	
+	if (tccp->csty & J3D_CCP_CSTY_PRT) {
+		for (i = 0; i < tccp->numresolution[0]; i++) {
+			if (i < tccp->numresolution[2])
+                cio_write(cio, tccp->prctsiz[0][i] + (tccp->prctsiz[1][i] << 4) + (tccp->prctsiz[2][i] << 8), 2);	/* SPcox (N_i) Table A9*/
+			else
+				if (j3d->cinfo->codec_format == CODEC_J3D) 
+                    cio_write(cio, tccp->prctsiz[0][i] + (tccp->prctsiz[1][i] << 4), 2);	/* SPcox (N_i) Table A9*/
+				else
+                    cio_write(cio, tccp->prctsiz[0][i] + (tccp->prctsiz[1][i] << 4), 1);	/* SPcox (N_i) Table A9*/		}
+	}
+}
+
+static void j3d_read_cox(opj_j3d_t *j3d, int compno) {
+	int i;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j3d->cio;
+
+	tccp->numresolution[0] = cio_read(cio, 1) + 1;	/* SPcox (D) No of decomposition levels in x-axis*/
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		tccp->numresolution[1] = cio_read(cio, 1) + 1;	/* SPcox (E) No of decomposition levels in y-axis*/
+		tccp->numresolution[2] = cio_read(cio, 1) + 1;	/* SPcox (F) No of decomposition levels in z-axis*/
+	}else if (j3d->cinfo->codec_format == CODEC_J2K) {
+		tccp->numresolution[1] = tccp->numresolution[0];	
+		tccp->numresolution[2] = 1;							
+	}
+	/* check the reduce value */
+	cp->reduce[0] = int_min((tccp->numresolution[0])-1, cp->reduce[0]);
+	cp->reduce[1] = int_min((tccp->numresolution[1])-1, cp->reduce[1]);
+	cp->reduce[2] = int_min((tccp->numresolution[2])-1, cp->reduce[2]);
+	
+	tccp->cblk[0] = cio_read(cio, 1) + 2;	/* SPcox (G) */
+	tccp->cblk[1] = cio_read(cio, 1) + 2;	/* SPcox (H) */
+	if (j3d->cinfo->codec_format == CODEC_J3D)
+		tccp->cblk[2] = cio_read(cio, 1) + 2;	/* SPcox (I) */
+	else
+		tccp->cblk[2] = tccp->cblk[0];
+
+	tccp->cblksty = cio_read(cio, 1);	/* SPcox (J) */
+	tccp->dwtid[0] = cio_read(cio, 1);	/* SPcox (K) */
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		tccp->dwtid[1] = cio_read(cio, 1);	/* SPcox (L) */
+		tccp->dwtid[2] = cio_read(cio, 1);	/* SPcox (M) */
+	}else{
+		tccp->dwtid[1] = tccp->dwtid[0];	/* SPcox (L) */
+		tccp->dwtid[2] = tccp->dwtid[0];	/* SPcox (M) */
+	}
+	tccp->reversible = (tccp->dwtid[0]>=1 && tccp->dwtid[1]>=1 && tccp->dwtid[2]>=1); //TODO: only valid for irreversible 9x7 WTs
+	if (tccp->csty & J3D_CP_CSTY_PRT) {
+		for (i = 0; i < tccp->numresolution[0]; i++) {
+			int tmp = cio_read(cio, 2);	/* SPcox (N_i) */
+			tccp->prctsiz[0][i] = tmp & 0xf;
+			tccp->prctsiz[1][i] = tmp >> 4;
+			tccp->prctsiz[2][i] = tmp >> 8;
+		}
+	}
+}
+
+static void j3d_write_cod(opj_j3d_t *j3d) {
+	opj_cp_t *cp = NULL;
+	opj_tcp_t *tcp = NULL;
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, J3D_MS_COD, 2);	/* COD */
+	
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	
+	cp = j3d->cp;
+	tcp = &cp->tcps[j3d->curtileno];
+
+	/* Scod : Table A-4*/
+	cio_write(cio, tcp->csty, 1);		/* Scod : Coding style parameters */
+	/* SGcod : Table A-5*/
+	cio_write(cio, tcp->prg, 1);		/* SGcod (A) : Progression order */
+	cio_write(cio, tcp->numlayers, 2);	/* SGcod (B) : No of layers */
+	cio_write(cio, tcp->mct, 1);		/* SGcod (C) : Multiple component transformation usage */
+	/* SPcod : Table A-6*/
+	j3d_write_cox(j3d, 0);				
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lcod */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_cod(opj_j3d_t *j3d) {
+	int len, i, pos;
+	
+	opj_cio_t *cio = j3d->cio;
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_volume_t *volume = j3d->volume;
+
+	/* Lcod */
+	len = cio_read(cio, 2);				
+	/* Scod : Table A-4*/
+	tcp->csty = cio_read(cio, 1);		
+	/* SGcod : Table A-5*/
+	tcp->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);
+	tcp->numlayers = cio_read(cio, 2);	
+	tcp->mct = cio_read(cio, 1);		
+	
+	pos = cio_tell(cio);
+	for (i = 0; i < volume->numcomps; i++) {
+		tcp->tccps[i].csty = tcp->csty & J3D_CP_CSTY_PRT;
+		cio_seek(cio, pos);
+		j3d_read_cox(j3d, i);
+	}
+}
+
+static void j3d_write_coc(opj_j3d_t *j3d, int compno) {
+	int lenp, len;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = &cp->tcps[j3d->curtileno];
+	opj_volume_t *volume = j3d->volume;
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, J3D_MS_COC, 2);	/* COC */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, compno, volume->numcomps <= 256 ? 1 : 2);	/* Ccoc */
+	cio_write(cio, tcp->tccps[compno].csty, 1);					/* Scoc */
+	
+	j3d_write_cox(j3d, compno);
+	
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lcoc */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_coc(opj_j3d_t *j3d) {
+	int len, compno;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_volume_t *volume = j3d->volume;
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);		/* Lcoc */
+	compno = cio_read(cio, volume->numcomps <= 256 ? 1 : 2);	/* Ccoc */
+	tcp->tccps[compno].csty = cio_read(cio, 1);	/* Scoc */
+	j3d_read_cox(j3d, compno);
+}
+
+static void j3d_write_qcx(opj_j3d_t *j3d, int compno) {
+	int bandno, numbands;
+	int expn, mant;
+	
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = &cp->tcps[j3d->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, tccp->qntsty + (tccp->numgbits << 5), 1);	/* Sqcx : Table A28 de 15444-1*/
+	
+	if (j3d->cinfo->codec_format == CODEC_J2K)
+        numbands = tccp->qntsty == J3D_CCP_QNTSTY_SIQNT ? 1 : tccp->numresolution[0] * 3 - 2; 
+	else if (j3d->cinfo->codec_format == CODEC_J3D) {
+		int diff = tccp->numresolution[0] - tccp->numresolution[2];
+        numbands = (tccp->qntsty == J3D_CCP_QNTSTY_SIQNT) ? 1 : (tccp->numresolution[0] * 7 - 6) - 4 *diff; /* SIQNT vs. SEQNT */
+	}
+	
+	for (bandno = 0; bandno < numbands; bandno++) {
+		expn = tccp->stepsizes[bandno].expn;
+		mant = tccp->stepsizes[bandno].mant;
+		
+		if (tccp->qntsty == J3D_CCP_QNTSTY_NOQNT) {
+			cio_write(cio, expn << 3, 1);	/* SPqcx_i */
+		} else {
+			cio_write(cio, (expn << 11) + mant, 2);	/* SPqcx_i */
+		}
+	}
+}
+
+static void j3d_read_qcx(opj_j3d_t *j3d, int compno, int len) {
+	int tmp;
+	int bandno, numbands;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j3d->cio;
+
+	tmp = cio_read(cio, 1);		/* Sqcx */
+	tccp->qntsty = tmp & 0x1f;
+	tccp->numgbits = tmp >> 5;
+
+	/*Numbands = 1				si SIQNT
+			     len - 1		si NOQNT
+				 (len - 1) / 2	si SEQNT */
+	numbands = tccp->qntsty == J3D_CCP_QNTSTY_SIQNT ? 1 : ((tccp->qntsty == J3D_CCP_QNTSTY_NOQNT) ? len - 1 : (len - 1) / 2);
+
+	for (bandno = 0; bandno < numbands; bandno++) {
+		int expn, mant;
+		if (tccp->qntsty == J3D_CCP_QNTSTY_NOQNT) {
+			expn = cio_read(cio, 1) >> 3;	/* SPqcx_i */
+			mant = 0;
+		} else {
+			tmp = cio_read(cio, 2);			/* SPqcx_i */
+			expn = tmp >> 11;
+			mant = tmp & 0x7ff;
+		}
+		tccp->stepsizes[bandno].expn = expn;
+		tccp->stepsizes[bandno].mant = mant;
+	}
+	
+	/* Add Antonin : if scalar_derived -> compute other stepsizes */
+	if (tccp->qntsty == J3D_CCP_QNTSTY_SIQNT) {
+		for (bandno = 1; bandno < J3D_MAXBANDS; bandno++) {
+			int numbands = (cp->transform_format==TRF_2D_DWT) ? 3 : 7;
+			tccp->stepsizes[bandno].expn = tccp->stepsizes[0].expn - ((bandno - 1) / numbands);
+			tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
+		}
+	}
+	/* ddA */
+}
+
+static void j3d_write_qcd(opj_j3d_t *j3d) {
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, J3D_MS_QCD, 2);	/* QCD */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	j3d_write_qcx(j3d, 0);			/* Sqcd*/
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lqcd */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_qcd(opj_j3d_t *j3d) {
+	int len, i, pos;
+
+	opj_cio_t *cio = j3d->cio;
+	opj_volume_t *volume = j3d->volume;
+	
+	len = cio_read(cio, 2);		/* Lqcd */
+	pos = cio_tell(cio);
+	for (i = 0; i < volume->numcomps; i++) {
+		cio_seek(cio, pos);
+		j3d_read_qcx(j3d, i, len - 2);
+	}
+}
+
+static void j3d_write_qcc(opj_j3d_t *j3d, int compno) {
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, J3D_MS_QCC, 2);	/* QCC */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, compno, j3d->volume->numcomps <= 256 ? 1 : 2);	/* Cqcc */
+	j3d_write_qcx(j3d, compno);
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lqcc */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_qcc(opj_j3d_t *j3d) {
+	int len, compno;
+	int numcomp = j3d->volume->numcomps;
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);	/* Lqcc */
+	compno = cio_read(cio, numcomp <= 256 ? 1 : 2);	/* Cqcc */
+	j3d_read_qcx(j3d, compno, len - 2 - (numcomp <= 256 ? 1 : 2));
+}
+
+static void j3d_write_poc(opj_j3d_t *j3d) {
+	int len, numpchgs, i;
+
+	int numcomps = j3d->volume->numcomps;
+	
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = &cp->tcps[j3d->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[0];
+	opj_cio_t *cio = j3d->cio;
+
+	numpchgs = tcp->numpocs;
+	cio_write(cio, J3D_MS_POC, 2);	/* POC  */
+	len = 2 + (5 + 2 * (numcomps <= 256 ? 1 : 2)) * numpchgs;
+	cio_write(cio, len, 2);		/* Lpoc */
+	for (i = 0; i < numpchgs; i++) {
+		opj_poc_t *poc = &tcp->pocs[i];
+		cio_write(cio, poc->resno0, 1);	/* RSpoc_i */
+		cio_write(cio, poc->compno0, (numcomps <= 256 ? 1 : 2));	/* CSpoc_i */
+		cio_write(cio, poc->layno1, 2);	/* LYEpoc_i */
+		poc->layno1 = int_min(poc->layno1, tcp->numlayers);
+		cio_write(cio, poc->resno1, 1);	/* REpoc_i */
+		poc->resno1 = int_min(poc->resno1, tccp->numresolution[0]);
+		cio_write(cio, poc->compno1, (numcomps <= 256 ? 1 : 2));	/* CEpoc_i */
+		poc->compno1 = int_min(poc->compno1, numcomps);
+		cio_write(cio, poc->prg, 1);	/* Ppoc_i */
+	}
+}
+
+static void j3d_read_poc(opj_j3d_t *j3d) {
+	int len, numpchgs, i, old_poc;
+
+	int numcomps = j3d->volume->numcomps;
+	
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_tccp_t *tccp = &tcp->tccps[0];
+	opj_cio_t *cio = j3d->cio;
+	
+	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
+	tcp->POC = 1;
+	len = cio_read(cio, 2);		/* Lpoc */
+	numpchgs = (len - 2) / (5 + 2 * (numcomps <= 256 ? 1 : 2));
+	
+	for (i = old_poc; i < numpchgs + old_poc; i++) {
+		opj_poc_t *poc;
+		poc = &tcp->pocs[i];
+		poc->resno0 = cio_read(cio, 1);	/* RSpoc_i */
+		poc->compno0 = cio_read(cio, numcomps <= 256 ? 1 : 2);	/* CSpoc_i */
+		poc->layno1 = int_min(cio_read(cio, 2), (unsigned int) tcp->numlayers);	/* LYEpoc_i */
+		poc->resno1 = int_min(cio_read(cio, 1), (unsigned int) tccp->numresolution[0]);	/* REpoc_i */
+		poc->compno1 = int_min(
+			cio_read(cio, numcomps <= 256 ? 1 : 2), (unsigned int) numcomps);	/* CEpoc_i */
+		poc->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);	/* Ppoc_i */
+	}
+	
+	tcp->numpocs = numpchgs + old_poc - 1;
+}
+
+static void j3d_read_crg(opj_j3d_t *j3d) {
+	int len, i, Xcrg_i, Ycrg_i, Zcrg_i;
+	
+	opj_cio_t *cio = j3d->cio;
+	int numcomps = j3d->volume->numcomps;
+	
+	len = cio_read(cio, 2);			/* Lcrg */
+	for (i = 0; i < numcomps; i++) {
+		Xcrg_i = cio_read(cio, 2);	/* Xcrg_i */
+		Ycrg_i = cio_read(cio, 2);	/* Ycrg_i */
+		Zcrg_i = cio_read(cio, 2);	/* Zcrg_i */
+	}
+}
+
+static void j3d_read_tlm(opj_j3d_t *j3d) {
+	int len, Ztlm, Stlm, ST, SP, tile_tlm, i;
+	long int Ttlm_i, Ptlm_i;
+
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);		/* Ltlm */
+	Ztlm = cio_read(cio, 1);	/* Ztlm */
+	Stlm = cio_read(cio, 1);	/* Stlm */
+	ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);
+	SP = (Stlm >> 6) & 0x01;
+	tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
+	for (i = 0; i < tile_tlm; i++) {
+		Ttlm_i = cio_read(cio, ST);	/* Ttlm_i */
+		Ptlm_i = cio_read(cio, SP ? 4 : 2);	/* Ptlm_i */
+	}
+}
+
+static void j3d_read_plm(opj_j3d_t *j3d) {
+	int len, i, Zplm, Nplm, add, packet_len = 0;
+	
+	opj_cio_t *cio = j3d->cio;
+
+	len = cio_read(cio, 2);		/* Lplm */
+	Zplm = cio_read(cio, 1);	/* Zplm */
+	len -= 3;
+	while (len > 0) {
+		Nplm = cio_read(cio, 4);		/* Nplm */
+		len -= 4;
+		for (i = Nplm; i > 0; i--) {
+			add = cio_read(cio, 1);
+			len--;
+			packet_len = (packet_len << 7) + add;	/* Iplm_ij */
+			if ((add & 0x80) == 0) {
+				/* New packet */
+				packet_len = 0;
+			}
+			if (len <= 0)
+				break;
+		}
+	}
+}
+
+static void j3d_read_plt(opj_j3d_t *j3d) {
+	int len, i, Zplt, packet_len = 0, add;
+	
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);		/* Lplt */
+	Zplt = cio_read(cio, 1);	/* Zplt */
+	for (i = len - 3; i > 0; i--) {
+		add = cio_read(cio, 1);
+		packet_len = (packet_len << 7) + add;	/* Iplt_i */
+		if ((add & 0x80) == 0) {
+			/* New packet */
+			packet_len = 0;
+		}
+	}
+}
+
+static void j3d_read_ppm(opj_j3d_t *j3d) {
+	int len, Z_ppm, i, j;
+	int N_ppm;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);
+	cp->ppm = 1;
+	
+	Z_ppm = cio_read(cio, 1);	/* Z_ppm */
+	len -= 3;
+	while (len > 0) {
+		if (cp->ppm_previous == 0) {
+			N_ppm = cio_read(cio, 4);	/* N_ppm */
+			len -= 4;
+		} else {
+			N_ppm = cp->ppm_previous;
+		}
+		j = cp->ppm_store;
+		if (Z_ppm == 0) {	/* First PPM marker */
+			cp->ppm_data = (unsigned char *) opj_malloc(N_ppm * sizeof(unsigned char));
+			cp->ppm_data_first = cp->ppm_data;
+			cp->ppm_len = N_ppm;
+		} else {			/* NON-first PPM marker */
+			cp->ppm_data = (unsigned char *) opj_realloc(cp->ppm_data, (N_ppm +	cp->ppm_store) * sizeof(unsigned char));
+			cp->ppm_data_first = cp->ppm_data;
+			cp->ppm_len = N_ppm + cp->ppm_store;
+		}
+		for (i = N_ppm; i > 0; i--) {	/* Read packet header */
+			cp->ppm_data[j] = cio_read(cio, 1);
+			j++;
+			len--;
+			if (len == 0)
+				break;			/* Case of non-finished packet header in present marker but finished in next one */
+		}
+		cp->ppm_previous = i - 1;
+		cp->ppm_store = j;
+	}
+}
+
+static void j3d_read_ppt(opj_j3d_t *j3d) {
+	int len, Z_ppt, i, j = 0;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = cp->tcps + j3d->curtileno;
+	opj_cio_t *cio = j3d->cio;
+
+	len = cio_read(cio, 2);
+	Z_ppt = cio_read(cio, 1);
+	tcp->ppt = 1;
+	if (Z_ppt == 0) {		/* First PPT marker */
+		tcp->ppt_data = (unsigned char *) opj_malloc((len - 3) * sizeof(unsigned char));
+		tcp->ppt_data_first = tcp->ppt_data;
+		tcp->ppt_store = 0;
+		tcp->ppt_len = len - 3;
+	} else {			/* NON-first PPT marker */
+		tcp->ppt_data =	(unsigned char *) opj_realloc(tcp->ppt_data, (len - 3 + tcp->ppt_store) * sizeof(unsigned char));
+		tcp->ppt_data_first = tcp->ppt_data;
+		tcp->ppt_len = len - 3 + tcp->ppt_store;
+	}
+	j = tcp->ppt_store;
+	for (i = len - 3; i > 0; i--) {
+		tcp->ppt_data[j] = cio_read(cio, 1);
+		j++;
+	}
+	tcp->ppt_store = j;
+}
+
+static void j3d_write_sot(opj_j3d_t *j3d) {
+	int lenp, len;
+
+	opj_cio_t *cio = j3d->cio;
+
+	j3d->sot_start = cio_tell(cio);
+	cio_write(cio, J3D_MS_SOT, 2);		/* SOT */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);					/* Lsot (further) */
+	cio_write(cio, j3d->curtileno, 2);	/* Isot */
+	cio_skip(cio, 4);					/* Psot (further in j3d_write_sod) */
+	cio_write(cio, 0, 1);				/* TPsot */
+	cio_write(cio, 1, 1);				/* TNsot (no of tile-parts of this tile in this codestream)*/
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);				/* Lsot */
+	cio_seek(cio, lenp + len);
+}
+
+static void j3d_read_sot(opj_j3d_t *j3d) {
+	int len, tileno, totlen, partno, numparts, i;
+	opj_tcp_t *tcp = NULL;
+	char status = 0;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_cio_t *cio = j3d->cio;
+	
+	len = cio_read(cio, 2);
+	tileno = cio_read(cio, 2);
+	
+	if (cp->tileno_size == 0) {
+		cp->tileno[cp->tileno_size] = tileno;
+		cp->tileno_size++;
+	} else {
+		i = 0;
+		while (i < cp->tileno_size && status == 0) {
+			status = cp->tileno[i] == tileno ? 1 : 0;
+			i++;
+		}
+		if (status == 0) {
+			cp->tileno[cp->tileno_size] = tileno;
+			cp->tileno_size++;
+		}
+	}
+	
+	totlen = cio_read(cio, 4);
+	if (!totlen)
+		totlen = cio_numbytesleft(cio) + 8;
+	
+	partno = cio_read(cio, 1);
+	numparts = cio_read(cio, 1);
+	
+	j3d->curtileno = tileno;
+	j3d->eot = cio_getbp(cio) - 12 + totlen;
+	j3d->state = J3D_STATE_TPH;
+	tcp = &cp->tcps[j3d->curtileno];
+	
+	if (tcp->first == 1) {
+		
+		/* Initialization PPT */
+		opj_tccp_t *tmp = tcp->tccps;
+		memcpy(tcp, j3d->default_tcp, sizeof(opj_tcp_t));
+		tcp->ppt = 0;
+		tcp->ppt_data = NULL;
+		tcp->ppt_data_first = NULL;
+		tcp->tccps = tmp;
+
+		for (i = 0; i < j3d->volume->numcomps; i++) {
+			tcp->tccps[i] = j3d->default_tcp->tccps[i];
+		}
+		cp->tcps[j3d->curtileno].first = 0;
+	}
+}
+
+static void j3d_write_sod(opj_j3d_t *j3d, void *tile_coder) {
+	int l, layno;
+	int totlen;
+	opj_tcp_t *tcp = NULL;
+	opj_volume_info_t *volume_info = NULL;
+	
+	opj_tcd_t *tcd = (opj_tcd_t*)tile_coder;	/* cast is needed because of conflicts in header inclusions */
+	opj_cp_t *cp = j3d->cp;
+	opj_cio_t *cio = j3d->cio;
+	
+	cio_write(cio, J3D_MS_SOD, 2);
+	if (j3d->curtileno == 0) {
+		j3d->sod_start = cio_tell(cio) + j3d->pos_correction;
+	}
+	
+	/* INDEX >> */
+	volume_info = j3d->volume_info;
+	if (volume_info && volume_info->index_on) {
+		volume_info->tile[j3d->curtileno].end_header = cio_tell(cio) + j3d->pos_correction - 1;
+	}
+	/* << INDEX */
+	
+	tcp = &cp->tcps[j3d->curtileno];
+	for (layno = 0; layno < tcp->numlayers; layno++) {
+		tcp->rates[layno] -= tcp->rates[layno] ? (j3d->sod_start / (cp->th * cp->tw * cp->tl)) : 0;
+	}
+	
+	if(volume_info) {
+		volume_info->num = 0;
+	}
+
+	l = tcd_encode_tile(tcd, j3d->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, volume_info);
+	
+	/* Writing Psot in SOT marker */
+	totlen = cio_tell(cio) + l - j3d->sot_start;
+	cio_seek(cio, j3d->sot_start + 6);
+	cio_write(cio, totlen, 4);
+	cio_seek(cio, j3d->sot_start + totlen);
+}
+
+static void j3d_read_sod(opj_j3d_t *j3d) {
+	int len, truncate = 0, i;
+	unsigned char *data = NULL, *data_ptr = NULL;
+
+	opj_cio_t *cio = j3d->cio;
+	int curtileno = j3d->curtileno;
+	
+	len = int_min(j3d->eot - cio_getbp(cio), cio_numbytesleft(cio) + 1);
+	
+	if (len == cio_numbytesleft(cio) + 1) {
+		truncate = 1;		/* Case of a truncate codestream */
+	}
+	
+	data = (unsigned char *) opj_malloc((j3d->tile_len[curtileno] + len) * sizeof(unsigned char));
+
+	for (i = 0; i < j3d->tile_len[curtileno]; i++) {
+		data[i] = j3d->tile_data[curtileno][i];
+	}
+
+	data_ptr = data + j3d->tile_len[curtileno];
+	for (i = 0; i < len; i++) {
+		data_ptr[i] = cio_read(cio, 1);
+	}
+	
+	j3d->tile_len[curtileno] += len;
+	opj_free(j3d->tile_data[curtileno]);
+	j3d->tile_data[curtileno] = data;
+	
+	if (!truncate) {
+		j3d->state = J3D_STATE_TPHSOT;
+	} else {
+		j3d->state = J3D_STATE_NEOC;	/* RAJOUTE !! */
+	}
+}
+
+static void j3d_write_rgn(opj_j3d_t *j3d, int compno, int tileno) {
+	
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	opj_cio_t *cio = j3d->cio;
+	int numcomps = j3d->volume->numcomps;
+	
+	cio_write(cio, J3D_MS_RGN, 2);						/* RGN  */
+	cio_write(cio, numcomps <= 256 ? 5 : 6, 2);			/* Lrgn */
+	cio_write(cio, compno, numcomps <= 256 ? 1 : 2);	/* Crgn */
+	cio_write(cio, 0, 1);								/* Srgn */
+	cio_write(cio, tcp->tccps[compno].roishift, 1);		/* SPrgn */
+}
+
+static void j3d_read_rgn(opj_j3d_t *j3d) {
+	int len, compno, roisty;
+
+	opj_cp_t *cp = j3d->cp;
+	opj_tcp_t *tcp = j3d->state == J3D_STATE_TPH ? &cp->tcps[j3d->curtileno] : j3d->default_tcp;
+	opj_cio_t *cio = j3d->cio;
+	int numcomps = j3d->volume->numcomps;
+
+	len = cio_read(cio, 2);										/* Lrgn */
+	compno = cio_read(cio, numcomps <= 256 ? 1 : 2);			/* Crgn */
+	roisty = cio_read(cio, 1);									/* Srgn */
+	tcp->tccps[compno].roishift = cio_read(cio, 1);				/* SPrgn */
+}
+
+static void j3d_write_eoc(opj_j3d_t *j3d) {
+	opj_cio_t *cio = j3d->cio;
+	/* opj_event_msg(j3d->cinfo, "%.8x: EOC\n", cio_tell(cio) + j3d->pos_correction); */
+	cio_write(cio, J3D_MS_EOC, 2);
+}
+
+static void j3d_read_eoc(opj_j3d_t *j3d) {
+	int i, tileno;
+
+#ifndef NO_PACKETS_DECODING  
+	opj_tcd_t *tcd = tcd_create(j3d->cinfo);
+    tcd_malloc_decode(tcd, j3d->volume, j3d->cp);
+	/*j3d_dump_volume(stdout, tcd->volume);
+	j3d_dump_cp(stdout, tcd->volume, tcd->cp);*/
+	for (i = 0; i < j3d->cp->tileno_size; i++) {
+		tileno = j3d->cp->tileno[i];
+		//opj_event_msg(j3d->cinfo, EVT_INFO, "tcd_decode_tile \n");
+		tcd_decode_tile(tcd, j3d->tile_data[tileno], j3d->tile_len[tileno], tileno);
+		opj_free(j3d->tile_data[tileno]);
+		j3d->tile_data[tileno] = NULL;
+	}
+	tcd_free_decode(tcd);
+	tcd_destroy(tcd);
+#else 
+	for (i = 0; i < j3d->cp->tileno_size; i++) {
+		tileno = j3d->cp->tileno[i];
+		opj_free(j3d->tile_data[tileno]);
+		j3d->tile_data[tileno] = NULL;
+	}
+#endif
+	
+	j3d->state = J3D_STATE_MT;
+}
+
+static void j3d_read_unk(opj_j3d_t *j3d) {
+	opj_event_msg(j3d->cinfo, EVT_WARNING, "Unknown marker\n");
+}
+
+static opj_atk_t atk_info_wt[] = {
+	{0, 1, J3D_ATK_WS, J3D_ATK_IRR, 0, J3D_ATK_WS, 1.230174104, 4, {0}, {0}, {0}, {1,1,1,1}, {-1.586134342059924, -0.052980118572961, 0.882911075530934, 0.443506852043971}},/* WT 9-7 IRR*/
+	{1, 0, J3D_ATK_WS, J3D_ATK_REV, 0, J3D_ATK_WS, 0, 2, {0}, {1,2}, {1,2}, {1,1}, {-1.0,1.0}},/* WT 5-3 REV*/
+	{2, 0, J3D_ATK_ARB, J3D_ATK_REV, 0, J3D_ATK_CON, 0, 2, {0,0}, {0,1}, {0,1}, {1,1}, {{-1.0},{1.0}}}, /* WT 2-2 REV*/
+	{3, 0, J3D_ATK_ARB, J3D_ATK_REV, 1, J3D_ATK_CON, 0, 3, {0,0,-1}, {0,1,2}, {0,1,2}, {1,1,3}, {{-1.0},{1.0},{1.0,0.0,-1.0}}}, /* WT 2-6 REV*/
+	{4, 0, J3D_ATK_ARB, J3D_ATK_REV, 1, J3D_ATK_CON, 0, 3, {0,0,-2}, {0,1,6}, {0,1,32}, {1,1,5}, {{-1},{1},{-3.0,22.0,0.0,-22.0,3.0}}}, /* WT 2-10 REV*/
+	{5, 1, J3D_ATK_ARB, J3D_ATK_IRR, 1, J3D_ATK_WS, 1, 7, {0}, {0}, {0}, {1,1,2,1,2,1,3},{{-1},{1.58613434206},{-0.460348209828, 0.460348209828},{0.25},{0.374213867768,-0.374213867768},{-1.33613434206},{0.29306717103,0,-0.29306717103}}}, /* WT 6-10 IRR*/
+	{6, 1, J3D_ATK_ARB, J3D_ATK_IRR, 0, J3D_ATK_WS, 1, 11, {0}, {0}, {0}, {1,1,2,1,2,1,2,1,2,1,5},{{-1},{0,99715069105},{-1.00573127827, 1.00573127827},{-0.27040357631},{2.20509972343, -2.20509972343},{0.08059995736},
+		{-1.62682532350, 1.62682532350},{0.52040357631},{0.60404664250, -0.60404664250},{-0.82775064841},{-0.06615812964, 0.29402137720, 0, -0.29402137720, 0.06615812964}}}, /* WT 10-18 IRR*/
+	{7, 1, J3D_ATK_WS, J3D_ATK_IRR, 0, J3D_ATK_WS, 1, 2, {0}, {0}, {0}, {1,1}, {-0.5, 0.25}},	/* WT 5-3 IRR*/
+	{8, 0, J3D_ATK_WS, J3D_ATK_REV, 0, J3D_ATK_WS, 0, 2, {0}, {4,4}, {8,8}, {2,2}, {{-9,1},{5,-1}}}		/* WT 13-7 REV*/
+};
+
+typedef struct opj_dec_mstabent {
+	/** marker value */
+	int id;
+	/** value of the state when the marker can appear */
+	int states;
+	/** action linked to the marker */
+	void (*handler) (opj_j3d_t *j3d);
+} opj_dec_mstabent_t;
+
+opj_dec_mstabent_t j3d_dec_mstab[] = {
+  {J3D_MS_SOC, J3D_STATE_MHSOC, j3d_read_soc},
+  {J3D_MS_SOT, J3D_STATE_MH | J3D_STATE_TPHSOT, j3d_read_sot},
+  {J3D_MS_SOD, J3D_STATE_TPH, j3d_read_sod},
+  {J3D_MS_EOC, J3D_STATE_TPHSOT, j3d_read_eoc},
+  {J3D_MS_CAP, J3D_STATE_MHSIZ, j3d_read_cap},
+  {J3D_MS_SIZ, J3D_STATE_MHSIZ, j3d_read_siz},
+  {J3D_MS_ZSI, J3D_STATE_MHSIZ, j3d_read_zsi},
+  {J3D_MS_COD, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_cod},
+  {J3D_MS_COC, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_coc},
+  {J3D_MS_RGN, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_rgn},
+  {J3D_MS_QCD, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_qcd},
+  {J3D_MS_QCC, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_qcc},
+  {J3D_MS_POC, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_poc},
+  {J3D_MS_TLM, J3D_STATE_MH, j3d_read_tlm},
+  {J3D_MS_PLM, J3D_STATE_MH, j3d_read_plm},
+  {J3D_MS_PLT, J3D_STATE_TPH, j3d_read_plt},
+  {J3D_MS_PPM, J3D_STATE_MH, j3d_read_ppm},
+  {J3D_MS_PPT, J3D_STATE_TPH, j3d_read_ppt},
+  {J3D_MS_SOP, 0, 0},
+  {J3D_MS_CRG, J3D_STATE_MH, j3d_read_crg},
+  {J3D_MS_COM, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_com},
+  {J3D_MS_DCO, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_dco},
+  {J3D_MS_ATK, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_atk},
+  {0, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_unk}
+  /*, -->must define the j3d_read functions
+  {J3D_MS_CBD, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_cbd},
+  {J3D_MS_MCT, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_mct},
+  {J3D_MS_MCC, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_mcc},
+  {J3D_MS_MCO, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_mco},
+  {J3D_MS_NLT, J3D_STATE_MH | J3D_STATE_TPH, j3d_read_nlt},
+  {J3D_MS_VMS, J3D_STATE_MH, j3d_read_vms},
+  {J3D_MS_DFS, J3D_STATE_MH, j3d_read_dfs},
+  {J3D_MS_ADS, J3D_STATE_MH, j3d_read_ads},
+  {J3D_MS_QPD, J3D_STATE_MH, j3d_read_qpd},
+  {J3D_MS_QPC, J3D_STATE_TPH, j3d_read_qpc}*/
+};
+
+/**
+Read the lookup table containing all the marker, status and action
+@param id Marker value
+*/
+static opj_dec_mstabent_t *j3d_dec_mstab_lookup(int id) {
+	opj_dec_mstabent_t *e;
+	for (e = j3d_dec_mstab; e->id != 0; e++) {
+		if (e->id == id) {
+			break;
+		}
+	}
+	return e;
+}
+
+/* ----------------------------------------------------------------------- */
+/* J3D / JPT decoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+opj_j3d_t* j3d_create_decompress(opj_common_ptr cinfo) {
+	opj_j3d_t *j3d = (opj_j3d_t*)opj_malloc(sizeof(opj_j3d_t));
+	if(j3d) {
+		j3d->cinfo = cinfo;
+		j3d->default_tcp = (opj_tcp_t*)opj_malloc(sizeof(opj_tcp_t));
+		if(!j3d->default_tcp) {
+			opj_free(j3d);
+			return NULL;
+		}
+	}
+	return j3d;
+}
+
+void j3d_destroy_decompress(opj_j3d_t *j3d) {
+	int i = 0;
+
+	if(j3d->tile_len != NULL) {
+		opj_free(j3d->tile_len);
+	}
+	if(j3d->tile_data != NULL) {
+		opj_free(j3d->tile_data);
+	}
+	if(j3d->default_tcp != NULL) {
+		opj_tcp_t *default_tcp = j3d->default_tcp;
+		if(default_tcp->ppt_data_first != NULL) {
+			opj_free(default_tcp->ppt_data_first);
+		}
+		if(j3d->default_tcp->tccps != NULL) {
+			opj_free(j3d->default_tcp->tccps);
+		}
+		opj_free(j3d->default_tcp);
+	}
+	if(j3d->cp != NULL) {
+		opj_cp_t *cp = j3d->cp;
+		if(cp->tcps != NULL) {
+			for(i = 0; i < cp->tw * cp->th * cp->tl; i++) {
+				if(cp->tcps[i].ppt_data_first != NULL) {
+					opj_free(cp->tcps[i].ppt_data_first);
+				}
+				if(cp->tcps[i].tccps != NULL) {
+					opj_free(cp->tcps[i].tccps);
+				}
+			}
+			opj_free(cp->tcps);
+		}
+		if(cp->ppm_data_first != NULL) {
+			opj_free(cp->ppm_data_first);
+		}
+		if(cp->tileno != NULL) {
+			opj_free(cp->tileno);  
+		}
+		if(cp->comment != NULL) {
+			opj_free(cp->comment);
+		}
+
+		opj_free(cp);
+	}
+
+	opj_free(j3d);
+}
+
+void j3d_setup_decoder(opj_j3d_t *j3d, opj_dparameters_t *parameters) {
+	if(j3d && parameters) {
+		/* create and initialize the coding parameters structure */
+		opj_cp_t *cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+		cp->reduce[0] = parameters->cp_reduce[0];
+		cp->reduce[1] = parameters->cp_reduce[1];
+		cp->reduce[2] = parameters->cp_reduce[2];
+		cp->layer = parameters->cp_layer;
+		cp->bigendian = parameters->bigendian;
+		
+		
+		cp->encoding_format = ENCOD_2EB;
+		cp->transform_format = TRF_2D_DWT;
+		
+		/* keep a link to cp so that we can destroy it later in j3d_destroy_decompress */
+		j3d->cp = cp;
+	}
+}
+
+opj_volume_t* j3d_decode(opj_j3d_t *j3d, opj_cio_t *cio) {
+	opj_volume_t *volume = NULL;
+
+	opj_common_ptr cinfo = j3d->cinfo;
+
+	j3d->cio = cio;
+
+	/* create an empty volume */
+	volume = (opj_volume_t*)opj_malloc(sizeof(opj_volume_t));
+	j3d->volume = volume;
+
+	j3d->state = J3D_STATE_MHSOC;
+	
+	for (;;) {
+		opj_dec_mstabent_t *e;
+		int id = cio_read(cio, 2);
+		if (id >> 8 != 0xff) {
+			opj_volume_destroy(volume);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		e = j3d_dec_mstab_lookup(id);
+		//opj_event_msg(cinfo, EVT_INFO, "MARKER %x PREVSTATE %d E->STATE %d\n",e->id,j3d->state,e->states);
+		if (!(j3d->state & e->states)) {
+			opj_volume_destroy(volume);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: unexpected marker %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		if (e->handler) {
+			(*e->handler)(j3d);
+		}
+		//opj_event_msg(cinfo, EVT_INFO, "POSTSTATE %d\n",j3d->state);
+		if (j3d->state == J3D_STATE_MT) {
+			break;
+		}
+		if (j3d->state == J3D_STATE_NEOC) {
+			break;
+		}
+	}
+	if (j3d->state == J3D_STATE_NEOC) {
+		j3d_read_eoc(j3d);
+	}
+
+	if (j3d->state != J3D_STATE_MT) {
+		opj_event_msg(cinfo, EVT_WARNING, "Incomplete bitstream\n");
+	}
+	
+	return volume;
+}
+
+/* ----------------------------------------------------------------------- */
+/* J3D encoder interface                                                       */
+/* ----------------------------------------------------------------------- */
+
+opj_j3d_t* j3d_create_compress(opj_common_ptr cinfo) {
+	opj_j3d_t *j3d = (opj_j3d_t*)opj_malloc(sizeof(opj_j3d_t));
+	if(j3d) {
+		j3d->cinfo = cinfo;
+	}
+	return j3d;
+}
+
+void j3d_destroy_compress(opj_j3d_t *j3d) {
+	int tileno;
+
+	if(!j3d) return;
+
+	if(j3d->volume_info != NULL) {
+		opj_volume_info_t *volume_info = j3d->volume_info;
+		if (volume_info->index_on && j3d->cp) {
+			opj_cp_t *cp = j3d->cp;
+			for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+				opj_tile_info_t *tile_info = &volume_info->tile[tileno];
+				opj_free(tile_info->thresh);
+				opj_free(tile_info->packet);
+			}
+			opj_free(volume_info->tile);
+		}
+		opj_free(volume_info);
+	}
+	if(j3d->cp != NULL) {
+		opj_cp_t *cp = j3d->cp;
+
+		if(cp->comment) {
+			opj_free(cp->comment);
+		}
+		if(cp->matrice) {
+			opj_free(cp->matrice);
+		}
+		for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+			opj_free(cp->tcps[tileno].tccps);
+		}
+		opj_free(cp->tcps);
+		opj_free(cp);
+	}
+
+	opj_free(j3d);
+}
+
+void j3d_setup_encoder(opj_j3d_t *j3d, opj_cparameters_t *parameters, opj_volume_t *volume) {
+	int i, j, tileno, numpocs_tile;
+	opj_cp_t *cp = NULL;
+
+	if(!j3d || !parameters || ! volume) {
+		return;
+	}
+
+	/* create and initialize the coding parameters structure */
+	cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+
+	/* keep a link to cp so that we can destroy it later in j3d_destroy_compress */
+	j3d->cp = cp;
+
+	/* set default values for cp */
+	cp->tw = 1;
+	cp->th = 1;
+	cp->tl = 1;
+
+	/* copy user encoding parameters */
+	cp->disto_alloc = parameters->cp_disto_alloc;
+	cp->fixed_alloc = parameters->cp_fixed_alloc;
+	cp->fixed_quality = parameters->cp_fixed_quality;
+
+	/* transform and coding method */
+	cp->transform_format = parameters->transform_format;
+	cp->encoding_format = parameters->encoding_format;
+
+	/* mod fixed_quality */
+	if(parameters->cp_matrice) {
+		size_t array_size = parameters->tcp_numlayers * 3 * parameters->numresolution[0] * sizeof(int);
+		cp->matrice = (int *) opj_malloc(array_size);
+		memcpy(cp->matrice, parameters->cp_matrice, array_size);
+	} 
+
+	/* creation of an index file ? */
+	cp->index_on = parameters->index_on;
+	if(cp->index_on) {
+		j3d->volume_info = (opj_volume_info_t*)opj_malloc(sizeof(opj_volume_info_t));
+	}
+	
+	/* tiles */
+	cp->tdx = parameters->cp_tdx;
+	cp->tdy = parameters->cp_tdy;
+	cp->tdz = parameters->cp_tdz;
+	/* tile offset */
+	cp->tx0 = parameters->cp_tx0;
+	cp->ty0 = parameters->cp_ty0;
+	cp->tz0 = parameters->cp_tz0;
+	/* comment string */
+	if(parameters->cp_comment) {
+		cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1);
+		if(cp->comment) {
+			strcpy(cp->comment, parameters->cp_comment);
+		}
+	}
+
+	/*calculate other encoding parameters*/
+	if (parameters->tile_size_on) {
+		cp->tw = int_ceildiv(volume->x1 - cp->tx0, cp->tdx);
+		cp->th = int_ceildiv(volume->y1 - cp->ty0, cp->tdy);
+		cp->tl = int_ceildiv(volume->z1 - cp->tz0, cp->tdz);
+	} else {
+		cp->tdx = volume->x1 - cp->tx0;
+		cp->tdy = volume->y1 - cp->ty0;
+		cp->tdz = volume->z1 - cp->tz0;
+	}
+
+	/* initialize the multiple tiles */
+	/* ---------------------------- */
+	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(opj_tcp_t));
+
+	for (tileno = 0; tileno < cp->tw * cp->th * cp->tl; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		tcp->numlayers = parameters->tcp_numlayers;
+		for (j = 0; j < tcp->numlayers; j++) {
+			if (cp->fixed_quality) {	/* add fixed_quality */
+				tcp->distoratio[j] = parameters->tcp_distoratio[j];
+			} else {
+				tcp->rates[j] = parameters->tcp_rates[j];
+			}
+		}
+		tcp->csty = parameters->csty;
+		tcp->prg = parameters->prog_order;
+		tcp->mct = volume->numcomps == 3 ? 1 : 0;
+
+		numpocs_tile = 0;
+		tcp->POC = 0;
+		if (parameters->numpocs) {
+			/* initialisation of POC */
+			tcp->POC = 1;
+			for (i = 0; i < parameters->numpocs; i++) {
+				if((tileno == parameters->POC[i].tile - 1) || (parameters->POC[i].tile == -1)) {
+					opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];
+					tcp_poc->resno0		= parameters->POC[numpocs_tile].resno0;
+					tcp_poc->compno0	= parameters->POC[numpocs_tile].compno0;
+					tcp_poc->layno1		= parameters->POC[numpocs_tile].layno1;
+					tcp_poc->resno1		= parameters->POC[numpocs_tile].resno1;
+					tcp_poc->compno1	= parameters->POC[numpocs_tile].compno1;
+					tcp_poc->prg		= parameters->POC[numpocs_tile].prg;
+					tcp_poc->tile		= parameters->POC[numpocs_tile].tile;
+					numpocs_tile++;
+				}
+			}
+		}
+		tcp->numpocs = numpocs_tile;
+
+		tcp->tccps = (opj_tccp_t *) opj_malloc(volume->numcomps * sizeof(opj_tccp_t));
+		
+		for (i = 0; i < volume->numcomps; i++) {
+			opj_tccp_t *tccp = &tcp->tccps[i];
+			tccp->csty = parameters->csty & J3D_CCP_CSTY_PRT;	/* 0 => standard precint || 1 => custom-defined precinct  */
+			tccp->numresolution[0] = parameters->numresolution[0];
+			tccp->numresolution[1] = parameters->numresolution[1];
+			tccp->numresolution[2] = parameters->numresolution[2];
+						assert (parameters->cblock_init[0] <= T1_MAXCBLKW);
+						assert (parameters->cblock_init[0] >= T1_MINCBLKW);
+						assert (parameters->cblock_init[1] <= T1_MAXCBLKH);
+						assert (parameters->cblock_init[1] >= T1_MINCBLKH);
+						assert (parameters->cblock_init[2] <= T1_MAXCBLKD);
+						assert (parameters->cblock_init[2] >= T1_MINCBLKD);
+			tccp->cblk[0] = int_floorlog2(parameters->cblock_init[0]); 
+			tccp->cblk[1] = int_floorlog2(parameters->cblock_init[1]); 
+			tccp->cblk[2] = int_floorlog2(parameters->cblock_init[2]); 
+						assert (tccp->cblk[0]+tccp->cblk[1]+tccp->cblk[1] <= T1_MAXWHD);
+			tccp->cblksty = parameters->mode; //Codeblock style --> Table A.19 (default 0)
+
+			/*ATK / transform */
+			tccp->reversible = parameters->irreversible ? 0 : 1; /* 0 => DWT 9-7 || 1 => DWT 5-3  */
+			for (j = 0; j < 3; j++) {
+					tccp->dwtid[j] = parameters->irreversible ? 0 : 1; /* 0 => DWT 9-7 || 1 => DWT 5-3  */
+			}
+      						
+			/* Quantification: SEQNT (Scalar Expounded, value for each subband) / NOQNT (no quant)*/
+			tccp->qntsty = parameters->irreversible ? J3D_CCP_QNTSTY_SEQNT : J3D_CCP_QNTSTY_NOQNT;
+			tccp->numgbits = 2;
+			if (i == parameters->roi_compno) {
+				tccp->roishift = parameters->roi_shift;
+			} else {
+				tccp->roishift = 0;
+			}
+			/* Custom defined precints */
+			if (parameters->csty & J3D_CCP_CSTY_PRT) {
+				int k;
+				for (k = 0; k < 3; k++) {
+					int p = 0;
+					for (j = tccp->numresolution[k] - 1; j >= 0; j--) {
+						if (p < parameters->res_spec) {/* p < number of precinct size specifications */
+							if (parameters->prct_init[k][p] < 1) {
+								tccp->prctsiz[k][j] = 1;
+							} else {
+								tccp->prctsiz[k][j] = int_floorlog2(parameters->prct_init[k][p]);
+							}
+						} else {
+							int res_spec = parameters->res_spec;
+							int size_prct = parameters->prct_init[k][res_spec - 1] >> (p - (res_spec - 1));
+							if (size_prct < 1) {
+								tccp->prctsiz[k][j] = 1;
+							} else {
+								tccp->prctsiz[k][j] = int_floorlog2(size_prct);
+							}
+						}
+					}
+					p++;
+				}
+			} else {
+				int k;
+				for (k = 0; k < 3; k++) {
+                    for (j = 0; j < tccp->numresolution[k]; j++) {
+                        tccp->prctsiz[k][j] = 15;
+					}
+				}
+			}
+			//Calcular stepsize for each subband (if NOQNT -->stepsize = 1.0)
+			dwt_calc_explicit_stepsizes(tccp, volume->comps[i].prec);
+		}
+	}
+}
+
+/**
+Create an index file
+@param j3d
+@param cio
+@param volume_info
+@param index Index filename
+@return Returns 1 if successful, returns 0 otherwise
+*/
+static int j3d_create_index(opj_j3d_t *j3d, opj_cio_t *cio, opj_volume_info_t *volume_info, char *index) {
+	
+	int tileno, compno, layno, resno, precno, pack_nb, x, y, z;
+	FILE *stream = NULL;
+	double total_disto = 0;
+
+	volume_info->codestream_size = cio_tell(cio) + j3d->pos_correction;	/* Correction 14/4/03 suite rmq de Patrick */
+
+	stream = fopen(index, "w");
+	if (!stream) {
+		opj_event_msg(j3d->cinfo, EVT_ERROR, "failed to open %s for writing\n", index);
+		return 0;
+	}
+	
+	fprintf(stream, "w %d\t h %d\t l %d\n", volume_info->volume_w, volume_info->volume_h, volume_info->volume_l);
+	fprintf(stream, "TRASNFORM\t%d\n", volume_info->transform_format);
+	fprintf(stream, "ENTROPY CODING\t%d\n", volume_info->encoding_format);
+	fprintf(stream, "PROG\t%d\n", volume_info->prog);
+	fprintf(stream, "TILE\tx %d y %d z %d\n", volume_info->tile_x, volume_info->tile_y, volume_info->tile_z);
+	fprintf(stream, "NOTILE\tx %d y %d z %d\n", volume_info->tw, volume_info->th, volume_info->tl);
+	fprintf(stream, "COMPONENTS\t%d\n", volume_info->comp);
+	fprintf(stream, "LAYER\t%d\n", volume_info->layer);
+	fprintf(stream, "RESOLUTIONS\tx %d y %d z %d\n", volume_info->decomposition[0], volume_info->decomposition[1], volume_info->decomposition[2]);
+	
+	fprintf(stream, "Precint sizes for each resolution:\n");
+	for (resno = volume_info->decomposition[0]; resno >= 0; resno--) {
+		fprintf(stream, "Resno %d \t [%d,%d,%d] \n", resno,
+			(1 << volume_info->tile[0].prctsiz[0][resno]), (1 << volume_info->tile[0].prctsiz[0][resno]), (1 << volume_info->tile[0].prctsiz[2][resno]));	/* based on tile 0 */
+	}
+	fprintf(stream, "HEADER_END\t%d\n", volume_info->main_head_end);
+	fprintf(stream, "CODESTREAM\t%d\n", volume_info->codestream_size);
+	fprintf(stream, "Num_tile Start_pos End_header End_pos Distotile Nbpix Ratio\n");
+	for (tileno = 0; tileno < (volume_info->tw * volume_info->th * volume_info->tl); tileno++) {
+		fprintf(stream, "%4d\t%9d\t%9d\t%9d\t%9e\t%9d\t%9e\n",
+			volume_info->tile[tileno].num_tile,
+			volume_info->tile[tileno].start_pos,
+			volume_info->tile[tileno].end_header,
+			volume_info->tile[tileno].end_pos,
+			volume_info->tile[tileno].distotile, volume_info->tile[tileno].nbpix,
+			volume_info->tile[tileno].distotile / volume_info->tile[tileno].nbpix);
+	}
+	
+	for (tileno = 0; tileno < (volume_info->tw * volume_info->th * volume_info->tl); tileno++) {
+		int start_pos, end_pos;
+		double disto = 0;
+		pack_nb = 0;
+		if (volume_info->prog == LRCP) {	/* LRCP */
+			fprintf(stream, "pack_nb tileno layno resno compno precno start_pos  end_pos   disto\n");
+			for (layno = 0; layno < volume_info->layer; layno++) {
+				for (resno = 0; resno < volume_info->decomposition[0] + 1; resno++) {
+					for (compno = 0; compno < volume_info->comp; compno++) {
+						int prec_max = volume_info->tile[tileno].prctno[0][resno] * volume_info->tile[tileno].prctno[1][resno] * volume_info->tile[tileno].prctno[2][resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = volume_info->tile[tileno].packet[pack_nb].start_pos;
+							end_pos = volume_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = volume_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %7d %5d %6d %6d %9d %9d %8e\n",pack_nb, tileno, layno, resno, compno, precno, start_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* LRCP */
+		else if (volume_info->prog == RLCP) {	/* RLCP */
+			/*
+			fprintf(stream, "pack_nb tileno resno layno compno precno start_pos  end_pos   disto");
+			*/
+			for (resno = 0; resno < volume_info->decomposition[0] + 1; resno++) {
+				for (layno = 0; layno < volume_info->layer; layno++) {
+					for (compno = 0; compno < volume_info->comp; compno++) {
+						int prec_max = volume_info->tile[tileno].prctno[0][resno] * volume_info->tile[tileno].prctno[1][resno]* volume_info->tile[tileno].prctno[2][resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = volume_info->tile[tileno].packet[pack_nb].start_pos;
+							end_pos = volume_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = volume_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d %9d %8e\n",
+								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* RLCP */
+		else if (volume_info->prog == RPCL) {	/* RPCL */
+			/*
+			fprintf(stream, "\npack_nb tileno resno precno compno layno start_pos  end_pos   disto\n"); 
+			*/
+			for (resno = 0; resno < volume_info->decomposition[0] + 1; resno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				//int x0 = volume_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tw * volume_info->tile_x;
+				//int y0 = volume_info->tile_Ox + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_y;
+				int x0 = volume_info->tile_Ox + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_x;
+				int y0 = volume_info->tile_Oy + (int)floor( (float)tileno/(float)volume_info->th ) * volume_info->tile_y;
+				int z0 = volume_info->tile_Ox + (int)floor( (float)tileno/(float)volume_info->tl ) * volume_info->tile_z;
+				int x1 = x0 + volume_info->tile_x;
+				int y1 = y0 + volume_info->tile_y;
+				int z1 = z0 + volume_info->tile_z;
+				for(z = z0; z < z1; z++) {
+					for(y = y0; y < y1; y++) {
+						for(x = x0; x < x1; x++) {
+							for (compno = 0; compno < volume_info->comp; compno++) {
+								int prec_max = volume_info->tile[tileno].prctno[0][resno] * volume_info->tile[tileno].prctno[1][resno] * volume_info->tile[tileno].prctno[2][resno];
+								for (precno = 0; precno < prec_max; precno++) {
+									int pcnx = volume_info->tile[tileno].prctno[0][resno];
+									int pcx = (int) pow( 2, volume_info->tile[tileno].prctsiz[0][resno] + volume_info->decomposition[0] - resno );
+									int pcy = (int) pow( 2, volume_info->tile[tileno].prctsiz[1][resno] + volume_info->decomposition[1] - resno );
+									int pcz = (int) pow( 2, volume_info->tile[tileno].prctsiz[2][resno] + volume_info->decomposition[2] - resno );
+									int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+									int precno_y = (int) floor( (float)precno/(float)pcnx );
+									if (precno_y*pcy == y ) {
+										if (precno_x*pcx == x ) {
+											for (layno = 0; layno < volume_info->layer; layno++) {
+												start_pos = volume_info->tile[tileno].packet[pack_nb].start_pos;
+												end_pos = volume_info->tile[tileno].packet[pack_nb].end_pos;
+												disto = volume_info->tile[tileno].packet[pack_nb].disto;
+												fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d %9d %8e\n",
+													pack_nb, tileno, resno, precno, compno, layno, start_pos, end_pos, disto); 
+												total_disto += disto;
+												pack_nb++; 
+											}
+										}
+									}
+								} /* precno */
+							} /* compno */
+						} /* x = x0..x1 */
+					} /* y = y0..y1 */
+				} /* z = z0..z1 */
+			} /* resno */
+		} /* RPCL */
+		else if (volume_info->prog == PCRL) {	/* PCRL */
+			/* I suppose components have same XRsiz, YRsiz */
+			int x0 = volume_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tw * volume_info->tile_x;
+			int y0 = volume_info->tile_Ox + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_y;
+			int z0 = volume_info->tile_Oz + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_z;
+			int x1 = x0 + volume_info->tile_x;
+			int y1 = y0 + volume_info->tile_y;
+			int z1 = z0 + volume_info->tile_z;
+			/*
+			fprintf(stream, "\npack_nb tileno precno compno resno layno start_pos  end_pos   disto\n"); 
+			*/
+			for(z = z0; z < z1; z++) {
+				for(y = y0; y < y1; y++) {
+					for(x = x0; x < x1; x++) {
+						for (compno = 0; compno < volume_info->comp; compno++) {
+							for (resno = 0; resno < volume_info->decomposition[0] + 1; resno++) {
+								int prec_max = volume_info->tile[tileno].prctno[0][resno] * volume_info->tile[tileno].prctno[1][resno];
+								for (precno = 0; precno < prec_max; precno++) {
+								int pcnx = volume_info->tile[tileno].prctno[0][resno];
+								int pcx = (int) pow( 2, volume_info->tile[tileno].prctsiz[0][resno] + volume_info->decomposition[0] - resno );
+								int pcy = (int) pow( 2, volume_info->tile[tileno].prctsiz[1][resno] + volume_info->decomposition[1] - resno );
+								int pcz = (int) pow( 2, volume_info->tile[tileno].prctsiz[2][resno] + volume_info->decomposition[2] - resno );
+								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+								int precno_y = (int) floor( (float)precno/(float)pcnx );
+								int precno_z = (int) floor( (float)precno/(float)pcnx );
+								if (precno_z*pcz == z ) {
+									if (precno_y*pcy == y ) {
+										if (precno_x*pcx == x ) {
+											for (layno = 0; layno < volume_info->layer; layno++) {
+												start_pos = volume_info->tile[tileno].packet[pack_nb].start_pos;
+												end_pos = volume_info->tile[tileno].packet[pack_nb].end_pos;
+												disto = volume_info->tile[tileno].packet[pack_nb].disto;
+												fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
+													pack_nb, tileno, precno, compno, resno, layno, start_pos, end_pos, disto); 
+												total_disto += disto;
+												pack_nb++; 
+											}
+										}
+									}
+								}
+							} /* precno */
+						} /* resno */
+					} /* compno */
+				} /* x = x0..x1 */
+			} /* y = y0..y1 */
+			}
+		} /* PCRL */
+		else {	/* CPRL */
+			/*
+			fprintf(stream, "\npack_nb tileno compno precno resno layno start_pos  end_pos   disto\n"); 
+			*/
+			for (compno = 0; compno < volume_info->comp; compno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = volume_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tw * volume_info->tile_x;
+				int y0 = volume_info->tile_Ox + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_y;
+				int z0 = volume_info->tile_Oz + (int)floor( (float)tileno/(float)volume_info->tw ) * volume_info->tile_z;
+				int x1 = x0 + volume_info->tile_x;
+				int y1 = y0 + volume_info->tile_y;
+				int z1 = z0 + volume_info->tile_z;
+				for(z = z0; z < z1; z++) {
+					for(y = y0; y < y1; y++) {
+						for(x = x0; x < x1; x++) {
+							for (resno = 0; resno < volume_info->decomposition[0] + 1; resno++) {
+								int prec_max = volume_info->tile[tileno].prctno[0][resno] * volume_info->tile[tileno].prctno[1][resno] * volume_info->tile[tileno].prctno[2][resno];
+								for (precno = 0; precno < prec_max; precno++) {
+									int pcnx = volume_info->tile[tileno].prctno[0][resno];
+									int pcny = volume_info->tile[tileno].prctno[1][resno];
+									int pcx = (int) pow( 2, volume_info->tile[tileno].prctsiz[0][resno] + volume_info->decomposition[0] - resno );
+									int pcy = (int) pow( 2, volume_info->tile[tileno].prctsiz[1][resno] + volume_info->decomposition[1] - resno );
+									int pcz = (int) pow( 2, volume_info->tile[tileno].prctsiz[2][resno] + volume_info->decomposition[2] - resno );
+									int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+									int precno_y = (int) floor( (float)precno/(float)pcnx );
+									int precno_z = 0; /*???*/
+									if (precno_z*pcz == z ) {
+										if (precno_y*pcy == y ) {
+											if (precno_x*pcx == x ) {
+												for (layno = 0; layno < volume_info->layer; layno++) {
+													start_pos = volume_info->tile[tileno].packet[pack_nb].start_pos;
+													end_pos = volume_info->tile[tileno].packet[pack_nb].end_pos;
+													disto = volume_info->tile[tileno].packet[pack_nb].disto;
+													fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
+														pack_nb, tileno, compno, precno, resno, layno, start_pos, end_pos, disto); 
+													total_disto += disto;
+													pack_nb++; 
+												}
+											}
+										}
+									}
+								} /* precno */
+							} /* resno */
+						} /* x = x0..x1 */
+					} /* y = y0..y1 */
+				} /* z = z0..z1 */
+			} /* comno */
+		} /* CPRL */   
+	} /* tileno */
+	
+	fprintf(stream, "SE_MAX\t%8e\n", volume_info->D_max);	/* SE max */
+	fprintf(stream, "SE_TOTAL\t%.8e\n", total_disto);			/* SE totale */
+	
+
+	fclose(stream);
+
+	return 1;
+}
+
+bool j3d_encode(opj_j3d_t *j3d, opj_cio_t *cio, opj_volume_t *volume, char *index) {
+	int tileno, compno;
+	opj_volume_info_t *volume_info = NULL;
+	opj_cp_t *cp = NULL;
+	opj_tcd_t *tcd = NULL;	/* TCD component */
+
+	j3d->cio = cio;	
+	j3d->volume = volume;
+	cp = j3d->cp;
+
+	/*j3d_dump_volume(stdout, volume);
+	j3d_dump_cp(stdout, volume, cp);*/
+
+	/* INDEX >> */
+	volume_info = j3d->volume_info;
+	if (volume_info && cp->index_on) {
+		volume_info->index_on = cp->index_on;
+		volume_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(opj_tile_info_t));
+		volume_info->volume_w = volume->x1 - volume->x0;
+		volume_info->volume_h = volume->y1 - volume->y0;
+		volume_info->volume_l = volume->z1 - volume->z0;
+		volume_info->prog = (&cp->tcps[0])->prg;
+		volume_info->tw = cp->tw;
+		volume_info->th = cp->th;
+		volume_info->tl = cp->tl;
+		volume_info->tile_x = cp->tdx;	/* new version parser */
+		volume_info->tile_y = cp->tdy;	/* new version parser */
+		volume_info->tile_z = cp->tdz;	/* new version parser */
+		volume_info->tile_Ox = cp->tx0;	/* new version parser */
+		volume_info->tile_Oy = cp->ty0;	/* new version parser */
+		volume_info->tile_Oz = cp->tz0;	/* new version parser */
+		volume_info->transform_format = cp->transform_format;
+		volume_info->encoding_format = cp->encoding_format;
+		volume_info->comp = volume->numcomps;
+		volume_info->layer = (&cp->tcps[0])->numlayers;
+		volume_info->decomposition[0] = (&cp->tcps[0])->tccps->numresolution[0] - 1;
+		volume_info->decomposition[1] = (&cp->tcps[0])->tccps->numresolution[1] - 1;
+		volume_info->decomposition[2] = (&cp->tcps[0])->tccps->numresolution[2] - 1;
+		volume_info->D_max = 0;		/* ADD Marcela */
+	}
+	/* << INDEX */
+
+	j3d_write_soc(j3d);
+	j3d_write_siz(j3d);
+	if (j3d->cinfo->codec_format == CODEC_J3D) {
+		j3d_write_cap(j3d);
+		j3d_write_zsi(j3d);
+	}
+	j3d_write_cod(j3d);
+	j3d_write_qcd(j3d);
+	for (compno = 0; compno < volume->numcomps; compno++) {
+		opj_tcp_t *tcp = &cp->tcps[0];
+		if (tcp->tccps[compno].roishift)
+			j3d_write_rgn(j3d, compno, 0);			
+	}
+	/*Optional 15444-2 markers*/
+	if (j3d->cp->tcps->tccps[0].atk != NULL)
+        j3d_write_atk(j3d);
+	if (j3d->volume->comps[0].dcoffset != 0)
+        j3d_write_dco(j3d);
+
+	if (j3d->cp->transform_format != TRF_2D_DWT || j3d->cp->encoding_format != ENCOD_2EB)
+		j3d_write_com(j3d);
+	
+	/* INDEX >> */
+	if(volume_info && volume_info->index_on) {
+		volume_info->main_head_end = cio_tell(cio) - 1;
+	}
+	/* << INDEX */
+
+	/* create the tile encoder */
+	tcd = tcd_create(j3d->cinfo);
+
+	/* encode each tile */
+	for (tileno = 0; tileno < cp->tw * cp->th * cp->tl; tileno++) {
+		opj_event_msg(j3d->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th * cp->tl);
+		
+		j3d->curtileno = tileno;
+
+		/* initialisation before tile encoding  */
+		if (tileno == 0) {	
+			tcd_malloc_encode(tcd, volume, cp, j3d->curtileno);
+		} else {
+			tcd_init_encode(tcd, volume, cp, j3d->curtileno);
+		}
+		
+		/* INDEX >> */
+		if(volume_info && volume_info->index_on) {
+			volume_info->tile[j3d->curtileno].num_tile = j3d->curtileno;
+			volume_info->tile[j3d->curtileno].start_pos = cio_tell(cio) + j3d->pos_correction;
+		}
+		/* << INDEX */
+		
+		j3d_write_sot(j3d);
+	
+		for (compno = 1; compno < volume->numcomps; compno++) {
+			j3d_write_coc(j3d, compno);
+			j3d_write_qcc(j3d, compno);
+		}
+
+		if (cp->tcps[tileno].numpocs) {
+			j3d_write_poc(j3d);
+		}
+		j3d_write_sod(j3d, tcd); //--> tcd_encode_tile
+
+		/* INDEX >> */
+		if(volume_info && volume_info->index_on) {
+			volume_info->tile[j3d->curtileno].end_pos = cio_tell(cio) + j3d->pos_correction - 1;
+		}
+		/* << INDEX */		
+	}
+	
+	/* destroy the tile encoder */
+	tcd_free_encode(tcd);
+	tcd_destroy(tcd);
+
+	j3d_write_eoc(j3d);
+	
+	/* Creation of the index file */
+	if(volume_info && volume_info->index_on) {
+		if(!j3d_create_index(j3d, cio, volume_info, index)) {
+			opj_event_msg(j3d->cinfo, EVT_ERROR, "failed to create index file %s\n", index);
+			return false;
+		}
+	}
+	  
+	return true;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/jp3d.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/jp3d.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,518 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __J3D_H
+#define __J3D_H
+/**
+@file j3d.h
+@brief The JPEG-2000 Codestream Reader/Writer (J3D)
+
+The functions in J3D.C have for goal to read/write the several parts of the codestream: markers and data.
+*/
+
+/** @defgroup J3D J3D - JPEG-2000 codestream reader/writer */
+/*@{*/
+
+#define J3D_CP_CSTY_PRT 0x01
+#define J3D_CP_CSTY_SOP 0x02
+#define J3D_CP_CSTY_EPH 0x04
+#define J3D_CCP_CSTY_PRT 0x01
+/** Table A-8 */
+#define J3D_CCP_CBLKSTY_LAZY 0x01	 /* Selective arithmetic coding bypass */
+#define J3D_CCP_CBLKSTY_RESET 0x02   /* Reset context probabilities on coding pass boundaries */
+#define J3D_CCP_CBLKSTY_TERMALL 0x04 /* Termination on each coding pass */
+#define J3D_CCP_CBLKSTY_VSC 0x08	 /* Vertically causal context, add also hook for switching off and on 3D context models */	
+#define J3D_CCP_CBLKSTY_PTERM 0x10	 /* Predictable termination */
+#define J3D_CCP_CBLKSTY_SEGSYM 0x20	 /* Segmentation symbols are used */
+#define J3D_CCP_CBLKSTY_3DCTXT 0x40  /* 3D context models (3D-EBCOT) vs 2D context models */
+
+#define J3D_CCP_QNTSTY_NOQNT 0	/* Quantization style : no quantization */
+#define J3D_CCP_QNTSTY_SIQNT 1	/* Quantization style : scalar derived (values signalled only in LLL subband) */
+#define J3D_CCP_QNTSTY_SEQNT 2	/* Quantization style : scalar expounded (values signalled for each subband) */
+
+/* ----------------------------------------------------------------------- */
+
+#define J3D_MS_SOC 0xff4f	/**< SOC marker value */
+#define J3D_MS_SOT 0xff90	/**< SOT marker value */
+#define J3D_MS_SOD 0xff93	/**< SOD marker value */
+#define J3D_MS_EOC 0xffd9	/**< EOC marker value */
+#define J3D_MS_CAP 0xff50	/**< CAP marker value */
+#define J3D_MS_SIZ 0xff51	/**< SIZ marker value */
+#define J3D_MS_ZSI 0xff54	/**< ZSI marker value */
+#define J3D_MS_COD 0xff52	/**< COD marker value */
+#define J3D_MS_COC 0xff53	/**< COC marker value */
+#define J3D_MS_RGN 0xff5e	/**< RGN marker value */
+#define J3D_MS_QCD 0xff5c	/**< QCD marker value */
+#define J3D_MS_QCC 0xff5d	/**< QCC marker value */
+#define J3D_MS_POC 0xff5f	/**< POC marker value */
+#define J3D_MS_TLM 0xff55	/**< TLM marker value */
+#define J3D_MS_PLM 0xff57	/**< PLM marker value */
+#define J3D_MS_PLT 0xff58	/**< PLT marker value */
+#define J3D_MS_PPM 0xff60	/**< PPM marker value */
+#define J3D_MS_PPT 0xff61	/**< PPT marker value */
+#define J3D_MS_SOP 0xff91	/**< SOP marker value */
+#define J3D_MS_EPH 0xff92	/**< EPH marker value */
+#define J3D_MS_CRG 0xff63	/**< CRG marker value */
+#define J3D_MS_COM 0xff64	/**< COM marker value */
+//15444-2
+#define J3D_MS_DCO 0xff70	/**< DCO marker value */
+#define J3D_MS_VMS 0xff71   /**< VMS marker value */
+#define J3D_MS_DFS 0xff72	/**< DFS marker value */
+#define J3D_MS_ADS 0xff73	/**< ADS marker value */
+#define J3D_MS_ATK 0xff79	/**< ATK marker value */
+#define J3D_MS_CBD 0xff78	/**< CBD marker value */
+#define J3D_MS_MCT 0xff74	/**< MCT marker value */
+#define J3D_MS_MCC 0xff75	/**< MCC marker value */
+#define J3D_MS_MCO 0xff77	/**< MCO marker value */
+#define J3D_MS_NLT 0xff76	/**< NLT marker value */
+#define J3D_MS_QPD 0xff5a	/**< QPD marker value */
+#define J3D_MS_QPC 0xff5b	/**< QPC marker value */
+
+/* ----------------------------------------------------------------------- */
+/* Capability RSIZ parameter, extended */
+#define J3D_RSIZ_BASIC 0x0000
+
+#define J3D_RSIZ_DCO   0x8001 /* Required */
+#define J3D_RSIZ_VSQNT 0x8002
+#define J3D_RSIZ_TCQNT 0x8004
+#define J3D_RSIZ_VMASK 0x8008
+#define J3D_RSIZ_SSOVL 0x8010
+#define J3D_RSIZ_ADECS 0x8020
+#define J3D_RSIZ_ATK   0x8040 /*Required*/
+#define J3D_RSIZ_SSYMK 0x8080
+#define J3D_RSIZ_MCT   0x8100 /*Not compatible with DCO*/
+#define J3D_RSIZ_NLT   0x8200 /*Required*/
+#define J3D_RSIZ_ASHAP 0x8400
+#define J3D_RSIZ_PRQNT 0x8800
+
+#define J3D_CAP_10		0x00400000
+/* Arbitrary transformation kernel, 15444-2 */
+#define J3D_ATK_IRR 0
+#define J3D_ATK_REV 1
+#define J3D_ATK_ARB 0
+#define J3D_ATK_WS 1
+#define J3D_ATK_CON 0
+/* ----------------------------------------------------------------------- */
+
+/**
+Values that specify the status of the decoding process when decoding the main header. 
+These values may be combined with a | operator. 
+*/
+typedef enum J3D_STATUS {
+	/**< a SOC marker is expected */
+	J3D_STATE_MHSOC  = 0x0001, 
+	/**< a SIZ marker is expected */
+	J3D_STATE_MHSIZ  = 0x0002, 
+	/**< the decoding process is in the main header */
+	J3D_STATE_MH     = 0x0004, 
+	/**< the decoding process is in a tile part header and expects a SOT marker */
+	J3D_STATE_TPHSOT = 0x0008, 
+	/**< the decoding process is in a tile part header */
+	J3D_STATE_TPH    = 0x0010, 
+	/**< the EOC marker has just been read */
+	J3D_STATE_MT     = 0x0020, 
+	/**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J3D_STATE_NEOC   = 0x0040  
+} J3D_STATUS;
+
+
+
+/**
+Arbitrary transformation kernel
+*/
+typedef struct opj_atk {
+/** index of wavelet kernel */
+	int index;
+/** Numerical type of scaling factor and lifting step parameters */
+	int coeff_typ;		
+/** Wavelet filter category */
+	int filt_cat;		
+/** Wavelet transformation type (REV/IRR) */
+	int wt_typ;			
+/** Initial odd/even subsequence */
+	int minit;			
+/** Boundary extension method (constant CON / whole-sample symmetric WS) */
+	int exten;			
+/** Scaling factor. Only for wt_typ=IRR */
+	double Katk;			
+/** Number of lifting steps */
+	int Natk;			
+/** Offset for lifting step s. Only for filt_cat=ARB */
+	int Oatk[256];		
+/** Base 2 scaling exponent for lifting step s. Only for wt_typ=REV */
+	int Eatk[256];		
+/** Additive residue for lifting step s. Only for wt_typ=REV */
+	int Batk[256];		
+/** Number of lifting coefficients signaled for lifting step s  */
+	int LCatk[256];	
+/** Lifting coefficient k for lifting step s */
+	double Aatk[256][256];	
+} opj_atk_t;
+
+
+/**
+Quantization stepsize
+*/
+typedef struct opj_stepsize {
+/** exponent */
+	int expn;	
+/** mantissa */
+	int mant;	
+} opj_stepsize_t;
+
+/**
+Tile-component coding parameters
+*/
+typedef struct opj_tccp {
+	/** coding style */
+	int csty;							
+	/** number of resolutions of x, y and z-axis */
+	int numresolution[3];	
+	/** code-blocks width height & depth*/
+	int cblk[3];			
+	/** code-block coding style */
+	int cblksty;			
+	/** 0: no ATK (only 9-7 or 5-3) 1: ATK defined WT*/
+	int atk_wt[3];				
+	/** Arbitrary transformation kernel (15444-2)*/
+	opj_atk_t *atk;			
+	/** DWT identifier for x, y and z-axis (0:WT9-7 1:WT5-3	>1:WT-atk->index) */
+	int dwtid[3];
+	/** reversible/irreversible wavelet transfomation (0:irrev 1:reversible)*/	
+	int reversible; 		
+	/** quantisation style */
+	int qntsty;				
+	/** stepsizes used for quantization */
+	opj_stepsize_t stepsizes[J3D_MAXBANDS];	
+	/** number of guard bits. Table A28 de 15444-1*/
+	int numgbits;			
+	/** Region Of Interest shift */
+	int roishift;			
+	/** precinct width heigth & depth*/
+	int prctsiz[3][J3D_MAXRLVLS];		
+} opj_tccp_t;
+
+/**
+Tile coding parameters : coding/decoding parameters common to all tiles 
+(information like COD, COC in main header)
+*/
+typedef struct opj_tcp {
+/** 1 : first part-tile of a tile */
+	int first;				
+	/** coding style */
+	int csty;				
+	/** progression order */
+	OPJ_PROG_ORDER prg;		
+	/** number of layers */
+	int numlayers;			
+	/** multi-component transform identifier */
+	int mct;				
+	/** rates of layers */
+	float rates[100];			
+	/** number of progression order changes */
+	int numpocs;			
+	/** indicates if a POC marker has been used O:NO, 1:YES */
+	int POC;				
+	/** progression order changes */
+	opj_poc_t pocs[J3D_MAXRLVLS - 1];
+	/** add fixed_quality */
+	float distoratio[100];
+	/** tile-component coding parameters */
+	opj_tccp_t *tccps;		
+/** packet header store there for futur use in t2_decode_packet */
+	unsigned char *ppt_data;		
+	/** pointer remaining on the first byte of the first header if ppt is used */
+	unsigned char *ppt_data_first;	
+	/** If ppt == 1 --> there was a PPT marker for the present tile */
+	int ppt;		
+	/** used in case of multiple marker PPT (number of info already stored) */
+	int ppt_store;	
+	int ppt_len;	
+} opj_tcp_t;
+
+/**
+Coding parameters
+*/
+typedef struct opj_cp {
+/** transform format 0: 2DWT, 1: 2D1P, 2: 3DWT, 3: 3RLS */
+	OPJ_TRANSFORM transform_format;		
+	/** entropy coding format 0: 2EB, 1: 3EB, 2: 2GR, 3: 3GR, 4: GRI*/
+	OPJ_ENTROPY_CODING encoding_format;	
+	/** allocation by rate/distortion */
+	int disto_alloc;	
+	/** allocation by fixed layer */
+	int fixed_alloc;	
+	/** add fixed_quality */
+	int fixed_quality;	
+	/** Rsiz: capabilities */
+	int rsiz;			
+	/** if != 0, then original dimension divided by 2^(reduce); if == 0 or not used, volume is decoded to the full resolution */
+	int reduce[3];		
+	/** if != 0, then only the first "layer" layers are decoded; if == 0 or not used, all the quality layers are decoded */
+	int layer;			
+	/** 0 = no index || 1 = index */
+	int index_on;		
+	/** Big-Endian/Little-endian order */
+	int bigendian;
+	/** XTOsiz */
+	int tx0;	
+	/** YTOsiz */
+	int ty0;		
+	/** ZTOsiz */
+	int tz0;	
+	/** XTsiz */
+	int tdx;	
+	/** YTsiz */
+	int tdy;	
+	/** ZTsiz */
+	int tdz;	
+	/** comment for coding */
+	char *comment;		
+	/** number of tiles in width, heigth and depth */
+	int tw;		
+	int th;
+	int tl;
+	/** ID number of the tiles present in the codestream */
+	int *tileno;	
+	/** size of the vector tileno */
+	int tileno_size;
+	/** tile coding parameters */
+	opj_tcp_t *tcps;
+	/** fixed layer */
+	int *matrice;		
+
+	/** packet header store there for futur use in t2_decode_packet */
+	unsigned char *ppm_data;		
+	/** pointer remaining on the first byte of the first header if ppm is used */
+	unsigned char *ppm_data_first;	
+	/** if ppm == 1 --> there was a PPM marker for the present tile */
+	int ppm;			
+	/** use in case of multiple marker PPM (number of info already store) */
+	int ppm_store;		
+	/** use in case of multiple marker PPM (case on non-finished previous info) */
+	int ppm_previous;	
+	int ppm_len;		
+} opj_cp_t;
+
+/**
+Information concerning a packet inside tile
+*/
+typedef struct opj_packet_info {
+	/** start position */
+	int start_pos;	
+	/** end position */
+	int end_pos;	
+	/** distorsion introduced */
+	double disto;	
+} opj_packet_info_t;
+
+/**
+Index structure : information regarding tiles inside volume
+*/
+typedef struct opj_tile_info {
+	/** value of thresh for each layer by tile cfr. Marcela   */
+	double *thresh;		
+	/** number of tile */
+	int num_tile;		
+	/** start position */
+	int start_pos;		
+	/** end position of the header */
+	int end_header;		
+	/** end position */
+	int end_pos;		
+	/** precinct number for each resolution level (width, heigth and depth) */
+	int prctno[3][J3D_MAXRLVLS];	
+	/** precinct size (in power of 2), in X for each resolution level */
+	int prctsiz[3][J3D_MAXRLVLS];	
+	/** information concerning packets inside tile */
+	opj_packet_info_t *packet;		
+	
+	/** add fixed_quality */
+	int nbpix;			
+	/** add fixed_quality */
+	double distotile;	
+} opj_tile_info_t;
+
+/**
+Index structure
+*/
+typedef struct opj_volume_info {
+	
+	/** transform format 0: 2DWT, 1: 2D1P, 2: 3DWT, 3: 3RLS */
+	OPJ_TRANSFORM transform_format;		
+	/** output file format 0: 2EB, 1: 3EB, 2: 2GR, 3: 3GR, 4: GRI*/
+	OPJ_ENTROPY_CODING encoding_format;	/** 0 = no index || 1 = index */
+	int index_on;	
+	/** 0 = wt 9-7 || 1 = wt 5-3 || >=2 wt atk defined */
+	int dwtid[3];	
+	/** maximum distortion reduction on the whole volume (add for Marcela) */
+	double D_max;	
+	/** packet number */
+	int num;		
+	/** writing the packet in the index with t2_encode_packets */
+	int index_write;	
+	/** volume width, height and depth */
+	int volume_w;	
+	int volume_h;
+	int volume_l;
+	/** progression order */
+	OPJ_PROG_ORDER prog;	
+	/** tile size in x, y and z */
+	int tile_x;		
+	int tile_y;
+	int tile_z;
+	/** tile origin in x, y and z */
+	int tile_Ox;	
+	int tile_Oy;
+	int tile_Oz;
+	/** number of tiles in X, Y and Z */
+	int tw;			
+	int th;
+	int tl;
+	/** component numbers */
+	int comp;				
+	/** number of layer */
+	int layer;				
+	/** number of decomposition in X, Y and Z*/
+	int decomposition[3];	
+	/** DC offset (15444-2) */
+	int dcoffset;	
+	/** main header position */
+	int main_head_end;		
+	/** codestream's size */
+	int codestream_size;	
+	/** information regarding tiles inside volume */
+	opj_tile_info_t *tile;	
+} opj_volume_info_t;
+
+/**
+JPEG-2000 codestream reader/writer
+*/
+typedef struct opj_j3d {
+	/** codec context */
+	opj_common_ptr cinfo;	
+	/** locate in which part of the codestream the decoder is (main header, tile header, end) */
+	int state;				
+	/** number of the tile curently concern by coding/decoding */
+	int curtileno;			
+	/** locate the position of the end of the tile in the codestream, used to detect a truncated codestream (in j3d_read_sod)	*/
+	unsigned char *eot;	
+	/**	locate the start position of the SOT marker of the current coded tile:  */
+	int sot_start;		
+	/*  after encoding the tile, a jump (in j3d_write_sod) is done to the SOT marker to store the value of its length. */
+	int sod_start;		
+	/**	as the J3D-file is written in several parts during encoding, it enables to make the right correction in position return by cio_tell	*/
+	int pos_correction;	
+	/** array used to store the data of each tile */
+	unsigned char **tile_data;	
+	/** array used to store the length of each tile */
+	int *tile_len;				
+
+	/** decompression only : store decoding parameters common to all tiles */
+	opj_tcp_t *default_tcp;		
+	/** pointer to the encoded / decoded volume */
+	opj_volume_t *volume;		
+	/** pointer to the coding parameters */
+	opj_cp_t *cp;				
+	/** helper used to write the index file */
+	opj_volume_info_t *volume_info;	
+	/** pointer to the byte i/o stream */
+    opj_cio_t *cio;						
+} opj_j3d_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Creates a J3D decompression structure
+@param cinfo Codec context info
+@return Returns a handle to a J3D decompressor if successful, returns NULL otherwise
+*/
+opj_j3d_t* j3d_create_decompress(opj_common_ptr cinfo);
+/**
+Destroy a J3D decompressor handle
+@param j3d J3D decompressor handle to destroy
+*/
+void j3d_destroy_decompress(opj_j3d_t *j3d);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in j3d->cp. 
+@param j3d J3D decompressor handle
+@param parameters decompression parameters
+*/
+void j3d_setup_decoder(opj_j3d_t *j3d, opj_dparameters_t *parameters);
+/**
+Decode an volume from a JPEG-2000 codestream
+@param j3d J3D decompressor handle
+@param cio Input buffer stream
+@return Returns a decoded volume if successful, returns NULL otherwise
+*/
+opj_volume_t* j3d_decode(opj_j3d_t *j3d, opj_cio_t *cio);
+/**
+Decode an volume form a JPT-stream (JPEG 2000, JPIP)
+@param j3d J3D decompressor handle
+@param cio Input buffer stream
+@return Returns a decoded volume if successful, returns NULL otherwise
+*/
+opj_volume_t* j3d_decode_jpt_stream(opj_j3d_t *j3d, opj_cio_t *cio);
+/**
+Creates a J3D compression structure
+@param cinfo Codec context info
+@return Returns a handle to a J3D compressor if successful, returns NULL otherwise
+*/
+opj_j3d_t* j3d_create_compress(opj_common_ptr cinfo);
+/**
+Destroy a J3D compressor handle
+@param j3d J3D compressor handle to destroy
+*/
+void j3d_destroy_compress(opj_j3d_t *j3d);
+/**
+Setup the encoder parameters using the current volume and using user parameters. 
+Coding parameters are returned in j3d->cp. 
+@param j3d J3D compressor handle
+@param parameters compression parameters
+@param volume input filled volume
+*/
+void j3d_setup_encoder(opj_j3d_t *j3d, opj_cparameters_t *parameters, opj_volume_t *volume);
+/**
+Encode an volume into a JPEG-2000 codestream
+@param j3d J3D compressor handle
+@param cio Output buffer stream
+@param volume Volume to encode
+@param index Name of the index file if required, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+bool j3d_encode(opj_j3d_t *j3d, opj_cio_t *cio, opj_volume_t *volume, char *index);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __J3D_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d_lib.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/jp3d_lib.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/jp3d_lib.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,76 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/times.h>
+#endif /* WIN32 */
+#include "opj_includes.h"
+
+double opj_clock() {
+#ifdef WIN32
+	/* WIN32: use QueryPerformance (very accurate) */
+    LARGE_INTEGER freq , t ;
+    /* freq is the clock speed of the CPU */
+    QueryPerformanceFrequency(&freq) ;
+	/* cout << "freq = " << ((double) freq.QuadPart) << endl; */
+    /* t is the high resolution performance counter (see MSDN) */
+    QueryPerformanceCounter ( & t ) ;
+    return ( t.QuadPart /(double) freq.QuadPart ) ;
+#else
+	/* Unix or Linux: use resource usage */
+    struct rusage t;
+    double procTime;
+    /* (1) Get the rusage data structure at this moment (man getrusage) */
+    getrusage(0,&t);
+    /* (2) What is the elapsed time ? - CPU time = User time + System time */
+	/* (2a) Get the seconds */
+    procTime = t.ru_utime.tv_sec + t.ru_stime.tv_sec;
+    /* (2b) More precisely! Get the microseconds part ! */
+    return ( procTime + (t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;
+#endif
+}
+
+void* opj_malloc( size_t size ) {
+	void *memblock = malloc(size);
+	if(memblock) {
+		memset(memblock, 0, size);
+	}
+	return memblock;
+}
+
+void* opj_realloc( void *memblock, size_t size ) {
+	return realloc(memblock, size);
+}
+
+void opj_free( void *memblock ) {
+	free(memblock);
+}
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d_lib.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/jp3d_lib.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/jp3d_lib.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/jp3d_lib.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __J3D_LIB_H
+#define __J3D_LIB_H
+/**
+@file jp3d_lib.h
+@brief Internal functions
+
+The functions in JP3D_LIB.C are internal utilities mainly used for memory management.
+*/
+
+/** @defgroup MISC MISC - Miscellaneous internal functions */
+/*@{*/
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Difference in successive opj_clock() calls tells you the elapsed time
+@return Returns time in seconds
+*/
+double opj_clock();
+
+/**
+Allocate a memory block with elements initialized to 0
+@param size Bytes to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+void* opj_malloc( size_t size );
+
+/**
+Reallocate memory blocks.
+@param memblock Pointer to previously allocated memory block
+@param size New size in bytes
+@return Returns a void pointer to the reallocated (and possibly moved) memory block
+*/
+void* opj_realloc( void *memblock, size_t size );
+
+/**
+Deallocates or frees a memory block.
+@param memblock Previously allocated memory block to be freed
+*/
+void opj_free( void *memblock );
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __J3D_LIB_H */
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mct.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/mct.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mct.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/mct.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,131 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* <summary> */
+/* This table contains the norms of the basis function of the reversible MCT. */
+/* </summary> */
+static const double mct_norms[3] = { 1.732, .8292, .8292 };
+
+/* <summary> */
+/* This table contains the norms of the basis function of the irreversible MCT. */
+/* </summary> */
+static const double mct_norms_real[3] = { 1.732, 1.805, 1.573 };
+
+/* <summary> */
+/* Foward reversible MCT. */
+/* </summary> */
+void mct_encode(int *c0, int *c1, int *c2, int n) {
+	int i;
+	for (i = 0; i < n; i++) {
+		int r, g, b, y, u, v;
+		r = c0[i];
+		g = c1[i];
+		b = c2[i];
+		y = (r + (g << 1) + b) >> 2;
+		u = b - g;
+		v = r - g;
+		c0[i] = y;
+		c1[i] = u;
+		c2[i] = v;
+	}
+}
+
+/* <summary> */
+/* Inverse reversible MCT. */
+/* </summary> */
+void mct_decode(int *c0, int *c1, int *c2, int n) {
+	int i;
+	for (i = 0; i < n; i++) {
+		int y, u, v, r, g, b;
+		y = c0[i];
+		u = c1[i];
+		v = c2[i];
+		g = y - ((u + v) >> 2);
+		r = v + g;
+		b = u + g;
+		c0[i] = r;
+		c1[i] = g;
+		c2[i] = b;
+	}
+}
+
+/* <summary> */
+/* Get norm of basis function of reversible MCT. */
+/* </summary> */
+double mct_getnorm(int compno) {
+	return mct_norms[compno];
+}
+
+/* <summary> */
+/* Foward irreversible MCT. */
+/* </summary> */
+void mct_encode_real(int *c0, int *c1, int *c2, int n) {
+	int i;
+	for (i = 0; i < n; i++) {
+		int r, g, b, y, u, v;
+		r = c0[i];
+		g = c1[i];
+		b = c2[i];
+		y = fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
+		u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
+		v = fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+		c0[i] = y;
+		c1[i] = u;
+		c2[i] = v;
+	}
+}
+
+/* <summary> */
+/* Inverse irreversible MCT. */
+/* </summary> */
+void mct_decode_real(int *c0, int *c1, int *c2, int n) {
+	int i;
+	for (i = 0; i < n; i++) {
+		int y, u, v, r, g, b;
+		y = c0[i];
+		u = c1[i];
+		v = c2[i];
+		r = y + fix_mul(v, 11485);
+		g = y - fix_mul(u, 2819) - fix_mul(v, 5850);
+		b = y + fix_mul(u, 14516);
+		c0[i] = r;
+		c1[i] = g;
+		c2[i] = b;
+	}
+}
+
+/* <summary> */
+/* Get norm of basis function of irreversible MCT. */
+/* </summary> */
+double mct_getnorm_real(int compno) {
+	return mct_norms_real[compno];
+}
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mct.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/mct.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mct.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/mct.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,97 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MCT_H
+#define __MCT_H
+/**
+@file mct.h
+@brief Implementation of a multi-component transforms (MCT)
+
+The functions in MCT.C have for goal to realize reversible and irreversible multicomponent
+transform. The functions in MCT.C are used by some function in TCD.C.
+*/
+
+/** @defgroup MCT MCT - Implementation of a multi-component transform */
+/*@{*/
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Apply a reversible multi-component transform to an image
+@param c0 Samples for red component
+@param c1 Samples for green component
+@param c2 Samples blue component
+@param n Number of samples for each component
+*/
+void mct_encode(int *c0, int *c1, int *c2, int n);
+/**
+Apply a reversible multi-component inverse transform to an image
+@param c0 Samples for luminance component
+@param c1 Samples for red chrominance component
+@param c2 Samples for blue chrominance component
+@param n Number of samples for each component
+*/
+void mct_decode(int *c0, int *c1, int *c2, int n);
+/**
+Get norm of the basis function used for the reversible multi-component transform
+@param compno Number of the component (0->Y, 1->U, 2->V)
+@return 
+*/
+double mct_getnorm(int compno);
+
+/**
+Apply an irreversible multi-component transform to an image
+@param c0 Samples for red component
+@param c1 Samples for green component
+@param c2 Samples blue component
+@param n Number of samples for each component
+*/
+void mct_encode_real(int *c0, int *c1, int *c2, int n);
+/**
+Apply an irreversible multi-component inverse transform to an image
+@param c0 Samples for luminance component
+@param c1 Samples for red chrominance component
+@param c2 Samples for blue chrominance component
+@param n Number of samples for each component
+*/
+void mct_decode_real(int *c0, int *c1, int *c2, int n);
+/**
+Get norm of the basis function used for the irreversible multi-component transform
+@param compno Number of the component (0->Y, 1->U, 2->V)
+@return 
+*/
+double mct_getnorm_real(int compno);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __MCT_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mqc.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/mqc.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mqc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/mqc.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,548 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup MQC MQC - Implementation of an MQ-Coder */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Output a byte, doing bit-stuffing if necessary.
+After a 0xff byte, the next byte must be smaller than 0x90.
+@param mqc MQC handle
+*/
+static void mqc_byteout(opj_mqc_t *mqc);
+/**
+Renormalize mqc->a and mqc->c while encoding, so that mqc->a stays between 0x8000 and 0x10000
+@param mqc MQC handle
+*/
+static void mqc_renorme(opj_mqc_t *mqc);
+/**
+Encode the most probable symbol
+@param mqc MQC handle
+*/
+static void mqc_codemps(opj_mqc_t *mqc);
+/**
+Encode the most least symbol
+@param mqc MQC handle
+*/
+static void mqc_codelps(opj_mqc_t *mqc);
+/**
+Fill mqc->c with 1's for flushing
+@param mqc MQC handle
+*/
+static void mqc_setbits(opj_mqc_t *mqc);
+/**
+Exchange MPS with LPS
+@param mqc MQC handle
+@return 
+*/
+static int mqc_mpsexchange(opj_mqc_t *mqc);
+/**
+Exchange LPS with MPS
+@param mqc MQC handle
+@return 
+*/
+static int mqc_lpsexchange(opj_mqc_t *mqc);
+/**
+Input a byte
+@param mqc MQC handle
+*/
+static void mqc_bytein(opj_mqc_t *mqc);
+/**
+Renormalize mqc->a and mqc->c while decoding
+@param mqc MQC handle
+*/
+static void mqc_renormd(opj_mqc_t *mqc);
+
+/*@}*/
+
+/*@}*/
+
+/* <summary> */
+/* This array defines all the possible states for a context. */
+/* </summary> */
+static opj_mqc_state_t mqc_states[47 * 2] = {
+	{0x5601, 0, &mqc_states[2], &mqc_states[3]},
+	{0x5601, 1, &mqc_states[3], &mqc_states[2]},
+	{0x3401, 0, &mqc_states[4], &mqc_states[12]},
+	{0x3401, 1, &mqc_states[5], &mqc_states[13]},
+	{0x1801, 0, &mqc_states[6], &mqc_states[18]},
+	{0x1801, 1, &mqc_states[7], &mqc_states[19]},
+	{0x0ac1, 0, &mqc_states[8], &mqc_states[24]},
+	{0x0ac1, 1, &mqc_states[9], &mqc_states[25]},
+	{0x0521, 0, &mqc_states[10], &mqc_states[58]},
+	{0x0521, 1, &mqc_states[11], &mqc_states[59]},
+	{0x0221, 0, &mqc_states[76], &mqc_states[66]},
+	{0x0221, 1, &mqc_states[77], &mqc_states[67]},
+	{0x5601, 0, &mqc_states[14], &mqc_states[13]},
+	{0x5601, 1, &mqc_states[15], &mqc_states[12]},
+	{0x5401, 0, &mqc_states[16], &mqc_states[28]},
+	{0x5401, 1, &mqc_states[17], &mqc_states[29]},
+	{0x4801, 0, &mqc_states[18], &mqc_states[28]},
+	{0x4801, 1, &mqc_states[19], &mqc_states[29]},
+	{0x3801, 0, &mqc_states[20], &mqc_states[28]},
+	{0x3801, 1, &mqc_states[21], &mqc_states[29]},
+	{0x3001, 0, &mqc_states[22], &mqc_states[34]},
+	{0x3001, 1, &mqc_states[23], &mqc_states[35]},
+	{0x2401, 0, &mqc_states[24], &mqc_states[36]},
+	{0x2401, 1, &mqc_states[25], &mqc_states[37]},
+	{0x1c01, 0, &mqc_states[26], &mqc_states[40]},
+	{0x1c01, 1, &mqc_states[27], &mqc_states[41]},
+	{0x1601, 0, &mqc_states[58], &mqc_states[42]},
+	{0x1601, 1, &mqc_states[59], &mqc_states[43]},
+	{0x5601, 0, &mqc_states[30], &mqc_states[29]},
+	{0x5601, 1, &mqc_states[31], &mqc_states[28]},
+	{0x5401, 0, &mqc_states[32], &mqc_states[28]},
+	{0x5401, 1, &mqc_states[33], &mqc_states[29]},
+	{0x5101, 0, &mqc_states[34], &mqc_states[30]},
+	{0x5101, 1, &mqc_states[35], &mqc_states[31]},
+	{0x4801, 0, &mqc_states[36], &mqc_states[32]},
+	{0x4801, 1, &mqc_states[37], &mqc_states[33]},
+	{0x3801, 0, &mqc_states[38], &mqc_states[34]},
+	{0x3801, 1, &mqc_states[39], &mqc_states[35]},
+	{0x3401, 0, &mqc_states[40], &mqc_states[36]},
+	{0x3401, 1, &mqc_states[41], &mqc_states[37]},
+	{0x3001, 0, &mqc_states[42], &mqc_states[38]},
+	{0x3001, 1, &mqc_states[43], &mqc_states[39]},
+	{0x2801, 0, &mqc_states[44], &mqc_states[38]},
+	{0x2801, 1, &mqc_states[45], &mqc_states[39]},
+	{0x2401, 0, &mqc_states[46], &mqc_states[40]},
+	{0x2401, 1, &mqc_states[47], &mqc_states[41]},
+	{0x2201, 0, &mqc_states[48], &mqc_states[42]},
+	{0x2201, 1, &mqc_states[49], &mqc_states[43]},
+	{0x1c01, 0, &mqc_states[50], &mqc_states[44]},
+	{0x1c01, 1, &mqc_states[51], &mqc_states[45]},
+	{0x1801, 0, &mqc_states[52], &mqc_states[46]},
+	{0x1801, 1, &mqc_states[53], &mqc_states[47]},
+	{0x1601, 0, &mqc_states[54], &mqc_states[48]},
+	{0x1601, 1, &mqc_states[55], &mqc_states[49]},
+	{0x1401, 0, &mqc_states[56], &mqc_states[50]},
+	{0x1401, 1, &mqc_states[57], &mqc_states[51]},
+	{0x1201, 0, &mqc_states[58], &mqc_states[52]},
+	{0x1201, 1, &mqc_states[59], &mqc_states[53]},
+	{0x1101, 0, &mqc_states[60], &mqc_states[54]},
+	{0x1101, 1, &mqc_states[61], &mqc_states[55]},
+	{0x0ac1, 0, &mqc_states[62], &mqc_states[56]},
+	{0x0ac1, 1, &mqc_states[63], &mqc_states[57]},
+	{0x09c1, 0, &mqc_states[64], &mqc_states[58]},
+	{0x09c1, 1, &mqc_states[65], &mqc_states[59]},
+	{0x08a1, 0, &mqc_states[66], &mqc_states[60]},
+	{0x08a1, 1, &mqc_states[67], &mqc_states[61]},
+	{0x0521, 0, &mqc_states[68], &mqc_states[62]},
+	{0x0521, 1, &mqc_states[69], &mqc_states[63]},
+	{0x0441, 0, &mqc_states[70], &mqc_states[64]},
+	{0x0441, 1, &mqc_states[71], &mqc_states[65]},
+	{0x02a1, 0, &mqc_states[72], &mqc_states[66]},
+	{0x02a1, 1, &mqc_states[73], &mqc_states[67]},
+	{0x0221, 0, &mqc_states[74], &mqc_states[68]},
+	{0x0221, 1, &mqc_states[75], &mqc_states[69]},
+	{0x0141, 0, &mqc_states[76], &mqc_states[70]},
+	{0x0141, 1, &mqc_states[77], &mqc_states[71]},
+	{0x0111, 0, &mqc_states[78], &mqc_states[72]},
+	{0x0111, 1, &mqc_states[79], &mqc_states[73]},
+	{0x0085, 0, &mqc_states[80], &mqc_states[74]},
+	{0x0085, 1, &mqc_states[81], &mqc_states[75]},
+	{0x0049, 0, &mqc_states[82], &mqc_states[76]},
+	{0x0049, 1, &mqc_states[83], &mqc_states[77]},
+	{0x0025, 0, &mqc_states[84], &mqc_states[78]},
+	{0x0025, 1, &mqc_states[85], &mqc_states[79]},
+	{0x0015, 0, &mqc_states[86], &mqc_states[80]},
+	{0x0015, 1, &mqc_states[87], &mqc_states[81]},
+	{0x0009, 0, &mqc_states[88], &mqc_states[82]},
+	{0x0009, 1, &mqc_states[89], &mqc_states[83]},
+	{0x0005, 0, &mqc_states[90], &mqc_states[84]},
+	{0x0005, 1, &mqc_states[91], &mqc_states[85]},
+	{0x0001, 0, &mqc_states[90], &mqc_states[86]},
+	{0x0001, 1, &mqc_states[91], &mqc_states[87]},
+	{0x5601, 0, &mqc_states[92], &mqc_states[92]},
+	{0x5601, 1, &mqc_states[93], &mqc_states[93]},
+};
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static void mqc_byteout(opj_mqc_t *mqc) {
+	if (*mqc->bp == 0xff) {
+		mqc->bp++;
+		*mqc->bp = mqc->c >> 20;
+		mqc->c &= 0xfffff;
+		mqc->ct = 7;
+	} else {
+		if ((mqc->c & 0x8000000) == 0) {	/* ((mqc->c&0x8000000)==0) CHANGE */
+			mqc->bp++;
+			*mqc->bp = mqc->c >> 19;
+			mqc->c &= 0x7ffff;
+			mqc->ct = 8;
+		} else {
+			(*mqc->bp)++;
+			if (*mqc->bp == 0xff) {
+				mqc->c &= 0x7ffffff;
+				mqc->bp++;
+				*mqc->bp = mqc->c >> 20;
+				mqc->c &= 0xfffff;
+				mqc->ct = 7;
+			} else {
+				mqc->bp++;
+				*mqc->bp = mqc->c >> 19;
+				mqc->c &= 0x7ffff;
+				mqc->ct = 8;
+			}
+		}
+	}
+}
+
+static void mqc_renorme(opj_mqc_t *mqc) {
+	do {
+		mqc->a <<= 1;
+		mqc->c <<= 1;
+		mqc->ct--;
+		if (mqc->ct == 0) {
+			mqc_byteout(mqc);
+		}
+	} while ((mqc->a & 0x8000) == 0);
+}
+
+static void mqc_codemps(opj_mqc_t *mqc) {
+	mqc->a -= (*mqc->curctx)->qeval;
+	if ((mqc->a & 0x8000) == 0) {
+		if (mqc->a < (*mqc->curctx)->qeval) {
+			mqc->a = (*mqc->curctx)->qeval;
+		} else {
+			mqc->c += (*mqc->curctx)->qeval;
+		}
+		*mqc->curctx = (*mqc->curctx)->nmps;
+		mqc_renorme(mqc);
+	} else {
+		mqc->c += (*mqc->curctx)->qeval;
+	}
+}
+
+static void mqc_codelps(opj_mqc_t *mqc) {
+	mqc->a -= (*mqc->curctx)->qeval;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		mqc->c += (*mqc->curctx)->qeval;
+	} else {
+		mqc->a = (*mqc->curctx)->qeval;
+	}
+	*mqc->curctx = (*mqc->curctx)->nlps;
+	mqc_renorme(mqc);
+}
+
+static void mqc_setbits(opj_mqc_t *mqc) {
+	unsigned int tempc = mqc->c + mqc->a;
+	mqc->c |= 0xffff;
+	if (mqc->c >= tempc) {
+		mqc->c -= 0x8000;
+	}
+}
+
+static int mqc_mpsexchange(opj_mqc_t *mqc) {
+	int d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		d = 1 - (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	} else {
+		d = (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	}
+	
+	return d;
+}
+
+static int mqc_lpsexchange(opj_mqc_t *mqc) {
+	int d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	} else {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = 1 - (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	}
+	
+	return d;
+}
+
+static void mqc_bytein(opj_mqc_t *mqc) {
+	if (mqc->bp != mqc->end) {
+		unsigned int c;
+		if (mqc->bp + 1 != mqc->end) {
+			c = *(mqc->bp + 1);
+		} else {
+			c = 0xff;
+		}
+		if (*mqc->bp == 0xff) {
+			if (c > 0x8f) {
+				mqc->c += 0xff00;
+				mqc->ct = 8;
+			} else {
+				mqc->bp++;
+				mqc->c += c << 9;
+				mqc->ct = 7;
+			}
+		} else {
+			mqc->bp++;
+			mqc->c += c << 8;
+			mqc->ct = 8;
+		}
+	} else {
+		mqc->c += 0xff00;
+		mqc->ct = 8;
+	}
+}
+
+static void mqc_renormd(opj_mqc_t *mqc) {
+	do {
+		if (mqc->ct == 0) {
+			mqc_bytein(mqc);
+		}
+		mqc->a <<= 1;
+		mqc->c <<= 1;
+		mqc->ct--;
+	} while (mqc->a < 0x8000);
+}
+
+/* 
+==========================================================
+   MQ-Coder interface
+==========================================================
+*/
+
+opj_mqc_t* mqc_create() {
+	opj_mqc_t *mqc = (opj_mqc_t*)opj_malloc(sizeof(opj_mqc_t));
+	return mqc;
+}
+
+void mqc_destroy(opj_mqc_t *mqc) {
+	if(mqc) {
+		opj_free(mqc);
+	}
+}
+
+int mqc_numbytes(opj_mqc_t *mqc) {
+	return mqc->bp - mqc->start;
+}
+
+void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp) {
+	mqc_setcurctx(mqc, 0);
+	mqc->a = 0x8000;
+	mqc->c = 0;
+	mqc->bp = bp - 1;
+	mqc->ct = 12;
+	if (*mqc->bp == 0xff) {
+		mqc->ct = 13;
+	}
+	mqc->start = bp;
+}
+
+void mqc_setcurctx(opj_mqc_t *mqc, int ctxno) {
+	mqc->curctx = &mqc->ctxs[ctxno];
+}
+
+void mqc_encode(opj_mqc_t *mqc, int d) {
+	if ((*mqc->curctx)->mps == d) {
+		mqc_codemps(mqc);
+	} else {
+		mqc_codelps(mqc);
+	}
+}
+
+void mqc_flush(opj_mqc_t *mqc) {
+	mqc_setbits(mqc);
+	mqc->c <<= mqc->ct;
+	mqc_byteout(mqc);
+	mqc->c <<= mqc->ct;
+	mqc_byteout(mqc);
+	
+	if (*mqc->bp != 0xff) {
+		mqc->bp++;
+	}
+}
+
+void mqc_bypass_init_enc(opj_mqc_t *mqc) {
+	mqc->c = 0;
+	mqc->ct = 8;
+	/*if (*mqc->bp == 0xff) {
+	mqc->ct = 7;
+     } */
+}
+
+void mqc_bypass_enc(opj_mqc_t *mqc, int d) {
+	mqc->ct--;
+	mqc->c = mqc->c + (d << mqc->ct);
+	if (mqc->ct == 0) {
+		mqc->bp++;
+		*mqc->bp = mqc->c;
+		mqc->ct = 8;
+		if (*mqc->bp == 0xff) {
+			mqc->ct = 7;
+		}
+		mqc->c = 0;
+	}
+}
+
+int mqc_bypass_flush_enc(opj_mqc_t *mqc) {
+	unsigned char bit_padding;
+	
+	bit_padding = 0;
+	
+	if (mqc->ct != 0) {
+		while (mqc->ct > 0) {
+			mqc->ct--;
+			mqc->c += bit_padding << mqc->ct;
+			bit_padding = (bit_padding + 1) & 0x01;
+		}
+		mqc->bp++;
+		*mqc->bp = mqc->c;
+		mqc->ct = 8;
+		mqc->c = 0;
+	}
+	
+	return 1;
+}
+
+void mqc_reset_enc(opj_mqc_t *mqc) {
+	mqc_resetstates(mqc);
+	mqc_setstate(mqc, 18, 0, 46);
+	mqc_setstate(mqc, 0, 0, 3);
+	mqc_setstate(mqc, 1, 0, 4);
+}
+
+void mqc_reset_enc_3(opj_mqc_t *mqc) {
+	mqc_resetstates(mqc);
+	mqc_setstate(mqc, T1_3D_CTXNO_UNI, 0, 46);
+	mqc_setstate(mqc, T1_3D_CTXNO_AGG, 0, 3);
+	mqc_setstate(mqc, T1_3D_CTXNO_ZC, 0, 4);
+}
+
+int mqc_restart_enc(opj_mqc_t *mqc) {
+	int correction = 1;
+	
+	/* <flush part> */
+	int n = 27 - 15 - mqc->ct;
+	mqc->c <<= mqc->ct;
+	while (n > 0) {
+		mqc_byteout(mqc);
+		n -= mqc->ct;
+		mqc->c <<= mqc->ct;
+	}
+	mqc_byteout(mqc);
+	
+	return correction;
+}
+
+void mqc_restart_init_enc(opj_mqc_t *mqc) {
+	/* <Re-init part> */
+	mqc_setcurctx(mqc, 0);
+	mqc->a = 0x8000;
+	mqc->c = 0;
+	mqc->ct = 12;
+	mqc->bp--;
+	if (*mqc->bp == 0xff) {
+		mqc->ct = 13;
+	}
+}
+
+void mqc_erterm_enc(opj_mqc_t *mqc) {
+	int k = 11 - mqc->ct + 1;
+	
+	while (k > 0) {
+		mqc->c <<= mqc->ct;
+		mqc->ct = 0;
+		mqc_byteout(mqc);
+		k -= mqc->ct;
+	}
+	
+	if (*mqc->bp != 0xff) {
+		mqc_byteout(mqc);
+	}
+}
+
+void mqc_segmark_enc(opj_mqc_t *mqc) {
+	int i;
+	mqc_setcurctx(mqc, 18);
+	
+	for (i = 1; i < 5; i++) {
+		mqc_encode(mqc, i % 2);
+	}
+}
+
+void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len) {
+	mqc_setcurctx(mqc, 0);
+	mqc->start = bp;
+	mqc->end = bp + len;
+	mqc->bp = bp;
+	if (len==0) mqc->c = 0xff << 16;
+	else mqc->c = *mqc->bp << 16;
+	mqc_bytein(mqc);
+	mqc->c <<= 7;
+	mqc->ct -= 7;
+	mqc->a = 0x8000;
+}
+
+int mqc_decode(opj_mqc_t *mqc) {
+	int d;
+	mqc->a -= (*mqc->curctx)->qeval;
+	if ((mqc->c >> 16) < (*mqc->curctx)->qeval) {
+		d = mqc_lpsexchange(mqc);
+		mqc_renormd(mqc);
+	} else {
+		mqc->c -= (*mqc->curctx)->qeval << 16;
+		if ((mqc->a & 0x8000) == 0) {
+			d = mqc_mpsexchange(mqc);
+			mqc_renormd(mqc);
+		} else {
+			d = (*mqc->curctx)->mps;
+		}
+	}
+
+	return d;
+}
+
+void mqc_resetstates(opj_mqc_t *mqc) {
+	int i;
+	for (i = 0; i < MQC_NUMCTXS; i++) {
+		mqc->ctxs[i] = mqc_states;
+	}
+}
+
+void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob) {
+	mqc->ctxs[ctxno] = &mqc_states[msb + (prob << 1)];
+}
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mqc.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/mqc.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/mqc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/mqc.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,201 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MQC_H
+#define __MQC_H
+/**
+@file mqc.h
+@brief Implementation of an MQ-Coder (MQC)
+
+The functions in MQC.C have for goal to realize the MQ-coder operations. The functions
+in MQC.C are used by some function in T1.C.
+*/
+
+/** @defgroup MQC MQC - Implementation of an MQ-Coder */
+/*@{*/
+
+/**
+This struct defines the state of a context.
+*/
+typedef struct opj_mqc_state {
+	/** the probability of the Least Probable Symbol (0.75->0x8000, 1.5->0xffff) */
+	unsigned int qeval;
+	/** the Most Probable Symbol (0 or 1) */
+	int mps;
+	/** next state if the next encoded symbol is the MPS */
+	struct opj_mqc_state *nmps;
+	/** next state if the next encoded symbol is the LPS */
+	struct opj_mqc_state *nlps;
+} opj_mqc_state_t;
+
+#define MQC_NUMCTXS 32
+
+/**
+MQ coder
+*/
+typedef struct opj_mqc {
+	unsigned int c;
+	unsigned int a;
+	unsigned int ct;
+	unsigned char *bp;
+	unsigned char *start;
+	unsigned char *end;
+	opj_mqc_state_t *ctxs[MQC_NUMCTXS];
+	opj_mqc_state_t **curctx;
+} opj_mqc_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new MQC handle 
+@return Returns a new MQC handle if successful, returns NULL otherwise
+*/
+opj_mqc_t* mqc_create();
+/**
+Destroy a previously created MQC handle
+@param mqc MQC handle to destroy
+*/
+void mqc_destroy(opj_mqc_t *mqc);
+/**
+Return the number of bytes written/read since initialisation
+@param mqc MQC handle
+@return Returns the number of bytes already encoded
+*/
+int mqc_numbytes(opj_mqc_t *mqc);
+/**
+Reset the states of all the context of the coder/decoder 
+(each context is set to a state where 0 and 1 are more or less equiprobable)
+@param mqc MQC handle
+*/
+void mqc_resetstates(opj_mqc_t *mqc);
+/**
+Set the state of a particular context
+@param mqc MQC handle
+@param ctxno Number that identifies the context
+@param msb The MSB of the new state of the context
+@param prob Number that identifies the probability of the symbols for the new state of the context
+*/
+void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob);
+/**
+Initialize the encoder
+@param mqc MQC handle
+@param bp Pointer to the start of the buffer where the bytes will be written
+*/
+void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp);
+/**
+Set the current context used for coding/decoding
+@param mqc MQC handle
+@param ctxno Number that identifies the context
+*/
+void mqc_setcurctx(opj_mqc_t *mqc, int ctxno);
+/**
+Encode a symbol using the MQ-coder
+@param mqc MQC handle
+@param d The symbol to be encoded (0 or 1)
+*/
+void mqc_encode(opj_mqc_t *mqc, int d);
+/**
+Flush the encoder, so that all remaining data is written
+@param mqc MQC handle
+*/
+void mqc_flush(opj_mqc_t *mqc);
+/**
+BYPASS mode switch, initialization operation. 
+JPEG 2000 p 505. 
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+*/
+void mqc_bypass_init_enc(opj_mqc_t *mqc);
+/**
+BYPASS mode switch, coding operation. 
+JPEG 2000 p 505. 
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+@param d The symbol to be encoded (0 or 1)
+*/
+void mqc_bypass_enc(opj_mqc_t *mqc, int d);
+/**
+BYPASS mode switch, flush operation
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+@return Returns 1 (always)
+*/
+int mqc_bypass_flush_enc(opj_mqc_t *mqc);
+/**
+RESET mode switch
+@param mqc MQC handle
+*/
+void mqc_reset_enc(opj_mqc_t *mqc);
+/**
+RESET mode switch
+@param mqc MQC handle
+*/
+void mqc_reset_enc_3(opj_mqc_t *mqc);
+/**
+RESTART mode switch (TERMALL)
+@param mqc MQC handle
+@return Returns 1 (always)
+*/
+int mqc_restart_enc(opj_mqc_t *mqc);
+/**
+RESTART mode switch (TERMALL) reinitialisation
+@param mqc MQC handle
+*/
+void mqc_restart_init_enc(opj_mqc_t *mqc);
+/**
+ERTERM mode switch (PTERM)
+@param mqc MQC handle
+*/
+void mqc_erterm_enc(opj_mqc_t *mqc);
+/**
+SEGMARK mode switch (SEGSYM)
+@param mqc MQC handle
+*/
+void mqc_segmark_enc(opj_mqc_t *mqc);
+/**
+Initialize the decoder
+@param mqc MQC handle
+@param bp Pointer to the start of the buffer from which the bytes will be read
+@param len Length of the input buffer
+*/
+void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len);
+/**
+Decode a symbol
+@param mqc MQC handle
+@return Returns the decoded symbol (0 or 1)
+*/
+int mqc_decode(opj_mqc_t *mqc);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __MQC_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/openjpeg.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/openjpeg.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/openjpeg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/openjpeg.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,207 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef WIN32
+#include <windows.h>
+#endif /* WIN32 */
+
+#include "opj_includes.h"
+
+/* ---------------------------------------------------------------------- */
+#ifdef WIN32
+#ifndef OPJ_STATIC
+BOOL APIENTRY
+DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
+	switch (ul_reason_for_call) {
+		case DLL_PROCESS_ATTACH :
+			break;
+		case DLL_PROCESS_DETACH :
+			break;
+		case DLL_THREAD_ATTACH :
+		case DLL_THREAD_DETACH :
+			break;
+    }
+
+    return TRUE;
+}
+#endif /* OPJ_STATIC */
+#endif /* WIN32 */
+
+/* ---------------------------------------------------------------------- */
+
+const char* OPJ_CALLCONV opj_version() {
+    return OPENJPEG_VERSION;
+}
+opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format) {
+	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_malloc(sizeof(opj_dinfo_t));
+	if(!dinfo) return NULL;
+	dinfo->is_decompressor = true;
+	switch(format) {
+		case CODEC_J3D:
+		case CODEC_J2K:
+			/* get a J3D decoder handle */
+			dinfo->j3d_handle = (void*)j3d_create_decompress((opj_common_ptr)dinfo);
+			if(!dinfo->j3d_handle) {
+				opj_free(dinfo);
+				return NULL;
+			}
+			break;
+		default:
+			opj_free(dinfo);
+			return NULL;
+	}
+
+	dinfo->codec_format = format;
+
+	return dinfo;
+}
+
+void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo) {
+	if(dinfo) {
+		/* destroy the codec */
+		if(dinfo->codec_format != CODEC_UNKNOWN) {
+			j3d_destroy_decompress((opj_j3d_t*)dinfo->j3d_handle);
+		}
+		/* destroy the decompressor */
+		opj_free(dinfo);
+	}
+}
+
+void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters) {
+	if(parameters) {
+		memset(parameters, 0, sizeof(opj_dparameters_t));
+		/* default decoding parameters */
+		parameters->cp_layer = 0;
+		parameters->cp_reduce[0] = 0;
+		parameters->cp_reduce[1] = 0;
+		parameters->cp_reduce[2] = 0;
+		parameters->bigendian = 0;
+
+		parameters->decod_format = -1;
+		parameters->cod_format = -1;
+	}
+}
+
+void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters) {
+	if(dinfo && parameters) {
+		if (dinfo->codec_format != CODEC_UNKNOWN) {
+			j3d_setup_decoder((opj_j3d_t*)dinfo->j3d_handle, parameters);
+		}
+	}
+}
+
+opj_volume_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio) {
+	if(dinfo && cio) {
+		if (dinfo->codec_format != CODEC_UNKNOWN) {
+			return j3d_decode((opj_j3d_t*)dinfo->j3d_handle, cio);
+		}
+	}
+
+	return NULL;
+}
+
+opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format) {
+	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_malloc(sizeof(opj_cinfo_t));
+	if(!cinfo) return NULL;
+	cinfo->is_decompressor = false;
+	switch(format) {
+		case CODEC_J3D:
+		case CODEC_J2K:
+			/* get a J3D coder handle */
+			cinfo->j3d_handle = (void*)j3d_create_compress((opj_common_ptr)cinfo);
+			if(!cinfo->j3d_handle) {
+				opj_free(cinfo);
+				return NULL;
+			}
+			break;
+		default:
+			opj_free(cinfo);
+			return NULL;
+	}
+
+	cinfo->codec_format = format;
+
+	return cinfo;
+}
+
+void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo) {
+	if(cinfo) {
+		/* destroy the codec */
+		if (cinfo->codec_format != CODEC_UNKNOWN) {
+				j3d_destroy_compress((opj_j3d_t*)cinfo->j3d_handle);
+		}
+		/* destroy the decompressor */
+		opj_free(cinfo);
+	}
+}
+
+void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters) {
+	if(parameters) {
+		memset(parameters, 0, sizeof(opj_cparameters_t));
+		/* default coding parameters */
+		parameters->numresolution[0] = 3;
+		parameters->numresolution[1] = 3;
+		parameters->numresolution[2] = 1;
+		parameters->cblock_init[0] = 64;
+		parameters->cblock_init[1] = 64;
+		parameters->cblock_init[2] = 64;
+		parameters->prog_order = LRCP;
+		parameters->roi_compno = -1;		/* no ROI */
+		parameters->atk_wt[0] = 1;				/* 5-3 WT */
+		parameters->atk_wt[1] = 1;				/* 5-3 WT */
+		parameters->atk_wt[2] = 1;				/* 5-3 WT */
+		parameters->irreversible = 0;
+		parameters->subsampling_dx = 1;
+		parameters->subsampling_dy = 1;
+		parameters->subsampling_dz = 1;
+
+		parameters->decod_format = -1;
+		parameters->cod_format = -1;
+		parameters->encoding_format = ENCOD_2EB;
+		parameters->transform_format = TRF_2D_DWT;
+	}
+}
+
+void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_volume_t *volume) {
+	if(cinfo && parameters && volume) {
+		if (cinfo->codec_format != CODEC_UNKNOWN) {
+			j3d_setup_encoder((opj_j3d_t*)cinfo->j3d_handle, parameters, volume);
+		}
+	}
+}
+
+bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_volume_t *volume, char *index) {
+	if(cinfo && cio && volume) {
+		if (cinfo->codec_format != CODEC_UNKNOWN) {
+			return j3d_encode((opj_j3d_t*)cinfo->j3d_handle, cio, volume, index);
+		}
+	}
+
+	return false;
+}
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/openjpeg.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/openjpeg.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/openjpeg.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/openjpeg.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,715 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPENJPEG_H
+#define OPENJPEG_H
+
+#define OPENJPEG_VERSION "1.0.0"
+
+/* 
+==========================================================
+   Compiler directives
+==========================================================
+*/
+
+#if defined(OPJ_STATIC) || !(defined(WIN32) || defined(__WIN32__))
+#define OPJ_API
+#define OPJ_CALLCONV
+#else
+#define OPJ_CALLCONV __stdcall
+/*
+The following ifdef block is the standard way of creating macros which make exporting 
+from a DLL simpler. All files within this DLL are compiled with the OPJ_EXPORTS
+symbol defined on the command line. this symbol should not be defined on any project
+that uses this DLL. This way any other project whose source files include this file see 
+OPJ_API functions as being imported from a DLL, wheras this DLL sees symbols
+defined with this macro as being exported.
+*/
+#ifdef OPJ_EXPORTS
+#define OPJ_API __declspec(dllexport)
+#else
+#define OPJ_API __declspec(dllimport)
+#endif /* OPJ_EXPORTS */
+#endif /* !OPJ_STATIC || !WIN32 */
+
+#ifndef __cplusplus
+#if defined(HAVE_STDBOOL_H)
+/*
+The C language implementation does correctly provide the standard header
+file "stdbool.h".
+ */
+#include <stdbool.h>
+#else
+/*
+The C language implementation does not provide the standard header file
+"stdbool.h" as required by ISO/IEC 9899:1999.  Try to compensate for this
+braindamage below.
+*/
+#if !defined(bool)
+#define	bool	int
+#endif
+#if !defined(true)
+#define true	1
+#endif
+#if !defined(false)
+#define	false	0
+#endif
+#endif
+#endif /* __cplusplus */
+
+/* 
+==========================================================
+   Useful constant definitions
+==========================================================
+*/
+#ifndef MAX_SLICES
+#define MAX_SLICES 300	/**< Maximum allowed size for slices */
+#endif /* MAX_PATH */
+
+#ifndef MAX_PATH
+#define MAX_PATH 260	/**< Maximum allowed size for filenames */
+#endif /* MAX_PATH */
+
+#define J3D_MAXRLVLS 32					/**< Number of maximum resolution level authorized */
+#define J3D_MAXBANDS (7*J3D_MAXRLVLS + 1)	/**< Number of maximum sub-band linked to number of resolution level */
+
+#define TINY 1.0E-20
+/* 
+==========================================================
+   enum definitions
+==========================================================
+*/
+
+#define J2K_CFMT 0
+#define J3D_CFMT 1
+#define LSE_CFMT 2
+
+#define BIN_DFMT 0
+#define PGX_DFMT 1
+#define IMG_DFMT 2
+/* ----------------------------------------------------------------------- */
+
+/** Progression order */
+typedef enum PROG_ORDER {
+/**< place-holder */	
+	PROG_UNKNOWN = -1,	
+/**< layer-resolution-component-precinct order */	
+	LRCP = 0,		
+/**< resolution-layer-component-precinct order */	
+	RLCP = 1,		
+/**< resolution-precinct-component-layer order */	
+	RPCL = 2,		
+/**< precinct-component-resolution-layer order */	
+	PCRL = 3,		
+/**< component-precinct-resolution-layer order */	
+	CPRL = 4		
+} OPJ_PROG_ORDER;
+
+/**
+Supported volume color spaces
+*/
+typedef enum COLOR_SPACE {
+/**< place-holder */	
+	CLRSPC_UNKNOWN = -1,	
+/**< sRGB */	
+	CLRSPC_SRGB = 1,		
+/**< grayscale */	
+	CLRSPC_GRAY = 2,		
+/**< YUV */	
+	CLRSPC_SYCC = 3			
+} OPJ_COLOR_SPACE;
+
+/**
+Supported codec
+*/
+typedef enum CODEC_FORMAT {
+	/**< place-holder */
+	CODEC_UNKNOWN = -1,
+/**< JPEG-2000 codestream : read/write */
+	CODEC_J2K = 0,		
+/**< JPEG-2000 Part 10 file format : read/write */
+	CODEC_J3D = 1		
+} OPJ_CODEC_FORMAT;
+
+/**
+Supported entropy coding algorithms
+*/
+typedef enum ENTROPY_CODING {
+/**< place-holder */
+	ENCOD_UNKNOWN = -1,
+/**< 2D EBCOT encoding */
+	ENCOD_2EB = 0,		
+/**< 3D EBCOT encoding */
+	ENCOD_3EB = 1,		
+/**< Golomb-Rice coding with 2D context */
+	ENCOD_2GR = 2,		
+/**< Golomb-Rice coding with 3D context  */
+	ENCOD_3GR = 3		
+} OPJ_ENTROPY_CODING;
+
+/**
+Supported transforms
+*/
+typedef enum TRANSFORM {
+/**< place-holder */
+	TRF_UNKNOWN = -1,	
+/**< 2D DWT, no transform in axial dim */
+	TRF_2D_DWT = 0,		
+/**< 3D DWT */
+	TRF_3D_DWT = 1,		
+/**< 3D prediction*/
+	TRF_3D_RLS = 2,		
+	TRF_3D_LSE = 3
+} OPJ_TRANSFORM;
+/* 
+==========================================================
+   event manager typedef definitions
+==========================================================
+*/
+
+/**
+Callback function prototype for events
+@param msg Event message
+@param client_data 
+*/
+typedef void (*opj_msg_callback) (const char *msg, void *client_data);
+
+/**
+Message handler object
+used for 
+<ul>
+<li>Error messages
+<li>Warning messages
+<li>Debugging messages
+</ul>
+*/
+typedef struct opj_event_mgr {
+	/** Error message callback if available, NULL otherwise */
+	opj_msg_callback error_handler;
+	/** Warning message callback if available, NULL otherwise */
+	opj_msg_callback warning_handler;
+	/** Debug message callback if available, NULL otherwise */
+	opj_msg_callback info_handler;
+} opj_event_mgr_t;
+
+
+/* 
+==========================================================
+   codec typedef definitions
+==========================================================
+*/
+
+/**
+Progression order changes
+*/
+typedef struct opj_poc {
+  int resno0, compno0;
+  int layno1, resno1, compno1;
+  OPJ_PROG_ORDER prg;
+  int tile;
+  char progorder[4];
+} opj_poc_t;
+
+
+/**
+Compression parameters
+*/
+typedef struct opj_cparameters {
+/** size of tile: tile_size_on = false (not in argument) or = true (in argument) */
+	bool tile_size_on;	
+/** XTOsiz */
+	int cp_tx0;
+/** YTOsiz */
+	int cp_ty0;	
+/** ZTOsiz */
+	int cp_tz0;		
+
+/** XTsiz */
+	int cp_tdx;	
+/** YTsiz */
+	int cp_tdy;	
+/** ZTsiz */
+	int cp_tdz;		
+							
+/** allocation by rate/distortion */
+	int cp_disto_alloc;		
+/** allocation by fixed layer */		
+	int cp_fixed_alloc;		
+/** add fixed_quality */	
+	int cp_fixed_quality;	
+/** fixed layer */
+	int *cp_matrice;
+/** number of layers */
+	int tcp_numlayers;
+/** rates for successive layers */
+	float tcp_rates[100];
+/** psnr's for successive layers */
+	float tcp_distoratio[100];	
+/** comment for coding */
+	char *cp_comment;
+/** csty : coding style */
+	int csty;					
+/** DC offset (DCO) */
+	int dcoffset;
+/** progression order (default LRCP) */
+	OPJ_PROG_ORDER prog_order;	
+/** progression order changes */
+	opj_poc_t POC[J3D_MAXRLVLS-1];	
+/** number of progression order changes (POC), default to 0 */
+	int numpocs;				
+
+/** number of resolutions */
+	int numresolution[3];		
+/** initial code block width, height and depth, default to 64 */
+ 	int cblock_init[3];			
+/** mode switch (1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL) 8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)) */
+	int mode;					
+
+/** 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default) */
+	int irreversible;			
+/** WT from ATK, default to 0 (false), no of atk used */
+	int atk_wt[3];
+/** region of interest: affected component in [0..3], -1 means no ROI */
+	int roi_compno;				
+/** region of interest: upshift value */
+	int roi_shift;				
+
+/* number of precinct size specifications */
+	int res_spec;				
+/** initial precinct width */
+	int prct_init[3][J3D_MAXRLVLS];	
+
+/** transform format 0: 0: 2DWT, 1: 2D1P, 2: 3DWT, 3: 3RLS */
+	OPJ_TRANSFORM transform_format;	
+/** output file format 0: 2EB, 1: 3EB, 2: 2GR, 3: 3GR, 4: GRI */
+	OPJ_ENTROPY_CODING encoding_format;	
+
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+	char infile[MAX_PATH];		/** input file name */
+	char outfile[MAX_PATH];		/** output file name */
+	char imgfile[MAX_PATH];		/** IMG file name for BIN volumes*/
+	int index_on;				/** creation of an index file, default to 0 (false) */
+	char index[MAX_PATH];		/** index file name */
+	
+	int volume_offset_x0;		/** subvolume encoding: origin volume offset in x, y and z direction */
+	int volume_offset_y0;
+	int volume_offset_z0;
+	
+	int subsampling_dx;			/** subsampling value for dx */
+	int subsampling_dy;
+	int subsampling_dz;
+	
+	int decod_format;			/** input file format 0: BIN, 1: PGX */
+	int cod_format;				/** output file format 0: JP3D */
+	/*@}*/
+} opj_cparameters_t;
+
+/**
+Decompression parameters
+*/
+typedef struct opj_dparameters {
+/** Set the number of highest resolution levels to be discarded. if != 0, then original dimension divided by 2^(reduce); if == 0 or not used, volume is decoded to the full resolution */
+	int cp_reduce[3];		
+/** Set the maximum number of quality layers to decode. if != 0, then only the first "layer" layers are decoded; if == 0 or not used, all the quality layers are decoded 	*/
+	int cp_layer;	
+	int bigendian;
+	
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+/** input file name */
+	char infile[MAX_PATH];	
+/** output file name */
+	char outfile[MAX_PATH];	
+/** IMG file name for BIN volumes*/
+	char imgfile[MAX_PATH];
+/** Original file name for PSNR measures*/
+	char original[MAX_PATH];
+/** input file format 0: J2K, 1: JP3D */
+	int decod_format;		
+/** input file format 0: BIN, 1: PGM */
+	int cod_format;
+/** original file format 0: BIN, 1: PGM */
+	int orig_format;	
+	/*@}*/
+} opj_dparameters_t;
+
+/** Common fields between JPEG-2000 compression and decompression master structs. */
+#define opj_common_fields \
+	opj_event_mgr_t *event_mgr;	/**< pointer to the event manager */\
+	void * client_data;			/**< Available for use by application */\
+	bool is_decompressor;		/**< So common code can tell which is which */\
+	OPJ_CODEC_FORMAT codec_format;		/**< selected codec */\
+	OPJ_ENTROPY_CODING encoding_format;	/**< selected entropy coding */\
+	OPJ_TRANSFORM transform_format;		/**< selected transform */\
+	void *j3d_handle			/**< pointer to the J3D codec */
+	
+/* Routines that are to be used by both halves of the library are declared
+ * to receive a pointer to this structure.  There are no actual instances of
+ * opj_common_struct_t, only of opj_cinfo_t and opj_dinfo_t.
+ */
+typedef struct opj_common_struct {
+  opj_common_fields;		/* Fields common to both master struct types */
+  /* Additional fields follow in an actual opj_cinfo_t or
+   * opj_dinfo_t.  All three structs must agree on these
+   * initial fields!  (This would be a lot cleaner in C++.)
+   */
+} opj_common_struct_t;
+
+typedef opj_common_struct_t * opj_common_ptr;
+
+/**
+Compression context info
+*/
+typedef struct opj_cinfo {
+	/** Fields shared with opj_dinfo_t */
+	opj_common_fields;	
+	/* other specific fields go here */
+} opj_cinfo_t;
+
+/**
+Decompression context info
+*/
+typedef struct opj_dinfo {
+	/** Fields shared with opj_cinfo_t */
+	opj_common_fields;	
+	/* other specific fields go here */
+} opj_dinfo_t;
+
+/* 
+==========================================================
+   I/O stream typedef definitions
+==========================================================
+*/
+
+/*
+ * Stream open flags.
+ */
+/** The stream was opened for reading. */
+#define OPJ_STREAM_READ	0x0001
+/** The stream was opened for writing. */
+#define OPJ_STREAM_WRITE 0x0002
+
+/**
+Byte input-output stream (CIO)
+*/
+typedef struct opj_cio {
+/** codec context */
+	opj_common_ptr cinfo;	
+/** open mode (read/write) either OPJ_STREAM_READ or OPJ_STREAM_WRITE */
+	int openmode;			
+/** pointer to the start of the buffer */
+	unsigned char *buffer;	
+/** buffer size in bytes */
+	int length;				
+/** pointer to the start of the stream */
+	unsigned char *start;		
+/** pointer to the end of the stream */
+	unsigned char *end;			
+/** pointer to the current position */
+	unsigned char *bp;			
+} opj_cio_t;
+
+/* 
+==========================================================
+   volume typedef definitions
+==========================================================
+*/
+
+/**
+Defines a single volume component
+*/
+typedef struct opj_volume_comp {
+/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
+	int dx;	
+/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
+	int dy;	
+/** ZRsiz: vertical separation of a sample of ith component with respect to the reference grid */
+	int dz;
+/** data width */
+	int w;	
+	/** data height */
+	int h;	
+	/** data length : no of slices */
+	int l;	
+	/** x component offset compared to the whole volume */
+	int x0;	
+	/** y component offset compared to the whole volume */
+	int y0;	
+	/** z component offset compared to the whole volume */
+	int z0;	
+	/** precision */
+	int prec;	
+	/** volume depth in bits */
+	int bpp;	
+	/** DC offset (15444-2) */
+	int dcoffset;
+	/** signed (1) / unsigned (0) */
+	int sgnd;		
+	/** BE byte order (1) / LE byte order  (0) */
+	int bigendian;
+	/** number of decoded resolution */
+	int resno_decoded[3];	
+	/** number of division by 2 of the out volume compared to the original size of volume */
+	int factor[3];	
+	/** volume component data */
+	int *data;				
+} opj_volume_comp_t;
+
+/** 
+Defines volume data and characteristics
+*/
+typedef struct opj_volume {
+/** XOsiz: horizontal offset from the origin of the reference grid to the left side of the volume area */
+	int x0;	
+/** YOsiz: vertical offset from the origin of the reference grid to the top side of the volume area */
+	int y0;	
+/** ZOsiz: vertical offset from the origin of the reference grid to the top side of the volume area */
+	int z0;	
+/** Xsiz: width of the reference grid */
+	int x1;	
+/** Ysiz: height of the reference grid */
+	int y1;	
+/** Zsiz: length of the reference grid */
+	int z1;	
+/** number of components in the volume */
+	int numcomps;	
+/** number of slices in the volume */
+	int numslices;	
+/** color space: sRGB, Greyscale or YUV */
+	OPJ_COLOR_SPACE color_space;
+/** volume components */
+	opj_volume_comp_t *comps;	
+} opj_volume_t;
+
+/**
+Component parameters structure used by the opj_volume_create function
+*/
+typedef struct opj_volume_comptparm {
+	/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
+	int dx;	
+	/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
+	int dy;	
+	/** ZRsiz: axial separation of a sample of ith component with respect to the reference grid */
+	int dz;	
+	/** data width */
+	int w;	
+	/** data height */
+	int h;	
+	/** data length */
+	int l;	
+	/** x component offset compared to the whole volume */
+	int x0;	
+	/** y component offset compared to the whole volume */
+	int y0;
+	/** z component offset compared to the whole volume */
+	int z0;	
+	/** precision */
+	int prec;
+	/** volume depth in bits */
+	int bpp;	
+	/** signed (1) / unsigned (0) */
+	int sgnd;
+	/** DC offset*/
+	int dcoffset;
+	/** BE byte order (1) / LE byte order  (0) */
+	int bigendian;
+} opj_volume_cmptparm_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* 
+==========================================================
+   openjpeg version
+==========================================================
+*/
+
+OPJ_API const char * OPJ_CALLCONV opj_version();
+
+/* 
+==========================================================
+   volume functions definitions
+==========================================================
+*/
+
+/**
+Create an volume
+@param numcmpts number of components
+@param cmptparms components parameters
+@param clrspc volume color space
+@return returns a new volume structure if successful, returns NULL otherwise
+*/
+OPJ_API opj_volume_t* OPJ_CALLCONV opj_volume_create(int numcmpts, opj_volume_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc);
+
+/**
+Deallocate any resources associated with an volume
+@param volume volume to be destroyed
+*/
+OPJ_API void OPJ_CALLCONV opj_volume_destroy(opj_volume_t *volume);
+
+/* 
+==========================================================
+   stream functions definitions
+==========================================================
+*/
+
+/**
+Open and allocate a memory stream for read / write. 
+On reading, the user must provide a buffer containing encoded data. The buffer will be 
+wrapped by the returned CIO handle. 
+On writing, buffer parameters must be set to 0: a buffer will be allocated by the library 
+to contain encoded data. 
+@param cinfo Codec context info
+@param buffer Reading: buffer address. Writing: NULL
+@param length Reading: buffer length. Writing: 0
+@return Returns a CIO handle if successful, returns NULL otherwise
+*/
+OPJ_API opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length);
+
+/**
+Close and free a CIO handle
+@param cio CIO handle to free
+*/
+OPJ_API void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio);
+
+/**
+Get position in byte stream
+@param cio CIO handle
+@return Returns the position in bytes
+*/
+OPJ_API int OPJ_CALLCONV cio_tell(opj_cio_t *cio);
+/**
+Set position in byte stream
+@param cio CIO handle
+@param pos Position, in number of bytes, from the beginning of the stream
+*/
+OPJ_API void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos);
+
+/* 
+==========================================================
+   event manager functions definitions
+==========================================================
+*/
+
+OPJ_API opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context);
+
+/* 
+==========================================================
+   codec functions definitions
+==========================================================
+*/
+/**
+Creates a J3D decompression structure
+@param format Decoder to select
+@return Returns a handle to a decompressor if successful, returns NULL otherwise
+*/
+OPJ_API opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format);
+/**
+Destroy a decompressor handle
+@param dinfo decompressor handle to destroy
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo);
+/**
+Set decoding parameters to default values
+@param parameters Decompression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in j3d->cp. 
+@param dinfo decompressor handle
+@param parameters decompression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters);
+/**
+Decode an volume from a JPEG-2000 codestream
+@param dinfo decompressor handle
+@param cio Input buffer stream
+@return Returns a decoded volume if successful, returns NULL otherwise
+*/
+OPJ_API opj_volume_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio);
+/**
+Creates a J3D/JP2 compression structure
+@param format Coder to select
+@return Returns a handle to a compressor if successful, returns NULL otherwise
+*/
+OPJ_API opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format);
+/**
+Destroy a compressor handle
+@param cinfo compressor handle to destroy
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo);
+/**
+Set encoding parameters to default values, that means : 
+<ul>
+<li>Lossless
+<li>1 tile
+<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)
+<li>Size of code-block : 64 x 64
+<li>Number of resolutions: 6
+<li>No SOP marker in the codestream
+<li>No EPH marker in the codestream
+<li>No sub-sampling in x or y direction
+<li>No mode switch activated
+<li>Progression order: LRCP
+<li>No index file
+<li>No ROI upshifted
+<li>No offset of the origin of the volume
+<li>No offset of the origin of the tiles
+<li>Reversible DWT 5-3
+</ul>
+@param parameters Compression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters);
+/**
+Setup the encoder parameters using the current volume and using user parameters. 
+@param cinfo compressor handle
+@param parameters compression parameters
+@param volume input filled volume
+*/
+OPJ_API void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_volume_t *volume);
+/**
+Encode an volume into a JPEG-2000 codestream
+@param cinfo compressor handle
+@param cio Output buffer stream
+@param volume Volume to encode
+@param index Name of the index file if required, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+OPJ_API bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_volume_t *volume, char *index);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OPENJPEG_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/opj_includes.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/opj_includes.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/opj_includes.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/opj_includes.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,82 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPJ_INCLUDES_H
+#define OPJ_INCLUDES_H
+
+/*
+ ==========================================================
+   Standard includes used by the library
+ ==========================================================
+*/
+#include <memory.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <float.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <ctype.h>
+#include <assert.h>
+/*
+ ==========================================================
+   OpenJPEG interface
+ ==========================================================
+ */
+#include "openjpeg.h"
+
+/*
+ ==========================================================
+   OpenJPEG modules
+ ==========================================================
+*/
+
+#include "dirent.h"
+#include "jp3d_lib.h"
+#include "event.h"
+#include "cio.h"
+
+#include "volume.h"
+#include "jp3d.h"
+
+#include "mqc.h"
+#include "raw.h"
+#include "bio.h"
+#include "tgt.h"
+#include "tcd.h"
+#include "t1.h"
+#include "t1_3d.h"
+#include "dwt.h"
+#include "pi.h"
+#include "t2.h"
+#include "mct.h"
+#include "int.h"
+#include "fix.h"
+
+//#include "pred.h"
+//#include "golomb.h"
+
+#endif /* OPJ_INCLUDES_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/pi.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/pi.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,630 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup PI PI - Implementation of a packet iterator */
+/*@{*/
+
+/** @name Funciones locales */
+/*@{*/
+
+/**
+Get next packet in layer-resolution-component-precinct order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_lrcp(opj_pi_iterator_t * pi);
+/**
+Get next packet in resolution-layer-component-precinct order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_rlcp(opj_pi_iterator_t * pi);
+/**
+Get next packet in resolution-precinct-component-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_rpcl(opj_pi_iterator_t * pi);
+/**
+Get next packet in precinct-component-resolution-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_pcrl(opj_pi_iterator_t * pi);
+/**
+Get next packet in component-precinct-resolution-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_cprl(opj_pi_iterator_t * pi);
+
+/*@}*/
+
+/*@}*/
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static bool pi_next_lrcp(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+		for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolution[0]) {
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				//for (pi->precno = 0; pi->precno < (res->prctno[0] * res->prctno[1]); pi->precno++) {
+				for (pi->precno = 0; pi->precno < (res->prctno[0] * res->prctno[1] * res->prctno[2]); pi->precno++) {
+					index = pi->layno * pi->step_l 
+						+ pi->resno * pi->step_r 
+						+ pi->compno * pi->step_c 
+						+ pi->precno * pi->step_p;
+					if (!pi->include[index]) {
+						pi->include[index] = 1;
+						return true;
+					}
+LABEL_SKIP:;
+
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_rlcp(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolution[0]) {
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				//for (pi->precno = 0; pi->precno < (res->prctno[0] * res->prctno[1]); pi->precno++) {
+				for (pi->precno = 0; pi->precno < (res->prctno[0] * res->prctno[1] * res->prctno[2]); pi->precno++) {
+					index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+					if (!pi->include[index]) {
+						pi->include[index] = 1;
+						return true;
+					}
+LABEL_SKIP:;
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_rpcl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		goto LABEL_SKIP;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolution[0]; resno++) {
+				int dx, dy,dz;
+				res = &comp->resolutions[resno];
+				dx = comp->dx * (1 << (res->pdx + comp->numresolution[0] - 1 - resno));
+				dy = comp->dy * (1 << (res->pdy + comp->numresolution[1] - 1 - resno));
+				dz = comp->dz * (1 << (res->pdz + comp->numresolution[2] - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+				pi->dz = !pi->dz ? dz : int_min(pi->dz, dz);
+			}
+		}
+	}
+
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->z = pi->tz0; pi->z < pi->tz1; pi->z += pi->dz - (pi->z % pi->dz)) {
+			for (pi->y = pi->ty0; pi->y < pi->ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+				for (pi->x = pi->tx0; pi->x < pi->tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+					for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+						int levelnox, levelnoy, levelnoz;
+						int trx0, try0, trz0;
+						int trx1, try1, trz1;
+						int rpx, rpy, rpz;
+						int prci, prcj, prck;
+						comp = &pi->comps[pi->compno];
+						if (pi->resno >= comp->numresolution[0]) {
+							continue;
+						}
+						res = &comp->resolutions[pi->resno];
+						levelnox = comp->numresolution[0] - 1 - pi->resno;
+						levelnoy = comp->numresolution[1] - 1 - pi->resno;
+						levelnoz = comp->numresolution[2] - 1 - pi->resno;
+						trx0 = int_ceildiv(pi->tx0, comp->dx << levelnox);
+						try0 = int_ceildiv(pi->ty0, comp->dy << levelnoy);
+						trz0 = int_ceildiv(pi->tz0, comp->dz << levelnoz);
+						trx1 = int_ceildiv(pi->tx1, comp->dx << levelnox);
+						try1 = int_ceildiv(pi->ty1, comp->dy << levelnoy);
+						trz1 = int_ceildiv(pi->tz1, comp->dz << levelnoz);
+						rpx = res->pdx + levelnox;
+						rpy = res->pdy + levelnoy;
+						rpz = res->pdz + levelnoz;
+						if ((!(pi->x % (comp->dx << rpx) == 0) || (pi->x == pi->tx0 && (trx0 << levelnox) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->y % (comp->dy << rpy) == 0) || (pi->y == pi->ty0 && (try0 << levelnoy) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->z % (comp->dz << rpz) == 0) || (pi->z == pi->tz0 && (trz0 << levelnoz) % (1 << rpx)))) {
+							continue;
+						}
+						if ((res->prctno[0]==0)||(res->prctno[1]==0)||(res->prctno[2]==0)) continue;
+						
+						if ((trx0==trx1)||(try0==try1)||(trz0==trz1)) continue;
+						
+						prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelnox), res->pdx) 
+							- int_floordivpow2(trx0, res->pdx);
+						prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelnoy), res->pdy) 
+							- int_floordivpow2(try0, res->pdy);
+						prck = int_floordivpow2(int_ceildiv(pi->z, comp->dz << levelnoz), res->pdz) 
+							- int_floordivpow2(trz0, res->pdz);
+						pi->precno = prci + prcj * res->prctno[0] + prck * res->prctno[0] * res->prctno[1];
+						for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+							index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+							if (!pi->include[index]) {
+								pi->include[index] = 1;
+								return true;
+							}
+	LABEL_SKIP:;
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_pcrl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto LABEL_SKIP;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		pi->dz = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolution[0]; resno++) {
+				int dx, dy, dz;
+				res = &comp->resolutions[resno];
+				dx = comp->dx * (1 << (res->pdx + comp->numresolution[0] - 1 - resno));
+				dy = comp->dy * (1 << (res->pdy + comp->numresolution[1] - 1 - resno));
+				dz = comp->dz * (1 << (res->pdy + comp->numresolution[2] - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+				pi->dz = !pi->dz ? dz : int_min(pi->dz, dz);
+			}
+		}
+	}
+
+for (pi->z = pi->tz0; pi->z < pi->tz1; pi->z += pi->dz - (pi->z % pi->dz)) {
+	for (pi->y = pi->ty0; pi->y < pi->ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+		for (pi->x = pi->tx0; pi->x < pi->tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolution[0]); pi->resno++) {
+						int levelnox, levelnoy, levelnoz;
+						int trx0, try0, trz0;
+						int trx1, try1, trz1;
+						int rpx, rpy, rpz;
+						int prci, prcj, prck;
+						comp = &pi->comps[pi->compno];
+						if (pi->resno >= comp->numresolution[0]) {
+							continue;
+						}
+						res = &comp->resolutions[pi->resno];
+						levelnox = comp->numresolution[0] - 1 - pi->resno;
+						levelnoy = comp->numresolution[1] - 1 - pi->resno;
+						levelnoz = comp->numresolution[2] - 1 - pi->resno;
+						trx0 = int_ceildiv(pi->tx0, comp->dx << levelnox);
+						try0 = int_ceildiv(pi->ty0, comp->dy << levelnoy);
+						trz0 = int_ceildiv(pi->tz0, comp->dz << levelnoz);
+						trx1 = int_ceildiv(pi->tx1, comp->dx << levelnox);
+						try1 = int_ceildiv(pi->ty1, comp->dy << levelnoy);
+						trz1 = int_ceildiv(pi->tz1, comp->dz << levelnoz);
+						rpx = res->pdx + levelnox;
+						rpy = res->pdy + levelnoy;
+						rpz = res->pdz + levelnoz;
+						if ((!(pi->x % (comp->dx << rpx) == 0) || (pi->x == pi->tx0 && (trx0 << levelnox) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->y % (comp->dy << rpy) == 0) || (pi->y == pi->ty0 && (try0 << levelnoy) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->z % (comp->dz << rpz) == 0) || (pi->z == pi->tz0 && (trz0 << levelnoz) % (1 << rpx)))) {
+							continue;
+						}
+						if ((res->prctno[0]==0)||(res->prctno[1]==0)||(res->prctno[2]==0)) continue;
+						
+						if ((trx0==trx1)||(try0==try1)||(trz0==trz1)) continue;
+						
+						prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelnox), res->pdx) 
+							- int_floordivpow2(trx0, res->pdx);
+						prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelnoy), res->pdy) 
+							- int_floordivpow2(try0, res->pdy);
+						prck = int_floordivpow2(int_ceildiv(pi->z, comp->dz << levelnoz), res->pdz) 
+							- int_floordivpow2(trz0, res->pdz);
+						pi->precno = prci + prcj * res->prctno[0] + prck * res->prctno[0] * res->prctno[1];
+						for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+							index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+							if (!pi->include[index]) {
+								pi->include[index] = 1;
+								return true;
+							}	
+LABEL_SKIP:;
+					}
+				}
+			}
+		}
+	}
+}
+	
+	return false;
+}
+
+static bool pi_next_cprl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+		int resno;
+		comp = &pi->comps[pi->compno];
+		pi->dx = 0;
+		pi->dy = 0;
+		for (resno = 0; resno < comp->numresolution[0]; resno++) {
+			int dx, dy;
+			res = &comp->resolutions[resno];
+			dx = comp->dx * (1 << (res->pdx + comp->numresolution[0] - 1 - resno));
+			dy = comp->dy * (1 << (res->pdy + comp->numresolution[0] - 1 - resno));
+			pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+			pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+		}
+	for (pi->z = pi->tz0; pi->z < pi->tz1; pi->z += pi->dz - (pi->z % pi->dz)) {
+		for (pi->y = pi->ty0; pi->y < pi->ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+			for (pi->x = pi->tx0; pi->x < pi->tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolution[0]); pi->resno++) {
+						int levelnox, levelnoy, levelnoz;
+						int trx0, try0, trz0;
+						int trx1, try1, trz1;
+						int rpx, rpy, rpz;
+						int prci, prcj, prck;
+						comp = &pi->comps[pi->compno];
+						if (pi->resno >= comp->numresolution[0]) {
+							continue;
+						}
+						res = &comp->resolutions[pi->resno];
+						levelnox = comp->numresolution[0] - 1 - pi->resno;
+						levelnoy = comp->numresolution[1] - 1 - pi->resno;
+						levelnoz = comp->numresolution[2] - 1 - pi->resno;
+						trx0 = int_ceildiv(pi->tx0, comp->dx << levelnox);
+						try0 = int_ceildiv(pi->ty0, comp->dy << levelnoy);
+						trz0 = int_ceildiv(pi->tz0, comp->dz << levelnoz);
+						trx1 = int_ceildiv(pi->tx1, comp->dx << levelnox);
+						try1 = int_ceildiv(pi->ty1, comp->dy << levelnoy);
+						trz1 = int_ceildiv(pi->tz1, comp->dz << levelnoz);
+						rpx = res->pdx + levelnox;
+						rpy = res->pdy + levelnoy;
+						rpz = res->pdz + levelnoz;
+						if ((!(pi->x % (comp->dx << rpx) == 0) || (pi->x == pi->tx0 && (trx0 << levelnox) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->y % (comp->dy << rpy) == 0) || (pi->y == pi->ty0 && (try0 << levelnoy) % (1 << rpx)))) {
+							continue;
+						}
+						if ((!(pi->z % (comp->dz << rpz) == 0) || (pi->z == pi->tz0 && (trz0 << levelnoz) % (1 << rpx)))) {
+							continue;
+						}
+						if ((res->prctno[0]==0)||(res->prctno[1]==0)||(res->prctno[2]==0)) continue;
+						
+						if ((trx0==trx1)||(try0==try1)||(trz0==trz1)) continue;
+						
+						prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelnox), res->pdx) 
+							- int_floordivpow2(trx0, res->pdx);
+						prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelnoy), res->pdy) 
+							- int_floordivpow2(try0, res->pdy);
+						prck = int_floordivpow2(int_ceildiv(pi->z, comp->dz << levelnoz), res->pdz) 
+							- int_floordivpow2(trz0, res->pdz);
+						pi->precno = prci + prcj * res->prctno[0] + prck * res->prctno[0] * res->prctno[1];
+						for (pi->layno = 0; pi->layno < pi->poc.layno1; pi->layno++) {
+							index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+							if (!pi->include[index]) {
+								pi->include[index] = 1;
+								return true;
+							}
+	LABEL_SKIP:;
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+/* 
+==========================================================
+   Packet iterator interface
+==========================================================
+*/
+
+opj_pi_iterator_t *pi_create(opj_volume_t *volume, opj_cp_t *cp, int tileno) {
+	int p, q, r;
+	int compno, resno, pino;
+	opj_pi_iterator_t *pi = NULL;
+	opj_tcp_t *tcp = NULL;
+	opj_tccp_t *tccp = NULL;
+	size_t array_size;
+	
+	tcp = &cp->tcps[tileno];
+
+	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
+	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
+	if(!pi) {
+		fprintf(stdout,"[ERROR] Malloc of opj_pi_iterator failed \n");
+		return NULL;
+	}
+	
+	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
+		int maxres = 0;
+		int maxprec = 0;
+		p = tileno % cp->tw;
+		q = tileno / cp->tw;
+		r = tileno / (cp->tw * cp->th);
+
+		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, volume->x0);
+		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, volume->y0);
+		pi[pino].tz0 = int_max(cp->tz0 + r * cp->tdz, volume->z0);
+		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, volume->x1);
+		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, volume->y1);
+		pi[pino].tz1 = int_min(cp->tz0 + (r + 1) * cp->tdz, volume->z1);
+		pi[pino].numcomps = volume->numcomps;
+
+		array_size = volume->numcomps * sizeof(opj_pi_comp_t);
+		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
+		if(!pi[pino].comps) {
+			fprintf(stdout,"[ERROR] Malloc of opj_pi_comp failed \n");
+			pi_destroy(pi, cp, tileno);
+			return NULL;
+		}
+		memset(pi[pino].comps, 0, array_size);
+		
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			int tcx0, tcx1, tcy0, tcy1, tcz0, tcz1;
+			int i;
+			opj_pi_comp_t *comp = &pi[pino].comps[compno];
+			tccp = &tcp->tccps[compno];
+			
+			comp->dx = volume->comps[compno].dx;
+			comp->dy = volume->comps[compno].dy;
+			comp->dz = volume->comps[compno].dz;
+			for (i = 0; i < 3; i++) {
+				comp->numresolution[i] = tccp->numresolution[i];
+				if (comp->numresolution[i] > maxres) {
+					maxres = comp->numresolution[i];
+				}
+			}
+			array_size = comp->numresolution[0] * sizeof(opj_pi_resolution_t);
+			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
+			if(!comp->resolutions) {
+				fprintf(stdout,"[ERROR] Malloc of opj_pi_resolution failed \n");
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+
+			tcx0 = int_ceildiv(pi->tx0, comp->dx);
+			tcy0 = int_ceildiv(pi->ty0, comp->dy);
+			tcz0 = int_ceildiv(pi->tz0, comp->dz);
+			tcx1 = int_ceildiv(pi->tx1, comp->dx);
+			tcy1 = int_ceildiv(pi->ty1, comp->dy);
+			tcz1 = int_ceildiv(pi->tz1, comp->dz);
+			
+			for (resno = 0; resno < comp->numresolution[0]; resno++) {
+				int levelnox, levelnoy, levelnoz, diff;
+				int rx0, ry0, rz0, rx1, ry1, rz1;
+				int px0, py0, pz0, px1, py1, pz1;
+				opj_pi_resolution_t *res = &comp->resolutions[resno];
+				if (tccp->csty & J3D_CCP_CSTY_PRT) {
+					res->pdx = tccp->prctsiz[0][resno];
+					res->pdy = tccp->prctsiz[1][resno];
+					res->pdz = tccp->prctsiz[2][resno];
+				} else {
+					res->pdx = 15;
+					res->pdy = 15;
+					res->pdz = 15;
+				}
+				levelnox = comp->numresolution[0] - 1 - resno;
+				levelnoy = comp->numresolution[1] - 1 - resno;
+                levelnoz = comp->numresolution[2] - 1 - resno;
+				if (levelnoz < 0) levelnoz = 0; 
+				diff = comp->numresolution[0] - comp->numresolution[2];
+
+				rx0 = int_ceildivpow2(tcx0, levelnox);
+				ry0 = int_ceildivpow2(tcy0, levelnoy);
+				rz0 = int_ceildivpow2(tcz0, levelnoz);
+				rx1 = int_ceildivpow2(tcx1, levelnox);
+				ry1 = int_ceildivpow2(tcy1, levelnoy);
+				rz1 = int_ceildivpow2(tcz1, levelnoz);
+				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
+				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
+				pz0 = int_floordivpow2(rz0, res->pdz) << res->pdz;
+				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
+				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
+				pz1 = int_ceildivpow2(rz1, res->pdz) << res->pdz;
+				res->prctno[0] = (rx0==rx1)? 0 : ((px1 - px0) >> res->pdx);
+				res->prctno[1] = (ry0==ry1)? 0 : ((py1 - py0) >> res->pdy);
+				res->prctno[2] = (rz0==rz1)? 0 : ((pz1 - pz0) >> res->pdz);
+
+				if (res->prctno[0]*res->prctno[1]*res->prctno[2] > maxprec) {
+					maxprec = res->prctno[0]*res->prctno[1]*res->prctno[2];
+				}
+			}
+		}
+		
+		tccp = &tcp->tccps[0];
+		pi[pino].step_p = 1;
+		pi[pino].step_c = maxprec * pi[pino].step_p;
+		pi[pino].step_r = volume->numcomps * pi[pino].step_c;
+		pi[pino].step_l = maxres * pi[pino].step_r;
+		
+		if (pino == 0) {
+			array_size = volume->numcomps * maxres * tcp->numlayers * maxprec * sizeof(short int);
+			pi[pino].include = (short int *) opj_malloc(array_size);
+			if(!pi[pino].include) {
+				fprintf(stdout,"[ERROR] Malloc of pi[pino].include failed \n");
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+		}
+		else {
+			pi[pino].include = pi[pino - 1].include;
+		}
+		
+		if (tcp->POC == 0) {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = 0;
+			pi[pino].poc.compno0 = 0;
+			pi[pino].poc.layno1 = tcp->numlayers;
+			pi[pino].poc.resno1 = maxres;
+			pi[pino].poc.compno1 = volume->numcomps;
+			pi[pino].poc.prg = tcp->prg;
+		} else {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = tcp->pocs[pino].resno0;
+			pi[pino].poc.compno0 = tcp->pocs[pino].compno0;
+			pi[pino].poc.layno1 = tcp->pocs[pino].layno1;
+			pi[pino].poc.resno1 = tcp->pocs[pino].resno1;
+			pi[pino].poc.compno1 = tcp->pocs[pino].compno1;
+			pi[pino].poc.prg = tcp->pocs[pino].prg;
+		}
+	}
+	
+	return pi;
+}
+
+void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno) {
+	int compno, pino;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	if(pi) {
+		for (pino = 0; pino < tcp->numpocs + 1; pino++) {	
+			if(pi[pino].comps) {
+				for (compno = 0; compno < pi->numcomps; compno++) {
+					opj_pi_comp_t *comp = &pi[pino].comps[compno];
+					if(comp->resolutions) {
+						opj_free(comp->resolutions);
+					}
+				}
+				opj_free(pi[pino].comps);
+			}
+		}
+		if(pi->include) {
+			opj_free(pi->include);
+		}
+		opj_free(pi);
+	}
+}
+
+bool pi_next(opj_pi_iterator_t * pi) {
+	switch (pi->poc.prg) {
+		case LRCP:
+			return pi_next_lrcp(pi);
+		case RLCP:
+			return pi_next_rlcp(pi);
+		case RPCL:
+			return pi_next_rpcl(pi);
+		case PCRL:
+			return pi_next_pcrl(pi);
+		case CPRL:
+			return pi_next_cprl(pi);
+	}
+	
+	return false;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/pi.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/pi.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,145 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PI_H
+#define __PI_H
+/**
+@file pi.h
+@brief Implementation of a packet iterator (PI)
+
+The functions in PI.C have for goal to realize a packet iterator that permits to get the next
+packet following the progression order and change of it. The functions in PI.C are used
+by some function in T2.C.
+*/
+
+/** @defgroup PI PI - Implementation of a packet iterator */
+/*@{*/
+
+/**
+Packet iterator : resolution level information 
+*/
+typedef struct opj_pi_resolution {
+/** Size of precints in horizontal axis */
+	int pdx;
+/** Size of precints in vertical axis */
+	int pdy;
+/** Size of precints in axial axis */
+	int pdz;
+/** Number of precints in each axis */
+	int prctno[3];				
+} opj_pi_resolution_t;
+
+/**
+Packet iterator : component information 
+*/
+typedef struct opj_pi_comp {
+/** Size in horizontal axis */
+	int dx;
+/** Size in vertical axis */
+	int dy;
+/** Size in axial axis */
+	int dz;
+/** Number of resolution levels */
+	int numresolution[3];			
+/** Packet iterator : resolution level information */
+	opj_pi_resolution_t *resolutions;
+} opj_pi_comp_t;
+
+/** 
+Packet iterator 
+*/
+typedef struct opj_pi_iterator {
+/** precise if the packet has been already used (usefull for progression order change) */
+	short int *include;		
+/** layer step used to localize the packet in the include vector */
+	int step_l;		
+/** resolution step used to localize the packet in the include vector */
+	int step_r;	
+/** component step used to localize the packet in the include vector */
+	int step_c;				
+/** precinct step used to localize the packet in the include vector */
+	int step_p;				
+/** component that identify the packet */
+	int compno;				
+/** resolution that identify the packet */
+	int resno;				
+/** precinct that identify the packet */
+	int precno;				
+/** layer that identify the packet */
+	int layno;				
+/** 0 if the first packet */
+	int first;				
+/** progression order change information */
+	opj_poc_t poc;			
+/**	Packet iterator : component information */
+opj_pi_comp_t *comps;
+	
+	int numcomps;
+	int tx0, ty0, tz0;
+	int tx1, ty1, tz1;
+	int x, y, z;
+	int dx, dy, dz;
+} opj_pi_iterator_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a packet iterator
+@param volume Raw volume for which the packets will be listed
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which to list the packets
+@return Returns a packet iterator that points to the first packet of the tile
+@see pi_destroy
+*/
+opj_pi_iterator_t *pi_create(opj_volume_t * volume, opj_cp_t * cp, int tileno);
+
+/**
+Destroy a packet iterator
+@param pi Previously created packet iterator
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which the packets were listed
+@see pi_create
+*/
+void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno);
+
+/**
+Modify the packet iterator to point to the next packet
+@param pi Packet iterator to modify
+@return Returns false if pi pointed to the last packet or else returns true 
+*/
+bool pi_next(opj_pi_iterator_t * pi);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __PI_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/raw.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/raw.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/raw.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/raw.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+
+/* 
+==========================================================
+   RAW encoding interface
+==========================================================
+*/
+
+opj_raw_t* raw_create() {
+	opj_raw_t *raw = (opj_raw_t*)opj_malloc(sizeof(opj_raw_t));
+	return raw;
+}
+
+void raw_destroy(opj_raw_t *raw) {
+	if(raw) {
+		opj_free(raw);
+	}
+}
+
+int raw_numbytes(opj_raw_t *raw) {
+	return raw->bp - raw->start;
+}
+
+void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len) {
+	raw->start = bp;
+	raw->lenmax = len;
+	raw->len = 0;
+	raw->c = 0;
+	raw->ct = 0;
+}
+
+int raw_decode(opj_raw_t *raw) {
+	int d;
+	if (raw->ct == 0) {
+		raw->ct = 8;
+		if (raw->len == raw->lenmax) {
+			raw->c = 0xff;
+		} else {
+			if (raw->c == 0xff) {
+				raw->ct = 7;
+			}
+			raw->c = *(raw->start + raw->len);
+			raw->len++;
+		}
+	}
+	raw->ct--;
+	d = (raw->c >> raw->ct) & 0x01;
+	
+	return d;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/raw.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/raw.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/raw.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/raw.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,99 @@
+/*
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RAW_H
+#define __RAW_H
+/**
+@file raw.h
+@brief Implementation of operations for raw encoding (RAW)
+
+The functions in RAW.C have for goal to realize the operation of raw encoding linked
+with the corresponding mode switch.
+*/
+
+/** @defgroup RAW RAW - Implementation of operations for raw encoding */
+/*@{*/
+
+/**
+RAW encoding operations
+*/
+typedef struct opj_raw {
+/** Temporary buffer where bits are coded or decoded */
+	unsigned char c;		
+/** Number of bits already read or free to write */
+	unsigned int ct;		
+/** Maximum length to decode */
+	unsigned int lenmax;	
+/** Length decoded */
+	unsigned int len;		
+/** Pointer to the current position in the buffer */
+	unsigned char *bp;		
+/** Pointer to the start of the buffer */
+	unsigned char *start;	
+/** Pointer to the end of the buffer */
+	unsigned char *end;		
+} opj_raw_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new RAW handle 
+@return Returns a new RAW handle if successful, returns NULL otherwise
+*/
+opj_raw_t* raw_create();
+/**
+Destroy a previously created RAW handle
+@param raw RAW handle to destroy
+*/
+void raw_destroy(opj_raw_t *raw);
+/**
+Return the number of bytes written/read since initialisation
+@param raw RAW handle to destroy
+@return Returns the number of bytes already encoded
+*/
+int raw_numbytes(opj_raw_t *raw);
+/**
+Initialize the decoder
+@param raw RAW handle
+@param bp Pointer to the start of the buffer from which the bytes will be read
+@param len Length of the input buffer
+*/
+void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len);
+/**
+Decode a symbol using raw-decoder. Cfr p.506 TAUBMAN
+@param raw RAW handle
+@return Returns the decoded symbol (0 or 1)
+*/
+int raw_decode(opj_raw_t *raw);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __RAW_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1_3d.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/t1_3d.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1_3d.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t1_3d.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,1230 @@
+/*
+ * Copyrigth (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup T1_3D T1_3D - Implementation of the tier-1 coding */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+static int t1_3d_getctxno_zc(unsigned int f, int orient);
+static int t1_3d_getctxno_sc(unsigned int f);
+static int t1_3d_getctxno_mag(unsigned int f, int fsvr);
+static int t1_3d_getspb(unsigned int f);
+static int t1_3d_getnmsedec_sig(opj_t1_3d_t *t1, int x, int bitpos);
+static int t1_3d_getnmsedec_ref(opj_t1_3d_t *t1, int x, int bitpos);
+static void t1_3d_updateflags(unsigned int *fp, int s);
+/**
+Encode significant pass
+*/
+static void t1_3d_enc_sigpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int bpno, int one, int *nmsedec, char type, int vsc);
+/**
+Decode significant pass
+*/
+static void t1_3d_dec_sigpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int oneplushalf, char type, int vsc);
+/**
+Encode significant pass
+*/
+static void t1_3d_enc_sigpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, char type, int cblksty);
+/**
+Decode significant pass
+*/
+static void t1_3d_dec_sigpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, char type, int cblksty);
+/**
+Encode refinement pass
+*/
+static void t1_3d_enc_refpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int bpno, int one, int *nmsedec, char type, int vsc);
+/**
+Decode refinement pass
+*/
+static void t1_3d_dec_refpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int poshalf, int neghalf, char type, int vsc);
+/**
+Encode refinement pass
+*/
+static void t1_3d_enc_refpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int *nmsedec, char type, int cblksty);
+/**
+Decode refinement pass
+*/
+static void t1_3d_dec_refpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, char type, int cblksty);
+/**
+Encode clean-up pass
+*/
+static void t1_3d_enc_clnpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int bpno, int one, int *nmsedec, int partial, int vsc);
+/**
+Decode clean-up pass
+*/
+static void t1_3d_dec_clnpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int oneplushalf, int partial, int vsc);
+/**
+Encode clean-up pass
+*/
+static void t1_3d_enc_clnpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, int cblksty);
+/**
+Decode clean-up pass
+*/
+static void t1_3d_dec_clnpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int cblksty);
+/**
+Encode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param compno Component number
+@param level[3]
+@param dwtid[3]
+@param stepsize
+@param cblksty Code-block style
+@param numcomps
+@param tile
+*/
+static void t1_3d_encode_cblk(opj_t1_3d_t *t1, opj_tcd_cblk_t * cblk, int orient, int compno,  int level[3], int dwtid[3], double stepsize, int cblksty, int numcomps, opj_tcd_tile_t * tile);
+/**
+Decode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param roishift Region of interest shifting value
+@param cblksty Code-block style
+*/
+static void t1_3d_decode_cblk(opj_t1_3d_t *t1, opj_tcd_cblk_t * cblk, int orient, int roishift, int cblksty);
+static int t1_3d_init_ctxno_zc(unsigned int f, int orient);
+static int t1_3d_init_ctxno_sc(unsigned int f);
+static int t1_3d_init_ctxno_mag(unsigned int f, int f2);
+static int t1_3d_init_spb(unsigned int f);
+/**
+Initialize the look-up tables of the Tier-1 coder/decoder
+@param t1 T1 handle
+*/
+static void t1_3d_init_luts(opj_t1_3d_t *t1);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+static int t1_3d_getctxno_zc(unsigned int f, int orient) {
+	return t1_3d_init_ctxno_zc((f & T1_3D_SIG_OTH), orient);
+}
+
+static int t1_3d_getctxno_sc(unsigned int f) {
+	return t1_3d_init_ctxno_sc((f & T1_3D_SIG_PRIM) | ((f >> 16) & T1_3D_SGN));
+	//return t1->lut_ctxno_sc[((f & T1_3D_SIG_PRIM) | ((f >> 16) & T1_3D_SGN)) >> 4];
+}
+
+static int t1_3d_getctxno_mag(unsigned int f, int fsvr) {
+	return t1_3d_init_ctxno_mag((f & T1_3D_SIG_OTH), fsvr);
+}
+
+static int t1_3d_getspb(unsigned int f) {
+	return t1_3d_init_spb((f & T1_3D_SIG_PRIM) | ((f >> 16) & T1_3D_SGN));
+	//return t1->lut_spb[((f & T1_3D_SIG_PRIM) | ((f >> 16) & T1_3D_SGN)) >> 4];
+}
+
+static int t1_3d_getnmsedec_sig(opj_t1_3d_t *t1, int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return t1->lut_nmsedec_sig[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+	
+	return t1->lut_nmsedec_sig0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static int t1_3d_getnmsedec_ref(opj_t1_3d_t *t1, int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return t1->lut_nmsedec_ref[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+
+    return t1->lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static void t1_3d_updateflags(unsigned int *fp, int s) {
+	unsigned int *np = fp - (T1_MAXCBLKW + 2);
+	unsigned int *sp = fp + (T1_MAXCBLKW + 2);
+
+	unsigned int *bwp = fp + ((T1_MAXCBLKW + 2)*(T1_MAXCBLKH +2));
+	unsigned int *bnp = bwp - (T1_MAXCBLKW + 2);
+	unsigned int *bsp = bwp + (T1_MAXCBLKW + 2);
+	
+	unsigned int *fwp = fp - ((T1_MAXCBLKW + 2)*(T1_MAXCBLKH +2));
+	unsigned int *fnp = fwp - (T1_MAXCBLKW + 2);
+	unsigned int *fsp = fwp + (T1_MAXCBLKW + 2);
+
+	np[-1] |= T1_3D_SIG_SE;
+	np[1] |= T1_3D_SIG_SW;
+	sp[-1] |= T1_3D_SIG_NE;
+	sp[1] |= T1_3D_SIG_NW;
+	*np |= T1_3D_SIG_S;
+	*sp |= T1_3D_SIG_N;
+	fp[-1] |= T1_3D_SIG_E;
+	fp[1] |= T1_3D_SIG_W;
+
+	*fwp |= T1_3D_SIG_FC;
+	*bwp |= T1_3D_SIG_BC;
+
+	fnp[-1] |= T1_3D_SIG_FSE;
+	fnp[1] |= T1_3D_SIG_FSW;
+	fsp[-1] |= T1_3D_SIG_FNE;
+	fsp[1] |= T1_3D_SIG_FNW;
+	*fnp |= T1_3D_SIG_FS;
+	*fsp |= T1_3D_SIG_FN;
+	fwp[-1] |= T1_3D_SIG_FE;
+	fwp[1] |= T1_3D_SIG_FW;
+
+	bnp[-1] |= T1_3D_SIG_BSE;
+	bnp[1] |= T1_3D_SIG_BSW;
+	bsp[-1] |= T1_3D_SIG_BNE;
+	bsp[1] |= T1_3D_SIG_BNW;
+	*bnp |= T1_3D_SIG_BS;
+	*bsp |= T1_3D_SIG_BN;
+	bwp[-1] |= T1_3D_SIG_BE;
+	bwp[1] |= T1_3D_SIG_BW;
+
+	if (s) {
+		*np |= (T1_3D_SGN_S << 16);
+		*sp |= (T1_3D_SGN_N << 16);
+		fp[-1] |= (T1_3D_SGN_E << 16);
+		fp[1] |= (T1_3D_SGN_W << 16);
+		*fwp |= (T1_3D_SGN_F << 16);
+		*bwp |= (T1_3D_SGN_B << 16);
+	}
+}
+
+static void t1_3d_enc_sigpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int bpno, int one, int *nmsedec, char type, int vsc) {
+	int v, flagsvr;
+	unsigned int flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if ((flag & T1_3D_SIG_OTH) && !(flagsvr & (T1_3D_SIG | T1_3D_VISIT))) {
+		v = int_abs(*dp) & one ? 1 : 0;
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_setcurctx(mqc, t1_3d_getctxno_zc(flag, orient));	/* ESSAI */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_setcurctx(mqc, t1_3d_getctxno_zc(flag, orient));
+			mqc_encode(mqc, v);
+		}
+		if (v) {
+			v = *dp < 0 ? 1 : 0;
+			*nmsedec +=	t1_3d_getnmsedec_sig(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+				mqc_setcurctx(mqc, t1_3d_getctxno_sc(flag));	/* ESSAI */
+				mqc_bypass_enc(mqc, v);
+			} else {
+				mqc_setcurctx(mqc, t1_3d_getctxno_sc(flag));
+				mqc_encode(mqc, v ^ t1_3d_getspb(flag));
+			}
+			t1_3d_updateflags(fp, v);
+			*fsvr |= T1_3D_SIG;
+		}
+		*fsvr |= T1_3D_VISIT;
+	}
+}
+
+static void t1_3d_dec_sigpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int oneplushalf, char type, int vsc) {
+	int v, flagsvr;
+	unsigned int flag;
+	
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if ((flag & T1_3D_SIG_OTH) && !(flagsvr & (T1_3D_SIG | T1_3D_VISIT))) {
+		if (type == T1_TYPE_RAW) {
+			if (raw_decode(raw)) {
+				v = raw_decode(raw);	/* ESSAI */
+				*dp = v ? -oneplushalf : oneplushalf;
+				t1_3d_updateflags(fp, v);
+				*fsvr |= T1_3D_SIG;
+			}
+		} else {
+			mqc_setcurctx(mqc, t1_3d_getctxno_zc(flag, orient));
+			if (mqc_decode(mqc)) {
+				mqc_setcurctx(mqc, t1_3d_getctxno_sc(flag));
+				v = mqc_decode(mqc) ^ t1_3d_getspb(flag);
+				*dp = v ? -oneplushalf : oneplushalf;
+				t1_3d_updateflags(fp, v);
+				*fsvr |= T1_3D_SIG;
+			}
+		}
+		*fsvr |= T1_3D_VISIT;
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_3d_enc_sigpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, char type, int cblksty) {
+	int i, j, k, m, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				for (j = k; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_enc_sigpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, bpno, one, nmsedec, type, vsc);
+				}
+			}
+		}
+	}
+}
+
+static void t1_3d_dec_sigpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, char type, int cblksty) {
+	int i, j, k, m, one, half, oneplushalf, vsc;
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				for (j = k; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_dec_sigpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, oneplushalf, type, vsc);
+				}
+			}
+		}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_3d_enc_refpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int bpno, int one, int *nmsedec, char type, int vsc) {
+	int v, flagsvr;
+	unsigned int flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if ((flagsvr & (T1_3D_SIG | T1_3D_VISIT)) == T1_3D_SIG) {
+		*nmsedec += t1_3d_getnmsedec_ref(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+		v = int_abs(*dp) & one ? 1 : 0;
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_setcurctx(mqc, t1_3d_getctxno_mag(flag, flagsvr));	/* ESSAI */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_setcurctx(mqc, t1_3d_getctxno_mag(flag, flagsvr));
+			mqc_encode(mqc, v);
+		}
+		*fsvr |= T1_3D_REFINE;
+	}
+}
+
+static void t1_3d_dec_refpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int poshalf, int neghalf, char type, int vsc) {
+	int v, t, flagsvr;
+	unsigned int flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if ((flagsvr & (T1_3D_SIG | T1_3D_VISIT)) == T1_3D_SIG) {
+		if (type == T1_TYPE_RAW) {
+			mqc_setcurctx(mqc, t1_3d_getctxno_mag(flag, flagsvr));	/* ESSAI */
+			v = raw_decode(raw);
+		} else {
+			mqc_setcurctx(mqc, t1_3d_getctxno_mag(flag, flagsvr));
+			v = mqc_decode(mqc);
+		}
+		t = v ? poshalf : neghalf;
+		*dp += *dp < 0 ? -t : t;
+		*fsvr |= T1_3D_REFINE;
+	}
+}				/* VSC and  BYPASS by Antonin  */
+
+static void t1_3d_enc_refpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int *nmsedec, char type, int cblksty) {
+	int i, j, k, m, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++){
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				for (j = k; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_enc_refpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], bpno, one, nmsedec, type, vsc);
+				}
+			}
+		}
+	}	
+}
+
+static void t1_3d_dec_refpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, char type, int cblksty) {
+	int i, j, k, m, one, poshalf, neghalf;
+	int vsc;
+	one = 1 << bpno;
+	poshalf = one >> 1;
+	neghalf = bpno > 0 ? -poshalf : -1;
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				for (j = k; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_dec_refpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], poshalf, neghalf, type, vsc);
+				}
+			}
+		}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_3d_enc_clnpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int bpno, int one, int *nmsedec, int partial, int vsc) {
+	int v, flagsvr;
+	unsigned int flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(*fsvr & (T1_3D_SIG | T1_3D_VISIT))) {
+		mqc_setcurctx(mqc, t1_3d_getctxno_zc(flag, orient));
+		v = int_abs(*dp) & one ? 1 : 0;
+		mqc_encode(mqc, v);
+		if (v) {
+LABEL_PARTIAL:
+			*nmsedec += t1_3d_getnmsedec_sig(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_3d_getctxno_sc(flag));
+			v = *dp < 0 ? 1 : 0;
+			mqc_encode(mqc, v ^ t1_3d_getspb(flag));
+			t1_3d_updateflags(fp, v);
+			*fsvr |= T1_3D_SIG;
+		}
+	}
+	*fsvr &= ~T1_3D_VISIT;
+}
+
+static void t1_3d_dec_clnpass_step(opj_t1_3d_t *t1, unsigned int *fp, int *fsvr, int *dp, int orient, int oneplushalf, int partial, int vsc) {
+	int v, flagsvr;
+	unsigned int flag;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) : (*fp);
+	flagsvr = (*fsvr);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(flagsvr & (T1_3D_SIG | T1_3D_VISIT))) {
+		mqc_setcurctx(mqc, t1_3d_getctxno_zc(flag, orient));
+		if (mqc_decode(mqc)) {
+LABEL_PARTIAL:
+			mqc_setcurctx(mqc, t1_3d_getctxno_sc(flag));
+			v = mqc_decode(mqc) ^ t1_3d_getspb(flag);
+			*dp = v ? -oneplushalf : oneplushalf;
+			t1_3d_updateflags(fp, v);
+			*fsvr |= T1_3D_SIG;
+		}
+	}
+	*fsvr &= ~T1_3D_VISIT;
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_3d_enc_clnpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, int cblksty) {
+	int i, j, k, m, one, agg, runlen, vsc;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				if (k + 3 < h) {
+					if (cblksty & J3D_CCP_CBLKSTY_VSC) {
+						agg = !( ((t1->flagSVR[1 + m][1 + k][1 + i] | (T1_3D_SIG | T1_3D_VISIT)) & (t1->flags[1 + m][1 + k][1 + i] & T1_3D_SIG_OTH))
+							||   ((t1->flagSVR[1 + m][1 + k + 1][1 + i] | (T1_3D_SIG | T1_3D_VISIT)) & (t1->flags[1 + m][1 + k + 1][1 + i] & T1_3D_SIG_OTH))
+							||   ((t1->flagSVR[1 + m][1 + k + 2][1 + i] | (T1_3D_SIG | T1_3D_VISIT)) & (t1->flags[1 + m][1 + k + 2][1 + i] & T1_3D_SIG_OTH))
+							||   ((t1->flagSVR[1 + m][1 + k + 3][1 + i] | (T1_3D_SIG | T1_3D_VISIT)) & ((t1->flags[1 + m][1 + k + 3][1 + i] & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) & (T1_3D_SIG_OTH)))
+							);
+					} else {
+						agg = !(
+							((t1->flagSVR[1 + m][1 + k][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 1][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 1][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 2][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 2][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 3][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 3][1 + i] & T1_3D_SIG_OTH))
+							);
+					}
+				} else {
+					agg = 0;
+				}
+				if (agg) {
+					for (runlen = 0; runlen < 4; runlen++) {
+						if (int_abs(t1->data[m][k + runlen][i]) & one)
+							break;
+					}
+					mqc_setcurctx(mqc, T1_CTXNO_AGG);
+					mqc_encode(mqc, runlen != 4);
+					if (runlen == 4) {
+						continue;
+					}
+					mqc_setcurctx(mqc, T1_CTXNO_UNI);
+					mqc_encode(mqc, runlen >> 1);
+					mqc_encode(mqc, runlen & 1);
+				} else {
+					runlen = 0;
+				}
+				for (j = k + runlen; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_enc_clnpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, bpno, one, nmsedec, agg && (j == k + runlen), vsc);
+				}
+			}
+		}
+	}
+}
+
+static void t1_3d_dec_clnpass(opj_t1_3d_t *t1, int w, int h, int l, int bpno, int orient, int cblksty) {
+	int i, j, k, m, one, half, oneplushalf, agg, runlen, vsc;
+	int segsym = cblksty & J3D_CCP_CBLKSTY_SEGSYM;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				if (k + 3 < h) {
+					if (cblksty & J3D_CCP_CBLKSTY_VSC) {
+						agg = !(
+							((t1->flagSVR[1 + m][1 + k][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 1][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 1][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 2][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 2][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 3][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | ((t1->flags[1 + m][1 + k + 3][1 + i] & (~(T1_3D_SIG_S | T1_3D_SIG_SE | T1_3D_SIG_SW | (T1_3D_SGN_S << 16)))) & (T1_3D_SIG_OTH)))
+							);
+					} else {
+						agg = !(
+							((t1->flagSVR[1 + m][1 + k][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 1][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 1][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 2][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 2][1 + i] & T1_3D_SIG_OTH))
+							|| ((t1->flagSVR[1 + m][1 + k + 3][1 + i] & (T1_3D_SIG | T1_3D_VISIT)) | (t1->flags[1 + m][1 + k + 3][1 + i] & T1_3D_SIG_OTH))
+							);
+					}
+				} else {
+					agg = 0;
+				}
+				if (agg) {
+					mqc_setcurctx(mqc, T1_CTXNO_AGG);
+					if (!mqc_decode(mqc)) {
+						continue;
+					}
+					mqc_setcurctx(mqc, T1_CTXNO_UNI);
+					runlen = mqc_decode(mqc);
+					runlen = (runlen << 1) | mqc_decode(mqc);
+				} else {
+					runlen = 0;
+				}
+				for (j = k + runlen; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_3d_dec_clnpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->flagSVR[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, oneplushalf, agg && (j == k + runlen), vsc);
+				}
+			}
+		}
+	}
+	if (segsym) {
+		int v = 0;
+		mqc_setcurctx(mqc, T1_CTXNO_UNI);
+		v = mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		/*
+		if (v!=0xa) {
+			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
+		} 
+		*/
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+
+static void t1_3d_encode_cblk(opj_t1_3d_t *t1, opj_tcd_cblk_t * cblk, int orient, int compno, int level[3], int dwtid[3], double stepsize, int cblksty, int numcomps, opj_tcd_tile_t * tile) {
+	int i, j, k;
+	int w, h, l;
+	int passno;
+	int bpno, passtype;
+	int max;
+	int nmsedec = 0;
+	double cumwmsedec = 0;
+	char type = T1_TYPE_MQ;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	w = cblk->x1 - cblk->x0;
+	h = cblk->y1 - cblk->y0;
+	l = cblk->z1 - cblk->z0;
+
+	max = 0;
+	for (k = 0; k < l; k++) {
+		for (j = 0; j < h; j++) {
+			for (i = 0; i < w; i++) {
+				max = int_max(max, int_abs(t1->data[k][j][i]));
+			}
+		}
+	}
+	for (k = 0; k <= l; k++) {
+		for (j = 0; j <= h; j++) {
+			for (i = 0; i <= w; i++) {
+				t1->flags[k][j][i] = 0;
+				t1->flagSVR[k][j][i] = 0;
+			}
+		}
+	}
+	
+	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
+	
+	bpno = cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_reset_enc(mqc);
+	mqc_init_enc(mqc, cblk->data);
+	
+	for (passno = 0; bpno >= 0; passno++) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		int correction = 3;
+		double tmpwmsedec;
+		type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		
+		switch (passtype) {
+			case 0:
+				t1_3d_enc_sigpass(t1, w, h, l, bpno, orient, &nmsedec, type, cblksty);
+				break;
+			case 1:
+				t1_3d_enc_refpass(t1, w, h, l, bpno, &nmsedec, type, cblksty);
+				break;
+			case 2:
+				t1_3d_enc_clnpass(t1, w, h, l, bpno, orient, &nmsedec, cblksty);
+				/* code switch SEGMARK (i.e. SEGSYM) */
+				if (cblksty & J3D_CCP_CBLKSTY_SEGSYM)
+					mqc_segmark_enc(mqc);
+				break;
+		}
+		
+		/* fixed_quality */
+		tmpwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, stepsize, numcomps, dwtid);
+		cumwmsedec += tmpwmsedec;
+		tile->distotile += tmpwmsedec;
+		
+		/* Code switch "RESTART" (i.e. TERMALL) */
+		if ((cblksty & J3D_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
+			if (type == T1_TYPE_RAW) {
+				mqc_flush(mqc);
+				correction = 1;
+				/* correction = mqc_bypass_flush_enc(); */
+			} else {			/* correction = mqc_restart_enc(); */
+				mqc_flush(mqc);
+				correction = 1;
+			}
+			pass->term = 1;
+		} else {
+			if (((bpno < (cblk->numbps - 4) && (passtype > 0)) 
+				|| ((bpno == (cblk->numbps - 4)) && (passtype == 2))) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) {
+				if (type == T1_TYPE_RAW) {
+					mqc_flush(mqc);
+					correction = 1;
+				} else {	
+					mqc_flush(mqc);
+					correction = 1;
+				}
+				pass->term = 1;
+			} else {
+				pass->term = 0;
+			}
+		}
+		
+		if (++passtype == 3) {
+			passtype = 0;
+			bpno--;
+		}
+		
+		if (pass->term && bpno > 0) {
+			type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+			if (type == T1_TYPE_RAW)
+				mqc_bypass_init_enc(mqc);
+			else
+				mqc_restart_init_enc(mqc);
+		}
+		
+		pass->distortiondec = cumwmsedec;
+		pass->rate = mqc_numbytes(mqc) + correction;	/* FIXME */
+		pass->len = pass->rate - (passno == 0 ? 0 : cblk->passes[passno - 1].rate);
+
+		/* Code-switch "RESET" */
+		if (cblksty & J3D_CCP_CBLKSTY_RESET)
+			mqc_reset_enc(mqc);
+	}
+	
+	/* Code switch "ERTERM" (i.e. PTERM) */
+	if (cblksty & J3D_CCP_CBLKSTY_PTERM)
+		mqc_erterm_enc(mqc);
+	else /* Default coding */ if (!(cblksty & J3D_CCP_CBLKSTY_LAZY))
+		mqc_flush(mqc);
+	
+	cblk->totalpasses = passno;
+}
+
+static void t1_3d_decode_cblk(opj_t1_3d_t *t1, opj_tcd_cblk_t * cblk, int orient, int roishift, int cblksty) {
+	int i, j, k;
+	int w, h, l;
+	int bpno, passtype;
+	int segno, passno;
+	char type = T1_TYPE_MQ; /* BYPASS mode */
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	w = cblk->x1 - cblk->x0;
+	h = cblk->y1 - cblk->y0;
+	l = cblk->z1 - cblk->z0;
+
+    for (k = 0; k < l; k++) {
+		for (j = 0; j < h; j++) {
+			for (i = 0; i < w; i++) {
+				t1->data[k][j][i] = 0;
+			}
+		}
+	}
+	
+	for (k = 0; k <= l; k++) {
+		for (j = 0; j <= h; j++) {
+			for (i = 0; i <= w; i++) {
+				t1->flags[k][j][i] = 0;
+				t1->flagSVR[k][j][i] = 0;
+			}
+		}
+	}
+
+	
+	bpno = roishift + cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_reset_enc(mqc);
+	
+	for (segno = 0; segno < cblk->numsegs; segno++) {
+		opj_tcd_seg_t *seg = &cblk->segs[segno];
+		
+		/* BYPASS mode */
+		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		if (type == T1_TYPE_RAW) {
+			raw_init_dec(raw, seg->data, seg->len);
+		} else {
+			mqc_init_dec(mqc, seg->data, seg->len);
+		}
+		
+		for (passno = 0; passno < seg->numpasses; passno++) {
+			switch (passtype) {
+				case 0:
+					t1_3d_dec_sigpass(t1, w, h, l, bpno+1, orient, type, cblksty);
+					break;
+				case 1:
+					t1_3d_dec_refpass(t1, w, h, l, bpno+1, type, cblksty);
+					break;
+				case 2:
+					t1_3d_dec_clnpass(t1, w, h, l, bpno+1, orient, cblksty);
+					break;
+			}
+			
+			if ((cblksty & J3D_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
+				mqc_reset_enc(mqc);
+			}
+			if (++passtype == 3) {
+				passtype = 0;
+				bpno--;
+			}
+
+		}
+	}
+}
+
+static int t1_3d_init_ctxno_zc(unsigned int f, int orient) {
+	unsigned int h, v, c;
+	unsigned int d2xy, d2xz, d2yz, d3;
+	int n;
+	unsigned int hvc, hc, d2, d2xy2yz, d2xy2xz;
+	n = 0;
+	h = ((f & T1_3D_SIG_W) != 0) + ((f & T1_3D_SIG_E) != 0);
+	v = ((f & T1_3D_SIG_N) != 0) + ((f & T1_3D_SIG_S) != 0);
+	c = ((f & T1_3D_SIG_FC) != 0) + ((f & T1_3D_SIG_BC) != 0);
+	d2xy = ((f & T1_3D_SIG_NW) != 0) + ((f & T1_3D_SIG_NE) != 0) + ((f & T1_3D_SIG_SE) != 0) + ((f & T1_3D_SIG_SW) != 0);
+	d2xz = ((f & T1_3D_SIG_FW) != 0) + ((f & T1_3D_SIG_BW) != 0) + ((f & T1_3D_SIG_FE) != 0) + ((f & T1_3D_SIG_BE) != 0);
+	d2yz = ((f & T1_3D_SIG_FN) != 0) + ((f & T1_3D_SIG_FS) != 0) + ((f & T1_3D_SIG_BN) != 0) + ((f & T1_3D_SIG_BS) != 0);
+    d3 = ((f & T1_3D_SIG_FNW) != 0) + ((f & T1_3D_SIG_FNE) != 0) + ((f & T1_3D_SIG_FSE) != 0) + ((f & T1_3D_SIG_FSW) != 0) 
+		+ ((f & T1_3D_SIG_BNW) != 0) + ((f & T1_3D_SIG_BNE) != 0) + ((f & T1_3D_SIG_BSE) != 0) + ((f & T1_3D_SIG_BSW) != 0);
+	
+	switch (orient) {
+		case 0: //LLL
+		case 7: //HHH
+			hvc = h + v + c;
+			d2 = d2xy + d2xz + d2yz;
+			if (!hvc) {
+				if (!d2) {
+                    n = (!d3) ? 0 : 1;
+				} else if (d2 == 1) {
+					n = (!d3) ? 2 : 3;
+				} else {
+					n = (!d3) ? 4 : 5;
+				}
+			} else if (hvc == 1) {
+				if (!d2) {
+                    n = (!d3) ? 6 : 7;
+				} else if (d2 == 1) {
+					n = (!d3) ? 8 : 9;
+				} else {
+					n = 10;
+				}
+			} else if (hvc == 2) {
+				if (!d2) {
+                    n = (!d3) ? 11 : 12;
+				} else {
+					n = 13;
+				}
+			} else if (hvc == 3) {
+				n = 14;
+			} else {
+				n = 15;
+			}
+			break;
+		//LHL, HLL, LLH
+		case 1:
+		case 2:
+		case 4:
+			hc = h + c;
+			d2xy2yz = d2xy + d2yz;
+            if (!hc) {
+				if (!v) {
+					if (!d2xy) {
+						n = (!d2xy2yz) ? ((!d3) ? 0 : 1) : ((!d3) ? 2 : 3);	
+					} else if (d2xy == 1) {
+						n = (!d2xy2yz) ? ((!d3) ? 4 : 5) : 6;	
+					} else { //>=2
+                        n = 7;
+					}
+				} else {
+					n = (v == 1) ? 8 : 9; // =1 or =2
+				} 
+			} else if (hc == 1) {
+				n = (!v) ? ( (!d2xy) ? ( (!d2xy2yz) ? ( (!d3) ? 10 : 11) : (12) ) : (13) ) : (14);
+			} else { //if (hc >= 2)
+				n = 15;
+			}
+			break;
+		//HLH, HHL, LHH
+		case 3:
+		case 5:
+		case 6:
+			hc = h + c;
+			d2xy2xz = d2xy + d2xz;
+			if (!v) {
+				if (!d2xz) {
+					if (!hc && !d2xy2xz) {
+						n = (!d3) ? 0 : 1;
+					} else if (hc == 1) {
+						n = (!d2xy2xz) ?  2 : 3;
+					} else { //if >= 2
+						n = 4;
+					}
+				} else if ( d2xz>=1 && !hc ) {
+					n = 5;
+				} else if ( hc>=1 ) {
+					n = (d2xz==1) ? 6 : 7;
+				} 
+			} else if (v == 1) {
+				if (!d2xz) {
+					n = (!hc) ? 8 : 9;
+				} else if (d2xz == 1) {
+					n = (!hc) ? 10 : 11;
+				} else if (d2xz == 2) {
+					n = (!hc) ? 12 : 13;
+				} else { // if (d2xz >= 3) {
+					n = 14;
+				}
+			} else if (v == 2) {
+				n = 15;
+			} 
+			break;
+	}
+	
+	return (T1_3D_CTXNO_ZC + n);
+}
+
+static int t1_3d_init_ctxno_sc(unsigned int f) {
+	int hc, vc, cc;
+	int n = 0;
+
+	hc = int_min( ( (f & (T1_3D_SIG_E | T1_3D_SGN_E)) == T1_3D_SIG_E ) 
+					+ ( (f & (T1_3D_SIG_W | T1_3D_SGN_W)) == T1_3D_SIG_W ) , 1) 
+		- int_min( ( (f & (T1_3D_SIG_E | T1_3D_SGN_E)) == (T1_3D_SIG_E | T1_3D_SGN_E) ) 
+					+ ( (f & (T1_3D_SIG_W | T1_3D_SGN_W) ) == (T1_3D_SIG_W | T1_3D_SGN_W)), 1);
+	
+	vc = int_min(((f & (T1_3D_SIG_N | T1_3D_SGN_N)) == T1_3D_SIG_N) 
+					+ ((f & (T1_3D_SIG_S | T1_3D_SGN_S)) == T1_3D_SIG_S), 1) 
+		- int_min(((f & (T1_3D_SIG_N | T1_3D_SGN_N)) == (T1_3D_SIG_N | T1_3D_SGN_N)) 
+					+ ((f & (T1_3D_SIG_S | T1_3D_SGN_S)) == (T1_3D_SIG_S | T1_3D_SGN_S)), 1);
+	
+	cc = int_min(((f & (T1_3D_SIG_FC | T1_3D_SGN_F)) == T1_3D_SIG_FC) 
+					+ ((f & (T1_3D_SIG_BC | T1_3D_SGN_B)) == T1_3D_SIG_BC), 1) 
+		- int_min(((f & (T1_3D_SIG_FC | T1_3D_SGN_F)) == (T1_3D_SIG_FC | T1_3D_SGN_F)) 
+					+ ((f & (T1_3D_SIG_BC | T1_3D_SGN_B)) == (T1_3D_SIG_BC | T1_3D_SGN_B)), 1);
+	if (hc < 0) {
+		hc = -hc;
+		vc = -vc;
+		cc = -cc;
+	}
+
+	if (!hc) {
+		if (!vc) 
+			n = (!cc) ? 0 : 1;
+		else if (vc == -1)
+			n = (!cc) ? 1 : ( (cc>0) ? 2 : 4);
+		else if (vc == 1)
+			n = (!cc) ? 1 : ( (cc<0) ? 2 : 4);
+	} else if (hc == 1) {
+		if (!vc)
+			n = (!cc) ? 1 : ( (cc<0) ? 2 : 4);
+		else if (vc == 1)
+			n = (!cc) ? 4 : ( (cc>0) ? 5 : 3);
+		else if (vc == -1)
+			n = (!cc) ? 2 : 3;
+	} else if (hc == -1) {
+		if (!vc)
+			n = (!cc) ? 1 : ( (cc>0) ? 2 : 4);
+		else if (vc == 1)
+			n = (!cc) ? 2 : 3;
+		else if (vc == -1)
+			n = (!cc) ? 4 : ( (cc<0) ? 5 : 3);
+	}
+	
+	return (T1_3D_CTXNO_SC + n);
+}
+
+static int t1_3d_init_ctxno_mag(unsigned int f, int f2) {
+	int n;
+	if (!(f2 & T1_3D_REFINE))	//First refinement for this coefficient (no previous refinement)
+		n = (f & (T1_3D_SIG_PRIM)) ? 1 : 0;
+	else
+		n = 2;
+	
+	return (T1_3D_CTXNO_MAG + n);
+}
+
+static int t1_3d_init_spb(unsigned int f) {
+	int hc, vc, cc;
+	int n = 0;
+	
+	hc = int_min( ( (f & (T1_3D_SIG_E | T1_3D_SGN_E)) == T1_3D_SIG_E ) 
+					+ ( (f & (T1_3D_SIG_W | T1_3D_SGN_W)) == T1_3D_SIG_W ) , 1) 
+		- int_min( ( (f & (T1_3D_SIG_E | T1_3D_SGN_E)) == (T1_3D_SIG_E | T1_3D_SGN_E) ) 
+					+ ( (f & (T1_3D_SIG_W | T1_3D_SGN_W) ) == (T1_3D_SIG_W | T1_3D_SGN_W)), 1);
+	
+	vc = int_min(((f & (T1_3D_SIG_N | T1_3D_SGN_N)) == T1_3D_SIG_N) 
+					+ ((f & (T1_3D_SIG_S | T1_3D_SGN_S)) == T1_3D_SIG_S), 1) 
+		- int_min(((f & (T1_3D_SIG_N | T1_3D_SGN_N)) == (T1_3D_SIG_N | T1_3D_SGN_N)) 
+					+ ((f & (T1_3D_SIG_S | T1_3D_SGN_S)) == (T1_3D_SIG_S | T1_3D_SGN_S)), 1);
+	
+	cc = int_min(((f & (T1_3D_SIG_FC | T1_3D_SGN_F)) == T1_3D_SIG_FC) 
+					+ ((f & (T1_3D_SIG_BC | T1_3D_SGN_B)) == T1_3D_SIG_BC), 1) 
+		- int_min(((f & (T1_3D_SIG_FC | T1_3D_SGN_F)) == (T1_3D_SIG_FC | T1_3D_SGN_F)) 
+					+ ((f & (T1_3D_SIG_BC | T1_3D_SGN_B)) == (T1_3D_SIG_BC | T1_3D_SGN_B)), 1);
+	
+	n = ((hc + vc + cc) < 0); 
+	
+	return n;
+}
+
+static void t1_3d_init_luts(opj_t1_3d_t *t1) {
+	int i;
+	double u, v, t;
+	/*for (j = 0; j < 4; j++) {
+		for (i = 0; i < 256; ++i) {
+			t1->lut_ctxno_zc[(j << 8) | i] = t1_3d_init_ctxno_zc(i, j);
+		}
+	}
+	for (i = 0; i < 4096; i++) {
+		t1->lut_ctxno_sc[i] = t1_3d_init_ctxno_sc(i << 4);
+	}
+	for (j = 0; j < 2; j++) {
+		for (i = 0; i < 2048; ++i) {
+			t1->lut_ctxno_mag[(j << 11) + i] = t1_3d_init_ctxno_mag((j ? T1_3D_REFINE : 0) | i);
+		}
+	}
+	for (i = 0; i < 4096; ++i) {
+		t1->lut_spb[i] = t1_3d_init_spb(i << 4);
+	}*/
+	/* FIXME FIXME FIXME */
+	for (i = 0; i < (1 << T1_NMSEDEC_BITS); i++) {
+		t = i / pow(2, T1_NMSEDEC_FRACBITS);
+		u = t;
+		v = t - 1.5;
+		t1->lut_nmsedec_sig[i] = 
+			int_max(0, 
+			(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		t1->lut_nmsedec_sig0[i] =
+			int_max(0,
+			(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		u = t - 1.0;
+		if (i & (1 << (T1_NMSEDEC_BITS - 1))) {
+			v = t - 1.5;
+		} else {
+			v = t - 0.5;
+		}
+		t1->lut_nmsedec_ref[i] =
+			int_max(0,
+			(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		t1->lut_nmsedec_ref0[i] =
+			int_max(0,
+			(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+	}
+}
+
+/* ----------------------------------------------------------------------- */
+
+opj_t1_3d_t* t1_3d_create(opj_common_ptr cinfo) {
+	opj_t1_3d_t *t1 = (opj_t1_3d_t*)opj_malloc(sizeof(opj_t1_3d_t));
+	if(t1) {
+		t1->cinfo = cinfo;
+		/* create MQC and RAW handles */
+		t1->mqc = mqc_create();
+		t1->raw = raw_create();
+		/* initialize the look-up tables of the Tier-1 coder/decoder */
+		t1_3d_init_luts(t1);
+	}
+	return t1;
+}
+
+void t1_3d_destroy(opj_t1_3d_t *t1) {
+	if(t1) {
+		/* destroy MQC and RAW handles */
+		mqc_destroy(t1->mqc);
+		raw_destroy(t1->raw);
+		opj_free(t1);
+	}
+}
+
+void t1_3d_encode_cblks(opj_t1_3d_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp) {
+	int compno, resno, bandno, precno, cblkno;
+	int x, y, z, i, j, k, orient;
+	int level[3];
+	tile->distotile = 0;		/* fixed_quality */
+
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+
+						if (band->bandno == 0) {
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 1) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 2) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 3) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 4) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 5) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 6) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 7) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						}
+
+						if (tcp->tccps[compno].reversible == 1) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+                                    for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+                                        t1->data[k][j][i] = 
+										tilec->data[(x + i) + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] << T1_NMSEDEC_FRACBITS;
+									}
+								}
+							}
+						} else if (tcp->tccps[compno].reversible == 0) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+                                    for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+                                        t1->data[k][j][i] = fix_mul(
+										tilec->data[(x + i) + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)],
+										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (13 - T1_NMSEDEC_FRACBITS);
+									}
+								}
+							}
+						}
+						orient = band->bandno;	/* FIXME */
+						for (i = 0; i < 3; i++) 
+							level[i] = tilec->numresolution[i] - 1 - resno;
+
+						t1_3d_encode_cblk(t1, cblk, orient, compno, level, tcp->tccps[compno].dwtid, band->stepsize, tcp->tccps[compno].cblksty, tile->numcomps, tile);
+							
+					} /* cblkno */
+				} /* precno */
+			} /* bandno */
+		} /* resno  */
+	} /* compno  */
+}
+
+void t1_3d_decode_cblks(opj_t1_3d_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp) {
+	int compno, resno, bandno, precno, cblkno;
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						int x, y, z, i, j, k, orient;
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+
+						orient = band->bandno;	/* FIXME */
+
+						//fprintf(stdout,"[INFO] t1_3d_decode_cblk(t1, cblk, orient(%d), tcp->tccps[compno].roishift (%d), tcp->tccps[compno].cblksty (%d));\n",orient,tcp->tccps[compno].roishift, tcp->tccps[compno].cblksty);
+						t1_3d_decode_cblk(t1, cblk, orient, tcp->tccps[compno].roishift, tcp->tccps[compno].cblksty);
+
+						if (band->bandno == 0) {
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 1) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 2) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 3) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 4) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 5) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 6) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 7) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						}
+					
+						if (tcp->tccps[compno].roishift) {
+							int thresh, val, mag;
+							thresh = 1 << tcp->tccps[compno].roishift;
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										val = t1->data[k][j][i];
+										mag = int_abs(val);
+										if (mag >= thresh) {
+											mag >>= tcp->tccps[compno].roishift;
+											t1->data[k][j][i] = val < 0 ? -mag : mag;
+										}
+									}
+								}
+							}
+						}
+						
+						if (tcp->tccps[compno].reversible == 1) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										int tmp = t1->data[k][j][i];
+										tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = tmp/2;
+									}
+								}
+							}
+						} else {		/* if (tcp->tccps[compno].reversible == 0) */
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										double tmp = (double)(t1->data[k][j][i] * band->stepsize * 4096.0);
+										if (t1->data[k][j][i] >> 1 == 0) {
+											tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = 0;
+										} else {
+											int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
+											tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = ((tmp<0)?-tmp2:tmp2);
+										}
+									}
+								}
+							}
+						}
+					} /* cblkno */
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
+}
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1_3d.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/t1_3d.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1_3d.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t1_3d.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,173 @@
+/*
+ * Copyrigth (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __T1_3D_H
+#define __T1_3D_H
+/**
+@file t1_3d.h
+@brief Implementation of the tier-1 coding (coding of code-block coefficients) (T1)
+
+The functions in T1_3D.C have for goal to realize the tier-1 coding operation of 3D-EBCOT.
+The functions in T1_3D.C are used by some function in TCD.C.
+*/
+
+/** @defgroup T1_3D T1_3D - Implementation of the tier-1 coding */
+/*@{*/
+
+/* ----------------------------------------------------------------------- */
+
+/* Neighbourhood of 3D EBCOT (Significance context)*/
+#define T1_3D_SIG_NE  0x00000001	/*< Context orientation : North-East direction */
+#define T1_3D_SIG_SE  0x00000002	/*< Context orientation : South-East direction */
+#define T1_3D_SIG_SW  0x00000004	/*< Context orientation : South-West direction */
+#define T1_3D_SIG_NW  0x00000008	/* Context orientation : North-West direction */
+#define T1_3D_SIG_N   0x00000010	/*< Context orientation : North direction */
+#define T1_3D_SIG_E   0x00000020	/*< Context orientation : East direction */
+#define T1_3D_SIG_S   0x00000040	/*< Context orientation : South direction */
+#define T1_3D_SIG_W   0x00000080	/*< Context orientation : West direction */
+#define T1_3D_SIG_FC  0x00000100	/*< Context orientation : Forward Central direction */		
+#define T1_3D_SIG_BC  0x00000200	/*< Context orientation : Backward Central direction */	
+#define T1_3D_SIG_FNE 0x00000400	/*< Context orientation : Forward North-East direction */	
+#define T1_3D_SIG_FSE 0x00000800	/*< Context orientation : Forward South-East direction */	
+#define T1_3D_SIG_FSW 0x00001000	/*< Context orientation : Forward South-West direction */	
+#define T1_3D_SIG_FNW 0x00002000	/*< Context orientation : Forward North-West direction */	
+#define T1_3D_SIG_FN  0x00004000	/*< Context orientation : Forward North direction */		
+#define T1_3D_SIG_FE  0x00008000	/*< Context orientation : Forward East direction */		
+#define T1_3D_SIG_FS  0x00010000	/*< Context orientation : Forward South direction */		
+#define T1_3D_SIG_FW  0x00020000	/*< Context orientation : Forward West direction */		
+#define T1_3D_SIG_BNE 0x00040000	/*< Context orientation : Backward North-East direction */	
+#define T1_3D_SIG_BSE 0x00080000	/*< Context orientation : Backward South-East direction */	
+#define T1_3D_SIG_BSW 0x00100000	/*< Context orientation : Backward South-West direction */	
+#define T1_3D_SIG_BNW 0x00200000	/*< Context orientation : Backward North-West direction */	
+#define T1_3D_SIG_BN  0x00400000	/*< Context orientation : Backward North direction */		
+#define T1_3D_SIG_BE  0x00800000	/*< Context orientation : Backward East direction */		
+#define T1_3D_SIG_BS  0x01000000	/*< Context orientation : Backward South direction */		
+#define T1_3D_SIG_BW  0x02000000	/*< Context orientation : Backward West direction */		
+#define T1_3D_SIG_COTH	(T1_3D_SIG_N|T1_3D_SIG_NE|T1_3D_SIG_E|T1_3D_SIG_SE|T1_3D_SIG_S|T1_3D_SIG_SW|T1_3D_SIG_W|T1_3D_SIG_NW)
+#define T1_3D_SIG_BOTH	(T1_3D_SIG_BN|T1_3D_SIG_BNE|T1_3D_SIG_BE|T1_3D_SIG_BSE|T1_3D_SIG_BS|T1_3D_SIG_BSW|T1_3D_SIG_BW|T1_3D_SIG_BNW|T1_3D_SIG_BC)
+#define T1_3D_SIG_FOTH  (T1_3D_SIG_FN|T1_3D_SIG_FNE|T1_3D_SIG_FE|T1_3D_SIG_FSE|T1_3D_SIG_FS|T1_3D_SIG_FSW|T1_3D_SIG_FW|T1_3D_SIG_FNW|T1_3D_SIG_FC)
+#define T1_3D_SIG_OTH	(T1_3D_SIG_FOTH|T1_3D_SIG_BOTH|T1_3D_SIG_COTH)
+#define T1_3D_SIG_PRIM	(T1_3D_SIG_N|T1_3D_SIG_E|T1_3D_SIG_S|T1_3D_SIG_W|T1_3D_SIG_FC|T1_3D_SIG_BC)
+
+#define T1_3D_SGN_N		0x0400		
+#define T1_3D_SGN_E		0x0800		
+#define T1_3D_SGN_S		0x1000		
+#define T1_3D_SGN_W		0x2000		
+#define T1_3D_SGN_F		0x4000	
+#define T1_3D_SGN_B		0x8000
+#define T1_3D_SGN		(T1_3D_SGN_N|T1_3D_SGN_E|T1_3D_SGN_S|T1_3D_SGN_W|T1_3D_SGN_F|T1_3D_SGN_B)
+
+#define T1_3D_SIG		0x0001  //Significance state
+#define T1_3D_REFINE	0x0002  //Delayed significance
+#define T1_3D_VISIT		0x0004  //First-pass membership
+
+#define T1_3D_NUMCTXS_AGG	1
+#define T1_3D_NUMCTXS_ZC	16
+#define T1_3D_NUMCTXS_MAG	3
+#define T1_3D_NUMCTXS_SC	6
+#define T1_3D_NUMCTXS_UNI	1
+
+#define T1_3D_CTXNO_AGG 0
+#define T1_3D_CTXNO_ZC	(T1_3D_CTXNO_AGG+T1_3D_NUMCTXS_AGG) //1
+#define T1_3D_CTXNO_MAG (T1_3D_CTXNO_ZC+T1_3D_NUMCTXS_ZC)	//17
+#define T1_3D_CTXNO_SC	(T1_3D_CTXNO_MAG+T1_3D_NUMCTXS_MAG)	//20
+#define T1_3D_CTXNO_UNI (T1_3D_CTXNO_SC+T1_3D_NUMCTXS_SC)	//26
+#define T1_3D_NUMCTXS	(T1_3D_CTXNO_UNI+T1_3D_NUMCTXS_UNI) //27
+
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Tier-1 coding (coding of code-block coefficients)
+*/
+typedef struct opj_t1_3d {
+	/** Codec context */
+	opj_common_ptr cinfo;
+	/** MQC component */
+	opj_mqc_t *mqc;
+	/** RAW component */
+	opj_raw_t *raw;
+	/** LUTs for decoding normalised MSE */
+	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS];
+	/** Codeblock data */
+	int data[T1_CBLKD][T1_CBLKH][T1_CBLKW];
+	/** Context information for each voxel in codeblock */
+	unsigned int flags[T1_CBLKD + 2][T1_CBLKH + 2][T1_CBLKH + 2];
+	/** Voxel information (significance/visited/refined) */
+	int flagSVR[T1_CBLKD + 2][T1_CBLKH + 2][T1_CBLKH + 2];
+} opj_t1_3d_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new T1_3D handle 
+and initialize the look-up tables of the Tier-1 coder/decoder
+@return Returns a new T1 handle if successful, returns NULL otherwise
+@see t1_init_luts
+*/
+opj_t1_3d_t* t1_3d_create(opj_common_ptr cinfo);
+/**
+Destroy a previously created T1_3D handle
+@param t1 T1_3D handle to destroy
+*/
+void t1_3d_destroy(opj_t1_3d_t *t1);
+/**
+Encode the code-blocks of a tile
+@param t1 T1_3D handle
+@param tile The tile to encode
+@param tcp Tile coding parameters
+*/
+void t1_3d_encode_cblks(opj_t1_3d_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+/**
+Decode the code-blocks of a tile
+@param t1 T1_3D handle
+@param tile The tile to decode
+@param tcp Tile coding parameters
+*/
+void t1_3d_decode_cblks(opj_t1_3d_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+/**
+Get weigths of MSE decoding
+@param nmsedec The normalized MSE reduction
+@param compno 
+@param level 
+@param orient
+@param bpno
+@param reversible
+@param stepsize
+@param numcomps
+@param dwtid
+returns MSE associated to decoding pass
+double t1_3d_getwmsedec(int nmsedec, int compno, int levelxy, int levelz, int orient, int bpno, int reversible, double stepsize, int numcomps, int dwtid);
+*/
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __T1_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/t1.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t1.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,1181 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup T1 T1 - Implementation of the tier-1 coding */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+static int t1_getctxno_zc(opj_t1_t *t1, int f, int orient);
+static int t1_getctxno_sc(opj_t1_t *t1, int f);
+static int t1_getctxno_mag(opj_t1_t *t1, int f);
+static int t1_getspb(opj_t1_t *t1, int f);
+static int t1_getnmsedec_sig(opj_t1_t *t1, int x, int bitpos);
+static int t1_getnmsedec_ref(opj_t1_t *t1, int x, int bitpos);
+static void t1_updateflags(int *fp, int s);
+/**
+Encode significant pass
+*/
+static void t1_enc_sigpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, char type, int vsc);
+/**
+Decode significant pass
+*/
+static void t1_dec_sigpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int oneplushalf, char type, int vsc);
+/**
+Encode significant pass
+*/
+static void t1_enc_sigpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, char type, int cblksty);
+/**
+Decode significant pass
+*/
+static void t1_dec_sigpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, char type, int cblksty);
+/**
+Encode refinement pass
+*/
+static void t1_enc_refpass_step(opj_t1_t *t1, int *fp, int *dp, int bpno, int one, int *nmsedec, char type, int vsc);
+/**
+Decode refinement pass
+*/
+static void t1_dec_refpass_step(opj_t1_t *t1, int *fp, int *dp, int poshalf, int neghalf, char type, int vsc);
+/**
+Encode refinement pass
+*/
+static void t1_enc_refpass(opj_t1_t *t1, int w, int h, int l, int bpno, int *nmsedec, char type, int cblksty);
+/**
+Decode refinement pass
+*/
+static void t1_dec_refpass(opj_t1_t *t1, int w, int h, int l, int bpno, char type, int cblksty);
+/**
+Encode clean-up pass
+*/
+static void t1_enc_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, int partial, int vsc);
+/**
+Decode clean-up pass
+*/
+static void t1_dec_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int oneplushalf, int partial, int vsc);
+/**
+Encode clean-up pass
+*/
+static void t1_enc_clnpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, int cblksty);
+/**
+Decode clean-up pass
+*/
+static void t1_dec_clnpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int cblksty);
+/**
+Encode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param compno Component number
+@param level
+@param dwtid
+@param stepsize
+@param cblksty Code-block style
+@param numcomps
+@param tile
+*/
+static void t1_encode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int compno, int level[3], int dwtid[3], double stepsize, int cblksty, int numcomps, opj_tcd_tile_t * tile);
+/**
+Decode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param roishift Region of interest shifting value
+@param cblksty Code-block style
+*/
+static void t1_decode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int roishift, int cblksty);
+
+static int t1_init_ctxno_zc(int f, int orient);
+static int t1_init_ctxno_sc(int f);
+static int t1_init_ctxno_mag(int f);
+static int t1_init_spb(int f);
+/**
+Initialize the look-up tables of the Tier-1 coder/decoder
+@param t1 T1 handle
+*/
+static void t1_init_luts(opj_t1_t *t1);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+static int t1_getctxno_zc(opj_t1_t *t1, int f, int orient) {
+	return t1->lut_ctxno_zc[(orient << 8) | (f & T1_SIG_OTH)];
+}
+
+static int t1_getctxno_sc(opj_t1_t *t1, int f) {
+	return t1->lut_ctxno_sc[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
+}
+
+static int t1_getctxno_mag(opj_t1_t *t1, int f) {
+	return t1->lut_ctxno_mag[(f & T1_SIG_OTH) | (((f & T1_REFINE) != 0) << 11)];
+}
+
+static int t1_getspb(opj_t1_t *t1, int f) {
+	return t1->lut_spb[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
+}
+
+static int t1_getnmsedec_sig(opj_t1_t *t1, int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return t1->lut_nmsedec_sig[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+	
+	return t1->lut_nmsedec_sig0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static int t1_getnmsedec_ref(opj_t1_t *t1, int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return t1->lut_nmsedec_ref[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+
+    return t1->lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static void t1_updateflags(int *fp, int s) {
+	int *np = fp - (T1_MAXCBLKW + 2);
+	int *sp = fp + (T1_MAXCBLKW + 2);
+	np[-1] |= T1_SIG_SE;
+	np[1] |= T1_SIG_SW;
+	sp[-1] |= T1_SIG_NE;
+	sp[1] |= T1_SIG_NW;
+	*np |= T1_SIG_S;
+	*sp |= T1_SIG_N;
+	fp[-1] |= T1_SIG_E;
+	fp[1] |= T1_SIG_W;
+	if (s) {
+		*np |= T1_SGN_S;
+		*sp |= T1_SGN_N;
+		fp[-1] |= T1_SGN_E;
+		fp[1] |= T1_SGN_W;
+	}
+}
+
+static void t1_enc_sigpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, char type, int vsc) {
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+		v = int_abs(*dp) & one ? 1 : 0;
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_setcurctx(mqc, t1_getctxno_zc(t1, flag, orient));	/* ESSAI */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_setcurctx(mqc, t1_getctxno_zc(t1, flag, orient));
+			mqc_encode(mqc, v);
+		}
+		if (v) {
+			v = *dp < 0 ? 1 : 0;
+			*nmsedec +=	t1_getnmsedec_sig(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+				mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));	/* ESSAI */
+				mqc_bypass_enc(mqc, v);
+			} else {
+				mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
+				mqc_encode(mqc, v ^ t1_getspb(t1, flag));
+			}
+			t1_updateflags(fp, v);
+			*fp |= T1_SIG;
+		}
+		*fp |= T1_VISIT;
+	}
+}
+
+static void t1_dec_sigpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int oneplushalf, char type, int vsc) {
+	int v, flag;
+	
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+		if (type == T1_TYPE_RAW) {
+			if (raw_decode(raw)) {
+				v = raw_decode(raw);	/* ESSAI */
+				*dp = v ? -oneplushalf : oneplushalf;
+				t1_updateflags(fp, v);
+				*fp |= T1_SIG;
+			}
+		} else {
+			mqc_setcurctx(mqc, t1_getctxno_zc(t1, flag, orient));
+			if (mqc_decode(mqc)) {
+				mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
+				v = mqc_decode(mqc) ^ t1_getspb(t1, flag);
+				*dp = v ? -oneplushalf : oneplushalf;
+				t1_updateflags(fp, v);
+				*fp |= T1_SIG;
+			}
+		}
+		*fp |= T1_VISIT;
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_sigpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, char type, int cblksty) {
+	int i, j, k, m, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++) {
+	for (k = 0; k < h; k += 4) {
+		for (i = 0; i < w; i++) {
+			for (j = k; j < k + 4 && j < h; j++) {
+				vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+				t1_enc_sigpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, bpno, one, nmsedec, type, vsc);
+			}
+		}
+	}
+	}
+}
+
+static void t1_dec_sigpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, char type, int cblksty) {
+	int i, j, k, m, one, half, oneplushalf, vsc;
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (m = 0; m < l; m++) {
+	for (k = 0; k < h; k += 4) {
+		for (i = 0; i < w; i++) {
+			for (j = k; j < k + 4 && j < h; j++) {
+				vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+				t1_dec_sigpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, oneplushalf, type, vsc);
+			}
+		}
+	}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_refpass_step(opj_t1_t *t1, int *fp, int *dp, int bpno, int one, int *nmsedec, char type, int vsc) {
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		*nmsedec += t1_getnmsedec_ref(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+		v = int_abs(*dp) & one ? 1 : 0;
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_setcurctx(mqc, t1_getctxno_mag(t1, flag));	/* ESSAI */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_setcurctx(mqc, t1_getctxno_mag(t1, flag));
+			mqc_encode(mqc, v);
+		}
+		*fp |= T1_REFINE;
+	}
+}
+
+static void t1_dec_refpass_step(opj_t1_t *t1, int *fp, int *dp, int poshalf, int neghalf, char type, int vsc) {
+	int v, t, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		if (type == T1_TYPE_RAW) {
+			mqc_setcurctx(mqc, t1_getctxno_mag(t1, flag));	/* ESSAI */
+			v = raw_decode(raw);
+		} else {
+			mqc_setcurctx(mqc, t1_getctxno_mag(t1, flag));
+			v = mqc_decode(mqc);
+		}
+		t = v ? poshalf : neghalf;
+		*dp += *dp < 0 ? -t : t;
+		*fp |= T1_REFINE;
+	}
+}				/* VSC and  BYPASS by Antonin  */
+
+static void t1_enc_refpass(opj_t1_t *t1, int w, int h, int l, int bpno, int *nmsedec, char type, int cblksty) {
+	int i, j, k, m, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+		for (i = 0; i < w; i++) {
+			for (j = k; j < k + 4 && j < h; j++) {
+				vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+				t1_enc_refpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->data[m][j][i], bpno, one, nmsedec, type, vsc);
+			}
+		}
+	}
+	}
+}
+
+static void t1_dec_refpass(opj_t1_t *t1, int w, int h, int l, int bpno, char type, int cblksty) {
+	int i, j, k, m, one, poshalf, neghalf;
+	int vsc;
+	one = 1 << bpno;
+	poshalf = one >> 1;
+	neghalf = bpno > 0 ? -poshalf : -1;
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+		for (i = 0; i < w; i++) {
+			for (j = k; j < k + 4 && j < h; j++) {
+				vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+				t1_dec_refpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->data[m][j][i], poshalf, neghalf, type, vsc);
+			}
+		}
+	}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int bpno, int one, int *nmsedec, int partial, int vsc) {
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(*fp & (T1_SIG | T1_VISIT))) {
+		mqc_setcurctx(mqc, t1_getctxno_zc(t1, flag, orient));
+		v = int_abs(*dp) & one ? 1 : 0;
+		mqc_encode(mqc, v);
+		if (v) {
+LABEL_PARTIAL:
+			*nmsedec += t1_getnmsedec_sig(t1, int_abs(*dp), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
+			v = *dp < 0 ? 1 : 0;
+			mqc_encode(mqc, v ^ t1_getspb(t1, flag));
+			t1_updateflags(fp, v);
+			*fp |= T1_SIG;
+		}
+	}
+	*fp &= ~T1_VISIT;
+}
+
+static void t1_dec_clnpass_step(opj_t1_t *t1, int *fp, int *dp, int orient, int oneplushalf, int partial, int vsc) {
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*fp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*fp);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(flag & (T1_SIG | T1_VISIT))) {
+		mqc_setcurctx(mqc, t1_getctxno_zc(t1, flag, orient));
+		if (mqc_decode(mqc)) {
+LABEL_PARTIAL:
+			mqc_setcurctx(mqc, t1_getctxno_sc(t1, flag));
+			v = mqc_decode(mqc) ^ t1_getspb(t1, flag);
+			*dp = v ? -oneplushalf : oneplushalf;
+			t1_updateflags(fp, v);
+			*fp |= T1_SIG;
+		}
+	}
+	*fp &= ~T1_VISIT;
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_clnpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int *nmsedec, int cblksty) {
+	int i, j, k, m, one, agg, runlen, vsc;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+			for (i = 0; i < w; i++) {
+				if (k + 3 < h) {
+					if (cblksty & J3D_CCP_CBLKSTY_VSC) {
+						agg = !(t1->flags[1 + m][1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| t1->flags[1 + m][1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| t1->flags[1 + m][1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| (t1->flags[1 + m][1 + k + 3][1 + i] 
+							& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+					} else {
+						agg = !(t1->flags[1 + m][1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| t1->flags[1 + m][1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| t1->flags[1 + m][1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+							|| t1->flags[1 + m][1 + k + 3][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+					}
+				} else {
+					agg = 0;
+				}
+				if (agg) {
+					for (runlen = 0; runlen < 4; runlen++) {
+						if (int_abs(t1->data[m][k + runlen][i]) & one)
+							break;
+					}
+					mqc_setcurctx(mqc, T1_CTXNO_AGG);
+					mqc_encode(mqc, runlen != 4);
+					if (runlen == 4) {
+						continue;
+					}
+					mqc_setcurctx(mqc, T1_CTXNO_UNI);
+					mqc_encode(mqc, runlen >> 1);
+					mqc_encode(mqc, runlen & 1);
+				} else {
+					runlen = 0;
+				}
+				for (j = k + runlen; j < k + 4 && j < h; j++) {
+					vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+					t1_enc_clnpass_step(t1, &(t1->flags[1 + m][1 + j][1 + i]), &(t1->data[m][j][i]), orient, bpno, one, nmsedec, agg && (j == k + runlen), vsc);
+				}
+			}
+	}
+	}
+}
+
+static void t1_dec_clnpass(opj_t1_t *t1, int w, int h, int l, int bpno, int orient, int cblksty) {
+	int i, j, k, m, one, half, oneplushalf, agg, runlen, vsc;
+	int segsym = cblksty & J3D_CCP_CBLKSTY_SEGSYM;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (m = 0; m < l; m++) {
+		for (k = 0; k < h; k += 4) {
+		for (i = 0; i < w; i++) {
+			if (k + 3 < h) {
+				if (cblksty & J3D_CCP_CBLKSTY_VSC) {
+					agg = !(t1->flags[1 + m][1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| t1->flags[1 + m][1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| t1->flags[1 + m][1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| (t1->flags[1 + m][1 + k + 3][1 + i] 
+						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				} else {
+					agg = !(t1->flags[1 + m][1 + k][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| t1->flags[1 + m][1 + k + 1][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| t1->flags[1 + m][1 + k + 2][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| t1->flags[1 + m][1 + k + 3][1 + i] & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				}
+			} else {
+				agg = 0;
+			}
+			if (agg) {
+				mqc_setcurctx(mqc, T1_CTXNO_AGG);
+				if (!mqc_decode(mqc)) {
+					continue;
+				}
+				mqc_setcurctx(mqc, T1_CTXNO_UNI);
+				runlen = mqc_decode(mqc);
+				runlen = (runlen << 1) | mqc_decode(mqc);
+			} else {
+				runlen = 0;
+			}
+			for (j = k + runlen; j < k + 4 && j < h; j++) {
+				vsc = ((cblksty & J3D_CCP_CBLKSTY_VSC) && (j == k + 3 || j == h - 1)) ? 1 : 0;
+				t1_dec_clnpass_step(t1, &t1->flags[1 + m][1 + j][1 + i], &t1->data[m][j][i], orient, oneplushalf, agg && (j == k + runlen), vsc);
+			}
+		}
+	}
+	}
+	if (segsym) {
+		int v = 0;
+		mqc_setcurctx(mqc, T1_CTXNO_UNI);
+		v = mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		/*
+		if (v!=0xa) {
+			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
+		} 
+		*/
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+
+static void t1_encode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int compno, int level[3], int dwtid[3], double stepsize, int cblksty, int numcomps, opj_tcd_tile_t * tile) {
+	int i, j, k;
+	int w, h, l;
+	int passno;
+	int bpno, passtype;
+	int max;
+	int nmsedec = 0;
+	double cumwmsedec = 0;
+	char type = T1_TYPE_MQ;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	w = cblk->x1 - cblk->x0;
+	h = cblk->y1 - cblk->y0;
+	l = cblk->z1 - cblk->z0;
+
+	max = 0;
+	for (k = 0; k < l; k++) {
+		for (j = 0; j < h; j++) {
+			for (i = 0; i < w; i++) {
+				max = int_max(max, int_abs(t1->data[k][j][i]));
+			}
+		}
+	}
+	for (k = 0; k <= l; k++) {
+		for (j = 0; j <= h; j++) {
+			for (i = 0; i <= w; i++) {
+				t1->flags[k][j][i] = 0;	
+			}
+		}
+	}
+
+	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
+	
+	bpno = cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_reset_enc(mqc);
+	mqc_init_enc(mqc, cblk->data);
+	
+	for (passno = 0; bpno >= 0; passno++) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		int correction = 3;
+		double tmpwmsedec;
+		type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		//fprintf(stdout,"passno %d passtype %d w %d h %d l %d bpno %d orient %d type %d cblksty %d\n",passno,passtype,w,h,l,bpno,orient,type,cblksty);
+
+		switch (passtype) {
+			case 0:
+				t1_enc_sigpass(t1, w, h, l, bpno, orient, &nmsedec, type, cblksty);
+				break;
+			case 1:
+				t1_enc_refpass(t1, w, h, l, bpno, &nmsedec, type, cblksty);
+				break;
+			case 2:
+				//fprintf(stdout,"w %d h %d l %d bpno %d orient %d \n",w,h,l,bpno,orient);
+				t1_enc_clnpass(t1, w, h, l, bpno, orient, &nmsedec, cblksty);
+				/* code switch SEGMARK (i.e. SEGSYM) */
+				if (cblksty & J3D_CCP_CBLKSTY_SEGSYM)
+					mqc_segmark_enc(mqc);
+				break;
+		}
+		
+		/* fixed_quality */
+		tmpwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, stepsize, numcomps, dwtid);
+		cumwmsedec += tmpwmsedec;
+		tile->distotile += tmpwmsedec;
+		
+		/* Code switch "RESTART" (i.e. TERMALL) */
+		if ((cblksty & J3D_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
+			if (type == T1_TYPE_RAW) {
+				mqc_flush(mqc);
+				correction = 1;
+				/* correction = mqc_bypass_flush_enc(); */
+			} else {			/* correction = mqc_restart_enc(); */
+				mqc_flush(mqc);
+				correction = 1;
+			}
+			pass->term = 1;
+		} else {
+			if (((bpno < (cblk->numbps - 4) && (passtype > 0)) 
+				|| ((bpno == (cblk->numbps - 4)) && (passtype == 2))) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) {
+				if (type == T1_TYPE_RAW) {
+					mqc_flush(mqc);
+					correction = 1;
+					/* correction = mqc_bypass_flush_enc(); */
+				} else {		/* correction = mqc_restart_enc(); */
+					mqc_flush(mqc);
+					correction = 1;
+				}
+				pass->term = 1;
+			} else {
+				pass->term = 0;
+			}
+		}
+		
+		if (++passtype == 3) {
+			passtype = 0;
+			bpno--;
+		}
+		
+		if (pass->term && bpno > 0) {
+			type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+			if (type == T1_TYPE_RAW)
+				mqc_bypass_init_enc(mqc);
+			else
+				mqc_restart_init_enc(mqc);
+		}
+		
+		pass->distortiondec = cumwmsedec;
+		pass->rate = mqc_numbytes(mqc) + correction;	/* FIXME */
+		pass->len = pass->rate - (passno == 0 ? 0 : cblk->passes[passno - 1].rate);
+		
+		/* Code-switch "RESET" */
+		if (cblksty & J3D_CCP_CBLKSTY_RESET)
+			mqc_reset_enc(mqc);
+	}
+	
+	/* Code switch "ERTERM" (i.e. PTERM) */
+	if (cblksty & J3D_CCP_CBLKSTY_PTERM)
+		mqc_erterm_enc(mqc);
+	else /* Default coding */ if (!(cblksty & J3D_CCP_CBLKSTY_LAZY))
+		mqc_flush(mqc);
+	
+	cblk->totalpasses = passno;
+}
+
+static void t1_decode_cblk(opj_t1_t *t1, opj_tcd_cblk_t * cblk, int orient, int roishift, int cblksty) {
+	int i, j, k, w, h, l;
+	int bpno, passtype;
+	int segno, passno;
+	char type = T1_TYPE_MQ; /* BYPASS mode */
+	
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	w = cblk->x1 - cblk->x0;
+	h = cblk->y1 - cblk->y0;
+	l = cblk->z1 - cblk->z0;
+
+    for (k = 0; k < l; k++) {
+		for (j = 0; j < h; j++) {
+			for (i = 0; i < w; i++) {
+				t1->data[k][j][i] = 0;
+			}
+		}
+	}
+	
+	for (k = 0; k <= l; k++) {
+		for (j = 0; j <= h; j++) {
+			for (i = 0; i <= w; i++) {
+				t1->flags[k][j][i] = 0;
+			}
+		}
+	}
+
+	bpno = roishift + cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_reset_enc(mqc);
+	
+	for (segno = 0; segno < cblk->numsegs; segno++) {
+		opj_tcd_seg_t *seg = &cblk->segs[segno];
+		
+		/* BYPASS mode */
+		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J3D_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		if (type == T1_TYPE_RAW) {
+			raw_init_dec(raw, seg->data, seg->len);
+		} else {
+			mqc_init_dec(mqc, seg->data, seg->len);
+		}
+
+		for (passno = 0; passno < seg->numpasses; passno++) {
+			switch (passtype) {
+				case 0:
+					t1_dec_sigpass(t1, w, h, l, bpno+1, orient, type, cblksty);
+					break;
+				case 1:
+					t1_dec_refpass(t1, w, h, l, bpno+1, type, cblksty);
+					break;
+				case 2:
+					t1_dec_clnpass(t1, w, h, l, bpno+1, orient, cblksty);
+					break;
+			}
+			
+			if ((cblksty & J3D_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
+				mqc_reset_enc(mqc);
+			}
+			if (++passtype == 3) {
+				passtype = 0;
+				bpno--;
+			}
+		}
+	}
+}
+
+static int t1_init_ctxno_zc(int f, int orient) {
+	int h, v, d, n, t, hv;
+	n = 0;
+	h = ((f & T1_SIG_W) != 0) + ((f & T1_SIG_E) != 0);
+	v = ((f & T1_SIG_N) != 0) + ((f & T1_SIG_S) != 0);
+	d = ((f & T1_SIG_NW) != 0) + ((f & T1_SIG_NE) != 0) + ((f & T1_SIG_SE) != 0) + ((f & T1_SIG_SW) != 0);
+	
+	switch (orient) {
+		case 2:
+			t = h;
+			h = v;
+			v = t;
+		case 0:
+		case 1:
+			if (!h) {
+				if (!v) {
+					if (!d)
+						n = 0;
+					else if (d == 1)
+						n = 1;
+					else
+						n = 2;
+				} else if (v == 1) {
+					n = 3;
+				} else {
+					n = 4;
+				}
+			} else if (h == 1) {
+				if (!v) {
+					if (!d)
+						n = 5;
+					else
+						n = 6;
+				} else {
+					n = 7;
+				}
+			} else
+				n = 8;
+			break;
+		case 3:
+			hv = h + v;
+			if (!d) {
+				if (!hv) {
+					n = 0;
+				} else if (hv == 1) {
+					n = 1;
+				} else {
+					n = 2;
+				}
+			} else if (d == 1) {
+				if (!hv) {
+					n = 3;
+				} else if (hv == 1) {
+					n = 4;
+				} else {
+					n = 5;
+				}
+			} else if (d == 2) {
+				if (!hv) {
+					n = 6;
+				} else {
+					n = 7;
+				}
+			} else {
+				n = 8;
+			}
+			break;
+	}
+	
+	return (T1_CTXNO_ZC + n);
+}
+
+static int t1_init_ctxno_sc(int f) {
+	int hc, vc, n;
+	n = 0;
+
+	hc = int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+		T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+	       1) - int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+		   (T1_SIG_E | T1_SGN_E)) +
+		   ((f & (T1_SIG_W | T1_SGN_W)) ==
+		   (T1_SIG_W | T1_SGN_W)), 1);
+	
+	vc = int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+		T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+	       1) - int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+		   (T1_SIG_N | T1_SGN_N)) +
+		   ((f & (T1_SIG_S | T1_SGN_S)) ==
+		   (T1_SIG_S | T1_SGN_S)), 1);
+	
+	if (hc < 0) {
+		hc = -hc;
+		vc = -vc;
+	}
+	if (!hc) {
+		if (vc == -1)
+			n = 1;
+		else if (!vc)
+			n = 0;
+		else
+			n = 1;
+	} else if (hc == 1) {
+		if (vc == -1)
+			n = 2;
+		else if (!vc)
+			n = 3;
+		else
+			n = 4;
+	}
+	
+	return (T1_CTXNO_SC + n);
+}
+
+static int t1_init_ctxno_mag(int f) {
+	int n;
+	if (!(f & T1_REFINE))
+		n = (f & (T1_SIG_OTH)) ? 1 : 0;
+	else
+		n = 2;
+	
+	return (T1_CTXNO_MAG + n);
+}
+
+static int t1_init_spb(int f) {
+	int hc, vc, n;
+	
+	hc = int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+		T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+	       1) - int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+		   (T1_SIG_E | T1_SGN_E)) +
+		   ((f & (T1_SIG_W | T1_SGN_W)) ==
+		   (T1_SIG_W | T1_SGN_W)), 1);
+	
+	vc = int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+		T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+	       1) - int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+		   (T1_SIG_N | T1_SGN_N)) +
+		   ((f & (T1_SIG_S | T1_SGN_S)) ==
+		   (T1_SIG_S | T1_SGN_S)), 1);
+	
+	if (!hc && !vc)
+		n = 0;
+	else
+		n = (!(hc > 0 || (!hc && vc > 0)));
+	
+	return n;
+}
+
+static void t1_init_luts(opj_t1_t *t1) {
+	int i, j;
+	double u, v, t;
+	for (j = 0; j < 4; j++) {
+		for (i = 0; i < 256; ++i) {
+			t1->lut_ctxno_zc[(j << 8) | i] = t1_init_ctxno_zc(i, j);
+		}
+	}
+	for (i = 0; i < 256; i++) {
+		t1->lut_ctxno_sc[i] = t1_init_ctxno_sc(i << 4);
+	}
+	for (j = 0; j < 2; j++) {
+		for (i = 0; i < 2048; ++i) {
+			t1->lut_ctxno_mag[(j << 11) + i] = t1_init_ctxno_mag((j ? T1_REFINE : 0) | i);
+		}
+	}
+	for (i = 0; i < 256; ++i) {
+		t1->lut_spb[i] = t1_init_spb(i << 4);
+	}
+	/* FIXME FIXME FIXME */
+	/* fprintf(stdout,"nmsedec luts:\n"); */
+	for (i = 0; i < (1 << T1_NMSEDEC_BITS); i++) {
+		t = i / pow(2, T1_NMSEDEC_FRACBITS);
+		u = t;
+		v = t - 1.5;
+		t1->lut_nmsedec_sig[i] = 
+			int_max(0, 
+			(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		t1->lut_nmsedec_sig0[i] =
+			int_max(0,
+			(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		u = t - 1.0;
+		if (i & (1 << (T1_NMSEDEC_BITS - 1))) {
+			v = t - 1.5;
+		} else {
+			v = t - 0.5;
+		}
+		t1->lut_nmsedec_ref[i] =
+			int_max(0,
+			(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		t1->lut_nmsedec_ref0[i] =
+			int_max(0,
+			(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+	}
+}
+
+/* ----------------------------------------------------------------------- */
+
+opj_t1_t* t1_create(opj_common_ptr cinfo) {
+	opj_t1_t *t1 = (opj_t1_t*)opj_malloc(sizeof(opj_t1_t));
+	if(t1) {
+		t1->cinfo = cinfo;
+		/* create MQC and RAW handles */
+		t1->mqc = mqc_create();
+		t1->raw = raw_create();
+		/* initialize the look-up tables of the Tier-1 coder/decoder */
+		t1_init_luts(t1);
+	}
+	return t1;
+}
+
+void t1_destroy(opj_t1_t *t1) {
+	if(t1) {
+		/* destroy MQC and RAW handles */
+		mqc_destroy(t1->mqc);
+		raw_destroy(t1->raw);
+		//opj_free(t1->data);
+		//opj_free(t1->flags);
+		opj_free(t1);
+	}
+}
+
+void t1_encode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp) {
+	int compno, resno, bandno, precno, cblkno;
+	int x, y, z, i, j, k, orient;
+	int n=0;
+	int level[3];
+	FILE *fid = NULL;
+//	char filename[10];
+	tile->distotile = 0;		/* fixed_quality */
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			
+			/* Weighted first order entropy
+			sprintf(filename,"res%d.txt",resno);
+			if ((fid = fopen(filename,"w")) == 0){
+				fprintf(stdout,"Error while opening %s\n", filename);
+				exit(1);
+			}
+			*/
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+
+						//fprintf(stdout,"Precno %d Cblkno %d \n",precno,cblkno);
+						if (band->bandno == 0) {
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 1) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 2) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 3) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 4) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 5) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 6) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 7) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						}
+
+						if (tcp->tccps[compno].reversible == 1) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+                                    for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+                                        t1->data[k][j][i] = 
+										tilec->data[(x + i) + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] << T1_NMSEDEC_FRACBITS;
+//fprintf(fid," %d",t1->data[k][j][i]);
+									}
+								}
+							}
+						} else if (tcp->tccps[compno].reversible == 0) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+                                    for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+                                        t1->data[k][j][i] = fix_mul(
+										tilec->data[(x + i) + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)],
+										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (13 - T1_NMSEDEC_FRACBITS);
+									}
+								}
+							}
+						}
+
+						orient = band->bandno;	/* FIXME */
+						if (orient == 2) {
+							orient = 1;
+						} else if (orient == 1) {
+							orient = 2;
+						}
+						for (i = 0; i < 3; i++) 
+							level[i] = tilec->numresolution[i] - 1 - resno;
+						//fprintf(stdout,"t1_encode_cblk(t1, cblk, %d, %d, %d %d %d, %d, %f, %d, %d, tile);\n", orient, compno, level[0], level[1], level[2], tcp->tccps[compno].reversible, band->stepsize, tcp->tccps[compno].cblksty, tile->numcomps);
+						t1_encode_cblk(t1, cblk, orient, compno, level, tcp->tccps[compno].dwtid, band->stepsize, tcp->tccps[compno].cblksty, tile->numcomps, tile);
+							
+					} /* cblkno */
+				} /* precno */
+//fprintf(fid,"\n");
+			} /* bandno */
+//fclose(fid);
+		} /* resno  */
+	} /* compno  */
+}
+
+void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp) {
+	int compno, resno, bandno, precno, cblkno;
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						int x, y, k, i, j, z, orient;
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+
+						orient = band->bandno;	/* FIXME */
+						if (orient == 2) {
+							orient = 1;
+						} else if (orient == 1) {
+							orient = 2;
+						}
+
+						t1_decode_cblk(t1, cblk, orient, tcp->tccps[compno].roishift, tcp->tccps[compno].cblksty);
+
+						if (band->bandno == 0) {
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 1) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 2) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 3) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = cblk->z0 - band->z0;
+						} else if (band->bandno == 4) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 5) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 6) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						} else if (band->bandno == 7) {		
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x = pres->x1 - pres->x0 + cblk->x0 - band->x0;
+							y = pres->y1 - pres->y0 + cblk->y0 - band->y0;
+							z = pres->z1 - pres->z0 + cblk->z0 - band->z0;
+						}
+						
+						if (tcp->tccps[compno].roishift) {
+							int thresh, val, mag;
+							thresh = 1 << tcp->tccps[compno].roishift;
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										val = t1->data[k][j][i];
+										mag = int_abs(val);
+										if (mag >= thresh) {
+											mag >>= tcp->tccps[compno].roishift;
+											t1->data[k][j][i] = val < 0 ? -mag : mag;
+										}
+									}
+								}
+							}
+						}
+						
+						if (tcp->tccps[compno].reversible == 1) {
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										int tmp = t1->data[k][j][i];
+										tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = tmp/2;
+									}
+								}
+							}
+						} else {		/* if (tcp->tccps[compno].reversible == 0) */
+							for (k = 0; k < cblk->z1 - cblk->z0; k++) {
+								for (j = 0; j < cblk->y1 - cblk->y0; j++) {
+									for (i = 0; i < cblk->x1 - cblk->x0; i++) {
+										double tmp = (double)(t1->data[k][j][i] * band->stepsize * 4096.0);
+										if (t1->data[k][j][i] >> 1 == 0) {
+											tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = 0;
+										} else {
+											int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
+											tilec->data[x + i + (y + j) * (tilec->x1 - tilec->x0) + (z + k) * (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0)] = ((tmp<0)?-tmp2:tmp2);
+										}
+									}
+								}
+							}
+						}
+					} /* cblkno */
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
+}
+
+
+/** mod fixed_quality */
+double t1_getwmsedec(int nmsedec, int compno, int level[3], int orient, int bpno, double stepsize, int numcomps, int dwtid[3])	{
+	double w1, w2, wmsedec;
+	
+	if (dwtid[0] == 1 || dwtid[1] == 1 || dwtid[2] == 1) {
+		w1 = (numcomps > 1) ? mct_getnorm_real(compno) : 1;
+	} else {			
+		w1 = (numcomps > 1) ? mct_getnorm(compno) : 1;
+	}
+	w2 = dwt_getnorm(orient, level, dwtid);
+
+	//fprintf(stdout,"nmsedec %d level %d %d %d orient %d bpno %d stepsize %f \n",nmsedec ,level[0],level[1],level[2],orient,bpno,stepsize);
+	wmsedec = w1 * w2 * stepsize * (1 << bpno);
+	wmsedec *= wmsedec * nmsedec / 8192.0;
+	
+	return wmsedec;
+}
+/** mod fixed_quality */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/t1.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t1.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t1.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,173 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __T1_H
+#define __T1_H
+/**
+@file t1.h
+@brief Implementation of the tier-1 coding (coding of code-block coefficients) (T1)
+
+The functions in T1.C have for goal to realize the tier-1 coding operation. The functions
+in T1.C are used by some function in TCD.C.
+*/
+
+/** @defgroup T1 T1 - Implementation of the tier-1 coding */
+/*@{*/
+
+/* ----------------------------------------------------------------------- */
+#define T1_NMSEDEC_BITS 7
+
+#define T1_MAXCBLKW 256	/*< Maximum size of code-block (width) */
+#define T1_MAXCBLKH 256	/*< Maximum size of code-block (heigth) */
+#define T1_MAXCBLKD 256	/*< Maximum size of code-block (depth) */
+#define T1_MINCBLKW 4		/*< Minimum size of code-block (width) */
+#define T1_MINCBLKH 4		/*< Minimum size of code-block (heigth) */
+#define T1_MINCBLKD 4		/*< Minimum size of code-block (depth) */
+#define T1_MAXWHD 18	
+#define T1_CBLKW 256
+#define T1_CBLKH 256
+#define T1_CBLKD 256
+
+#define T1_SIG_NE 0x0001	/*< Context orientation : North-East direction */
+#define T1_SIG_SE 0x0002	/*< Context orientation : South-East direction */
+#define T1_SIG_SW 0x0004	/*< Context orientation : South-West direction */
+#define T1_SIG_NW 0x0008	/*< Context orientation : North-West direction */
+#define T1_SIG_N 0x0010		/*< Context orientation : North direction */
+#define T1_SIG_E 0x0020		/*< Context orientation : East direction */
+#define T1_SIG_S 0x0040		/*< Context orientation : South direction */
+#define T1_SIG_W 0x0080		/*< Context orientation : West direction */
+#define T1_SIG_OTH (T1_SIG_N|T1_SIG_NE|T1_SIG_E|T1_SIG_SE|T1_SIG_S|T1_SIG_SW|T1_SIG_W|T1_SIG_NW)
+#define T1_SIG_PRIM (T1_SIG_N|T1_SIG_E|T1_SIG_S|T1_SIG_W)
+
+#define T1_SGN_N 0x0100
+#define T1_SGN_E 0x0200
+#define T1_SGN_S 0x0400
+#define T1_SGN_W 0x0800
+#define T1_SGN (T1_SGN_N|T1_SGN_E|T1_SGN_S|T1_SGN_W)
+
+#define T1_SIG 0x1000
+#define T1_REFINE 0x2000
+#define T1_VISIT 0x4000
+
+#define T1_NUMCTXS_AGG 1
+#define T1_NUMCTXS_ZC 9
+#define T1_NUMCTXS_MAG 3
+#define T1_NUMCTXS_SC 5
+#define T1_NUMCTXS_UNI 1
+
+#define T1_CTXNO_AGG 0
+#define T1_CTXNO_ZC (T1_CTXNO_AGG+T1_NUMCTXS_AGG)
+#define T1_CTXNO_MAG (T1_CTXNO_ZC+T1_NUMCTXS_ZC)
+#define T1_CTXNO_SC (T1_CTXNO_MAG+T1_NUMCTXS_MAG)
+#define T1_CTXNO_UNI (T1_CTXNO_SC+T1_NUMCTXS_SC)
+#define T1_NUMCTXS (T1_CTXNO_UNI+T1_NUMCTXS_UNI)
+
+#define T1_NMSEDEC_FRACBITS (T1_NMSEDEC_BITS-1)
+
+#define T1_TYPE_MQ 0	/*< Normal coding using entropy coder */
+#define T1_TYPE_RAW 1	/*< No encoding the information is store under raw format in codestream (mode switch RAW)*/
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Tier-1 coding (coding of code-block coefficients)
+*/
+typedef struct opj_t1 {
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** MQC component */
+	opj_mqc_t *mqc;
+	/** RAW component */
+	opj_raw_t *raw;
+	/** LUTs for context-based coding */
+	int lut_ctxno_zc[1024];
+	int lut_ctxno_sc[256];
+	int lut_ctxno_mag[4096];
+	int lut_spb[256];
+	/** LUTs for decoding normalised MSE */
+	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS];
+	/** Codeblock data */
+	int data[T1_CBLKD][T1_CBLKH][T1_CBLKW];//int ***data;
+	/** Context information for each voxel in codeblock */
+	int flags[T1_CBLKD + 2][T1_CBLKH + 2][T1_CBLKH + 2];//int ***flags;
+} opj_t1_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new T1 handle 
+and initialize the look-up tables of the Tier-1 coder/decoder
+@return Returns a new T1 handle if successful, returns NULL otherwise
+@see t1_init_luts
+*/
+opj_t1_t* t1_create(opj_common_ptr cinfo);
+/**
+Destroy a previously created T1 handle
+@param t1 T1 handle to destroy
+*/
+void t1_destroy(opj_t1_t *t1);
+/**
+Encode the code-blocks of a tile
+@param t1 T1 handle
+@param tile The tile to encode
+@param tcp Tile coding parameters
+*/
+void t1_encode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+/**
+Decode the code-blocks of a tile
+@param t1 T1 handle
+@param tile The tile to decode
+@param tcp Tile coding parameters
+*/
+void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+/**
+Get weigths of MSE decoding
+@param nmsedec The normalized MSE reduction
+@param compno 
+@param level 
+@param orient
+@param bpno
+@param stepsize
+@param numcomps
+@param dwtid
+returns MSE associated to decoding pass
+*/
+double t1_getwmsedec(int nmsedec, int compno, int level[3], int orient, int bpno, double stepsize, int numcomps, int dwtid[3]);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __T1_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t2.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t2.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,675 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup T2 T2 - Implementation of a tier-2 coding */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+static void t2_putcommacode(opj_bio_t *bio, int n);
+static int t2_getcommacode(opj_bio_t *bio);
+/**
+Variable length code for signalling delta Zil (truncation point)
+@param bio Bit Input/Output component
+@param n delta Zil
+*/
+static void t2_putnumpasses(opj_bio_t *bio, int n);
+static int t2_getnumpasses(opj_bio_t *bio);
+/**
+Encode a packet of a tile to a destination buffer
+@param tile Tile for which to write the packets
+@param tcp Tile coding parameters
+@param pi Packet identity
+@param dest Destination buffer
+@param len Length of the destination buffer
+@param volume_info Structure to create an index file
+@param tileno Number of the tile encoded
+@param cp Coding parameters
+@return Number of bytes encoded from the packet
+*/
+static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_volume_info_t *volume_info, int tileno, opj_cp_t *cp);
+/**
+Initialize the segment decoder
+@param seg Segment instance
+@param cblksty Codeblock style
+@param first Is first segment
+*/
+static void t2_init_seg(opj_tcd_seg_t *seg, int cblksty, int first);
+/**
+Decode a packet of a tile from a source buffer
+@param t2 T2 handle
+@param src Source buffer
+@param len Length of the source buffer
+@param tile Tile for which to write the packets
+@param tcp Tile coding parameters
+@param pi Packet identity
+@return Number of bytes decoded from the packet
+*/
+int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+/* #define RESTART 0x04 */
+static void t2_putcommacode(opj_bio_t *bio, int n) {
+	while (--n >= 0) {
+		bio_write(bio, 1, 1);
+	}
+	bio_write(bio, 0, 1);
+}
+
+static int t2_getcommacode(opj_bio_t *bio) {
+	int n;
+	for (n = 0; bio_read(bio, 1); n++) {
+		;
+	}
+	return n;
+}
+
+static void t2_putnumpasses(opj_bio_t *bio, int n) {
+	if (n == 1) {
+		bio_write(bio, 0, 1);
+	} else if (n == 2) {
+		bio_write(bio, 2, 2);
+	} else if (n <= 5) {
+		bio_write(bio, 0xc | (n - 3), 4);
+	} else if (n <= 36) {
+		bio_write(bio, 0x1e0 | (n - 6), 9);
+	} else if (n <= 164) {
+		bio_write(bio, 0xff80 | (n - 37), 16);
+	}
+}
+
+static int t2_getnumpasses(opj_bio_t *bio) {
+	int n;
+	if (!bio_read(bio, 1))
+		return 1;
+	if (!bio_read(bio, 1))
+		return 2;
+	if ((n = bio_read(bio, 2)) != 3)
+		return (3 + n);
+	if ((n = bio_read(bio, 5)) != 31)
+		return (6 + n);
+	return (37 + bio_read(bio, 7));
+}
+
+static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_volume_info_t * volume_info, int tileno, opj_cp_t *cp) {
+	int bandno, cblkno;
+	unsigned char *sop = 0, *eph = 0;
+	unsigned char *c = dest;
+
+	int compno = pi->compno;	/* component value */
+	int resno  = pi->resno;		/* resolution level value */
+	int precno = pi->precno;	/* precinct value */
+	int layno  = pi->layno;		/* quality layer value */
+
+	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+	
+	opj_bio_t *bio = NULL;	/* BIO component */
+
+	/* <SOP 0xff91> */
+	if ((tcp->csty & J3D_CP_CSTY_SOP)) {
+		sop = (unsigned char *) opj_malloc(6 * sizeof(unsigned char));
+		sop[0] = 255;
+		sop[1] = 145;
+		sop[2] = 0;
+		sop[3] = 4;
+		sop[4] = (volume_info) ? (volume_info->num % 65536) / 256 : (0 % 65536) / 256 ;
+		sop[5] = (volume_info) ? (volume_info->num % 65536) % 256 : (0 % 65536) % 256 ;
+		memcpy(c, sop, 6);
+		opj_free(sop);
+		c += 6;
+	} 
+	/* </SOP> */
+	
+	if (!layno) {
+		for (bandno = 0; bandno < res->numbands; bandno++) {
+			opj_tcd_band_t *band = &res->bands[bandno];
+			opj_tcd_precinct_t *prc = &band->precincts[precno];
+			tgt_reset(prc->incltree);
+			tgt_reset(prc->imsbtree);
+			for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				cblk->numpasses = 0;
+                tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
+			}
+		}
+	}
+		
+	bio = bio_create();
+	bio_init_enc(bio, c, len);
+	bio_write(bio, 1, 1);		/* Empty header bit */
+	
+	/* Writing Packet header */
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			if (!cblk->numpasses && layer->numpasses) {
+                tgt_setvalue(prc->incltree, cblkno, layno);
+			}
+		}
+
+		for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			int increment = 0;
+			int nump = 0;
+			int len = 0, passno;
+			/* cblk inclusion bits */
+			if (!cblk->numpasses) {
+				tgt_encode(bio, prc->incltree, cblkno, layno + 1);
+			} else {
+				bio_write(bio, layer->numpasses != 0, 1);
+			}
+			/* if cblk not included, go to the next cblk  */
+			if (!layer->numpasses) {
+				continue;
+			}
+			/* if first instance of cblk --> zero bit-planes information */
+			if (!cblk->numpasses) {
+				cblk->numlenbits = 3;
+				tgt_encode(bio, prc->imsbtree, cblkno, 999);
+			}
+			/* number of coding passes included */
+			t2_putnumpasses(bio, layer->numpasses);
+			
+			/* computation of the increase of the length indicator and insertion in the header     */
+			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
+				opj_tcd_pass_t *pass = &cblk->passes[passno];
+				nump++;
+				len += pass->len;
+				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+					increment = int_max(increment, int_floorlog2(len) + 1 - (cblk->numlenbits + int_floorlog2(nump)));
+					len = 0;
+					nump = 0;
+				}
+			}
+			t2_putcommacode(bio, increment);
+
+			/* computation of the new Length indicator */
+			cblk->numlenbits += increment;
+
+			/* insertion of the codeword segment length */
+			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
+				opj_tcd_pass_t *pass = &cblk->passes[passno];
+				nump++;
+				len += pass->len;
+				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+					bio_write(bio, len, cblk->numlenbits + int_floorlog2(nump));
+					len = 0;
+					nump = 0;
+				}
+			}
+
+		}
+	}
+	
+	
+	if (bio_flush(bio)) {
+		return -999;		/* modified to eliminate longjmp !! */
+	}
+	
+	c += bio_numbytes(bio);
+
+	bio_destroy(bio);
+	
+	/* <EPH 0xff92> */
+	if (tcp->csty & J3D_CP_CSTY_EPH) {
+		eph = (unsigned char *) opj_malloc(2 * sizeof(unsigned char));
+		eph[0] = 255;
+		eph[1] = 146;
+		memcpy(c, eph, 2);
+		opj_free(eph);
+		c += 2;
+	}
+	/* </EPH> */
+	
+	/* Writing the packet body */
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			if (!layer->numpasses) {
+				continue;
+			}
+			if (c + layer->len > dest + len) {
+				return -999;
+			}
+			
+			memcpy(c, layer->data, layer->len);
+			cblk->numpasses += layer->numpasses;
+			c += layer->len;
+			/* ADD for index Cfr. Marcela --> delta disto by packet */
+			if(volume_info && volume_info->index_write && volume_info->index_on) {
+				opj_tile_info_t *info_TL = &volume_info->tile[tileno];
+				opj_packet_info_t *info_PK = &info_TL->packet[volume_info->num];
+				info_PK->disto += layer->disto;
+				if (volume_info->D_max < info_PK->disto) {
+					volume_info->D_max = info_PK->disto;
+				}
+			}
+			/* </ADD> */
+		}
+	}
+	
+	return (c - dest);
+}
+
+static void t2_init_seg(opj_tcd_seg_t * seg, int cblksty, int first) {
+	seg->numpasses = 0;
+	seg->len = 0;
+	if (cblksty & J3D_CCP_CBLKSTY_TERMALL) {
+		seg->maxpasses = 1;
+	}
+	else if (cblksty & J3D_CCP_CBLKSTY_LAZY) {
+		if (first) {
+			seg->maxpasses = 10;
+		} else {
+			seg->maxpasses = (((seg - 1)->maxpasses == 1) || ((seg - 1)->maxpasses == 10)) ? 2 : 1;
+		}
+	} else {
+		seg->maxpasses = 109;
+	}
+}
+
+int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi) {
+	int bandno, cblkno;
+	unsigned char *c = src;
+
+	opj_cp_t *cp = t2->cp;
+
+	int compno = pi->compno;	/* component value */
+	int resno  = pi->resno;		/* resolution level value */
+	int precno = pi->precno;	/* precinct value */
+	int layno  = pi->layno;		/* quality layer value */
+
+	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+	
+	unsigned char *hd = NULL;
+	int present;
+	
+	opj_bio_t *bio = NULL;	/* BIO component */
+	
+	if (layno == 0) {
+		for (bandno = 0; bandno < res->numbands; bandno++) {
+			opj_tcd_band_t *band = &res->bands[bandno];
+			opj_tcd_precinct_t *prc = &band->precincts[precno];
+			
+			if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)||(band->z1-band->z0 == 0)) continue;
+
+			tgt_reset(prc->incltree);
+			tgt_reset(prc->imsbtree);
+			for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				cblk->numsegs = 0;
+			}
+		}
+	}
+	
+	/* SOP markers */
+	
+	if (tcp->csty & J3D_CP_CSTY_SOP) {
+		if ((*c) != 0xff || (*(c + 1) != 0x91)) {
+			opj_event_msg(t2->cinfo, EVT_WARNING, "Expected SOP marker\n");
+		} else {
+			c += 6;
+		}
+		
+		/** TODO : check the Nsop value */
+	}
+	
+	/* 
+	When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
+	This part deal with this caracteristic
+	step 1: Read packet header in the saved structure
+	step 2: Return to codestream for decoding 
+	*/
+
+	bio = bio_create();
+	
+	if (cp->ppm == 1) {		/* PPM */
+		hd = cp->ppm_data;
+		bio_init_dec(bio, hd, cp->ppm_len);
+	} else if (tcp->ppt == 1) {	/* PPT */
+		hd = tcp->ppt_data;
+		bio_init_dec(bio, hd, tcp->ppt_len);
+	} else {			/* Normal Case */
+		hd = c;
+		bio_init_dec(bio, hd, src+len-hd);
+	}
+	
+	present = bio_read(bio, 1);
+	
+	if (!present) {
+		bio_inalign(bio);
+		hd += bio_numbytes(bio);
+		bio_destroy(bio);
+		
+		/* EPH markers */
+		
+		if (tcp->csty & J3D_CP_CSTY_EPH) {
+			if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
+				printf("Error : expected EPH marker\n");
+			} else {
+				hd += 2;
+			}
+		}
+		
+		if (cp->ppm == 1) {		/* PPM case */
+			cp->ppm_len += cp->ppm_data-hd;
+			cp->ppm_data = hd;
+			return (c - src);
+		}
+		if (tcp->ppt == 1) {	/* PPT case */
+			tcp->ppt_len+=tcp->ppt_data-hd;
+			tcp->ppt_data = hd;
+			return (c - src);
+		}
+		
+		return (hd - src);
+	}
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		
+		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)||(band->z1-band->z0 == 0)) continue;
+		
+		for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+			int included, increment, n;
+			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_seg_t *seg = NULL;
+			/* if cblk not yet included before --> inclusion tagtree */
+			if (!cblk->numsegs) {
+                included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
+				/* else one bit */
+			} else {
+				included = bio_read(bio, 1);
+			}
+			/* if cblk not included */
+			if (!included) {
+				cblk->numnewpasses = 0;
+				continue;
+			}
+			/* if cblk not yet included --> zero-bitplane tagtree */
+			if (!cblk->numsegs) {
+				int i, numimsbs;
+				for (i = 0; !tgt_decode(bio, prc->imsbtree, cblkno, i); i++);
+				numimsbs = i - 1;
+				cblk->numbps = band->numbps - numimsbs;
+				cblk->numlenbits = 3;
+			}
+			/* number of coding passes */
+			cblk->numnewpasses = t2_getnumpasses(bio);
+			increment = t2_getcommacode(bio);
+			/* length indicator increment */
+			cblk->numlenbits += increment;
+			if (!cblk->numsegs) {
+				seg = &cblk->segs[0];
+				t2_init_seg(seg, tcp->tccps[compno].cblksty, 1);
+			} else {
+				seg = &cblk->segs[cblk->numsegs - 1];
+				if (seg->numpasses == seg->maxpasses) {
+					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+				}
+			}
+			n = cblk->numnewpasses;
+			
+			do {
+				seg->numnewpasses = int_min(seg->maxpasses - seg->numpasses, n);
+				seg->newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(seg->numnewpasses));
+				n -= seg->numnewpasses;
+				if (n > 0) {
+					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+				}
+			} while (n > 0);
+		}
+	}
+	
+	if (bio_inalign(bio)) {
+		bio_destroy(bio);
+		return -999;
+	}
+	
+	hd += bio_numbytes(bio);
+	bio_destroy(bio);
+	
+	/* EPH markers */
+	if (tcp->csty & J3D_CP_CSTY_EPH) {
+		if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
+			opj_event_msg(t2->cinfo, EVT_ERROR, "Expected EPH marker\n");
+		} else {
+			hd += 2;
+		}
+	}
+	
+	if (cp->ppm==1) {
+		cp->ppm_len+=cp->ppm_data-hd;
+		cp->ppm_data = hd;
+	} else if (tcp->ppt == 1) {
+		tcp->ppt_len+=tcp->ppt_data-hd;
+		tcp->ppt_data = hd;
+	} else {
+		c=hd;
+	}
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		
+		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)||(band->z1-band->z0 == 0)) continue;		
+
+		for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_seg_t *seg = NULL;
+			if (!cblk->numnewpasses)
+				continue;
+			if (!cblk->numsegs) {
+				seg = &cblk->segs[0];
+				cblk->numsegs++;
+				cblk->len = 0;
+			} else {
+				seg = &cblk->segs[cblk->numsegs - 1];
+				if (seg->numpasses == seg->maxpasses) {
+					seg++;
+					cblk->numsegs++;
+				}
+			}
+			
+			do {
+				if (c + seg->newlen > src + len) {
+					return -999;
+				}
+				
+				memcpy(cblk->data + cblk->len, c, seg->newlen);
+				if (seg->numpasses == 0) {
+					seg->data = cblk->data + cblk->len;
+				}
+				c += seg->newlen;
+				cblk->len += seg->newlen;
+				seg->len += seg->newlen;
+				seg->numpasses += seg->numnewpasses;
+				cblk->numnewpasses -= seg->numnewpasses;
+				if (cblk->numnewpasses > 0) {
+					seg++;
+					cblk->numsegs++;
+				}
+			} while (cblk->numnewpasses > 0);
+		}
+	}
+	
+	return (c - src);
+}
+
+/* ----------------------------------------------------------------------- */
+
+int t2_encode_packets(opj_t2_t* t2, int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_volume_info_t *volume_info) {
+	unsigned char *c = dest;
+	int e = 0;
+	opj_pi_iterator_t *pi = NULL;
+	int pino;
+
+	opj_volume_t *volume = t2->volume;
+	opj_cp_t *cp = t2->cp;
+	
+	/* create a packet iterator */
+	pi = pi_create(volume, cp, tileno);
+	if(!pi) {
+		fprintf(stdout,"[ERROR] Failed to create a pi structure\n");
+		return -999;
+	}
+	
+	if(volume_info) {
+		volume_info->num = 0;
+	}
+	
+	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
+		while (pi_next(&pi[pino])) {
+			if (pi[pino].layno < maxlayers) {
+				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, volume_info, tileno, cp);
+				//opj_event_msg(t2->cinfo, EVT_INFO, "  t2_encode_packet: %d bytes coded\n",e);
+				if (e == -999) {
+					break;
+				} else {
+					c += e;
+				}
+				
+				/* INDEX >> */
+				if(volume_info && volume_info->index_on) {
+					if(volume_info->index_write) {
+						opj_tile_info_t *info_TL = &volume_info->tile[tileno];
+						opj_packet_info_t *info_PK = &info_TL->packet[volume_info->num];
+						if (!volume_info->num) {
+							info_PK->start_pos = info_TL->end_header + 1;
+						} else {
+							info_PK->start_pos = info_TL->packet[volume_info->num - 1].end_pos + 1;
+						}
+						info_PK->end_pos = info_PK->start_pos + e - 1;
+					}
+
+					volume_info->num++;
+				}
+				/* << INDEX */
+			}
+		}
+	}
+
+	/* don't forget to release pi */
+	pi_destroy(pi, cp, tileno);
+	
+	if (e == -999) {
+		return e;
+	}
+
+    return (c - dest);
+}
+
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile) {
+	unsigned char *c = src;
+	opj_pi_iterator_t *pi;
+	int pino, e = 0;
+	int n = 0,i;
+
+	opj_volume_t *volume = t2->volume;
+	opj_cp_t *cp = t2->cp;
+	
+	/* create a packet iterator */
+	pi = pi_create(volume, cp, tileno);
+	if(!pi) {
+		/* TODO: throw an error */
+		return -999;
+	}
+	
+	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
+		while (pi_next(&pi[pino])) {
+			if ((cp->layer==0) || (cp->layer>=((pi[pino].layno)+1))) {
+				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino]);
+			} else {
+				e = 0;
+			}
+			
+			/* progression in resolution */
+			for (i = 0; i < 3; i++){
+                volume->comps[pi[pino].compno].resno_decoded[i] = (e > 0) ? int_max(pi[pino].resno, volume->comps[pi[pino].compno].resno_decoded[i]) : volume->comps[pi[pino].compno].resno_decoded[i];
+			}
+			n++;
+			
+			if (e == -999) {		/* ADD */
+				break;
+			} else {
+				opj_event_msg(t2->cinfo, EVT_INFO, "  t2_decode_packet: %d bytes decoded\n",e);
+				c += e;
+			}
+		}
+	}
+
+	/* don't forget to release pi */
+	pi_destroy(pi, cp, tileno);
+	
+	if (e == -999) {
+		return e;
+	}
+	
+    return (c - src);
+}
+
+/* ----------------------------------------------------------------------- */
+
+opj_t2_t* t2_create(opj_common_ptr cinfo, opj_volume_t *volume, opj_cp_t *cp) {
+	/* create the tcd structure */
+	opj_t2_t *t2 = (opj_t2_t*)opj_malloc(sizeof(opj_t2_t));
+	if(!t2) return NULL;
+	t2->cinfo = cinfo;
+	t2->volume = volume;
+	t2->cp = cp;
+
+	return t2;
+}
+
+void t2_destroy(opj_t2_t *t2) {
+	if(t2) {
+		opj_free(t2);
+	}
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t2.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/t2.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,101 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __T2_H
+#define __T2_H
+/**
+@file t2.h
+@brief Implementation of a tier-2 coding (packetization of code-block data) (T2)
+
+*/
+
+/** @defgroup T2 T2 - Implementation of a tier-2 coding */
+/*@{*/
+
+/**
+Tier-2 coding
+*/
+typedef struct opj_t2 {
+/** Codec context */
+	opj_common_ptr cinfo;	
+/** Encoding: pointer to the src volume. Decoding: pointer to the dst volume. */
+	opj_volume_t *volume;	
+/** Pointer to the volume coding parameters */
+	opj_cp_t *cp;			
+} opj_t2_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Encode the packets of a tile to a destination buffer
+@param t2 T2 handle
+@param tileno number of the tile encoded
+@param tile the tile for which to write the packets
+@param maxlayers maximum number of layers
+@param dest the destination buffer
+@param len the length of the destination buffer
+@param volume_info structure to create an index file
+@return Number of bytes written from packets
+*/
+int t2_encode_packets(opj_t2_t* t2, int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_volume_info_t *volume_info);
+
+/**
+Decode the packets of a tile from a source buffer
+@param t2 T2 handle
+@param src the source buffer
+@param len length of the source buffer
+@param tileno number that identifies the tile for which to decode the packets
+@param tile tile for which to decode the packets
+@return Number of bytes read from packets
+ */
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile);
+
+/**
+Create a T2 handle
+@param cinfo Codec context info
+@param volume Source or destination volume
+@param cp Volume coding parameters
+@return Returns a new T2 handle if successful, returns NULL otherwise
+*/
+opj_t2_t* t2_create(opj_common_ptr cinfo, opj_volume_t *volume, opj_cp_t *cp);
+/**
+Destroy a T2 handle
+@param t2 T2 handle to destroy
+*/
+void t2_destroy(opj_t2_t *t2);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __T2_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tcd.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/tcd.c.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,1738 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez, LPI-UVA, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_volume_t * vol) {
+	int tileno, compno, resno, bandno, precno, cblkno;
+
+	fprintf(fd, "volume {\n");
+	fprintf(fd, "  tw=%d, th=%d, tl=%d, x0=%d x1=%d y0=%d y1=%d z0=%d z1=%d\n", 
+		vol->tw, vol->th, vol->tl, tcd->volume->x0, tcd->volume->x1, tcd->volume->y0, tcd->volume->y1, tcd->volume->z0, tcd->volume->z1);
+
+	for (tileno = 0; tileno < vol->th * vol->tw * vol->tl; tileno++) {
+		opj_tcd_tile_t *tile = &tcd->tcd_volume->tiles[tileno];
+		fprintf(fd, "  tile {\n");
+		fprintf(fd, "    x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, numcomps=%d\n",
+			tile->x0, tile->y0, tile->z0, tile->x1, tile->y1, tile->z1, tile->numcomps);
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			fprintf(fd, "    tilecomp %d {\n",compno);
+			fprintf(fd,	"     x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, numresx=%d, numresy=%d, numresz=%d\n",
+				tilec->x0, tilec->y0, tilec->z0, tilec->x1, tilec->y1, tilec->z1, tilec->numresolution[0], tilec->numresolution[1], tilec->numresolution[2]);
+			for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+				fprintf(fd, "     res %d{\n",resno);
+				fprintf(fd,"      x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, pw=%d, ph=%d, pl=%d, numbands=%d\n",
+					res->x0, res->y0, res->z0, res->x1, res->y1, res->z1, res->prctno[0], res->prctno[1], res->prctno[2], res->numbands);
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					opj_tcd_band_t *band = &res->bands[bandno];
+					fprintf(fd, "       band %d{\n", bandno);
+					fprintf(fd,	"		 x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, stepsize=%f, numbps=%d\n",
+						band->x0, band->y0, band->z0, band->x1, band->y1, band->z1, band->stepsize, band->numbps);
+					for (precno = 0; precno < (res->prctno[0] * res->prctno[1] * res->prctno[2]); precno++) {
+						opj_tcd_precinct_t *prec = &band->precincts[precno];
+						fprintf(fd, "		  prec %d{\n",precno);
+						fprintf(fd,	"		   x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, cw=%d, ch=%d, cl=%d,\n",
+							prec->x0, prec->y0, prec->z0, prec->x1, prec->y1, prec->z1, prec->cblkno[0], prec->cblkno[1], prec->cblkno[2]);
+						for (cblkno = 0; cblkno < (prec->cblkno[0] * prec->cblkno[1] * prec->cblkno[2]); cblkno++) {
+							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
+							fprintf(fd, "		    cblk %d{\n",cblkno);
+							fprintf(fd,	"		     x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d\n", cblk->x0, cblk->y0, cblk->z0, cblk->x1, cblk->y1, cblk->z1);
+							fprintf(fd, "            }\n");
+						}
+						fprintf(fd, "          }\n");
+					}
+					fprintf(fd, "        }\n");
+				}
+				fprintf(fd, "      }\n");
+			}
+			fprintf(fd, "    }\n");
+		}
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+void tilec_dump(FILE *fd, opj_tcd_tilecomp_t *tilec) {
+
+	int i=0,k;
+	int datalen;
+	int *a;
+
+	fprintf(fd, "    tilecomp{\n");
+	fprintf(fd,	"     x0=%d, y0=%d, z0=%d, x1=%d, y1=%d, z1=%d, numresx=%d, numresy=%d, numresz=%d\n",
+		tilec->x0, tilec->y0, tilec->z0, tilec->x1, tilec->y1, tilec->z1, tilec->numresolution[0], tilec->numresolution[1], tilec->numresolution[2]);
+	fprintf(fd, "     data {\n");
+	datalen = (tilec->z1 - tilec->z0) * (tilec->y1 - tilec->y0) * (tilec->x1 - tilec->x0);
+	a = tilec->data;
+	for (k = 0; k < datalen; k++) {
+		if (!(k % tilec->x1)){
+			fprintf(fd, "\n");
+		}
+		if (!(k % (tilec->y1 * tilec->x1))){
+			fprintf(fd, "Slice %d\n",i++);
+		}
+		fprintf(fd," %d",a[k]);
+		
+		
+	}			
+	fprintf(fd, "     }\n");
+	/*i=0;
+	fprintf(fd, "Slice %d\n");
+	if (tilec->prediction->prederr) {
+		fprintf(fd, "     prederror {\n");
+		a = tilec->prediction->prederr;
+		for (k = 0; k < datalen; k++) {
+			fprintf(fd," %d",*(a++));
+			if (!(k % (tilec->y1 - tilec->y0) * (tilec->x1 - tilec->x0))){
+				fprintf(fd, "\n");fprintf(fd, "Slice %d\n",i++);
+			}
+			if (!(k % (tilec->x1 - tilec->x0))){
+				fprintf(fd, "\n");
+			}
+		}
+	}
+	fprintf(fd, "     }\n");*/
+	fprintf(fd, "}\n");
+}
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Create a new TCD handle
+*/
+opj_tcd_t* tcd_create(opj_common_ptr cinfo) {
+	/* create the tcd structure */
+	opj_tcd_t *tcd = (opj_tcd_t*)opj_malloc(sizeof(opj_tcd_t));
+	if(!tcd) return NULL;
+	tcd->cinfo = cinfo;
+	tcd->tcd_volume = (opj_tcd_volume_t*)opj_malloc(sizeof(opj_tcd_volume_t));
+	if(!tcd->tcd_volume) {
+		opj_free(tcd);
+		return NULL;
+	}
+
+	return tcd;
+}
+
+/**
+Destroy a previously created TCD handle
+*/
+void tcd_destroy(opj_tcd_t *tcd) {
+	if(tcd) {
+		opj_free(tcd->tcd_volume);
+		opj_free(tcd);
+	}
+}
+
+/* ----------------------------------------------------------------------- */
+void tcd_malloc_encode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp, int curtileno) {
+	int compno, resno, bandno, precno, cblkno, i, j;//, k;
+
+	opj_tcd_tile_t		*tile = NULL;		/* pointer to tcd->tile */
+	opj_tcd_tilecomp_t	*tilec = NULL;		/* pointer to tcd->tilec */
+	opj_tcd_resolution_t	*res = NULL;		/* pointer to tcd->res */
+	opj_tcd_band_t		*band = NULL;		/* pointer to tcd->band */
+	opj_tcd_precinct_t	*prc = NULL;		/* pointer to tcd->prc */
+	opj_tcd_cblk_t		*cblk = NULL;		/* pointer to tcd->cblk */
+	opj_tcp_t		*tcp = &cp->tcps[curtileno];
+	int p,q,r;
+
+	tcd->volume = volume;
+	tcd->cp = cp;
+	tcd->tcd_volume->tw = cp->tw;
+	tcd->tcd_volume->th = cp->th;
+	tcd->tcd_volume->tl = cp->tl;
+	tcd->tcd_volume->tiles = (opj_tcd_tile_t *) opj_malloc(sizeof(opj_tcd_tile_t));
+	tcd->tile = tcd->tcd_volume->tiles;
+	tile = tcd->tile;
+	
+
+	/* p61 ISO/IEC IS15444-1 : 2002 */
+	/* curtileno --> raster scanned index of tiles */
+	/* p,q,r --> matricial index of tiles */
+	p = curtileno % cp->tw;	
+	q = curtileno / cp->tw;	
+	r = curtileno / (cp->tw * cp->th); /* extension to 3-D */
+
+	/* 4 borders of the tile rescale on the volume if necessary (B.3)*/
+	tile->x0 = int_max(cp->tx0 + p * cp->tdx, volume->x0);
+	tile->y0 = int_max(cp->ty0 + q * cp->tdy, volume->y0);
+	tile->z0 = int_max(cp->tz0 + r * cp->tdz, volume->z0);
+	tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, volume->x1);
+	tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, volume->y1);
+	tile->z1 = int_min(cp->tz0 + (r + 1) * cp->tdz, volume->z1);
+	tile->numcomps = volume->numcomps;
+
+	/* Modification of the RATE >> */
+	for (j = 0; j < tcp->numlayers; j++) {
+		if (tcp->rates[j] <= 1) {
+			tcp->rates[j] = 0;
+		} else {
+			float num = (float) (tile->numcomps * (tile->x1 - tile->x0) * (tile->y1 - tile->y0) * (tile->z1 - tile->z0) * volume->comps[0].prec);
+			float den = (float) (8 * volume->comps[0].dx * volume->comps[0].dy * volume->comps[0].dz);
+			den = tcp->rates[j] * den;
+			tcp->rates[j] = (num + den - 1) / den;
+		}
+		/*tcp->rates[j] = tcp->rates[j] ? int_ceildiv(
+			tile->numcomps * (tile->x1 - tile->x0) * (tile->y1 - tile->y0) * (tile->z1 - tile->z0) * volume->comps[0].prec,
+            (tcp->rates[j] * 8 * volume->comps[0].dx * volume->comps[0].dy * volume->comps[0].dz)) : 0;*/
+		if (tcp->rates[j]) {
+			if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
+				tcp->rates[j] = tcp->rates[j - 1] + 20;
+			} else if (!j && tcp->rates[j] < 30){
+				tcp->rates[j] = 30;
+			}
+		}
+	}
+	/* << Modification of the RATE */
+
+	tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(volume->numcomps * sizeof(opj_tcd_tilecomp_t));
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tccp_t *tccp = &tcp->tccps[compno];
+		int res_max;
+		int prevnumbands = 0;
+
+		/* opj_tcd_tilecomp_t *tilec=&tile->comps[compno]; */
+		tcd->tilec = &tile->comps[compno];
+		tilec = tcd->tilec;
+
+		/* border of each tile component (global) (B.3) */
+		tilec->x0 = int_ceildiv(tile->x0, volume->comps[compno].dx);
+		tilec->y0 = int_ceildiv(tile->y0, volume->comps[compno].dy);
+		tilec->z0 = int_ceildiv(tile->z0, volume->comps[compno].dz);
+		tilec->x1 = int_ceildiv(tile->x1, volume->comps[compno].dx);
+		tilec->y1 = int_ceildiv(tile->y1, volume->comps[compno].dy);
+		tilec->z1 = int_ceildiv(tile->z1, volume->comps[compno].dz);
+
+		tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * (tilec->z1 - tilec->z0) * sizeof(int));
+		
+		res_max = 0;
+		for (i = 0;i < 3; i++){
+			tilec->numresolution[i] = tccp->numresolution[i];
+			//Greater of 3 resolutions contains all information
+			res_max = (tilec->numresolution[i] > res_max) ? tilec->numresolution[i] : res_max;
+		}
+		
+
+		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(res_max * sizeof(opj_tcd_resolution_t));
+		for (resno = 0; resno < res_max; resno++) {
+			
+			int pdx, pdy, pdz;
+			int tlprcxstart, tlprcystart, tlprczstart;
+			int brprcxend, brprcyend, brprczend;
+			int tlcbgxstart, tlcbgystart, tlcbgzstart;
+			int brcbgxend, brcbgyend, brcbgzend;
+			int cbgwidthexpn, cbgheightexpn, cbglengthexpn;
+			int cblkwidthexpn, cblkheightexpn, cblklengthexpn;
+
+			int diff = tccp->numresolution[0] - tccp->numresolution[2]; 
+			int levelnox = tilec->numresolution[0] - 1 - resno; 
+			int levelnoy = tilec->numresolution[1] - 1 - resno;
+			int levelnoz = tilec->numresolution[2] - 1 - ((resno <= diff) ? 0 : (resno - diff));
+				if (levelnoz < 0) levelnoz = 0;
+
+			/* opj_tcd_resolution_t *res=&tilec->resolutions[resno]; */
+			tcd->res = &tilec->resolutions[resno];
+			res = tcd->res;
+			
+			/* border for each resolution level (global) (B.14)*/
+			res->x0 = int_ceildivpow2(tilec->x0, levelnox);
+			res->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+			res->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+			res->x1 = int_ceildivpow2(tilec->x1, levelnox);
+			res->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+			res->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+			//if (res->z1 < 0)fprintf(stdout,"Res: %d       %d/%d --> %d\n",resno,tilec->z1, levelnoz, int_ceildivpow2(tilec->z1, levelnoz));
+
+			res->numbands = (resno == 0) ? 1 : (resno <= diff) ? 3 : 7; /* --> 3D */
+
+			/* p. 30, table A-13, ISO/IEC IS154444-1 : 2002 */
+			if (tccp->csty & J3D_CCP_CSTY_PRT) {
+				pdx = tccp->prctsiz[0][resno];
+				pdy = tccp->prctsiz[1][resno];
+				pdz = tccp->prctsiz[2][resno];
+			} else {
+				pdx = 15;
+				pdy = 15;
+				pdz = 15;
+			}
+			
+			/* p. 66, B.16, ISO/IEC IS15444-1 : 2002  */
+			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+			tlprczstart = int_floordivpow2(res->z0, pdz) << pdz;
+			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+			brprczend = int_ceildivpow2(res->z1, pdz) << pdz;
+			
+			res->prctno[0] = (brprcxend - tlprcxstart) >> pdx;
+			res->prctno[1] = (brprcyend - tlprcystart) >> pdy;
+			res->prctno[2] = (brprczend - tlprczstart) >> pdz;
+				if (res->prctno[2] == 0) res->prctno[2] = 1;
+				
+			/* p. 67, B.17 & B.18, ISO/IEC IS15444-1 : 2002  */
+			if (resno == 0) {
+				tlcbgxstart = tlprcxstart;
+				tlcbgystart = tlprcystart;
+				tlcbgzstart = tlprczstart;
+				brcbgxend = brprcxend;
+				brcbgyend = brprcyend;
+				brcbgzend = brprczend;
+				cbgwidthexpn = pdx;
+				cbgheightexpn = pdy;
+				cbglengthexpn = pdz;
+			} else {
+				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+				tlcbgzstart = int_ceildivpow2(tlprczstart, 1);
+				brcbgxend = int_ceildivpow2(brprcxend, 1);
+				brcbgyend = int_ceildivpow2(brprcyend, 1);
+				brcbgzend = int_ceildivpow2(brprczend, 1);
+				cbgwidthexpn = pdx - 1;
+				cbgheightexpn = pdy - 1;
+				cbglengthexpn = pdz - 1;
+			}
+			
+			cblkwidthexpn = int_min(tccp->cblk[0], cbgwidthexpn); //6
+			cblkheightexpn = int_min(tccp->cblk[1], cbgheightexpn); //6
+			cblklengthexpn = int_min(tccp->cblk[2], cbglengthexpn); //6
+			
+			res->bands = (opj_tcd_band_t *) opj_malloc(res->numbands * sizeof(opj_tcd_band_t));
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				int x0b, y0b, z0b, i;
+				int gain, numbps;
+				opj_stepsize_t *ss = NULL;
+
+				tcd->band = &res->bands[bandno];
+				band = tcd->band;
+
+				band->bandno = (resno == 0) ? 0 : bandno + 1;
+				/* Bandno:	0 - LLL 	2 - LHL 
+							1 - HLL		3 - HHL
+							4 - LLH		6 - LHH
+							5 - HLH		7 - HHH		*/
+				x0b = (band->bandno == 1) || (band->bandno == 3) || (band->bandno == 5 ) || (band->bandno == 7 ) ? 1 : 0; 
+				y0b = (band->bandno == 2) || (band->bandno == 3) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0;
+				z0b = (band->bandno == 4) || (band->bandno == 5) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0; 
+				
+				/* p. 65, B.15, ISO/IEC IS15444-1 : 2002  */
+				if (band->bandno == 0) {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0, levelnox);
+					band->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+					band->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+					band->x1 = int_ceildivpow2(tilec->x1, levelnox);
+					band->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+					band->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+				} else {
+					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelnox) * x0b, levelnox + 1);
+					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelnoy) * y0b, levelnoy + 1);
+					band->z0 = int_ceildivpow2(tilec->z0 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelnox) * x0b, levelnox + 1);
+					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelnoy) * y0b, levelnoy + 1);
+					band->z1 = int_ceildivpow2(tilec->z1 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+				}
+				
+				ss = &tccp->stepsizes[(resno == 0) ? 0 : (prevnumbands + bandno + 1)];
+				if (bandno == (res->numbands - 1)) 
+					prevnumbands += (resno == 0) ? 0 : res->numbands;
+				gain = dwt_getgain(band->bandno,tccp->reversible);					
+				numbps = volume->comps[compno].prec + gain;
+ 				band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
+				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+				
+				band->precincts = (opj_tcd_precinct_t *) opj_malloc((res->prctno[0] * res->prctno[1] * res->prctno[2]) * sizeof(opj_tcd_precinct_t));
+				
+				for (i = 0; i < (res->prctno[0] * res->prctno[1] * res->prctno[2]); i++) {
+					band->precincts[i].imsbtree = NULL;
+					band->precincts[i].incltree = NULL;
+				}
+
+				for (precno = 0; precno < (res->prctno[0] * res->prctno[1] * res->prctno[2]); precno++) {
+					int tlcblkxstart, tlcblkystart, tlcblkzstart, brcblkxend, brcblkyend, brcblkzend;
+					int cbgxstart, cbgystart, cbgzstart, cbgxend, cbgyend, cbgzend;
+
+					cbgxstart = tlcbgxstart + (precno % res->prctno[0]) * (1 << cbgwidthexpn);
+					cbgystart = tlcbgystart + ((precno % (res->prctno[0] * res->prctno[1])) / res->prctno[0]) * (1 << cbgheightexpn);
+					cbgzstart = tlcbgzstart + (precno / (res->prctno[0] * res->prctno[1])) * (1 << cbglengthexpn);
+					cbgxend = cbgxstart + (1 << cbgwidthexpn);
+					cbgyend = cbgystart + (1 << cbgheightexpn);
+					cbgzend = cbgzstart + (1 << cbglengthexpn);
+					
+					tcd->prc = &band->precincts[precno];
+					prc = tcd->prc;
+
+					/* precinct size (global) */
+					prc->x0 = int_max(cbgxstart, band->x0);
+					prc->y0 = int_max(cbgystart, band->y0);
+					prc->z0 = int_max(cbgzstart, band->z0);
+					prc->x1 = int_min(cbgxend, band->x1);
+					prc->y1 = int_min(cbgyend, band->y1);
+					prc->z1 = int_min(cbgzend, band->z1);
+					
+					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+					tlcblkzstart = int_floordivpow2(prc->z0, cblklengthexpn) << cblklengthexpn;
+					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+					brcblkzend = int_ceildivpow2(prc->z1, cblklengthexpn) << cblklengthexpn;
+					prc->cblkno[0] = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+					prc->cblkno[1] = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+					prc->cblkno[2] = (brcblkzend - tlcblkzstart) >> cblklengthexpn;
+					prc->cblkno[2] = (prc->cblkno[2] == 0) ? 1 : prc->cblkno[2];
+
+					prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]) * sizeof(opj_tcd_cblk_t));
+					prc->incltree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+					prc->imsbtree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+					//tgt_tree_dump(stdout,prc->incltree);
+					for (cblkno = 0; cblkno < (prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]); cblkno++) {
+						int cblkxstart = tlcblkxstart + (cblkno % prc->cblkno[0]) * (1 << cblkwidthexpn);
+						int cblkystart = tlcblkystart + ((cblkno % (prc->cblkno[0] * prc->cblkno[1])) / prc->cblkno[0]) * (1 << cblkheightexpn);
+						int cblkzstart = tlcblkzstart + (cblkno / (prc->cblkno[0] * prc->cblkno[1])) * (1 << cblklengthexpn);
+						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+						int cblkyend = cblkystart + (1 << cblkheightexpn);
+						int cblkzend = cblkzstart + (1 << cblklengthexpn);
+						int prec = ((tilec->bpp > 16) ? 3 : ((tilec->bpp > 8) ? 2 : 1));
+						
+						tcd->cblk = &prc->cblks[cblkno];
+						cblk = tcd->cblk;
+
+						/* code-block size (global) */
+						cblk->x0 = int_max(cblkxstart, prc->x0);
+						cblk->y0 = int_max(cblkystart, prc->y0);
+						cblk->z0 = int_max(cblkzstart, prc->z0);
+						cblk->x1 = int_min(cblkxend, prc->x1);
+						cblk->y1 = int_min(cblkyend, prc->y1);
+						cblk->z1 = int_min(cblkzend, prc->z1);
+					}					
+				}
+			}
+		}
+	}
+	//tcd_dump(stdout, tcd, tcd->tcd_volume);
+
+}
+void tcd_init_encode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp, int curtileno) {
+	int compno, resno, bandno, precno, cblkno;
+	int j, p, q, r;
+
+	opj_tcd_tile_t		*tile = NULL;		/* pointer to tcd->tile */
+	opj_tcd_tilecomp_t	*tilec = NULL;		/* pointer to tcd->tilec */
+	opj_tcd_resolution_t	*res = NULL;	/* pointer to tcd->res */
+	opj_tcd_band_t		*band = NULL;		/* pointer to tcd->band */
+	opj_tcd_precinct_t	*prc = NULL;		/* pointer to tcd->prc */
+	opj_tcd_cblk_t		*cblk = NULL;		/* pointer to tcd->cblk */
+	opj_tcp_t *tcp = &cp->tcps[curtileno];
+
+	tcd->tile = tcd->tcd_volume->tiles;
+	tile = tcd->tile;
+
+	/* p61 ISO/IEC IS15444-1 : 2002 */
+	/* curtileno --> raster scanned index of tiles */
+	/* p,q,r --> matricial index of tiles */
+	p = curtileno % cp->tw;	
+	q = curtileno / cp->tw;	
+	r = curtileno / (cp->tw * cp->th); /* extension to 3-D */
+	
+	/* 4 borders of the tile rescale on the volume if necessary (B.3)*/
+	tile->x0 = int_max(cp->tx0 + p * cp->tdx, volume->x0);
+	tile->y0 = int_max(cp->ty0 + q * cp->tdy, volume->y0);
+	tile->z0 = int_max(cp->tz0 + r * cp->tdz, volume->z0);
+	tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, volume->x1);
+	tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, volume->y1);
+	tile->z1 = int_min(cp->tz0 + (r + 1) * cp->tdz, volume->z1);
+	tile->numcomps = volume->numcomps;
+
+	/* Modification of the RATE >> */
+	for (j = 0; j < tcp->numlayers; j++) {
+		if (tcp->rates[j] <= 1) {
+			tcp->rates[j] = 0;
+		} else {
+			float num = (float) (tile->numcomps * (tile->x1 - tile->x0) * (tile->y1 - tile->y0) * (tile->z1 - tile->z0) * volume->comps[0].prec);
+			float den = (float) (8 * volume->comps[0].dx * volume->comps[0].dy * volume->comps[0].dz);
+			den = tcp->rates[j] * den;
+			tcp->rates[j] = (num + den - 1) / den;
+		}
+		/*tcp->rates[j] = tcp->rates[j] ? int_ceildiv(
+			tile->numcomps * (tile->x1 - tile->x0) * (tile->y1 - tile->y0) * (tile->z1 - tile->z0) * volume->comps[0].prec,
+            (tcp->rates[j] * 8 * volume->comps[0].dx * volume->comps[0].dy * volume->comps[0].dz)) : 0;*/
+		if (tcp->rates[j]) {
+			if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
+				tcp->rates[j] = tcp->rates[j - 1] + 20;
+			} else if (!j && tcp->rates[j] < 30){
+				tcp->rates[j] = 30;
+			}
+		}
+	}
+	/* << Modification of the RATE */
+
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tccp_t *tccp = &tcp->tccps[compno];
+		int res_max, i;
+		int prevnumbands = 0;
+
+		/* opj_tcd_tilecomp_t *tilec=&tile->comps[compno]; */
+		tcd->tilec = &tile->comps[compno];
+		tilec = tcd->tilec;
+
+		/* border of each tile component (global) (B.3) */
+		tilec->x0 = int_ceildiv(tile->x0, volume->comps[compno].dx);
+		tilec->y0 = int_ceildiv(tile->y0, volume->comps[compno].dy);
+		tilec->z0 = int_ceildiv(tile->z0, volume->comps[compno].dz);
+		tilec->x1 = int_ceildiv(tile->x1, volume->comps[compno].dx);
+		tilec->y1 = int_ceildiv(tile->y1, volume->comps[compno].dy);
+		tilec->z1 = int_ceildiv(tile->z1, volume->comps[compno].dz);
+
+		tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * (tilec->z1 - tilec->z0) * sizeof(int));
+		
+		res_max = 0;
+		for (i = 0;i < 3; i++){
+			tilec->numresolution[i] = tccp->numresolution[i];
+			//Greater of 3 resolutions contains all information
+			res_max = (tilec->numresolution[i] > res_max) ? tilec->numresolution[i] : res_max;
+		}
+
+		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(res_max * sizeof(opj_tcd_resolution_t));
+		for (resno = 0; resno < res_max; resno++) {
+			int pdx, pdy, pdz;
+			int tlprcxstart, tlprcystart, tlprczstart, brprcxend, brprcyend, brprczend;
+			int tlcbgxstart, tlcbgystart, tlcbgzstart, brcbgxend, brcbgyend, brcbgzend;
+			int cbgwidthexpn, cbgheightexpn, cbglengthexpn;
+			int cblkwidthexpn, cblkheightexpn, cblklengthexpn;
+			
+			int levelnox = tilec->numresolution[0] - 1 - resno; 
+			int levelnoy = tilec->numresolution[1] - 1 - resno;
+			int diff = tccp->numresolution[0] - tccp->numresolution[2]; 
+			int levelnoz = tilec->numresolution[2] - 1 - ((resno <= diff) ? 0 : (resno - diff));
+				if (levelnoz < 0) levelnoz = 0;
+
+			tcd->res = &tilec->resolutions[resno];
+			res = tcd->res;
+			
+			/* border for each resolution level (global) (B.14)*/
+			res->x0 = int_ceildivpow2(tilec->x0, levelnox);
+			res->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+			res->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+			res->x1 = int_ceildivpow2(tilec->x1, levelnox);
+			res->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+			res->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+
+			// res->numbands = resno == 0 ? 1 : 3; /* --> 2D */
+			res->numbands = (resno == 0) ? 1 : (resno <= diff) ? 3 : 7; /* --> 3D */
+
+			/* p. 30, table A-13, ISO/IEC IS154444-1 : 2002 */			
+			if (tccp->csty & J3D_CCP_CSTY_PRT) {
+				pdx = tccp->prctsiz[0][resno];
+				pdy = tccp->prctsiz[1][resno];
+				pdz = tccp->prctsiz[2][resno];
+			} else {
+				pdx = 15;
+				pdy = 15;
+				pdz = 15;
+			}
+			/* p. 66, B.16, ISO/IEC IS15444-1 : 2002  */
+			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+			tlprczstart = int_floordivpow2(res->z0, pdz) << pdz;
+			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+			brprczend = int_ceildivpow2(res->z1, pdz) << pdz;
+			
+			res->prctno[0] = (brprcxend - tlprcxstart) >> pdx;
+			res->prctno[1] = (brprcyend - tlprcystart) >> pdy;
+			res->prctno[2] = (brprczend - tlprczstart) >> pdz;
+			if (res->prctno[2] == 0) res->prctno[2] = 1;
+
+			/* p. 67, B.17 & B.18, ISO/IEC IS15444-1 : 2002  */
+			if (resno == 0) {
+				tlcbgxstart = tlprcxstart;
+				tlcbgystart = tlprcystart;
+				tlcbgzstart = tlprczstart;
+				brcbgxend = brprcxend;
+				brcbgyend = brprcyend;
+				brcbgzend = brprczend;
+				cbgwidthexpn = pdx;
+				cbgheightexpn = pdy;
+				cbglengthexpn = pdz;
+			} else {
+				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+				tlcbgzstart = int_ceildivpow2(tlprczstart, 1);
+				brcbgxend = int_ceildivpow2(brprcxend, 1);
+				brcbgyend = int_ceildivpow2(brprcyend, 1);
+				brcbgzend = int_ceildivpow2(brprczend, 1);
+				cbgwidthexpn = pdx - 1;
+				cbgheightexpn = pdy - 1;
+				cbglengthexpn = pdz - 1;
+			}
+			
+			cblkwidthexpn = int_min(tccp->cblk[0], cbgwidthexpn);
+			cblkheightexpn = int_min(tccp->cblk[1], cbgheightexpn);
+			cblklengthexpn = int_min(tccp->cblk[2], cbglengthexpn);
+			
+			res->bands = (opj_tcd_band_t *) opj_malloc(res->numbands * sizeof(opj_tcd_band_t));
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				int x0b, y0b, z0b;
+				int gain, numbps;
+				opj_stepsize_t *ss = NULL;
+
+				tcd->band = &res->bands[bandno];
+				band = tcd->band;
+
+				band->bandno = resno == 0 ? 0 : bandno + 1;
+				/* Bandno:	0 - LLL 	2 - LHL 
+							1 - HLL		3 - HHL
+							4 - LLH		6 - LHH
+							5 - HLH		7 - HHH		*/
+				x0b = (band->bandno == 1) || (band->bandno == 3) || (band->bandno == 5 ) || (band->bandno == 7 ) ? 1 : 0; 
+				y0b = (band->bandno == 2) || (band->bandno == 3) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0;
+				z0b = (band->bandno == 4) || (band->bandno == 5) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0; 
+				
+				/* p. 65, B.15, ISO/IEC IS15444-1 : 2002  */
+				if (band->bandno == 0) {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0, levelnox);
+					band->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+					band->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+					band->x1 = int_ceildivpow2(tilec->x1, levelnox);
+					band->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+					band->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+				} else {
+					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelnox) * x0b, levelnox + 1);
+					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelnoy) * y0b, levelnoy + 1);
+					band->z0 = int_ceildivpow2(tilec->z0 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelnox) * x0b, levelnox + 1);
+					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelnoy) * y0b, levelnoy + 1);
+					band->z1 = int_ceildivpow2(tilec->z1 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+				}
+								
+				ss = &tccp->stepsizes[(resno == 0) ? 0 : (prevnumbands + bandno + 1)];
+				if (bandno == (res->numbands - 1)) 
+					prevnumbands += (resno == 0) ? 0 : res->numbands;
+				gain = dwt_getgain(band->bandno,tccp->reversible);					
+				numbps = volume->comps[compno].prec + gain;
+				
+				band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
+				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+				
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					int tlcblkxstart, tlcblkystart, tlcblkzstart, brcblkxend, brcblkyend, brcblkzend;
+
+					int cbgxstart = tlcbgxstart + (precno % res->prctno[0]) * (1 << cbgwidthexpn);
+					int cbgystart = tlcbgystart + ((precno / (res->prctno[0] * res->prctno[1])) / res->prctno[0]) * (1 << cbgheightexpn);
+					int cbgzstart = tlcbgzstart + (precno / (res->prctno[0] * res->prctno[1])) * (1 << cbglengthexpn);
+					int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+					int cbgyend = cbgystart + (1 << cbgheightexpn);
+					int cbgzend = cbgzstart + (1 << cbglengthexpn);
+
+					/* opj_tcd_precinct_t *prc=&band->precincts[precno]; */
+					tcd->prc = &band->precincts[precno];
+					prc = tcd->prc;
+
+					/* precinct size (global) */
+					prc->x0 = int_max(cbgxstart, band->x0);
+					prc->y0 = int_max(cbgystart, band->y0);
+					prc->z0 = int_max(cbgzstart, band->z0);
+					prc->x1 = int_min(cbgxend, band->x1);
+					prc->y1 = int_min(cbgyend, band->y1);
+					prc->z1 = int_min(cbgzend, band->z1);
+
+					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+					tlcblkzstart = int_floordivpow2(prc->z0, cblklengthexpn) << cblklengthexpn;
+					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+					brcblkzend = int_ceildivpow2(prc->z1, cblklengthexpn) << cblklengthexpn;
+					prc->cblkno[0] = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+					prc->cblkno[1] = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+					prc->cblkno[2] = (brcblkzend - tlcblkzstart) >> cblklengthexpn;
+					prc->cblkno[2] = (prc->cblkno[2] == 0) ? 1 : prc->cblkno[2];
+
+					opj_free(prc->cblks);
+					prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]) * sizeof(opj_tcd_cblk_t));
+					prc->incltree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+					prc->imsbtree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+
+					for (cblkno = 0; cblkno < (prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]); cblkno++) {
+							int cblkxstart = tlcblkxstart + (cblkno % prc->cblkno[0]) * (1 << cblkwidthexpn);
+							int cblkystart = tlcblkystart + ((cblkno % (prc->cblkno[0] * prc->cblkno[1])) / prc->cblkno[0]) * (1 << cblkheightexpn);
+							int cblkzstart = tlcblkzstart + (cblkno / (prc->cblkno[0] * prc->cblkno[1])) * (1 << cblklengthexpn);
+							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+							int cblkyend = cblkystart + (1 << cblkheightexpn);
+							int cblkzend = cblkzstart + (1 << cblklengthexpn);
+							int prec = ((tilec->bpp > 16) ? 3 : ((tilec->bpp > 8) ? 2 : 1));
+
+							tcd->cblk = &prc->cblks[cblkno];
+							cblk = tcd->cblk;
+
+							/* code-block size (global) */
+							cblk->x0 = int_max(cblkxstart, prc->x0);
+							cblk->y0 = int_max(cblkystart, prc->y0);
+							cblk->z0 = int_max(cblkzstart, prc->z0);
+							cblk->x1 = int_min(cblkxend, prc->x1);
+							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->z1 = int_min(cblkzend, prc->z1);
+					}
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
+	//tcd_dump(stdout, tcd, tcd->tcd_volume);
+}
+
+
+void tcd_free_encode(opj_tcd_t *tcd) {
+	int tileno, compno, resno, bandno, precno;
+
+	opj_tcd_tile_t *tile = NULL;		/* pointer to tcd->tile		*/
+//	opj_tcd_slice_t *slice = NULL;		/* pointer to tcd->slice */
+	opj_tcd_tilecomp_t *tilec = NULL;	/* pointer to tcd->tilec	*/
+	opj_tcd_resolution_t *res = NULL;	/* pointer to tcd->res		*/
+	opj_tcd_band_t *band = NULL;		/* pointer to tcd->band		*/
+	opj_tcd_precinct_t *prc = NULL;		/* pointer to tcd->prc		*/
+
+	for (tileno = 0; tileno < 1; tileno++) {
+		tcd->tile = tcd->tcd_volume->tiles;
+		tile = tcd->tile;
+
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			tcd->tilec = &tile->comps[compno];
+			tilec = tcd->tilec;
+
+			for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+				tcd->res = &tilec->resolutions[resno];
+				res = tcd->res;
+
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					tcd->band = &res->bands[bandno];
+					band = tcd->band;
+
+					for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+						tcd->prc = &band->precincts[precno];
+						prc = tcd->prc;
+
+						if (prc->incltree != NULL) {
+                            tgt_destroy(prc->incltree);
+                            prc->incltree = NULL;
+						}
+						if (prc->imsbtree != NULL) {
+                            tgt_destroy(prc->imsbtree);
+                            prc->imsbtree = NULL;
+						}
+						opj_free(prc->cblks);
+						prc->cblks = NULL;
+					} /* for (precno */
+					opj_free(band->precincts);
+					band->precincts = NULL;
+				} /* for (bandno */
+			} /* for (resno */
+			opj_free(tilec->resolutions);
+			tilec->resolutions = NULL;
+		} /* for (compno */
+		opj_free(tile->comps);
+		tile->comps = NULL;
+	} /* for (tileno */
+	opj_free(tcd->tcd_volume->tiles);
+	tcd->tcd_volume->tiles = NULL;
+}
+
+/* ----------------------------------------------------------------------- */
+void tcd_malloc_decode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp) {
+	int tileno, compno, resno, bandno, precno, cblkno, res_max,
+		i, j, p, q, r;
+	unsigned int x0 = 0, y0 = 0, z0 = 0, 
+		x1 = 0, y1 = 0, z1 = 0, 
+		w, h, l;
+
+	tcd->volume = volume;
+	tcd->cp = cp;
+	tcd->tcd_volume->tw = cp->tw;
+	tcd->tcd_volume->th = cp->th;
+	tcd->tcd_volume->tl = cp->tl;
+	tcd->tcd_volume->tiles = (opj_tcd_tile_t *) opj_malloc(cp->tw * cp->th * cp->tl * sizeof(opj_tcd_tile_t));
+	
+	for (i = 0; i < cp->tileno_size; i++) {
+		opj_tcp_t *tcp = &(cp->tcps[cp->tileno[i]]);
+		opj_tcd_tile_t *tile = &(tcd->tcd_volume->tiles[cp->tileno[i]]);
+	
+		/* p61 ISO/IEC IS15444-1 : 2002 */
+		/* curtileno --> raster scanned index of tiles */
+		/* p,q,r --> matricial index of tiles */
+		tileno = cp->tileno[i];
+		p = tileno % cp->tw;	
+		q = tileno / cp->tw;	
+		r = tileno / (cp->tw * cp->th); /* extension to 3-D */
+
+		/* 4 borders of the tile rescale on the volume if necessary (B.3)*/
+		tile->x0 = int_max(cp->tx0 + p * cp->tdx, volume->x0);
+		tile->y0 = int_max(cp->ty0 + q * cp->tdy, volume->y0);
+		tile->z0 = int_max(cp->tz0 + r * cp->tdz, volume->z0);
+		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, volume->x1);
+		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, volume->y1);
+		tile->z1 = int_min(cp->tz0 + (r + 1) * cp->tdz, volume->z1);
+		tile->numcomps = volume->numcomps;		
+		
+		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(volume->numcomps * sizeof(opj_tcd_tilecomp_t));
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			int prevnumbands = 0;
+
+			/* border of each tile component (global) */
+			tilec->x0 = int_ceildiv(tile->x0, volume->comps[compno].dx);
+			tilec->y0 = int_ceildiv(tile->y0, volume->comps[compno].dy);
+			tilec->z0 = int_ceildiv(tile->z0, volume->comps[compno].dz);
+			tilec->x1 = int_ceildiv(tile->x1, volume->comps[compno].dx);
+			tilec->y1 = int_ceildiv(tile->y1, volume->comps[compno].dy);
+			tilec->z1 = int_ceildiv(tile->z1, volume->comps[compno].dz);
+			
+			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * (tilec->z1 - tilec->z0) * sizeof(int));
+
+			res_max = 0;
+			for (i = 0;i < 3; i++){
+				tilec->numresolution[i] = tccp->numresolution[i];
+				//Greater of 3 resolutions contains all information
+				res_max = (tilec->numresolution[i] > res_max) ? tilec->numresolution[i] : res_max;
+			}
+
+			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(res_max * sizeof(opj_tcd_resolution_t));
+
+			for (resno = 0; resno < res_max; resno++) {
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+				int pdx, pdy, pdz;
+				int tlprcxstart, tlprcystart, tlprczstart, brprcxend, brprcyend, brprczend;
+				int tlcbgxstart, tlcbgystart, tlcbgzstart, brcbgxend, brcbgyend, brcbgzend;
+				int cbgwidthexpn, cbgheightexpn, cbglengthexpn;
+				int cblkwidthexpn, cblkheightexpn, cblklengthexpn;
+				int levelnox = tilec->numresolution[0] - 1 - resno; 
+				int levelnoy = tilec->numresolution[1] - 1 - resno;
+				int diff = tccp->numresolution[0] - tccp->numresolution[2]; 
+				int levelnoz = tilec->numresolution[2] - 1 - ((resno <= diff) ? 0 : (resno - diff));
+					if (levelnoz < 0) levelnoz = 0;
+
+				/* border for each resolution level (global) */
+				res->x0 = int_ceildivpow2(tilec->x0, levelnox);
+				res->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+				res->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+				res->x1 = int_ceildivpow2(tilec->x1, levelnox);
+				res->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+				res->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+				res->numbands = (resno == 0) ? 1 : (resno <= diff) ? 3 : 7; /* --> 3D */
+				
+				/* p. 30, table A-13, ISO/IEC IS154444-1 : 2002 */
+				if (tccp->csty & J3D_CCP_CSTY_PRT) {
+					pdx = tccp->prctsiz[0][resno];
+					pdy = tccp->prctsiz[1][resno];
+					pdz = tccp->prctsiz[2][resno];
+				} else {
+					pdx = 15;
+					pdy = 15;
+					pdz = 15;
+				}
+				
+				/* p. 66, B.16, ISO/IEC IS15444-1 : 2002  */
+				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+				tlprczstart = int_floordivpow2(res->z0, pdz) << pdz;
+				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+				brprczend = int_ceildivpow2(res->z1, pdz) << pdz;
+				
+				res->prctno[0] = (brprcxend - tlprcxstart) >> pdx;
+				res->prctno[1] = (brprcyend - tlprcystart) >> pdy;
+				res->prctno[2] = (brprczend - tlprczstart) >> pdz;
+				
+				/* p. 67, B.17 & B.18, ISO/IEC IS15444-1 : 2002  */
+				if (resno == 0) {
+					tlcbgxstart = tlprcxstart;//0
+					tlcbgystart = tlprcystart;
+					tlcbgzstart = tlprczstart;
+					brcbgxend = brprcxend;//1
+					brcbgyend = brprcyend;
+					brcbgzend = brprczend;
+					cbgwidthexpn = pdx; //15
+					cbgheightexpn = pdy;
+					cbglengthexpn = pdz;
+				} else {
+					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+					tlcbgzstart = int_ceildivpow2(tlprczstart, 1);
+					brcbgxend = int_ceildivpow2(brprcxend, 1);
+					brcbgyend = int_ceildivpow2(brprcyend, 1);
+					brcbgzend = int_ceildivpow2(brprczend, 1);
+					cbgwidthexpn = pdx - 1;
+					cbgheightexpn = pdy - 1;
+					cbglengthexpn = pdz - 1;
+				}
+				
+				cblkwidthexpn = int_min(tccp->cblk[0], cbgwidthexpn); //6
+				cblkheightexpn = int_min(tccp->cblk[1], cbgheightexpn); //6
+				cblklengthexpn = int_min(tccp->cblk[2], cbglengthexpn); //6
+
+				res->bands = (opj_tcd_band_t *) opj_malloc(res->numbands * sizeof(opj_tcd_band_t));
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					int x0b, y0b, z0b;
+					int gain, numbps;
+					opj_stepsize_t *ss = NULL;
+
+					opj_tcd_band_t *band = &res->bands[bandno];
+					band->bandno = resno == 0 ? 0 : bandno + 1;
+					/* Bandno:	0 - LLL 	2 - LHL 
+								1 - HLL		3 - HHL
+								4 - LLH		6 - LHH
+								5 - HLH		7 - HHH		*/
+					x0b = (band->bandno == 1) || (band->bandno == 3) || (band->bandno == 5 ) || (band->bandno == 7 ) ? 1 : 0; 
+					y0b = (band->bandno == 2) || (band->bandno == 3) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0;
+					z0b = (band->bandno == 4) || (band->bandno == 5) || (band->bandno == 6 ) || (band->bandno == 7 ) ? 1 : 0; 
+					
+					/* p. 65, B.15, ISO/IEC IS15444-1 : 2002  */
+					if (band->bandno == 0) {
+						/* band border (global) */
+						band->x0 = int_ceildivpow2(tilec->x0, levelnox);
+						band->y0 = int_ceildivpow2(tilec->y0, levelnoy);
+						band->z0 = int_ceildivpow2(tilec->z0, levelnoz);
+						band->x1 = int_ceildivpow2(tilec->x1, levelnox);
+						band->y1 = int_ceildivpow2(tilec->y1, levelnoy);
+						band->z1 = int_ceildivpow2(tilec->z1, levelnoz);
+					} else {
+						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelnox) * x0b, levelnox + 1);
+						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelnoy) * y0b, levelnoy + 1);
+						band->z0 = int_ceildivpow2(tilec->z0 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelnox) * x0b, levelnox + 1);
+						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelnoy) * y0b, levelnoy + 1);
+						band->z1 = int_ceildivpow2(tilec->z1 - (1 << levelnoz) * z0b, (resno <= diff) ? levelnoz : levelnoz + 1);
+					}	
+
+					ss = &tccp->stepsizes[(resno == 0) ? 0 : (prevnumbands + bandno + 1)];
+					if (bandno == (res->numbands - 1)) 
+						prevnumbands += (resno == 0) ? 0 : res->numbands;
+					gain = dwt_getgain(band->bandno,tccp->reversible);					
+					numbps = volume->comps[compno].prec + gain;
+
+					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
+					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+					
+					band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->prctno[0] * res->prctno[1] * res->prctno[2] * sizeof(opj_tcd_precinct_t));
+					
+					for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+						int tlcblkxstart, tlcblkystart, tlcblkzstart, brcblkxend, brcblkyend, brcblkzend;
+
+						int cbgxstart = tlcbgxstart + (precno % res->prctno[0]) * (1 << cbgwidthexpn);
+						int cbgystart = tlcbgystart + (precno / res->prctno[0]) * (1 << cbgheightexpn);
+						int cbgzstart = tlcbgzstart + (precno / (res->prctno[0] * res->prctno[1])) * (1 << cbglengthexpn);
+						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+						int cbgyend = cbgystart + (1 << cbgheightexpn);
+						int cbgzend = cbgzstart + (1 << cbglengthexpn);
+
+						opj_tcd_precinct_t *prc = &band->precincts[precno];
+						/* precinct size (global) */
+						prc->x0 = int_max(cbgxstart, band->x0);
+						prc->y0 = int_max(cbgystart, band->y0);
+						prc->z0 = int_max(cbgzstart, band->z0);
+						prc->x1 = int_min(cbgxend, band->x1);
+						prc->y1 = int_min(cbgyend, band->y1);
+						prc->z1 = int_min(cbgzend, band->z1);
+
+						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+						tlcblkzstart = int_floordivpow2(prc->z0, cblklengthexpn) << cblklengthexpn;
+						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+						brcblkzend = int_ceildivpow2(prc->z1, cblklengthexpn) << cblklengthexpn;
+						prc->cblkno[0] = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+						prc->cblkno[1] = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+						prc->cblkno[2] = (brcblkzend - tlcblkzstart) >> cblklengthexpn;
+						prc->cblkno[2] = (prc->cblkno[2] == 0) ? 1 : prc->cblkno[2];
+
+						prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]) * sizeof(opj_tcd_cblk_t));
+						prc->incltree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+						prc->imsbtree = tgt_create(prc->cblkno[0], prc->cblkno[1], prc->cblkno[2]);
+						
+						for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+							int cblkxstart = tlcblkxstart + (cblkno % prc->cblkno[0]) * (1 << cblkwidthexpn);
+							int cblkystart = tlcblkystart + ((cblkno % (prc->cblkno[0] * prc->cblkno[1])) / prc->cblkno[0]) * (1 << cblkheightexpn);
+							int cblkzstart = tlcblkzstart + (cblkno / (prc->cblkno[0] * prc->cblkno[1])) * (1 << cblklengthexpn);
+							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+							int cblkyend = cblkystart + (1 << cblkheightexpn);
+							int cblkzend = cblkzstart + (1 << cblklengthexpn);
+							int prec = ((tilec->bpp > 16) ? 3 : ((tilec->bpp > 8) ? 2 : 1));
+							/* code-block size (global) */
+							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+							
+							/* code-block size (global) */
+							cblk->x0 = int_max(cblkxstart, prc->x0);
+							cblk->y0 = int_max(cblkystart, prc->y0);
+							cblk->z0 = int_max(cblkzstart, prc->z0);
+							cblk->x1 = int_min(cblkxend, prc->x1);
+							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->z1 = int_min(cblkzend, prc->z1);
+						}
+					} /* precno */
+				} /* bandno */
+			} /* resno */
+		} /* compno */
+	} /* i = 0..cp->tileno_size */
+
+	//tcd_dump(stdout, tcd, tcd->tcd_volume);
+
+	/* 
+	Allocate place to store the decoded data = final volume
+	Place limited by the tile really present in the codestream 
+	*/
+	
+	for (i = 0; i < volume->numcomps; i++) {
+		for (j = 0; j < cp->tileno_size; j++) {
+			tileno = cp->tileno[j];
+			x0 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].x0 : int_min(x0,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].x0);
+			y0 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].y0 : int_min(y0,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].y0);
+			z0 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].z0 : int_min(z0,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].z0);
+			x1 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].x1 : int_max(x1,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].x1);
+			y1 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].y1 : int_max(y1,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].y1);
+			z1 = (j == 0) ? tcd->tcd_volume->tiles[tileno].comps[i].z1 : int_max(z1,(unsigned int) tcd->tcd_volume->tiles[tileno].comps[i].z1);
+		}
+		
+		w = x1 - x0;
+		h = y1 - y0;
+		l = z1 - z0;
+		
+		volume->comps[i].data = (int *) opj_malloc(w * h * l * sizeof(int));
+		volume->comps[i].w = w;
+		volume->comps[i].h = h;
+		volume->comps[i].l = l;
+		volume->comps[i].x0 = x0;
+		volume->comps[i].y0 = y0;
+		volume->comps[i].z0 = z0;
+		volume->comps[i].bigendian = cp->bigendian;
+	}
+}
+
+void tcd_free_decode(opj_tcd_t *tcd) {
+	int tileno,compno,resno,bandno,precno;
+
+	opj_tcd_volume_t *tcd_volume = tcd->tcd_volume;
+	
+	for (tileno = 0; tileno < tcd_volume->tw * tcd_volume->th * tcd_volume->tl; tileno++) {
+		opj_tcd_tile_t *tile = &tcd_volume->tiles[tileno];
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					opj_tcd_band_t *band = &res->bands[bandno];
+					for (precno = 0; precno < res->prctno[1] * res->prctno[0] * res->prctno[2]; precno++) {
+						opj_tcd_precinct_t *prec = &band->precincts[precno];
+						if (prec->cblks != NULL) opj_free(prec->cblks);
+						if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+                        if (prec->incltree != NULL) tgt_destroy(prec->incltree);
+						/*for (treeno = 0; treeno < prec->numtrees; treeno++){
+                            if (prec->imsbtree[treeno] != NULL) tgt_destroy(prec->imsbtree[treeno]);
+                            if (prec->incltree[treeno] != NULL) tgt_destroy(prec->incltree[treeno]);
+						}*/
+					}
+					if (band->precincts != NULL) opj_free(band->precincts);
+				}
+			}
+			if (tilec->resolutions != NULL) opj_free(tilec->resolutions);
+		}
+		if (tile->comps != NULL) opj_free(tile->comps);
+	}
+
+	if (tcd_volume->tiles != NULL) opj_free(tcd_volume->tiles);
+}
+
+
+
+/* ----------------------------------------------------------------------- */
+void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final) {
+	int compno, resno, bandno, precno, cblkno;
+	int value;			/*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolution[0]][3]; */
+	int matrice[10][10][3];
+	int i, j, k;
+
+	opj_cp_t *cp = tcd->cp;
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+	opj_tcp_t *tcd_tcp = tcd->tcp;
+
+	/*matrice=(int*)opj_malloc(tcd_tcp->numlayers*tcd_tile->comps[0].numresolution[0]*3*sizeof(int)); */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		for (i = 0; i < tcd_tcp->numlayers; i++) {
+			for (j = 0; j < tilec->numresolution[0]; j++) {
+				for (k = 0; k < 3; k++) {
+					matrice[i][j][k] =
+						(int) (cp->matrice[i * tilec->numresolution[0] * 3 + j * 3 + k] 
+						* (float) (tcd->volume->comps[compno].prec / 16.0));
+				}
+			}
+		}
+        
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_layer_t *layer = &cblk->layers[layno];
+						int n;
+						int imsb = tcd->volume->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
+						/* Correction of the matrix of coefficient to include the IMSB information */
+						if (layno == 0) {
+							value = matrice[layno][resno][bandno];
+							if (imsb >= value) {
+								value = 0;
+							} else {
+								value -= imsb;
+							}
+						} else {
+							value =	matrice[layno][resno][bandno] -	matrice[layno - 1][resno][bandno];
+							if (imsb >= matrice[layno - 1][resno][bandno]) {
+								value -= (imsb - matrice[layno - 1][resno][bandno]);
+								if (value < 0) {
+									value = 0;
+								}
+							}
+						}
+						
+						if (layno == 0) {
+							cblk->numpassesinlayers = 0;
+						}
+						
+						n = cblk->numpassesinlayers;
+						if (cblk->numpassesinlayers == 0) {
+							if (value != 0) {
+								n = 3 * value - 2 + cblk->numpassesinlayers;
+							} else {
+								n = cblk->numpassesinlayers;
+							}
+						} else {
+							n = 3 * value + cblk->numpassesinlayers;
+						}
+						
+						layer->numpasses = n - cblk->numpassesinlayers;
+						
+						if (!layer->numpasses)
+							continue;
+						
+						if (cblk->numpassesinlayers == 0) {
+							layer->len = cblk->passes[n - 1].rate;
+							layer->data = cblk->data;
+						} else {
+							layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+						}
+						if (final)
+							cblk->numpassesinlayers = n;
+					}
+				}
+			}
+		}
+	}
+}
+
+void tcd_rateallocate_fixed(opj_tcd_t *tcd) {
+	int layno;
+	for (layno = 0; layno < tcd->tcp->numlayers; layno++) {
+		tcd_makelayer_fixed(tcd, layno, 1);
+	}
+}
+
+void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final) {
+	int compno, resno, bandno, precno, cblkno, passno;
+	
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+
+	tcd_tile->distolayer[layno] = 0;	/* fixed_quality */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_layer_t *layer = &cblk->layers[layno];
+						
+						int n;
+						if (layno == 0) {
+							cblk->numpassesinlayers = 0;
+						}
+						n = cblk->numpassesinlayers;
+						for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {
+							int dr;
+							double dd;
+							opj_tcd_pass_t *pass = &cblk->passes[passno];
+							if (n == 0) {
+								dr = pass->rate;
+								dd = pass->distortiondec;
+							} else {
+								dr = pass->rate - cblk->passes[n - 1].rate;
+								dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;
+							}
+							if (!dr) {
+								if (dd)
+									n = passno + 1;
+								continue;
+							}
+							if (dd / dr >= thresh){
+								n = passno + 1;
+							}
+						}
+						layer->numpasses = n - cblk->numpassesinlayers;
+						
+						if (!layer->numpasses) {
+							layer->disto = 0;
+							continue;
+						}
+						if (cblk->numpassesinlayers == 0) {
+							layer->len = cblk->passes[n - 1].rate;
+							layer->data = cblk->data;
+							layer->disto = cblk->passes[n - 1].distortiondec;
+						} else {
+							layer->len = cblk->passes[n - 1].rate -	cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;
+						}
+						
+						tcd_tile->distolayer[layno] += layer->disto;	/* fixed_quality */
+						
+						if (final)
+							cblk->numpassesinlayers = n;
+
+					//	fprintf(stdout,"MakeLayer : %d %f %d %d \n",layer->len, layer->disto, layer->numpasses, n);
+					}
+				}
+			}
+		}
+	}
+}
+
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_volume_info_t * volume_info) {
+	int compno, resno, bandno, precno, cblkno, passno, layno;
+	double min, max;
+	double cumdisto[100];	/* fixed_quality */
+	const double K = 1;		/* 1.1; // fixed_quality */
+	double maxSE = 0;
+
+	opj_cp_t *cp = tcd->cp;
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+	opj_tcp_t *tcd_tcp = tcd->tcp;
+
+	min = DBL_MAX;
+	max = 0;
+	
+	tcd_tile->nbpix = 0;		/* fixed_quality */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		tilec->nbpix = 0;
+		for (resno = 0; resno < tilec->numresolution[0]; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->prctno[0] * res->prctno[1] * res->prctno[2]; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					for (cblkno = 0; cblkno < prc->cblkno[0] * prc->cblkno[1] * prc->cblkno[2]; cblkno++) {
+						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						for (passno = 0; passno < cblk->totalpasses; passno++) {
+							opj_tcd_pass_t *pass = &cblk->passes[passno];
+							int dr;
+							double dd, rdslope;
+							if (passno == 0) {
+								dr = pass->rate;
+								dd = pass->distortiondec;
+							} else {
+								dr = pass->rate - cblk->passes[passno - 1].rate;
+								dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;
+							}
+							if (dr == 0) {
+								continue;
+							}
+							rdslope = dd / dr;
+							if (rdslope < min) {
+								min = rdslope;
+							}
+							if (rdslope > max) {
+								max = rdslope;
+							}
+
+						} /* passno */
+						
+						/* fixed_quality */
+						tcd_tile->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0) * (cblk->z1 - cblk->z0));
+                        tilec->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0) * (cblk->z1 - cblk->z0));
+					} /* cbklno */ 
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+		
+		maxSE += (((double)(1 << tcd->volume->comps[compno].prec) - 1.0) 
+			* ((double)(1 << tcd->volume->comps[compno].prec) -1.0)) 
+			* ((double)(tilec->nbpix));
+	} /* compno */
+	
+	/* add antonin index */
+	if(volume_info && volume_info->index_on) {
+		opj_tile_info_t *info_TL = &volume_info->tile[tcd->tcd_tileno];
+		info_TL->nbpix = tcd_tile->nbpix;
+		info_TL->distotile = tcd_tile->distotile;
+		info_TL->thresh = (double *) opj_malloc(tcd_tcp->numlayers * sizeof(double));
+	}
+	/* dda */
+	
+	for (layno = 0; layno < tcd_tcp->numlayers; layno++) {
+		double lo = min;
+		double hi = max;
+		int success = 0;
+		int maxlen = tcd_tcp->rates[layno] ? int_min(((int) tcd_tcp->rates[layno]), len) : len;
+		double goodthresh;
+		double distotarget;		/* fixed_quality */
+		int i = 0;
+		
+        /* fixed_quality */
+		distotarget = tcd_tile->distotile - ((K * maxSE) / pow((float)10, tcd_tcp->distoratio[layno] / 10));
+        
+		if ((tcd_tcp->rates[layno]) || (cp->disto_alloc==0)) {
+			opj_t2_t *t2 = t2_create(tcd->cinfo, tcd->volume, cp);
+			int oldl = 0, oldoldl = 0;
+			for (i = 0; i < 128; i++) {
+				double thresh = (lo + hi) / 2;
+				int l = 0;
+				double distoachieved = 0;	/* fixed_quality -q */
+			
+				tcd_makelayer(tcd, layno, thresh, 0);
+		
+				if (cp->fixed_quality) {	/* fixed_quality -q */
+					distoachieved =	(layno == 0) ? tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];
+					if (distoachieved < distotarget) {
+						hi = thresh; 
+						continue;
+					}
+					lo = thresh;
+				} else {		/* disto_alloc -r, fixed_alloc -f */
+					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, volume_info);
+					//fprintf(stdout, "layno %d i %d len=%d max=%d \n",layno,i,l,maxlen);
+					if (l == -999) {
+						lo = thresh; 
+						continue;
+					} else if (l == oldl && oldl == oldoldl && tcd_tile->distolayer[layno] > 0.0 && i>32)
+						break;
+					hi = thresh;
+					oldoldl = oldl;
+					oldl = l;
+				}
+				success = 1;
+				goodthresh = thresh;
+			} 
+			t2_destroy(t2);
+		} else {
+			success = 1;
+			goodthresh = min;
+		}
+		if (!success) {
+			return false;
+		}
+		
+		if(volume_info && volume_info->index_on) {	/* Threshold for Marcela Index */
+			volume_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
+		}
+		tcd_makelayer(tcd, layno, goodthresh, 1);
+	        
+		/* fixed_quality */
+		cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : cumdisto[layno - 1] + tcd_tile->distolayer[layno];	
+	}
+
+	return true;
+}
+
+/* ----------------------------------------------------------------------- */
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_volume_info_t * volume_info) {
+	int compno;
+	int l, i, npck = 0;
+	double encoding_time;
+	
+	opj_tcd_tile_t	*tile = NULL;
+	opj_tcp_t		*tcd_tcp = NULL;
+	opj_cp_t		*cp = NULL;
+
+	opj_tcp_t		*tcp = &tcd->cp->tcps[0];
+	opj_tccp_t		*tccp = &tcp->tccps[0];
+	opj_volume_t	*volume = tcd->volume;
+	opj_t2_t		*t2 = NULL;		/* T2 component */
+
+	tcd->tcd_tileno = tileno;			/* current encoded/decoded tile */
+	
+	tcd->tcd_tile = tcd->tcd_volume->tiles; /* tile information */
+	tile = tcd->tcd_tile;
+	
+	tcd->tcp = &tcd->cp->tcps[tileno];	/* coding/decoding params of tileno */	
+	tcd_tcp = tcd->tcp;
+	
+	cp = tcd->cp;		/* coding parameters */
+
+	/* INDEX >> */
+	if(volume_info && volume_info->index_on) {
+		opj_tcd_tilecomp_t *tilec_idx = &tile->comps[0];	/* based on component 0 */
+		for (i = 0; i < tilec_idx->numresolution[0]; i++) {
+			opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[i];
+
+			volume_info->tile[tileno].prctno[0][i] = res_idx->prctno[0];
+			volume_info->tile[tileno].prctno[1][i] = res_idx->prctno[1];
+			volume_info->tile[tileno].prctno[2][i] = res_idx->prctno[2];
+
+			npck += res_idx->prctno[0] * res_idx->prctno[1] * res_idx->prctno[2];
+
+			volume_info->tile[tileno].prctsiz[0][i] = tccp->prctsiz[0][i];
+			volume_info->tile[tileno].prctsiz[1][i] = tccp->prctsiz[1][i];
+			volume_info->tile[tileno].prctsiz[2][i] = tccp->prctsiz[2][i];
+		}
+		volume_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(volume_info->comp * volume_info->layer * npck * sizeof(opj_packet_info_t));
+	}
+	/* << INDEX */
+	
+	/*---------------TILE-------------------*/
+	encoding_time = opj_clock();	/* time needed to encode a tile */
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		int x, y, z;
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		
+		int adjust;
+		int offset_x = int_ceildiv(volume->x0, volume->comps[compno].dx); //ceil(x0 / subsampling_dx)
+		int offset_y = int_ceildiv(volume->y0, volume->comps[compno].dy);
+		int offset_z = int_ceildiv(volume->z0, volume->comps[compno].dz);
+		
+		int tw = tilec->x1 - tilec->x0;
+		int w = int_ceildiv(volume->x1 - volume->x0, volume->comps[compno].dx);
+		int th = tilec->y1 - tilec->y0;
+		int h = int_ceildiv(volume->y1 - volume->y0, volume->comps[compno].dy);
+		int tl = tilec->z1 - tilec->z0;
+		int l = int_ceildiv(volume->z1 - volume->z0, volume->comps[compno].dz);
+
+		
+		
+		/* extract tile data from volume.comps[0].data to tile.comps[0].data */
+		//fprintf(stdout,"[INFO] Extract tile data\n");
+		if (tcd->cp->transform_format == TRF_3D_RLS || tcd->cp->transform_format == TRF_3D_LSE) {
+			adjust = 0;
+		} else {
+            adjust = volume->comps[compno].sgnd ? 0 : 1 << (volume->comps[compno].prec - 1); //sign=='+' --> 2^(prec-1)
+			if (volume->comps[compno].dcoffset != 0){
+				adjust += volume->comps[compno].dcoffset;
+				fprintf(stdout,"[INFO] DC Offset applied: DCO = %d -> adjust = %d\n",volume->comps[compno].dcoffset,adjust);
+			}
+		}		
+
+		if (tcd_tcp->tccps[compno].reversible == 1) { //IF perfect reconstruction (DWT.5-3)
+			for (z = tilec->z0; z < tilec->z1; z++) {
+				for (y = tilec->y0; y < tilec->y1; y++) {
+					/* start of the src tile scanline */
+					int *data = &volume->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w + (z - offset_z) * w * h];
+					/* start of the dst tile scanline */
+					int *tile_data = &tilec->data[(y - tilec->y0) * tw + (z - tilec->z0) * tw * th];
+					for (x = tilec->x0; x < tilec->x1; x++) {
+						*tile_data++ = *data++ - adjust;
+					}
+				}
+			}
+		} else if (tcd_tcp->tccps[compno].reversible == 0) { //IF not (DWT.9-7)
+			for (z = tilec->z0; z < tilec->z1; z++) {
+				for (y = tilec->y0; y < tilec->y1; y++) {
+					/* start of the src tile scanline */
+					int *data = &volume->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w + (z - offset_z) * w * h];
+					/* start of the dst tile scanline */
+					int *tile_data = &tilec->data[(y - tilec->y0) * tw + (z - tilec->z0) * tw * th];
+					for (x = tilec->x0; x < tilec->x1; x++) {
+						*tile_data++ = (*data++ - adjust) << 13;
+					}
+				}
+			}
+		}
+	
+	}
+
+	/*----------------MCT-------------------*/
+	if (tcd_tcp->mct) {
+		int samples = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0) * (tile->comps[0].z1 - tile->comps[0].z0);
+		fprintf(stdout,"[INFO] Tcd_encode_tile: mct\n");
+		if (tcd_tcp->tccps[0].reversible == 0) {
+			mct_encode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
+		} else {
+			mct_encode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
+		}
+	}
+	/*----------------TRANSFORM---------------------------------*/
+	fprintf(stdout,"[INFO] Tcd_encode_tile: Transform\n");
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		dwt_encode(tilec, tcd_tcp->tccps[compno].dwtid);
+	} 
+
+	/*-------------------ENTROPY CODING-----------------------------*/
+	fprintf(stdout,"[INFO] Tcd_encode_tile: Entropy coding\n");
+	if ((cp->encoding_format == ENCOD_2EB)||(cp->encoding_format == ENCOD_3EB))
+	{
+		if (cp->encoding_format == ENCOD_2EB) {
+			opj_t1_t *t1 = NULL;
+			t1 = t1_create(tcd->cinfo);
+			t1_encode_cblks(t1, tile, tcd_tcp);
+			t1_destroy(t1);	
+		} else if (cp->encoding_format == ENCOD_3EB) {
+			opj_t1_3d_t *t1 = NULL;		
+			t1 = t1_3d_create(tcd->cinfo);
+			t1_3d_encode_cblks(t1, tile, tcd_tcp);
+			t1_3d_destroy(t1);	
+		}
+		/*-----------RATE-ALLOCATE------------------*/
+		/* INDEX */
+		if(volume_info) {
+			volume_info->index_write = 0;
+		}
+		if (cp->disto_alloc || cp->fixed_quality) {	
+   			fprintf(stdout,"[INFO] Tcd_encode_tile: Rate-allocate\n");
+			tcd_rateallocate(tcd, dest, len, volume_info);			/* Normal Rate/distortion allocation */
+		} else {/* fixed_alloc */
+    	    fprintf(stdout,"[INFO] Tcd_encode_tile: Rate-allocate fixed\n");
+            tcd_rateallocate_fixed(tcd);							/* Fixed layer allocation */
+		}
+
+		/*--------------TIER2------------------*/
+		/* INDEX */
+		if(volume_info) {
+			volume_info->index_write = 1;
+		}
+		fprintf(stdout,"[INFO] Tcd_encode_tile: Tier - 2\n");
+        t2 = t2_create(tcd->cinfo, volume, cp);
+		l = t2_encode_packets(t2, tileno, tile, tcd_tcp->numlayers, dest, len, volume_info);
+        t2_destroy(t2);
+	} else if ((cp->encoding_format == ENCOD_2GR)||(cp->encoding_format == ENCOD_3GR)) {
+		/*if(volume_info) {
+			volume_info->index_write = 1;
+		}
+		gr = golomb_create(tcd->cinfo, volume, cp);
+		l = golomb_encode(gr, tileno, tile, dest, len, volume_info);
+		golomb_destroy(gr);*/
+	}
+
+	
+	/*---------------CLEAN-------------------*/
+	fprintf(stdout,"[INFO] Tcd_encode_tile: %d bytes coded\n",l);
+	encoding_time = opj_clock() - encoding_time;
+	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile encoded in %f s\n", encoding_time);
+	
+	/* cleaning memory */
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		tcd->tilec = &tile->comps[compno];
+		opj_free(tcd->tilec->data);
+	}
+	
+	if (l == -999){
+		fprintf(stdout,"[ERROR] Unable to perform T2 tier. Return -999.\n");
+		return 0;
+	}
+
+	return l;
+}
+
+
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno) {
+	int l, i;
+	int compno, eof = 0;
+	double tile_time, t1_time, dwt_time;
+
+	opj_tcd_tile_t *tile = NULL;
+	opj_t2_t *t2 = NULL;		/* T2 component */
+	
+	tcd->tcd_tileno = tileno;
+	tcd->tcd_tile = &(tcd->tcd_volume->tiles[tileno]);
+	tcd->tcp = &(tcd->cp->tcps[tileno]);
+	tile = tcd->tcd_tile;
+	
+	tile_time = opj_clock();	/* time needed to decode a tile */
+	opj_event_msg(tcd->cinfo, EVT_INFO, "tile %d / %d\n", tileno + 1, tcd->cp->tw * tcd->cp->th * tcd->cp->tl);
+
+	if ((tcd->cp->encoding_format == ENCOD_2EB) || (tcd->cp->encoding_format == ENCOD_3EB)) {
+		/*--------------TIER2------------------*/
+		t2 = t2_create(tcd->cinfo, tcd->volume, tcd->cp);
+		l = t2_decode_packets(t2, src, len, tileno, tile);
+		t2_destroy(t2);
+		opj_event_msg(tcd->cinfo, EVT_INFO, "Tcd_decode_tile: %d bytes decoded\n",l);
+		
+		if (l == -999) {
+			eof = 1;
+			opj_event_msg(tcd->cinfo, EVT_ERROR, "Tcd_decode_tile: incomplete bistream\n");
+		}
+	
+		/*------------------TIER1-----------------*/
+		opj_event_msg(tcd->cinfo, EVT_INFO, "Tcd_decode_tile: Entropy decoding %d \n",tcd->cp->encoding_format);
+		t1_time = opj_clock();	/* time needed to decode a tile */
+		if (tcd->cp->encoding_format == ENCOD_2EB) {
+			opj_t1_t *t1 = NULL;		/* T1 component */
+			t1 = t1_create(tcd->cinfo);
+			t1_decode_cblks(t1, tile, tcd->tcp);
+			t1_destroy(t1);
+		}else if (tcd->cp->encoding_format == ENCOD_3EB) {
+			opj_t1_3d_t *t1 = NULL;		/* T1 component */
+			t1 = t1_3d_create(tcd->cinfo);
+			t1_3d_decode_cblks(t1, tile, tcd->tcp);
+			t1_3d_destroy(t1);
+		}
+
+		t1_time = opj_clock() - t1_time;
+		#ifdef VERBOSE
+				opj_event_msg(tcd->cinfo, EVT_INFO, "- tier-1 took %f s\n", t1_time);
+		#endif
+	} else if ((tcd->cp->encoding_format == ENCOD_2GR)||(tcd->cp->encoding_format == ENCOD_3GR)) {
+		opj_event_msg(tcd->cinfo, EVT_INFO, "Tcd_decode_tile: Entropy decoding -- Does nothing :-D\n");
+		/*
+		gr = golomb_create(tcd->cinfo, tcd->volume, tcd->cp);
+		l = golomb_decode(gr, tileno, tile, src, len);
+		golomb_destroy(gr);
+		if (l == -999) {
+			eof = 1;
+			opj_event_msg(tcd->cinfo, EVT_ERROR, "Tcd_decode_tile: incomplete bistream\n");
+		}
+		*/
+	} 
+
+	/*----------------DWT---------------------*/
+	fprintf(stdout,"[INFO] Tcd_decode_tile: Inverse DWT\n");
+	dwt_time = opj_clock();	/* time needed to decode a tile */
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		int stops[3], dwtid[3];
+	
+		for (i = 0; i < 3; i++) {
+			if (tcd->cp->reduce[i] != 0) 
+				tcd->volume->comps[compno].resno_decoded[i] = tile->comps[compno].numresolution[i] - tcd->cp->reduce[i] - 1;
+			stops[i] = tilec->numresolution[i] - 1 - tcd->volume->comps[compno].resno_decoded[i];
+			if (stops[i] < 0) stops[i]=0;
+			dwtid[i] = tcd->cp->tcps->tccps[compno].dwtid[i];
+		}
+		
+		dwt_decode(tilec, stops, dwtid);
+
+		for (i = 0; i < 3; i++) {
+			if (tile->comps[compno].numresolution[i] > 0) {
+				tcd->volume->comps[compno].factor[i] = tile->comps[compno].numresolution[i] - (tcd->volume->comps[compno].resno_decoded[i] + 1);
+				if ( (tcd->volume->comps[compno].factor[i]) < 0 )
+					tcd->volume->comps[compno].factor[i] = 0;
+			}
+		}
+	}
+	dwt_time = opj_clock() - dwt_time;
+	#ifdef VERBOSE
+			opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
+	#endif
+
+	/*----------------MCT-------------------*/
+	
+	if (tcd->tcp->mct) {
+		if (tcd->tcp->tccps[0].reversible == 1) {
+			mct_decode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
+				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0) * (tile->comps[0].z1 - tile->comps[0].z0));
+		} else {
+			mct_decode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
+				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0)* (tile->comps[0].z1 - tile->comps[0].z0));
+		}
+	}
+	
+	/*---------------TILE-------------------*/
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		opj_tcd_resolution_t *res =	&tilec->resolutions[tcd->volume->comps[compno].resno_decoded[0]];
+		int adjust;
+		int minval = tcd->volume->comps[compno].sgnd ? -(1 << (tcd->volume->comps[compno].prec - 1)) : 0;
+		int maxval = tcd->volume->comps[compno].sgnd ? (1 << (tcd->volume->comps[compno].prec - 1)) - 1 : (1 << tcd->volume->comps[compno].prec) - 1;
+		
+		int tw = tilec->x1 - tilec->x0;
+		int w = tcd->volume->comps[compno].w;
+		int th = tilec->y1 - tilec->y0;
+		int h = tcd->volume->comps[compno].h;
+
+		int i, j, k;
+		int offset_x = int_ceildivpow2(tcd->volume->comps[compno].x0, tcd->volume->comps[compno].factor[0]);
+		int offset_y = int_ceildivpow2(tcd->volume->comps[compno].y0, tcd->volume->comps[compno].factor[1]);
+		int offset_z = int_ceildivpow2(tcd->volume->comps[compno].z0, tcd->volume->comps[compno].factor[2]);
+		
+		if (tcd->cp->transform_format == TRF_3D_RLS || tcd->cp->transform_format == TRF_3D_LSE) {
+			adjust = 0;
+		} else {
+            adjust = tcd->volume->comps[compno].sgnd ? 0 : 1 << (tcd->volume->comps[compno].prec - 1); //sign=='+' --> 2^(prec-1)
+			if (tcd->volume->comps[compno].dcoffset != 0){
+				adjust += tcd->volume->comps[compno].dcoffset;
+				fprintf(stdout,"[INFO] DC Offset applied: DCO = %d -> adjust = %d\n",tcd->volume->comps[compno].dcoffset,adjust);
+			}
+		}
+
+		for (k = res->z0; k < res->z1; k++) {
+			for (j = res->y0; j < res->y1; j++) {
+				for (i = res->x0; i < res->x1; i++) {
+					int v;
+					float tmp = (float)((tilec->data[i - res->x0 + (j - res->y0) * tw + (k - res->z0) * tw * th]) / 8192.0);
+
+					if (tcd->tcp->tccps[compno].reversible == 1) {
+						v = tilec->data[i - res->x0 + (j - res->y0) * tw + (k - res->z0) * tw * th];
+					} else {
+						int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
+						v = ((tmp < 0) ? -tmp2:tmp2);
+					}
+					v += adjust;
+					
+					tcd->volume->comps[compno].data[(i - offset_x) + (j - offset_y) * w + (k - offset_z) * w * h] = int_clamp(v, minval, maxval);
+				}
+			}
+		}
+	}
+	
+	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
+	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
+		
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_free(tcd->tcd_volume->tiles[tileno].comps[compno].data);
+		tcd->tcd_volume->tiles[tileno].comps[compno].data = NULL;
+	}
+	
+	if (eof) {
+		return false;
+	}
+	
+	return true;
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tcd.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/tcd.h.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,334 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __TCD_H
+#define __TCD_H
+/**
+@file tcd.h
+@brief Implementation of a tile coder/decoder (TCD)
+
+The functions in TCD.C have for goal to encode or decode each tile independently from
+each other. The functions in TCD.C are used by some function in JP3D.C.
+*/
+
+/** @defgroup TCD TCD - Implementation of a tile coder/decoder */
+/*@{*/
+
+/**
+Tile coder/decoder: segment instance
+*/
+typedef struct opj_tcd_seg {
+/** Number of passes in the segment */
+	int numpasses;			
+/** Length of information */
+    int len;					
+/** Data */
+	unsigned char *data;		
+/** Number of passes posible for the segment */
+	int maxpasses;			
+/** Number of passes added to the segment */
+	int numnewpasses;		    
+/** New length after inclusion of segments */
+	int newlen;
+} opj_tcd_seg_t;
+
+/**
+Tile coder/decoder: pass instance
+*/
+typedef struct opj_tcd_pass {
+/** Rate obtained in the pass*/
+  int rate;					
+/** Distorsion obtained in the pass*/
+  double distortiondec;		
+  int term;
+/** Length of information */
+  int len;					
+} opj_tcd_pass_t;
+
+/**
+Tile coder/decoder: layer instance
+*/
+typedef struct opj_tcd_layer {
+/** Number of passes in the layer */
+	int numpasses;			
+/** Length of information */
+  int len;					
+/** Distortion within layer */
+  double disto;				/* add for index (Cfr. Marcela) */
+  unsigned char *data;		/* data */
+} opj_tcd_layer_t;
+
+/**
+Tile coder/decoder: codeblock instance
+*/
+typedef struct opj_tcd_cblk {
+/** Dimension of the code-blocks : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the code-blocks : right low corner (x1,y1,z1) */
+  int x1, y1, z1;		
+/** Number of bits per simbol in codeblock */
+  int numbps;
+  int numlenbits;
+  int len;						/* length */
+/** Number of pass already done for the code-blocks */
+  int numpasses;				
+/** number of pass added to the code-blocks */
+  int numnewpasses;				
+/** Number of segments */
+  int numsegs;					
+/** Segments informations */
+  opj_tcd_seg_t segs[100];		
+/** Number of passes in the layer */
+  int numpassesinlayers;		
+/** Layer information */
+  opj_tcd_layer_t layers[100];	
+/** Total number of passes */
+  int totalpasses;				
+/** Information about the passes */
+  opj_tcd_pass_t passes[100];	
+/* Data */
+  unsigned char data[524288];		
+  //unsigned char *data;
+} opj_tcd_cblk_t;
+
+/**
+Tile coder/decoder: precint instance
+*/
+typedef struct opj_tcd_precinct {
+/** Dimension of the precint : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the precint : right low corner (x1,y1,z1) */
+  int x1, y1, z1;
+/** Number of codeblocks in precinct in width and heigth and length*/
+  int cblkno[3];				
+/** Information about the codeblocks */
+  opj_tcd_cblk_t *cblks;		
+/** Inclusion tree */
+  opj_tgt_tree_t *incltree;		
+/** Missing MSBs tree */
+  opj_tgt_tree_t *imsbtree;		
+} opj_tcd_precinct_t;
+
+/**
+Tile coder/decoder: subband instance
+*/
+typedef struct opj_tcd_band {
+/** Dimension of the subband : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the subband : right low corner (x1,y1,z1) */
+  int x1, y1, z1;
+/** Information about the precints */
+  opj_tcd_precinct_t *precincts;	/* precinct information */
+/** Number of bits per symbol in band */
+  int numbps;
+/** Quantization stepsize associated */
+  float stepsize;
+/** Band orientation (O->LLL,...,7->HHH) */
+  int bandno;
+} opj_tcd_band_t;
+
+/**
+Tile coder/decoder: resolution instance
+*/
+typedef struct opj_tcd_resolution {
+/** Dimension of the resolution level : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the resolution level : right low corner (x1,y1,z1) */
+  int x1, y1, z1;
+/** Number of precints in each dimension for the resolution level */
+  int prctno[3];				
+/** Number of subbands for the resolution level */
+  int numbands;					
+/** Subband information */
+  opj_tcd_band_t *bands;		
+} opj_tcd_resolution_t;
+
+/**
+Tile coder/decoder: component instance
+*/
+typedef struct opj_tcd_tilecomp {
+/** Dimension of the component : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the component : right low corner (x1,y1,z1) */
+  int x1, y1, z1;
+/** Number of resolutions level if DWT transform*/
+  int numresolution[3];					
+/** Resolution information */
+  opj_tcd_resolution_t *resolutions;	
+/** Data of the component */
+  int *data;					
+/** Fixed_quality related */
+  int nbpix;				
+/** Number of bits per voxel in component */
+  int bpp;
+} opj_tcd_tilecomp_t;
+
+/**
+Tile coder/decoder: tile instance
+*/
+typedef struct opj_tcd_tile {
+/** Dimension of the tile : left upper corner (x0, y0, z0) */
+  int x0, y0, z0;
+/** Dimension of the tile : right low corner (x1,y1,z1) */
+  int x1, y1, z1;
+/** Number of components in tile */
+  int numcomps;					
+/** Components information */
+  opj_tcd_tilecomp_t *comps;	
+/** Fixed_quality related : no of bytes of data*/
+  int nbpix;					
+/** Fixed_quality related : distortion achieved in tile */
+  double distotile;				
+/** Fixed_quality related : distortion achieved in each layer */
+  double distolayer[100];		
+} opj_tcd_tile_t;
+
+/**
+Tile coder/decoder: volume instance
+*/
+typedef struct opj_tcd_volume {
+/** Number of tiles in width and heigth and length */
+	int tw, th, tl;				
+/** Tiles information */
+  opj_tcd_tile_t *tiles;		
+} opj_tcd_volume_t;
+
+/**
+Tile coder/decoder
+*/
+typedef struct opj_tcd {
+/** Codec context */	
+	opj_common_ptr cinfo;			
+/** Volume information */	
+	opj_volume_t *volume;			
+/** Coding parameters */	
+	opj_cp_t *cp;					
+/** Coding/decoding parameters common to all tiles */	
+	opj_tcp_t *tcp;					
+/** Info on each volume tile */
+	opj_tcd_volume_t *tcd_volume;	
+/** Pointer to the current encoded/decoded tile */
+	opj_tcd_tile_t *tcd_tile;		
+/** Current encoded/decoded tile */
+	int tcd_tileno;					
+
+	/**@name working variables */
+	/*@{*/
+	opj_tcd_tile_t *tile;
+	opj_tcd_tilecomp_t *tilec;
+	opj_tcd_resolution_t *res;
+	opj_tcd_band_t *band;
+	opj_tcd_precinct_t *prc;
+	opj_tcd_cblk_t *cblk;
+	/*@}*/
+} opj_tcd_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Dump the content of a tcd structure
+*/
+void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_volume_t *img);
+/**
+Create a new TCD handle
+@param cinfo Codec context info
+@return Returns a new TCD handle if successful returns NULL otherwise
+*/
+opj_tcd_t* tcd_create(opj_common_ptr cinfo);
+/**
+Destroy a previously created TCD handle
+@param tcd TCD handle to destroy
+*/
+void tcd_destroy(opj_tcd_t *tcd);
+/**
+Initialize the tile coder (allocate the memory) 
+@param tcd TCD handle
+@param volume Raw volume
+@param cp Coding parameters
+@param curtileno Number that identifies the tile that will be encoded
+*/
+void tcd_malloc_encode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp, int curtileno);
+/**
+Initialize the tile coder (reuses the memory allocated by tcd_malloc_encode)(for 3D-DWT)
+@param tcd TCD handle
+@param volume Raw volume
+@param cp Coding parameters
+@param curtileno Number that identifies the tile that will be encoded
+*/
+void tcd_init_encode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp, int curtileno);
+/**
+Free the memory allocated for encoding
+@param tcd TCD handle
+*/
+void tcd_free_encode(opj_tcd_t *tcd);
+/**
+Initialize the tile decoder
+@param tcd TCD handle
+@param volume Raw volume
+@param cp Coding parameters
+*/
+void tcd_malloc_decode(opj_tcd_t *tcd, opj_volume_t * volume, opj_cp_t * cp);
+
+void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final);
+void tcd_rateallocate_fixed(opj_tcd_t *tcd);
+void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final);
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_volume_info_t * volume_info);
+/**
+Encode a tile from the raw volume into a buffer
+@param tcd TCD handle
+@param tileno Number that identifies one of the tiles to be encoded
+@param dest Destination buffer
+@param len Length of destination buffer
+@param volume_info Creation of index file
+@return 
+*/
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_volume_info_t * volume_info);
+/**
+Decode a tile from a buffer into a raw volume
+@param tcd TCD handle
+@param src Source buffer
+@param len Length of source buffer
+@param tileno Number that identifies one of the tiles to be decoded
+*/
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno);
+/**
+Free the memory allocated for decoding
+@param tcd TCD handle
+*/
+void tcd_free_decode(opj_tcd_t *tcd);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __TCD_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tgt.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/tgt.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,256 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* 
+==========================================================
+   Tag-tree coder interface
+==========================================================
+*/
+void tgt_tree_dump (FILE *fd, opj_tgt_tree_t * tree){
+	int nodesno;
+
+	fprintf(fd, "TGT_TREE {\n");
+	fprintf(fd, "  numnodes: %d \n", tree->numnodes);	
+	fprintf(fd, "  numleafsh: %d, numleafsv: %d, numleafsz: %d,\n", tree->numleafsh, tree->numleafsv, tree->numleafsz);
+
+	for (nodesno = 0; nodesno < tree->numnodes; nodesno++) {
+		fprintf(fd, "tgt_node %d {\n", nodesno);
+		fprintf(fd, "  value: %d \n", tree->nodes[nodesno].value);
+		fprintf(fd, "  low: %d \n", tree->nodes[nodesno].low);
+		fprintf(fd, "  known: %d \n", tree->nodes[nodesno].known);
+		if (tree->nodes[nodesno].parent) {
+			fprintf(fd, "  parent.value: %d \n", tree->nodes[nodesno].parent->value);
+			fprintf(fd, "  parent.low: %d \n", tree->nodes[nodesno].parent->low);
+			fprintf(fd, "  parent.known: %d \n", tree->nodes[nodesno].parent->known);
+		}
+		fprintf(fd, "}\n");
+
+	}
+	fprintf(fd, "}\n");
+
+}
+
+
+opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv, int numleafsz) {
+	
+	int nplh[32];
+	int nplv[32];
+	int nplz[32];
+	opj_tgt_node_t *node = NULL;
+	opj_tgt_node_t *parentnode = NULL;
+	opj_tgt_node_t *parentnode0 = NULL;
+	opj_tgt_tree_t *tree = NULL;
+	int i, j, k, p, p0;
+	int numlvls;
+	int n, z = 0;
+
+	tree = (opj_tgt_tree_t *) opj_malloc(sizeof(opj_tgt_tree_t));
+	if(!tree) 
+		return NULL;
+	tree->numleafsh = numleafsh;
+	tree->numleafsv = numleafsv;
+	tree->numleafsz = numleafsz;
+
+	numlvls = 0;
+	nplh[0] = numleafsh;
+	nplv[0] = numleafsv;
+	nplz[0] = numleafsz;
+	tree->numnodes = 0;
+	do {
+		n = nplh[numlvls] * nplv[numlvls] * nplz[numlvls]; 
+		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
+		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
+		nplz[numlvls + 1] = (nplz[numlvls] + 1) / 2;
+		tree->numnodes += n;
+		++numlvls;
+	} while (n > 1);
+
+	if (tree->numnodes == 0) {
+		opj_free(tree);
+		return NULL;
+	}
+
+	tree->nodes = (opj_tgt_node_t *) opj_malloc(tree->numnodes * sizeof(opj_tgt_node_t));
+	if(!tree->nodes) {
+		opj_free(tree);
+		return NULL;
+	}
+
+	node = tree->nodes;
+	parentnode = &tree->nodes[tree->numleafsh * tree->numleafsv * tree->numleafsz];
+	parentnode0 = parentnode;
+		
+	p = tree->numleafsh * tree->numleafsv * tree->numleafsz;
+	p0 = p;
+	n = 0;
+	//fprintf(stdout,"\nH %d V %d Z %d numlvls %d nodes %d\n",tree->numleafsh,tree->numleafsv,tree->numleafsz,numlvls,tree->numnodes);
+	for (i = 0; i < numlvls - 1; ++i) {
+		for (j = 0; j < nplv[i]; ++j) {
+			k = nplh[i]*nplz[i];
+			while (--k >= 0) {
+				node->parent = parentnode;		//fprintf(stdout,"node[%d].parent = node[%d]\n",n,p);
+				++node;	++n;		
+				if (--k >= 0 && n < p) {
+					node->parent = parentnode;	//fprintf(stdout,"node[%d].parent = node[%d]\n",n,p);
+					++node;	++n;	
+				}
+				if (nplz[i] != 1){ //2D operation vs 3D operation
+					if (--k >= 0 && n < p) {
+						node->parent = parentnode;	//fprintf(stdout,"node[%d].parent = node[%d]\n",n,p);
+						++node;	++n;
+					}
+					if (--k >= 0 && n < p) {
+						node->parent = parentnode;	//fprintf(stdout,"node[%d].parent = node[%d]\n",n,p);
+						++node;	++n;
+					}
+				}
+				++parentnode; ++p;
+			}
+			if ((j & 1) || j == nplv[i] - 1) {
+				parentnode0 = parentnode;			p0 = p;		//fprintf(stdout,"parent = node[%d] \n",p);
+			} else {
+				parentnode = parentnode0;			p = p0;		//fprintf(stdout,"parent = node[%d] \n",p);
+				parentnode0 += nplh[i]*nplz[i];		p0 += nplh[i]*nplz[i];
+			}
+		}
+	}
+	node->parent = 0;
+
+	
+	tgt_reset(tree);
+
+	return tree;
+}
+
+void tgt_destroy(opj_tgt_tree_t *tree) {
+	opj_free(tree->nodes);
+	opj_free(tree);
+}
+
+void tgt_reset(opj_tgt_tree_t *tree) {
+	int i;
+
+	if (NULL == tree)
+		return;
+	
+	for (i = 0; i < tree->numnodes; i++) {
+		tree->nodes[i].value = 999;
+		tree->nodes[i].low = 0;
+		tree->nodes[i].known = 0;
+	}
+}
+
+void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value) {
+	opj_tgt_node_t *node;
+	node = &tree->nodes[leafno];
+	while (node && node->value > value) {
+		node->value = value;
+		node = node->parent;
+	}
+}
+
+void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
+	opj_tgt_node_t *stk[31];
+	opj_tgt_node_t **stkptr;
+	opj_tgt_node_t *node;
+	int low;
+
+	stkptr = stk;
+	node = &tree->nodes[leafno];
+	while (node->parent) {
+		*stkptr++ = node;
+		node = node->parent;
+	}
+	
+	low = 0;
+	for (;;) {
+		if (low > node->low) {
+			node->low = low;
+		} else {
+			low = node->low;
+		}
+		
+		while (low < threshold) {
+			if (low >= node->value) {
+				if (!node->known) {
+					bio_write(bio, 1, 1);
+					node->known = 1;
+				}
+				break;
+			}
+			bio_write(bio, 0, 1);
+			++low;
+		}
+		
+		node->low = low;
+		if (stkptr == stk)
+			break;
+		node = *--stkptr;
+	}
+}
+
+int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
+	opj_tgt_node_t *stk[31];
+	opj_tgt_node_t **stkptr;
+	opj_tgt_node_t *node;
+	int low;
+
+	stkptr = stk;
+	node = &tree->nodes[leafno];
+	while (node->parent) {
+		*stkptr++ = node;
+		node = node->parent;
+	}
+	
+	low = 0;
+	for (;;) {
+		if (low > node->low) {
+			node->low = low;
+		} else {
+			low = node->low;
+		}
+		while (low < threshold && low < node->value) {
+			if (bio_read(bio, 1)) {
+				node->value = low;
+			} else {
+				++low;
+			}
+		}
+		node->low = low;
+		if (stkptr == stk) {
+			break;
+		}
+		node = *--stkptr;
+	}
+	
+	return (node->value < threshold) ? 1 : 0;
+}
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tgt.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/tgt.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,124 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TGT_H
+#define __TGT_H
+/**
+@file tgt.h
+@brief Implementation of a tag-tree coder (TGT)
+
+The functions in TGT.C have for goal to realize a tag-tree coder. The functions in TGT.C
+are used by some function in T2.C.
+*/
+
+/** @defgroup TGT TGT - Implementation of a tag-tree coder */
+/*@{*/
+
+/**
+Tag node
+*/
+typedef struct opj_tgt_node {
+/** Node parent reference */
+  struct opj_tgt_node *parent;
+/**  */
+  int value;
+/**  */
+  int low;
+/**  */
+  int known;
+} opj_tgt_node_t;
+
+/**
+Tag tree
+*/
+typedef struct opj_tgt_tree {
+/** Number of leaves from horizontal axis */
+  int numleafsh;
+/** Number of leaves from vertical axis */
+  int numleafsv;
+/** Number of leaves from axial axis */
+  int numleafsz;
+/** Number of nodes */
+  int numnodes;
+/** Reference to each node instance */
+  opj_tgt_node_t *nodes;
+} opj_tgt_tree_t;
+
+/** @name Funciones generales */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a tag-tree
+@param numleafsh Width of the array of leafs of the tree
+@param numleafsv Height of the array of leafs of the tree
+@param numleafsz Depth of the array of leafs of the tree
+@return Returns a new tag-tree if successful, returns NULL otherwise
+*/
+opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv, int numleafsz);
+/**
+Destroy a tag-tree, liberating memory
+@param tree Tag-tree to destroy
+*/
+void tgt_destroy(opj_tgt_tree_t *tree);
+/**
+Reset a tag-tree (set all leaves to 0)
+@param tree Tag-tree to reset
+*/
+void tgt_reset(opj_tgt_tree_t *tree);
+/**
+Set the value of a leaf of a tag-tree
+@param tree Tag-tree to modify
+@param leafno Number that identifies the leaf to modify
+@param value New value of the leaf
+*/
+void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value);
+/**
+Encode the value of a leaf of the tag-tree up to a given threshold
+@param bio Pointer to a BIO handle
+@param tree Tag-tree to modify
+@param leafno Number that identifies the leaf to encode
+@param threshold Threshold to use when encoding value of the leaf
+*/
+void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+/**
+Decode the value of a leaf of the tag-tree up to a given threshold
+@param bio Pointer to a BIO handle
+@param tree Tag-tree to decode
+@param leafno Number that identifies the leaf to decode
+@param threshold Threshold to use when decoding value of the leaf
+@return Returns 1 if the node's value < threshold, returns 0 otherwise
+*/
+int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+
+/*@}*/
+/* ----------------------------------------------------------------------- */
+void tgt_tree_dump (FILE *fd, opj_tgt_tree_t * tree);
+
+#endif /* __TGT_H */
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/volume.c.svn-base ./jp3d/libjp3dvm/.svn/text-base/volume.c.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/volume.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/volume.c.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+opj_volume_t* OPJ_CALLCONV opj_volume_create(int numcmpts, opj_volume_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc) {
+	int compno;
+	opj_volume_t *volume = NULL;
+
+	volume = (opj_volume_t*)opj_malloc(sizeof(opj_volume_t));
+	if(volume) {
+		volume->color_space = clrspc;
+		volume->numcomps = numcmpts;
+		/* allocate memory for the per-component information */
+		volume->comps = (opj_volume_comp_t*)opj_malloc(volume->numcomps * sizeof(opj_volume_comp_t));
+		if(!volume->comps) {
+			opj_volume_destroy(volume);
+			return NULL;
+		}
+		/* create the individual volume components */
+		for(compno = 0; compno < numcmpts; compno++) {
+			opj_volume_comp_t *comp = &volume->comps[compno];
+			comp->dx = cmptparms[compno].dx;
+			comp->dy = cmptparms[compno].dy;
+			comp->dz = cmptparms[compno].dz;
+			comp->w = cmptparms[compno].w;
+			comp->h = cmptparms[compno].h;
+			comp->l = cmptparms[compno].l;
+			comp->x0 = cmptparms[compno].x0;
+			comp->y0 = cmptparms[compno].y0;
+			comp->z0 = cmptparms[compno].z0;
+			comp->prec = cmptparms[compno].prec;
+			comp->bpp = cmptparms[compno].bpp;
+			comp->sgnd = cmptparms[compno].sgnd;
+			comp->bigendian = cmptparms[compno].bigendian;
+			comp->dcoffset = cmptparms[compno].dcoffset;
+			comp->data = (int*)opj_malloc(comp->w * comp->h * comp->l * sizeof(int));
+			if(!comp->data) {
+				fprintf(stdout,"Unable to malloc comp->data (%d x %d x %d x bytes)",comp->w,comp->h,comp->l);
+				opj_volume_destroy(volume);
+				return NULL;
+			}
+			//fprintf(stdout,"%d %d %d %d %d %d %d %d %d", comp->w,comp->h, comp->l, comp->dx, comp->dy, comp->dz, comp->prec, comp->bpp, comp->sgnd);
+		}
+	}
+
+	return volume;
+}
+
+void OPJ_CALLCONV opj_volume_destroy(opj_volume_t *volume) {
+	int i;
+	if(volume) {
+		if(volume->comps) {
+			/* volume components */
+			for(i = 0; i < volume->numcomps; i++) {
+				opj_volume_comp_t *volume_comp = &volume->comps[i];
+				if(volume_comp->data) {
+					opj_free(volume_comp->data);
+				}
+			}
+			opj_free(volume->comps);
+		}
+		opj_free(volume);
+	}
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/volume.h.svn-base ./jp3d/libjp3dvm/.svn/text-base/volume.h.svn-base
--- /home/robin/sldeb/trunk/jp3d/libjp3dvm/.svn/text-base/volume.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/libjp3dvm/.svn/text-base/volume.h.svn-base	2007-09-28 11:33:45.000000000 +0100
@@ -0,0 +1,43 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2006, Mónica Díez García, Image Processing Laboratory, University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __VOLUME_H
+#define __VOLUME_H
+/**
+@file volume.h
+@brief Implementation of operations on volumes (VOLUME)
+
+The functions in VOLUME.C have for goal to realize operations on volumes.
+*/
+
+/** @defgroup VOLUME VOLUME - Implementation of operations on volumes */
+/*@{*/
+
+
+/*@}*/
+
+#endif /* __VOLUME_H */
+
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/all-wcprops ./jp3d/.svn/all-wcprops
--- /home/robin/sldeb/trunk/jp3d/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/all-wcprops	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,59 @@
+K 25
+svn:wc:ra_dav:version-url
+V 28
+/svn/!svn/ver/437/trunk/jp3d
+END
+LICENSE.txt
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/289/trunk/jp3d/LICENSE.txt
+END
+DllJp3dVM.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/289/trunk/jp3d/DllJp3dVM.vcproj
+END
+DllJp3dVM.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/289/trunk/jp3d/DllJp3dVM.dsp
+END
+LibJp3dVM.sln
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/289/trunk/jp3d/LibJp3dVM.sln
+END
+DllJp3dVM.sln
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/289/trunk/jp3d/DllJp3dVM.sln
+END
+README.txt
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/289/trunk/jp3d/README.txt
+END
+LibJp3dVM.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/289/trunk/jp3d/LibJp3dVM.vcproj
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/437/trunk/jp3d/CMakeLists.txt
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/289/trunk/jp3d/Makefile
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/entries ./jp3d/.svn/entries
--- /home/robin/sldeb/trunk/jp3d/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,154 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/jp3d
+http://www.openjpeg.org/svn
+
+
+
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+LICENSE.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+a9203159191b6592396396ac6af92d2d
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+tcltk
+dir
+
+DllJp3dVM.vcproj
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+a44ab5007100142c8cfc16081245e15b
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+DllJp3dVM.dsp
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+03d68083afb752554f7e129b48751b69
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+LibJp3dVM.sln
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+af61fdfaedb1ded24f67bcb90215d436
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+libjp3dvm
+dir
+
+DllJp3dVM.sln
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+ac6ea9e76f91ab7b592ce4922ccc9d5d
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+README.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+6aea87761523f10862d14d118efcd519
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+LibJp3dVM.vcproj
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+ae9c737dc656225e8440a1391a0fc6be
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+codec
+dir
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+826249a4c1d0ded312b96e0a5a18fc4d
+2007-09-06T10:51:38.390778Z
+437
+gdcm
+has-props
+
+Makefile
+file
+
+
+
+
+2007-09-28T10:33:49.000000Z
+ef20dc045c177aace789ae0377c979a8
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/format ./jp3d/.svn/format
--- /home/robin/sldeb/trunk/jp3d/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/format	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/CMakeLists.txt.svn-base ./jp3d/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.dsp.svn-base ./jp3d/.svn/prop-base/DllJp3dVM.dsp.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/DllJp3dVM.dsp.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.sln.svn-base ./jp3d/.svn/prop-base/DllJp3dVM.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/DllJp3dVM.sln.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.vcproj.svn-base ./jp3d/.svn/prop-base/DllJp3dVM.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/DllJp3dVM.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/DllJp3dVM.vcproj.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LibJp3dVM.sln.svn-base ./jp3d/.svn/prop-base/LibJp3dVM.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LibJp3dVM.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/LibJp3dVM.sln.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LibJp3dVM.vcproj.svn-base ./jp3d/.svn/prop-base/LibJp3dVM.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LibJp3dVM.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/LibJp3dVM.vcproj.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LICENSE.txt.svn-base ./jp3d/.svn/prop-base/LICENSE.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/LICENSE.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/LICENSE.txt.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/Makefile.svn-base ./jp3d/.svn/prop-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/Makefile.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/prop-base/README.txt.svn-base ./jp3d/.svn/prop-base/README.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/prop-base/README.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/prop-base/README.txt.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/CMakeLists.txt.svn-base ./jp3d/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,11 @@
+# Linux makefile for OpenJPEG
+
+#VER_MAJOR = 1
+#VER_MINOR = 0.0
+
+SUBDIRS(
+  libjp3dvm
+  codec
+)
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.dsp.svn-base ./jp3d/.svn/text-base/DllJp3dVM.dsp.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/DllJp3dVM.dsp.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,273 @@
+# Microsoft Developer Studio Project File - Name="DllOpenJPEG" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=DllOpenJPEG - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "DllOpenJPEG.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "DllOpenJPEG.mak" CFG="DllOpenJPEG - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "DllOpenJPEG - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "DllOpenJPEG - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "DllOpenJPEG - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "DLLOPENJPEG_EXPORTS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "OPJ_EXPORTS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:"Release/OpenJPEG.dll"
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy libopenjpeg\openjpeg.h dist	copy Release\OpenJPEG.dll dist	copy Release\OpenJPEG.lib dist
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "DllOpenJPEG - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "DLLOPENJPEG_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "OPJ_EXPORTS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:"Debug/OpenJPEGd.dll" /pdbtype:sept
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy libopenjpeg\openjpeg.h dist	copy Debug\OpenJPEGd.dll dist	copy Debug\OpenJPEGd.lib dist
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "DllOpenJPEG - Win32 Release"
+# Name "DllOpenJPEG - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\libopenjpeg\bio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\cio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\dwt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\event.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\image.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k_lib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jp2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jpt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mct.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mqc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\openjpeg.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\pi.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\raw.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t1.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tcd.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tgt.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\OpenJPEG.rc
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.sln.svn-base ./jp3d/.svn/text-base/DllJp3dVM.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/DllJp3dVM.sln.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllOpenJPEG", "DllJp3dVM.vcproj", "{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}.Debug.ActiveCfg = Debug|Win32
+		{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}.Debug.Build.0 = Debug|Win32
+		{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}.Release.ActiveCfg = Release|Win32
+		{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.vcproj.svn-base ./jp3d/.svn/text-base/DllJp3dVM.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/DllJp3dVM.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/DllJp3dVM.vcproj.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,278 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="DllOpenJP3D"
+	ProjectGUID="{790A6CE5-CE92-4A59-ADF7-54A92760BD6C}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="2"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS"
+				StringPooling="TRUE"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Release/OpenJP3D.dll"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				ProgramDatabaseFile=".\Release/OpenJP3D.pdb"
+				ImportLibrary=".\Release/OpenJP3D.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="TRUE"
+				SuppressStartupBanner="TRUE"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/DllOpenJPEG.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist bin mkdir bin
+copy libjp3dvm\openjpeg.h bin
+copy Release\OpenJP3D.dll bin
+copy Release\OpenJP3D.lib bin
+"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="2"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Debug/OpenJP3D.dll"
+				LinkIncremental="1"
+				SuppressStartupBanner="TRUE"
+				GenerateDebugInformation="TRUE"
+				ProgramDatabaseFile=".\Debug/OpenJP3D.pdb"
+				ImportLibrary=".\Debug/OpenJP3D.lib"
+				TargetMachine="1"/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="TRUE"
+				SuppressStartupBanner="TRUE"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/DllOpenJPEG.tlb"
+				HeaderFileName=""/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist bin mkdir bin
+copy libjp3dvm\openjpeg.h bin
+copy Debug\OpenJP3D.dll bin
+"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1034"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCWebDeploymentTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\libjp3dvm\bio.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\cio.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dwt.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\event.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d_lib.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mct.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mqc.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\openjpeg.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\pi.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\raw.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1_3d.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t2.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tcd.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tgt.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\volume.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl">
+			<File
+				RelativePath=".\libjp3dvm\bio.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\cio.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dirent.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dwt.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\event.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\fix.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\int.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d_lib.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mct.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mqc.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\openjpeg.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\opj_includes.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\pi.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\raw.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1_3d.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t2.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tcd.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tgt.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\volume.h">
+			</File>
+		</Filter>
+		<Filter
+			Name="Resource Files"
+			Filter="ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe">
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/LibJp3dVM.sln.svn-base ./jp3d/.svn/text-base/LibJp3dVM.sln.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/LibJp3dVM.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/LibJp3dVM.sln.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,21 @@
+Microsoft Visual Studio Solution File, Format Version 8.00
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibJp3dVM", "LibJp3dVM.vcproj", "{6F3FB035-8F4E-4794-B091-0F0A20223BE7}"
+	ProjectSection(ProjectDependencies) = postProject
+	EndProjectSection
+EndProject
+Global
+	GlobalSection(SolutionConfiguration) = preSolution
+		Debug = Debug
+		Release = Release
+	EndGlobalSection
+	GlobalSection(ProjectConfiguration) = postSolution
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.ActiveCfg = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Debug.Build.0 = Debug|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.ActiveCfg = Release|Win32
+		{6F3FB035-8F4E-4794-B091-0F0A20223BE7}.Release.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ExtensibilityGlobals) = postSolution
+	EndGlobalSection
+	GlobalSection(ExtensibilityAddIns) = postSolution
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/LibJp3dVM.vcproj.svn-base ./jp3d/.svn/text-base/LibJp3dVM.vcproj.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/LibJp3dVM.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/LibJp3dVM.vcproj.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,249 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="7.10"
+	Name="LibJp3dVM"
+	ProjectGUID="{6F3FB035-8F4E-4794-B091-0F0A20223BE7}"
+	SccProjectName=""
+	SccLocalPath="">
+	<Platforms>
+		<Platform
+			Name="Win32"/>
+	</Platforms>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				InlineFunctionExpansion="0"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;OPJ_STATIC"
+				StringPooling="TRUE"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="TRUE"
+				PrecompiledHeaderFile=".\Release/LibJp3dVM.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile=".\Release\LibJp3dVM.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist bin mkdir bin
+copy Release\LibJp3dVM.lib bin
+copy libjp3dvm\openjpeg.h bin
+"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="FALSE"
+			CharacterSet="2">
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;OPJ_STATIC"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/LibJp3dVM.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="TRUE"
+				DebugInformationFormat="4"/>
+			<Tool
+				Name="VCCustomBuildTool"/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile=".\Debug\LibJp3dVM.lib"
+				SuppressStartupBanner="TRUE"/>
+			<Tool
+				Name="VCMIDLTool"/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist bin mkdir bin
+copy Debug\LibJp3dVM.lib bin
+copy libjp3dvm\openjpeg.h bin
+"/>
+			<Tool
+				Name="VCPreBuildEventTool"/>
+			<Tool
+				Name="VCPreLinkEventTool"/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"/>
+			<Tool
+				Name="VCManagedWrapperGeneratorTool"/>
+			<Tool
+				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat">
+			<File
+				RelativePath=".\libjp3dvm\bio.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\cio.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dwt.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\event.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d_lib.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mct.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mqc.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\openjpeg.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\pi.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\raw.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1_3d.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t2.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tcd.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tgt.c">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\volume.c">
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl">
+			<File
+				RelativePath=".\libjp3dvm\bio.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\cio.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dirent.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\dwt.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\event.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\fix.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\int.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\jp3d_lib.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mct.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\mqc.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\openjpeg.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\opj_includes.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\pi.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\raw.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t1_3d.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\t2.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tcd.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\tgt.h">
+			</File>
+			<File
+				RelativePath=".\libjp3dvm\volume.h">
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/LICENSE.txt.svn-base ./jp3d/.svn/text-base/LICENSE.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/LICENSE.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/LICENSE.txt.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,30 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herv Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2006, Mónica Díez, Image Processing Laboratory (LPI) - University of Valladolid, Spain
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ * notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ * notice, this list of conditions and the following disclaimer in the
+ * documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/Makefile.svn-base ./jp3d/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/Makefile.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,72 @@
+# Linux makefile for OpenJPEG
+
+VER_MAJOR = 1
+VER_MINOR = 0.0
+
+SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
+INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_includes.h
+INCLUDE = -Ilibopenjpeg
+
+# General configuration variables:
+CC = gcc
+AR = ar
+
+INSTALLDIR = /usr/lib
+
+# Converts cr/lf to just lf
+DOS2UNIX = dos2unix
+
+COMPILERFLAGS = -O3
+LIBRARIES = -lstdc++
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE)
+
+TARGET  = openjpeg
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
+LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
+
+
+
+default: all
+
+all: dist
+
+dist: OpenJPEG
+	mkdir dist
+	cp *.a dist/
+	cp *.so dist/
+	cp libopenjpeg/openjpeg.h dist/
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+OpenJPEG: $(STATICLIB) $(SHAREDLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(AR) r $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
+
+install:
+	install -m 644 -o root -g root $(STATICLIB) $(INSTALLDIR)
+	install -m 755 -o root -g root $(SHAREDLIB) $(INSTALLDIR)
+	ln -sf $(SHAREDLIB) $(INSTALLDIR)/$(LIBNAME)
+	ldconfig
+
+clean:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+
+osx:
+	make -f Makefile.osx
+
+osxinstall:
+	make -f Makefile.osx install
+
+osxclean:
+	make -f Makefile.osx clean
diff -urN /home/robin/sldeb/trunk/jp3d/.svn/text-base/README.txt.svn-base ./jp3d/.svn/text-base/README.txt.svn-base
--- /home/robin/sldeb/trunk/jp3d/.svn/text-base/README.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/.svn/text-base/README.txt.svn-base	2007-09-28 11:33:46.000000000 +0100
@@ -0,0 +1,285 @@
+===============================================================================
+	JPEG2000 Part 10 (ISO/IEC 15444-10 JP3D) Verification Model
+
+				Version 1.1
+===============================================================================
+
+
+1. Scope
+================
+
+This document describes the installation and the use of the JP3D VM decoder and encoder under several operating systems (Linux, Unix, Windows, ...). Version 1.1 contains a complete JPEG 2000 Part 10 encoder, as well as a decoder.
+The supported functionalities are compliant with the JPEG2000 part 10 algorithm as described in the WD 6.0.
+The provided encoder and the decoder are compatible also with the International standard IS 15444-1 (core coding system).
+This implementation has been developped from OpenJPEG implementation of JPEG2000 standard, and for this reason it is written in C language. 
+
+If you find some bugs or if you have problems using the encoder/decoder, please send an e-mail to jp3d@lpi.tel.uva.es
+
+2. Installing the code 
+======================================================
+
+- After decompressing the zip file provided, you should find 
+at least the following files in the created 'jp3d_vm' directory:
+
+ * libjp3dvm - This directory contains all library related code
+ * codec - This directory contains all codec related code
+ * tcltk - This directory contains the API scripts
+ * README - The file you are reading
+ * LICENCE - Copyright statement of the JP3D VM software
+
+2.1. Compiling the source code in Windows
+-------------------------------------------
+
+This version has been compiled with Visual Studio 2003 using
+the projects included in the distribution:
+
+ * LibJp3dVM.vcproj - Creates the library with all the JP3D functionalities
+ * jp3d_vm_enc.vcproj - Test encoder 
+ * jp3d_vm_dec.vcproj - Test decoder 
+
+2.2. Compiling the source code in Unix-like systems
+-------------------------------------------
+
+Library compilation
+------------------------
+This version of the library has been tested under the following OS:
+- Fedora Core 
+
+The installation process is as simple as this : 
+1) Enter the 'jp3d_vm' directory
+2) Build the distribution : 
+make
+make install
+3) Clean all files produced during the build process
+make clean
+
+Codec compilation
+------------------------
+Once you've built the library, you should compile the JP3D codec.
+
+1) Go to the 'codec' directory 
+2) Build the encoder and decoder programs:
+
+gcc convert.c volume_to_jp3d.c -o jp3d_vm_enc -I ../libjp3dvm/ -lm -ljp3dvm
+gcc convert.c jp3d_to_volume.c -o jp3d_vm_dec -I ../libjp3dvm/ -lm -ljp3dvm
+
+Note: You should add '-L ../libjp3dvm/' to those lines if you
+did not use the 'install' target (and the 'clean' target neither...).
+
+3. Running the JP3D VM
+====================================================
+
+3.1. JP3D ENCODER
+====================================================
+
+Required arguments
+------------------------
+
+ * Input file(s): -i Involume [*.bin, *.pgx]
+
+Specifies the volume to compress. Accepted formats are *.BIN (raw binary data) or *.PGX files.
+Both formats need some particular settings:
+
+  a) BIN format. As it has no header, volume characteristics will be obtained from a .IMG file. Its location will be specified through the following argument:
+	   -m Involumeinfo.IMG
+     This file shall have the following structure, with the appropiate value in each case (bit per voxel, color map, dimensions in X,Y,Z):
+	o Bpp	%d
+	o Color Map	%d
+	o Dimensions	%d %d %d
+
+  b) PGX format. Program will consider it as a volume slice. In order to denote a volume through a sequence of slices, you can define the input filename with the common pattern of the set of PGX files followed by a dash (as a wildcard character for the sequence numbers).
+	
+ * Output file: -o Outfile [*.jp3d, *j2k]
+
+Specifies the name of the file where the codestream will be saved. 
+Part 1 compliant codestream will be created when an outfile has .j2k format.
+
+Options 
+--------
+
+    * Rate values : -r 20,10,5
+      This option offers the possibility to define the compression rate to apply. 
+      Each value is a factor of compression (i.e. 20 : 1) and will generate a different quality layer. A lossless compression will be signified by the value 1.
+      NOTE : The order used to define the different levels of compression is important and must be from left to right in descending order.
+
+    * Quality values : -q 30,35,40
+      This option offers the possibility to define the quality level to achieve. Each value is a psnr, to be given in dB, and represents a quality layer. 
+      NOTE : The order used to define the different psnr-values is important and must be from left to right in ascending order.
+
+
+    * Number of resolutions : -n 3,3,2
+      This option offers the possibility to define the number of resolution levels computed for each dimension of the volume through the discret wavelet transform (DWT). Resolution in axial dimension can have a different value than in horizontal and vertical cases, but must be lower.
+      DEFAULT VALUE : 3,3,1 
+
+
+    * Switch modes : -M 3
+      This option offers the possibility to use a mode switch during the encoding process:
+          o BYPASS(LAZY)	[1]
+          o RESET		[2]
+          o RESTART(TERMALL)	[4]
+          o VSC			[8]
+          o ERTERM(SEGTERM)	[16]
+          o SEGMARK(SEGSYM)	[32]
+          o 3D_CONTEXT		[64]
+      For several mode switch just sum corresponding values: i.e. -M 38  => RESTART(4) + RESET(2) + SEGMARK(32)
+      DEFAULT VALUE: 0
+
+
+    * Progression order : -p LRCP
+      This option offers the possibility to specify the progression order. Possible progression orders are : LRCP, RLCP, RPCL, PCRL and CPRL.
+      DEFAULT VALUE: LRCP.
+
+
+    * Code-block size : -b 32,32,32
+      This option offers the possibility to define the size of the code-block. The dimension must respect the constraint defined in the JPEG-2000 standard. The maximum value autorized is 64x64x64.
+      DEFAULT VALUE: 64,64,64
+
+
+    * Precinct size : -c [128,128,128],[128,128,128],...
+      This option offers the possibility to define the size of the precincts at each resolution. Multiple records may be supplied, in which case the first record refers to the highest resolution level and subsequent records to lower resolution levels. The last specified record is right-shifted for each remaining lower resolution levels.
+      NOTE : specified values must be power of 2.
+      DEFAULT VALUE: 2^15 x 2^15 x 2^15
+
+
+    * Tile size : -t 512,512,512
+      This option offers the possibility to divide the volume in several tiles. The three values define the width, the heigth and the depth of the tile respectivily. 
+      DEFAULT VALUE: Volume dimensions (one tile)
+
+
+    * Subsampling factor : -s 2,2,2
+      This option offers the possibility to apply a subsampling factor for X, Y and Z axis. Value higher than 2 can be a source of error ! 
+      DEFAULT VALUE: 1,1,1
+
+
+    * SOP marker before each packet : -SOP
+      This option offers the possibility to add a specific marker before each packet. It is the marker SOP (Start of packet). If the option is not used no SOP marker will be added.
+
+
+    * EPH marker after each packet header : -EPH
+      This option offers the possibility to add a specific marker at the head of each packet header. It is the marker EPH (End of packet Header). If the option is not used no EPH marker will be added.
+
+
+    * Offset of the volume origin : -d 150,300,10
+      This option offers the possibility to move the origine of the volume in X, Y and/or Z axis. The division in tile could be modified as the anchor point for tiling will be different than the volume origin.
+      NOTE : the offset of the volume can not be higher than the tile dimension if the tile option is used.
+      DEFAULT VALUE: 0,0,0
+
+
+    * Offset of the tile origin : -T 100,75,5
+      This option offers the possibility to move the anchor point of the volume in X, Y and/or Z axis.
+      NOTE : the tile anchor point can not be on the volume area.
+      DEFAULT VALUE: 0,0,0
+
+
+    * Display the help menu : -help
+      This option displays on screen the content of this page
+
+Additional options 
+----------------------------------
+
+    * Encoding information file: -x index_name.idx
+      This option offers the possibility to create a text file with some structured information generated through the encoding. The name of the file must be specified, with .idx extension. The information structure is the following: 
+          o Volume size:
+                + VolW   + VolH   + VolD
+          o Progression Order:
+                + Prog
+          o Tile size: 
+                + TileW   + TileH   + TileD
+          o Number of components:
+                + NumComp
+          o Number of layers:
+                + NumLayer
+          o Number of decompositions (=(number of resolutions - 1)):
+                + NumDWTx   + NumDWTy   + NumDWTz
+          o Precinct size:
+                + [Precinct_width(NumDWT),Precinct_height(NumDWT),Precinct_depth(NumDWT)]
+                + [Precinct_width(NumDWT-1),Precinct_height(NumDWT-1),Precinct_depth(NumDWT-1)]
+                + ...
+                + [Precinct_width(0),Precinct_height(0),Precinct_depth(0)] 
+          o Main Header end position:
+                + MH_EndPos
+          o Codestream size:
+                + CSSize
+          o Tile 0 information:
+                + TileNum (0) 
+                + StartPos
+                + TileHeader_EndPos
+                + EndPos
+                + TotalDisto (this is the sum of the distortion reductions brought by each packet belonging to this tile)
+                + NumPix (this is the number of pixels in the tile)
+                + MaxMSE (=TotalDisto/NumPix)
+          o Tile1 information:
+                + TileNum (1)
+                + ...
+          o ...
+          o Tile N information:
+                + TileNum (N)
+                + ...
+          o Packet 0 from Tile 0 information:
+                + PackNum (0)
+                + TileNum (0) 
+                + LayerNum
+                + ResNum
+                + CompNum
+                + PrecNum
+                + StartPos
+                + EndPos
+                + Disto (distortion reduction brought by this packet)
+          o Packet 1 from Tile 0 information:
+                + PackNum (1)
+                + ...
+          o ...
+          o Packet M from Tile 0 information
+          o Packet 0 from Tile 1 information
+          o ...
+          o Packet M from Tile N information
+          o Maximum distortion reduction on the whole volume:
+                + MaxDisto
+          o Total distortion on the whole volume (sum of the distortion reductions from all packets in the volume):
+                + TotalDisto
+
+3.2. JP3D DECODER
+====================================================
+
+Required arguments
+------------------------
+
+    * Infile : -i compressed file
+      Currently accepts JP3D and J2K-files. The file type is identified based on its suffix (*.jp3d, *.j2k).
+
+
+    * Outfile(s) : -o decompressed file(s)
+      Currently accepts BIN-files and PGX-files. Binary data is written to the file (not ascii). 
+      If a BIN-file is defined, decoder will create automatically the volume characteristic file appending a .IMG extension to the provided output filename.
+      If a PGX-file is defined, decoder will understand this as a file pattern, appending corresponding indice from 0 to the number of decoded slices.
+      NOTE : There will be as many output files as there are components: an indice starting from 0 will then be appended to the output filename, just before the extension.
+
+
+Options available
+------------------------
+
+    * Reduce factor : -r 1,1,0
+      Set the number of highest resolution levels to be discarded in each dimension. The decoded volume size is effectively divided by 2 to the power of the number of discarded levels. 
+      NOTE : The reduce factor is limited by the smallest total number of decomposition levels among tiles.
+
+
+    * Layer number : -l 2
+      Set the maximum number of quality layers to decode. If there are less quality layers than the specified number, all the quality layers are decoded.
+
+
+    * Performance comparisons : -O original-file
+      This option offers the possibility to compute some quality results for the decompressed volume, like the PSNR value achieved or the global SSIM value. Needs the original file in order to compare with the new one.
+      NOTE: Only valid when -r option is 0,0,0 (both original and decompressed volumes have same resolutions)
+      NOTE: If original file is .BIN file, the volume characteristics file shall be defined with the -m option.
+	    (i.e. -O original-BIN-file -m original-IMG-file)
+
+
+    * Byte order (Big-endian / Little-endian) : -BE
+      This option offers the possibility to save the decompressed volume with a predefined byte order. 
+      DEFAULT VALUE: Little-endian
+
+
+    * Display the help menu : -help
+      This option displays on screen the content of this page
+
+
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/all-wcprops ./jp3d/tcltk/.svn/all-wcprops
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/all-wcprops	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,35 @@
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/289/trunk/jp3d/tcltk
+END
+encoder.tcl
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/tcltk/encoder.tcl
+END
+Thumbs.db
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/289/trunk/jp3d/tcltk/Thumbs.db
+END
+decoder.tcl
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/tcltk/decoder.tcl
+END
+LPI_JP3D_VM.tcl
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/289/trunk/jp3d/tcltk/LPI_JP3D_VM.tcl
+END
+logoLPI.gif
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/289/trunk/jp3d/tcltk/logoLPI.gif
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/entries ./jp3d/tcltk/.svn/entries
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,93 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/jp3d/tcltk
+http://www.openjpeg.org/svn
+
+
+
+2006-10-30T15:32:50.084611Z
+289
+antonin
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+encoder.tcl
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+ab97c6f73d12e5eee30e24839879e1cd
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+Thumbs.db
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+7605e08cdd2202ed61e2fe97d113a39a
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+decoder.tcl
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+99b321d9d1b5cda33d5a771d8dced0ea
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+LPI_JP3D_VM.tcl
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+ba082e3a6b9c7ba90790086bb192c80a
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
+logoLPI.gif
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+f274e8cfe6c8bf0a6249b390ee5b9307
+2006-10-30T15:32:50.084611Z
+289
+antonin
+has-props
+
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/format ./jp3d/tcltk/.svn/format
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/format	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/decoder.tcl.svn-base ./jp3d/tcltk/.svn/prop-base/decoder.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/decoder.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/prop-base/decoder.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/encoder.tcl.svn-base ./jp3d/tcltk/.svn/prop-base/encoder.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/encoder.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/prop-base/encoder.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/logoLPI.gif.svn-base ./jp3d/tcltk/.svn/prop-base/logoLPI.gif.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/logoLPI.gif.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/prop-base/logoLPI.gif.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/LPI_JP3D_VM.tcl.svn-base ./jp3d/tcltk/.svn/prop-base/LPI_JP3D_VM.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/LPI_JP3D_VM.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/prop-base/LPI_JP3D_VM.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/Thumbs.db.svn-base ./jp3d/tcltk/.svn/prop-base/Thumbs.db.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/prop-base/Thumbs.db.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/prop-base/Thumbs.db.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/decoder.tcl.svn-base ./jp3d/tcltk/.svn/text-base/decoder.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/decoder.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/text-base/decoder.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,272 @@
+
+namespace eval VMDecoder {
+	variable var
+	variable JP3Ddecoder "../bin/jp3d_vm_dec.exe"
+	#variable JP3Ddecoder "jp3d_vm_dec.exe"
+}
+
+
+proc VMDecoder::create { nb } {
+	variable var
+
+	set frameD [$nb insert end VMDecoder -text "Decoder"]
+	set topfD	[frame $frameD.topfD]
+	set medfD	[frame $frameD.medfD]
+	set bottomfD	[frame $frameD.bottomfD]
+	set srcfD [TitleFrame $topfD.srcfD -text "Source"]
+	set dstfD [TitleFrame $topfD.dstfD -text "Destination"]
+	set paramfD [TitleFrame $medfD.paramfD -text "Decoding parameters"]
+	set infofD [TitleFrame $medfD.infofD -text "Distortion measures"]
+
+	set frame1 [$srcfD getframe]
+	_sourceD  $frame1
+	set frame2  [$dstfD getframe]
+	_destinationD  $frame2
+	set frame3  [$infofD getframe]
+	_originalD $frame3
+	set frame4  [$paramfD getframe]
+	_paramsD $frame4
+
+	set butD   [Button $bottomfD.butD -text "Decode!" \
+		   -command  "VMDecoder::_decode $frame1 $frame2 $frame3" \
+		   -helptext "Decoding trigger button"]
+	set butR   [Button $bottomfD.butR -text "Save info" \
+		   -command  "VMDecoder::_save $frame3" \
+		   -helptext "Save information"]
+	
+	pack $srcfD $dstfD -side left -fill both -padx 10 -ipadx 5 -expand yes
+	pack $topfD -pady 4 -fill x
+	
+	pack $paramfD $infofD -side left -fill both -padx 10 -pady 2 -ipadx 5 -expand yes
+	pack $medfD -pady 4 -fill x 
+
+	pack $butD $butR -side left -padx 4 -pady 5 -expand yes
+	pack $bottomfD -pady 4 -fill x
+
+return $frameD
+}
+
+
+proc fileDialogD {w ent operation} {
+
+	variable file
+	
+	if {$operation == "open"} {
+		#-----Type names---------Extension(s)---
+		set types {
+		{"JP3D Files"	   {.jp3d}	}
+		{"All files"		*}
+		}
+		set file [tk_getOpenFile -filetypes $types -parent $w ]
+	} elseif {$operation == "original"} {
+		#-----Type names---------Extension(s)---
+		set types {
+		{"BIN Raw Image Files"  {.bin}  }
+		{"PGX Raw Image Files"	{.pgx}	}
+		{"All files"		*}
+		}
+		set file [tk_getOpenFile -filetypes $types -parent $w ]
+	} else {
+		#-----Type names---------Extension(s)---
+		set types {
+		{"BIN Raw Image Files"  {.bin}  }
+		{"PGX Raw Image Files"	{.pgx}	}
+		{"All files"		*}
+		}
+		set file [tk_getSaveFile -filetypes $types -parent $w -initialfile Untitled -defaultextension "*.bin"]
+	}
+	if {[string compare $file ""]} {
+		$ent delete 0 end
+		$ent insert end $file
+		$ent xview moveto 1
+	}
+}
+
+proc VMDecoder::_sourceD { parent } {
+	
+	variable var
+	
+	set labsrcD [LabelFrame $parent.labsrcD -text "Select compressed file: " -side top \
+			-anchor w -relief flat -borderwidth 0]
+	set subsrcD [$labsrcD getframe]
+	set listD [entry $subsrcD.entrysrcD -width 40 -textvariable VMDecoder::var(sourceD)]
+	
+	set labbrw [LabelFrame $parent.labbrw -side top -anchor w -relief flat -borderwidth 0]
+	set subbrw [$labbrw getframe]
+	set butbrw [button $subbrw.butbrw -image [Bitmap::get open] \
+		-relief raised -borderwidth 1 -padx 1 -pady 1 \
+		-command "fileDialogD . $subsrcD.entrysrcD open"]
+	
+	pack $listD -side top
+	pack $butbrw -side top
+	pack $labsrcD $labbrw -side left -fill both -expand yes
+
+
+}
+
+proc VMDecoder::_destinationD { parent } {
+	
+	variable var
+	
+	set labdstD [LabelFrame $parent.labdstD -text "Save decompressed volume file(s) as: " -side top \
+			-anchor w -relief flat -borderwidth 0]
+	set subdstD [$labdstD getframe]
+	set listD [entry $subdstD.entrydstD -width 40 -textvariable VMDecoder::var(destinationD)]
+	
+	set labbrw [LabelFrame $parent.labbrw -side top -anchor w -relief flat -borderwidth 0]
+	set subbrw [$labbrw getframe]
+	set butbrw [button $subbrw.butbrw -image [Bitmap::get save] \
+		-relief raised -borderwidth 1 -padx 1 -pady 1 \
+		-command "fileDialogD . $subdstD.entrydstD save"]
+
+	pack $listD -side top
+	pack $butbrw -side top
+	pack $labdstD $labbrw -side left -fill both -expand yes
+}
+
+proc VMDecoder::_originalD { parent } {
+	
+	variable var
+	
+	set laborgD [LabelFrame $parent.laborgD -text "Select original file: " -side top \
+			-anchor w -relief flat -borderwidth 0]
+	set suborgD [$laborgD getframe]
+	set listorgD [entry $suborgD.entryorgD -width 30 -textvariable VMDecoder::var(originalD)]
+	
+	set labbrw2 [LabelFrame $parent.labbrw2 -side top -anchor w -relief flat -borderwidth 0]
+	set subbrw2 [$labbrw2 getframe]
+	set butbrw2 [button $subbrw2.butbrw2 -image [Bitmap::get open] \
+		-relief raised -borderwidth 1 -padx 1 -pady 1 \
+		-command "fileDialogD . $suborgD.entryorgD original"]
+	
+	set infoD [Label $parent.infoD -relief sunken -textvariable VMDecoder::var(decodinfo) -justify left]
+
+	pack $listorgD -side left -anchor n
+	pack $butbrw2 -side left -anchor n
+	pack $infoD -side bottom -anchor nw -pady 4 -ipadx 150 -ipady 20 -expand yes
+	pack $laborgD $labbrw2 -side left -fill both 
+
+
+}
+
+proc VMDecoder::_paramsD { parent } {
+	
+	variable var
+	
+	########### DECODING  #############
+	set labcod [LabelFrame $parent.labcod -side top -anchor w -relief sunken -borderwidth 1]
+	set subcod  [$labcod getframe]
+
+		set frameres [frame $subcod.frameres -borderwidth 1]
+		set labres [LabelEntry $frameres.labres -label "Resolutions to discard: " -labelwidth 20 -labelanchor w \
+                   -textvariable VMDecoder::var(resdiscard) -editable 1 \
+                   -helptext "Number of highest resolution levels to be discarded on each dimension" ]
+	set VMDecoder::var(resdiscard) "0,0,0"
+	
+		set framelayer [frame $subcod.framelayer -borderwidth 1]
+		set lablayer [LabelEntry $framelayer.lablayer -label "Layers to decode: " -labelwidth 20 -labelanchor w \
+                   -textvariable VMDecoder::var(layer) -editable 1 \
+                   -helptext "Maximum number of quality layers to decode" ]
+	set VMDecoder::var(layer) "All"
+
+	set framebe [frame $subcod.framebe -borderwidth 1]
+	set chkbe [checkbutton $framebe.chkbe -text "Write decoded file with BigEndian byte order" \
+		   -variable VMDecoder::var(be) -onvalue 1 -offvalue 0 ]
+
+		pack $labres -side left -padx 2 -anchor n
+		pack $lablayer -side left -padx 2 -anchor n
+		pack $chkbe -side left -padx 2 -anchor w
+		pack $frameres $framelayer $framebe -side top -anchor w
+
+	pack $subcod -anchor n
+	pack $labcod -side left -fill both -padx 4 -expand yes
+}
+
+
+proc VMDecoder::_decode { framesrc framedst frameinfo} {
+
+	variable var
+
+	set sourceD [$framesrc.labsrcD.f.entrysrcD get ]
+	set destinationD [$framedst.labdstD.f.entrydstD get ]
+	set originD [$frameinfo.laborgD.f.entryorgD get ]
+	set cond1 [string match *.pgx [string tolower $destinationD]]
+	set cond2 [string match *\**.pgx [string tolower $destinationD]]
+	set cond3 [string match *.bin [string tolower $destinationD]]
+	
+	#comprobamos datos son correctos
+	if {($cond1 == 1) && ($cond2 == 0)} {
+		set pgx "*.pgx"
+		set pattern [string range $destinationD 0 [expr [string length $destinationD]-5]]
+		set destinationD $pattern$img
+	} elseif {$sourceD == ""} {
+	  MessageDlg .msgdlg -parent . -message "Error : Source file is not defined !" -type ok -icon error 
+	} elseif {$destinationD == ""} {
+	  MessageDlg .msgdlg -parent . -message "Error : Destination file is not defined !" -type ok -icon error 
+	} else {
+
+		#creamos datain a partir de los parametros de entrada
+		#set dirJP3Ddecoder [mk_relativepath $VMDecoder::JP3Ddecoder]
+		set dirJP3Ddecoder $VMDecoder::JP3Ddecoder
+		set datain [concat " $dirJP3Ddecoder -i [mk_relativepath $sourceD] "]
+		set datain [concat " $datain -o [mk_relativepath $destinationD] "]
+		if {$originD != ""} {
+			set datain [concat " $datain -O [mk_relativepath $originD] "]
+			if {$cond3 == 1} {
+				set img ".img"
+				set pattern [string range $originD 0 [expr [string length $originD]-5]]
+				set pattern $pattern$img
+				if {[file exists $pattern]} {
+				  set datain [concat " $datain -m [mk_relativepath $pattern] "]
+				} else {
+				  MessageDlg .msgdlg -parent . -message "Error : IMG file associated to original BIN volume file not found in same directory !" -type ok -icon info 
+				}
+			}
+		}
+		if {$VMDecoder::var(resdiscard) != "0,0,0"} {
+			set datain [concat " $datain -r $VMDecoder::var(resdiscard) "]
+		}
+		if {$VMDecoder::var(layer) != "All" && $VMDecoder::var(layer) > 0} {
+			set datain [concat " $datain -l $VMDecoder::var(layer) "]
+		}
+		if {$VMDecoder::var(be) == 1} {
+			set datain [concat " $datain -BE"]
+		}
+		
+		set VMDecoder::var(progval) 10
+		ProgressDlg .progress -parent . -title "Wait..." \
+			-type         infinite \
+			-width        20 \
+			-textvariable "Compute in progress..."\
+			-variable     VMDecoder::progval \
+			-stop         "Stop" \
+			-command      {destroy .progress}
+
+		after 200 set VMDecoder::var(progval) 2
+
+		set fp [open "| $datain " r+] 
+		fconfigure $fp -buffering line 
+		set jp3dVM::dataout [concat "EXECUTED PROGRAM:\n\t$datain"]
+		while {-1 != [gets $fp tmp]} {
+			set jp3dVM::dataout [concat "$jp3dVM::dataout\n$tmp"]
+		}
+		close $fp
+		destroy .progress
+		set cond [string first "ERROR" $jp3dVM::dataout]
+		set cond2 [string first "PSNR" $jp3dVM::dataout]
+		set cond3 [string first "RESULT" $jp3dVM::dataout]
+		if {$cond != -1} {
+		   MessageDlg .msgdlg -parent . -message [string range $jp3dVM::dataout [expr $cond-1] end] -type ok -icon error
+		} elseif {$cond3 != -1} {
+			if {$cond2 != -1} {
+				set VMDecoder::var(decodinfo) [string range $jp3dVM::dataout [expr $cond2-1] end]
+			}
+			MessageDlg .msgdlg -parent . -message [string range $jp3dVM::dataout [expr $cond3-1] end] -type ok -icon info
+		}
+	}
+}
+
+proc VMDecoder::_save { frameinfo } {
+
+}
+
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/encoder.tcl.svn-base ./jp3d/tcltk/.svn/text-base/encoder.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/encoder.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/text-base/encoder.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,470 @@
+
+namespace eval VMEncoder {
+	variable var
+	variable JP3Dencoder "../bin/jp3d_vm_enc.exe"
+}
+
+proc VMEncoder::create { nb } {
+
+	set frame [$nb insert end VMEncoder -text "Encoder"]
+	set topf	[frame $frame.topf]
+	set midf	[frame $frame.midf]
+	set bottomf	[frame $frame.bottomf]
+	set srcf [TitleFrame $topf.srcf -text "Source"]
+	set dstf [TitleFrame $topf.dstf -text "Destination"]
+	set Tparf [TitleFrame $midf.parfT -text "Transform Parameters"]
+	set Cparf [TitleFrame $midf.parfC -text "Coding Parameters"]
+
+	set frame1 [$srcf getframe]
+		VMEncoder::_sourceE  $frame1
+	
+	set frame2  [$dstf getframe]
+		VMEncoder::_destinationE  $frame2
+	
+	set frame3  [$Tparf getframe]
+		VMEncoder::_transformE $frame3
+
+	set frame4  [$Cparf getframe]
+		VMEncoder::_codingE $frame4
+	
+	set butE  [Button $bottomf.butE -text "Encode!" \
+		   -command  "VMEncoder::_encode $frame1 $frame2" \
+		   -helptext "Encoding trigger button"]
+	set butR  [Button $bottomf.butR -text "Restore defaults" \
+		   -command  "VMEncoder::_reset $frame1 $frame2 $frame3 $frame4" \
+		   -helptext "Reset to default values"]
+
+	pack $srcf $dstf -side left -fill y -padx 4 -expand yes
+	pack $topf -pady 2 -fill x
+
+	pack $Tparf $Cparf -side left -fill both -padx 4 -expand yes
+	pack $midf -pady 2 -fill x
+	
+	pack $butE $butR -side left -padx 40 -pady 5 -fill y -expand yes
+	pack $bottomf -pady 2 -fill x
+
+	return $frame
+}
+
+proc VMEncoder::_sourceE { parent } {
+
+	variable var
+
+	set labsrc [LabelFrame $parent.labsrc -text "Select volume file to encode: " -side top \
+			-anchor w -relief flat -borderwidth 0]
+	set subsrc [$labsrc getframe]
+	set list [entry $subsrc.entrysrc -width 30 -textvariable VMDecoder::var(source)]
+	
+	set labbrw [LabelFrame $parent.labbrw -side top -anchor w -relief flat -borderwidth 0]
+	set subbrw [$labbrw getframe]
+	set butbrw [button $subbrw.butbrw -image [Bitmap::get open] \
+		-relief raised -borderwidth 1 -padx 1 -pady 1 \
+		-command "fileDialogE . $subsrc.entrysrc open"]
+	
+	pack $list -side top
+	pack $butbrw -side top
+	pack $labsrc $labbrw -side left -fill both -expand yes
+}
+
+proc VMEncoder::_destinationE { parent } {
+
+	variable var
+
+	set labdst [LabelFrame $parent.labdst -text "Save compressed volume as: " -side top \
+			-anchor w -relief flat -borderwidth 0]
+	set subdst [$labdst getframe]
+	set list [entry $subdst.entrydst -width 30 -textvariable VMDecoder::var(destination)]
+	
+	set labbrw [LabelFrame $parent.labbrw -side top -anchor w -relief flat -borderwidth 0]
+	set subbrw [$labbrw getframe]
+	set butbrw [button $subbrw.butbrw -image [Bitmap::get save] \
+		-relief raised -borderwidth 1 -padx 1 -pady 1 \
+		-command "fileDialogE . $subdst.entrydst save"]
+	
+	pack $list -side top
+	pack $butbrw -side top
+	pack $labdst $labbrw -side left -fill both -expand yes
+}
+
+proc VMEncoder::_codingE { parent } {
+
+	
+	########### CODING  #############
+	set labcod [LabelFrame $parent.labcod -side top -anchor w -relief sunken -borderwidth 1]
+	set subcod  [$labcod getframe]
+
+		set framerate [frame $subcod.framerate -borderwidth 1]
+		set labrate [LabelEntry $framerate.labrate -label "Rates: " -labelwidth 9 -labelanchor w \
+                   -textvariable VMEncoder::var(rate) -editable 1 \
+                   -helptext "Compression ratios for different layers (R1, R2, R3,...). If R=1, lossless coding" ]
+	set VMEncoder::var(rate) "1"
+
+		set framecblk [frame $subcod.framecblk -borderwidth 1]
+		set labcblk [LabelEntry $framecblk.labcblk -label "Codeblock: " -labelwidth 9 -labelanchor w \
+                   -textvariable VMEncoder::var(cblksize) -editable 1 \
+                   -helptext "Codeblock size (X, Y, Z)" ]
+	set VMEncoder::var(cblksize) "64,64,64"
+
+		set frametile [frame $subcod.frametile -borderwidth 1]
+		set labtile [LabelEntry $frametile.labtile -label "Tile size: " -labelwidth 9 -labelanchor w \
+                   -textvariable VMEncoder::var(tilesize) -editable 1 \
+                   -helptext "Tile size (X, Y, Z)" ]
+	set VMEncoder::var(tilesize) "512,512,512"
+
+		set framesop [frame $subcod.framesop -borderwidth 1]
+		set chksop [checkbutton $framesop.chksop -text "Write SOP marker" \
+			   -variable VMEncoder::var(sop) -onvalue 1 -offvalue 0 ]
+		set frameeph [frame $subcod.frameeph -borderwidth 1]
+		set chkeph [checkbutton $frameeph.chkeph -text "Write EPH marker" \
+			   -variable VMEncoder::var(eph) -onvalue 1 -offvalue 0 ]
+	
+		set framepoc [frame $subcod.framepoc -borderwidth 1]
+		set labpoc [label $framepoc.labpoc -text "Progression order: " ]
+		set progorder [ComboBox $framepoc.progorder \
+			   -text {Choose a progression order} \
+			   -width 10 \
+			   -textvariable VMEncoder::var(progorder) \
+			   -values {"LRCP" "RLCP" "RPCL" "PCRL" "CPRL"} \
+			   -helptext "Progression order"]
+		set VMEncoder::var(progorder) "LRCP"
+
+		pack $labrate -side left -padx 2 -anchor n
+		pack $labcblk -side left -padx 2 -anchor n
+		pack $labpoc $progorder -side left -padx 2 -anchor w
+		#pack $labtile -side left -padx 2 -anchor n
+		pack $chksop -side left -padx 2 -anchor w
+		pack $chkeph -side left -padx 2 -anchor w
+	########### ENTROPY CODING  #############
+	set labent [LabelFrame $parent.labent -text "Entropy Coding" -side top -anchor w -relief sunken -borderwidth 1]
+	set subent  [$labent getframe]
+		foreach entval {2EB 3EB} entropy {2D_EBCOT 3D_EBCOT} {
+			set rad [radiobutton $subent.$entval \
+				-text $entropy \
+				-variable VMEncoder::var(encoding) \
+				-command "disableGR $entval $labcblk $progorder $labrate $chksop $chkeph" \
+				-value $entval ]
+			pack $rad -anchor w
+		}
+		$subent.2EB select 
+
+	pack $subent -padx 2 -anchor n
+
+	pack $framerate $framecblk $framepoc $framesop $frameeph -side top -anchor w
+	pack $subcod -anchor n
+
+	pack $labent $labcod -side left -fill both -padx 4 -expand yes
+
+
+}
+
+proc VMEncoder::_transformE { parent } {
+
+	variable var
+
+	########### TRANSFORM  #############
+	set labtrf [LabelFrame $parent.labtrf -text "Transform" -side top -anchor w -relief sunken -borderwidth 1]
+	set subtrf  [$labtrf getframe]
+	set labres [LabelFrame $parent.labres -side top -anchor w -relief sunken -borderwidth 1]
+	set subres [$labres getframe]
+		
+		########### ATK #############
+		set frameatk [frame $subres.frameatk -borderwidth 1]
+		set labatk [label $frameatk.labatk -text "Wavelet kernel:  " -anchor w]
+		set atk [ComboBox $frameatk.atk \
+				-textvariable VMEncoder::var(atk) \
+				-width 20 \
+				-text {Choose a wavelet kernel} \
+				-editable false \
+				-values {"R5.3" "I9.7"} ]
+		set VMEncoder::var(atk) "R5.3"
+		pack $labatk $atk -side left -anchor w
+		########### RESOLUTIONS #############
+		set frameres1 [frame $subres.frameres1 -borderwidth 1]
+		set labresolution [label $frameres1.labresol -text "Resolutions: " -anchor w ]
+		set frameres2 [frame $subres.frameres2 -borderwidth 1]
+		set labresX [label $frameres2.labresX -text "  X" -anchor w ]
+		set labresY [label $frameres2.labresY -text "  Y" -anchor w ]
+		set labresZ [label $frameres2.labresZ -text "  Z" -anchor w ]
+		
+
+		set resX [SpinBox $frameres2.spinresX \
+				-range {1 6 1} -textvariable VMEncoder::var(resX) \
+				-helptext "Number of resolutions in X" \
+				-width 3 \
+				-editable false ]
+ 		set resY [SpinBox $frameres2.spinresY \
+				-range {1 6 1} -textvariable VMEncoder::var(resY) \
+				-helptext "Number of resolutions in Y" \
+				-width 3 \
+				-editable false ]
+		set resZ [SpinBox $frameres2.spinresZ \
+				-range {1 6 1} -textvariable VMEncoder::var(resZ) \
+				-helptext "Number of resolutions in Z" \
+				-width 3 \
+				-editable false \
+				-state disabled ]
+		set VMEncoder::var(resX) 3
+		set VMEncoder::var(resY) 3
+		set VMEncoder::var(resZ) 3
+
+		########### TRF  #############
+		foreach trfval {2DWT 3DWT} trf {2D-DWT 3D-DWT} {
+			set rad [radiobutton $subtrf.$trfval -text $trf \
+					-variable VMEncoder::var(transform) \
+					-command "disable3RLS $trfval $atk $resX $resY $resZ"\
+					-value $trfval ]
+			pack $rad -anchor w
+		}
+		$subtrf.2DWT select
+		
+	pack $subtrf -side left -padx 2 -pady 4
+	
+		pack $labresolution -padx 2 -side left -anchor w
+		pack $labresX $resX -padx 2 -side left -anchor w
+		pack $labresY $resY -padx 2 -side left -anchor w
+		pack $labresZ $resZ -padx 2 -side left -anchor w
+
+		pack $frameres1 -side top -fill x
+		pack $frameres2 $frameatk -side top -padx 2 -pady 4 -anchor n
+
+	pack $subres -side left -padx 2 -pady 4
+	pack $labtrf $labres -side left -fill both -padx 4 -expand yes
+}
+
+
+proc VMEncoder::_encode { framesrc framedst } {
+
+	variable var
+
+	set source [$framesrc.labsrc.f.entrysrc get ]
+	set destination [$framedst.labdst.f.entrydst get ]
+	set cond1 [string match *.pgx [string tolower $source]]
+	set cond2 [string match *-*.pgx [string tolower $source]]
+	set cond3 [string match *.bin [string tolower $source]]
+
+	set img ".img"
+	set pattern [string range $source 0 [expr [string length $source]-5]]
+	set pattern $pattern$img
+	set exist [file exists $pattern]
+	
+	#comprobamos datos son correctos
+	if {($cond1 == 1) && ($cond2 == 0)} {
+	  MessageDlg .msgdlg -parent . -message "Info : Really want to encode an slice instead of a volume?.\n For a group of .pgx slices, name must contain a - denoting a sequential index!" -type ok -icon info
+	} 
+	
+	if {$source == ""} {
+	  MessageDlg .msgdlg -parent . -message "Error : Source file is not defined !" -type ok -icon error 
+	} elseif {$destination == ""} {
+	  MessageDlg .msgdlg -parent . -message "Error : Destination file is not defined !" -type ok -icon error 
+	} elseif { ($VMEncoder::var(transform) != "3RLS") && ($VMEncoder::var(atk) == "Choose a wavelet transformation kernel") } {
+	  MessageDlg .msgdlg -parent . -title "Info" -message "Please choose a wavelet transformation kernel"\
+			-type ok -icon warning
+	} elseif {($exist == 0) && ($cond1 == 0) && ($cond3 == 1)} {
+		  MessageDlg .msgdlg -parent . -message "Error : IMG file associated to BIN volume file not found in same directory !" -type ok -icon info 
+	} else {
+
+		#creamos datain a partir de los parametros de entrada
+#		set dirJP3Dencoder [mk_relativepath $VMEncoder::JP3Dencoder]
+		set dirJP3Dencoder $VMEncoder::JP3Dencoder
+		set datain [concat " $dirJP3Dencoder -i [mk_relativepath $source] "]
+		if {$cond3 == 1} {
+		   set datain [concat " $datain -m [mk_relativepath $pattern] "]
+		}
+		set datain [concat " $datain -o [mk_relativepath $destination] "]
+		if {$VMEncoder::var(encoding) != "2EB"} {
+			set datain [concat " $datain -C $VMEncoder::var(encoding) "]
+		}
+		if {$VMEncoder::var(transform) == "2DWT"} {
+			set datain [concat " $datain -n $VMEncoder::var(resX),$VMEncoder::var(resY) "]
+		} elseif {$VMEncoder::var(transform) == "3DWT"} {
+			set datain [concat " $datain -n $VMEncoder::var(resX),$VMEncoder::var(resY),$VMEncoder::var(resZ) "]
+		}
+		
+		set datain [concat " $datain -r $VMEncoder::var(rate) "]
+		
+		if {$VMEncoder::var(atk) == "I9.7"} {
+			set datain [concat " $datain -I "]
+		} 
+		if {$VMEncoder::var(sop) == 1} {
+			set datain [concat " $datain -SOP "]
+		}
+		if {$VMEncoder::var(eph) == 1} {
+			set datain [concat " $datain -EPH "]
+		}
+		if {$VMEncoder::var(progorder) != "LRCP"} {
+			set datain [concat " $datain -p $VMEncoder::var(progorder) "]
+		}
+		if {$VMEncoder::var(cblksize) != "64,64,64"} {
+			set datain [concat " $datain -b $VMEncoder::var(cblksize) "]
+		}
+
+		
+		#Making this work would be great !!! 
+		set VMEncoder::var(progval) 10
+		ProgressDlg .progress -parent . -title "Wait..." \
+			-type         infinite \
+			-width        20 \
+			-textvariable "Compute in progress..."\
+			-variable     VMEncoder::progval \
+			-stop         "Stop" \
+			-command      {destroy .progress}
+		after 200 set VMEncoder::var(progval) 2
+		set fp [open "| $datain " r+] 
+		fconfigure $fp -buffering line 
+		set jp3dVM::dataout [concat "EXECUTED PROGRAM:\n\t$datain"]
+		while {-1 != [gets $fp tmp]} {
+			set jp3dVM::dataout [concat "$jp3dVM::dataout\n$tmp"]
+		}
+		destroy .progress
+		set cond [string first "ERROR" $jp3dVM::dataout]
+		set cond2 [string first "RESULT" $jp3dVM::dataout]
+		if {$cond != -1} {
+		   MessageDlg .msgdlg -parent . -message [string range $jp3dVM::dataout [expr $cond-1] end] -type ok -icon error
+		} elseif {$cond2 != -1} {
+		   MessageDlg .msgdlg -parent . -message [string range $jp3dVM::dataout [expr $cond2+7] end] -type ok -icon info
+		   close $fp
+		} else {
+		   #Must do something with this !!! [pid $fp]
+  		   close $fp
+		}
+	}
+}
+
+proc VMEncoder::_reset { framesrc framedst frametrf framecod} {
+
+	variable var
+
+	#Restore defaults values
+	set VMEncoder::var(transform) 2DWT
+	set VMEncoder::var(encoding) 2EB
+	set VMEncoder::var(atk) "R5.3"
+	set VMEncoder::var(progorder) "LRCP"
+	set atk $frametrf.labres.f.frameatk.atk
+	set resX $frametrf.labres.f.frameres2.spinresX
+	set resY $frametrf.labres.f.frameres2.spinresY
+	set resZ $frametrf.labres.f.frameres2.spinresZ
+	disable3RLS 2DWT $atk $resX $resY $resZ 
+	set labcblk $framecod.labcod.f.framecblk.labcblk
+	set progorder $framecod.labcod.f.framepoc.progorder
+	set labrate $framecod.labcod.f.framerate.labrate
+	set chksop $framecod.labcod.f.framesop.chksop
+	set chkeph $framecod.labcod.f.frameeph.chkeph
+	disableGR 3EB $labcblk $progorder $labrate $chksop $chkeph
+
+	$framesrc.labsrc.f.entrysrc delete 0 end
+	$framedst.labdst.f.entrydst delete 0 end
+}
+
+proc fileDialogE {w ent operation} {
+
+	variable file
+	variable i j
+
+	if {$operation == "open"} {
+		set types {
+			{"Source Image Files"	{.pgx .bin}	}
+			{"All files"		*}
+		}
+		set file [tk_getOpenFile -filetypes $types -parent $w]
+		if {[string compare $file ""]} {
+			$ent delete 0 end
+			$ent insert end $file
+			$ent xview moveto 1
+		}
+	} else {
+		set types {
+			{"JP3D Files"		   {.jp3d}	}
+			{"JPEG2000 Files"	   {.j2k}	}
+			{"All files"		*}
+		}
+		set file [tk_getSaveFile -filetypes $types -parent $w \
+			-initialfile Untitled -defaultextension .jp3d]
+		if {[string compare $file ""]} {
+			$ent delete 0 end
+			$ent insert end $file
+			$ent xview moveto 1
+		}
+	}
+}
+
+proc mk_relativepath {abspath} {
+
+	set mydir [split [string trimleft [pwd] {/}] {/}]
+	set abspathcomps [split [string trimleft $abspath {/}] {/}]
+
+	set i 0
+	while {$i<[llength $mydir]} {
+		if {![string compare [lindex $abspathcomps $i] [lindex $mydir $i]]} {
+			incr i
+		} else {
+			break
+		}
+	}
+	set h [expr [llength $mydir]-$i]
+	set j [expr [llength $abspathcomps]-$i]
+
+	if {!$h} {
+		set relpath "./"
+	} else {
+		set relpath ""
+		while { $h > 0 } {
+			set relpath "../$relpath"
+			incr h -1
+		}
+	}
+
+	set h [llength $abspathcomps]
+	while { $h > $i } {
+		set relpath [concat $relpath[lindex $abspathcomps [expr [llength $abspathcomps]-$j]]/]
+		incr h -1
+		incr j -1
+	}
+	return [string trim $relpath {/}]
+}
+
+proc disable3RLS {flag atk resX resY resZ}  {
+
+	if {$flag == "3RLS"} {
+		$atk configure -state disabled
+		$resX configure -state disabled
+		$resY configure -state disabled
+		$resZ configure -state disabled
+	} elseif {$flag == "2DWT"} {
+		$atk configure -state normal
+		$resX configure -state normal
+		$resY configure -state normal
+		$resZ configure -state disabled
+	} elseif {$flag == "3DWT"} {
+		$atk configure -state normal
+		$resX configure -state normal
+		$resY configure -state normal
+		$resZ configure -state normal
+	}
+}
+
+proc disableGR {flag labcblk progorder labrate chksop chkeph} {
+	
+	if {$flag == "2EB"} {
+		$labcblk configure -state normal
+		$progorder configure -state normal
+		$labrate configure -state normal
+		$chksop configure -state normal
+		$chkeph configure -state normal
+		set VMEncoder::var(cblksize) "64,64,64"
+		set VMEncoder::var(tilesize) "512,512,512"
+	} elseif {$flag == "3EB"} {
+		$labcblk configure -state normal
+		$progorder configure -state normal
+		$labrate configure -state normal
+		$chksop configure -state normal
+		$chkeph configure -state normal
+		set VMEncoder::var(cblksize) "64,64,64"
+		set VMEncoder::var(tilesize) "512,512,512"
+	} else {
+		$labcblk configure -state disabled
+		$progorder configure -state disabled
+		$labrate configure -state disabled
+		$chksop configure -state disabled
+		$chkeph configure -state disabled
+	}
+}
\ No newline at end of file
Binary files /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/logoLPI.gif.svn-base and ./jp3d/tcltk/.svn/text-base/logoLPI.gif.svn-base differ
diff -urN /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/LPI_JP3D_VM.tcl.svn-base ./jp3d/tcltk/.svn/text-base/LPI_JP3D_VM.tcl.svn-base
--- /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/LPI_JP3D_VM.tcl.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jp3d/tcltk/.svn/text-base/LPI_JP3D_VM.tcl.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,114 @@
+#!/bin/sh
+# The next line is executed by /bin/sh, but not tcl \
+exec wish "$0" ${1+"$@"}
+
+namespace eval jp3dVM {
+
+    variable _progress 0
+    variable _afterid  ""
+    variable _status "Compute in progress..."
+    variable notebook
+    variable mainframe
+    variable dataout "Process execution information"
+    variable status
+    variable prgtext
+    variable prgindic
+
+    set pwd [pwd]
+    cd [file dirname [info script]]
+    variable VMDIR [pwd]
+    cd $pwd
+
+    foreach script {encoder.tcl decoder.tcl} {
+	namespace inscope :: source $VMDIR/$script
+    }
+}
+
+
+proc jp3dVM::create { } {
+    variable notebook
+    variable mainframe
+    variable dataout
+
+    bind all <F12> { catch {console show} }
+
+    # Menu description
+    set descmenu {
+        "&File" {} {} 0 {
+            {command "E&xit" {} "Exit BWidget jp3dVM" {} -command exit}
+        }
+        "&Options" {} {} 0 {
+            {command "&Encode" {} "Show encoder" {}
+                -command  {$jp3dVM::notebook raise [$jp3dVM::notebook page 0]}
+            }
+            {command "&Decode" {} "Show decoder" {}
+                -command  {$jp3dVM::notebook raise [$jp3dVM::notebook page 1]}
+            }
+        }
+	"&Help" {} {} 0 {
+            {command "&About authors..." {} "Show info about authors" {} 
+		-command {MessageDlg .msgdlg -parent . -title "About authors" -message " Copyright @ LPI-UVA 2006 " -type ok -icon info}}
+        }
+    }
+
+    set mainframe [MainFrame .mainframe \
+                       -menu         $descmenu \
+                       -textvariable jp3dVM::status \
+                       -progressvar  jp3dVM::prgindic]
+
+    $mainframe addindicator -text "JP3D Verification Model 1.0.0"
+
+    # NoteBook creation
+    set frame    [$mainframe getframe]
+    set notebook [NoteBook $frame.nb]
+
+    set logo [frame $frame.logo]
+    #creo imagen logo
+    image create photo LPIimg -file logoLPI.gif
+    set logoimg [Label $logo.logoimg -image LPIimg]
+    
+    set f0  [VMEncoder::create $notebook]
+    set f1  [VMDecoder::create $notebook]
+
+	set tfinfo [TitleFrame $frame.codinfo -text "Program Execution"]
+	set codinfo [$tfinfo getframe]
+	set sw [ScrolledWindow $codinfo.sw -relief sunken -borderwidth 2 -scrollbar both]
+	set sf [ScrollableFrame $codinfo.sf ]
+	$sw setwidget $sf
+	set subf [$sf getframe]
+	set labinfo [label $subf.labinfo -textvariable jp3dVM::dataout -justify left]
+
+	pack $labinfo -side left 
+	pack $sw 
+
+    $notebook compute_size
+    $notebook raise [$notebook page 0]
+
+    pack $logoimg -side left -fill x -expand yes 
+    pack $notebook -expand yes 
+    pack $logo $tfinfo -side left -expand yes 
+    pack $mainframe -fill both -expand yes
+    update idletasks
+}
+
+
+proc jp3dVM::main {} {
+    variable VMDIR
+
+    lappend ::auto_path [file dirname $VMDIR]
+    namespace inscope :: package require BWidget
+
+    option add *TitleFrame.l.font {helvetica 11 bold italic}
+
+    wm withdraw .
+    wm title . "JP3D Verification Model @ LPI"
+
+    jp3dVM::create
+    BWidget::place . 0 0 center
+    wm deiconify .
+    raise .
+    focus -force .
+}
+
+jp3dVM::main
+wm geom . [wm geom .]
Binary files /home/robin/sldeb/trunk/jp3d/tcltk/.svn/text-base/Thumbs.db.svn-base and ./jp3d/tcltk/.svn/text-base/Thumbs.db.svn-base differ
diff -urN /home/robin/sldeb/trunk/jpwl/CMakeLists.txt ./jpwl/CMakeLists.txt
--- /home/robin/sldeb/trunk/jpwl/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/CMakeLists.txt	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,55 @@
+# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
+
+ADD_DEFINITIONS(-DUSE_JPWL)
+
+SET(OPJ_SRCS 
+../libopenjpeg/bio.c 
+../libopenjpeg/cio.c 
+../libopenjpeg/dwt.c 
+../libopenjpeg/event.c 
+../libopenjpeg/image.c 
+../libopenjpeg/j2k.c 
+../libopenjpeg/j2k_lib.c 
+../libopenjpeg/jp2.c 
+../libopenjpeg/jpt.c 
+../libopenjpeg/mct.c 
+../libopenjpeg/mqc.c 
+../libopenjpeg/openjpeg.c 
+../libopenjpeg/pi.c 
+../libopenjpeg/raw.c 
+../libopenjpeg/t1.c 
+../libopenjpeg/t2.c 
+../libopenjpeg/tcd.c 
+../libopenjpeg/tgt.c
+)
+SET(JPWL_SRCS crc.c jpwl.c jpwl_lib.c rs.c)
+
+ADD_LIBRARY(openjpeg_JPWL ${JPWL_SRCS} ${OPJ_SRCS})
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+FIND_PACKAGE(TIFF REQUIRED)
+
+ADD_EXECUTABLE(JPWL_j2k_to_image
+../codec/convert.c ../codec/j2k_to_image.c
+)
+TARGET_LINK_LIBRARIES(JPWL_j2k_to_image openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_j2k_to_image m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(JPWL_image_to_j2k
+../codec/convert.c ../codec/image_to_j2k.c)
+TARGET_LINK_LIBRARIES(JPWL_image_to_j2k openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_image_to_j2k m)
+ENDIF(UNIX)
+
diff -urN /home/robin/sldeb/trunk/jpwl/jpwl.c ./jpwl/jpwl.c
--- /home/robin/sldeb/trunk/jpwl/jpwl.c	2007-02-23 18:24:49.000000000 +0000
+++ ./jpwl/jpwl.c	2007-11-27 22:39:51.000000000 +0000
@@ -29,20 +29,20 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#ifdef USE_JPWL
-
 #include "../libopenjpeg/opj_includes.h"
 
+#ifdef USE_JPWL
+
 /** @defgroup JPWL JPWL - JPEG-2000 Part11 (JPWL) codestream manager */
 /*@{*/
 
 /** @name Local static variables */
 /*@{*/
 
-/** position of markers to insert */
-static jpwl_marker_t jwmarker[JPWL_MAX_NO_MARKERS]; 
-/** number of prepared markers */
+/** number of JPWL prepared markers */
 static int jwmarker_num;
+/** properties of JPWL markers to insert */
+static jpwl_marker_t jwmarker[JPWL_MAX_NO_MARKERS]; 
 
 /*@}*/
 
@@ -88,42 +88,114 @@
 int jpwl_markcomp(const void *arg1, const void *arg2);
 
 /** write an EPB MS to a buffer
+@param j2k J2K compressor handle
 @param epbmark pointer to the EPB MS
 @param buf pointer to the memory buffer
 */
-void jpwl_epb_write(jpwl_epb_ms_t *epbmark, unsigned char *buf);
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf);
 
 /** write an EPC MS to a buffer
+@param j2k J2K compressor handle
 @param epcmark pointer to the EPC MS
 @param buf pointer to the memory buffer
 */
-void jpwl_epc_write(jpwl_epc_ms_t *epcmark, unsigned char *buf);
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epcmark, unsigned char *buf);
 
 /** write an ESD MS to a buffer
+@param j2k J2K compressor handle
 @param esdmark pointer to the ESD MS
 @param buf pointer to the memory buffer
 */
-void jpwl_esd_write(jpwl_esd_ms_t *esdmark, unsigned char *buf);
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esdmark, unsigned char *buf);
 
 /*-----------------------------------------------------------------*/
 
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+
+	int mm;
+
+	/* let's reset some settings */
+
+	/* clear the existing markers */
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		switch (jwmarker[mm].id) {
+
+		case J2K_MS_EPB:
+			free(jwmarker[mm].epbmark);
+			break;
+
+		case J2K_MS_EPC:
+			free(jwmarker[mm].epcmark);
+			break;
+
+		case J2K_MS_ESD:
+			free(jwmarker[mm].esdmark);
+			break;
+
+		case J2K_MS_RED:
+			free(jwmarker[mm].redmark);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* clear the marker structure array */
+	memset(jwmarker, 0, sizeof(jpwl_marker_t) * JPWL_MAX_NO_MARKERS);
+
+	/* no more markers in the list */
+	jwmarker_num = 0;
+
+	/* let's begin creating a marker list, according to user wishes */
+	jpwl_prepare_marks(j2k, cio, image);
+
+	/* now we dump the JPWL markers on the codestream */
+	jpwl_dump_marks(j2k, cio, image);
+
+	/* do not know exactly what is this for,
+	but it gets called during index creation */
+	j2k->pos_correction = 0;
+
+}
+
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
+
+	if (!cstr_info)
+		return;
+
+	/* expand the list? */
+	if ((cstr_info->marknum + 1) > cstr_info->maxmarknum) {
+		cstr_info->maxmarknum = 100 + (int) ((float) cstr_info->maxmarknum * 1.0F);
+		cstr_info->marker = opj_realloc(cstr_info->marker, cstr_info->maxmarknum);
+	}
+
+	/* add the marker */
+	cstr_info->marker[cstr_info->marknum].type = type;
+	cstr_info->marker[cstr_info->marknum].pos = pos;
+	cstr_info->marker[cstr_info->marknum].len = len;
+	cstr_info->marknum++;
+
+}
+
 void jpwl_prepare_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
 
 	unsigned short int socsiz_len = 0;
-	int ciopos = cio_tell(cio);
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
 	unsigned char *socp = NULL;
 
-	int tileno, tilespec, hprot, sens, pprot, packspec, lastileno, packno;
+	int tileno, acc_tpno, tpno, tilespec, hprot, sens, pprot, packspec, lastileno, packno;
 
 	jpwl_epb_ms_t *epb_mark;
 	jpwl_epc_ms_t *epc_mark;
 	jpwl_esd_ms_t *esd_mark;
 
-	/* find SOC + SIZ length */
+	/* find (SOC + SIZ) length */
 	/* I assume SIZ is always the first marker after SOC */
-	cio_seek(cio, 4);
+	cio_seek(cio, soc_pos + 4);
 	socsiz_len = (unsigned short int) cio_read(cio, 2) + 4; /* add the 2 marks length itself */
-	cio_seek(cio, 0);
+	cio_seek(cio, soc_pos + 0);
 	socp = cio_getbp(cio); /* pointer to SOC */
 
 	/* 
@@ -142,7 +214,7 @@
 		if (epc_mark) {
 			jwmarker[jwmarker_num].id = J2K_MS_EPC; /* its type */
 			jwmarker[jwmarker_num].epcmark = epc_mark; /* the EPC */
-			jwmarker[jwmarker_num].pos = socsiz_len; /* after SIZ */
+			jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
 			jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.1; /* not so first */
 			jwmarker[jwmarker_num].len = epc_mark->Lepc; /* its length */
 			jwmarker[jwmarker_num].len_ready = true; /* ready */
@@ -179,7 +251,7 @@
 			(unsigned char) j2k->cp->sens_MH, /* sensitivity method */
 			j2k->cp->sens_size, /* sensitivity size */
 			-1, /* this ESD is in main header */
-			0 /*j2k->image_info->num*/, /* number of packets in codestream */
+			0 /*j2k->cstr_info->num*/, /* number of packets in codestream */
 			NULL /*sensval*/ /* pointer to sensitivity data of packets */
 			)) {
 			
@@ -187,7 +259,7 @@
 			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
 				jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
 				jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
-				jwmarker[jwmarker_num].pos = socsiz_len; /* we choose to place it after SIZ */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* we choose to place it after SIZ */
 				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
 				jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
 				jwmarker[jwmarker_num].len_ready = true; /* not ready, yet */
@@ -212,89 +284,107 @@
 	/* 
 	 ESD MSs for Tile Part Headers 
 	*/
-	/* cycle through TPHs */
+	/* cycle through tiles */
 	sens = -1; /* default spec: no ESD */
 	tilespec = 0; /* first tile spec */
-	for (tileno = 0; tileno < j2k->image_info->tw * j2k->image_info->th; tileno++) {
-
-		int sot_len, Psot, Psotp, mm;
-		unsigned long sot_pos, post_sod_pos;
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
 
-		unsigned long int left_THmarks_len;
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
 
-		sot_pos = j2k->image_info->tile[tileno].start_pos;
-		cio_seek(cio, sot_pos + 2); 
-		sot_len = cio_read(cio, 2); /* SOT Len */
-		cio_skip(cio, 2);
-		Psotp = cio_tell(cio);
-		Psot = cio_read(cio, 4); /* tile length */
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) {
+	
+			int sot_len, Psot, Psotp, mm;
+			unsigned long sot_pos, post_sod_pos;
 
-		post_sod_pos = j2k->image_info->tile[tileno].end_header + 1;
-		left_THmarks_len = post_sod_pos - sot_pos;
+			unsigned long int left_THmarks_len;
 
-		/* add all the lengths of the markers which are len-ready and stay within SOT and SOD */
-		for (mm = 0; mm < jwmarker_num; mm++) {
-			if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
-				if (jwmarker[mm].len_ready)
-					left_THmarks_len += jwmarker[mm].len + 2;
-				else {
-					opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
-						jwmarker[mm].id, jwmarker[mm].dpos);				
-					exit(1);
+			/******* sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/******* post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - sot_pos;
+
+			/* add all the lengths of the markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
 				}
 			}
-		}
 
-		if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == tileno))
-			/* we got a specification from this tile onwards */
-			sens = j2k->cp->sens_TPH[tilespec++];
-	
-		/* must this TPH have an ESD MS? */
-		if (j2k->cp->esd_on && (sens >= 0)) {
+			/******* if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile onwards */
+				sens = j2k->cp->sens_TPH[tilespec++];
+		
+			/* must this TPH have an ESD MS? */
+			if (j2k->cp->esd_on && (sens >= 0)) {
 
-			/* Create the ESD */
-			if (esd_mark = jpwl_esd_create(
-				j2k, /* this encoder handle */
-				-1, /* we are averaging over all components */
-				(unsigned char) j2k->cp->sens_range, /* range method */
-				(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing size */
-				(unsigned char) sens, /* sensitivity method */
-				j2k->cp->sens_size, /* sensitivity value size */
-				tileno, /* this ESD is in a tile */
-				0, /* number of packets in codestream */
-				NULL /* pointer to sensitivity data of packets */
-				)) {
-				
-				/* Add this marker to the 'insertanda' list */
-				if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
-					jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
-					jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
-					jwmarker[jwmarker_num].pos = j2k->image_info->tile[tileno].start_pos + sot_len + 2; /* after SOT */
-					jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
-					jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
-					jwmarker[jwmarker_num].len_ready = true; /* ready, yet */
-					jwmarker[jwmarker_num].pos_ready = true; /* ready */
-					jwmarker[jwmarker_num].parms_ready = true; /* not ready */
-					jwmarker[jwmarker_num].data_ready = false; /* ready */
-					jwmarker_num++;
-				}
+				/* Create the ESD */
+				if (esd_mark = jpwl_esd_create(
+					j2k, /* this encoder handle */
+					-1, /* we are averaging over all components */
+					(unsigned char) j2k->cp->sens_range, /* range method */
+					(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing size */
+					(unsigned char) sens, /* sensitivity method */
+					j2k->cp->sens_size, /* sensitivity value size */
+					tileno, /* this ESD is in a tile */
+					0, /* number of packets in codestream */
+					NULL /* pointer to sensitivity data of packets */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
+						jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
+						jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready, yet */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* not ready */
+						jwmarker[jwmarker_num].data_ready = false; /* ready */
+						jwmarker_num++;
+					}
 
-				/* update Psot of the tile  */
-				cio_seek(cio, Psotp);
-				cio_write(cio, Psot + esd_mark->Lesd + 2, 4);
+					/* update Psot of the tile  */
+					cio_seek(cio, Psotp);
+					cio_write(cio, Psot + esd_mark->Lesd + 2, 4);
 
-				opj_event_msg(j2k->cinfo, EVT_INFO,
-					"TPH ESDs: tile %02d, method %d\n",
-					tileno,
-					sens
-					);
-
-			} else {
-				/* ooops, problems */
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d\n", tileno);				
-			};
+					opj_event_msg(j2k->cinfo, EVT_INFO,
+						/******* "TPH ESDs: tile %02d, method %d\n", */
+						"TPH ESDs: tile %02d, part %02d, method %d\n",
+						/******* tileno, */
+						tileno, tpno,
+						sens
+						);
+
+				} else {
+					/* ooops, problems */
+					/***** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d\n", tileno); */
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d,%d\n", tileno, tpno);
+				};
 
-		}				
+			}
+			
+		}
 	
 	};
 
@@ -307,7 +397,7 @@
 		int mm;
 
 		/* position of SOT */
-		unsigned int sot_pos = j2k->image_info->main_head_end + 1;
+		unsigned int sot_pos = j2k->cstr_info->main_head_end + 1;
 
 		/* how much space is there between end of SIZ and beginning of SOT? */
 		int left_MHmarks_len = sot_pos - socsiz_len;
@@ -341,7 +431,7 @@
 			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
 				jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
 				jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
-				jwmarker[jwmarker_num].pos = socsiz_len; /* after SIZ */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
 				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
 				jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
 				jwmarker[jwmarker_num].len_ready = true; /* ready */
@@ -371,200 +461,245 @@
 	lastileno = 0;
 	packspec = 0;
 	pprot = -1;
-	for (tileno = 0; tileno < j2k->image_info->tw * j2k->image_info->th; tileno++) {
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
 
-		int sot_len, Psot, Psotp, mm, epb_index = 0, prot_len = 0;
-		unsigned long sot_pos, post_sod_pos;
-		unsigned long int left_THmarks_len, epbs_len = 0;
-		int startpack = 0, stoppack = j2k->image_info->num;
-		jpwl_epb_ms_t *tph_epb = NULL;
-
-		sot_pos = j2k->image_info->tile[tileno].start_pos;
-		cio_seek(cio, sot_pos + 2); 
-		sot_len = cio_read(cio, 2); /* SOT Len */
-		cio_skip(cio, 2);
-		Psotp = cio_tell(cio);
-		Psot = cio_read(cio, 4); /* tile length */
-
-		/* a-priori length of the data dwelling between SOT and SOD */
-		post_sod_pos = j2k->image_info->tile[tileno].end_header + 1;
-		left_THmarks_len = post_sod_pos - (sot_pos + sot_len + 2);
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
 
-		/* add all the lengths of the JPWL markers which are len-ready and stay within SOT and SOD */
-		for (mm = 0; mm < jwmarker_num; mm++) {
-			if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
-				if (jwmarker[mm].len_ready)
-					left_THmarks_len += jwmarker[mm].len + 2;
-				else {
-					opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
-						jwmarker[mm].id, jwmarker[mm].dpos);				
-					exit(1);
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) { 
+		
+			int sot_len, Psot, Psotp, mm, epb_index = 0, prot_len = 0;
+			unsigned long sot_pos, post_sod_pos;
+			unsigned long int left_THmarks_len, epbs_len = 0;
+			int startpack = 0, stoppack = j2k->cstr_info->packno;
+			int first_tp_pack, last_tp_pack;
+			jpwl_epb_ms_t *tph_epb = NULL;
+
+			/****** sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/* a-priori length of the data dwelling between SOT and SOD */
+			/****** post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - (sot_pos + sot_len + 2);
+
+			/* add all the lengths of the JPWL markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
 				}
 			}
-		}
-
-		if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == tileno))
-			/* we got a specification from this tile onwards */
-			hprot = j2k->cp->hprot_TPH[tilespec++];
-	
-		/* must this TPH have an EPB MS? */
-		if (j2k->cp->epb_on && (hprot > 0)) {
 
-			/* Create the EPB */
-			if (epb_mark = jpwl_epb_create(
-				j2k, /* this encoder handle */
-				false, /* is it the latest? in TPH, no for now (if huge data size in TPH, we'd need more) */
-				true, /* is it packed? yes for now */
-				tileno, /* we are in TPH */
-				epb_index++, /* its index is 0 (first) */
-				hprot, /* protection type parameters of following data */
-				sot_len + 2, /* pre-data length: only SOT */
-				left_THmarks_len /* post-data length: from SOT end to SOD inclusive */
-				)) {
-				
-				/* Add this marker to the 'insertanda' list */
-				if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
-					jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
-					jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
-					jwmarker[jwmarker_num].pos = j2k->image_info->tile[tileno].start_pos + sot_len + 2; /* after SOT */
-					jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
-					jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
-					jwmarker[jwmarker_num].len_ready = true; /* ready */
-					jwmarker[jwmarker_num].pos_ready = true; /* ready */
-					jwmarker[jwmarker_num].parms_ready = true; /* ready */
-					jwmarker[jwmarker_num].data_ready = false; /* not ready */
-					jwmarker_num++;
-				}
+			/****** if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile part onwards */
+				hprot = j2k->cp->hprot_TPH[tilespec++];
+		
+			/* must this TPH have an EPB MS? */
+			if (j2k->cp->epb_on && (hprot > 0)) {
 
-				/* update Psot of the tile  */
-				Psot += epb_mark->Lepb + 2;
+				/* Create the EPB */
+				if (epb_mark = jpwl_epb_create(
+					j2k, /* this encoder handle */
+					false, /* is it the latest? in TPH, no for now (if huge data size in TPH, we'd need more) */
+					true, /* is it packed? yes for now */
+					tileno, /* we are in TPH */
+					epb_index++, /* its index is 0 (first) */
+					hprot, /* protection type parameters of following data */
+					sot_len + 2, /* pre-data length: only SOT */
+					left_THmarks_len /* post-data length: from SOT end to SOD inclusive */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
+						jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
+						jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* ready */
+						jwmarker[jwmarker_num].data_ready = false; /* not ready */
+						jwmarker_num++;
+					}
 
-				opj_event_msg(j2k->cinfo, EVT_INFO,
-					"TPH EPB : tile %02d, prot. %d\n",
-					tileno,
-					hprot
-					);
-
-				/* save this TPH EPB address */
-				tph_epb = epb_mark;
-
-			} else {
-				/* ooops, problems */
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB #%d\n", tileno);				
-			};
+					/* update Psot of the tile  */
+					Psot += epb_mark->Lepb + 2;
 
-		}				
-	
-		startpack = 0;
-		/* EPB MSs for UEP packet data protection in Tile Parts */
-		for (packno = 0; packno < j2k->image_info->num; packno++) {
-
-			if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
-				(j2k->cp->pprot_tileno[packspec] == tileno) && (j2k->cp->pprot_packno[packspec] == packno)) {
-
-				/* we got a specification from this tile and packet onwards */
-				/* print the previous spec */
-				if (packno > 0) {
-					stoppack = packno - 1;				
 					opj_event_msg(j2k->cinfo, EVT_INFO,
-						"UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
-						tileno,
-						startpack,
-						stoppack,
-						j2k->image_info->tile[tileno].packet[startpack].start_pos,
-						j2k->image_info->tile[tileno].packet[stoppack].end_pos,
-						pprot);
-
-					prot_len = j2k->image_info->tile[tileno].packet[stoppack].end_pos + 1 -
-						j2k->image_info->tile[tileno].packet[startpack].start_pos;
-
-					/*
-					  particular case: if this is the last header and the last packet,
-					  then it is better to protect even the EOC marker
-					*/
-					if ((tileno == ((j2k->image_info->tw * j2k->image_info->th) - 1)) &&
-						(stoppack == (j2k->image_info->num - 1)))
-						/* add the EOC len */
-						prot_len += 2;
-
-					/* let's add the EPBs */
-					Psot += jpwl_epbs_add(
-						j2k, /* J2K handle */
-						jwmarker, /* pointer to JPWL markers list */
-						&jwmarker_num, /* pointer to the number of current markers */
-						false, /* latest */
-						true, /* packed */
-						false, /* inside MH */
-						&epb_index, /* pointer to EPB index */
-						pprot, /* protection type */
-						(double) (j2k->image_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, /* position */
-						tileno, /* number of tile */
-						0, /* length of pre-data */
-						prot_len /*4000*/ /* length of post-data */
+						/***** "TPH EPB : tile %02d, prot. %d\n", */
+						"TPH EPB : tile %02d, part %02d, prot. %d\n",
+						/***** tileno, */
+						tileno, tpno,
+						hprot
 						);
+
+					/* save this TPH EPB address */
+					tph_epb = epb_mark;
+
+				} else {
+					/* ooops, problems */
+					/****** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB #%d\n", tileno);	*/
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB in #%d,d\n", tileno, tpno);
+				};
+
+			}				
+		
+			startpack = 0;
+			/* EPB MSs for UEP packet data protection in Tile Parts */
+			/****** for (packno = 0; packno < j2k->cstr_info->num; packno++) { */
+			/*first_tp_pack = (tpno > 0) ? (first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno - 1].tp_numpacks) : 0;*/
+			first_tp_pack = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pack;
+			last_tp_pack = first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks - 1;
+			for (packno = 0; packno < j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks; packno++) {
+
+				/******** if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == tileno) && (j2k->cp->pprot_packno[packspec] == packno)) { */
+				if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == acc_tpno) && (j2k->cp->pprot_packno[packspec] == packno)) {
+
+					/* we got a specification from this tile and packet onwards */
+					/* print the previous spec */
+					if (packno > 0) {
+						stoppack = packno - 1;				
+						opj_event_msg(j2k->cinfo, EVT_INFO,
+							/***** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+							"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+							/***** tileno, */
+							tileno, tpno,
+							startpack,
+							stoppack,
+							/***** j2k->cstr_info->tile[tileno].packet[startpack].start_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+							/***** j2k->cstr_info->tile[tileno].packet[stoppack].end_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+							pprot);
+
+						/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+						prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+						/*
+						  particular case: if this is the last header and the last packet,
+						  then it is better to protect even the EOC marker
+						*/
+						/****** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(stoppack == (j2k->cstr_info->num - 1))) */
+						if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+							(stoppack == last_tp_pack))
+							/* add the EOC len */
+							prot_len += 2;
+
+						/* let's add the EPBs */
+						Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							false, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/****** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, */ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+					}
+
+					startpack = packno;
+					pprot = j2k->cp->pprot[packspec++];
 				}
 
-				startpack = packno;
-				pprot = j2k->cp->pprot[packspec++];
+				//printf("Tile %02d, pack %02d ==> %d\n", tileno, packno, pprot);
+		
 			}
 
-			//printf("Tile %02d, pack %02d ==> %d\n", tileno, packno, pprot);
-	
-		}
+			/* we are at the end: print the remaining spec */
+			stoppack = packno - 1;
+			if (pprot >= 0) {
 
-		/* we are at the end: print the remaining spec */
-		stoppack = packno - 1;
-		if (pprot >= 0) {
+				opj_event_msg(j2k->cinfo, EVT_INFO,
+					/**** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+					"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+					/**** tileno, */
+					tileno, tpno,
+					startpack,
+					stoppack,
+					/***** j2k->image_info->tile[tileno].packet[startpack].start_pos,
+					j2k->image_info->tile[tileno].packet[stoppack].end_pos, */
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+					pprot);
+
+				/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+				prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+				/*
+				  particular case: if this is the last header and the last packet,
+				  then it is better to protect even the EOC marker
+				*/
+				/***** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(stoppack == (j2k->cstr_info->num - 1))) */
+				if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+					(stoppack == last_tp_pack))
+					/* add the EOC len */
+					prot_len += 2;
+
+				/* let's add the EPBs */
+				Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							true, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/***** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001,*/ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+			}
 
-			opj_event_msg(j2k->cinfo, EVT_INFO,
-				"UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
-				tileno,
-				startpack,
-				stoppack,
-				j2k->image_info->tile[tileno].packet[startpack].start_pos,
-				j2k->image_info->tile[tileno].packet[stoppack].end_pos,
-				pprot);
-
-			prot_len = j2k->image_info->tile[tileno].packet[stoppack].end_pos + 1 -
-				j2k->image_info->tile[tileno].packet[startpack].start_pos;
-
-			/*
-			  particular case: if this is the last header and the last packet,
-			  then it is better to protect even the EOC marker
-			*/
-			if ((tileno == ((j2k->image_info->tw * j2k->image_info->th) - 1)) &&
-				(stoppack == (j2k->image_info->num - 1)))
-				/* add the EOC len */
-				prot_len += 2;
-
-			/* let's add the EPBs */
-			Psot += jpwl_epbs_add(
-						j2k, /* J2K handle */
-						jwmarker, /* pointer to JPWL markers list */
-						&jwmarker_num, /* pointer to the number of current markers */
-						true, /* latest */
-						true, /* packed */
-						false, /* inside MH */
-						&epb_index, /* pointer to EPB index */
-						pprot, /* protection type */
-						(double) (j2k->image_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, /* position */
-						tileno, /* number of tile */
-						0, /* length of pre-data */
-						prot_len /*4000*/ /* length of post-data */
-						);
-		}
+			/* we can now check if the TPH EPB was really the last one */
+			if (tph_epb && (epb_index == 1)) {
+				/* set the TPH EPB to be the last one in current header */
+				tph_epb->Depb |= (unsigned char) ((true & 0x0001) << 6);
+				tph_epb = NULL;
+			}
 
-		/* we can now check if the TPH EPB was really the last one */
-		if (tph_epb && (epb_index == 1)) {
-			/* set the TPH EPB to be the last one in current header */
-			tph_epb->Depb |= (unsigned char) ((true & 0x0001) << 6);
-			tph_epb = NULL;
+			/* write back Psot */
+			cio_seek(cio, Psotp);
+			cio_write(cio, Psot, 4);
+		
 		}
 
-		/* write back Psot */
-		cio_seek(cio, Psotp);
-		cio_write(cio, Psot, 4);
-
 	};
 
 	/* reset the position */
@@ -575,9 +710,9 @@
 void jpwl_dump_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
 
 	int mm;
-	unsigned long int old_size = j2k->image_info->codestream_size;
+	unsigned long int old_size = j2k->cstr_info->codestream_size;
 	unsigned long int new_size = old_size;
-	int ciopos = cio_tell(cio);
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
 	unsigned char *jpwl_buf, *orig_buf;
 	unsigned long int orig_pos;
 	double epbcoding_time = 0.0, esdcoding_time = 0.0;
@@ -585,23 +720,27 @@
 	/* Order JPWL markers according to their wishlist position */
 	qsort((void *) jwmarker, (size_t) jwmarker_num, sizeof (jpwl_marker_t), jpwl_markcomp);
 
-	/* compute markers total size */
+	/* compute markers total size */ 
 	for (mm = 0; mm < jwmarker_num; mm++) {
 		/*printf("%x, %d, %.10f, %d long\n", jwmarker[mm].id, jwmarker[mm].pos,
 			jwmarker[mm].dpos, jwmarker[mm].len);*/
 		new_size += jwmarker[mm].len + 2;
 	}
 
-	/* allocate a temporary buffer of proper size */
-	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) new_size * sizeof (unsigned char)))) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL temp codestream buffer\n");
+	/* allocate a new buffer of proper size */
+	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) (new_size + soc_pos) * sizeof(unsigned char)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL codestream buffer\n");
 		exit(1);
 	};
+
+	/* copy the jp2 part, if any */
 	orig_buf = jpwl_buf;
+	memcpy(jpwl_buf, cio->buffer, soc_pos);
+	jpwl_buf += soc_pos;
 
 	/* cycle through markers */
-	orig_pos = 0; /* start from the beginning */
-	cio_seek(cio, 0); /* rewind the original */
+	orig_pos = soc_pos + 0; /* start from the beginning */
+	cio_seek(cio, soc_pos + 0); /* rewind the original */
 	for (mm = 0; mm < jwmarker_num; mm++) {
 
 		/*
@@ -619,15 +758,15 @@
 		switch (jwmarker[mm].id) {
 
 		case J2K_MS_EPB:
-			jpwl_epb_write(jwmarker[mm].epbmark, jpwl_buf);
+			jpwl_epb_write(j2k, jwmarker[mm].epbmark, jpwl_buf);
 			break;
 
 		case J2K_MS_EPC:
-			jpwl_epc_write(jwmarker[mm].epcmark, jpwl_buf);
+			jpwl_epc_write(j2k, jwmarker[mm].epcmark, jpwl_buf);
 			break;
 
 		case J2K_MS_ESD:
-			jpwl_esd_write(jwmarker[mm].esdmark, jpwl_buf);
+			jpwl_esd_write(j2k, jwmarker[mm].esdmark, jpwl_buf);
 			break;
 
 		case J2K_MS_RED:
@@ -638,6 +777,10 @@
 			break;
 		};
 
+		/* we update the markers struct */
+		if (j2k->cstr_info)
+			j2k->cstr_info->marker[j2k->cstr_info->marknum - 1].pos = (jpwl_buf - orig_buf);
+		
 		/* we set the marker dpos to the new position in the JPWL codestream */
 		jwmarker[mm].dpos = (double) (jpwl_buf - orig_buf);
 
@@ -647,15 +790,15 @@
 	}
 
 	/* finish remaining original codestream */
-	memcpy(jpwl_buf, cio_getbp(cio), old_size - orig_pos);
-	jpwl_buf += old_size - orig_pos;
-	cio_seek(cio, old_size);
+	memcpy(jpwl_buf, cio_getbp(cio), old_size - (orig_pos - soc_pos));
+	jpwl_buf += old_size - (orig_pos - soc_pos);
+	cio_seek(cio, soc_pos + old_size);
 	
 	/*
 	update info file based on added markers
 	*/
 	if (!jpwl_update_info(j2k, jwmarker, jwmarker_num))
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not update OPJ image_info structure\n");
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not update OPJ cstr_info structure\n");
 
 	/* now we need to repass some markers and fill their data fields */
 	
@@ -746,14 +889,14 @@
 
 	/* free original cio buffer and set it to the JPWL one */
 	opj_free(cio->buffer);
-	/*cio->cinfo;*/ /* no change */
-	/*cio->openmode;*/ /* no change */
-	cio->buffer = jpwl_buf - new_size;
-	cio->length = new_size;
-	cio->start = jpwl_buf - new_size;
-	cio->end = jpwl_buf - 1;
-	cio->bp = jpwl_buf - new_size;
-	cio_seek(cio, new_size);
+	cio->cinfo = cio->cinfo; /* no change */
+	cio->openmode = cio->openmode; /* no change */
+	cio->buffer = orig_buf;
+	cio->length = new_size + soc_pos;
+	cio->start = cio->buffer;
+	cio->end = cio->buffer + cio->length;
+	cio->bp = cio->buffer;
+	cio_seek(cio, soc_pos + new_size);
 
 }
 
@@ -864,6 +1007,10 @@
 		cio_write(cio, Pcrc, 2);
 
 	cio_seek(cio, Lepcp + Lepc);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, Lepcp - 2, Lepc + 2);
+
 }
 
 void j2k_read_epb(opj_j2k_t *j2k) {
@@ -1012,6 +1159,9 @@
 	cio_write(cio, Lepb, 2);		/* Lepb */
 
 	cio_seek(cio, Lepbp + Lepb);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, Lepbp - 2, Lepb + 2);
 }
 
 void j2k_read_esd(opj_j2k_t *j2k) {
@@ -1136,3 +1286,69 @@
 /*@}*/
 
 #endif /* USE_JPWL */
+
+
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+
+/** @name Local static functions */
+/*@{*/
+
+void j2k_read_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the SEC length */
+	Lsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"SEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Lsec - 2);  
+}
+
+void j2k_write_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec = 24;
+	int i;
+
+	opj_cio_t *cio = j2k->cio;
+
+	cio_write(cio, J2K_MS_SEC, 2);	/* SEC */
+	cio_write(cio, Lsec, 2);
+
+	/* write dummy data */
+	for (i = 0; i < Lsec - 2; i++)
+		cio_write(cio, 0, 1);
+}
+
+void j2k_read_insec(opj_j2k_t *j2k) {
+	unsigned short int Linsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the INSEC length */
+	Linsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"INSEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Linsec - 2);  
+}
+
+
+/*@}*/
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
diff -urN /home/robin/sldeb/trunk/jpwl/jpwl.h ./jpwl/jpwl.h
--- /home/robin/sldeb/trunk/jpwl/jpwl.h	2007-02-23 18:24:49.000000000 +0000
+++ ./jpwl/jpwl.h	2007-11-27 22:39:51.000000000 +0000
@@ -206,6 +206,14 @@
 }	jpwl_marker_t;
 
 /**
+Encode according to JPWL specs
+@param j2k J2K handle
+@param cio codestream handle
+@param image image handle
+*/
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image);
+
+/**
 Prepare the list of JPWL markers, after the Part 1 codestream
 has been finalized (index struct is full)
 @param j2k J2K handle
@@ -227,6 +235,7 @@
 @param j2k J2K handle
 */
 void j2k_read_epc(opj_j2k_t *j2k);
+
 /**
 Write the EPC marker (Error Protection Capability), BUT the DL field is always set to 0
 (this simplifies the management of EPBs and it is openly stated in the standard
@@ -235,21 +244,25 @@
 @param j2k J2K handle
 */
 void j2k_write_epc(opj_j2k_t *j2k);
+
 /**
 Read the EPB marker (Error Protection Block)
 @param j2k J2K handle
 */
 void j2k_read_epb(opj_j2k_t *j2k);
+
 /**
 Write the EPB marker (Error Protection Block)
 @param j2k J2K handle
 */
 void j2k_write_epb(opj_j2k_t *j2k);
+
 /**
 Read the ESD marker (Error Sensitivity Descriptor)
 @param j2k J2K handle
 */
 void j2k_read_esd(opj_j2k_t *j2k);
+
 /**
 Read the RED marker (Residual Error Descriptor)
 @param j2k J2K handle
@@ -321,6 +334,8 @@
 
 bool jpwl_epb_fill(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf, unsigned char *post_buf);
 
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
+
 /** corrects the data in the JPWL codestream
 @param j2k J2K compressor handle
 @return true if correction is performed correctly
@@ -379,5 +394,32 @@
 
 #endif /* USE_JPWL */
 
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+/**
+Read the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_sec(opj_j2k_t *j2k);
+
+/**
+Write the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_write_sec(opj_j2k_t *j2k);
+
+/**
+Read the INSEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_insec(opj_j2k_t *j2k);
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
 #endif /* __JPWL_H */
 
diff -urN /home/robin/sldeb/trunk/jpwl/JPWL_image_to_j2k.dsp ./jpwl/JPWL_image_to_j2k.dsp
--- /home/robin/sldeb/trunk/jpwl/JPWL_image_to_j2k.dsp	2007-03-27 18:18:56.000000000 +0100
+++ ./jpwl/JPWL_image_to_j2k.dsp	2007-09-28 11:33:51.000000000 +0100
@@ -42,7 +42,8 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /FR /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /c
+# SUBTRACT CPP /YX
 # ADD BASE RSC /l 0x80c /d "NDEBUG"
 # ADD RSC /l 0x80c /d "NDEBUG"
 BSC32=bscmake.exe
@@ -50,7 +51,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWL.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"Release"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWL.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /libpath:"Release"
 
 !ELSEIF  "$(CFG)" == "JPWL_image_to_j2k - Win32 Debug"
 
@@ -66,7 +67,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /FR /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /GZ /c
 # ADD BASE RSC /l 0x80c /d "_DEBUG"
 # ADD RSC /l 0x80c /d "_DEBUG"
 BSC32=bscmake.exe
diff -urN /home/robin/sldeb/trunk/jpwl/JPWL_j2k_to_image.dsp ./jpwl/JPWL_j2k_to_image.dsp
--- /home/robin/sldeb/trunk/jpwl/JPWL_j2k_to_image.dsp	2007-03-27 18:18:56.000000000 +0100
+++ ./jpwl/JPWL_j2k_to_image.dsp	2007-09-28 11:33:51.000000000 +0100
@@ -42,7 +42,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
 # ADD BASE RSC /l 0x80c /d "NDEBUG"
 # ADD RSC /l 0x80c /d "NDEBUG"
 BSC32=bscmake.exe
@@ -50,7 +50,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmt.lib"
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386
 
 !ELSEIF  "$(CFG)" == "JPWL_j2k_to_image - Win32 Debug"
 
@@ -66,7 +66,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
 # ADD BASE RSC /l 0x80c /d "_DEBUG"
 # ADD RSC /l 0x80c /d "_DEBUG"
 BSC32=bscmake.exe
@@ -74,7 +74,7 @@
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib  ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept
 
 !ENDIF 
 
@@ -91,28 +91,12 @@
 # End Source File
 # Begin Source File
 
-SOURCE=.\crc.c
-# End Source File
-# Begin Source File
-
 SOURCE=..\codec\compat\getopt.c
 # End Source File
 # Begin Source File
 
 SOURCE=..\codec\j2k_to_image.c
 # End Source File
-# Begin Source File
-
-SOURCE=.\jpwl.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\jpwl_lib.c
-# End Source File
-# Begin Source File
-
-SOURCE=.\rs.c
-# End Source File
 # End Group
 # Begin Group "Header Files"
 
diff -urN /home/robin/sldeb/trunk/jpwl/jpwl_lib.c ./jpwl/jpwl_lib.c
--- /home/robin/sldeb/trunk/jpwl/jpwl_lib.c	2007-02-23 01:23:05.000000000 +0000
+++ ./jpwl/jpwl_lib.c	2007-11-27 22:39:51.000000000 +0000
@@ -32,6 +32,7 @@
 #ifdef USE_JPWL
 
 #include "../libopenjpeg/opj_includes.h"
+#include <limits.h>
 
 /** Minimum and maximum values for the double->pfp conversion */
 #define MIN_V1 0.0
@@ -128,21 +129,26 @@
 	while (post_len > 0) {
 
 		/* maximum postlen in order to respect EPB size
-		(we use 65450 instead of 65535 for keeping room for EPB parms)*/
+		(we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms)*/
 		/*      (message word size)    *            (number of containable parity words)  */
-		max_postlen = k_post * (unsigned long int) floor(65450.0 / (double) (n_post - k_post));
+		max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
 
 		/* maximum postlen in order to respect EPB size */
 		if (*idx == 0)
-			/* (we use (65500 - L2) instead of 65535 for keeping room for EPB parms + pre-data) */
+			/* (we use (JPWL_MAXIMUM_EPB_ROOM - L2) instead of 65535 for keeping room for EPB parms + pre-data) */
 			/*      (message word size)    *                   (number of containable parity words)  */
-			max_postlen = k_post * (unsigned long int) floor((double) (65500 - L2) / (double) (n_post - k_post));
+			max_postlen = k_post * (unsigned long int) floor((double) (JPWL_MAXIMUM_EPB_ROOM - L2) / (double) (n_post - k_post));
 
 		else
-			/* (we use 65500 instead of 65535 for keeping room for EPB parms) */
+			/* (we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms) */
 			/*      (message word size)    *            (number of containable parity words)  */
-			max_postlen = k_post * (unsigned long int) floor(65500.0 / (double) (n_post - k_post));
+			max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
 
+		/* null protection case */
+		/* the max post length can be as large as the LDPepb field can host */
+		if (hprot == 0)
+			max_postlen = INT_MAX;
+		
 		/* length to use */
 		dL4 = min(max_postlen, post_len);
 
@@ -289,7 +295,7 @@
 	return epb;
 }
 
-void jpwl_epb_write(jpwl_epb_ms_t *epb, unsigned char *buf) {
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epb, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_EPB >> 8); 
@@ -317,6 +323,10 @@
 	/* Data */
 	/*memcpy(buf, epb->data, (size_t) epb->Lepb - 11);*/
 	memset(buf, 0, (size_t) epb->Lepb - 11);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, -1, epb->Lepb + 2);
+
 };
 
 
@@ -651,7 +661,7 @@
 	j2k->state = J2K_STATE_MHSOC;
 
 	/* cycle all over the markers */
-	while (cio_tell(cio) < cio->length) {
+	while ((unsigned int) cio_tell(cio) < cio->length) {
 
 		/* read the marker */
 		mark_pos = cio_tell(cio);
@@ -793,7 +803,7 @@
 	/* Initialize RS structures */
 	P = n_pre - k_pre;
 	NN_P = NN - P;
-	tt = (int) floor((float) P / 2.0F);
+	tt = (int) floor((float) P / 2.0F); /* correction capability of the code */
 	memset(codeword, 0, NN);
 	parityword = codeword + NN_P;
 	init_rs(NN_P);
@@ -834,7 +844,8 @@
 			/*if (conn == NULL)
 				opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
 
-		} else if (status < tt) {
+		} else if (status <= tt) {
+			/* it has corrected 0 <= errs <= tt */
 			/*if (conn == NULL)
 				opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
 			errnum += status;
@@ -848,21 +859,21 @@
 
 
 		/* advance parity buffer */
-		if ((status >= 0) && (status < tt))
+		if ((status >= 0) && (status <= tt))
 			/* copy back corrected parity only if all is OK */
 			memcpy(L2_buf, parityword, P);
 		L2_buf += P;
 
 		/* advance message buffer */
 		if (remaining < k_pre) {
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L1_buf, codeword, remaining);
 			L1_buf += remaining;
 			remaining = 0;
 
 		} else {
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L1_buf, codeword, k_pre);
 			L1_buf += k_pre;
@@ -1043,7 +1054,7 @@
 		/* Initialize RS structures */
 		P = n_post - k_post;
 		NN_P = NN - P;
-		tt = (int) floor((float) P / 2.0F);
+		tt = (int) floor((float) P / 2.0F); /* again, correction capability */
 		memset(codeword, 0, NN);
 		parityword = codeword + NN_P;
 		init_rs(NN_P);
@@ -1080,7 +1091,7 @@
 				/*if (conn == NULL)
 					opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
 
-			} else if (status < tt) {
+			} else if (status <= tt) {
 				/*if (conn == NULL)
 					opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
 				errnum += status;
@@ -1094,21 +1105,21 @@
 
 
 			/* advance parity buffer */
-			if ((status >= 0) && (status < tt))
+			if ((status >= 0) && (status <= tt))
 				/* copy back corrected data only if all is OK */
 				memcpy(L3_buf, parityword, P);
 			L3_buf += P;
 
 			/* advance message buffer */
 			if (remaining < k_post) {
-				if ((status >= 0) && (status < tt))
+				if ((status >= 0) && (status <= tt))
 					/* copy back corrected data only if all is OK */
 					memcpy(L4_buf, codeword, remaining);
 				L4_buf += remaining;
 				remaining = 0;
 
 			} else {
-				if ((status >= 0) && (status < tt))
+				if ((status >= 0) && (status <= tt))
 					/* copy back corrected data only if all is OK */
 					memcpy(L4_buf, codeword, k_post);
 				L4_buf += k_post;
@@ -1138,7 +1149,7 @@
 	return true;
 }
 
-void jpwl_epc_write(jpwl_epc_ms_t *epc, unsigned char *buf) {
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epc, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_EPC >> 8); 
@@ -1164,6 +1175,10 @@
 	/* Data */
 	/*memcpy(buf, epc->data, (size_t) epc->Lepc - 9);*/
 	memset(buf, 0, (size_t) epc->Lepc - 9);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, -1, epc->Lepc + 2);
+
 };
 
 int jpwl_esds_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
@@ -1215,7 +1230,7 @@
 		if (ad_size == 0)
 			/* if there are more than 66% of (2^16 - 1) bytes, switch to 4 bytes
 			 (we keep space for possible EPBs being inserted) */
-			ad_size = (j2k->image_info->codestream_size > (1 * 65535 / 3)) ? 4 : 2;
+			ad_size = (j2k->cstr_info->codestream_size > (1 * 65535 / 3)) ? 4 : 2;
 		esd->sensval_size = ad_size + ad_size + se_size; 
 		break;
 
@@ -1224,7 +1239,7 @@
 		/* auto sense address size */
 		if (ad_size == 0)
 			/* if there are more than 2^16 - 1 packets, switch to 4 bytes */
-			ad_size = (j2k->image_info->num > 65535) ? 4 : 2;
+			ad_size = (j2k->cstr_info->packno > 65535) ? 4 : 2;
 		esd->sensval_size = ad_size + ad_size + se_size; 
 		break;
 
@@ -1245,17 +1260,17 @@
 		/* just based on the portions of a codestream */
 		case (0):
 			/* MH + no. of THs + no. of packets */
-			svalnum = 1 + (j2k->image_info->tw * j2k->image_info->th) * (1 + j2k->image_info->num);
+			svalnum = 1 + (j2k->cstr_info->tw * j2k->cstr_info->th) * (1 + j2k->cstr_info->packno);
 			break;
 
 		/* all the ones that are based on the packets */
 		default:
 			if (tileno < 0)
 				/* MH: all the packets and all the tiles info is written */
-				svalnum = j2k->image_info->tw * j2k->image_info->th * j2k->image_info->num;
+				svalnum = j2k->cstr_info->tw * j2k->cstr_info->th * j2k->cstr_info->packno;
 			else
 				/* TPH: only that tile info is written */
-				svalnum = j2k->image_info->num;
+				svalnum = j2k->cstr_info->packno;
 			break;
 
 		}
@@ -1355,26 +1370,26 @@
 		buf += 7;
 
 	/* let's fill the data fields */
-	for (vv = (esd->tileno < 0) ? 0 : (j2k->image_info->num * esd->tileno); vv < esd->svalnum; vv++) {
+	for (vv = (esd->tileno < 0) ? 0 : (j2k->cstr_info->packno * esd->tileno); vv < esd->svalnum; vv++) {
 
-		int thistile = vv / j2k->image_info->num, thispacket = vv % j2k->image_info->num;
+		int thistile = vv / j2k->cstr_info->packno, thispacket = vv % j2k->cstr_info->packno;
 
 		/* skip for the hack some lines below */
-		if (thistile == j2k->image_info->tw * j2k->image_info->th)
+		if (thistile == j2k->cstr_info->tw * j2k->cstr_info->th)
 			break;
 
 		/* starting tile distortion */
 		if (thispacket == 0) {
-			TSE = j2k->image_info->tile[thistile].distotile;
-			oldMSE = TSE / j2k->image_info->tile[thistile].nbpix;
+			TSE = j2k->cstr_info->tile[thistile].distotile;
+			oldMSE = TSE / j2k->cstr_info->tile[thistile].numpix;
 			oldPSNR = 10.0 * log10(Omax2 / oldMSE);
 		}
 
 		/* TSE */
-		TSE -= j2k->image_info->tile[thistile].packet[thispacket].disto;
+		TSE -= j2k->cstr_info->tile[thistile].packet[thispacket].disto;
 
 		/* MSE */
-		MSE = TSE / j2k->image_info->tile[thistile].nbpix;
+		MSE = TSE / j2k->cstr_info->tile[thistile].numpix;
 
 		/* PSNR */
 		PSNR = 10.0 * log10(Omax2 / MSE);
@@ -1390,9 +1405,9 @@
 		/* byte range */
 		case (1):
 			/* start address of packet */
-			addr1 = (j2k->image_info->tile[thistile].packet[thispacket].start_pos) & addrmask;
+			addr1 = (j2k->cstr_info->tile[thistile].packet[thispacket].start_pos) & addrmask;
 			/* end address of packet */
-			addr2 = (j2k->image_info->tile[thistile].packet[thispacket].end_pos) & addrmask;
+			addr2 = (j2k->cstr_info->tile[thistile].packet[thispacket].end_pos) & addrmask;
 			break;
 
 		/* packet range */
@@ -1416,7 +1431,7 @@
 			if ((thistile == 0) && !doneMH) {
 				/* we have to manage MH addresses */
 				addr1 = 0; /* start of MH */
-				addr2 = j2k->image_info->main_head_end; /* end of MH */
+				addr2 = j2k->cstr_info->main_head_end; /* end of MH */
 				/* set special dvalue for this MH */
 				dvalue = -10.0;
 				doneMH = true; /* don't come here anymore */
@@ -1424,8 +1439,8 @@
 
 			} else if (!doneTPH) {
 				/* we have to manage TPH addresses */
-				addr1 = j2k->image_info->tile[thistile].start_pos;
-				addr2 = j2k->image_info->tile[thistile].end_header;
+				addr1 = j2k->cstr_info->tile[thistile].start_pos;
+				addr2 = j2k->cstr_info->tile[thistile].end_header;
 				/* set special dvalue for this TPH */
 				dvalue = -1.0;
 				doneTPH = true; /* don't come here till the next tile */
@@ -1483,7 +1498,7 @@
 			else
 				/* packet: first is most important, and then in decreasing order
 				down to the last, which counts for 1 */
-				dvalue = jpwl_pfp_to_double((unsigned short) (j2k->image_info->num - thispacket), esd->se_size);
+				dvalue = jpwl_pfp_to_double((unsigned short) (j2k->cstr_info->packno - thispacket), esd->se_size);
 			break;
 
 		/* MSE */
@@ -1554,7 +1569,7 @@
 	return true;
 }
 
-void jpwl_esd_write(jpwl_esd_ms_t *esd, unsigned char *buf) {
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esd, unsigned char *buf) {
 
 	/* Marker */
 	*(buf++) = (unsigned char) (J2K_MS_ESD >> 8); 
@@ -1579,6 +1594,10 @@
 	else
 		memset(buf, 0xAA, (size_t) esd->Lesd - 5);
 		/*memcpy(buf, esd->data, (size_t) esd->Lesd - 5);*/
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_ESD, -1, esd->Lesd + 2);
+
 }
 
 unsigned short int jpwl_double_to_pfp(double V, int bytes) {
@@ -1656,8 +1675,8 @@
 	int mm;
 	unsigned long int addlen;
 
-	opj_image_info_t *info = j2k->image_info;
-	int tileno, packno, numtiles = info->th * info->tw, numpacks = info->num;
+	opj_codestream_info_t *info = j2k->cstr_info;
+	int tileno, tpno, packno, numtiles = info->th * info->tw, numpacks = info->packno;
 
 	if (!j2k || !jwmarker ) {
 		opj_event_msg(j2k->cinfo, EVT_ERROR, "J2K handle or JPWL markers list badly allocated\n");
@@ -1696,22 +1715,56 @@
 
 		/* end_pos: increment with markers before the end of this tile */
 		/* code is disabled, since according to JPWL no markers can be beyond TPH */
-		/*addlen = 0;
+		addlen = 0;
 		for (mm = 0; mm < jwmarker_num; mm++)
 			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].end_pos)
-				addlen += jwmarker[mm].len + 2;*/
+				addlen += jwmarker[mm].len + 2;
 		info->tile[tileno].end_pos += addlen;
 
+		/* navigate through all the tile parts */
+		for (tpno = 0; tpno < info->tile[tileno].num_tps; tpno++) {
+
+			/* start_pos: increment with markers before SOT */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_start_pos += addlen;
+
+			/* end_header: increment with markers before of it */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_header)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_header += addlen;
+
+			/* end_pos: increment with markers before the end of this tile part */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_pos += addlen;
+
+		}
+
 		/* navigate through all the packets in this tile */
 		for (packno = 0; packno < numpacks; packno++) {
 			
 			/* start_pos: increment with markers before the packet */
 			/* disabled for the same reason as before */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos <= (unsigned long int) info->tile[tileno].packet[packno].start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].packet[packno].start_pos += addlen;
+
+			/* end_ph_pos: increment with markers before the packet */
+			/* disabled for the same reason as before */
 			/*addlen = 0;
 			for (mm = 0; mm < jwmarker_num; mm++)
-				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].start_pos)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].end_ph_pos)
 					addlen += jwmarker[mm].len + 2;*/
-			info->tile[tileno].packet[packno].start_pos += addlen;
+			info->tile[tileno].packet[packno].end_ph_pos += addlen;
 
 			/* end_pos: increment if marker is before the end of packet */
 			/* disabled for the same reason as before */
@@ -1724,6 +1777,8 @@
 		}
 	}
 
+	/* reorder the markers list */
+
 	return true;
 }
 
diff -urN /home/robin/sldeb/trunk/jpwl/LibOpenJPEG_JPWL.dsp ./jpwl/LibOpenJPEG_JPWL.dsp
--- /home/robin/sldeb/trunk/jpwl/LibOpenJPEG_JPWL.dsp	2007-03-27 13:48:17.000000000 +0100
+++ ./jpwl/LibOpenJPEG_JPWL.dsp	2007-11-27 22:39:51.000000000 +0000
@@ -245,6 +245,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=..\libopenjpeg\opj_malloc.h
+# End Source File
+# Begin Source File
+
 SOURCE=..\libopenjpeg\pi.h
 # End Source File
 # Begin Source File
diff -urN /home/robin/sldeb/trunk/jpwl/Makefile ./jpwl/Makefile
--- /home/robin/sldeb/trunk/jpwl/Makefile	2007-02-23 18:24:49.000000000 +0000
+++ ./jpwl/Makefile	2007-11-27 22:39:51.000000000 +0000
@@ -1,33 +1,83 @@
-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
-
-# General configuration variables:
-CC = gcc
-AR = ar
-
-CFLAGS = -O3 -DUSE_JPWL # -g -p -pg -DUSE_JPWL
-
-OPJ_SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c
-JPWL_SRCS = crc.c jpwl.c jpwl_lib.c rs.c
-
-TARGET  = openjpeg_JPWL
-STATICLIB = lib$(TARGET).a
-
-MODULES = $(OPJ_SRCS:.c=.o) $(JPWL_SRCS:.c=.o)
-
-all: JPWL_image_to_j2k JPWL_j2k_to_image
-
-.c.o:
-	$(CC) $(CFLAGS) -c $< -o $@
-
-$(STATICLIB): $(MODULES)
-	$(AR) r $@ $(MODULES)
-
-JPWL_j2k_to_image: ../codec/j2k_to_image.c $(STATICLIB)
-	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
-
-JPWL_image_to_j2k: ../codec/image_to_j2k.c $(STATICLIB)
-	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -lstdc++ 
-
-clean:
-	rm -f JPWL_j2k_to_image JPWL_image_to_j2k *.o *.a
-	cd ../libopenjpeg; rm -f *.o
+# Linux makefile for OpenJPEG + JPWL
+
+VER_MAJOR = 2
+VER_MINOR = 1.2.0
+
+JPWL_SRCS = ./crc.c ./jpwl.c ./jpwl_lib.c ./rs.c
+SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c $(JPWL_SRCS)
+INCLS = ../libopenjpeg/bio.h ../libopenjpeg/cio.h ../libopenjpeg/dwt.h ../libopenjpeg/event.h ../libopenjpeg/fix.h ../libopenjpeg/image.h ../libopenjpeg/int.h ../libopenjpeg/j2k.h ../libopenjpeg/j2k_lib.h ../libopenjpeg/jp2.h ../libopenjpeg/jpt.h ../libopenjpeg/mct.h ../libopenjpeg/mqc.h ../libopenjpeg/openjpeg.h ../libopenjpeg/pi.h ../libopenjpeg/raw.h ../libopenjpeg/t1.h ../libopenjpeg/t2.h ../libopenjpeg/tcd.h ../libopenjpeg/tgt.h ../libopenjpeg/opj_malloc.h ../libopenjpeg/opj_includes.h
+INCLUDE = -Ilibopenjpeg_JPWL
+
+# General configuration variables:
+CC = gcc
+AR = ar
+
+PREFIX = /usr
+INSTALL_LIBDIR = $(PREFIX)/lib
+INSTALL_INCLUDE = $(PREFIX)/include
+
+# Converts cr/lf to just lf
+DOS2UNIX = dos2unix
+
+COMPILERFLAGS = -O3 -fPIC
+LIBRARIES = -lstdc++
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE) -DUSE_JPWL
+
+TARGET  = openjpeg_JPWL
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
+LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
+
+
+
+default: all
+
+all: OpenJPEG_JPWL JPWL_image_to_j2k JPWL_j2k_to_image
+
+dist: OpenJPEG_JPWL
+	install -d dist
+	install -m 644 $(STATICLIB) dist
+	install -m 755 $(SHAREDLIB) dist
+	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
+	install libopenjpeg/openjpeg.h dist
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+OpenJPEG_JPWL: $(STATICLIB) $(SHAREDLIB)
+
+JPWL_codec: JPWL_j2k_to_image JPWL_image_to_j2k $(STATICLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(AR) r $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
+
+JPWL_j2k_to_image: ../codec/j2k_to_image.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+JPWL_image_to_j2k: ../codec/image_to_j2k.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+install: OpenJPEG
+	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
+	install -m 644 -o root -g root $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
+	install -m 755 -o root -g root $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
+	install -m 644 -o root -g root libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
+	-ldconfig
+
+cleanlib:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+
+cleancodec:
+	rm -f JPWL_j2k_to_image JPWL_image_to_j2k JPWL_j2k_to_image.o JPWL_image_to_j2k.o
+
+clean: cleanlib cleancodec
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/all-wcprops ./jpwl/.svn/all-wcprops
--- /home/robin/sldeb/trunk/jpwl/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/all-wcprops	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,95 @@
+K 25
+svn:wc:ra_dav:version-url
+V 28
+/svn/!svn/ver/469/trunk/jpwl
+END
+LibOpenJPEG_JPWL.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/469/trunk/jpwl/LibOpenJPEG_JPWL.dsp
+END
+JPWL_image_to_j2k.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/315/trunk/jpwl/JPWL_image_to_j2k.dsw
+END
+JPWL_j2k_to_image.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/315/trunk/jpwl/JPWL_j2k_to_image.dsw
+END
+jpwl_lib.c
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/469/trunk/jpwl/jpwl_lib.c
+END
+crc.c
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/347/trunk/jpwl/crc.c
+END
+crc.h
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/347/trunk/jpwl/crc.h
+END
+jpwl.c
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/469/trunk/jpwl/jpwl.c
+END
+jpwl.h
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/469/trunk/jpwl/jpwl.h
+END
+rs.c
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/347/trunk/jpwl/rs.c
+END
+rs.h
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/364/trunk/jpwl/rs.h
+END
+JPWL_image_to_j2k.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/455/trunk/jpwl/JPWL_image_to_j2k.dsp
+END
+JPWL_j2k_to_image.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/432/trunk/jpwl/JPWL_j2k_to_image.dsp
+END
+README.txt
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/347/trunk/jpwl/README.txt
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/435/trunk/jpwl/CMakeLists.txt
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 37
+/svn/!svn/ver/469/trunk/jpwl/Makefile
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/dir-prop-base ./jpwl/.svn/dir-prop-base
--- /home/robin/sldeb/trunk/jpwl/.svn/dir-prop-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/dir-prop-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 10
+svn:ignore
+V 81
+JPWL_image_to_j2k.ncb
+Debug
+LibOpenJPEG_JPWL___Win32_Debug
+JPWL_image_to_j2k.plg
+
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/entries ./jpwl/.svn/entries
--- /home/robin/sldeb/trunk/jpwl/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,221 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/jpwl
+http://www.openjpeg.org/svn
+
+
+
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+LibOpenJPEG_JPWL.dsp
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+8e1a53746c2b8093677329eae95c912d
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
+JPWL_image_to_j2k.dsw
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+f221b4da75e3e94923dd3c4a96e0d2c9
+2006-12-04T16:16:15.087629Z
+315
+devaux
+has-props
+
+JPWL_j2k_to_image.dsw
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+f4b9f24d7eb251784d155a8f9f84e0dc
+2006-12-04T16:16:15.087629Z
+315
+devaux
+has-props
+
+jpwl_lib.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+888bbd14cb3a71eeee47b3a19e7f8bbf
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
+crc.c
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+c49cab8f8bfebd36faf9d84ed5d64a9f
+2007-02-23T18:24:49.769815Z
+347
+unipg
+has-props
+
+crc.h
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+a4fcedb0e7c7966719b58872d3c58a26
+2007-02-23T18:24:49.769815Z
+347
+unipg
+has-props
+
+jpwl.c
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+5a05d18ecfb9853ac17d39a8b3286117
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+jpwl.h
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+78fa1dcb70c0f203976954bb5cc58c8d
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
+rs.c
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+3e2e4df3ea239ab2906b27d073ff4ffd
+2007-02-23T18:24:49.769815Z
+347
+unipg
+has-props
+
+rs.h
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+47e357ed7f31f2f8d835cff936b5c34b
+2007-03-27T12:48:17.101066Z
+364
+unipg
+has-props
+
+JPWL_image_to_j2k.dsp
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+3ca552e44dae21d56dc3cd3d02fa3aa1
+2007-09-11T15:21:12.790511Z
+455
+unipg
+has-props
+
+JPWL_j2k_to_image.dsp
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+2366e937ca939d9c81ed30a10b91c6b3
+2007-09-03T13:30:59.661352Z
+432
+unipg
+has-props
+
+README.txt
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+905f55a43ab804841e9e23b470950ce2
+2007-02-23T18:24:49.769815Z
+347
+unipg
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:51.000000Z
+5583561beb2645f82787b5a7fa8becde
+2007-09-06T10:23:40.517894Z
+435
+gdcm
+has-props
+
+Makefile
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+8d635539e619190e588656396eb9f2ba
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/format ./jpwl/.svn/format
--- /home/robin/sldeb/trunk/jpwl/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/format	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/CMakeLists.txt.svn-base ./jpwl/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,13 @@
+K 13
+svn:eol-style
+V 6
+native
+K 14
+svn:executable
+V 1
+*
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/crc.c.svn-base ./jpwl/.svn/prop-base/crc.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/crc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/crc.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,5 @@
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/crc.h.svn-base ./jpwl/.svn/prop-base/crc.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/crc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/crc.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/jpwl.h.svn-base ./jpwl/.svn/prop-base/jpwl.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/jpwl.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/jpwl.h.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_image_to_j2k.dsp.svn-base ./jpwl/.svn/prop-base/JPWL_image_to_j2k.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_image_to_j2k.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/JPWL_image_to_j2k.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_image_to_j2k.dsw.svn-base ./jpwl/.svn/prop-base/JPWL_image_to_j2k.dsw.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_image_to_j2k.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/JPWL_image_to_j2k.dsw.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_j2k_to_image.dsp.svn-base ./jpwl/.svn/prop-base/JPWL_j2k_to_image.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_j2k_to_image.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/JPWL_j2k_to_image.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_j2k_to_image.dsw.svn-base ./jpwl/.svn/prop-base/JPWL_j2k_to_image.dsw.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/JPWL_j2k_to_image.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/JPWL_j2k_to_image.dsw.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/jpwl_lib.c.svn-base ./jpwl/.svn/prop-base/jpwl_lib.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/jpwl_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/jpwl_lib.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/LibOpenJPEG_JPWL.dsp.svn-base ./jpwl/.svn/prop-base/LibOpenJPEG_JPWL.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/LibOpenJPEG_JPWL.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/LibOpenJPEG_JPWL.dsp.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/Makefile.svn-base ./jpwl/.svn/prop-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/Makefile.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,5 @@
+K 14
+svn:executable
+V 1
+*
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/rs.c.svn-base ./jpwl/.svn/prop-base/rs.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/rs.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/rs.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/prop-base/rs.h.svn-base ./jpwl/.svn/prop-base/rs.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/prop-base/rs.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/prop-base/rs.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/CMakeLists.txt.svn-base ./jpwl/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,55 @@
+# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
+
+ADD_DEFINITIONS(-DUSE_JPWL)
+
+SET(OPJ_SRCS 
+../libopenjpeg/bio.c 
+../libopenjpeg/cio.c 
+../libopenjpeg/dwt.c 
+../libopenjpeg/event.c 
+../libopenjpeg/image.c 
+../libopenjpeg/j2k.c 
+../libopenjpeg/j2k_lib.c 
+../libopenjpeg/jp2.c 
+../libopenjpeg/jpt.c 
+../libopenjpeg/mct.c 
+../libopenjpeg/mqc.c 
+../libopenjpeg/openjpeg.c 
+../libopenjpeg/pi.c 
+../libopenjpeg/raw.c 
+../libopenjpeg/t1.c 
+../libopenjpeg/t2.c 
+../libopenjpeg/tcd.c 
+../libopenjpeg/tgt.c
+)
+SET(JPWL_SRCS crc.c jpwl.c jpwl_lib.c rs.c)
+
+ADD_LIBRARY(openjpeg_JPWL ${JPWL_SRCS} ${OPJ_SRCS})
+
+# Do the proper thing when building static...if only there was configured
+# headers or def files instead
+#IF(NOT BUILD_SHARED_LIBS)
+#  ADD_DEFINITIONS(-DOPJ_STATIC)
+#ENDIF(NOT BUILD_SHARED_LIBS)
+
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+FIND_PACKAGE(TIFF REQUIRED)
+
+ADD_EXECUTABLE(JPWL_j2k_to_image
+../codec/convert.c ../codec/j2k_to_image.c
+)
+TARGET_LINK_LIBRARIES(JPWL_j2k_to_image openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_j2k_to_image m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(JPWL_image_to_j2k
+../codec/convert.c ../codec/image_to_j2k.c)
+TARGET_LINK_LIBRARIES(JPWL_image_to_j2k openjpeg_JPWL ${TIFF_LIBRARIES})
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(JPWL_image_to_j2k m)
+ENDIF(UNIX)
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/crc.c.svn-base ./jpwl/.svn/text-base/crc.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/crc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/crc.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,160 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef USE_JPWL
+
+#include "crc.h"
+
+/**
+@file crc.c
+@brief Functions used to compute the 16- and 32-bit CRC of byte arrays
+
+*/
+
+/** file: CRC16.CPP
+ *
+ * CRC - Cyclic Redundancy Check (16-bit)
+ *
+ * A CRC-checksum is used to be sure, the data hasn't changed or is false.
+ * To create a CRC-checksum, initialise a check-variable (unsigned short),
+ * and set this to zero. Than call for every byte in the file (e.g.) the
+ * procedure updateCRC16 with this check-variable as the first parameter,
+ * and the byte as the second. At the end, the check-variable contains the
+ * CRC-checksum.
+ *
+ * implemented by Michael Neumann, 14.06.1998
+ * 
+ */
+const unsigned short CRC16_table[256] = {
+	0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7, 
+	0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef, 
+	0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6, 
+	0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,
+	0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485, 
+	0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d, 
+	0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4, 
+	0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc, 
+	0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823, 
+	0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b, 
+	0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12, 
+	0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,
+	0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41, 
+	0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49, 
+	0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70, 
+	0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78, 
+	0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f, 
+	0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,
+	0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e, 
+	0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256, 
+	0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,
+	0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405, 
+	0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c, 
+	0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634, 
+	0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab, 
+	0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3, 
+	0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a, 
+	0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92, 
+	0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9, 
+	0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1, 
+	0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8, 
+	0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0
+};
+
+void updateCRC16(unsigned short *crc, unsigned char data) {
+	*crc = CRC16_table[(*crc >> 8) & 0xFF] ^ (*crc << 8) ^ data;
+};
+
+
+/** file: CRC32.CPP
+ *
+ * CRC - Cyclic Redundancy Check (32-bit)
+ *
+ * A CRC-checksum is used to be sure, the data hasn't changed or is false.
+ * To create a CRC-checksum, initialise a check-variable (unsigned long),
+ * and set this to zero. Than call for every byte in the file (e.g.) the
+ * procedure updateCRC32 with this check-variable as the first parameter,
+ * and the byte as the second. At the end, the check-variable contains the
+ * CRC-checksum.
+ *
+ * implemented by Michael Neumann, 14.06.1998
+ *
+ */
+const unsigned long CRC32_table[256] = {
+	0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
+	0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
+	0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
+	0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
+	0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
+	0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
+	0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
+	0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
+	0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
+	0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
+	0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
+	0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
+	0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
+	0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
+	0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
+	0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
+	0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
+	0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
+	0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
+	0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
+	0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
+	0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
+	0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
+	0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
+	0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
+	0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
+	0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
+	0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
+	0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
+	0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
+	0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
+	0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
+	0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
+	0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
+	0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
+	0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
+	0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
+	0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
+	0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
+	0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
+	0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
+	0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
+	0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
+};
+
+void updateCRC32(unsigned long *crc, unsigned char data) {
+	*crc = CRC32_table[(unsigned char) *crc ^ data] ^ ((*crc >> 8) & 0x00FFFFFF);
+};
+
+#endif /* USE_JPWL */
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/crc.h.svn-base ./jpwl/.svn/text-base/crc.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/crc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/crc.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,84 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef USE_JPWL
+
+/**
+@file crc.h
+@brief Functions used to compute the 16- and 32-bit CRC of byte arrays
+
+*/
+
+#ifndef __CRC16_HEADER__
+#define __CRC16_HEADER__
+
+/** file: CRC16.HPP
+ *
+ * CRC - Cyclic Redundancy Check (16-bit)
+ *
+ * A CRC-checksum is used to be sure, the data hasn't changed or is false.
+ * To create a CRC-checksum, initialise a check-variable (unsigned short),
+ * and set this to zero. Than call for every byte in the file (e.g.) the
+ * procedure updateCRC16 with this check-variable as the first parameter,
+ * and the byte as the second. At the end, the check-variable contains the
+ * CRC-checksum.
+ *
+ * implemented by Michael Neumann, 14.06.1998
+ * 
+ */
+void updateCRC16(unsigned short *, unsigned char);
+
+#endif /* __CRC16_HEADER__ */
+
+
+#ifndef __CRC32_HEADER__
+#define __CRC32_HEADER__
+
+/** file: CRC32.HPP
+ *
+ * CRC - Cyclic Redundancy Check (32-bit)
+ *
+ * A CRC-checksum is used to be sure, the data hasn't changed or is false.
+ * To create a CRC-checksum, initialise a check-variable (unsigned short),
+ * and set this to zero. Than call for every byte in the file (e.g.) the
+ * procedure updateCRC32 with this check-variable as the first parameter,
+ * and the byte as the second. At the end, the check-variable contains the
+ * CRC-checksum.
+ *
+ * implemented by Michael Neumann, 14.06.1998
+ *
+ */
+void updateCRC32(unsigned long *, unsigned char);
+
+#endif /* __CRC32_HEADER__ */
+
+
+#endif /* USE_JPWL */
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl.c.svn-base ./jpwl/.svn/text-base/jpwl.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/jpwl.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,1354 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "../libopenjpeg/opj_includes.h"
+
+#ifdef USE_JPWL
+
+/** @defgroup JPWL JPWL - JPEG-2000 Part11 (JPWL) codestream manager */
+/*@{*/
+
+/** @name Local static variables */
+/*@{*/
+
+/** number of JPWL prepared markers */
+static int jwmarker_num;
+/** properties of JPWL markers to insert */
+static jpwl_marker_t jwmarker[JPWL_MAX_NO_MARKERS]; 
+
+/*@}*/
+
+/*@}*/
+
+/** @name Local static functions */
+/*@{*/
+
+/** create an EPC marker segment
+@param j2k J2K compressor handle
+@param esd_on true if ESD is activated
+@param red_on true if RED is activated
+@param epb_on true if EPB is activated
+@param info_on true if informative techniques are activated
+@return returns the freshly created EPC
+*/
+jpwl_epc_ms_t *jpwl_epc_create(opj_j2k_t *j2k, bool esd_on, bool red_on, bool epb_on, bool info_on);
+
+/*@}*/
+
+/** create an EPC marker segment
+@param j2k J2K compressor handle
+@param comps considered component (-1=average, 0/1/2/...=component no.)
+@param addrm addressing mode (0=packet, 1=byte range, 2=packet range, 3=reserved)
+@param ad_size size of addresses (2/4 bytes)
+@param senst sensitivity type
+@param se_size sensitivity values size (1/2 bytes)
+@param tileno tile where this ESD lies (-1 means MH)
+@param svalnum number of sensitivity values (if 0, they will be automatically filled)
+@param sensval pointer to an array of sensitivity values (if NULL, they will be automatically filled)
+@return returns the freshly created ESD
+*/
+jpwl_esd_ms_t *jpwl_esd_create(opj_j2k_t *j2k, int comps, unsigned char addrm, unsigned char ad_size,
+								unsigned char senst, int se_size, int tileno,
+								unsigned long int svalnum, void *sensval);
+			
+/** this function is used to compare two JPWL markers based on
+their relevant wishlist position
+@param arg1 pointer to first marker
+@param arg2 pointer to second marker
+@return 1 if arg1>arg2, 0 if arg1=arg2, -1 if arg1<arg2
+*/
+int jpwl_markcomp(const void *arg1, const void *arg2);
+
+/** write an EPB MS to a buffer
+@param j2k J2K compressor handle
+@param epbmark pointer to the EPB MS
+@param buf pointer to the memory buffer
+*/
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf);
+
+/** write an EPC MS to a buffer
+@param j2k J2K compressor handle
+@param epcmark pointer to the EPC MS
+@param buf pointer to the memory buffer
+*/
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epcmark, unsigned char *buf);
+
+/** write an ESD MS to a buffer
+@param j2k J2K compressor handle
+@param esdmark pointer to the ESD MS
+@param buf pointer to the memory buffer
+*/
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esdmark, unsigned char *buf);
+
+/*-----------------------------------------------------------------*/
+
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+
+	int mm;
+
+	/* let's reset some settings */
+
+	/* clear the existing markers */
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		switch (jwmarker[mm].id) {
+
+		case J2K_MS_EPB:
+			free(jwmarker[mm].epbmark);
+			break;
+
+		case J2K_MS_EPC:
+			free(jwmarker[mm].epcmark);
+			break;
+
+		case J2K_MS_ESD:
+			free(jwmarker[mm].esdmark);
+			break;
+
+		case J2K_MS_RED:
+			free(jwmarker[mm].redmark);
+			break;
+
+		default:
+			break;
+		}
+	}
+
+	/* clear the marker structure array */
+	memset(jwmarker, 0, sizeof(jpwl_marker_t) * JPWL_MAX_NO_MARKERS);
+
+	/* no more markers in the list */
+	jwmarker_num = 0;
+
+	/* let's begin creating a marker list, according to user wishes */
+	jpwl_prepare_marks(j2k, cio, image);
+
+	/* now we dump the JPWL markers on the codestream */
+	jpwl_dump_marks(j2k, cio, image);
+
+	/* do not know exactly what is this for,
+	but it gets called during index creation */
+	j2k->pos_correction = 0;
+
+}
+
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len) {
+
+	if (!cstr_info)
+		return;
+
+	/* expand the list? */
+	if ((cstr_info->marknum + 1) > cstr_info->maxmarknum) {
+		cstr_info->maxmarknum = 100 + (int) ((float) cstr_info->maxmarknum * 1.0F);
+		cstr_info->marker = opj_realloc(cstr_info->marker, cstr_info->maxmarknum);
+	}
+
+	/* add the marker */
+	cstr_info->marker[cstr_info->marknum].type = type;
+	cstr_info->marker[cstr_info->marknum].pos = pos;
+	cstr_info->marker[cstr_info->marknum].len = len;
+	cstr_info->marknum++;
+
+}
+
+void jpwl_prepare_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+
+	unsigned short int socsiz_len = 0;
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
+	unsigned char *socp = NULL;
+
+	int tileno, acc_tpno, tpno, tilespec, hprot, sens, pprot, packspec, lastileno, packno;
+
+	jpwl_epb_ms_t *epb_mark;
+	jpwl_epc_ms_t *epc_mark;
+	jpwl_esd_ms_t *esd_mark;
+
+	/* find (SOC + SIZ) length */
+	/* I assume SIZ is always the first marker after SOC */
+	cio_seek(cio, soc_pos + 4);
+	socsiz_len = (unsigned short int) cio_read(cio, 2) + 4; /* add the 2 marks length itself */
+	cio_seek(cio, soc_pos + 0);
+	socp = cio_getbp(cio); /* pointer to SOC */
+
+	/* 
+	 EPC MS for Main Header: if we are here it's required
+	*/
+	/* create the EPC */
+	if (epc_mark = jpwl_epc_create(
+			j2k,
+			j2k->cp->esd_on, /* is ESD present? */
+			j2k->cp->red_on, /* is RED present? */
+			j2k->cp->epb_on, /* is EPB present? */
+			false /* are informative techniques present? */
+		)) {
+
+		/* Add this marker to the 'insertanda' list */
+		if (epc_mark) {
+			jwmarker[jwmarker_num].id = J2K_MS_EPC; /* its type */
+			jwmarker[jwmarker_num].epcmark = epc_mark; /* the EPC */
+			jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
+			jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.1; /* not so first */
+			jwmarker[jwmarker_num].len = epc_mark->Lepc; /* its length */
+			jwmarker[jwmarker_num].len_ready = true; /* ready */
+			jwmarker[jwmarker_num].pos_ready = true; /* ready */
+			jwmarker[jwmarker_num].parms_ready = false; /* not ready */
+			jwmarker[jwmarker_num].data_ready = true; /* ready */
+			jwmarker_num++;
+		};
+
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"MH  EPC : setting %s%s%s\n",
+			j2k->cp->esd_on ? "ESD, " : "",
+			j2k->cp->red_on ? "RED, " : "",
+			j2k->cp->epb_on ? "EPB, " : ""
+			);
+
+	} else {
+		/* ooops, problems */
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create MH EPC\n");				
+	};
+
+	/* 
+	 ESD MS for Main Header
+	*/
+	/* first of all, must MH have an ESD MS? */
+	if (j2k->cp->esd_on && (j2k->cp->sens_MH >= 0)) {
+
+		/* Create the ESD */
+		if (esd_mark = jpwl_esd_create(
+			j2k, /* this encoder handle */
+			-1, /* we are averaging over all components */
+			(unsigned char) j2k->cp->sens_range, /* range method */
+			(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing */
+			(unsigned char) j2k->cp->sens_MH, /* sensitivity method */
+			j2k->cp->sens_size, /* sensitivity size */
+			-1, /* this ESD is in main header */
+			0 /*j2k->cstr_info->num*/, /* number of packets in codestream */
+			NULL /*sensval*/ /* pointer to sensitivity data of packets */
+			)) {
+			
+			/* Add this marker to the 'insertanda' list */
+			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+				jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
+				jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* we choose to place it after SIZ */
+				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
+				jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
+				jwmarker[jwmarker_num].len_ready = true; /* not ready, yet */
+				jwmarker[jwmarker_num].pos_ready = true; /* ready */
+				jwmarker[jwmarker_num].parms_ready = true; /* not ready */
+				jwmarker[jwmarker_num].data_ready = false; /* not ready */
+				jwmarker_num++;
+			}
+
+			opj_event_msg(j2k->cinfo, EVT_INFO,
+				"MH  ESDs: method %d\n",
+				j2k->cp->sens_MH
+				);
+
+		} else {
+			/* ooops, problems */
+			opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create MH ESD\n");				
+		};
+
+	}
+
+	/* 
+	 ESD MSs for Tile Part Headers 
+	*/
+	/* cycle through tiles */
+	sens = -1; /* default spec: no ESD */
+	tilespec = 0; /* first tile spec */
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
+
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
+
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) {
+	
+			int sot_len, Psot, Psotp, mm;
+			unsigned long sot_pos, post_sod_pos;
+
+			unsigned long int left_THmarks_len;
+
+			/******* sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/******* post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - sot_pos;
+
+			/* add all the lengths of the markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
+				}
+			}
+
+			/******* if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->sens_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile onwards */
+				sens = j2k->cp->sens_TPH[tilespec++];
+		
+			/* must this TPH have an ESD MS? */
+			if (j2k->cp->esd_on && (sens >= 0)) {
+
+				/* Create the ESD */
+				if (esd_mark = jpwl_esd_create(
+					j2k, /* this encoder handle */
+					-1, /* we are averaging over all components */
+					(unsigned char) j2k->cp->sens_range, /* range method */
+					(unsigned char) j2k->cp->sens_addr, /* sensitivity addressing size */
+					(unsigned char) sens, /* sensitivity method */
+					j2k->cp->sens_size, /* sensitivity value size */
+					tileno, /* this ESD is in a tile */
+					0, /* number of packets in codestream */
+					NULL /* pointer to sensitivity data of packets */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_ESD; /* its type */
+						jwmarker[jwmarker_num].esdmark = esd_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos + 0.2; /* not first at all! */
+						jwmarker[jwmarker_num].len = esd_mark->Lesd; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready, yet */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* not ready */
+						jwmarker[jwmarker_num].data_ready = false; /* ready */
+						jwmarker_num++;
+					}
+
+					/* update Psot of the tile  */
+					cio_seek(cio, Psotp);
+					cio_write(cio, Psot + esd_mark->Lesd + 2, 4);
+
+					opj_event_msg(j2k->cinfo, EVT_INFO,
+						/******* "TPH ESDs: tile %02d, method %d\n", */
+						"TPH ESDs: tile %02d, part %02d, method %d\n",
+						/******* tileno, */
+						tileno, tpno,
+						sens
+						);
+
+				} else {
+					/* ooops, problems */
+					/***** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d\n", tileno); */
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH ESD #%d,%d\n", tileno, tpno);
+				};
+
+			}
+			
+		}
+	
+	};
+
+	/* 
+	 EPB MS for Main Header
+	*/
+	/* first of all, must MH have an EPB MS? */
+	if (j2k->cp->epb_on && (j2k->cp->hprot_MH > 0)) {
+
+		int mm;
+
+		/* position of SOT */
+		unsigned int sot_pos = j2k->cstr_info->main_head_end + 1;
+
+		/* how much space is there between end of SIZ and beginning of SOT? */
+		int left_MHmarks_len = sot_pos - socsiz_len;
+
+		/* add all the lengths of the markers which are len-ready and stay within SOC and SOT */
+		for (mm = 0; mm < jwmarker_num; mm++) {
+			if ((jwmarker[mm].pos >=0) && (jwmarker[mm].pos < sot_pos)) {
+				if (jwmarker[mm].len_ready)
+					left_MHmarks_len += jwmarker[mm].len + 2;
+				else {
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up MH EPB\n",
+						jwmarker[mm].id, jwmarker[mm].dpos);				
+					exit(1);
+				}
+			}
+		}
+
+		/* Create the EPB */
+		if (epb_mark = jpwl_epb_create(
+			j2k, /* this encoder handle */
+			true, /* is it the latest? */
+			true, /* is it packed? not for now */
+			-1, /* we are in main header */
+			0, /* its index is 0 (first) */
+			j2k->cp->hprot_MH, /* protection type parameters of data */
+			socsiz_len, /* pre-data: only SOC+SIZ */
+			left_MHmarks_len /* post-data: from SOC to SOT, and all JPWL markers within */
+			)) {
+			
+			/* Add this marker to the 'insertanda' list */
+			if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+				jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
+				jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
+				jwmarker[jwmarker_num].pos = soc_pos + socsiz_len; /* after SIZ */
+				jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
+				jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
+				jwmarker[jwmarker_num].len_ready = true; /* ready */
+				jwmarker[jwmarker_num].pos_ready = true; /* ready */
+				jwmarker[jwmarker_num].parms_ready = true; /* ready */
+				jwmarker[jwmarker_num].data_ready = false; /* not ready */
+				jwmarker_num++;
+			}
+
+			opj_event_msg(j2k->cinfo, EVT_INFO,
+				"MH  EPB : prot. %d\n",
+				j2k->cp->hprot_MH
+				);
+
+		} else {
+			/* ooops, problems */
+			opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create MH EPB\n");				
+		};
+	}
+
+	/* 
+	 EPB MSs for Tile Parts
+	*/
+	/* cycle through TPHs */
+	hprot = j2k->cp->hprot_MH; /* default spec */
+	tilespec = 0; /* first tile spec */
+	lastileno = 0;
+	packspec = 0;
+	pprot = -1;
+	acc_tpno = 0;
+	for (tileno = 0; tileno < j2k->cstr_info->tw * j2k->cstr_info->th; tileno++) {
+
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"Tile %d has %d tile part(s)\n",
+			tileno, j2k->cstr_info->tile[tileno].num_tps
+			);
+
+		/* for every tile part in the tile */
+		for (tpno = 0; tpno < j2k->cstr_info->tile[tileno].num_tps; tpno++, acc_tpno++) { 
+		
+			int sot_len, Psot, Psotp, mm, epb_index = 0, prot_len = 0;
+			unsigned long sot_pos, post_sod_pos;
+			unsigned long int left_THmarks_len, epbs_len = 0;
+			int startpack = 0, stoppack = j2k->cstr_info->packno;
+			int first_tp_pack, last_tp_pack;
+			jpwl_epb_ms_t *tph_epb = NULL;
+
+			/****** sot_pos = j2k->cstr_info->tile[tileno].start_pos; */
+			sot_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos;
+			cio_seek(cio, sot_pos + 2); 
+			sot_len = cio_read(cio, 2); /* SOT Len */
+			cio_skip(cio, 2);
+			Psotp = cio_tell(cio);
+			Psot = cio_read(cio, 4); /* tile length */
+
+			/* a-priori length of the data dwelling between SOT and SOD */
+			/****** post_sod_pos = j2k->cstr_info->tile[tileno].end_header + 1; */
+			post_sod_pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_end_header + 1;
+			left_THmarks_len = post_sod_pos - (sot_pos + sot_len + 2);
+
+			/* add all the lengths of the JPWL markers which are len-ready and stay within SOT and SOD */
+			for (mm = 0; mm < jwmarker_num; mm++) {
+				if ((jwmarker[mm].pos >= sot_pos) && (jwmarker[mm].pos < post_sod_pos)) {
+					if (jwmarker[mm].len_ready)
+						left_THmarks_len += jwmarker[mm].len + 2;
+					else {
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "MS %x in %f is not len-ready: could not set up TH EPB\n",
+							jwmarker[mm].id, jwmarker[mm].dpos);				
+						exit(1);
+					}
+				}
+			}
+
+			/****** if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == tileno)) */
+			if ((tilespec < JPWL_MAX_NO_TILESPECS) && (j2k->cp->hprot_TPH_tileno[tilespec] == acc_tpno))
+				/* we got a specification from this tile part onwards */
+				hprot = j2k->cp->hprot_TPH[tilespec++];
+		
+			/* must this TPH have an EPB MS? */
+			if (j2k->cp->epb_on && (hprot > 0)) {
+
+				/* Create the EPB */
+				if (epb_mark = jpwl_epb_create(
+					j2k, /* this encoder handle */
+					false, /* is it the latest? in TPH, no for now (if huge data size in TPH, we'd need more) */
+					true, /* is it packed? yes for now */
+					tileno, /* we are in TPH */
+					epb_index++, /* its index is 0 (first) */
+					hprot, /* protection type parameters of following data */
+					sot_len + 2, /* pre-data length: only SOT */
+					left_THmarks_len /* post-data length: from SOT end to SOD inclusive */
+					)) {
+					
+					/* Add this marker to the 'insertanda' list */
+					if (jwmarker_num < JPWL_MAX_NO_MARKERS) {
+						jwmarker[jwmarker_num].id = J2K_MS_EPB; /* its type */
+						jwmarker[jwmarker_num].epbmark = epb_mark; /* the EPB */
+						/****** jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].start_pos + sot_len + 2; */ /* after SOT */
+						jwmarker[jwmarker_num].pos = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2; /* after SOT */
+						jwmarker[jwmarker_num].dpos = (double) jwmarker[jwmarker_num].pos; /* first first first! */
+						jwmarker[jwmarker_num].len = epb_mark->Lepb; /* its length */
+						jwmarker[jwmarker_num].len_ready = true; /* ready */
+						jwmarker[jwmarker_num].pos_ready = true; /* ready */
+						jwmarker[jwmarker_num].parms_ready = true; /* ready */
+						jwmarker[jwmarker_num].data_ready = false; /* not ready */
+						jwmarker_num++;
+					}
+
+					/* update Psot of the tile  */
+					Psot += epb_mark->Lepb + 2;
+
+					opj_event_msg(j2k->cinfo, EVT_INFO,
+						/***** "TPH EPB : tile %02d, prot. %d\n", */
+						"TPH EPB : tile %02d, part %02d, prot. %d\n",
+						/***** tileno, */
+						tileno, tpno,
+						hprot
+						);
+
+					/* save this TPH EPB address */
+					tph_epb = epb_mark;
+
+				} else {
+					/* ooops, problems */
+					/****** opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB #%d\n", tileno);	*/
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB in #%d,d\n", tileno, tpno);
+				};
+
+			}				
+		
+			startpack = 0;
+			/* EPB MSs for UEP packet data protection in Tile Parts */
+			/****** for (packno = 0; packno < j2k->cstr_info->num; packno++) { */
+			/*first_tp_pack = (tpno > 0) ? (first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno - 1].tp_numpacks) : 0;*/
+			first_tp_pack = j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pack;
+			last_tp_pack = first_tp_pack + j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks - 1;
+			for (packno = 0; packno < j2k->cstr_info->tile[tileno].tp[tpno].tp_numpacks; packno++) {
+
+				/******** if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == tileno) && (j2k->cp->pprot_packno[packspec] == packno)) { */
+				if ((packspec < JPWL_MAX_NO_PACKSPECS) &&
+					(j2k->cp->pprot_tileno[packspec] == acc_tpno) && (j2k->cp->pprot_packno[packspec] == packno)) {
+
+					/* we got a specification from this tile and packet onwards */
+					/* print the previous spec */
+					if (packno > 0) {
+						stoppack = packno - 1;				
+						opj_event_msg(j2k->cinfo, EVT_INFO,
+							/***** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+							"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+							/***** tileno, */
+							tileno, tpno,
+							startpack,
+							stoppack,
+							/***** j2k->cstr_info->tile[tileno].packet[startpack].start_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+							/***** j2k->cstr_info->tile[tileno].packet[stoppack].end_pos, */
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+							pprot);
+
+						/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+						prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+							j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+						/*
+						  particular case: if this is the last header and the last packet,
+						  then it is better to protect even the EOC marker
+						*/
+						/****** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(stoppack == (j2k->cstr_info->num - 1))) */
+						if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+							(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+							(stoppack == last_tp_pack))
+							/* add the EOC len */
+							prot_len += 2;
+
+						/* let's add the EPBs */
+						Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							false, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/****** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001, */ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+					}
+
+					startpack = packno;
+					pprot = j2k->cp->pprot[packspec++];
+				}
+
+				//printf("Tile %02d, pack %02d ==> %d\n", tileno, packno, pprot);
+		
+			}
+
+			/* we are at the end: print the remaining spec */
+			stoppack = packno - 1;
+			if (pprot >= 0) {
+
+				opj_event_msg(j2k->cinfo, EVT_INFO,
+					/**** "UEP EPBs: tile %02d, packs. %02d-%02d (B %d-%d), prot. %d\n", */
+					"UEP EPBs: tile %02d, part %02d, packs. %02d-%02d (B %d-%d), prot. %d\n",
+					/**** tileno, */
+					tileno, tpno,
+					startpack,
+					stoppack,
+					/***** j2k->image_info->tile[tileno].packet[startpack].start_pos,
+					j2k->image_info->tile[tileno].packet[stoppack].end_pos, */
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos,
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos,
+					pprot);
+
+				/***** prot_len = j2k->cstr_info->tile[tileno].packet[stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[startpack].start_pos; */
+				prot_len = j2k->cstr_info->tile[tileno].packet[first_tp_pack + stoppack].end_pos + 1 -
+					j2k->cstr_info->tile[tileno].packet[first_tp_pack + startpack].start_pos;
+
+				/*
+				  particular case: if this is the last header and the last packet,
+				  then it is better to protect even the EOC marker
+				*/
+				/***** if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(stoppack == (j2k->cstr_info->num - 1))) */
+				if ((tileno == ((j2k->cstr_info->tw * j2k->cstr_info->th) - 1)) &&
+					(tpno == (j2k->cstr_info->tile[tileno].num_tps - 1)) &&
+					(stoppack == last_tp_pack))
+					/* add the EOC len */
+					prot_len += 2;
+
+				/* let's add the EPBs */
+				Psot += jpwl_epbs_add(
+							j2k, /* J2K handle */
+							jwmarker, /* pointer to JPWL markers list */
+							&jwmarker_num, /* pointer to the number of current markers */
+							true, /* latest */
+							true, /* packed */
+							false, /* inside MH */
+							&epb_index, /* pointer to EPB index */
+							pprot, /* protection type */
+							/***** (double) (j2k->cstr_info->tile[tileno].start_pos + sot_len + 2) + 0.0001,*/ /* position */
+							(double) (j2k->cstr_info->tile[tileno].tp[tpno].tp_start_pos + sot_len + 2) + 0.0001, /* position */
+							tileno, /* number of tile */
+							0, /* length of pre-data */
+							prot_len /*4000*/ /* length of post-data */
+							);
+			}
+
+			/* we can now check if the TPH EPB was really the last one */
+			if (tph_epb && (epb_index == 1)) {
+				/* set the TPH EPB to be the last one in current header */
+				tph_epb->Depb |= (unsigned char) ((true & 0x0001) << 6);
+				tph_epb = NULL;
+			}
+
+			/* write back Psot */
+			cio_seek(cio, Psotp);
+			cio_write(cio, Psot, 4);
+		
+		}
+
+	};
+
+	/* reset the position */
+	cio_seek(cio, ciopos);
+
+}
+
+void jpwl_dump_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image) {
+
+	int mm;
+	unsigned long int old_size = j2k->cstr_info->codestream_size;
+	unsigned long int new_size = old_size;
+	int ciopos = cio_tell(cio), soc_pos = j2k->cstr_info->main_head_start;
+	unsigned char *jpwl_buf, *orig_buf;
+	unsigned long int orig_pos;
+	double epbcoding_time = 0.0, esdcoding_time = 0.0;
+
+	/* Order JPWL markers according to their wishlist position */
+	qsort((void *) jwmarker, (size_t) jwmarker_num, sizeof (jpwl_marker_t), jpwl_markcomp);
+
+	/* compute markers total size */ 
+	for (mm = 0; mm < jwmarker_num; mm++) {
+		/*printf("%x, %d, %.10f, %d long\n", jwmarker[mm].id, jwmarker[mm].pos,
+			jwmarker[mm].dpos, jwmarker[mm].len);*/
+		new_size += jwmarker[mm].len + 2;
+	}
+
+	/* allocate a new buffer of proper size */
+	if (!(jpwl_buf = (unsigned char *) opj_malloc((size_t) (new_size + soc_pos) * sizeof(unsigned char)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for JPWL codestream buffer\n");
+		exit(1);
+	};
+
+	/* copy the jp2 part, if any */
+	orig_buf = jpwl_buf;
+	memcpy(jpwl_buf, cio->buffer, soc_pos);
+	jpwl_buf += soc_pos;
+
+	/* cycle through markers */
+	orig_pos = soc_pos + 0; /* start from the beginning */
+	cio_seek(cio, soc_pos + 0); /* rewind the original */
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		/*
+		need to copy a piece of the original codestream
+		if there is such
+		*/
+		memcpy(jpwl_buf, cio_getbp(cio), jwmarker[mm].pos - orig_pos);
+		jpwl_buf += jwmarker[mm].pos - orig_pos;
+		orig_pos = jwmarker[mm].pos;
+		cio_seek(cio, orig_pos);
+
+		/*
+		then write down the marker
+		*/
+		switch (jwmarker[mm].id) {
+
+		case J2K_MS_EPB:
+			jpwl_epb_write(j2k, jwmarker[mm].epbmark, jpwl_buf);
+			break;
+
+		case J2K_MS_EPC:
+			jpwl_epc_write(j2k, jwmarker[mm].epcmark, jpwl_buf);
+			break;
+
+		case J2K_MS_ESD:
+			jpwl_esd_write(j2k, jwmarker[mm].esdmark, jpwl_buf);
+			break;
+
+		case J2K_MS_RED:
+			memset(jpwl_buf, 0, jwmarker[mm].len + 2); /* placeholder */
+			break;
+
+		default:
+			break;
+		};
+
+		/* we update the markers struct */
+		if (j2k->cstr_info)
+			j2k->cstr_info->marker[j2k->cstr_info->marknum - 1].pos = (jpwl_buf - orig_buf);
+		
+		/* we set the marker dpos to the new position in the JPWL codestream */
+		jwmarker[mm].dpos = (double) (jpwl_buf - orig_buf);
+
+		/* advance JPWL buffer position */
+		jpwl_buf += jwmarker[mm].len + 2;
+
+	}
+
+	/* finish remaining original codestream */
+	memcpy(jpwl_buf, cio_getbp(cio), old_size - (orig_pos - soc_pos));
+	jpwl_buf += old_size - (orig_pos - soc_pos);
+	cio_seek(cio, soc_pos + old_size);
+	
+	/*
+	update info file based on added markers
+	*/
+	if (!jpwl_update_info(j2k, jwmarker, jwmarker_num))
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not update OPJ cstr_info structure\n");
+
+	/* now we need to repass some markers and fill their data fields */
+	
+	/* first of all, DL and Pcrc in EPCs */ 
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		/* find the EPCs */
+		if (jwmarker[mm].id == J2K_MS_EPC) {
+
+			int epc_pos = (int) jwmarker[mm].dpos, pp;
+			unsigned short int mycrc = 0x0000;
+
+			/* fix and fill the DL field */
+			jwmarker[mm].epcmark->DL = new_size;
+			orig_buf[epc_pos + 6] = (unsigned char) (jwmarker[mm].epcmark->DL >> 24);
+			orig_buf[epc_pos + 7] = (unsigned char) (jwmarker[mm].epcmark->DL >> 16);
+			orig_buf[epc_pos + 8] = (unsigned char) (jwmarker[mm].epcmark->DL >> 8);
+			orig_buf[epc_pos + 9] = (unsigned char) (jwmarker[mm].epcmark->DL >> 0);
+
+			/* compute the CRC field (excluding itself) */
+			for (pp = 0; pp < 4; pp++)
+				jpwl_updateCRC16(&mycrc, orig_buf[epc_pos + pp]);
+			for (pp = 6; pp < (jwmarker[mm].len + 2); pp++)
+				jpwl_updateCRC16(&mycrc, orig_buf[epc_pos + pp]);
+
+			/* fix and fill the CRC */
+			jwmarker[mm].epcmark->Pcrc = mycrc;
+			orig_buf[epc_pos + 4] = (unsigned char) (jwmarker[mm].epcmark->Pcrc >> 8);
+			orig_buf[epc_pos + 5] = (unsigned char) (jwmarker[mm].epcmark->Pcrc >> 0);
+
+		}
+	}
+
+	/* then, sensitivity data in ESDs */ 
+	esdcoding_time = opj_clock();
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		/* find the ESDs */
+		if (jwmarker[mm].id == J2K_MS_ESD) {
+
+			/* remember that they are now in a new position (dpos) */
+			int esd_pos = (int) jwmarker[mm].dpos;
+
+			jpwl_esd_fill(j2k, jwmarker[mm].esdmark, &orig_buf[esd_pos]);
+		
+		}
+
+	}
+	esdcoding_time = opj_clock() - esdcoding_time;
+	if (j2k->cp->esd_on)
+		opj_event_msg(j2k->cinfo, EVT_INFO, "ESDs sensitivities computed in %f s\n", esdcoding_time);
+
+	/* finally, RS or CRC parity in EPBs */ 
+	epbcoding_time = opj_clock();
+	for (mm = 0; mm < jwmarker_num; mm++) {
+
+		/* find the EPBs */
+		if (jwmarker[mm].id == J2K_MS_EPB) {
+
+			/* remember that they are now in a new position (dpos) */
+			int nn, accum_len;
+
+			/* let's see how many EPBs are following this one, included itself */
+			/* for this to work, we suppose that the markers are correctly ordered */
+			/* and, overall, that they are in packed mode inside headers */
+			accum_len = 0;
+			for (nn = mm; (nn < jwmarker_num) && (jwmarker[nn].id == J2K_MS_EPB) &&
+				(jwmarker[nn].pos == jwmarker[mm].pos); nn++)
+				accum_len += jwmarker[nn].epbmark->Lepb + 2;
+
+			/* fill the current (first) EPB with post-data starting from the computed position */
+			jpwl_epb_fill(j2k, jwmarker[mm].epbmark, &orig_buf[(int) jwmarker[mm].dpos],
+				&orig_buf[(int) jwmarker[mm].dpos + accum_len]);
+		
+			/* fill the remaining EPBs in the header with post-data starting from the last position */
+			for (nn = mm + 1; (nn < jwmarker_num) && (jwmarker[nn].id == J2K_MS_EPB) &&
+				(jwmarker[nn].pos == jwmarker[mm].pos); nn++)
+				jpwl_epb_fill(j2k, jwmarker[nn].epbmark, &orig_buf[(int) jwmarker[nn].dpos], NULL);
+
+			/* skip all the processed EPBs */
+			mm = nn - 1;
+		}
+
+	}
+	epbcoding_time = opj_clock() - epbcoding_time;
+	if (j2k->cp->epb_on)
+		opj_event_msg(j2k->cinfo, EVT_INFO, "EPBs redundancy computed in %f s\n", epbcoding_time);
+
+	/* free original cio buffer and set it to the JPWL one */
+	opj_free(cio->buffer);
+	cio->cinfo = cio->cinfo; /* no change */
+	cio->openmode = cio->openmode; /* no change */
+	cio->buffer = orig_buf;
+	cio->length = new_size + soc_pos;
+	cio->start = cio->buffer;
+	cio->end = cio->buffer + cio->length;
+	cio->bp = cio->buffer;
+	cio_seek(cio, soc_pos + new_size);
+
+}
+
+
+void j2k_read_epc(opj_j2k_t *j2k) {
+	unsigned long int DL, Lepcp, Pcrcp, l;
+	unsigned short int Lepc, Pcrc = 0x0000;
+	unsigned char Pepc;	
+	opj_cio_t *cio = j2k->cio;
+	char *ans1;
+
+	/* Simply read the EPC parameters */
+	Lepcp = cio_tell(cio);
+	Lepc = cio_read(cio, 2);
+	Pcrcp = cio_tell(cio);
+	cio_skip(cio, 2); /* Pcrc */
+	DL = cio_read(cio, 4);
+	Pepc = cio_read(cio, 1);
+
+	/* compute Pcrc */
+	cio_seek(cio, Lepcp - 2);
+
+		/* Marker */
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* Length */
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* skip Pcrc */
+		cio_skip(cio, 2);
+
+		/* read all remaining */
+		for (l = 4; l < Lepc; l++)
+			jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* check Pcrc with the result */
+		cio_seek(cio, Pcrcp);
+		ans1 = (Pcrc == (unsigned short int) cio_read(cio, 2)) ? "crc-ok" : "crc-ko";
+
+	/* now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO, 
+		"EPC(%u,%d): %s, DL=%d%s %s %s\n",
+		Lepcp - 2,
+		Lepc,
+		ans1,
+		DL, /* data length this EPC is referring to */
+		(Pepc & 0x10) ? ", esd" : "", /* ESD is present */
+		(Pepc & 0x20) ? ", red" : "", /* RED is present */
+		(Pepc & 0x40) ? ", epb" : ""); /* EPB is present */
+
+	cio_seek(cio, Lepcp + Lepc);  
+}
+
+void j2k_write_epc(opj_j2k_t *j2k) {
+
+	unsigned long int DL, Lepcp, Pcrcp, l;
+	unsigned short int Lepc, Pcrc;
+	unsigned char Pepc;	
+
+	opj_cio_t *cio = j2k->cio;
+
+	cio_write(cio, J2K_MS_EPC, 2);	/* EPC */
+	Lepcp = cio_tell(cio);
+	cio_skip(cio, 2);
+
+	/* CRC-16 word of the EPC */
+	Pcrc = 0x0000; /* initialize */
+	Pcrcp = cio_tell(cio);
+	cio_write(cio, Pcrc, 2); /* Pcrc placeholder*/
+
+	/* data length of the EPC protection domain */
+	DL = 0x00000000; /* we leave this set to 0, as if the information is not available */
+	cio_write(cio, DL, 4);   /* DL */
+
+	/* jpwl capabilities */
+	Pepc = 0x00;
+	cio_write(cio, Pepc, 1); /* Pepc */
+
+	/* ID section */
+	/* no ID's, as of now */
+
+	Lepc = (unsigned short) (cio_tell(cio) - Lepcp);
+	cio_seek(cio, Lepcp);
+	cio_write(cio, Lepc, 2); /* Lepc */
+
+	/* compute Pcrc */
+	cio_seek(cio, Lepcp - 2);
+
+		/* Marker */
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* Length */
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+		jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* skip Pcrc */
+		cio_skip(cio, 2);
+
+		/* read all remaining */
+		for (l = 4; l < Lepc; l++)
+			jpwl_updateCRC16(&Pcrc, (unsigned char) cio_read(cio, 1)); 
+
+		/* fill Pcrc with the result */
+		cio_seek(cio, Pcrcp);
+		cio_write(cio, Pcrc, 2);
+
+	cio_seek(cio, Lepcp + Lepc);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, Lepcp - 2, Lepc + 2);
+
+}
+
+void j2k_read_epb(opj_j2k_t *j2k) {
+	unsigned long int LDPepb, Pepb;
+	unsigned short int Lepb;
+	unsigned char Depb;
+	char str1[25] = "";
+	bool status;
+	static bool first_in_tph = true;
+	int type, pre_len, post_len;
+	static unsigned char *redund = NULL;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* B/W = 45, RGB = 51 */
+	/*           SIZ   SIZ_FIELDS     SIZ_COMPS               FOLLOWING_MARKER */
+	int skipnum = 2  +     38     + 3 * j2k->cp->exp_comps  +         2;
+
+	if (j2k->cp->correct) {
+
+		/* go back to EPB marker value */
+		cio_seek(cio, cio_tell(cio) - 2);
+
+		/* we need to understand where we are */
+		if (j2k->state == J2K_STATE_MH) {
+			/* we are in MH */
+			type = 0; /* MH */
+			pre_len = skipnum; /* SOC+SIZ */
+			post_len = -1; /* auto */
+
+		} else if ((j2k->state == J2K_STATE_TPH) && first_in_tph) {
+			/* we are in TPH */
+			type = 1; /* TPH */
+			pre_len = 12; /* SOC+SIZ */
+			first_in_tph = false;
+			post_len = -1; /* auto */
+
+		} else {
+			/* we are elsewhere */
+			type = 2; /* other */
+			pre_len = 0; /* nada */
+			post_len = -1; /* auto */
+
+		}
+
+		/* call EPB corrector */
+		/*printf("before %x, ", redund);*/
+		status = jpwl_epb_correct(j2k,      /* J2K decompressor handle */
+								  cio->bp,  /* pointer to EPB in codestream buffer */
+								  type,     /* EPB type: MH */
+								  pre_len,  /* length of pre-data */
+								  post_len, /* length of post-data: -1 means auto */
+								  NULL,     /* do everything auto */
+								  &redund
+								 );
+		/*printf("after %x\n", redund);*/
+
+		/* Read the (possibly corrected) EPB parameters */
+		cio_skip(cio, 2);
+		Lepb = cio_read(cio, 2);
+		Depb = cio_read(cio, 1);
+		LDPepb = cio_read(cio, 4);
+		Pepb = cio_read(cio, 4);
+
+		if (!status) {
+
+			opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL correction could not be performed\n");
+
+			/* advance to EPB endpoint */
+			cio_skip(cio, Lepb + 2);  
+
+			return;
+		}
+
+		/* last in current header? */
+		if (Depb & 0x40) {
+			redund = NULL; /* reset the pointer to L4 buffer */
+			first_in_tph = true;
+		}
+
+		/* advance to EPB endpoint */
+		cio_skip(cio, Lepb - 11);  
+
+	} else {
+
+		/* Simply read the EPB parameters */
+		Lepb = cio_read(cio, 2);
+		Depb = cio_read(cio, 1);
+		LDPepb = cio_read(cio, 4);
+		Pepb = cio_read(cio, 4);
+
+		/* What does Pepb tells us about the protection method? */
+		if (((Pepb & 0xF0000000) >> 28) == 0)
+			sprintf(str1, "pred"); /* predefined */
+		else if (((Pepb & 0xF0000000) >> 28) == 1)
+			sprintf(str1, "crc-%d", 16 * ((Pepb & 0x00000001) + 1)); /* CRC mode */
+		else if (((Pepb & 0xF0000000) >> 28) == 2)
+			sprintf(str1, "rs(%d,32)", (Pepb & 0x0000FF00) >> 8); /* RS mode */
+		else if (Pepb == 0xFFFFFFFF)
+			sprintf(str1, "nometh"); /* RS mode */
+		else
+			sprintf(str1, "unknown"); /* unknown */
+
+		/* Now we write them to screen */
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"EPB(%d): (%sl, %sp, %u), %lu, %s\n",
+			cio_tell(cio) - 13,
+			(Depb & 0x40) ? "" : "n", /* latest EPB or not? */
+			(Depb & 0x80) ? "" : "n", /* packed or unpacked EPB? */
+			(Depb & 0x3F), /* EPB index value */
+			LDPepb, /*length of the data protected by the EPB */
+			str1); /* protection method */
+
+		cio_skip(cio, Lepb - 11);  
+	}
+}
+
+void j2k_write_epb(opj_j2k_t *j2k) {
+	unsigned long int LDPepb, Pepb, Lepbp;
+	unsigned short int Lepb;
+	unsigned char Depb;
+
+	opj_cio_t *cio = j2k->cio;
+
+	cio_write(cio, J2K_MS_EPB, 2);	/* EPB */
+	Lepbp = cio_tell(cio);
+	cio_skip(cio, 2);
+
+	/* EPB style */
+	Depb = 0x00; /* test */
+	cio_write(cio, Depb, 1);   /* Depb */
+
+	/* length of the data to be protected by this EPB */
+	LDPepb = 0x00000000; /* test */
+	cio_write(cio, LDPepb, 4);   /* LDPepb */
+
+	/* next error correction tool */
+	Pepb = 0x00000000; /* test */
+	cio_write(cio, Pepb, 4);   /* Pepb */
+
+	/* EPB data */
+	/* no data, as of now */
+
+	Lepb = (unsigned short) (cio_tell(cio) - Lepbp);
+	cio_seek(cio, Lepbp);
+	cio_write(cio, Lepb, 2);		/* Lepb */
+
+	cio_seek(cio, Lepbp + Lepb);
+
+	/* marker struct update */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, Lepbp - 2, Lepb + 2);
+}
+
+void j2k_read_esd(opj_j2k_t *j2k) {
+	unsigned short int Lesd, Cesd;
+	unsigned char Pesd;
+
+	int cesdsize = (j2k->image->numcomps >= 257) ? 2 : 1;
+
+	char str1[4][4] = {"p", "br", "pr", "res"};
+	char str2[8][8] = {"res", "mse", "mse-r", "psnr", "psnr-i", "maxerr", "tse", "res"};
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the ESD parameters */
+	Lesd = cio_read(cio, 2);
+	Cesd = cio_read(cio, cesdsize);
+	Pesd = cio_read(cio, 1);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"ESD(%d): c%d, %s, %s, %s, %s, %s\n",
+		cio_tell(cio) - (5 + cesdsize),
+		Cesd, /* component number for this ESD */
+		str1[(Pesd & (unsigned char) 0xC0) >> 6], /* addressing mode */
+		str2[(Pesd & (unsigned char) 0x38) >> 3], /* sensitivity type */
+		((Pesd & (unsigned char) 0x04) >> 2) ? "2Bs" : "1Bs",
+		((Pesd & (unsigned char) 0x02) >> 1) ? "4Ba" : "2Ba",
+		(Pesd & (unsigned char) 0x01) ? "avgc" : "");
+
+	cio_skip(cio, Lesd - (3 + cesdsize));  
+}
+
+void j2k_read_red(opj_j2k_t *j2k) {
+	unsigned short int Lred;
+	unsigned char Pred;
+	char str1[4][4] = {"p", "br", "pr", "res"};
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the RED parameters */
+	Lred = cio_read(cio, 2);
+	Pred = cio_read(cio, 1);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"RED(%d): %s, %dc, %s, %s\n",
+		cio_tell(cio) - 5,
+		str1[(Pred & (unsigned char) 0xC0) >> 6], /* addressing mode */
+		(Pred & (unsigned char) 0x38) >> 3, /* corruption level */
+		((Pred & (unsigned char) 0x02) >> 1) ? "4Ba" : "2Ba", /* address range */
+		(Pred & (unsigned char) 0x01) ? "errs" : "free"); /* error free? */
+
+	cio_skip(cio, Lred - 3);  
+}
+
+bool jpwl_check_tile(opj_j2k_t *j2k, opj_tcd_t *tcd, int tileno) {
+
+	/*
+	   we navigate through the tile and find possible invalid parameters:
+       this saves a lot of crashes!!!!!
+	 */
+	int compno, resno, precno, /*layno,*/ bandno, blockno;
+	int numprecincts, numblocks;
+
+	/* this is the selected tile */
+	opj_tcd_tile_t *tile = &(tcd->tcd_image->tiles[tileno]);
+
+	/* will keep the component */
+	opj_tcd_tilecomp_t *comp = NULL;
+
+	/* will keep the resolution */
+	opj_tcd_resolution_t *res;
+
+	/* will keep the subband */
+	opj_tcd_band_t *band; 
+
+	/* will keep the precinct */
+	opj_tcd_precinct_t *prec; 
+
+	/* will keep the codeblock */
+	opj_tcd_cblk_t *block;
+
+	/* check all tile components */
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		comp = &(tile->comps[compno]);
+
+		/* check all component resolutions */
+		for (resno = 0; resno < comp->numresolutions; resno++) {
+			res = &(comp->resolutions[resno]);
+			numprecincts = res->pw * res->ph;
+
+			/* check all the subbands */
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				band = &(res->bands[bandno]);
+
+				/* check all the precincts */
+				for (precno = 0; precno < numprecincts; precno++) {
+					prec = &(band->precincts[precno]);
+					numblocks = prec->ch * prec->cw;
+
+					/* check all the codeblocks */
+					for (blockno = 0; blockno < numblocks; blockno++) {
+						block = &(prec->cblks[blockno]);
+
+						/* x-origin is invalid */
+						if ((block->x0 < prec->x0) || (block->x0 > prec->x1)) {
+							opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+								"JPWL: wrong x-cord of block origin %d => x-prec is (%d, %d)\n",
+								block->x0, prec->x0, prec->x1);
+							if (!JPWL_ASSUME || JPWL_ASSUME)
+								return false;
+						};
+					}
+				}				
+			}
+		}
+	}
+
+	return true;
+}
+
+/*@}*/
+
+#endif /* USE_JPWL */
+
+
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+
+/** @name Local static functions */
+/*@{*/
+
+void j2k_read_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the SEC length */
+	Lsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"SEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Lsec - 2);  
+}
+
+void j2k_write_sec(opj_j2k_t *j2k) {
+	unsigned short int Lsec = 24;
+	int i;
+
+	opj_cio_t *cio = j2k->cio;
+
+	cio_write(cio, J2K_MS_SEC, 2);	/* SEC */
+	cio_write(cio, Lsec, 2);
+
+	/* write dummy data */
+	for (i = 0; i < Lsec - 2; i++)
+		cio_write(cio, 0, 1);
+}
+
+void j2k_read_insec(opj_j2k_t *j2k) {
+	unsigned short int Linsec;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* Simply read the INSEC length */
+	Linsec = cio_read(cio, 2);
+
+	/* Now we write them to screen */
+	opj_event_msg(j2k->cinfo, EVT_INFO,
+		"INSEC(%d)\n",
+		cio_tell(cio) - 2
+		);
+
+	cio_skip(cio, Linsec - 2);  
+}
+
+
+/*@}*/
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl.h.svn-base ./jpwl/.svn/text-base/jpwl.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/jpwl.h.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,425 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __JPWL_H
+#define __JPWL_H
+
+#ifdef USE_JPWL
+
+#include "crc.h"
+#include "rs.h"
+
+/**
+@file jpwl.h
+@brief The JPEG-2000 Part11 (JPWL) marker segments manager
+
+The functions in JPWL.C have for goal to read/write the markers added by JPWL.
+*/
+
+/** @defgroup JPWL JPWL - JPEG-2000 Part11 (JPWL) codestream manager */
+/*@{*/
+
+/**
+Assume a basic codestream structure, so you can resort better from uncorrected errors
+*/
+#define JPWL_ASSUME true
+
+/**
+EPB (Error Protection Block) Marker segment
+*/
+typedef struct jpwl_epb_ms {
+	/**@name Private fields set by epb_create */
+	/*@{*/
+	/** is the latest in header? */
+	bool latest;
+	/** is it in packed mode? */
+	bool packed;
+	/** TH where this marker has been placed (-1 means MH) */
+	int tileno;
+	/** index in current header (0-63) */
+	unsigned char index;
+	/** error protection method	[-1=absent 0=none 1=predefined 16=CRC-16 32=CRC-32 37-128=RS] */
+	int hprot;
+	/** message word length of pre-data */
+	int k_pre;
+	/** code word length of pre-data */
+	int n_pre;
+	/** length of pre-data */
+	int pre_len;
+	/** message word length of post-data */
+	int k_post;
+	/** code word length of post-data */
+	int n_post;
+	/** length of post-data */
+	int post_len;
+	/*@}*/
+	/**@name Marker segment fields */
+	/*@{*/
+	/** two bytes for the length of EPB MS, exluding the marker itself (11 to 65535 bytes) */
+	unsigned short int Lepb;
+	/** single byte for the style */
+	unsigned char Depb; 
+	/** four bytes, from 0 to 2^31-1 */
+	unsigned long int LDPepb;
+	/** four bytes, next error management method */
+	unsigned long int Pepb;
+	/** EPB data, variable size */
+	unsigned char *data;   
+	/*@}*/
+}	jpwl_epb_ms_t;
+
+/**
+EPC (Error Protection Capability) Marker segment
+*/
+typedef struct jpwl_epc_ms {
+	/** is ESD active? */
+	bool esd_on;
+	/** is RED active? */
+	bool red_on;
+	/** is EPB active? */
+	bool epb_on;
+	/** are informative techniques active? */
+	bool info_on;
+	/**@name Marker segment fields */
+	/*@{*/
+	/** two bytes for the length of EPC MS, exluding the marker itself (9 to 65535 bytes) */
+	unsigned short int Lepc;   
+	/** two bytes, CRC for the EPC, excluding Pcrc itself */
+	unsigned short int Pcrc;   
+	/** four bytes, the codestream length from SOC to EOC */
+	unsigned long int DL;     
+	/** one byte, signals JPWL techniques adoption */
+	unsigned char Pepc;	
+	/** EPC data, variable length */
+	unsigned char *data;	
+	/*@}*/
+}	jpwl_epc_ms_t;
+
+/**
+ESD (Error Sensitivity Descriptor) Marker segment
+*/
+typedef struct jpwl_esd_ms {
+	/** codestream addressing mode [0=packet, 1=byte range, 2=packet range, 3=reserved] */
+	unsigned char addrm;
+	/** size of codestream addresses [2/4 bytes] */
+	unsigned char ad_size;
+	/** type of sensitivity
+	[0=relative error, 1=MSE, 2=MSE reduction, 3=PSNR, 4=PSNR increment,
+	5=MAXERR (absolute peak error), 6=TSE (total squared error), 7=reserved */
+	unsigned char senst;
+	/** size of sensitivity data (1/2 bytes) */
+	unsigned char se_size;
+	/**@name Marker segment fields */
+	/*@{*/
+	/** two bytes for the length of ESD MS, exluding the marker itself (4 to 65535 bytes) */
+	unsigned short int Lesd;   
+	/** two bytes, component of error sensitivity */
+	unsigned short int Cesd;
+	/** one byte, signals JPWL techniques adoption */
+	unsigned char Pesd;	
+	/** ESD data, variable length */
+	unsigned char *data;	
+	/*@}*/
+	/**@name Fields set by esd_create (only internal use) */
+	/*@{*/
+	/** number of components in the image */
+	int numcomps;
+	/** tile where this marker has been placed (-1 means MH) */
+	int tileno;
+	/** number of sensitivity values */
+	unsigned long int svalnum;
+	/** size of a single sensitivity pair (address+value) */
+	size_t sensval_size;
+	/*@}*/
+}	jpwl_esd_ms_t;
+
+/**
+RED (Residual Error Descriptor) Marker segment
+*/
+typedef struct jpwl_red_ms {
+	/** two bytes for the length of RED MS, exluding the marker itself (3 to 65535 bytes) */
+	unsigned short int Lred;
+	/** one byte, signals JPWL techniques adoption */
+	unsigned char Pred;	
+	/** RED data, variable length */
+	unsigned char *data;	
+}	jpwl_red_ms_t;
+
+/**
+Structure used to store JPWL markers temporary position and readyness
+*/
+typedef struct jpwl_marker {
+	/** marker value (J2K_MS_EPC, etc.) */
+	int id;
+	/** union keeping the pointer to the real marker struct */
+	union {
+		/** pointer to EPB marker */
+		jpwl_epb_ms_t *epbmark;
+		/** pointer to EPC marker */
+		jpwl_epc_ms_t *epcmark;
+		/** pointer to ESD marker */
+		jpwl_esd_ms_t *esdmark;
+		/** pointer to RED marker */
+		jpwl_red_ms_t *redmark;
+	};
+	/** position where the marker should go, in the pre-JPWL codestream */ 
+	unsigned long int pos;
+	/** same as before, only written as a double, so we can sort it better */
+	double dpos;
+	/** length of the marker segment (marker excluded) */
+	unsigned short int len;
+	/** the marker length is ready or not? */
+	bool len_ready;
+	/** the marker position is ready or not? */
+	bool pos_ready;
+	/** the marker parameters are ready or not? */
+	bool parms_ready;
+	/** are the written data ready or not */
+	bool data_ready;
+}	jpwl_marker_t;
+
+/**
+Encode according to JPWL specs
+@param j2k J2K handle
+@param cio codestream handle
+@param image image handle
+*/
+void jpwl_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image);
+
+/**
+Prepare the list of JPWL markers, after the Part 1 codestream
+has been finalized (index struct is full)
+@param j2k J2K handle
+@param cio codestream handle
+@param image image handle
+*/
+void jpwl_prepare_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image);
+
+/**
+Dump the list of JPWL markers, after it has been prepared
+@param j2k J2K handle
+@param cio codestream handle
+@param image image handle
+*/
+void jpwl_dump_marks(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image);
+
+/**
+Read the EPC marker (Error Protection Capability)
+@param j2k J2K handle
+*/
+void j2k_read_epc(opj_j2k_t *j2k);
+
+/**
+Write the EPC marker (Error Protection Capability), BUT the DL field is always set to 0
+(this simplifies the management of EPBs and it is openly stated in the standard
+as a possible value, mening that the information is not available) and the informative techniques
+are not yet implemented
+@param j2k J2K handle
+*/
+void j2k_write_epc(opj_j2k_t *j2k);
+
+/**
+Read the EPB marker (Error Protection Block)
+@param j2k J2K handle
+*/
+void j2k_read_epb(opj_j2k_t *j2k);
+
+/**
+Write the EPB marker (Error Protection Block)
+@param j2k J2K handle
+*/
+void j2k_write_epb(opj_j2k_t *j2k);
+
+/**
+Read the ESD marker (Error Sensitivity Descriptor)
+@param j2k J2K handle
+*/
+void j2k_read_esd(opj_j2k_t *j2k);
+
+/**
+Read the RED marker (Residual Error Descriptor)
+@param j2k J2K handle
+*/
+void j2k_read_red(opj_j2k_t *j2k);
+
+/** create an EPB marker segment
+@param j2k J2K compressor handle
+@param latest it is the latest EPB in the header
+@param packed EPB is in packed style
+@param tileno tile number where the marker has been placed (-1 means MH)
+@param idx current EPB running index
+@param hprot applied protection type (-1/0,1,16,32,37-128)
+@param pre_len length of pre-protected data
+@param post_len length of post-protected data
+@return returns the freshly created EPB
+*/
+jpwl_epb_ms_t *jpwl_epb_create(opj_j2k_t *j2k, bool latest, bool packed, int tileno, int idx, int hprot,
+							   unsigned long int pre_len, unsigned long int post_len);
+
+/** add a number of EPB marker segments
+@param j2k J2K compressor handle
+@param jwmarker pointer to the JPWL markers list
+@param jwmarker_num pointer to the number of JPWL markers (gets updated)
+@param latest it is the latest group of EPBs in the header
+@param packed EPBs are in packed style
+@param insideMH it is in the MH
+@param idx pointer to the starting EPB running index (gets updated)
+@param hprot applied protection type (-1/0,1,16,32,37-128)
+@param place_pos place in original codestream where EPBs should go
+@param tileno tile number of these EPBs
+@param pre_len length of pre-protected data
+@param post_len length of post-protected data
+@return returns the length of all added markers
+*/
+int jpwl_epbs_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
+				  bool latest, bool packed, bool insideMH, int *idx, int hprot,
+				  double place_pos, int tileno,
+				  unsigned long int pre_len, unsigned long int post_len);
+
+/** add a number of ESD marker segments
+@param j2k J2K compressor handle
+@param jwmarker pointer to the JPWL markers list
+@param jwmarker_num pointer to the number of JPWL markers (gets updated)
+@param comps considered component (-1=average, 0/1/2/...=component no.)
+@param addrm addressing mode (0=packet, 1=byte range, 2=packet range, 3=reserved)
+@param ad_size size of addresses (2/4 bytes)
+@param senst sensitivity type
+@param se_size sensitivity values size (1/2 bytes)
+@param place_pos place in original codestream where EPBs should go
+@param tileno tile number of these EPBs
+@return returns the length of all added markers
+*/
+int jpwl_esds_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
+				  int comps, unsigned char addrm, unsigned char ad_size,
+				  unsigned char senst, unsigned char se_size,
+				  double place_pos, int tileno);
+	
+/** updates the information structure by modifying the positions and lengths
+@param j2k J2K compressor handle
+@param jwmarker pointer to JPWL markers list
+@param jwmarker_num number of JPWL markers
+@return returns true in case of success
+*/			  
+bool jpwl_update_info(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int jwmarker_num);
+
+
+bool jpwl_esd_fill(opj_j2k_t *j2k, jpwl_esd_ms_t *esdmark, unsigned char *buf);
+
+bool jpwl_epb_fill(opj_j2k_t *j2k, jpwl_epb_ms_t *epbmark, unsigned char *buf, unsigned char *post_buf);
+
+void j2k_add_marker(opj_codestream_info_t *cstr_info, unsigned short int type, int pos, int len);
+
+/** corrects the data in the JPWL codestream
+@param j2k J2K compressor handle
+@return true if correction is performed correctly
+*/
+bool jpwl_correct(opj_j2k_t *j2k);
+
+/** corrects the data protected by an EPB
+@param j2k J2K compressor handle
+@param buffer pointer to the EPB position
+@param type type of EPB: 0=MH, 1=TPH, 2=other, 3=auto
+@param pre_len length of pre-data
+@param post_len length of post_data
+@param conn is a pointer to the length of all connected (packed) EPBs
+@param L4_bufp is a pointer to the buffer pointer of redundancy data
+@return returns true if correction could be succesfully performed
+*/
+bool jpwl_epb_correct(opj_j2k_t *j2k, unsigned char *buffer, int type, int pre_len, int post_len, int *conn,
+					  unsigned char **L4_bufp);
+
+/** check that a tile and its children have valid data
+@param j2k J2K decompressor handle
+@param tcd Tile decompressor handle
+@param tileno number of the tile to check
+*/
+bool jpwl_check_tile(opj_j2k_t *j2k, opj_tcd_t *tcd, int tileno);
+
+/** Macro functions for CRC computation */
+
+/**
+Computes the CRC-16, as stated in JPWL specs
+@param CRC two bytes containing the CRC value (must be initialized with 0x0000)
+@param DATA byte for which the CRC is computed; call this on every byte of the sequence
+and get the CRC at the end
+*/
+#define jpwl_updateCRC16(CRC, DATA) updateCRC16(CRC, DATA)
+
+/**
+Computes the CRC-32, as stated in JPWL specs
+@param CRC four bytes containing the CRC value (must be initialized with 0x00000000)
+@param DATA byte for which the CRC is computed; call this on every byte of the sequence
+and get the CRC at the end
+*/
+#define jpwl_updateCRC32(CRC, DATA) updateCRC32(CRC, DATA)
+
+/**
+Computes the minimum between two integers
+@param a first integer to compare
+@param b second integer to compare
+@return returns the minimum integer between a and b
+*/
+#ifndef min
+#define min(a,b)    (((a) < (b)) ? (a) : (b))
+#endif /* min */
+
+/*@}*/
+
+#endif /* USE_JPWL */
+
+#ifdef USE_JPSEC
+
+/** @defgroup JPSEC JPSEC - JPEG-2000 Part 8 (JPSEC) codestream manager */
+/*@{*/
+
+/**
+Read the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_sec(opj_j2k_t *j2k);
+
+/**
+Write the SEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_write_sec(opj_j2k_t *j2k);
+
+/**
+Read the INSEC marker (SEcured Codestream)
+@param j2k J2K handle
+*/
+void j2k_read_insec(opj_j2k_t *j2k);
+
+/*@}*/
+
+#endif /* USE_JPSEC */
+
+#endif /* __JPWL_H */
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_image_to_j2k.dsp.svn-base ./jpwl/.svn/text-base/JPWL_image_to_j2k.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_image_to_j2k.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/JPWL_image_to_j2k.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,119 @@
+# Microsoft Developer Studio Project File - Name="JPWL_image_to_j2k" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=JPWL_image_to_j2k - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "JPWL_image_to_j2k.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "JPWL_image_to_j2k.mak" CFG="JPWL_image_to_j2k - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "JPWL_image_to_j2k - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "JPWL_image_to_j2k - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "JPWL_image_to_j2k - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x80c /d "NDEBUG"
+# ADD RSC /l 0x80c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWL.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386 /libpath:"Release"
+
+!ELSEIF  "$(CFG)" == "JPWL_image_to_j2k - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /FR /FD /GZ /c
+# ADD BASE RSC /l 0x80c /d "_DEBUG"
+# ADD RSC /l 0x80c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib LibOpenJPEG_JPWLd.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"Debug"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "JPWL_image_to_j2k - Win32 Release"
+# Name "JPWL_image_to_j2k - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\codec\convert.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\image_to_j2k.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\codec\convert.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_image_to_j2k.dsw.svn-base ./jpwl/.svn/text-base/JPWL_image_to_j2k.dsw.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_image_to_j2k.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/JPWL_image_to_j2k.dsw.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "JPWL_image_to_j2k"=".\JPWL_image_to_j2k.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG_JPWL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "LibOpenJPEG_JPWL"=".\LibOpenJPEG_JPWL.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_j2k_to_image.dsp.svn-base ./jpwl/.svn/text-base/JPWL_j2k_to_image.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_j2k_to_image.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/JPWL_j2k_to_image.dsp.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,126 @@
+# Microsoft Developer Studio Project File - Name="JPWL_j2k_to_image" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=JPWL_j2k_to_image - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "JPWL_j2k_to_image.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "JPWL_j2k_to_image.mak" CFG="JPWL_j2k_to_image - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "JPWL_j2k_to_image - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "JPWL_j2k_to_image - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "JPWL_j2k_to_image - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
+# ADD BASE RSC /l 0x80c /d "NDEBUG"
+# ADD RSC /l 0x80c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "JPWL_j2k_to_image - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "JPWL_j2k_to_image___Win32_Debug"
+# PROP BASE Intermediate_Dir "JPWL_j2k_to_image___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x80c /d "_DEBUG"
+# ADD RSC /l 0x80c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "JPWL_j2k_to_image - Win32 Release"
+# Name "JPWL_j2k_to_image - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\codec\convert.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\j2k_to_image.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\codec\convert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\crc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\codec\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\jpwl.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\rs.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_j2k_to_image.dsw.svn-base ./jpwl/.svn/text-base/JPWL_j2k_to_image.dsw.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/JPWL_j2k_to_image.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/JPWL_j2k_to_image.dsw.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "JPWL_j2k_to_image"=".\JPWL_j2k_to_image.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG_JPWL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "LibOpenJPEG_JPWL"=".\LibOpenJPEG_JPWL.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl_lib.c.svn-base ./jpwl/.svn/text-base/jpwl_lib.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/jpwl_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/jpwl_lib.c.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,1785 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef USE_JPWL
+
+#include "../libopenjpeg/opj_includes.h"
+#include <limits.h>
+
+/** Minimum and maximum values for the double->pfp conversion */
+#define MIN_V1 0.0
+#define MAX_V1 17293822569102704640.0
+#define MIN_V2 0.000030517578125
+#define MAX_V2 131040.0
+
+/** conversion between a double precision floating point
+number and the corresponding pseudo-floating point used 
+to represent sensitivity values
+@param V the double precision value
+@param bytes the number of bytes of the representation
+@return the pseudo-floating point value (cast accordingly)
+*/
+unsigned short int jpwl_double_to_pfp(double V, int bytes);
+
+/** conversion between a pseudo-floating point used 
+to represent sensitivity values and the corresponding
+double precision floating point number  
+@param em the pseudo-floating point value (cast accordingly)
+@param bytes the number of bytes of the representation
+@return the double precision value
+*/
+double jpwl_pfp_to_double(unsigned short int em, int bytes);
+
+	/*-------------------------------------------------------------*/
+
+int jpwl_markcomp(const void *arg1, const void *arg2)
+{
+   /* Compare the two markers' positions */
+   double diff = (((jpwl_marker_t *) arg1)->dpos - ((jpwl_marker_t *) arg2)->dpos);
+
+   if (diff == 0.0)
+	   return (0);
+   else if (diff < 0)
+	   return (-1);
+   else
+	   return (+1);
+}
+
+int jpwl_epbs_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
+				  bool latest, bool packed, bool insideMH, int *idx, int hprot,
+				  double place_pos, int tileno,
+				  unsigned long int pre_len, unsigned long int post_len) {
+
+	jpwl_epb_ms_t *epb_mark = NULL;
+
+	int k_pre, k_post, n_pre, n_post;
+	
+	unsigned long int L1, L2, dL4, max_postlen, epbs_len = 0;
+
+	/* We find RS(n,k) for EPB parms and pre-data, if any */
+	if (insideMH && (*idx == 0)) {
+		/* First EPB in MH */ 
+		k_pre = 64;
+		n_pre = 160;
+	} else if (!insideMH && (*idx == 0)) {
+		/* First EPB in TH */
+		k_pre = 25;
+		n_pre = 80;
+	} else {
+		/* Following EPBs in MH or TH */
+		k_pre = 13;
+		n_pre = 40;
+	};
+
+	/* Find lengths, Figs. B3 and B4 */
+	/* size of pre data: pre_buf(pre_len) + EPB(2) + Lepb(2) + Depb(1) + LDPepb(4) + Pepb(4) */
+	L1 = pre_len + 13;
+
+	/* size of pre-data redundancy */
+	/*   (redundancy per codeword)       *     (number of codewords, rounded up)   */
+	L2 = (n_pre - k_pre) * (unsigned long int) ceil((double) L1 / (double) k_pre);
+
+	/* Find protection type for post data and its associated redundancy field length*/
+	if ((hprot == 16) || (hprot == 32)) {
+		/* there is a CRC for post-data */
+		k_post = post_len;
+		n_post = post_len + (hprot >> 3);
+		/*L3 = hprot >> 3;*/ /* 2 (CRC-16) or 4 (CRC-32) bytes */
+
+	} else if ((hprot >= 37) && (hprot <= 128)) {
+		/* there is a RS for post-data */
+		k_post = 32;
+		n_post = hprot;
+
+	} else {
+		/* Use predefined codes */
+		n_post = n_pre;
+		k_post = k_pre;
+	};
+
+	/* Create the EPB(s) */
+	while (post_len > 0) {
+
+		/* maximum postlen in order to respect EPB size
+		(we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms)*/
+		/*      (message word size)    *            (number of containable parity words)  */
+		max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
+
+		/* maximum postlen in order to respect EPB size */
+		if (*idx == 0)
+			/* (we use (JPWL_MAXIMUM_EPB_ROOM - L2) instead of 65535 for keeping room for EPB parms + pre-data) */
+			/*      (message word size)    *                   (number of containable parity words)  */
+			max_postlen = k_post * (unsigned long int) floor((double) (JPWL_MAXIMUM_EPB_ROOM - L2) / (double) (n_post - k_post));
+
+		else
+			/* (we use JPWL_MAXIMUM_EPB_ROOM instead of 65535 for keeping room for EPB parms) */
+			/*      (message word size)    *            (number of containable parity words)  */
+			max_postlen = k_post * (unsigned long int) floor((double) JPWL_MAXIMUM_EPB_ROOM / (double) (n_post - k_post));
+
+		/* null protection case */
+		/* the max post length can be as large as the LDPepb field can host */
+		if (hprot == 0)
+			max_postlen = INT_MAX;
+		
+		/* length to use */
+		dL4 = min(max_postlen, post_len);
+
+		if (epb_mark = jpwl_epb_create(
+			j2k, /* this encoder handle */
+			latest ? (dL4 < max_postlen) : false, /* is it the latest? */
+			packed, /* is it packed? */
+			tileno, /* we are in TPH */
+			*idx, /* its index */
+			hprot, /* protection type parameters of following data */
+			0, /* pre-data: nothing for now */
+			dL4 /* post-data: the stub computed previously */
+			)) {
+			
+			/* Add this marker to the 'insertanda' list */
+			if (*jwmarker_num < JPWL_MAX_NO_MARKERS) {
+				jwmarker[*jwmarker_num].id = J2K_MS_EPB; /* its type */
+				jwmarker[*jwmarker_num].epbmark = epb_mark; /* the EPB */
+				jwmarker[*jwmarker_num].pos = (int) place_pos; /* after SOT */
+				jwmarker[*jwmarker_num].dpos = place_pos + 0.0000001 * (double)(*idx); /* not very first! */
+				jwmarker[*jwmarker_num].len = epb_mark->Lepb; /* its length */
+				jwmarker[*jwmarker_num].len_ready = true; /* ready */
+				jwmarker[*jwmarker_num].pos_ready = true; /* ready */
+				jwmarker[*jwmarker_num].parms_ready = true; /* ready */
+				jwmarker[*jwmarker_num].data_ready = false; /* not ready */
+				(*jwmarker_num)++;
+			}
+
+			/* increment epb index */
+			(*idx)++;
+
+			/* decrease postlen */
+			post_len -= dL4;
+
+			/* increase the total length of EPBs */
+			epbs_len += epb_mark->Lepb + 2;
+
+		} else {
+			/* ooops, problems */
+			opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not create TPH EPB for UEP in tile %d\n", tileno);				
+		};
+	}
+
+	return epbs_len;
+}
+
+
+jpwl_epb_ms_t *jpwl_epb_create(opj_j2k_t *j2k, bool latest, bool packed, int tileno, int idx, int hprot,
+						  unsigned long int pre_len, unsigned long int post_len) {
+
+	jpwl_epb_ms_t *epb = NULL;
+	unsigned short int data_len = 0;
+	unsigned short int L2, L3;
+	unsigned long int L1, L4;
+	unsigned char *predata_in = NULL;
+
+	bool insideMH = (tileno == -1);
+
+	/* Alloc space */
+	if (!(epb = (jpwl_epb_ms_t *) opj_malloc((size_t) 1 * sizeof (jpwl_epb_ms_t)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for one EPB MS\n");
+		return NULL;
+	};
+
+	/* We set RS(n,k) for EPB parms and pre-data, if any */
+	if (insideMH && (idx == 0)) {
+		/* First EPB in MH */ 
+		epb->k_pre = 64;
+		epb->n_pre = 160;
+	} else if (!insideMH && (idx == 0)) {
+		/* First EPB in TH */
+		epb->k_pre = 25;
+		epb->n_pre = 80;
+	} else {
+		/* Following EPBs in MH or TH */
+		epb->k_pre = 13;
+		epb->n_pre = 40;
+	};
+
+	/* Find lengths, Figs. B3 and B4 */
+	/* size of pre data: pre_buf(pre_len) + EPB(2) + Lepb(2) + Depb(1) + LDPepb(4) + Pepb(4) */
+	L1 = pre_len + 13;
+	epb->pre_len = pre_len;
+
+	/* size of pre-data redundancy */
+	/*   (redundancy per codeword)       *               (number of codewords, rounded up)   */
+	L2 = (epb->n_pre - epb->k_pre) * (unsigned short int) ceil((double) L1 / (double) epb->k_pre);
+
+	/* length of post-data */
+	L4 = post_len;
+	epb->post_len = post_len;
+
+	/* Find protection type for post data and its associated redundancy field length*/
+	if ((hprot == 16) || (hprot == 32)) {
+		/* there is a CRC for post-data */
+		epb->Pepb = 0x10000000 | ((unsigned long int) hprot >> 5); /* 0=CRC-16, 1=CRC-32 */
+		epb->k_post = post_len;
+		epb->n_post = post_len + (hprot >> 3);
+		/*L3 = hprot >> 3;*/ /* 2 (CRC-16) or 4 (CRC-32) bytes */
+
+	} else if ((hprot >= 37) && (hprot <= 128)) {
+		/* there is a RS for post-data */
+		epb->Pepb = 0x20000020 | (((unsigned long int) hprot & 0x000000FF) << 8);
+		epb->k_post = 32;
+		epb->n_post = hprot;
+
+	} else if (hprot == 1) {
+		/* Use predefined codes */
+		epb->Pepb = (unsigned long int) 0x00000000;
+		epb->n_post = epb->n_pre;
+		epb->k_post = epb->k_pre;
+	
+	} else if (hprot == 0) {
+		/* Placeholder EPB: only protects its parameters, no protection method */
+		epb->Pepb = (unsigned long int) 0xFFFFFFFF;
+		epb->n_post = 1;
+		epb->k_post = 1;
+	
+	} else {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Invalid protection value for EPB h = %d\n", hprot);				
+		return NULL;
+	}
+
+	epb->hprot = hprot;
+
+	/*   (redundancy per codeword)          *                (number of codewords, rounded up) */
+	L3 = (epb->n_post - epb->k_post) * (unsigned short int) ceil((double) L4 / (double) epb->k_post);
+
+	/* private fields */
+	epb->tileno = tileno;
+
+	/* Fill some fields of the EPB */
+
+	/* total length of the EPB MS (less the EPB marker itself): */
+	/* Lepb(2) + Depb(1) + LDPepb(4) + Pepb(4) + pre_redundancy + post-redundancy */
+	epb->Lepb = 11 + L2 + L3;
+
+	/* EPB style */
+	epb->Depb = ((packed & 0x0001) << 7) | ((latest & 0x0001) << 6) | (idx & 0x003F);
+
+	/* length of data protected by EPB: */
+	epb->LDPepb = L1 + L4;
+
+	return epb;
+}
+
+void jpwl_epb_write(opj_j2k_t *j2k, jpwl_epb_ms_t *epb, unsigned char *buf) {
+
+	/* Marker */
+	*(buf++) = (unsigned char) (J2K_MS_EPB >> 8); 
+	*(buf++) = (unsigned char) (J2K_MS_EPB >> 0); 
+
+	/* Lepb */
+	*(buf++) = (unsigned char) (epb->Lepb >> 8); 
+	*(buf++) = (unsigned char) (epb->Lepb >> 0); 
+
+	/* Depb */
+	*(buf++) = (unsigned char) (epb->Depb >> 0); 
+
+	/* LDPepb */
+	*(buf++) = (unsigned char) (epb->LDPepb >> 24); 
+	*(buf++) = (unsigned char) (epb->LDPepb >> 16); 
+	*(buf++) = (unsigned char) (epb->LDPepb >> 8); 
+	*(buf++) = (unsigned char) (epb->LDPepb >> 0); 
+
+	/* Pepb */
+	*(buf++) = (unsigned char) (epb->Pepb >> 24); 
+	*(buf++) = (unsigned char) (epb->Pepb >> 16); 
+	*(buf++) = (unsigned char) (epb->Pepb >> 8); 
+	*(buf++) = (unsigned char) (epb->Pepb >> 0); 
+
+	/* Data */
+	/*memcpy(buf, epb->data, (size_t) epb->Lepb - 11);*/
+	memset(buf, 0, (size_t) epb->Lepb - 11);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPB, -1, epb->Lepb + 2);
+
+};
+
+
+jpwl_epc_ms_t *jpwl_epc_create(opj_j2k_t *j2k, bool esd_on, bool red_on, bool epb_on, bool info_on) {
+
+	jpwl_epc_ms_t *epc = NULL;
+
+	/* Alloc space */
+	if (!(epc = (jpwl_epc_ms_t *) malloc((size_t) 1 * sizeof (jpwl_epc_ms_t)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for EPC MS\n");
+		return NULL;
+	};
+
+	/* Set the EPC parameters */
+	epc->esd_on = esd_on;
+	epc->epb_on = epb_on;
+	epc->red_on = red_on;
+	epc->info_on = info_on;
+
+	/* Fill the EPC fields with default values */
+	epc->Lepc = 9;
+	epc->Pcrc = 0x0000;
+	epc->DL = 0x00000000;
+	epc->Pepc = ((j2k->cp->esd_on & 0x0001) << 4) | ((j2k->cp->red_on & 0x0001) << 5) |
+		((j2k->cp->epb_on & 0x0001) << 6) | ((j2k->cp->info_on & 0x0001) << 7);
+
+	return (epc);
+}
+
+bool jpwl_epb_fill(opj_j2k_t *j2k, jpwl_epb_ms_t *epb, unsigned char *buf, unsigned char *post_buf) {
+
+	unsigned long int L1, L2, L3, L4;
+	int remaining;
+	unsigned long int P, NN_P;
+
+	/* Operating buffer */
+	static unsigned char codeword[NN], *parityword;
+
+	unsigned char *L1_buf, *L2_buf;
+	/* these ones are static, since we need to keep memory of
+	 the exact place from one call to the other */
+	static unsigned char *L3_buf, *L4_buf;
+
+	/* some consistency check */
+	if (!buf) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "There is no operating buffer for EPBs\n");
+		return false;
+	}
+
+	if (!post_buf && !L4_buf) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "There is no operating buffer for EPBs data\n");
+		return false;
+	}
+
+	/*
+	 * Compute parity bytes on pre-data, ALWAYS present (at least only for EPB parms)
+	 */
+
+	/* Initialize RS structures */
+	P = epb->n_pre - epb->k_pre;
+	NN_P = NN - P;
+	memset(codeword, 0, NN);
+	parityword = codeword + NN_P;
+	init_rs(NN_P);
+
+	/* pre-data begins pre_len bytes before of EPB buf */
+	L1_buf = buf - epb->pre_len;
+	L1 = epb->pre_len + 13;
+
+	/* redundancy for pre-data begins immediately after EPB parms */
+	L2_buf = buf + 13;
+	L2 = (epb->n_pre - epb->k_pre) * (unsigned short int) ceil((double) L1 / (double) epb->k_pre);
+
+	/* post-data
+	   the position of L4 buffer can be:
+	     1) passed as a parameter: in that case use it
+	     2) null: in that case use the previous (static) one
+	*/
+	if (post_buf)
+		L4_buf = post_buf;
+	L4 = epb->post_len;
+
+	/* post-data redundancy begins immediately after pre-data redundancy */
+	L3_buf = L2_buf + L2;
+	L3 = (epb->n_post - epb->k_post) * (unsigned short int) ceil((double) L4 / (double) epb->k_post);
+
+	/* let's check whether EPB length is sufficient to contain all these data */
+	if (epb->Lepb < (11 + L2 + L3))
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "There is no room in EPB data field for writing redundancy data\n");
+	/*printf("Env. %d, nec. %d (%d + %d)\n", epb->Lepb - 11, L2 + L3, L2, L3);*/
+
+	/* Compute redundancy of pre-data message words */
+	remaining = L1;
+	while (remaining) {
+
+		/* copy message data into codeword buffer */
+		if (remaining < epb->k_pre) {
+			/* the last message word is zero-padded */
+			memset(codeword, 0, NN);
+			memcpy(codeword, L1_buf, remaining);
+			L1_buf += remaining;
+			remaining = 0;
+
+		} else {
+			memcpy(codeword, L1_buf, epb->k_pre);
+			L1_buf += epb->k_pre;
+			remaining -= epb->k_pre;
+
+		}
+
+		/* Encode the buffer and obtain parity bytes */
+		if (encode_rs(codeword, parityword))
+			opj_event_msg(j2k->cinfo, EVT_WARNING,
+				"Possible encoding error in codeword @ position #%d\n", (L1_buf - buf) / epb->k_pre);
+
+		/* copy parity bytes only in redundancy buffer */
+		memcpy(L2_buf, parityword, P); 
+
+		/* advance parity buffer */
+		L2_buf += P;
+	}
+
+	/*
+	 * Compute parity bytes on post-data, may be absent if there are no data
+	 */
+	/*printf("Hprot is %d (tileno=%d, k_pre=%d, n_pre=%d, k_post=%d, n_post=%d, pre_len=%d, post_len=%d)\n",
+		epb->hprot, epb->tileno, epb->k_pre, epb->n_pre, epb->k_post, epb->n_post, epb->pre_len,
+		epb->post_len);*/
+	if (epb->hprot < 0) {
+
+		/* there should be no EPB */
+		
+	} else if (epb->hprot == 0) {
+
+		/* no protection for the data */
+		/* advance anyway */
+		L4_buf += epb->post_len;
+
+	} else if (epb->hprot == 16) {
+
+		/* CRC-16 */
+		unsigned short int mycrc = 0x0000;
+
+		/* compute the CRC field (excluding itself) */
+		remaining = L4;
+		while (remaining--)
+			jpwl_updateCRC16(&mycrc, *(L4_buf++));
+
+		/* write the CRC field */
+		*(L3_buf++) = (unsigned char) (mycrc >> 8);
+		*(L3_buf++) = (unsigned char) (mycrc >> 0);
+
+	} else if (epb->hprot == 32) {
+
+		/* CRC-32 */
+		unsigned long int mycrc = 0x00000000;
+
+		/* compute the CRC field (excluding itself) */
+		remaining = L4;
+		while (remaining--)
+			jpwl_updateCRC32(&mycrc, *(L4_buf++));
+
+		/* write the CRC field */
+		*(L3_buf++) = (unsigned char) (mycrc >> 24);
+		*(L3_buf++) = (unsigned char) (mycrc >> 16);
+		*(L3_buf++) = (unsigned char) (mycrc >> 8);
+		*(L3_buf++) = (unsigned char) (mycrc >> 0);
+
+	} else {
+
+		/* RS */
+
+		/* Initialize RS structures */
+		P = epb->n_post - epb->k_post;
+		NN_P = NN - P;
+		memset(codeword, 0, NN);
+		parityword = codeword + NN_P;
+		init_rs(NN_P);
+
+		/* Compute redundancy of post-data message words */
+		remaining = L4;
+		while (remaining) {
+
+			/* copy message data into codeword buffer */
+			if (remaining < epb->k_post) {
+				/* the last message word is zero-padded */
+				memset(codeword, 0, NN);
+				memcpy(codeword, L4_buf, remaining);
+				L4_buf += remaining;
+				remaining = 0;
+
+			} else {
+				memcpy(codeword, L4_buf, epb->k_post);
+				L4_buf += epb->k_post;
+				remaining -= epb->k_post;
+
+			}
+
+			/* Encode the buffer and obtain parity bytes */
+			if (encode_rs(codeword, parityword))
+				opj_event_msg(j2k->cinfo, EVT_WARNING,
+					"Possible encoding error in codeword @ position #%d\n", (L4_buf - buf) / epb->k_post);
+
+			/* copy parity bytes only in redundancy buffer */
+			memcpy(L3_buf, parityword, P); 
+
+			/* advance parity buffer */
+			L3_buf += P;
+		}
+
+	}
+
+	return true;
+}
+
+
+bool jpwl_correct(opj_j2k_t *j2k) {
+
+	opj_cio_t *cio = j2k->cio;
+	bool status;
+	static bool mh_done = false;
+	int mark_pos, id, len, skips, sot_pos;
+	unsigned long int Psot = 0;
+
+	/* go back to marker position */
+	mark_pos = cio_tell(cio) - 2;
+	cio_seek(cio, mark_pos);
+
+	if ((j2k->state == J2K_STATE_MHSOC) && !mh_done) {
+
+		int mark_val = 0, skipnum = 0;
+
+		/*
+		  COLOR IMAGE
+		  first thing to do, if we are here, is to look whether
+		  51 (skipnum) positions ahead there is an EPB, in case of MH
+		*/
+		/*
+		  B/W IMAGE
+		  first thing to do, if we are here, is to look whether
+		  45 (skipnum) positions ahead there is an EPB, in case of MH
+		*/
+		/*       SIZ   SIZ_FIELDS     SIZ_COMPS               FOLLOWING_MARKER */
+		skipnum = 2  +     38     + 3 * j2k->cp->exp_comps  +         2;
+		if ((cio->bp + skipnum) < cio->end) {
+
+			cio_skip(cio, skipnum);
+
+			/* check that you are not going beyond the end of codestream */
+
+			/* call EPB corrector */
+			status = jpwl_epb_correct(j2k,     /* J2K decompressor handle */
+									  cio->bp, /* pointer to EPB in codestream buffer */
+									  0,       /* EPB type: MH */
+									  skipnum,      /* length of pre-data */
+									  -1,      /* length of post-data: -1 means auto */
+									  NULL,
+									  NULL
+									 );
+
+			/* read the marker value */
+			mark_val = (*(cio->bp) << 8) | *(cio->bp + 1);
+
+			if (status && (mark_val == J2K_MS_EPB)) {
+				/* we found it! */
+				mh_done = true;
+				return true;
+			}
+
+		}
+
+	}
+
+	if (true /*(j2k->state == J2K_STATE_TPHSOT) || (j2k->state == J2K_STATE_TPH)*/) {
+		/* else, look if 12 positions ahead there is an EPB, in case of TPH */
+		cio_seek(cio, mark_pos);
+		if ((cio->bp + 12) < cio->end) {
+
+			cio_skip(cio, 12);
+
+			/* call EPB corrector */
+			status = jpwl_epb_correct(j2k,     /* J2K decompressor handle */
+									  cio->bp, /* pointer to EPB in codestream buffer */
+									  1,       /* EPB type: TPH */
+									  12,      /* length of pre-data */
+									  -1,      /* length of post-data: -1 means auto */
+									  NULL,
+									  NULL
+									 );
+			if (status)
+				/* we found it! */
+				return true;
+		}
+	}
+
+	return false;
+
+	/* for now, don't use this code */
+
+	/* else, look if here is an EPB, in case of other */
+	if (mark_pos > 64) {
+		/* it cannot stay before the first MH EPB */
+		cio_seek(cio, mark_pos);
+		cio_skip(cio, 0);
+
+		/* call EPB corrector */
+		status = jpwl_epb_correct(j2k,     /* J2K decompressor handle */
+								  cio->bp, /* pointer to EPB in codestream buffer */
+								  2,       /* EPB type: TPH */
+								  0,       /* length of pre-data */
+								  -1,      /* length of post-data: -1 means auto */
+								  NULL,
+								  NULL
+								 );
+		if (status)
+			/* we found it! */
+			return true;
+	}
+
+	/* nope, no EPBs probably, or they are so damaged that we can give up */
+	return false;
+	
+	return true;
+
+	/* AN ATTEMPT OF PARSER */
+	/* NOT USED ACTUALLY    */
+
+	/* go to the beginning of the file */
+	cio_seek(cio, 0);
+
+	/* let's begin */
+	j2k->state = J2K_STATE_MHSOC;
+
+	/* cycle all over the markers */
+	while ((unsigned int) cio_tell(cio) < cio->length) {
+
+		/* read the marker */
+		mark_pos = cio_tell(cio);
+		id = cio_read(cio, 2);
+
+		/* details */
+		printf("Marker@%d: %X\n", cio_tell(cio) - 2, id);
+
+		/* do an action in response to the read marker */
+		switch (id) {
+
+		/* short markers */
+
+			/* SOC */
+		case J2K_MS_SOC:
+			j2k->state = J2K_STATE_MHSIZ;
+			len = 0;
+			skips = 0;
+			break;
+
+			/* EOC */
+		case J2K_MS_EOC:
+			j2k->state = J2K_STATE_MT;
+			len = 0;
+			skips = 0;
+			break;
+
+			/* particular case of SOD */
+		case J2K_MS_SOD:
+			len = Psot - (mark_pos - sot_pos) - 2;
+			skips = len;
+			break;
+
+		/* long markers */
+
+			/* SOT */
+		case J2K_MS_SOT:
+			j2k->state = J2K_STATE_TPH;
+			sot_pos = mark_pos; /* position of SOT */
+			len = cio_read(cio, 2); /* read the length field */
+			cio_skip(cio, 2); /* this field is unnecessary */
+			Psot = cio_read(cio, 4); /* tile length */
+			skips = len - 8;
+			break;
+
+			/* remaining */
+		case J2K_MS_SIZ:
+			j2k->state = J2K_STATE_MH;
+			/* read the length field */
+			len = cio_read(cio, 2);
+			skips = len - 2;
+			break;
+
+			/* remaining */
+		default:
+			/* read the length field */
+			len = cio_read(cio, 2);
+			skips = len - 2;
+			break;
+
+		}
+
+		/* skip to marker's end */
+		cio_skip(cio, skips);	
+
+	}
+
+
+}
+
+bool jpwl_epb_correct(opj_j2k_t *j2k, unsigned char *buffer, int type, int pre_len, int post_len, int *conn,
+					  unsigned char **L4_bufp) {
+
+	/* Operating buffer */
+	unsigned char codeword[NN], *parityword;
+
+	unsigned long int P, NN_P;
+	unsigned long int L1, L4;
+	int remaining, n_pre, k_pre, n_post, k_post;
+
+	int status, tt;
+
+	int orig_pos = cio_tell(j2k->cio);
+
+	unsigned char *L1_buf, *L2_buf;
+	unsigned char *L3_buf, *L4_buf;
+
+	unsigned long int LDPepb, Pepb;
+	unsigned short int Lepb;
+	unsigned char Depb;
+	char str1[25] = "";
+	int myconn, errnum = 0;
+	bool errflag = false;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	/* check for common errors */
+	if (!buffer) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "The EPB pointer is a NULL buffer\n");
+		return false;
+	}
+	
+	/* set bignesses */
+	L1 = pre_len + 13;
+
+	/* pre-data correction */
+	switch (type) {
+
+	case 0:
+		/* MH EPB */
+		k_pre = 64;
+		n_pre = 160;
+		break;
+
+	case 1:
+		/* TPH EPB */
+		k_pre = 25;
+		n_pre = 80;
+		break;
+
+	case 2:
+		/* other EPBs */
+		k_pre = 13;
+		n_pre = 40;
+		break;
+
+	case 3:
+		/* automatic setup */
+		break;
+
+	default:
+		/* unknown type */
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Unknown expected EPB type\n");
+		return false;
+		break;
+
+	}
+
+	/* Initialize RS structures */
+	P = n_pre - k_pre;
+	NN_P = NN - P;
+	tt = (int) floor((float) P / 2.0F); /* correction capability of the code */
+	memset(codeword, 0, NN);
+	parityword = codeword + NN_P;
+	init_rs(NN_P);
+
+	/* Correct pre-data message words */
+	L1_buf = buffer - pre_len;
+	L2_buf = buffer + 13;
+	remaining = L1;
+	while (remaining) {
+ 
+		/* always zero-pad codewords */
+		/* (this is required, since after decoding the zeros in the long codeword
+		    could change, and keep unchanged in subsequent calls) */
+		memset(codeword, 0, NN);
+
+		/* copy codeword buffer into message bytes */
+		if (remaining < k_pre)
+			memcpy(codeword, L1_buf, remaining);
+		else
+			memcpy(codeword, L1_buf, k_pre);
+
+		/* copy redundancy buffer in parity bytes */
+		memcpy(parityword, L2_buf, P); 
+
+		/* Decode the buffer and possibly obtain corrected bytes */
+		status = eras_dec_rs(codeword, NULL, 0);
+		if (status == -1) {
+			/*if (conn == NULL)
+				opj_event_msg(j2k->cinfo, EVT_WARNING,
+					"Possible decoding error in codeword @ position #%d\n", (L1_buf - buffer) / k_pre);*/
+			errflag = true;
+			/* we can try to safely get out from the function:
+			  if we are here, either this is not an EPB or the first codeword
+			  is too damaged to be helpful */
+			/*return false;*/
+
+		} else if (status == 0) {
+			/*if (conn == NULL)
+				opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
+
+		} else if (status <= tt) {
+			/* it has corrected 0 <= errs <= tt */
+			/*if (conn == NULL)
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
+			errnum += status;
+
+		} else {
+			/*if (conn == NULL)
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "EPB correction capability exceeded\n");
+			return false;*/
+			errflag = true;
+		}
+
+
+		/* advance parity buffer */
+		if ((status >= 0) && (status <= tt))
+			/* copy back corrected parity only if all is OK */
+			memcpy(L2_buf, parityword, P);
+		L2_buf += P;
+
+		/* advance message buffer */
+		if (remaining < k_pre) {
+			if ((status >= 0) && (status <= tt))
+				/* copy back corrected data only if all is OK */
+				memcpy(L1_buf, codeword, remaining);
+			L1_buf += remaining;
+			remaining = 0;
+
+		} else {
+			if ((status >= 0) && (status <= tt))
+				/* copy back corrected data only if all is OK */
+				memcpy(L1_buf, codeword, k_pre);
+			L1_buf += k_pre;
+			remaining -= k_pre;
+
+		}
+	}
+
+	/* print summary */
+	if (!conn) {
+
+		/*if (errnum)
+			opj_event_msg(j2k->cinfo, EVT_INFO, "+ %d symbol errors corrected (Ps=%.1e)\n", errnum,
+				(float) errnum / ((float) n_pre * (float) L1 / (float) k_pre));*/
+		if (errflag) {
+			/*opj_event_msg(j2k->cinfo, EVT_INFO, "+ there were unrecoverable errors\n");*/
+			return false;
+		}
+
+	}
+
+	/* presumably, now, EPB parameters are correct */
+	/* let's get them */
+
+	/* Simply read the EPB parameters */
+	if (conn)
+		cio->bp = buffer;
+	cio_skip(cio, 2); /* the marker */
+	Lepb = cio_read(cio, 2);
+	Depb = cio_read(cio, 1);
+	LDPepb = cio_read(cio, 4);
+	Pepb = cio_read(cio, 4);
+
+	/* What does Pepb tells us about the protection method? */
+	if (((Pepb & 0xF0000000) >> 28) == 0)
+		sprintf(str1, "pred"); /* predefined */
+	else if (((Pepb & 0xF0000000) >> 28) == 1)
+		sprintf(str1, "crc-%d", 16 * ((Pepb & 0x00000001) + 1)); /* CRC mode */
+	else if (((Pepb & 0xF0000000) >> 28) == 2)
+		sprintf(str1, "rs(%d,32)", (Pepb & 0x0000FF00) >> 8); /* RS mode */
+	else if (Pepb == 0xFFFFFFFF)
+		sprintf(str1, "nometh"); /* RS mode */
+	else
+		sprintf(str1, "unknown"); /* unknown */
+
+	/* Now we write them to screen */
+	if (!conn && post_len)
+		opj_event_msg(j2k->cinfo, EVT_INFO,
+			"EPB(%d): (%sl, %sp, %u), %lu, %s\n",
+			cio_tell(cio) - 13,
+			(Depb & 0x40) ? "" : "n", /* latest EPB or not? */
+			(Depb & 0x80) ? "" : "n", /* packed or unpacked EPB? */
+			(Depb & 0x3F), /* EPB index value */
+			LDPepb, /*length of the data protected by the EPB */
+			str1); /* protection method */
+
+
+	/* well, we need to investigate how long is the connected length of packed EPBs */
+	myconn = Lepb + 2;
+	if ((Depb & 0x40) == 0) /* not latest in header */
+		jpwl_epb_correct(j2k,      /* J2K decompressor handle */
+					     buffer + Lepb + 2,   /* pointer to next EPB in codestream buffer */
+					     2,     /* EPB type: should be of other type */
+					     0,  /* only EPB fields */
+					     0, /* do not look after */
+						 &myconn,
+						 NULL
+					     );
+	if (conn)
+		*conn += myconn;
+
+	/*if (!conn)
+		printf("connected = %d\n", myconn);*/
+
+	/*cio_seek(j2k->cio, orig_pos);
+	return true;*/
+
+	/* post-data
+	   the position of L4 buffer is at the end of currently connected EPBs
+	*/
+	if (!(L4_bufp))
+		L4_buf = buffer + myconn;
+	else if (!(*L4_bufp))
+		L4_buf = buffer + myconn;
+	else
+		L4_buf = *L4_bufp;
+	if (post_len == -1) 
+		L4 = LDPepb - pre_len - 13;
+	else if (post_len == 0)
+		L4 = 0;
+	else
+		L4 = post_len;
+
+	L3_buf = L2_buf;
+
+	/* Do a further check here on the read parameters */
+	if (L4 > (unsigned long) cio_numbytesleft(j2k->cio))
+		/* overflow */
+		return false;
+
+	/* we are ready for decoding the remaining data */
+	if (((Pepb & 0xF0000000) >> 28) == 1) {
+		/* CRC here */
+		if ((16 * ((Pepb & 0x00000001) + 1)) == 16) {
+
+			/* CRC-16 */
+			unsigned short int mycrc = 0x0000, filecrc = 0x0000;
+
+			/* compute the CRC field */
+			remaining = L4;
+			while (remaining--)
+				jpwl_updateCRC16(&mycrc, *(L4_buf++));
+
+			/* read the CRC field */
+			filecrc = *(L3_buf++) << 8;
+			filecrc |= *(L3_buf++);
+
+			/* check the CRC field */
+			if (mycrc == filecrc) {
+				if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_INFO, "- CRC is OK\n");
+			} else {
+				if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "- CRC is KO (r=%d, c=%d)\n", filecrc, mycrc);
+				errflag = true;
+			}	
+		}
+
+		if ((16 * ((Pepb & 0x00000001) + 1)) == 32) {
+
+			/* CRC-32 */
+			unsigned long int mycrc = 0x00000000, filecrc = 0x00000000;
+
+			/* compute the CRC field */
+			remaining = L4;
+			while (remaining--)
+				jpwl_updateCRC32(&mycrc, *(L4_buf++));
+
+			/* read the CRC field */
+			filecrc = *(L3_buf++) << 24;
+			filecrc |= *(L3_buf++) << 16;
+			filecrc |= *(L3_buf++) << 8;
+			filecrc |= *(L3_buf++);
+
+			/* check the CRC field */
+			if (mycrc == filecrc) {
+				if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_INFO, "- CRC is OK\n");
+			} else {
+				if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "- CRC is KO (r=%d, c=%d)\n", filecrc, mycrc);
+				errflag = true;
+			}
+		}
+
+	} else if (Pepb == 0xFFFFFFFF) {
+		/* no method */
+
+		/* advance without doing anything */
+		remaining = L4;
+		while (remaining--)
+			L4_buf++;
+
+	} else if ((((Pepb & 0xF0000000) >> 28) == 2) || (((Pepb & 0xF0000000) >> 28) == 0)) {
+		/* RS coding here */
+
+		if (((Pepb & 0xF0000000) >> 28) == 0) {
+
+			k_post = k_pre;
+			n_post = n_pre;
+
+		} else {
+
+			k_post = 32;
+			n_post = (Pepb & 0x0000FF00) >> 8;
+		}
+
+		/* Initialize RS structures */
+		P = n_post - k_post;
+		NN_P = NN - P;
+		tt = (int) floor((float) P / 2.0F); /* again, correction capability */
+		memset(codeword, 0, NN);
+		parityword = codeword + NN_P;
+		init_rs(NN_P);
+
+		/* Correct post-data message words */
+		/*L4_buf = buffer + Lepb + 2;*/
+		L3_buf = L2_buf;
+		remaining = L4;
+		while (remaining) {
+ 
+			/* always zero-pad codewords */
+			/* (this is required, since after decoding the zeros in the long codeword
+				could change, and keep unchanged in subsequent calls) */
+			memset(codeword, 0, NN);
+
+			/* copy codeword buffer into message bytes */
+			if (remaining < k_post)
+				memcpy(codeword, L4_buf, remaining);
+			else
+				memcpy(codeword, L4_buf, k_post);
+
+			/* copy redundancy buffer in parity bytes */
+			memcpy(parityword, L3_buf, P); 
+
+			/* Decode the buffer and possibly obtain corrected bytes */
+			status = eras_dec_rs(codeword, NULL, 0);
+			if (status == -1) {
+				/*if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_WARNING,
+						"Possible decoding error in codeword @ position #%d\n", (L4_buf - (buffer + Lepb + 2)) / k_post);*/
+				errflag = true;
+
+			} else if (status == 0) {
+				/*if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_INFO, "codeword is correctly decoded\n");*/
+
+			} else if (status <= tt) {
+				/*if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "%d errors corrected in codeword\n", status);*/
+				errnum += status;
+
+			} else {
+				/*if (conn == NULL)
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "EPB correction capability exceeded\n");
+				return false;*/
+				errflag = true;
+			}
+
+
+			/* advance parity buffer */
+			if ((status >= 0) && (status <= tt))
+				/* copy back corrected data only if all is OK */
+				memcpy(L3_buf, parityword, P);
+			L3_buf += P;
+
+			/* advance message buffer */
+			if (remaining < k_post) {
+				if ((status >= 0) && (status <= tt))
+					/* copy back corrected data only if all is OK */
+					memcpy(L4_buf, codeword, remaining);
+				L4_buf += remaining;
+				remaining = 0;
+
+			} else {
+				if ((status >= 0) && (status <= tt))
+					/* copy back corrected data only if all is OK */
+					memcpy(L4_buf, codeword, k_post);
+				L4_buf += k_post;
+				remaining -= k_post;
+
+			}
+		}
+	}
+
+	/* give back the L4_buf address */
+	if (L4_bufp)
+		*L4_bufp = L4_buf;
+
+	/* print summary */
+	if (!conn) {
+
+		if (errnum)
+			opj_event_msg(j2k->cinfo, EVT_INFO, "- %d symbol errors corrected (Ps=%.1e)\n", errnum,
+				(float) errnum / (float) LDPepb);
+		if (errflag)
+			opj_event_msg(j2k->cinfo, EVT_INFO, "- there were unrecoverable errors\n");
+
+	}
+
+	cio_seek(j2k->cio, orig_pos);
+
+	return true;
+}
+
+void jpwl_epc_write(opj_j2k_t *j2k, jpwl_epc_ms_t *epc, unsigned char *buf) {
+
+	/* Marker */
+	*(buf++) = (unsigned char) (J2K_MS_EPC >> 8); 
+	*(buf++) = (unsigned char) (J2K_MS_EPC >> 0); 
+
+	/* Lepc */
+	*(buf++) = (unsigned char) (epc->Lepc >> 8); 
+	*(buf++) = (unsigned char) (epc->Lepc >> 0); 
+
+	/* Pcrc */
+	*(buf++) = (unsigned char) (epc->Pcrc >> 8); 
+	*(buf++) = (unsigned char) (epc->Pcrc >> 0);
+
+	/* DL */
+	*(buf++) = (unsigned char) (epc->DL >> 24); 
+	*(buf++) = (unsigned char) (epc->DL >> 16); 
+	*(buf++) = (unsigned char) (epc->DL >> 8); 
+	*(buf++) = (unsigned char) (epc->DL >> 0); 
+
+	/* Pepc */
+	*(buf++) = (unsigned char) (epc->Pepc >> 0); 
+
+	/* Data */
+	/*memcpy(buf, epc->data, (size_t) epc->Lepc - 9);*/
+	memset(buf, 0, (size_t) epc->Lepc - 9);
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EPC, -1, epc->Lepc + 2);
+
+};
+
+int jpwl_esds_add(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int *jwmarker_num,
+				  int comps, unsigned char addrm, unsigned char ad_size,
+				  unsigned char senst, unsigned char se_size,
+				  double place_pos, int tileno) {
+
+	return 0;
+}
+
+jpwl_esd_ms_t *jpwl_esd_create(opj_j2k_t *j2k, int comp, unsigned char addrm, unsigned char ad_size,
+								unsigned char senst, unsigned char se_size, int tileno,
+								unsigned long int svalnum, void *sensval) {
+
+	jpwl_esd_ms_t *esd = NULL;
+
+	/* Alloc space */
+	if (!(esd = (jpwl_esd_ms_t *) malloc((size_t) 1 * sizeof (jpwl_esd_ms_t)))) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Could not allocate room for ESD MS\n");
+		return NULL;
+	};
+
+	/* if relative sensitivity, activate byte range mode */
+	if (senst == 0)
+		addrm = 1;
+
+	/* size of sensval's ... */
+	if ((ad_size != 0) && (ad_size != 2) && (ad_size != 4)) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Address size %d for ESD MS is forbidden\n", ad_size);
+		return NULL;
+	}
+	if ((se_size != 1) && (se_size != 2)) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Sensitivity size %d for ESD MS is forbidden\n", se_size);
+		return NULL;
+	}
+	
+	/* ... depends on the addressing mode */
+	switch (addrm) {
+
+	/* packet mode */
+	case (0):
+		ad_size = 0; /* as per the standard */
+		esd->sensval_size = se_size; 
+		break;
+
+	/* byte range */
+	case (1):
+		/* auto sense address size */
+		if (ad_size == 0)
+			/* if there are more than 66% of (2^16 - 1) bytes, switch to 4 bytes
+			 (we keep space for possible EPBs being inserted) */
+			ad_size = (j2k->cstr_info->codestream_size > (1 * 65535 / 3)) ? 4 : 2;
+		esd->sensval_size = ad_size + ad_size + se_size; 
+		break;
+
+	/* packet range */
+	case (2):
+		/* auto sense address size */
+		if (ad_size == 0)
+			/* if there are more than 2^16 - 1 packets, switch to 4 bytes */
+			ad_size = (j2k->cstr_info->packno > 65535) ? 4 : 2;
+		esd->sensval_size = ad_size + ad_size + se_size; 
+		break;
+
+	case (3):
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Address mode %d for ESD MS is unimplemented\n", addrm);
+		return NULL;
+
+	default:
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Address mode %d for ESD MS is forbidden\n", addrm);
+		return NULL;
+	}
+
+	/* set or unset sensitivity values */
+	if (svalnum <= 0) {
+
+		switch (senst) {
+
+		/* just based on the portions of a codestream */
+		case (0):
+			/* MH + no. of THs + no. of packets */
+			svalnum = 1 + (j2k->cstr_info->tw * j2k->cstr_info->th) * (1 + j2k->cstr_info->packno);
+			break;
+
+		/* all the ones that are based on the packets */
+		default:
+			if (tileno < 0)
+				/* MH: all the packets and all the tiles info is written */
+				svalnum = j2k->cstr_info->tw * j2k->cstr_info->th * j2k->cstr_info->packno;
+			else
+				/* TPH: only that tile info is written */
+				svalnum = j2k->cstr_info->packno;
+			break;
+
+		}
+	}		
+
+	/* fill private fields */
+	esd->senst = senst;
+	esd->ad_size = ad_size;
+	esd->se_size = se_size;
+	esd->addrm = addrm;
+	esd->svalnum = svalnum;
+	esd->numcomps = j2k->image->numcomps;
+	esd->tileno = tileno;
+	
+	/* Set the ESD parameters */
+	/* length, excluding data field */
+	if (esd->numcomps < 257)
+		esd->Lesd = 4 + (unsigned short int) (esd->svalnum * esd->sensval_size);
+	else
+		esd->Lesd = 5 + (unsigned short int) (esd->svalnum * esd->sensval_size);
+
+	/* component data field */
+	if (comp >= 0)
+		esd->Cesd = comp;
+	else
+		/* we are averaging */
+		esd->Cesd = 0;
+
+	/* Pesd field */
+	esd->Pesd = 0x00;
+	esd->Pesd |= (esd->addrm & 0x03) << 6; /* addressing mode */
+	esd->Pesd |= (esd->senst & 0x07) << 3; /* sensitivity type */
+	esd->Pesd |= ((esd->se_size >> 1) & 0x01) << 2; /* sensitivity size */
+	esd->Pesd |= ((esd->ad_size >> 2) & 0x01) << 1; /* addressing size */
+	esd->Pesd |= (comp < 0) ? 0x01 : 0x00; /* averaging components */
+
+	/* if pointer to sensval is NULL, we can fill data field by ourselves */
+	if (!sensval) {
+
+		/* old code moved to jpwl_esd_fill() */
+		esd->data = NULL;
+
+	} else {
+			/* we set the data field as the sensitivity values poinnter passed to the function */
+			esd->data = (unsigned char *) sensval;
+	}
+
+	return (esd);
+}
+
+bool jpwl_esd_fill(opj_j2k_t *j2k, jpwl_esd_ms_t *esd, unsigned char *buf) {
+
+	int i;
+	unsigned long int vv;
+	unsigned long int addr1, addr2;
+	double dvalue, Omax2, tmp, TSE, MSE, oldMSE, PSNR, oldPSNR;
+	unsigned short int pfpvalue;
+	unsigned long int addrmask = 0x00000000;
+	bool doneMH = false, doneTPH = false;
+
+	/* sensitivity values in image info are as follows:
+		- for each tile, distotile is the starting distortion for that tile, sum of all components
+		- for each packet in a tile, disto is the distortion reduction caused by that packet to that tile
+		- the TSE for a single tile should be given by   distotile - sum(disto)  , for all components
+		- the MSE for a single tile is given by     TSE / nbpix    , for all components
+		- the PSNR for a single tile is given by   10*log10( Omax^2 / MSE)    , for all components
+		  (Omax is given by    2^bpp - 1    for unsigned images and by    2^(bpp - 1) - 1    for signed images
+	*/
+
+	/* browse all components and find Omax */
+	Omax2 = 0.0;
+	for (i = 0; i < j2k->image->numcomps; i++) {
+		tmp = pow(2.0, (double) (j2k->image->comps[i].sgnd ?
+			(j2k->image->comps[i].bpp - 1) : (j2k->image->comps[i].bpp))) - 1;
+		if (tmp > Omax2)
+			Omax2 = tmp;
+	}
+	Omax2 = Omax2 * Omax2;
+
+	/* if pointer of esd->data is not null, simply write down all the values byte by byte */
+	if (esd->data) {
+		for (i = 0; i < (int) esd->svalnum; i++)
+			*(buf++) = esd->data[i]; 
+		return true;
+	}
+
+	/* addressing mask */
+	if (esd->ad_size == 2)
+		addrmask = 0x0000FFFF; /* two bytes */
+	else
+		addrmask = 0xFFFFFFFF; /* four bytes */
+
+	/* set on precise point where sensitivity starts */
+	if (esd->numcomps < 257)
+		buf += 6;
+	else
+		buf += 7;
+
+	/* let's fill the data fields */
+	for (vv = (esd->tileno < 0) ? 0 : (j2k->cstr_info->packno * esd->tileno); vv < esd->svalnum; vv++) {
+
+		int thistile = vv / j2k->cstr_info->packno, thispacket = vv % j2k->cstr_info->packno;
+
+		/* skip for the hack some lines below */
+		if (thistile == j2k->cstr_info->tw * j2k->cstr_info->th)
+			break;
+
+		/* starting tile distortion */
+		if (thispacket == 0) {
+			TSE = j2k->cstr_info->tile[thistile].distotile;
+			oldMSE = TSE / j2k->cstr_info->tile[thistile].numpix;
+			oldPSNR = 10.0 * log10(Omax2 / oldMSE);
+		}
+
+		/* TSE */
+		TSE -= j2k->cstr_info->tile[thistile].packet[thispacket].disto;
+
+		/* MSE */
+		MSE = TSE / j2k->cstr_info->tile[thistile].numpix;
+
+		/* PSNR */
+		PSNR = 10.0 * log10(Omax2 / MSE);
+
+		/* fill the address range */
+		switch (esd->addrm) {
+
+		/* packet mode */
+		case (0):
+			/* nothing, there is none */
+			break;
+
+		/* byte range */
+		case (1):
+			/* start address of packet */
+			addr1 = (j2k->cstr_info->tile[thistile].packet[thispacket].start_pos) & addrmask;
+			/* end address of packet */
+			addr2 = (j2k->cstr_info->tile[thistile].packet[thispacket].end_pos) & addrmask;
+			break;
+
+		/* packet range */
+		case (2):
+			/* not implemented here */
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "Addressing mode packet_range is not implemented\n");
+			break;
+
+		/* unknown addressing method */
+		default:
+			/* not implemented here */
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "Unknown addressing mode\n");
+			break;
+
+		}
+
+		/* hack for writing relative sensitivity of MH and TPHs */
+		if ((esd->senst == 0) && (thispacket == 0)) {
+
+			/* possible MH */
+			if ((thistile == 0) && !doneMH) {
+				/* we have to manage MH addresses */
+				addr1 = 0; /* start of MH */
+				addr2 = j2k->cstr_info->main_head_end; /* end of MH */
+				/* set special dvalue for this MH */
+				dvalue = -10.0;
+				doneMH = true; /* don't come here anymore */
+				vv--; /* wrap back loop counter */
+
+			} else if (!doneTPH) {
+				/* we have to manage TPH addresses */
+				addr1 = j2k->cstr_info->tile[thistile].start_pos;
+				addr2 = j2k->cstr_info->tile[thistile].end_header;
+				/* set special dvalue for this TPH */
+				dvalue = -1.0;
+				doneTPH = true; /* don't come here till the next tile */
+				vv--; /* wrap back loop counter */
+			}
+
+		} else
+			doneTPH = false; /* reset TPH counter */
+
+		/* write the addresses to the buffer */
+		switch (esd->ad_size) {
+
+		case (0):
+			/* do nothing */
+			break;
+
+		case (2):
+			/* two bytes */
+			*(buf++) = (unsigned char) (addr1 >> 8); 
+			*(buf++) = (unsigned char) (addr1 >> 0); 
+			*(buf++) = (unsigned char) (addr2 >> 8); 
+			*(buf++) = (unsigned char) (addr2 >> 0); 
+			break;
+
+		case (4):
+			/* four bytes */
+			*(buf++) = (unsigned char) (addr1 >> 24); 
+			*(buf++) = (unsigned char) (addr1 >> 16); 
+			*(buf++) = (unsigned char) (addr1 >> 8); 
+			*(buf++) = (unsigned char) (addr1 >> 0); 
+			*(buf++) = (unsigned char) (addr2 >> 24); 
+			*(buf++) = (unsigned char) (addr2 >> 16); 
+			*(buf++) = (unsigned char) (addr2 >> 8); 
+			*(buf++) = (unsigned char) (addr2 >> 0); 
+			break;
+
+		default:
+			/* do nothing */
+			break;
+		}
+
+
+		/* let's fill the value field */
+		switch (esd->senst) {
+
+		/* relative sensitivity */
+		case (0):
+			/* we just write down the packet ordering */
+			if (dvalue == -10)
+				/* MH */
+				dvalue = MAX_V1 + 1000.0; /* this will cause pfpvalue set to 0xFFFF */
+			else if (dvalue == -1)
+				/* TPH */
+				dvalue = MAX_V1 + 1000.0; /* this will cause pfpvalue set to 0xFFFF */
+			else
+				/* packet: first is most important, and then in decreasing order
+				down to the last, which counts for 1 */
+				dvalue = jpwl_pfp_to_double((unsigned short) (j2k->cstr_info->packno - thispacket), esd->se_size);
+			break;
+
+		/* MSE */
+		case (1):
+			/* !!! WRONG: let's put here disto field of packets !!! */
+			dvalue = MSE;
+			break;
+
+		/* MSE reduction */
+		case (2):
+			dvalue = oldMSE - MSE;
+			oldMSE = MSE;
+			break;
+
+		/* PSNR */
+		case (3):
+			dvalue = PSNR;
+			break;
+
+		/* PSNR increase */
+		case (4):
+			dvalue = PSNR - oldPSNR;
+			oldPSNR = PSNR;
+			break;
+
+		/* MAXERR */
+		case (5):
+			dvalue = 0.0;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "MAXERR sensitivity mode is not implemented\n");
+			break;
+
+		/* TSE */
+		case (6):
+			dvalue = TSE;
+			break;
+
+		/* reserved */
+		case (7):
+			dvalue = 0.0;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "Reserved sensitivity mode is not implemented\n");
+			break;
+
+		default:
+			dvalue = 0.0;
+			break;
+		}
+
+		/* compute the pseudo-floating point value */
+		pfpvalue = jpwl_double_to_pfp(dvalue, esd->se_size);
+
+		/* write the pfp value to the buffer */
+		switch (esd->se_size) {
+
+		case (1):
+			/* one byte */
+			*(buf++) = (unsigned char) (pfpvalue >> 0); 
+			break;
+
+		case (2):
+			/* two bytes */
+			*(buf++) = (unsigned char) (pfpvalue >> 8); 
+			*(buf++) = (unsigned char) (pfpvalue >> 0); 
+			break;
+		}
+
+	}
+
+	return true;
+}
+
+void jpwl_esd_write(opj_j2k_t *j2k, jpwl_esd_ms_t *esd, unsigned char *buf) {
+
+	/* Marker */
+	*(buf++) = (unsigned char) (J2K_MS_ESD >> 8); 
+	*(buf++) = (unsigned char) (J2K_MS_ESD >> 0); 
+
+	/* Lesd */
+	*(buf++) = (unsigned char) (esd->Lesd >> 8); 
+	*(buf++) = (unsigned char) (esd->Lesd >> 0); 
+
+	/* Cesd */
+	if (esd->numcomps >= 257)
+		*(buf++) = (unsigned char) (esd->Cesd >> 8); 
+	*(buf++) = (unsigned char) (esd->Cesd >> 0); 
+
+	/* Pesd */
+	*(buf++) = (unsigned char) (esd->Pesd >> 0); 
+
+	/* Data */
+	if (esd->numcomps < 257)
+		memset(buf, 0xAA, (size_t) esd->Lesd - 4);
+		/*memcpy(buf, esd->data, (size_t) esd->Lesd - 4);*/
+	else
+		memset(buf, 0xAA, (size_t) esd->Lesd - 5);
+		/*memcpy(buf, esd->data, (size_t) esd->Lesd - 5);*/
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_ESD, -1, esd->Lesd + 2);
+
+}
+
+unsigned short int jpwl_double_to_pfp(double V, int bytes) {
+
+	unsigned short int em, e, m;
+
+	switch (bytes) {
+
+	case (1):
+
+		if (V < MIN_V1) {
+			e = 0x0000;
+			m = 0x0000;
+		} else if (V > MAX_V1) {
+			e = 0x000F;
+			m = 0x000F;
+		} else {
+			e = (unsigned short int) (floor(log(V) * 1.44269504088896) / 4.0);
+			m = (unsigned short int) (0.5 + (V / (pow(2.0, (double) (4 * e)))));
+		}
+		em = ((e & 0x000F) << 4) + (m & 0x000F);		
+		break;
+
+	case (2):
+
+		if (V < MIN_V2) {
+			e = 0x0000;
+			m = 0x0000;
+		} else if (V > MAX_V2) {
+			e = 0x001F;
+			m = 0x07FF;
+		} else {
+			e = (unsigned short int) floor(log(V) * 1.44269504088896) + 15;
+			m = (unsigned short int) (0.5 + 2048.0 * ((V / (pow(2.0, (double) e - 15.0))) - 1.0));
+		}
+		em = ((e & 0x001F) << 11) + (m & 0x07FF);
+		break;
+
+	default:
+
+		em = 0x0000;
+		break;
+	};
+
+	return em;
+}
+
+double jpwl_pfp_to_double(unsigned short int em, int bytes) {
+
+	double V;
+
+	switch (bytes) {
+
+	case 1:
+		V = (double) (em & 0x0F) * pow(2.0, (double) (em & 0xF0));
+		break;
+
+	case 2:
+
+		V = pow(2.0, (double) ((em & 0xF800) >> 11) - 15.0) * (1.0 + (double) (em & 0x07FF) / 2048.0);
+		break;
+
+	default:
+		V = 0.0;
+		break;
+
+	}
+
+	return V;
+
+}
+
+bool jpwl_update_info(opj_j2k_t *j2k, jpwl_marker_t *jwmarker, int jwmarker_num) {
+
+	int mm;
+	unsigned long int addlen;
+
+	opj_codestream_info_t *info = j2k->cstr_info;
+	int tileno, tpno, packno, numtiles = info->th * info->tw, numpacks = info->packno;
+
+	if (!j2k || !jwmarker ) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "J2K handle or JPWL markers list badly allocated\n");
+		return false;
+	}
+
+	/* main_head_end: how many markers are there before? */
+	addlen = 0;
+	for (mm = 0; mm < jwmarker_num; mm++)
+		if (jwmarker[mm].pos < (unsigned long int) info->main_head_end)
+			addlen += jwmarker[mm].len + 2;
+	info->main_head_end += addlen;
+
+	/* codestream_size: always increment with all markers */
+	addlen = 0;
+	for (mm = 0; mm < jwmarker_num; mm++)
+		addlen += jwmarker[mm].len + 2;
+	info->codestream_size += addlen;
+
+	/* navigate through all the tiles */
+	for (tileno = 0; tileno < numtiles; tileno++) {
+
+		/* start_pos: increment with markers before SOT */
+		addlen = 0;
+		for (mm = 0; mm < jwmarker_num; mm++)
+			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].start_pos)
+				addlen += jwmarker[mm].len + 2;
+		info->tile[tileno].start_pos += addlen;
+
+		/* end_header: increment with markers before of it */
+		addlen = 0;
+		for (mm = 0; mm < jwmarker_num; mm++)
+			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].end_header)
+				addlen += jwmarker[mm].len + 2;
+		info->tile[tileno].end_header += addlen;
+
+		/* end_pos: increment with markers before the end of this tile */
+		/* code is disabled, since according to JPWL no markers can be beyond TPH */
+		addlen = 0;
+		for (mm = 0; mm < jwmarker_num; mm++)
+			if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].end_pos)
+				addlen += jwmarker[mm].len + 2;
+		info->tile[tileno].end_pos += addlen;
+
+		/* navigate through all the tile parts */
+		for (tpno = 0; tpno < info->tile[tileno].num_tps; tpno++) {
+
+			/* start_pos: increment with markers before SOT */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_start_pos += addlen;
+
+			/* end_header: increment with markers before of it */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_header)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_header += addlen;
+
+			/* end_pos: increment with markers before the end of this tile part */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].tp[tpno].tp_end_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].tp[tpno].tp_end_pos += addlen;
+
+		}
+
+		/* navigate through all the packets in this tile */
+		for (packno = 0; packno < numpacks; packno++) {
+			
+			/* start_pos: increment with markers before the packet */
+			/* disabled for the same reason as before */
+			addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos <= (unsigned long int) info->tile[tileno].packet[packno].start_pos)
+					addlen += jwmarker[mm].len + 2;
+			info->tile[tileno].packet[packno].start_pos += addlen;
+
+			/* end_ph_pos: increment with markers before the packet */
+			/* disabled for the same reason as before */
+			/*addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].end_ph_pos)
+					addlen += jwmarker[mm].len + 2;*/
+			info->tile[tileno].packet[packno].end_ph_pos += addlen;
+
+			/* end_pos: increment if marker is before the end of packet */
+			/* disabled for the same reason as before */
+			/*addlen = 0;
+			for (mm = 0; mm < jwmarker_num; mm++)
+				if (jwmarker[mm].pos < (unsigned long int) info->tile[tileno].packet[packno].end_pos)
+					addlen += jwmarker[mm].len + 2;*/
+			info->tile[tileno].packet[packno].end_pos += addlen;
+
+		}
+	}
+
+	/* reorder the markers list */
+
+	return true;
+}
+
+#endif /* USE_JPWL */
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/LibOpenJPEG_JPWL.dsp.svn-base ./jpwl/.svn/text-base/LibOpenJPEG_JPWL.dsp.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/LibOpenJPEG_JPWL.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/LibOpenJPEG_JPWL.dsp.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,280 @@
+# Microsoft Developer Studio Project File - Name="LibOpenJPEG_JPWL" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=LibOpenJPEG_JPWL - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "LibOpenJPEG_JPWL.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "LibOpenJPEG_JPWL.mak" CFG="LibOpenJPEG_JPWL - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "LibOpenJPEG_JPWL - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "LibOpenJPEG_JPWL - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "LibOpenJPEG_JPWL - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "LibOpenJPEG_JPWL___Win32_Release"
+# PROP BASE Intermediate_Dir "LibOpenJPEG_JPWL___Win32_Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /c
+# ADD BASE RSC /l 0x80c /d "NDEBUG"
+# ADD RSC /l 0x80c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+
+!ELSEIF  "$(CFG)" == "LibOpenJPEG_JPWL - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "LibOpenJPEG_JPWL___Win32_Debug"
+# PROP BASE Intermediate_Dir "LibOpenJPEG_JPWL___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /YX /FD /GZ /c
+# ADD BASE RSC /l 0x80c /d "_DEBUG"
+# ADD RSC /l 0x80c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\LibOpenJPEG_JPWLd.lib"
+
+!ENDIF 
+
+# Begin Target
+
+# Name "LibOpenJPEG_JPWL - Win32 Release"
+# Name "LibOpenJPEG_JPWL - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=..\libopenjpeg\bio.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\cio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\crc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\dwt.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\event.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\image.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k_lib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jp2.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jpt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\jpwl.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\jpwl_lib.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mct.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mqc.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\pi.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\raw.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\rs.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t1.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t2.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tcd.c
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tgt.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=..\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\crc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\jpwl.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\opj_malloc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\rs.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/Makefile.svn-base ./jpwl/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/Makefile.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,83 @@
+# Linux makefile for OpenJPEG + JPWL
+
+VER_MAJOR = 2
+VER_MINOR = 1.2.0
+
+JPWL_SRCS = ./crc.c ./jpwl.c ./jpwl_lib.c ./rs.c
+SRCS = ../libopenjpeg/bio.c ../libopenjpeg/cio.c ../libopenjpeg/dwt.c ../libopenjpeg/event.c ../libopenjpeg/image.c ../libopenjpeg/j2k.c ../libopenjpeg/j2k_lib.c ../libopenjpeg/jp2.c ../libopenjpeg/jpt.c ../libopenjpeg/mct.c ../libopenjpeg/mqc.c ../libopenjpeg/openjpeg.c ../libopenjpeg/pi.c ../libopenjpeg/raw.c ../libopenjpeg/t1.c ../libopenjpeg/t2.c ../libopenjpeg/tcd.c ../libopenjpeg/tgt.c $(JPWL_SRCS)
+INCLS = ../libopenjpeg/bio.h ../libopenjpeg/cio.h ../libopenjpeg/dwt.h ../libopenjpeg/event.h ../libopenjpeg/fix.h ../libopenjpeg/image.h ../libopenjpeg/int.h ../libopenjpeg/j2k.h ../libopenjpeg/j2k_lib.h ../libopenjpeg/jp2.h ../libopenjpeg/jpt.h ../libopenjpeg/mct.h ../libopenjpeg/mqc.h ../libopenjpeg/openjpeg.h ../libopenjpeg/pi.h ../libopenjpeg/raw.h ../libopenjpeg/t1.h ../libopenjpeg/t2.h ../libopenjpeg/tcd.h ../libopenjpeg/tgt.h ../libopenjpeg/opj_malloc.h ../libopenjpeg/opj_includes.h
+INCLUDE = -Ilibopenjpeg_JPWL
+
+# General configuration variables:
+CC = gcc
+AR = ar
+
+PREFIX = /usr
+INSTALL_LIBDIR = $(PREFIX)/lib
+INSTALL_INCLUDE = $(PREFIX)/include
+
+# Converts cr/lf to just lf
+DOS2UNIX = dos2unix
+
+COMPILERFLAGS = -O3 -fPIC
+LIBRARIES = -lstdc++
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE) -DUSE_JPWL
+
+TARGET  = openjpeg_JPWL
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
+LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
+
+
+
+default: all
+
+all: OpenJPEG_JPWL JPWL_image_to_j2k JPWL_j2k_to_image
+
+dist: OpenJPEG_JPWL
+	install -d dist
+	install -m 644 $(STATICLIB) dist
+	install -m 755 $(SHAREDLIB) dist
+	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
+	install libopenjpeg/openjpeg.h dist
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+OpenJPEG_JPWL: $(STATICLIB) $(SHAREDLIB)
+
+JPWL_codec: JPWL_j2k_to_image JPWL_image_to_j2k $(STATICLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(AR) r $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
+
+JPWL_j2k_to_image: ../codec/j2k_to_image.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/j2k_to_image.c -o JPWL_j2k_to_image -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+JPWL_image_to_j2k: ../codec/image_to_j2k.c
+	gcc $(CFLAGS) ../codec/convert.c ../codec/image_to_j2k.c -o JPWL_image_to_j2k -I ../libopenjpeg/ -L . -lopenjpeg_JPWL -lm -ltiff
+
+install: OpenJPEG
+	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
+	install -m 644 -o root -g root $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
+	install -m 755 -o root -g root $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
+	install -m 644 -o root -g root libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
+	-ldconfig
+
+cleanlib:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+
+cleancodec:
+	rm -f JPWL_j2k_to_image JPWL_image_to_j2k JPWL_j2k_to_image.o JPWL_image_to_j2k.o
+
+clean: cleanlib cleancodec
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/README.txt.svn-base ./jpwl/.svn/text-base/README.txt.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/README.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/README.txt.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,136 @@
+===============================================================================
+	JPEG2000 Part 11 (ISO/IEC 15444-11 JPWL) Software
+
+
+
+		Version 20061213
+===============================================================================
+
+
+
+
+
+1. Scope
+=============
+
+This document describes the installation and use of the JPWL module in the framework of OpenJPEG library.
+
+This implementation has been developed from OpenJPEG implementation of JPEG2000 standard, and for this reason it is written in C language.
+
+If you find some bugs or if you have problems using the encoder/decoder, please send an e-mail to jpwl@diei.unipg.it
+
+
+2. Installing the code
+==========================
+
+The JPWL code is integrated with the standard OpenJPEG library and codecs: it is activated by setting the macro USE_JPWL to defined in the preprocessor configuration options of your preferred C compiler.
+
+2.1. Compiling the source code in Windows
+-------------------------------------------
+
+The "jpwl" directory is already populated with a couple of Visual C++ 6.0 workspaces
+
+ * JPWL_image_to_j2k.dsw - Creates the encoder with JPWL functionalities
+ * JPWL_j2k_to_image.dsw - Creates the decoder with JPWL functionalities
+
+2.2. Compiling the source code in Unix-like systems
+-----------------------------------------------------
+
+Under linux, enter the jpwl directory and type "make clean" and "make".
+
+
+3. Running the JPWL software
+=========================
+
+The options available at the command line are exactly the same of the base OpenJPEG codecs. In addition, there is a "-W" switch that activates JPWL functionalities.
+
+3.1. JPWL Encoder
+-------------------
+
+-W           : adoption of JPWL (Part 11) capabilities (-W params)
+               The parameters can be written and repeated in any order:
+               [h<tile><=type>,s<tile><=method>,a=<addr>,z=<size>,g=<range>,...
+                ...,p<tile:pack><=type>]
+
+                 h selects the header error protection (EPB): 'type' can be
+                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]
+                   if 'tile' is absent, it applies to main and tile headers
+                   if 'tile' is present, it applies from that tile
+                     onwards, up to the next h<tile> spec, or to the last tile
+                     in the codestream (max. 16 specs)
+
+                 p selects the packet error protection (EEP/UEP with EPBs)
+                  to be applied to raw data: 'type' can be
+                   [0=none 1,absent=predefined 16=CRC-16 32=CRC-32 37-128=RS]
+                   if 'tile:pack' is absent, it starts from tile 0, packet 0
+                   if 'tile:pack' is present, it applies from that tile
+                     and that packet onwards, up to the next packet spec
+                     or to the last packet in the last tile in the codestream
+                     (max. 16 specs)
+
+                 s enables sensitivity data insertion (ESD): 'method' can be
+                   [-1=NO ESD 0=RELATIVE ERROR 1=MSE 2=MSE REDUCTION 3=PSNR
+                    4=PSNR INCREMENT 5=MAXERR 6=TSE 7=RESERVED]
+                   if 'tile' is absent, it applies to main header only
+                   if 'tile' is present, it applies from that tile
+                     onwards, up to the next s<tile> spec, or to the last tile
+                     in the codestream (max. 16 specs)
+
+                 g determines the addressing mode: <range> can be
+                   [0=PACKET 1=BYTE RANGE 2=PACKET RANGE]
+
+                 a determines the size of data addressing: <addr> can be
+                   2/4 bytes (small/large codestreams). If not set, auto-mode
+
+                 z determines the size of sensitivity values: <size> can be
+                   1/2 bytes, for the transformed pseudo-floating point value
+
+                 ex.:
+ h,h0=64,h3=16,h5=32,p0=78,p0:24=56,p1,p3:0=0,p3:20=32,s=0,s0=6,s3=-1,a=0,g=1,z=1
+                 means
+                   predefined EPB in MH, rs(64,32) from TPH 0 to TPH 2,
+                   CRC-16 in TPH 3 and TPH 4, CRC-32 in remaining TPHs,
+                   UEP rs(78,32) for packets 0 to 23 of tile 0,
+                   UEP rs(56,32) for packets 24 to the last of tile 0,
+                   UEP rs default for packets of tile 1,
+                   no UEP for packets 0 to 19 of tile 3,
+                   UEP CRC-32 for packets 20 of tile 3 to last tile,
+                   relative sensitivity ESD for MH,
+                   TSE ESD from TPH 0 to TPH 2, byte range with automatic
+                   size of addresses and 1 byte for each sensitivity value
+
+                 ex.:
+                       h,s,p
+                 means
+                   default protection to headers (MH and TPHs) as well as
+                   data packets, one ESD in MH
+
+                 N.B.: use the following recommendations when specifying
+                       the JPWL parameters list
+                   - when you use UEP, always pair the 'p' option with 'h'
+
+3.2. JPWL Decoder
+-------------------
+
+  -W <options>
+    Activates the JPWL correction capability, if the codestream complies.
+    Options can be a comma separated list of <param=val> tokens:
+    c, c=numcomps
+       numcomps is the number of expected components in the codestream
+       (search of first EPB rely upon this, default is 3)
+
+
+4. Known bugs and limitations
+===============================
+
+4.1. Bugs
+-----------
+
+* It is not possible to save a JPWL encoded codestream using the wrapped file format (i.e. JP2): only raw file format (i.e. J2K) is working
+
+4.2. Limitations
+------------------
+
+* When specifying an UEP protection, you need to activate even TPH protection for those tiles where there is a protection of the packets
+* RED insertion is not currently implemented at the decoder
+* JPWL at entropy coding level is not implemented
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/rs.c.svn-base ./jpwl/.svn/text-base/rs.c.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/rs.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/rs.c.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,594 @@
+ /*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef USE_JPWL
+
+/**
+@file rs.c
+@brief Functions used to compute the Reed-Solomon parity and check of byte arrays
+
+*/
+
+/**
+ * Reed-Solomon coding and decoding
+ * Phil Karn (karn@ka9q.ampr.org) September 1996
+ * 
+ * This file is derived from the program "new_rs_erasures.c" by Robert
+ * Morelos-Zaragoza (robert@spectra.eng.hawaii.edu) and Hari Thirumoorthy
+ * (harit@spectra.eng.hawaii.edu), Aug 1995
+ *
+ * I've made changes to improve performance, clean up the code and make it
+ * easier to follow. Data is now passed to the encoding and decoding functions
+ * through arguments rather than in global arrays. The decode function returns
+ * the number of corrected symbols, or -1 if the word is uncorrectable.
+ *
+ * This code supports a symbol size from 2 bits up to 16 bits,
+ * implying a block size of 3 2-bit symbols (6 bits) up to 65535
+ * 16-bit symbols (1,048,560 bits). The code parameters are set in rs.h.
+ *
+ * Note that if symbols larger than 8 bits are used, the type of each
+ * data array element switches from unsigned char to unsigned int. The
+ * caller must ensure that elements larger than the symbol range are
+ * not passed to the encoder or decoder.
+ *
+ */
+#include <stdio.h>
+#include <stdlib.h>
+#include "rs.h"
+
+/* This defines the type used to store an element of the Galois Field
+ * used by the code. Make sure this is something larger than a char if
+ * if anything larger than GF(256) is used.
+ *
+ * Note: unsigned char will work up to GF(256) but int seems to run
+ * faster on the Pentium.
+ */
+typedef int gf;
+
+/* Primitive polynomials - see Lin & Costello, Appendix A,
+ * and  Lee & Messerschmitt, p. 453.
+ */
+#if(MM == 2)/* Admittedly silly */
+int Pp[MM+1] = { 1, 1, 1 };
+
+#elif(MM == 3)
+/* 1 + x + x^3 */
+int Pp[MM+1] = { 1, 1, 0, 1 };
+
+#elif(MM == 4)
+/* 1 + x + x^4 */
+int Pp[MM+1] = { 1, 1, 0, 0, 1 };
+
+#elif(MM == 5)
+/* 1 + x^2 + x^5 */
+int Pp[MM+1] = { 1, 0, 1, 0, 0, 1 };
+
+#elif(MM == 6)
+/* 1 + x + x^6 */
+int Pp[MM+1] = { 1, 1, 0, 0, 0, 0, 1 };
+
+#elif(MM == 7)
+/* 1 + x^3 + x^7 */
+int Pp[MM+1] = { 1, 0, 0, 1, 0, 0, 0, 1 };
+
+#elif(MM == 8)
+/* 1+x^2+x^3+x^4+x^8 */
+int Pp[MM+1] = { 1, 0, 1, 1, 1, 0, 0, 0, 1 };
+
+#elif(MM == 9)
+/* 1+x^4+x^9 */
+int Pp[MM+1] = { 1, 0, 0, 0, 1, 0, 0, 0, 0, 1 };
+
+#elif(MM == 10)
+/* 1+x^3+x^10 */
+int Pp[MM+1] = { 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1 };
+
+#elif(MM == 11)
+/* 1+x^2+x^11 */
+int Pp[MM+1] = { 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+#elif(MM == 12)
+/* 1+x+x^4+x^6+x^12 */
+int Pp[MM+1] = { 1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1 };
+
+#elif(MM == 13)
+/* 1+x+x^3+x^4+x^13 */
+int Pp[MM+1] = { 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+#elif(MM == 14)
+/* 1+x+x^6+x^10+x^14 */
+int Pp[MM+1] = { 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1 };
+
+#elif(MM == 15)
+/* 1+x+x^15 */
+int Pp[MM+1] = { 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1 };
+
+#elif(MM == 16)
+/* 1+x+x^3+x^12+x^16 */
+int Pp[MM+1] = { 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1 };
+
+#else
+#error "MM must be in range 2-16"
+#endif
+
+/* Alpha exponent for the first root of the generator polynomial */
+#define B0	0  /* Different from the default 1 */
+
+/* index->polynomial form conversion table */
+gf Alpha_to[NN + 1];
+
+/* Polynomial->index form conversion table */
+gf Index_of[NN + 1];
+
+/* No legal value in index form represents zero, so
+ * we need a special value for this purpose
+ */
+#define A0	(NN)
+
+/* Generator polynomial g(x)
+ * Degree of g(x) = 2*TT
+ * has roots @**B0, @**(B0+1), ... ,@^(B0+2*TT-1)
+ */
+/*gf Gg[NN - KK + 1];*/
+gf		Gg[NN - 1];
+
+/* Compute x % NN, where NN is 2**MM - 1,
+ * without a slow divide
+ */
+static /*inline*/ gf
+modnn(int x)
+{
+	while (x >= NN) {
+		x -= NN;
+		x = (x >> MM) + (x & NN);
+	}
+	return x;
+}
+
+/*#define	min(a,b)	((a) < (b) ? (a) : (b))*/
+
+#define	CLEAR(a,n) {\
+	int ci;\
+	for(ci=(n)-1;ci >=0;ci--)\
+		(a)[ci] = 0;\
+	}
+
+#define	COPY(a,b,n) {\
+	int ci;\
+	for(ci=(n)-1;ci >=0;ci--)\
+		(a)[ci] = (b)[ci];\
+	}
+#define	COPYDOWN(a,b,n) {\
+	int ci;\
+	for(ci=(n)-1;ci >=0;ci--)\
+		(a)[ci] = (b)[ci];\
+	}
+
+void init_rs(int k)
+{
+	KK = k;
+	if (KK >= NN) {
+		printf("KK must be less than 2**MM - 1\n");
+		exit(1);
+	}
+	
+	generate_gf();
+	gen_poly();
+}
+
+/* generate GF(2**m) from the irreducible polynomial p(X) in p[0]..p[m]
+   lookup tables:  index->polynomial form   alpha_to[] contains j=alpha**i;
+                   polynomial form -> index form  index_of[j=alpha**i] = i
+   alpha=2 is the primitive element of GF(2**m)
+   HARI's COMMENT: (4/13/94) alpha_to[] can be used as follows:
+        Let @ represent the primitive element commonly called "alpha" that
+   is the root of the primitive polynomial p(x). Then in GF(2^m), for any
+   0 <= i <= 2^m-2,
+        @^i = a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)
+   where the binary vector (a(0),a(1),a(2),...,a(m-1)) is the representation
+   of the integer "alpha_to[i]" with a(0) being the LSB and a(m-1) the MSB. Thus for
+   example the polynomial representation of @^5 would be given by the binary
+   representation of the integer "alpha_to[5]".
+                   Similarily, index_of[] can be used as follows:
+        As above, let @ represent the primitive element of GF(2^m) that is
+   the root of the primitive polynomial p(x). In order to find the power
+   of @ (alpha) that has the polynomial representation
+        a(0) + a(1) @ + a(2) @^2 + ... + a(m-1) @^(m-1)
+   we consider the integer "i" whose binary representation with a(0) being LSB
+   and a(m-1) MSB is (a(0),a(1),...,a(m-1)) and locate the entry
+   "index_of[i]". Now, @^index_of[i] is that element whose polynomial 
+    representation is (a(0),a(1),a(2),...,a(m-1)).
+   NOTE:
+        The element alpha_to[2^m-1] = 0 always signifying that the
+   representation of "@^infinity" = 0 is (0,0,0,...,0).
+        Similarily, the element index_of[0] = A0 always signifying
+   that the power of alpha which has the polynomial representation
+   (0,0,...,0) is "infinity".
+ 
+*/
+
+void
+generate_gf(void)
+{
+	register int i, mask;
+
+	mask = 1;
+	Alpha_to[MM] = 0;
+	for (i = 0; i < MM; i++) {
+		Alpha_to[i] = mask;
+		Index_of[Alpha_to[i]] = i;
+		/* If Pp[i] == 1 then, term @^i occurs in poly-repr of @^MM */
+		if (Pp[i] != 0)
+			Alpha_to[MM] ^= mask;	/* Bit-wise EXOR operation */
+		mask <<= 1;	/* single left-shift */
+	}
+	Index_of[Alpha_to[MM]] = MM;
+	/*
+	 * Have obtained poly-repr of @^MM. Poly-repr of @^(i+1) is given by
+	 * poly-repr of @^i shifted left one-bit and accounting for any @^MM
+	 * term that may occur when poly-repr of @^i is shifted.
+	 */
+	mask >>= 1;
+	for (i = MM + 1; i < NN; i++) {
+		if (Alpha_to[i - 1] >= mask)
+			Alpha_to[i] = Alpha_to[MM] ^ ((Alpha_to[i - 1] ^ mask) << 1);
+		else
+			Alpha_to[i] = Alpha_to[i - 1] << 1;
+		Index_of[Alpha_to[i]] = i;
+	}
+	Index_of[0] = A0;
+	Alpha_to[NN] = 0;
+}
+
+
+/*
+ * Obtain the generator polynomial of the TT-error correcting, length
+ * NN=(2**MM -1) Reed Solomon code from the product of (X+@**(B0+i)), i = 0,
+ * ... ,(2*TT-1)
+ *
+ * Examples:
+ *
+ * If B0 = 1, TT = 1. deg(g(x)) = 2*TT = 2.
+ * g(x) = (x+@) (x+@**2)
+ *
+ * If B0 = 0, TT = 2. deg(g(x)) = 2*TT = 4.
+ * g(x) = (x+1) (x+@) (x+@**2) (x+@**3)
+ */
+void
+gen_poly(void)
+{
+	register int i, j;
+
+	Gg[0] = Alpha_to[B0];
+	Gg[1] = 1;		/* g(x) = (X+@**B0) initially */
+	for (i = 2; i <= NN - KK; i++) {
+		Gg[i] = 1;
+		/*
+		 * Below multiply (Gg[0]+Gg[1]*x + ... +Gg[i]x^i) by
+		 * (@**(B0+i-1) + x)
+		 */
+		for (j = i - 1; j > 0; j--)
+			if (Gg[j] != 0)
+				Gg[j] = Gg[j - 1] ^ Alpha_to[modnn((Index_of[Gg[j]]) + B0 + i - 1)];
+			else
+				Gg[j] = Gg[j - 1];
+		/* Gg[0] can never be zero */
+		Gg[0] = Alpha_to[modnn((Index_of[Gg[0]]) + B0 + i - 1)];
+	}
+	/* convert Gg[] to index form for quicker encoding */
+	for (i = 0; i <= NN - KK; i++)
+		Gg[i] = Index_of[Gg[i]];
+}
+
+
+/*
+ * take the string of symbols in data[i], i=0..(k-1) and encode
+ * systematically to produce NN-KK parity symbols in bb[0]..bb[NN-KK-1] data[]
+ * is input and bb[] is output in polynomial form. Encoding is done by using
+ * a feedback shift register with appropriate connections specified by the
+ * elements of Gg[], which was generated above. Codeword is   c(X) =
+ * data(X)*X**(NN-KK)+ b(X)
+ */
+int
+encode_rs(dtype *data, dtype *bb)
+{
+	register int i, j;
+	gf feedback;
+
+	CLEAR(bb,NN-KK);
+	for (i = KK - 1; i >= 0; i--) {
+#if (MM != 8)
+		if(data[i] > NN)
+			return -1;	/* Illegal symbol */
+#endif
+		feedback = Index_of[data[i] ^ bb[NN - KK - 1]];
+		if (feedback != A0) {	/* feedback term is non-zero */
+			for (j = NN - KK - 1; j > 0; j--)
+				if (Gg[j] != A0)
+					bb[j] = bb[j - 1] ^ Alpha_to[modnn(Gg[j] + feedback)];
+				else
+					bb[j] = bb[j - 1];
+			bb[0] = Alpha_to[modnn(Gg[0] + feedback)];
+		} else {	/* feedback term is zero. encoder becomes a
+				 * single-byte shifter */
+			for (j = NN - KK - 1; j > 0; j--)
+				bb[j] = bb[j - 1];
+			bb[0] = 0;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Performs ERRORS+ERASURES decoding of RS codes. If decoding is successful,
+ * writes the codeword into data[] itself. Otherwise data[] is unaltered.
+ *
+ * Return number of symbols corrected, or -1 if codeword is illegal
+ * or uncorrectable.
+ * 
+ * First "no_eras" erasures are declared by the calling program. Then, the
+ * maximum # of errors correctable is t_after_eras = floor((NN-KK-no_eras)/2).
+ * If the number of channel errors is not greater than "t_after_eras" the
+ * transmitted codeword will be recovered. Details of algorithm can be found
+ * in R. Blahut's "Theory ... of Error-Correcting Codes".
+ */
+int
+eras_dec_rs(dtype *data, int *eras_pos, int no_eras)
+{
+	int deg_lambda, el, deg_omega;
+	int i, j, r;
+	gf u,q,tmp,num1,num2,den,discr_r;
+	gf recd[NN];
+	/* Err+Eras Locator poly and syndrome poly */
+	/*gf lambda[NN-KK + 1], s[NN-KK + 1];	
+	gf b[NN-KK + 1], t[NN-KK + 1], omega[NN-KK + 1];
+	gf root[NN-KK], reg[NN-KK + 1], loc[NN-KK];*/
+	gf lambda[NN + 1], s[NN + 1];	
+	gf b[NN + 1], t[NN + 1], omega[NN + 1];
+	gf root[NN], reg[NN + 1], loc[NN];
+	int syn_error, count;
+
+	/* data[] is in polynomial form, copy and convert to index form */
+	for (i = NN-1; i >= 0; i--){
+#if (MM != 8)
+		if(data[i] > NN)
+			return -1;	/* Illegal symbol */
+#endif
+		recd[i] = Index_of[data[i]];
+	}
+	/* first form the syndromes; i.e., evaluate recd(x) at roots of g(x)
+	 * namely @**(B0+i), i = 0, ... ,(NN-KK-1)
+	 */
+	syn_error = 0;
+	for (i = 1; i <= NN-KK; i++) {
+		tmp = 0;
+		for (j = 0; j < NN; j++)
+			if (recd[j] != A0)	/* recd[j] in index form */
+				tmp ^= Alpha_to[modnn(recd[j] + (B0+i-1)*j)];
+		syn_error |= tmp;	/* set flag if non-zero syndrome =>
+					 * error */
+		/* store syndrome in index form  */
+		s[i] = Index_of[tmp];
+	}
+	if (!syn_error) {
+		/*
+		 * if syndrome is zero, data[] is a codeword and there are no
+		 * errors to correct. So return data[] unmodified
+		 */
+		return 0;
+	}
+	CLEAR(&lambda[1],NN-KK);
+	lambda[0] = 1;
+	if (no_eras > 0) {
+		/* Init lambda to be the erasure locator polynomial */
+		lambda[1] = Alpha_to[eras_pos[0]];
+		for (i = 1; i < no_eras; i++) {
+			u = eras_pos[i];
+			for (j = i+1; j > 0; j--) {
+				tmp = Index_of[lambda[j - 1]];
+				if(tmp != A0)
+					lambda[j] ^= Alpha_to[modnn(u + tmp)];
+			}
+		}
+#ifdef ERASURE_DEBUG
+		/* find roots of the erasure location polynomial */
+		for(i=1;i<=no_eras;i++)
+			reg[i] = Index_of[lambda[i]];
+		count = 0;
+		for (i = 1; i <= NN; i++) {
+			q = 1;
+			for (j = 1; j <= no_eras; j++)
+				if (reg[j] != A0) {
+					reg[j] = modnn(reg[j] + j);
+					q ^= Alpha_to[reg[j]];
+				}
+			if (!q) {
+				/* store root and error location
+				 * number indices
+				 */
+				root[count] = i;
+				loc[count] = NN - i;
+				count++;
+			}
+		}
+		if (count != no_eras) {
+			printf("\n lambda(x) is WRONG\n");
+			return -1;
+		}
+#ifndef NO_PRINT
+		printf("\n Erasure positions as determined by roots of Eras Loc Poly:\n");
+		for (i = 0; i < count; i++)
+			printf("%d ", loc[i]);
+		printf("\n");
+#endif
+#endif
+	}
+	for(i=0;i<NN-KK+1;i++)
+		b[i] = Index_of[lambda[i]];
+
+	/*
+	 * Begin Berlekamp-Massey algorithm to determine error+erasure
+	 * locator polynomial
+	 */
+	r = no_eras;
+	el = no_eras;
+	while (++r <= NN-KK) {	/* r is the step number */
+		/* Compute discrepancy at the r-th step in poly-form */
+		discr_r = 0;
+		for (i = 0; i < r; i++){
+			if ((lambda[i] != 0) && (s[r - i] != A0)) {
+				discr_r ^= Alpha_to[modnn(Index_of[lambda[i]] + s[r - i])];
+			}
+		}
+		discr_r = Index_of[discr_r];	/* Index form */
+		if (discr_r == A0) {
+			/* 2 lines below: B(x) <-- x*B(x) */
+			COPYDOWN(&b[1],b,NN-KK);
+			b[0] = A0;
+		} else {
+			/* 7 lines below: T(x) <-- lambda(x) - discr_r*x*b(x) */
+			t[0] = lambda[0];
+			for (i = 0 ; i < NN-KK; i++) {
+				if(b[i] != A0)
+					t[i+1] = lambda[i+1] ^ Alpha_to[modnn(discr_r + b[i])];
+				else
+					t[i+1] = lambda[i+1];
+			}
+			if (2 * el <= r + no_eras - 1) {
+				el = r + no_eras - el;
+				/*
+				 * 2 lines below: B(x) <-- inv(discr_r) *
+				 * lambda(x)
+				 */
+				for (i = 0; i <= NN-KK; i++)
+					b[i] = (lambda[i] == 0) ? A0 : modnn(Index_of[lambda[i]] - discr_r + NN);
+			} else {
+				/* 2 lines below: B(x) <-- x*B(x) */
+				COPYDOWN(&b[1],b,NN-KK);
+				b[0] = A0;
+			}
+			COPY(lambda,t,NN-KK+1);
+		}
+	}
+
+	/* Convert lambda to index form and compute deg(lambda(x)) */
+	deg_lambda = 0;
+	for(i=0;i<NN-KK+1;i++){
+		lambda[i] = Index_of[lambda[i]];
+		if(lambda[i] != A0)
+			deg_lambda = i;
+	}
+	/*
+	 * Find roots of the error+erasure locator polynomial. By Chien
+	 * Search
+	 */
+	COPY(&reg[1],&lambda[1],NN-KK);
+	count = 0;		/* Number of roots of lambda(x) */
+	for (i = 1; i <= NN; i++) {
+		q = 1;
+		for (j = deg_lambda; j > 0; j--)
+			if (reg[j] != A0) {
+				reg[j] = modnn(reg[j] + j);
+				q ^= Alpha_to[reg[j]];
+			}
+		if (!q) {
+			/* store root (index-form) and error location number */
+			root[count] = i;
+			loc[count] = NN - i;
+			count++;
+		}
+	}
+
+#ifdef DEBUG
+	printf("\n Final error positions:\t");
+	for (i = 0; i < count; i++)
+		printf("%d ", loc[i]);
+	printf("\n");
+#endif
+	if (deg_lambda != count) {
+		/*
+		 * deg(lambda) unequal to number of roots => uncorrectable
+		 * error detected
+		 */
+		return -1;
+	}
+	/*
+	 * Compute err+eras evaluator poly omega(x) = s(x)*lambda(x) (modulo
+	 * x**(NN-KK)). in index form. Also find deg(omega).
+	 */
+	deg_omega = 0;
+	for (i = 0; i < NN-KK;i++){
+		tmp = 0;
+		j = (deg_lambda < i) ? deg_lambda : i;
+		for(;j >= 0; j--){
+			if ((s[i + 1 - j] != A0) && (lambda[j] != A0))
+				tmp ^= Alpha_to[modnn(s[i + 1 - j] + lambda[j])];
+		}
+		if(tmp != 0)
+			deg_omega = i;
+		omega[i] = Index_of[tmp];
+	}
+	omega[NN-KK] = A0;
+
+	/*
+	 * Compute error values in poly-form. num1 = omega(inv(X(l))), num2 =
+	 * inv(X(l))**(B0-1) and den = lambda_pr(inv(X(l))) all in poly-form
+	 */
+	for (j = count-1; j >=0; j--) {
+		num1 = 0;
+		for (i = deg_omega; i >= 0; i--) {
+			if (omega[i] != A0)
+				num1  ^= Alpha_to[modnn(omega[i] + i * root[j])];
+		}
+		num2 = Alpha_to[modnn(root[j] * (B0 - 1) + NN)];
+		den = 0;
+
+		/* lambda[i+1] for i even is the formal derivative lambda_pr of lambda[i] */
+		for (i = min(deg_lambda,NN-KK-1) & ~1; i >= 0; i -=2) {
+			if(lambda[i+1] != A0)
+				den ^= Alpha_to[modnn(lambda[i+1] + i * root[j])];
+		}
+		if (den == 0) {
+#ifdef DEBUG
+			printf("\n ERROR: denominator = 0\n");
+#endif
+			return -1;
+		}
+		/* Apply error to data */
+		if (num1 != 0) {
+			data[loc[j]] ^= Alpha_to[modnn(Index_of[num1] + Index_of[num2] + NN - Index_of[den])];
+		}
+	}
+	return count;
+}
+
+
+#endif /* USE_JPWL */
diff -urN /home/robin/sldeb/trunk/jpwl/.svn/text-base/rs.h.svn-base ./jpwl/.svn/text-base/rs.h.svn-base
--- /home/robin/sldeb/trunk/jpwl/.svn/text-base/rs.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./jpwl/.svn/text-base/rs.h.svn-base	2007-09-28 11:33:51.000000000 +0100
@@ -0,0 +1,110 @@
+/*
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2005, Francois Devaux and Antonin Descampe
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2002-2005, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+ * Copyright (c) 2005-2006, Dept. of Electronic and Information Engineering, Universita' degli Studi di Perugia, Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef USE_JPWL
+
+/**
+@file rs.h
+@brief Functions used to compute Reed-Solomon parity and check of byte arrays
+
+*/
+
+#ifndef __RS_HEADER__
+#define __RS_HEADER__
+
+/** Global definitions for Reed-Solomon encoder/decoder
+ * Phil Karn KA9Q, September 1996
+ *
+ * The parameters MM and KK specify the Reed-Solomon code parameters.
+ *
+ * Set MM to be the size of each code symbol in bits. The Reed-Solomon
+ * block size will then be NN = 2**M - 1 symbols. Supported values are
+ * defined in rs.c.
+ *
+ * Set KK to be the number of data symbols in each block, which must be
+ * less than the block size. The code will then be able to correct up
+ * to NN-KK erasures or (NN-KK)/2 errors, or combinations thereof with
+ * each error counting as two erasures.
+ */
+#define MM  8		/* RS code over GF(2**MM) - change to suit */
+static int	KK;
+
+/* Original code */
+/*#define KK  239*/		/* KK = number of information symbols */
+
+#define	NN ((1 << MM) - 1)
+
+#if (MM <= 8)
+typedef unsigned char dtype;
+#else
+typedef unsigned int dtype;
+#endif
+
+/** Initialization function */
+void init_rs(int);
+
+/** These two functions *must* be called in this order (e.g.,
+ * by init_rs()) before any encoding/decoding
+ */
+void generate_gf(void);	/* Generate Galois Field */
+void gen_poly(void);	/* Generate generator polynomial */
+
+/** Reed-Solomon encoding
+ * data[] is the input block, parity symbols are placed in bb[]
+ * bb[] may lie past the end of the data, e.g., for (255,223):
+ *	encode_rs(&data[0],&data[223]);
+ */
+int encode_rs(dtype data[], dtype bb[]);
+
+/** Reed-Solomon erasures-and-errors decoding
+ * The received block goes into data[], and a list of zero-origin
+ * erasure positions, if any, goes in eras_pos[] with a count in no_eras.
+ *
+ * The decoder corrects the symbols in place, if possible and returns
+ * the number of corrected symbols. If the codeword is illegal or
+ * uncorrectible, the data array is unchanged and -1 is returned
+ */
+int eras_dec_rs(dtype data[], int eras_pos[], int no_eras);
+
+/**
+Computes the minimum between two integers
+@param a first integer to compare
+@param b second integer to compare
+@return returns the minimum integer between a and b
+*/
+#ifndef min
+#define min(a,b)    (((a) < (b)) ? (a) : (b))
+#endif /* min */
+
+#endif /* __RS_HEADER__ */
+
+
+#endif /* USE_JPWL */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/bio.c ./libopenjpeg/bio.c
--- /home/robin/sldeb/trunk/libopenjpeg/bio.c	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/bio.c	2007-09-28 11:33:44.000000000 +0100
@@ -114,7 +114,7 @@
 ==========================================================
 */
 
-opj_bio_t* bio_create() {
+opj_bio_t* bio_create(void) {
 	opj_bio_t *bio = (opj_bio_t*)opj_malloc(sizeof(opj_bio_t));
 	return bio;
 }
diff -urN /home/robin/sldeb/trunk/libopenjpeg/bio.h ./libopenjpeg/bio.h
--- /home/robin/sldeb/trunk/libopenjpeg/bio.h	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/bio.h	2007-09-28 11:33:44.000000000 +0100
@@ -64,7 +64,7 @@
 Create a new BIO handle 
 @return Returns a new BIO handle if successful, returns NULL otherwise
 */
-opj_bio_t* bio_create();
+opj_bio_t* bio_create(void);
 /**
 Destroy a previously created BIO handle
 @param bio BIO handle to destroy
diff -urN /home/robin/sldeb/trunk/libopenjpeg/cio.c ./libopenjpeg/cio.c
--- /home/robin/sldeb/trunk/libopenjpeg/cio.c	2007-03-07 16:04:33.000000000 +0000
+++ ./libopenjpeg/cio.c	2007-09-28 11:33:44.000000000 +0100
@@ -58,9 +58,10 @@
 				opj_free(cio);
 				return NULL;
 		}
-		cio->length = (int) (1.3 * cp->img_size);
+		cio->length = (unsigned int) (0.1625 * cp->img_size + 2000); /* 0.1625 = 1.3/8 and 2000 bytes as a minimum for headers */
 		cio->buffer = (unsigned char *)opj_malloc(cio->length);
 		if(!cio->buffer) {
+			opj_event_msg(cio->cinfo, EVT_ERROR, "Error allocating memory for compressed bitstream\n");
 			opj_free(cio);
 			return NULL;
 		}
@@ -139,7 +140,7 @@
  */
 unsigned char cio_bytein(opj_cio_t *cio) {
 	if (cio->bp >= cio->end) {
-		opj_event_msg(cio->cinfo, EVT_ERROR, "read error\n");
+		opj_event_msg(cio->cinfo, EVT_ERROR, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n", cio->start, cio->bp, cio->end);
 		return 0;
 	}
 	return *cio->bp++;
diff -urN /home/robin/sldeb/trunk/libopenjpeg/CMakeLists.txt ./libopenjpeg/CMakeLists.txt
--- /home/robin/sldeb/trunk/libopenjpeg/CMakeLists.txt	2006-07-22 04:47:02.000000000 +0100
+++ ./libopenjpeg/CMakeLists.txt	2007-09-28 11:33:44.000000000 +0100
@@ -32,9 +32,13 @@
 
 # Create the library
 ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+SET_TARGET_PROPERTIES(${OPENJPEG_LIBRARY_NAME} PROPERTIES
+	${OPENJPEG_LIBRARY_PROPERTIES})
 
 # Install library
-INSTALL_TARGETS(/lib/ ${OPENJPEG_LIBRARY_NAME})
+INSTALL(TARGETS ${OPENJPEG_LIBRARY_NAME}
+	DESTINATION lib)
 
 # Install includes files
-INSTALL_FILES(/include .h)
+INSTALL(FILES openjpeg.h
+	DESTINATION ${INCLUDE_INSTALL_DIR}/openjpeg)
diff -urN /home/robin/sldeb/trunk/libopenjpeg/dwt.c ./libopenjpeg/dwt.c
--- /home/robin/sldeb/trunk/libopenjpeg/dwt.c	2007-04-05 15:24:19.000000000 +0100
+++ ./libopenjpeg/dwt.c	2007-11-27 22:39:50.000000000 +0000
@@ -5,6 +5,8 @@
  * Copyright (c) 2002-2003, Yannick Verschueren
  * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
  * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Jonathan Ballard <dzonatas@dzonux.net>
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -29,6 +31,9 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
+#ifdef __SSE__
+#include <xmmintrin.h>
+#endif
 
 #include "opj_includes.h"
 
@@ -41,12 +46,32 @@
 /** @name Local data structures */
 /*@{*/
 
-typedef struct dwt_local{
-	int *	mem ;
+typedef struct dwt_local {
+	int* mem;
+	int dn;
+	int sn;
+	int cas;
+} dwt_t;
+
+typedef union {
+	float	f[4];
+} v4;
+
+typedef struct v4dwt_local {
+	v4*	wavelet ;
 	int		dn ;
 	int		sn ;
 	int		cas ;
-	} dwt_t ; 
+} v4dwt_t ;
+
+static const float alpha =  1.586134342f; //  12994
+static const float beta  =  0.052980118f; //    434
+static const float gamma = -0.882911075f; //  -7233
+static const float delta = -0.443506852f; //  -3633
+
+static const float K      = 1.230174105f; //  10078
+/* FIXME: What is this constant? */
+static const float c13318 = 1.625732422f;
 
 /*@}*/
 
@@ -75,11 +100,11 @@
 */
 static void dwt_interleave_v(dwt_t* v, int *a, int x);
 /**
-Forward 5-3 wavelet tranform in 1-D
+Forward 5-3 wavelet transform in 1-D
 */
 static void dwt_encode_1(int *a, int dn, int sn, int cas);
 /**
-Inverse 5-3 wavelet tranform in 1-D
+Inverse 5-3 wavelet transform in 1-D
 */
 static void dwt_decode_1(dwt_t *v);
 /**
@@ -87,17 +112,13 @@
 */
 static void dwt_encode_1_real(int *a, int dn, int sn, int cas);
 /**
-Inverse 9-7 wavelet transform in 1-D
-*/
-static void dwt_decode_1_real(dwt_t *v);
-/**
-FIXME : comment ???
+Explicit calculation of the Quantization Stepsizes 
 */
 static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
 /**
-Inverse wavelet tranform in 2-D.
+Inverse wavelet transform in 2-D.
 */
-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop , DWT1DFN fn);
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
 
 /*@}*/
 
@@ -199,7 +220,7 @@
 
 
 /* <summary>                            */
-/* Forward 5-3 wavelet tranform in 1-D. */
+/* Forward 5-3 wavelet transform in 1-D. */
 /* </summary>                           */
 static void dwt_encode_1(int *a, int dn, int sn, int cas) {
 	int i;
@@ -220,7 +241,7 @@
 }
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 1-D. */
+/* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
 static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
 	int i;
@@ -241,7 +262,7 @@
 }
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 1-D. */
+/* Inverse 5-3 wavelet transform in 1-D. */
 /* </summary>                           */ 
 static void dwt_decode_1(dwt_t *v) {
 	dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
@@ -285,102 +306,6 @@
 	}
 }
 
-static void dwt_decode_sm(dwt_t* v, int k, int n, int x) {
-	int m = k > n ? n : k;
-	int l = v->mem[1];			//D(0);
-	int j;
-	int i;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WS(i) -= fix_mul( ( l = WD(i) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WS(i) -= l;
-	}
-}
-
-static void dwt_decode_sp(dwt_t* v, int k, int n, int x) {
-	int m = k > n ? n : k;
-	int l = v->mem[1];			//D(0);
-	int j;
-	int i;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WS(i) += fix_mul( ( l = WD(i) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WS(i) += l;
-	}
-}
-
-static void dwt_decode_dm(dwt_t* v, int k, int n, int x) {
-	int m = k >= n ? n-1 : k;
-	int l = v->mem[0];				//S(0);
-	int i;
-	int j;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WD(i) -=  fix_mul( ( l = WS(i+1) ) + j , x);
-	}
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WD(i) -= l;
-	}
-}
-
-static void dwt_decode_dp(dwt_t* v, int k, int n, int x) {
-	int m = k >= n ? n-1 : k;
-	int l = v->mem[0];				//S(0);
-	int i;
-	int j;
-	for (i = 0; i < m; i++) {
-		j = l;
-		WD(i) +=  fix_mul( ( l = WS(i+1) ) + j , x);
-	}
-
-	if( i < k ) {
-		l = fix_mul( l + l , x );
-		for (; i < k; i++)
-			WD(i) += l;
-	}
-}
-
-
-/* <summary>                             */
-/* Inverse 9-7 wavelet transform in 1-D. */
-/* </summary>                            */
-static void dwt_decode_1_real(dwt_t* v) {
-	int i;
-	if (!v->cas) {
-		if ((v->dn > 0) || (v->sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < v->sn; i++)
-				WS(i) = fix_mul(WS(i), 10078);	/* 10076 */
-			for (i = 0; i < v->dn; i++)
-				WD(i) = fix_mul(WD(i), 13318);	/* 13320 */
-			dwt_decode_sm(v, v->sn, v->dn, 3633);
-			dwt_decode_dm(v, v->dn, v->sn, 7233);
-			dwt_decode_sp(v, v->sn, v->dn, 434);
-			dwt_decode_dp(v, v->dn, v->sn, 12994);
-		}
-	} else {
-		if ((v->sn > 0) || (v->dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
-			for (i = 0; i < v->sn; i++)
-				WD(i) = fix_mul(WD(i), 10078);	/* 10076 */
-			for (i = 0; i < v->dn; i++)
-				WS(i) = fix_mul(WS(i), 13318);	/* 13320 */
-			dwt_decode_dm(v, v->sn, v->dn, 3633);
-			dwt_decode_sm(v, v->dn, v->sn, 7233);
-			dwt_decode_dp(v, v->sn, v->dn, 434);
-			dwt_decode_sp(v, v->dn, v->sn, 12994);
-		}
-	}
-}
-
 static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
 	int p, n;
 	p = int_floorlog2(stepsize) - 13;
@@ -396,7 +321,7 @@
 */
 
 /* <summary>                            */
-/* Forward 5-3 wavelet tranform in 2-D. */
+/* Forward 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
 void dwt_encode(opj_tcd_tilecomp_t * tilec) {
 	int i, j, k;
@@ -411,7 +336,7 @@
 	
 	for (i = 0; i < l; i++) {
 		int rw;			/* width of the resolution level computed                                                           */
-		int rh;			/* heigth of the resolution level computed                                                          */
+		int rh;			/* height of the resolution level computed                                                          */
 		int rw1;		/* width of the resolution level once lower than computed one                                       */
 		int rh1;		/* height of the resolution level once lower than computed one                                      */
 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
@@ -452,10 +377,10 @@
 
 
 /* <summary>                            */
-/* Inverse 5-3 wavelet tranform in 2-D. */
+/* Inverse 5-3 wavelet transform in 2-D. */
 /* </summary>                           */
-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop) {
-	dwt_decode_tile(tilec, stop, &dwt_decode_1);
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
+	dwt_decode_tile(tilec, numres, &dwt_decode_1);
 }
 
 
@@ -494,7 +419,7 @@
 	
 	for (i = 0; i < l; i++) {
 		int rw;			/* width of the resolution level computed                                                     */
-		int rh;			/* heigth of the resolution level computed                                                    */
+		int rh;			/* height of the resolution level computed                                                    */
 		int rw1;		/* width of the resolution level once lower than computed one                                 */
 		int rh1;		/* height of the resolution level once lower than computed one                                */
 		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
@@ -534,14 +459,6 @@
 }
 
 
-/* <summary>                             */
-/* Inverse 9-7 wavelet transform in 2-D. */
-/* </summary>                            */
-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop) {
-	dwt_decode_tile(tilec, stop, dwt_decode_1_real);
-}
-
-
 /* <summary>                          */
 /* Get gain of 9-7 wavelet transform. */
 /* </summary>                         */
@@ -582,7 +499,7 @@
 /* <summary>                             */
 /* Determine maximum computed resolution level for inverse wavelet transform */
 /* </summary>                            */
-static int dwt_decode_max_resolution(opj_tcd_resolution_t* r, int i) {
+static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
 	int mr	= 1;
 	int w;
 	while( --i ) {
@@ -597,65 +514,312 @@
 
 
 /* <summary>                            */
-/* Inverse wavelet tranform in 2-D.     */
+/* Inverse wavelet transform in 2-D.     */
 /* </summary>                           */
-static void dwt_decode_tile(opj_tcd_tilecomp_t * tilec, int stop, DWT1DFN dwt_1D) {
-	opj_tcd_resolution_t* tr;
-	int i, j, k;
-	int *a = NULL;
-	int *aj = NULL;
-	int *m;
-	int w; //, l;
-	int rw;			/* width of the resolution level computed  */
-	int rh;			/* heigth of the resolution level computed  */
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
 	dwt_t h;
 	dwt_t v;
-	
-	if( 1 > ( i = tilec->numresolutions - stop ) )
-		return ;
 
-	tr = tilec->resolutions;
+	opj_tcd_resolution_t* tr = tilec->resolutions;
 
-	w = tilec->x1-tilec->x0;
-	a = tilec->data;
+	int rw = tr->x1 - tr->x0;	/* width of the resolution level computed */
+	int rh = tr->y1 - tr->y0;	/* height of the resolution level computed */
 
-	m = (int*)opj_malloc(sizeof(int) * (dwt_decode_max_resolution(tr, i)+5));
-	h.mem = v.mem = (int*)( (unsigned)m + 16 - ( (unsigned)m % 16 ) ) ;
+	int w = tilec->x1 - tilec->x0;
 
-	rw = tr->x1 - tr->x0;
-	rh = tr->y1 - tr->y0;
+	h.mem = opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
+	v.mem = h.mem;
 
-	while( --i ) {
-		tr++;
+	while( --numres) {
+		int * restrict tiledp = tilec->data;
+		int j;
+
+		++tr;
 		h.sn = rw;
 		v.sn = rh;
-		h.dn = ( rw = tr->x1 - tr->x0 ) - h.sn;
-		v.dn = ( rh = tr->y1 - tr->y0 ) - v.sn;
-				
+
+		rw = tr->x1 - tr->x0;
+		rh = tr->y1 - tr->y0;
+
+		h.dn = rw - h.sn;
 		h.cas = tr->x0 % 2;
-		v.cas = tr->y0 % 2;
 
-		aj = a;
-		j = rh;
-		while( j-- ) {		
-			dwt_interleave_h(&h, aj);
+		for(j = 0; j < rh; ++j) {
+			dwt_interleave_h(&h, &tiledp[j*w]);
 			(dwt_1D)(&h);
-			k = rw;
-			while( k-- )
-				aj[k] = h.mem[k];
-			aj += w;
+			memcpy(&tiledp[j*w], h.mem, rw * sizeof(int));
 		}
 
-		aj = a;
-		j = rw;
-		while( j-- ) {
-			dwt_interleave_v(&v, aj, w);
+		v.dn = rh - v.sn;
+		v.cas = tr->y0 % 2;
+
+		for(j = 0; j < rw; ++j){
+			int k;
+			dwt_interleave_v(&v, &tiledp[j], w);
 			(dwt_1D)(&v);
-			k = rh;
-			while( k-- )
-				aj[k * w] = v.mem[k];
-			aj++;
+			for(k = 0; k < rh; ++k) {
+				tiledp[k * w + j] = v.mem[k];
+			}
+		}
+	}
+	opj_aligned_free(h.mem);
+}
+
+static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
+	float* restrict bi = (float*) (w->wavelet + w->cas);
+	int count = w->sn;
+	int i, k;
+	for(k = 0; k < 2; ++k){
+		for(i = 0; i < count; ++i){
+			int j = i;
+			bi[i*8    ] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 1] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 2] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 3] = a[j];
+		}
+		bi = (float*) (w->wavelet + 1 - w->cas);
+		a += w->sn;
+		size -= w->sn;
+		count = w->dn;
+	}
+}
+
+static void v4dwt_interleave_v(v4dwt_t* restrict v , float* restrict a , int x){
+	v4* restrict bi = v->wavelet + v->cas;
+	int i;
+	for(i = 0; i < v->sn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+	a += v->sn * x;
+	bi = v->wavelet + 1 - v->cas;
+	for(i = 0; i < v->dn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+}
+
+#ifdef __SSE__
+
+static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		__m128 tmp = vw[i*2];
+		vw[i*2] = tmp * c;
+	}
+}
+
+static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
+	__m128* restrict vl = (__m128*) l;
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		__m128 tmp1 = vl[ 0];
+		__m128 tmp2 = vw[-1];
+		__m128 tmp3 = vw[ 0];
+		vw[-1] = tmp2 + ((tmp1 + tmp3) * c);
+		vl = vw;
+		vw += 2;
+	}
+	if(m >= k){
+		return;
+	}
+	c += c;
+	c *= vl[0];
+	for(; m < k; ++m){
+		__m128 tmp = vw[-1];
+		vw[-1] = tmp + c;
+		vw += 2;
+	}
+}
+
+#else
+
+static void v4dwt_decode_step1(v4* w, int count, const float c){
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		float tmp1 = fw[i*8    ];
+		float tmp2 = fw[i*8 + 1];
+		float tmp3 = fw[i*8 + 2];
+		float tmp4 = fw[i*8 + 3];
+		fw[i*8    ] = tmp1 * c;
+		fw[i*8 + 1] = tmp2 * c;
+		fw[i*8 + 2] = tmp3 * c;
+		fw[i*8 + 3] = tmp4 * c;
+	}
+}
+
+static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
+	float* restrict fl = (float*) l;
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		float tmp1_1 = fl[0];
+		float tmp1_2 = fl[1];
+		float tmp1_3 = fl[2];
+		float tmp1_4 = fl[3];
+		float tmp2_1 = fw[-4];
+		float tmp2_2 = fw[-3];
+		float tmp2_3 = fw[-2];
+		float tmp2_4 = fw[-1];
+		float tmp3_1 = fw[0];
+		float tmp3_2 = fw[1];
+		float tmp3_3 = fw[2];
+		float tmp3_4 = fw[3];
+		fw[-4] = tmp2_1 + ((tmp1_1 + tmp3_1) * c);
+		fw[-3] = tmp2_2 + ((tmp1_2 + tmp3_2) * c);
+		fw[-2] = tmp2_3 + ((tmp1_3 + tmp3_3) * c);
+		fw[-1] = tmp2_4 + ((tmp1_4 + tmp3_4) * c);
+		fl = fw;
+		fw += 8;
+	}
+	if(m < k){
+		float c1;
+		float c2;
+		float c3;
+		float c4;
+		c += c;
+		c1 = fl[0] * c;
+		c2 = fl[1] * c;
+		c3 = fl[2] * c;
+		c4 = fl[3] * c;
+		for(; m < k; ++m){
+			float tmp1 = fw[-4];
+			float tmp2 = fw[-3];
+			float tmp3 = fw[-2];
+			float tmp4 = fw[-1];
+			fw[-4] = tmp1 + c1;
+			fw[-3] = tmp2 + c2;
+			fw[-2] = tmp3 + c3;
+			fw[-1] = tmp4 + c4;
+			fw += 8;
+		}
+	}
+}
+
+#endif
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 1-D. */
+/* </summary>                            */
+static void v4dwt_decode(v4dwt_t* restrict dwt){
+	int a, b;
+	if(dwt->cas == 0) {
+		if(!((dwt->dn > 0) || (dwt->sn > 1))){
+			return;
+		}
+		a = 0;
+		b = 1;
+	}else{
+		if(!((dwt->sn > 0) || (dwt->dn > 1))) {
+			return;
+		}
+		a = 1;
+		b = 0;
+	}
+#ifdef __SSE__
+	v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(K));
+	v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(c13318));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(delta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(gamma));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(beta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(alpha));
+#else
+	v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, K);
+	v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, c13318);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), delta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), gamma);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), beta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), alpha);
+#endif
+}
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 2-D. */
+/* </summary>                            */
+void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
+	v4dwt_t h;
+	v4dwt_t v;
+
+	opj_tcd_resolution_t* res = tilec->resolutions;
+
+	int rw = res->x1 - res->x0;	/* width of the resolution level computed */
+	int rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+	int w = tilec->x1 - tilec->x0;
+
+	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
+	v.wavelet = h.wavelet;
+
+	while( --numres) {
+		float * restrict aj = (float*) tilec->data;
+		int bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
+		int j;
+
+		h.sn = rw;
+		v.sn = rh;
+
+		++res;
+
+		rw = res->x1 - res->x0;	/* width of the resolution level computed */
+		rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+		h.dn = rw - h.sn;
+		h.cas = res->x0 % 2;
+
+		for(j = rh; j > 0; j -= 4){
+			v4dwt_interleave_h(&h, aj, w, bufsize);
+			v4dwt_decode(&h);
+			if(j >= 4){
+				int k;
+				for(k = rw; --k >= 0;){
+					aj[k    ] = h.wavelet[k].f[0];
+					aj[k+w  ] = h.wavelet[k].f[1];
+					aj[k+w*2] = h.wavelet[k].f[2];
+					aj[k+w*3] = h.wavelet[k].f[3];
+				}
+			}else{
+				int k;
+				for(k = rw; --k >= 0;){
+					switch(j) {
+						case 3: aj[k+w*2] = h.wavelet[k].f[2];
+						case 2: aj[k+w  ] = h.wavelet[k].f[1];
+						case 1: aj[k    ] = h.wavelet[k].f[0];
+					}
+				}
+			}
+			aj += w*4;
+			bufsize -= w*4;
+		}
+
+		v.dn = rh - v.sn;
+		v.cas = res->y0 % 2;
+
+		aj = (float*) tilec->data;
+		for(j = rw; j > 0; j -= 4){
+			v4dwt_interleave_v(&v, aj, w);
+			v4dwt_decode(&v);
+			if(j >= 4){
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(float));
+				}
+			}else{
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], j * sizeof(float));
+				}
+			}
+			aj += 4;
 		}
 	}
-	opj_free(m);
+
+	opj_aligned_free(h.wavelet);
 }
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/dwt.h ./libopenjpeg/dwt.h
--- /home/robin/sldeb/trunk/libopenjpeg/dwt.h	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/dwt.h	2007-11-27 22:39:50.000000000 +0000
@@ -57,9 +57,9 @@
 Inverse 5-3 wavelet tranform in 2-D.
 Apply a reversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
-@param stop FIXME Number of decoded resolution levels ?
+@param numres Number of resolution levels to decode
 */
-void dwt_decode(opj_tcd_tilecomp_t * tilec, int stop);
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the reversible 5-3 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
@@ -83,9 +83,9 @@
 Inverse 9-7 wavelet transform in 2-D. 
 Apply an irreversible inverse DWT transform to a component of an image.
 @param tilec Tile component information (current tile)
-@param stop FIXME Number of decoded resolution levels ?
+@param numres Number of resolution levels to decode
 */
-void dwt_decode_real(opj_tcd_tilecomp_t * tilec, int stop);
+void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
 /**
 Get the gain of a subband for the irreversible 9-7 DWT.
 @param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
@@ -100,9 +100,9 @@
 */
 double dwt_getnorm_real(int level, int orient);
 /**
-FIXME : comment ???
-@param tccp
-@param prec
+Explicit calculation of the Quantization Stepsizes 
+@param tccp Tile-component coding parameters
+@param prec Precint analyzed
 */
 void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
 /* ----------------------------------------------------------------------- */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/image.c ./libopenjpeg/image.c
--- /home/robin/sldeb/trunk/libopenjpeg/image.c	2006-01-31 21:26:11.000000000 +0000
+++ ./libopenjpeg/image.c	2007-11-27 22:39:50.000000000 +0000
@@ -26,7 +26,7 @@
 
 #include "opj_includes.h"
 
-opj_image_t* opj_image_create0() {
+opj_image_t* opj_image_create0(void) {
 	opj_image_t *image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
 	return image;
 }
@@ -35,13 +35,14 @@
 	int compno;
 	opj_image_t *image = NULL;
 
-	image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
+	image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));
 	if(image) {
 		image->color_space = clrspc;
 		image->numcomps = numcmpts;
 		/* allocate memory for the per-component information */
 		image->comps = (opj_image_comp_t*)opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
 		if(!image->comps) {
+			fprintf(stderr,"Unable to allocate memory for image.\n");
 			opj_image_destroy(image);
 			return NULL;
 		}
@@ -57,8 +58,9 @@
 			comp->prec = cmptparms[compno].prec;
 			comp->bpp = cmptparms[compno].bpp;
 			comp->sgnd = cmptparms[compno].sgnd;
-			comp->data = (int*)opj_malloc(comp->w * comp->h * sizeof(int));
+			comp->data = (int*) opj_calloc(comp->w * comp->h, sizeof(int));
 			if(!comp->data) {
+				fprintf(stderr,"Unable to allocate memory for image.\n");
 				opj_image_destroy(image);
 				return NULL;
 			}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/image.h ./libopenjpeg/image.h
--- /home/robin/sldeb/trunk/libopenjpeg/image.h	2006-01-25 09:17:16.000000000 +0000
+++ ./libopenjpeg/image.h	2007-09-28 11:33:44.000000000 +0100
@@ -40,7 +40,7 @@
 @todo this function should be removed
 @return returns an empty image if successful, returns NULL otherwise
 */
-opj_image_t* opj_image_create0();
+opj_image_t* opj_image_create0(void);
 
 /*@}*/
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/j2k.c ./libopenjpeg/j2k.c
--- /home/robin/sldeb/trunk/libopenjpeg/j2k.c	2007-05-23 17:04:50.000000000 +0100
+++ ./libopenjpeg/j2k.c	2007-11-27 22:39:50.000000000 +0000
@@ -259,13 +259,13 @@
 }
 
 static void j2k_check_poc_val(opj_cparameters_t *parameters, int numcomps, int numlayers){
+	int* packet_array;
 	int index, resno, compno, layno, i;
-	char loss = 0;
 	int step_c = 1;
 	int step_r = numcomps * step_c;
 	int step_l = parameters->numresolution * step_r;
-	int array_size = step_l * numlayers * sizeof(int);
-	int *packet_array = (int *) opj_malloc(array_size);
+	bool loss = false;
+	packet_array = (int*) opj_calloc(step_l * numlayers, sizeof(int));
 	
 	for (i = 0; i < parameters->numpocs ; i++) {
 		int layno0 = 0;
@@ -285,12 +285,12 @@
 			for (layno = 0; layno < numlayers ; layno++) {
 				index = step_r * resno + step_c * compno + step_l * layno;
 				if(!(	packet_array[index]== 1)){
-					loss = 1;
+					loss = true;
 				}
 			}
 		}
 	}
-	if(loss == 1)
+	if(loss)
 		fprintf(stdout,"Missing packets possible loss of data\n");
 	opj_free(packet_array);
 }
@@ -406,7 +406,7 @@
 
 /**	mem allocation for TLM marker*/
 int j2k_calculate_tp(opj_cp_t *cp,int img_numcomp,opj_image_t *image,opj_j2k_t *j2k ){
-	int pino,tileno,maxres=0,totnum_tp=0;
+	int pino,tileno,totnum_tp=0;
 	j2k->cur_totnum_tp = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		int cur_totnum_tp = 0;
@@ -421,6 +421,12 @@
 			pi_destroy(pi, cp, tileno);
 		}
 		j2k->cur_totnum_tp[tileno] = cur_totnum_tp;
+		/* INDEX >> */
+		if (j2k->cstr_info) {
+			j2k->cstr_info->tile[tileno].num_tps = cur_totnum_tp;
+			j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
+		}
+		/* << INDEX */
 	}
 	return totnum_tp;
 }
@@ -428,10 +434,24 @@
 static void j2k_write_soc(opj_j2k_t *j2k) {
 	opj_cio_t *cio = j2k->cio;
 	cio_write(cio, J2K_MS_SOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio) - 2, 2);
+
+#endif /* USE_JPWL */
+/* <<UniPG */
 }
 
-static void j2k_read_soc(opj_j2k_t *j2k) {
+static void j2k_read_soc(opj_j2k_t *j2k) {	
 	j2k->state = J2K_STATE_MHSIZ;
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->main_head_start = cio_tell(j2k->cio) - 2;
+		j2k->cstr_info->codestream_size = cio_numbytesleft(j2k->cio) + 2 - j2k->cstr_info->main_head_start;
+	}
 }
 
 static void j2k_write_siz(opj_j2k_t *j2k) {
@@ -525,7 +545,7 @@
 	}
 #endif /* USE_JPWL */
 
-	image->comps = (opj_image_comp_t *) opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
+	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
 	for (i = 0; i < image->numcomps; i++) {
 		int tmp, w, h;
 		tmp = cio_read(cio, 1);		/* Ssiz_i */
@@ -563,13 +583,12 @@
 		}
 #endif /* USE_JPWL */
 
-
 		/* TODO: unused ? */
 		w = int_ceildiv(image->x1 - image->x0, image->comps[i].dx);
 		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);
 
 		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
-		image->comps[i].factor = 0;			/* reducing factor per component */
+		image->comps[i].factor = cp->reduce; /* reducing factor per component */
 	}
 	
 	cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
@@ -615,8 +634,8 @@
 	}
 #endif /* USE_JPWL */
 
-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
-	cp->tileno = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+	cp->tileno = (int*) opj_malloc(cp->tw * cp->th * sizeof(int));
 	cp->tileno_size = 0;
 	
 #ifdef USE_JPWL
@@ -644,14 +663,29 @@
 	cp->ppm_data_first = NULL;
 	cp->ppm_previous = 0;
 	cp->ppm_store = 0;
-	
-	j2k->default_tcp->tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
+
+	j2k->default_tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
 	for (i = 0; i < cp->tw * cp->th; i++) {
-		cp->tcps[i].tccps = (opj_tccp_t *) opj_malloc(sizeof(opj_tccp_t) * image->numcomps);
-	}
-	j2k->tile_data = (unsigned char **) opj_malloc(cp->tw * cp->th * sizeof(unsigned char *));
-	j2k->tile_len = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+		cp->tcps[i].tccps = (opj_tccp_t*) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
+	}	
+	j2k->tile_data = (unsigned char**) opj_calloc(cp->tw * cp->th, sizeof(unsigned char*));
+	j2k->tile_len = (int*) opj_calloc(cp->tw * cp->th, sizeof(int));
 	j2k->state = J2K_STATE_MH;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	
+		cstr_info->tile_y = cp->tdy;	
+		cstr_info->tile_Ox = cp->tx0;	
+		cstr_info->tile_Oy = cp->ty0;			
+		cstr_info->tile = (opj_tile_info_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tile_info_t));		
+	}
 }
 
 static void j2k_write_com(opj_j2k_t *j2k) {
@@ -665,7 +699,7 @@
 		cio_write(cio, J2K_MS_COM, 2);
 		lenp = cio_tell(cio);
 		cio_skip(cio, 2);
-		cio_write(cio, 0, 2);
+		cio_write(cio, 1, 2);		/* General use (IS 8859-15:1999 (Latin) values) */
 		for (i = 0; i < strlen(comment); i++) {
 			cio_write(cio, comment[i], 1);
 		}
@@ -716,8 +750,13 @@
 
 	tccp->numresolutions = cio_read(cio, 1) + 1;	/* SPcox (D) */
 
-	/* check the reduce value */
-	cp->reduce = int_min((tccp->numresolutions)-1, cp->reduce);
+	// If user wants to remove more resolutions than the codestream contains, return error
+	if (cp->reduce >= tccp->numresolutions) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
+					"of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
+		j2k->state |= J2K_STATE_ERR;
+	}
+
 	tccp->cblkw = cio_read(cio, 1) + 2;	/* SPcox (E) */
 	tccp->cblkh = cio_read(cio, 1) + 2;	/* SPcox (F) */
 	tccp->cblksty = cio_read(cio, 1);	/* SPcox (G) */
@@ -729,6 +768,21 @@
 			tccp->prch[i] = tmp >> 4;
 		}
 	}
+
+	/* INDEX >> */
+	if(j2k->cstr_info && compno == 0) {
+		for (i = 0; i < tccp->numresolutions; i++) {
+			if (tccp->csty & J2K_CP_CSTY_PRT) {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = tccp->prcw[i];
+				j2k->cstr_info->tile[j2k->curtileno].pdy[i] = tccp->prch[i];
+			}
+			else {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+			}
+		}
+	}
+	/* << INDEX */
 }
 
 static void j2k_write_cod(opj_j2k_t *j2k) {
@@ -778,6 +832,17 @@
 		cio_seek(cio, pos);
 		j2k_read_cox(j2k, i);
 	}
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->prog = tcp->prg;
+		cstr_info->numlayers = tcp->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (i = 0; i < image->numcomps; i++) {
+			cstr_info->numdecompos[i] = tcp->tccps[i].numresolutions - 1;
+		}
+	}
 }
 
 static void j2k_write_coc(opj_j2k_t *j2k, int compno) {
@@ -1018,7 +1083,6 @@
 	
 	opj_cp_t *cp = j2k->cp;
 	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
-	opj_tccp_t *tccp = &tcp->tccps[0];
 	opj_cio_t *cio = j2k->cio;
 	
 	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
@@ -1149,7 +1213,7 @@
 						"JPWL: failed memory allocation during PPM marker parsing (pos. %x)\n",
 						cio_tell(cio));
 					if (!JPWL_ASSUME || JPWL_ASSUME) {
-						free(cp->ppm_data);
+						opj_free(cp->ppm_data);
 						opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
 						return;
 					}
@@ -1229,6 +1293,13 @@
 	cio_seek(cio, lenp);
 	cio_write(cio, len, 2);				/* Lsot */
 	cio_seek(cio, lenp + len);
+
+	/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOT, j2k->sot_start, len + 2);
+#endif /* USE_JPWL */
+	/* <<UniPG */
 }
 
 static void j2k_read_sot(opj_j2k_t *j2k) {
@@ -1238,7 +1309,7 @@
 
 	opj_cp_t *cp = j2k->cp;
 	opj_cio_t *cio = j2k->cio;
-	
+
 	len = cio_read(cio, 2);
 	tileno = cio_read(cio, 2);
 
@@ -1267,7 +1338,6 @@
 		backup_tileno++;
 	};
 #endif /* USE_JPWL */
-
 	
 	if (cp->tileno_size == 0) {
 		cp->tileno[cp->tileno_size] = tileno;
@@ -1315,12 +1385,34 @@
 	numparts = cio_read(cio, 1);
 	
 	j2k->curtileno = tileno;
+	j2k->cur_tp_num = partno;
 	j2k->eot = cio_getbp(cio) - 12 + totlen;
 	j2k->state = J2K_STATE_TPH;
 	tcp = &cp->tcps[j2k->curtileno];
+
+	/* Index */
+	if (j2k->cstr_info) {
+		if (tcp->first) {
+			if (tileno == 0) 
+				j2k->cstr_info->main_head_end = cio_tell(cio) - 13;
+			j2k->cstr_info->tile[tileno].tileno = tileno;
+			j2k->cstr_info->tile[tileno].start_pos = cio_tell(cio) - 12;
+			j2k->cstr_info->tile[tileno].end_pos = j2k->cstr_info->tile[tileno].start_pos + totlen - 1;				
+			j2k->cstr_info->tile[tileno].num_tps = numparts;
+			if (numparts)
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));
+			else
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)
+		}
+		else {
+			j2k->cstr_info->tile[tileno].end_pos += totlen;
+		}		
+		j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = cio_tell(cio) - 12;
+		j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos = 
+			j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
+	}
 	
-	if (tcp->first == 1) {
-		
+	if (tcp->first == 1) {		
 		/* Initialization PPT */
 		opj_tccp_t *tmp = tcp->tccps;
 		memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t));
@@ -1340,7 +1432,7 @@
 	int l, layno;
 	int totlen;
 	opj_tcp_t *tcp = NULL;
-	opj_image_info_t *image_info = NULL;
+	opj_codestream_info_t *cstr_info = NULL;
 	
 	opj_tcd_t *tcd = (opj_tcd_t*)tile_coder;	/* cast is needed because of conflicts in header inclusions */
 	opj_cp_t *cp = j2k->cp;
@@ -1348,17 +1440,29 @@
 
 	tcd->tp_num = j2k->tp_num ;
 	tcd->cur_tp_num = j2k->cur_tp_num;
-	tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
 	
 	cio_write(cio, J2K_MS_SOD, 2);
 	if (j2k->curtileno == 0) {
 		j2k->sod_start = cio_tell(cio) + j2k->pos_correction;
 	}
-	
+
 	/* INDEX >> */
-	image_info = j2k->image_info;
-	if (image_info && image_info->index_on) {
-		image_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+	cstr_info = j2k->cstr_info;
+	if (cstr_info) {
+		if (!j2k->cur_tp_num ) {
+			cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+			j2k->cstr_info->tile[j2k->curtileno].tileno = j2k->curtileno;
+		}
+		else{
+			if(cstr_info->tile[j2k->curtileno].packet[cstr_info->packno - 1].end_pos < cio_tell(cio))
+				cstr_info->tile[j2k->curtileno].packet[cstr_info->packno].start_pos = cio_tell(cio);
+		}
+		/* UniPG>> */
+#ifdef USE_JPWL
+		/* update markers struct */
+		j2k_add_marker(j2k->cstr_info, J2K_MS_SOD, j2k->sod_start, 2);
+#endif /* USE_JPWL */
+		/* <<UniPG */
 	}
 	/* << INDEX */
 	
@@ -1366,11 +1470,13 @@
 	for (layno = 0; layno < tcp->numlayers; layno++) {
 		tcp->rates[layno] -= tcp->rates[layno] ? (j2k->sod_start / (cp->th * cp->tw)) : 0;
 	}
-	if(image_info) {
-		image_info->num = 0;
+	if(j2k->cur_tp_num == 0){
+		tcd->tcd_image->tiles->packno = 0;
+		if(cstr_info)
+			cstr_info->packno = 0;
 	}
 	
-	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, image_info);
+	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, cstr_info);
 	
 	/* Writing Psot in SOT marker */
 	totlen = cio_tell(cio) + l - j2k->sot_start;
@@ -1392,26 +1498,31 @@
 
 	opj_cio_t *cio = j2k->cio;
 	int curtileno = j2k->curtileno;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+			cio_tell(cio) + j2k->pos_correction - 1;
+		if (j2k->cur_tp_num == 0)
+			j2k->cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+		j2k->cstr_info->packno = 0;
+	}
 	
 	len = int_min(j2k->eot - cio_getbp(cio), cio_numbytesleft(cio) + 1);
-	
+
 	if (len == cio_numbytesleft(cio) + 1) {
 		truncate = 1;		/* Case of a truncate codestream */
-	}
-	
-	data = (unsigned char *) opj_malloc((j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
+	}	
 
-	for (i = 0; i < j2k->tile_len[curtileno]; i++) {
-		data[i] = j2k->tile_data[curtileno][i];
-	}
+	data = j2k->tile_data[curtileno];
+	data = (unsigned char*) opj_realloc(data, (j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
 
 	data_ptr = data + j2k->tile_len[curtileno];
 	for (i = 0; i < len; i++) {
 		data_ptr[i] = cio_read(cio, 1);
 	}
-	
+
 	j2k->tile_len[curtileno] += len;
-	opj_free(j2k->tile_data[curtileno]);
 	j2k->tile_data[curtileno] = data;
 	
 	if (!truncate) {
@@ -1419,10 +1530,10 @@
 	} else {
 		j2k->state = J2K_STATE_NEOC;	/* RAJOUTE !! */
 	}
+	j2k->cur_tp_num++;
 }
 
 static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno) {
-	
 	opj_cp_t *cp = j2k->cp;
 	opj_tcp_t *tcp = &cp->tcps[tileno];
 	opj_cio_t *cio = j2k->cio;
@@ -1469,20 +1580,34 @@
 	opj_cio_t *cio = j2k->cio;
 	/* opj_event_msg(j2k->cinfo, "%.8x: EOC\n", cio_tell(cio) + j2k->pos_correction); */
 	cio_write(cio, J2K_MS_EOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EOC, cio_tell(cio) - 2, 2);
+#endif /* USE_JPWL */
+/* <<UniPG */
 }
 
 static void j2k_read_eoc(opj_j2k_t *j2k) {
 	int i, tileno;
+	bool success;
 
 	/* if packets should be decoded */
 	if (j2k->cp->limit_decoding != DECODE_ALL_BUT_PACKETS) {
 		opj_tcd_t *tcd = tcd_create(j2k->cinfo);
 		tcd_malloc_decode(tcd, j2k->image, j2k->cp);
 		for (i = 0; i < j2k->cp->tileno_size; i++) {
+			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
 			tileno = j2k->cp->tileno[i];
-			tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno);
+			success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
 			opj_free(j2k->tile_data[tileno]);
 			j2k->tile_data[tileno] = NULL;
+			tcd_free_decode_tile(tcd, i);
+			if (success == false) {
+				j2k->state |= J2K_STATE_ERR;
+				break;
+			}
 		}
 		tcd_free_decode(tcd);
 		tcd_destroy(tcd);
@@ -1494,9 +1619,11 @@
 			opj_free(j2k->tile_data[tileno]);
 			j2k->tile_data[tileno] = NULL;
 		}
-	}
-	
-	j2k->state = J2K_STATE_MT;
+	}	
+	if (j2k->state & J2K_STATE_ERR)
+		j2k->state = J2K_STATE_MT + J2K_STATE_ERR;
+	else
+		j2k->state = J2K_STATE_MT; 
 }
 
 typedef struct opj_dec_mstabent {
@@ -1535,6 +1662,10 @@
   {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},
   {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},
 #endif /* USE_JPWL */
+#ifdef USE_JPSEC
+  {J2K_MS_SEC, J2K_STATE_MH, j2k_read_sec},
+  {J2K_MS_INSEC, 0, j2k_read_insec},
+#endif /* USE_JPSEC */
 
   {0, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_unk}
 };
@@ -1620,15 +1751,19 @@
 /* ----------------------------------------------------------------------- */
 
 opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
-	if(j2k) {
-		j2k->cinfo = cinfo;
-		j2k->default_tcp = (opj_tcp_t*)opj_malloc(sizeof(opj_tcp_t));
-		if(!j2k->default_tcp) {
-			opj_free(j2k);
-			return NULL;
-		}
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
+	if(!j2k)
+		return NULL;
+
+	j2k->default_tcp = (opj_tcp_t*) opj_calloc(1, sizeof(opj_tcp_t));
+	if(!j2k->default_tcp) {
+		opj_free(j2k);
+		return NULL;
 	}
+
+	j2k->cinfo = cinfo;
+	j2k->tile_data = NULL;
+
 	return j2k;
 }
 
@@ -1676,14 +1811,13 @@
 
 		opj_free(cp);
 	}
-
 	opj_free(j2k);
 }
 
 void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters) {
 	if(j2k && parameters) {
 		/* create and initialize the coding parameters structure */
-		opj_cp_t *cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+		opj_cp_t *cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
 		cp->reduce = parameters->cp_reduce;	
 		cp->layer = parameters->cp_layer;
 		cp->limit_decoding = parameters->cp_limit_decoding;
@@ -1700,12 +1834,15 @@
 	}
 }
 
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio) {
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	opj_image_t *image = NULL;
 
-	opj_common_ptr cinfo = j2k->cinfo;
+	opj_common_ptr cinfo = j2k->cinfo;	
 
 	j2k->cio = cio;
+	j2k->cstr_info = cstr_info;
+	if (cstr_info)
+		memset(cstr_info, 0, sizeof(opj_codestream_info_t));
 
 	/* create an empty image */
 	image = opj_image_create0();
@@ -1717,7 +1854,6 @@
 		opj_dec_mstabent_t *e;
 		int id = cio_read(cio, 2);
 
-
 #ifdef USE_JPWL
 		/* we try to honor JPWL correction power */
 		if (j2k->cp->correct) {
@@ -1777,6 +1913,9 @@
 		if (e->handler) {
 			(*e->handler)(j2k);
 		}
+		if (j2k->state & J2K_STATE_ERR) 
+			return NULL;	
+
 		if (j2k->state == J2K_STATE_MT) {
 			break;
 		}
@@ -1799,7 +1938,7 @@
 * Read a JPT-stream and decode file
 *
 */
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio) {
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio,  opj_codestream_info_t *cstr_info) {
 	opj_image_t *image = NULL;
 	opj_jpt_msg_header_t header;
 	int position;
@@ -1810,6 +1949,7 @@
 
 	/* create an empty image */
 	image = opj_image_create0();
+	j2k->image = image;
 
 	j2k->state = J2K_STATE_MHSOC;
 	
@@ -1882,7 +2022,7 @@
 /* ----------------------------------------------------------------------- */
 
 opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo) {
-	opj_j2k_t *j2k = (opj_j2k_t*)opj_malloc(sizeof(opj_j2k_t));
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
 	if(j2k) {
 		j2k->cinfo = cinfo;
 	}
@@ -1893,20 +2033,6 @@
 	int tileno;
 
 	if(!j2k) return;
-
-	if(j2k->image_info != NULL) {
-		opj_image_info_t *image_info = j2k->image_info;
-		if (image_info->index_on && j2k->cp) {
-			opj_cp_t *cp = j2k->cp;
-			for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
-				opj_tile_info_t *tile_info = &image_info->tile[tileno];
-				opj_free(tile_info->thresh);
-				opj_free(tile_info->packet);
-			}
-			opj_free(image_info->tile);
-		}
-		opj_free(image_info);
-	}
 	if(j2k->cp != NULL) {
 		opj_cp_t *cp = j2k->cp;
 
@@ -1935,7 +2061,7 @@
 	}
 
 	/* create and initialize the coding parameters structure */
-	cp = (opj_cp_t*)opj_malloc(sizeof(opj_cp_t));
+	cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
 
 	/* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
 	j2k->cp = cp;
@@ -1961,12 +2087,6 @@
 		memcpy(cp->matrice, parameters->cp_matrice, array_size);
 	}
 
-	/* creation of an index file ? */
-	cp->index_on = parameters->index_on;
-	if(cp->index_on) {
-		j2k->image_info = (opj_image_info_t*)opj_malloc(sizeof(opj_image_info_t));
-	}
-
 	/* tiles */
 	cp->tdx = parameters->cp_tdx;
 	cp->tdy = parameters->cp_tdy;
@@ -2065,7 +2185,7 @@
 
 	/* initialize the mutiple tiles */
 	/* ---------------------------- */
-	cp->tcps = (opj_tcp_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcp_t));
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
 
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		opj_tcp_t *tcp = &cp->tcps[tileno];
@@ -2112,8 +2232,8 @@
 			tcp->numpocs = 0;
 		}
 
-		tcp->tccps = (opj_tccp_t *) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
-		
+		tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+
 		for (i = 0; i < image->numcomps; i++) {
 			opj_tccp_t *tccp = &tcp->tccps[i];
 			tccp->csty = parameters->csty & 0x01;	/* 0 => one precinct || 1 => custom precinct  */
@@ -2191,244 +2311,8 @@
 	}
 }
 
-/**
-Create an index file
-@param j2k
-@param cio
-@param image_info
-@param index Index filename
-@return Returns 1 if successful, returns 0 otherwise
-*/
-static int j2k_create_index(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_info_t *image_info, char *index) {
-	int tileno, compno, layno, resno, precno, pack_nb, x, y;
-	FILE *stream = NULL;
-	double total_disto = 0;
-
-	image_info->codestream_size = cio_tell(cio) + j2k->pos_correction;	/* Correction 14/4/03 suite rmq de Patrick */
-
-
-#ifdef USE_JPWL
-	/* if JPWL is enabled and the name coincides with our own set
-	   then discard the creation of the file: this was just done to
-	   enable indexing, we do not want an index file
-	*/
-	if (j2k->cp->epc_on && !strcmp(index, JPWL_PRIVATEINDEX_NAME))
-		return 1;
-#endif /* USE_JPWL */
-
-
-	stream = fopen(index, "w");
-	if (!stream) {
-		opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to open %s for writing\n", index);
-		return 0;
-	}
-	
-	fprintf(stream, "%d %d\n", image_info->image_w, image_info->image_h);
-	fprintf(stream, "%d\n", image_info->prog);
-	fprintf(stream, "%d %d\n", image_info->tile_x, image_info->tile_y);
-	fprintf(stream, "%d %d\n", image_info->tw, image_info->th);
-	fprintf(stream, "%d\n", image_info->comp);
-	fprintf(stream, "%d\n", image_info->layer);
-	fprintf(stream, "%d\n", image_info->decomposition);
-	
-	for (resno = image_info->decomposition; resno >= 0; resno--) {
-		fprintf(stream, "[%d,%d] ", 
-			(1 << image_info->tile[0].pdx[resno]), (1 << image_info->tile[0].pdx[resno]));	/* based on tile 0 */
-	}
-	fprintf(stream, "\n");
-	fprintf(stream, "%d\n", image_info->main_head_end);
-	fprintf(stream, "%d\n", image_info->codestream_size);
-	
-	for (tileno = 0; tileno < image_info->tw * image_info->th; tileno++) {
-		fprintf(stream, "%4d %9d %9d %9d %9e %9d %9e\n",
-			image_info->tile[tileno].num_tile,
-			image_info->tile[tileno].start_pos,
-			image_info->tile[tileno].end_header,
-			image_info->tile[tileno].end_pos,
-			image_info->tile[tileno].distotile, image_info->tile[tileno].nbpix,
-			image_info->tile[tileno].distotile / image_info->tile[tileno].nbpix);
-	}
-	
-	for (tileno = 0; tileno < image_info->tw * image_info->th; tileno++) {
-		int start_pos, end_pos;
-		double disto = 0;
-		pack_nb = 0;
-		
-		/*
-		fprintf(stream, "pkno tileno layerno resno compno precno start_pos   end_pos       deltaSE        \n");
-		*/
-		
-		if (image_info->prog == LRCP) {	/* LRCP */
-			/*
-			fprintf(stream, "pack_nb tileno layno resno compno precno start_pos  end_pos   disto");
-			*/
-			for (layno = 0; layno < image_info->layer; layno++) {
-				for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-						for (precno = 0; precno < prec_max; precno++) {
-							start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-							end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-							disto = image_info->tile[tileno].packet[pack_nb].disto;
-							fprintf(stream, "%4d %6d %7d %5d %6d %6d %9d %9d %8e\n",
-								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_pos, disto);
-							total_disto += disto;
-							pack_nb++;
-						}
-					}
-				}
-			}
-		} /* LRCP */
-		else if (image_info->prog == RLCP) {	/* RLCP */
-			/*
-			fprintf(stream, "pack_nb tileno resno layno compno precno start_pos  end_pos   disto");
-			*/
-			for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-				for (layno = 0; layno < image_info->layer; layno++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-						for (precno = 0; precno < prec_max; precno++) {
-							start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-							end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-							disto = image_info->tile[tileno].packet[pack_nb].disto;
-							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d %9d %8e\n",
-								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_pos, disto);
-							total_disto += disto;
-							pack_nb++;
-						}
-					}
-				}
-			}
-		} /* RLCP */
-		else if (image_info->prog == RPCL) {	/* RPCL */
-			/*
-			fprintf(stream, "\npack_nb tileno resno precno compno layno start_pos  end_pos   disto\n"); 
-			*/
-			for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-				/* I suppose components have same XRsiz, YRsiz */
-				int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-				int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-				int x1 = x0 + image_info->tile_x;
-				int y1 = y0 + image_info->tile_y;
-				for(y = y0; y < y1; y++) {
-					for(x = x0; x < x1; x++) {
-						for (compno = 0; compno < image_info->comp; compno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d %9d %8e\n",
-												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* compno */
-					} /* x = x0..x1 */
-				} /* y = y0..y1 */
-			} /* resno */
-		} /* RPCL */
-		else if (image_info->prog == PCRL) {	/* PCRL */
-			/* I suppose components have same XRsiz, YRsiz */
-			int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-			int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-			int x1 = x0 + image_info->tile_x;
-			int y1 = y0 + image_info->tile_y;
-			/*
-			fprintf(stream, "\npack_nb tileno precno compno resno layno start_pos  end_pos   disto\n"); 
-			*/
-			for(y = y0; y < y1; y++) {
-				for(x = x0; x < x1; x++) {
-					for (compno = 0; compno < image_info->comp; compno++) {
-						for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
-												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* resno */
-					} /* compno */
-				} /* x = x0..x1 */
-			} /* y = y0..y1 */
-		} /* PCRL */
-		else {	/* CPRL */
-			/*
-			fprintf(stream, "\npack_nb tileno compno precno resno layno start_pos  end_pos   disto\n"); 
-			*/
-			for (compno = 0; compno < image_info->comp; compno++) {
-				/* I suppose components have same XRsiz, YRsiz */
-				int x0 = image_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tw * image_info->tile_x;
-				int y0 = image_info->tile_Ox + (int)floor( (float)tileno/(float)image_info->tw ) * image_info->tile_y;
-				int x1 = x0 + image_info->tile_x;
-				int y1 = y0 + image_info->tile_y;
-				for(y = y0; y < y1; y++) {
-					for(x = x0; x < x1; x++) {
-						for (resno = 0; resno < image_info->decomposition + 1; resno++) {
-							int prec_max = image_info->tile[tileno].pw[resno] * image_info->tile[tileno].ph[resno];
-							for (precno = 0; precno < prec_max; precno++) {
-								int pcnx = image_info->tile[tileno].pw[resno];
-								int pcx = (int) pow( 2, image_info->tile[tileno].pdx[resno] + image_info->decomposition - resno );
-								int pcy = (int) pow( 2, image_info->tile[tileno].pdy[resno] + image_info->decomposition - resno );
-								int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
-								int precno_y = (int) floor( (float)precno/(float)pcnx );
-								if (precno_y*pcy == y ) {
-									if (precno_x*pcx == x ) {
-										for (layno = 0; layno < image_info->layer; layno++) {
-											start_pos = image_info->tile[tileno].packet[pack_nb].start_pos;
-											end_pos = image_info->tile[tileno].packet[pack_nb].end_pos;
-											disto = image_info->tile[tileno].packet[pack_nb].disto;
-											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d %9d %8e\n",
-												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_pos, disto); 
-											total_disto += disto;
-											pack_nb++; 
-										}
-									}
-								}
-							} /* precno */
-						} /* resno */
-					} /* x = x0..x1 */
-				} /* y = y0..y1 */
-			} /* comno */
-		} /* CPRL */   
-	} /* tileno */
-	
-	fprintf(stream, "%8e\n", image_info->D_max); /* SE max */
-	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
-	fclose(stream);
-
-	return 1;
-}
-
-bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, char *index) {
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	int tileno, compno;
-	opj_image_info_t *image_info = NULL;
 	opj_cp_t *cp = NULL;
 
 	opj_tcd_t *tcd = NULL;	/* TCD component */
@@ -2441,31 +2325,38 @@
 	/* j2k_dump_cp(stdout, image, cp); */
 
 	/* INDEX >> */
-	image_info = j2k->image_info;
-	if (image_info && cp->index_on) {
-		image_info->index_on = cp->index_on;
-		image_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
-		image_info->image_w = image->x1 - image->x0;
-		image_info->image_h = image->y1 - image->y0;
-		image_info->prog = (&cp->tcps[0])->prg;
-		image_info->tw = cp->tw;
-		image_info->th = cp->th;
-		image_info->tile_x = cp->tdx;	/* new version parser */
-		image_info->tile_y = cp->tdy;	/* new version parser */
-		image_info->tile_Ox = cp->tx0;	/* new version parser */
-		image_info->tile_Oy = cp->ty0;	/* new version parser */
-		image_info->comp = image->numcomps;
-		image_info->layer = (&cp->tcps[0])->numlayers;
-		image_info->decomposition = (&cp->tcps[0])->tccps->numresolutions - 1;
-		image_info->D_max = 0;		/* ADD Marcela */
+	j2k->cstr_info = cstr_info;
+	if (cstr_info) {
+		int compno;
+		cstr_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->prog = (&cp->tcps[0])->prg;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	/* new version parser */
+		cstr_info->tile_y = cp->tdy;	/* new version parser */
+		cstr_info->tile_Ox = cp->tx0;	/* new version parser */
+		cstr_info->tile_Oy = cp->ty0;	/* new version parser */
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->numlayers = (&cp->tcps[0])->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (compno=0; compno < image->numcomps; compno++) {
+			cstr_info->numdecompos[compno] = (&cp->tcps[0])->tccps->numresolutions - 1;
+		}
+		cstr_info->D_max = 0.0;		/* ADD Marcela */
+		cstr_info->main_head_start = cio_tell(cio); /* position of SOC */
+		cstr_info->maxmarknum = 100;
+		cstr_info->marker = (opj_marker_info_t *) opj_malloc(cstr_info->maxmarknum * sizeof(opj_marker_info_t));
+		cstr_info->marknum = 0;
 	}
 	/* << INDEX */
-	
+
 	j2k_write_soc(j2k);
 	j2k_write_siz(j2k);
 	j2k_write_cod(j2k);
 	j2k_write_qcd(j2k);
-	
+
 	if(cp->cinema){
 		for (compno = 1; compno < image->numcomps; compno++) {
 			j2k_write_coc(j2k, compno);
@@ -2481,61 +2372,72 @@
 	if (cp->comment != NULL) {
 		j2k_write_com(j2k);
 	}
-	/* INDEX >> */
-	if(image_info && image_info->index_on) {
-		image_info->main_head_end = cio_tell(cio) - 1;
-	}
-	/* << INDEX */
 
 	j2k->totnum_tp = j2k_calculate_tp(cp,image->numcomps,image,j2k);
-	/*	 TLM Marker*/
+	/* TLM Marker*/
 	if(cp->cinema){
 		j2k_write_tlm(j2k);
 		if (cp->cinema == CINEMA4K_24) {
 			j2k_write_poc(j2k);
 		}
 	}
+
+	/* uncomment only for testing JPSEC marker writing */
+	/* j2k_write_sec(j2k); */
+
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->main_head_end = cio_tell(cio) - 1;
+	}
+	/* << INDEX */
 	/**** Main Header ENDS here ***/
-	
+
 	/* create the tile encoder */
 	tcd = tcd_create(j2k->cinfo);
 
 	/* encode each tile */
-
 	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
 		int pino;
 		int tilepartno=0;
+		/* UniPG>> */
+		int acc_pack_num = 0;
+		/* <<UniPG */
+
 
 		opj_tcp_t *tcp = &cp->tcps[tileno];
 		opj_event_msg(j2k->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
-		
+
 		j2k->curtileno = tileno;
 		j2k->cur_tp_num = 0;
-
+		tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
 		/* initialisation before tile encoding  */
 		if (tileno == 0) {
 			tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
 		} else {
 			tcd_init_encode(tcd, image, cp, j2k->curtileno);
 		}
-		
+
 		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-			image_info->tile[j2k->curtileno].num_tile = j2k->curtileno;
-			image_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
 		}
 		/* << INDEX */
 
 		for(pino = 0; pino <= tcp->numpocs; pino++) {
 			int tot_num_tp;
 			tcd->cur_pino=pino;
-			
+
 			/*Get number of tile parts*/
 			tot_num_tp = j2k_get_num_tp(cp,pino,tileno);
 			tcd->tp_pos = cp->tp_pos;
 
 			for(tilepartno = 0; tilepartno < tot_num_tp ; tilepartno++){
 				j2k->tp_num = tilepartno;
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pos =
+					cio_tell(cio) + j2k->pos_correction;
+				/* << INDEX */
 				j2k_write_sot(j2k);
 
 				if(j2k->cur_tp_num == 0 && cp->cinema == 0){
@@ -2548,83 +2450,86 @@
 					}
 				}
 
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+					cio_tell(cio) + j2k->pos_correction + 1;
+				/* << INDEX */
+
 				j2k_write_sod(j2k, tcd);
-				j2k->cur_tp_num ++;
-			}
-			
+
+				/* INDEX >> */
+				if(cstr_info) {
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_pos =
+						cio_tell(cio) + j2k->pos_correction - 1;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pack =
+						acc_pack_num;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_numpacks =
+						cstr_info->packno - acc_pack_num;
+					acc_pack_num = cstr_info->packno;
+				}
+				/* << INDEX */
+
+				j2k->cur_tp_num++;
+			}			
 		}
-		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-			image_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
 		}
-		/* << INDEX */
-		
-		
+
+
 		/*
 		if (tile->PPT) { // BAD PPT !!! 
-			FILE *PPT_file;
-			int i;
-			PPT_file=fopen("PPT","rb");
-			fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
-			for (i=0;i<tile->len_ppt;i++) {
-				unsigned char elmt;
-				fread(&elmt, 1, 1, PPT_file);
-				fwrite(&elmt,1,1,f);
-			}
-			fclose(PPT_file);
-			unlink("PPT");
+		FILE *PPT_file;
+		int i;
+		PPT_file=fopen("PPT","rb");
+		fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
+		for (i=0;i<tile->len_ppt;i++) {
+		unsigned char elmt;
+		fread(&elmt, 1, 1, PPT_file);
+		fwrite(&elmt,1,1,f);
+		}
+		fclose(PPT_file);
+		unlink("PPT");
 		}
 		*/
-		
+
 	}
-	
+
 	/* destroy the tile encoder */
 	tcd_free_encode(tcd);
 	tcd_destroy(tcd);
 
+	opj_free(j2k->cur_totnum_tp);
+
 	j2k_write_eoc(j2k);
-	
-	/* Creation of the index file */
-	if(image_info && image_info->index_on) {
-		if(!j2k_create_index(j2k, cio, image_info, index)) {
-			opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to create index file %s\n", index);
-			return false;
-		}
-	}
 
+	if(cstr_info) {
+		cstr_info->codestream_size = cio_tell(cio) + j2k->pos_correction;
+		/* UniPG>> */
+		/* The following adjustment is done to adjust the codestream size */
+		/* if SOD is not at 0 in the buffer. Useful in case of JP2, where */
+		/* the first bunch of bytes is not in the codestream              */
+		cstr_info->codestream_size -= cstr_info->main_head_start;
+		/* <<UniPG */
+	}
 
 #ifdef USE_JPWL
 	/*
-	preparation of JPWL marker segments: can be finalized only when the whole
-	codestream is known
+	preparation of JPWL marker segments
 	*/
-	if(image_info && image_info->index_on && cp->epc_on) {
-
-		/* let's begin creating a marker list, according to user wishes */
-		jpwl_prepare_marks(j2k, cio, image);
+	if(cp->epc_on) {
 
-		/* now we dump the JPWL markers on the codestream */
-		jpwl_dump_marks(j2k, cio, image);
-
-		/* do not know exactly what is this for,
-		but it gets called during index creation */
-		j2k->pos_correction = 0;
-
-		/* Re-creation of the index file, with updated info */
-		if(image_info && image_info->index_on) {
-			if(!j2k_create_index(j2k, cio, image_info, index)) {
-				opj_event_msg(j2k->cinfo, EVT_ERROR, "failed to re-create index file %s\n", index);
-				return false;
-			}
-		}
-
-		/* now we finalize the marker contents */
-		/*jpwl_finalize_marks(j2k, cio, image);*/
+		/* encode according to JPWL */
+		jpwl_encode(j2k, cio, image);
 
 	}
 #endif /* USE_JPWL */
 
-	
 	return true;
 }
 
+
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/j2k.h ./libopenjpeg/j2k.h
--- /home/robin/sldeb/trunk/libopenjpeg/j2k.h	2007-04-04 14:40:32.000000000 +0100
+++ ./libopenjpeg/j2k.h	2007-11-27 22:39:50.000000000 +0000
@@ -79,13 +79,18 @@
 #define J2K_MS_COM 0xff64	/**< COM marker value */
 /* UniPG>> */
 #ifdef USE_JPWL
-#define J2K_MS_EPC 0xff68	/**< EPC marker value (Part11) */
-#define J2K_MS_EPB 0xff66	/**< EPB marker value (Part11) */ 
-#define J2K_MS_ESD 0xff67	/**< ESD marker value (Part11) */ 
-#define J2K_MS_RED 0xff69	/**< RED marker value (Part11) */
+#define J2K_MS_EPC 0xff68	/**< EPC marker value (Part 11: JPEG 2000 for Wireless) */
+#define J2K_MS_EPB 0xff66	/**< EPB marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_ESD 0xff67	/**< ESD marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_RED 0xff69	/**< RED marker value (Part 11: JPEG 2000 for Wireless) */
 #endif /* USE_JPWL */
+#ifdef USE_JPSEC
+#define J2K_MS_SEC 0xff65    /**< SEC marker value (Part 8: Secure JPEG 2000) */
+#define J2K_MS_INSEC 0xff94  /**< INSEC marker value (Part 8: Secure JPEG 2000) */
+#endif /* USE_JPSEC */
 /* <<UniPG */
 
+
 /* ----------------------------------------------------------------------- */
 
 /**
@@ -99,7 +104,8 @@
 	J2K_STATE_TPHSOT = 0x0008, /**< the decoding process is in a tile part header and expects a SOT marker */
 	J2K_STATE_TPH    = 0x0010, /**< the decoding process is in a tile part header */
 	J2K_STATE_MT     = 0x0020, /**< the EOC marker has just been read */
-	J2K_STATE_NEOC   = 0x0040  /**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J2K_STATE_NEOC   = 0x0040, /**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J2K_STATE_ERR    = 0x0080  /**< the decoding process has encountered an error */
 } J2K_STATUS;
 
 /* ----------------------------------------------------------------------- */
@@ -222,8 +228,6 @@
 	int layer;
 	/** if == NO_LIMITATION, decode entire codestream; if == LIMIT_TO_MAIN_HEADER then only decode the main header */
 	OPJ_LIMIT_DECODING limit_decoding;
-	/** 0 = no index || 1 = index */
-	int index_on;
 	/** XTOsiz */
 	int tx0;
 	/** YTOsiz */
@@ -305,92 +309,6 @@
 } opj_cp_t;
 
 /**
-Information concerning a packet inside tile
-*/
-typedef struct opj_packet_info {
-	/** start position */
-	int start_pos;
-	/** end position */
-	int end_pos;
-	/** ADD for Marcela */
-	double disto;
-} opj_packet_info_t;
-
-/**
-Index structure : information regarding tiles inside image
-*/
-typedef struct opj_tile_info {
-	/** value of thresh for each layer by tile cfr. Marcela   */
-	double *thresh;
-	/** number of tile */
-	int num_tile;
-	/** start position */
-	int start_pos;
-	/** end position of the header */
-	int end_header;
-	/** end position */
-	int end_pos;
-	/** precinct number for each resolution level (width) */
-	int pw[33];
-	/** precinct number for each resolution level (height) */
-	int ph[33];
-	/** precinct size (in power of 2), in X for each resolution level */
-	int pdx[33];
-	/** precinct size (in power of 2), in Y for each resolution level */
-	int pdy[33];
-	/** information concerning packets inside tile */
-	opj_packet_info_t *packet;
-	/** add fixed_quality */
-	int nbpix;
-	/** add fixed_quality */
-	double distotile;
-} opj_tile_info_t;
-
-/**
-Index structure
-*/
-typedef struct opj_image_info {
-	/** 0 = no index || 1 = index */
-	int index_on;
-	/** maximum distortion reduction on the whole image (add for Marcela) */
-	double D_max;
-	/** packet number */
-	int num;
-	/** writing the packet in the index with t2_encode_packets */
-	int index_write;
-	/** image width */
-	int image_w;
-	/** image height */
-	int image_h;
-	/** progression order */
-	OPJ_PROG_ORDER prog;
-	/** tile size in x */
-	int tile_x;
-	/** tile size in y */
-	int tile_y;
-	/** */
-	int tile_Ox;
-	/** */
-	int tile_Oy;
-	/** number of tiles in X */
-	int tw;
-	/** number of tiles in Y */
-	int th;
-	/** component numbers */
-	int comp;
-	/** number of layer */
-	int layer;
-	/** number of decomposition */
-	int decomposition;
-	/** main header position */
-	int main_head_end;
-	/** codestream's size */
-	int codestream_size;
-	/** information regarding tiles inside image */
-	opj_tile_info_t *tile;
-} opj_image_info_t;
-
-/**
 JPEG-2000 codestream reader/writer
 */
 typedef struct opj_j2k {
@@ -445,7 +363,7 @@
 	/** pointer to the coding parameters */
 	opj_cp_t *cp;
 	/** helper used to write the index file */
-	opj_image_info_t *image_info;
+	opj_codestream_info_t *cstr_info;
 	/** pointer to the byte i/o stream */
 	opj_cio_t *cio;
 } opj_j2k_t;
@@ -475,16 +393,18 @@
 Decode an image from a JPEG-2000 codestream
 @param j2k J2K decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio);
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Decode an image form a JPT-stream (JPEG 2000, JPIP)
 @param j2k J2K decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio);
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a J2K compression structure
 @param cinfo Codec context info
@@ -513,10 +433,11 @@
 @param j2k J2K compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns true if successful, returns false otherwise
 */
-bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, char *index);
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/j2k_lib.c ./libopenjpeg/j2k_lib.c
--- /home/robin/sldeb/trunk/libopenjpeg/j2k_lib.c	2006-01-18 20:10:23.000000000 +0000
+++ ./libopenjpeg/j2k_lib.c	2007-11-27 22:39:50.000000000 +0000
@@ -33,7 +33,7 @@
 #endif /* WIN32 */
 #include "opj_includes.h"
 
-double opj_clock() {
+double opj_clock(void) {
 #ifdef WIN32
 	/* WIN32: use QueryPerformance (very accurate) */
     LARGE_INTEGER freq , t ;
@@ -57,20 +57,3 @@
 #endif
 }
 
-void* opj_malloc( size_t size ) {
-	void *memblock = malloc(size);
-	if(memblock) {
-		memset(memblock, 0, size);
-	}
-	return memblock;
-}
-
-void* opj_realloc( void *memblock, size_t size ) {
-	return realloc(memblock, size);
-}
-
-void opj_free( void *memblock ) {
-	free(memblock);
-}
-
-
diff -urN /home/robin/sldeb/trunk/libopenjpeg/j2k_lib.h ./libopenjpeg/j2k_lib.h
--- /home/robin/sldeb/trunk/libopenjpeg/j2k_lib.h	2006-01-18 20:10:23.000000000 +0000
+++ ./libopenjpeg/j2k_lib.h	2007-11-27 22:39:50.000000000 +0000
@@ -29,7 +29,7 @@
 @file j2k_lib.h
 @brief Internal functions
 
-The functions in J2K_LIB.C are internal utilities mainly used for memory management.
+The functions in J2K_LIB.C are internal utilities mainly used for timing.
 */
 
 /** @defgroup MISC MISC - Miscellaneous internal functions */
@@ -43,28 +43,7 @@
 Difference in successive opj_clock() calls tells you the elapsed time
 @return Returns time in seconds
 */
-double opj_clock();
-
-/**
-Allocate a memory block with elements initialized to 0
-@param size Bytes to allocate
-@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
-*/
-void* opj_malloc( size_t size );
-
-/**
-Reallocate memory blocks.
-@param memblock Pointer to previously allocated memory block
-@param size New size in bytes
-@return Returns a void pointer to the reallocated (and possibly moved) memory block
-*/
-void* opj_realloc( void *memblock, size_t size );
-
-/**
-Deallocates or frees a memory block.
-@param memblock Previously allocated memory block to be freed
-*/
-void opj_free( void *memblock );
+double opj_clock(void);
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff -urN /home/robin/sldeb/trunk/libopenjpeg/jp2.c ./libopenjpeg/jp2.c
--- /home/robin/sldeb/trunk/libopenjpeg/jp2.c	2007-05-10 15:21:09.000000000 +0100
+++ ./libopenjpeg/jp2.c	2007-11-27 22:39:50.000000000 +0000
@@ -71,7 +71,7 @@
 @return Returns true if successful, returns false otherwise
 */
 static bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index);
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
 static bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset);
 static void jp2_write_jp(opj_cio_t *cio);
 /**
@@ -404,7 +404,7 @@
 	return true;
 }
 
-static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index) {
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	unsigned int j2k_codestream_offset, j2k_codestream_length;
 	opj_jp2_box_t box;
 
@@ -416,7 +416,7 @@
 
 	/* J2K encoding */
 	j2k_codestream_offset = cio_tell(cio);
-	if(!j2k_encode(j2k, cio, image, index)) {
+	if(!j2k_encode(j2k, cio, image, cstr_info)) {
 		opj_event_msg(j2k->cinfo, EVT_ERROR, "Failed to encode image\n");
 		return 0;
 	}
@@ -507,7 +507,7 @@
 /* ----------------------------------------------------------------------- */
 
 opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo) {
-	opj_jp2_t *jp2 = (opj_jp2_t*)opj_malloc(sizeof(opj_jp2_t));
+	opj_jp2_t *jp2 = (opj_jp2_t*) opj_calloc(1, sizeof(opj_jp2_t));
 	if(jp2) {
 		jp2->cinfo = cinfo;
 		/* create the J2K codec */
@@ -541,7 +541,7 @@
 	/* further JP2 initializations go here */
 }
 
-opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio) {
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	opj_common_ptr cinfo;
 	opj_image_t *image = NULL;
 
@@ -558,11 +558,21 @@
 	}
 
 	/* J2K decoding */
-	image = j2k_decode(jp2->j2k, cio);
+	image = j2k_decode(jp2->j2k, cio, cstr_info);
 	if(!image) {
 		opj_event_msg(cinfo, EVT_ERROR, "Failed to decode J2K image\n");
 	}
 
+	/* Set Image Color Space */
+	if (jp2->enumcs == 16)
+		image->color_space = CLRSPC_SRGB;
+	else if (jp2->enumcs == 17)
+		image->color_space = CLRSPC_GRAY;
+	else if (jp2->enumcs == 18)
+		image->color_space = CLRSPC_SYCC;
+	else
+		image->color_space = CLRSPC_UNKNOWN;
+
 	return image;
 }
 
@@ -676,7 +686,7 @@
 
 }
 
-bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index) {
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 
 	/* JP2 encoding */
 
@@ -689,7 +699,7 @@
 
 	/* J2K encoding */
 
-	if(!jp2_write_jp2c(jp2, cio, image, index)) {
+	if(!jp2_write_jp2c(jp2, cio, image, cstr_info)) {
 		opj_event_msg(jp2->cinfo, EVT_ERROR, "Failed to encode image\n");
 		return false;
 	}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/jp2.h ./libopenjpeg/jp2.h
--- /home/robin/sldeb/trunk/libopenjpeg/jp2.h	2007-05-10 15:21:09.000000000 +0100
+++ ./libopenjpeg/jp2.h	2007-09-28 11:33:44.000000000 +0100
@@ -136,9 +136,10 @@
 Decode an image from a JPEG-2000 file stream
 @param jp2 JP2 decompressor handle
 @param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns a decoded image if successful, returns NULL otherwise
 */
-opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio);
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a JP2 compression structure
 @param cinfo Codec context info
@@ -163,10 +164,10 @@
 @param jp2 JP2 compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param cstr_info Codestream information structure if required, NULL otherwise
 @return Returns true if successful, returns false otherwise
 */
-bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, char *index);
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/mct.c ./libopenjpeg/mct.c
--- /home/robin/sldeb/trunk/libopenjpeg/mct.c	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/mct.c	2007-11-27 22:39:50.000000000 +0000
@@ -44,16 +44,20 @@
 /* <summary> */
 /* Foward reversible MCT. */
 /* </summary> */
-void mct_encode(int *c0, int *c1, int *c2, int n) {
+void mct_encode(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int r, g, b, y, u, v;
-		r = c0[i];
-		g = c1[i];
-		b = c2[i];
-		y = (r + (g << 1) + b) >> 2;
-		u = b - g;
-		v = r - g;
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y = (r + (g * 2) + b) >> 2;
+		int u = b - g;
+		int v = r - g;
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -63,16 +67,20 @@
 /* <summary> */
 /* Inverse reversible MCT. */
 /* </summary> */
-void mct_decode(int *c0, int *c1, int *c2, int n) {
+void mct_decode(
+		int* restrict c0,
+		int* restrict c1, 
+		int* restrict c2, 
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int y, u, v, r, g, b;
-		y = c0[i];
-		u = c1[i];
-		v = c2[i];
-		g = y - ((u + v) >> 2);
-		r = v + g;
-		b = u + g;
+	for (i = 0; i < n; ++i) {
+		int y = c0[i];
+		int u = c1[i];
+		int v = c2[i];
+		int g = y - ((u + v) >> 2);
+		int r = v + g;
+		int b = u + g;
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
@@ -89,16 +97,20 @@
 /* <summary> */
 /* Foward irreversible MCT. */
 /* </summary> */
-void mct_encode_real(int *c0, int *c1, int *c2, int n) {
+void mct_encode_real(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int r, g, b, y, u, v;
-		r = c0[i];
-		g = c1[i];
-		b = c2[i];
-		y = fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
-		u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
-		v = fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y =  fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
+		int u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
+		int v =  fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
 		c0[i] = y;
 		c1[i] = u;
 		c2[i] = v;
@@ -108,16 +120,20 @@
 /* <summary> */
 /* Inverse irreversible MCT. */
 /* </summary> */
-void mct_decode_real(int *c0, int *c1, int *c2, int n) {
+void mct_decode_real(
+		float* restrict c0,
+		float* restrict c1,
+		float* restrict c2,
+		int n)
+{
 	int i;
-	for (i = 0; i < n; i++) {
-		int y, u, v, r, g, b;
-		y = c0[i];
-		u = c1[i];
-		v = c2[i];
-		r = y + fix_mul(v, 11485);
-		g = y - fix_mul(u, 2819) - fix_mul(v, 5850);
-		b = y + fix_mul(u, 14516);
+	for(i = 0; i < n; ++i) {
+		float y = c0[i];
+		float u = c1[i];
+		float v = c2[i];
+		float r = y + (v * 1.402f);
+		float g = y - (u * 0.34413f) - (v * (0.71414f));
+		float b = y + (u * 1.772f);
 		c0[i] = r;
 		c1[i] = g;
 		c2[i] = b;
diff -urN /home/robin/sldeb/trunk/libopenjpeg/mct.h ./libopenjpeg/mct.h
--- /home/robin/sldeb/trunk/libopenjpeg/mct.h	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/mct.h	2007-11-27 22:39:50.000000000 +0000
@@ -83,7 +83,7 @@
 @param c2 Samples for blue chrominance component
 @param n Number of samples for each component
 */
-void mct_decode_real(int *c0, int *c1, int *c2, int n);
+void mct_decode_real(float* c0, float* c1, float* c2, int n);
 /**
 Get norm of the basis function used for the irreversible multi-component transform
 @param compno Number of the component (0->Y, 1->U, 2->V)
diff -urN /home/robin/sldeb/trunk/libopenjpeg/mqc.c ./libopenjpeg/mqc.c
--- /home/robin/sldeb/trunk/libopenjpeg/mqc.c	2007-02-28 14:27:20.000000000 +0000
+++ ./libopenjpeg/mqc.c	2007-09-28 11:33:44.000000000 +0100
@@ -344,7 +344,7 @@
 ==========================================================
 */
 
-opj_mqc_t* mqc_create() {
+opj_mqc_t* mqc_create(void) {
 	opj_mqc_t *mqc = (opj_mqc_t*)opj_malloc(sizeof(opj_mqc_t));
 	return mqc;
 }
@@ -371,10 +371,6 @@
 	mqc->start = bp;
 }
 
-void mqc_setcurctx(opj_mqc_t *mqc, int ctxno) {
-	mqc->curctx = &mqc->ctxs[ctxno];
-}
-
 void mqc_encode(opj_mqc_t *mqc, int d) {
 	if ((*mqc->curctx)->mps == d) {
 		mqc_codemps(mqc);
diff -urN /home/robin/sldeb/trunk/libopenjpeg/mqc.h ./libopenjpeg/mqc.h
--- /home/robin/sldeb/trunk/libopenjpeg/mqc.h	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/mqc.h	2007-09-28 11:33:44.000000000 +0100
@@ -79,7 +79,7 @@
 Create a new MQC handle 
 @return Returns a new MQC handle if successful, returns NULL otherwise
 */
-opj_mqc_t* mqc_create();
+opj_mqc_t* mqc_create(void);
 /**
 Destroy a previously created MQC handle
 @param mqc MQC handle to destroy
@@ -116,7 +116,7 @@
 @param mqc MQC handle
 @param ctxno Number that identifies the context
 */
-void mqc_setcurctx(opj_mqc_t *mqc, int ctxno);
+#define mqc_setcurctx(mqc, ctxno)	(mqc)->curctx = &(mqc)->ctxs[(int)(ctxno)]
 /**
 Encode a symbol using the MQ-coder
 @param mqc MQC handle
diff -urN /home/robin/sldeb/trunk/libopenjpeg/openjpeg.c ./libopenjpeg/openjpeg.c
--- /home/robin/sldeb/trunk/libopenjpeg/openjpeg.c	2007-04-04 14:40:32.000000000 +0100
+++ ./libopenjpeg/openjpeg.c	2007-11-27 22:39:50.000000000 +0000
@@ -53,7 +53,7 @@
 /* ---------------------------------------------------------------------- */
 
 
-const char* OPJ_CALLCONV opj_version() {
+const char* OPJ_CALLCONV opj_version(void) {
     return OPENJPEG_VERSION;
 }
 
@@ -148,20 +148,23 @@
 }
 
 opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio) {
+	return opj_decode_with_info(dinfo, cio, NULL);
+}
+
+opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
 	if(dinfo && cio) {
 		switch(dinfo->codec_format) {
 			case CODEC_J2K:
-				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio);
+				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
 			case CODEC_JPT:
-				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio);
+				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
 			case CODEC_JP2:
-				return jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio);
+				return jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio, cstr_info);
 			case CODEC_UNKNOWN:
 			default:
 				break;
 		}
 	}
-
 	return NULL;
 }
 
@@ -203,10 +206,10 @@
 		/* destroy the codec */
 		switch(cinfo->codec_format) {
 			case CODEC_J2K:
-				j2k_destroy_decompress((opj_j2k_t*)cinfo->j2k_handle);
+				j2k_destroy_compress((opj_j2k_t*)cinfo->j2k_handle);
 				break;
 			case CODEC_JP2:
-				jp2_destroy_decompress((opj_jp2_t*)cinfo->jp2_handle);
+				jp2_destroy_compress((opj_jp2_t*)cinfo->jp2_handle);
 				break;
 			case CODEC_JPT:
 			case CODEC_UNKNOWN:
@@ -288,20 +291,39 @@
 }
 
 bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index) {
+	if (index != NULL)
+		opj_event_msg((opj_common_ptr)cinfo, EVT_WARNING, "Set index to NULL when calling the opj_encode function.\n"
+		"To extract the index, use the opj_encode_with_info() function.\n"
+		"No index will be generated during this encoding\n");
+	return opj_encode_with_info(cinfo, cio, image, NULL);
+}
+
+bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
 	if(cinfo && cio && image) {
 		switch(cinfo->codec_format) {
 			case CODEC_J2K:
-				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, index);
+				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, cstr_info);
 			case CODEC_JP2:
-				return jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, index);
+				return jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, cstr_info);
 			case CODEC_JPT:
 			case CODEC_UNKNOWN:
 			default:
 				break;
 		}
 	}
-
 	return false;
 }
 
-
+void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info) {
+	if (cstr_info) {
+		int tileno;
+		for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+			opj_tile_info_t *tile_info = &cstr_info->tile[tileno];
+			opj_free(tile_info->thresh);
+			opj_free(tile_info->packet);
+			opj_free(tile_info->tp);
+		}
+		opj_free(cstr_info->tile);
+		opj_free(cstr_info->marker);
+	}
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/openjpeg.h ./libopenjpeg/openjpeg.h
--- /home/robin/sldeb/trunk/libopenjpeg/openjpeg.h	2007-06-04 14:27:25.000000000 +0100
+++ ./libopenjpeg/openjpeg.h	2007-11-27 22:39:50.000000000 +0000
@@ -104,6 +104,7 @@
 #define JPWL_EXPECTED_COMPONENTS 3 /**< Expect this number of components, so you'll find better the first EPB */
 #define JPWL_MAXIMUM_TILES 8192 /**< Expect this maximum number of tiles, to avoid some crashes */
 #define JPWL_MAXIMUM_HAMMING 2 /**< Expect this maximum number of bit errors in marker id's */
+#define JPWL_MAXIMUM_EPB_ROOM 65450 /**< Expect this maximum number of bytes for composition of EPBs */
 /* <<UniPG */
 
 /* 
@@ -302,9 +303,9 @@
 	char infile[OPJ_PATH_LEN];
 	/** output file name */
 	char outfile[OPJ_PATH_LEN];
-	/** creation of an index file, default to 0 (false) */
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
 	int index_on;
-	/** index file name */
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
 	char index[OPJ_PATH_LEN];
 	/** subimage encoding: origin image offset in x direction */
 	int image_offset_x0;
@@ -579,6 +580,142 @@
 	int sgnd;
 } opj_image_cmptparm_t;
 
+/* 
+==========================================================
+   Information on the JPEG 2000 codestream
+==========================================================
+*/
+
+/**
+Index structure : Information concerning a packet inside tile
+*/
+typedef struct opj_packet_info {
+	/** packet start position (including SOP marker if it exists) */
+	int start_pos;
+	/** end of packet header position (including EPH marker if it exists)*/
+	int end_ph_pos;
+	/** packet end position */
+	int end_pos;
+	/** packet distorsion */
+	double disto;
+} opj_packet_info_t;
+
+/**
+Index structure : Information concerning tile-parts
+*/
+typedef struct opj_tp_info {
+	/** start position of tile part */
+	int tp_start_pos;
+	/** end position of tile part header */
+	int tp_end_header;
+	/** end position of tile part */
+	int tp_end_pos;
+	/** start packet of tile part */
+	int tp_start_pack;
+	/** number of packets of tile part */
+	int tp_numpacks;
+} opj_tp_info_t;
+
+/**
+Index structure : information regarding tiles 
+*/
+typedef struct opj_tile_info {
+	/** value of thresh for each layer by tile cfr. Marcela   */
+	double *thresh;
+	/** number of tile */
+	int tileno;
+	/** start position */
+	int start_pos;
+	/** end position of the header */
+	int end_header;
+	/** end position */
+	int end_pos;
+	/** precinct number for each resolution level (width) */
+	int pw[33];
+	/** precinct number for each resolution level (height) */
+	int ph[33];
+	/** precinct size (in power of 2), in X for each resolution level */
+	int pdx[33];
+	/** precinct size (in power of 2), in Y for each resolution level */
+	int pdy[33];
+	/** information concerning packets inside tile */
+	opj_packet_info_t *packet;
+	/** add fixed_quality */
+	int numpix;
+	/** add fixed_quality */
+	double distotile;
+	/** number of tile parts */
+	int num_tps;
+	/** information concerning tile parts */
+	opj_tp_info_t *tp;
+} opj_tile_info_t;
+
+/* UniPG>> */
+/**
+Marker structure
+*/
+typedef struct opj_marker_info_t {
+	/** marker type */
+	unsigned short int type;
+	/** position in codestream */
+	int pos;
+	/** length, marker val included */
+	int len;
+} opj_marker_info_t;
+/* <<UniPG */
+
+/**
+Index structure of the codestream
+*/
+typedef struct opj_codestream_info {
+	/** maximum distortion reduction on the whole image (add for Marcela) */
+	double D_max;
+	/** packet number */
+	int packno;
+	/** writing the packet in the index with t2_encode_packets */
+	int index_write;
+	/** image width */
+	int image_w;
+	/** image height */
+	int image_h;
+	/** progression order */
+	OPJ_PROG_ORDER prog;
+	/** tile size in x */
+	int tile_x;
+	/** tile size in y */
+	int tile_y;
+	/** */
+	int tile_Ox;
+	/** */
+	int tile_Oy;
+	/** number of tiles in X */
+	int tw;
+	/** number of tiles in Y */
+	int th;
+	/** component numbers */
+	int numcomps;
+	/** number of layer */
+	int numlayers;
+	/** number of decomposition for each component */
+	int *numdecompos;
+/* UniPG>> */
+	/** number of markers */
+	int marknum;
+	/** list of markers */
+	opj_marker_info_t *marker;
+	/** actual size of markers array */
+	int maxmarknum;
+/* <<UniPG */
+	/** main header position */
+	int main_head_start;
+	/** main header position */
+	int main_head_end;
+	/** codestream's size */
+	int codestream_size;
+	/** information regarding tiles inside image */
+	opj_tile_info_t *tile;
+} opj_codestream_info_t;
+
 #ifdef __cplusplus
 extern "C" {
 #endif
@@ -590,7 +727,7 @@
 ==========================================================
 */
 
-OPJ_API const char * OPJ_CALLCONV opj_version();
+OPJ_API const char * OPJ_CALLCONV opj_version(void);
 
 /* 
 ==========================================================
@@ -688,12 +825,21 @@
 */
 OPJ_API void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters);
 /**
-Decode an image from a JPEG-2000 codestream
+Decode an image from a JPEG-2000 codestream 
 @param dinfo decompressor handle
 @param cio Input buffer stream
 @return Returns a decoded image if successful, returns NULL otherwise
 */
 OPJ_API opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio);
+
+/**
+Decode an image from a JPEG-2000 codestream and extract the codestream information
+@param dinfo decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
 /**
 Creates a J2K/JP2 compression structure
 @param format Coder to select
@@ -729,9 +875,9 @@
 OPJ_API void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters);
 /**
 Setup the encoder parameters using the current image and using user parameters. 
-@param cinfo compressor handle
-@param parameters compression parameters
-@param image input filled image
+@param cinfo Compressor handle
+@param parameters Compression parameters
+@param image Input filled image
 */
 OPJ_API void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image);
 /**
@@ -739,10 +885,24 @@
 @param cinfo compressor handle
 @param cio Output buffer stream
 @param image Image to encode
-@param index Name of the index file if required, NULL otherwise
+@param index Depreacted -> Set to NULL. To extract index, used opj_encode_wci()
 @return Returns true if successful, returns false otherwise
 */
 OPJ_API bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index);
+/**
+Encode an image into a JPEG-2000 codestream and extract the codestream information
+@param cinfo compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+OPJ_API bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+/**
+Destroy Codestream information after compression or decompression
+@param cstr_info Codestream information structure
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info);
 
 #ifdef __cplusplus
 }
diff -urN /home/robin/sldeb/trunk/libopenjpeg/opj_includes.h ./libopenjpeg/opj_includes.h
--- /home/robin/sldeb/trunk/libopenjpeg/opj_includes.h	2007-03-20 17:15:18.000000000 +0000
+++ ./libopenjpeg/opj_includes.h	2007-11-27 22:39:50.000000000 +0000
@@ -54,6 +54,11 @@
  ==========================================================
 */
 
+/* Ignore GCC attributes if this is not GCC */
+#ifndef __GNUC__
+	#define __attribute__(x) /* __attribute__(x) */
+#endif
+
 /*
 The inline keyword is supported by C99 but not by C90. 
 Most compilers implement their own version of this keyword ... 
@@ -71,7 +76,32 @@
 	#endif /* defined(<Compiler>) */
 #endif /* INLINE */
 
+/* Are restricted pointers available? (C99) */
+#if (__STDC_VERSION__ != 199901L)
+	/* Not a C99 compiler */
+	#ifdef __GNUC__
+		#define restrict __restrict__
+	#else
+		#define restrict /* restrict */
+	#endif
+#endif
+
+/* MSVC does not have lrintf */
+#ifdef _MSC_VER
+static INLINE long lrintf(float f){
+	int i;
+
+	_asm{
+		fld f
+		fistp i
+	};
+
+	return i;
+}
+#endif
+
 #include "j2k_lib.h"
+#include "opj_malloc.h"
 #include "event.h"
 #include "cio.h"
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/opj_malloc.h ./libopenjpeg/opj_malloc.h
--- /home/robin/sldeb/trunk/libopenjpeg/opj_malloc.h	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/opj_malloc.h	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __OPJ_MALLOC_H
+#define __OPJ_MALLOC_H
+/**
+@file opj_malloc.h
+@brief Internal functions
+
+The functions in opj_malloc.h are internal utilities used for memory management.
+*/
+
+/** @defgroup MISC MISC - Miscellaneous internal functions */
+/*@{*/
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Allocate an uninitialized memory block
+@param size Bytes to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+#define opj_malloc(size) malloc(size)
+
+/**
+Allocate a memory block with elements initialized to 0
+@param num Blocks to allocate
+@param size Bytes per block to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+#define opj_calloc(num, size) calloc(num, size)
+
+/**
+Allocate memory aligned to a 16 byte boundry
+@param size Bytes to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+/* FIXME: These should be set with cmake tests, but we're currently not requiring use of cmake */
+#ifdef WIN32
+	/* Someone should tell the mingw people that their malloc.h ought to provide _mm_malloc() */
+	#ifdef __GNUC__
+		#include <mm_malloc.h>
+		#define HAVE_MM_MALLOC
+	#else /* MSVC, Intel C++ */
+		#include <malloc.h>
+		#ifdef _mm_malloc
+			#define HAVE_MM_MALLOC
+		#endif
+	#endif
+#else /* Not WIN32 */
+	#if defined(__sun)
+		#define HAVE_MEMALIGN
+	/* Linux x86_64 and OSX always align allocations to 16 bytes */
+	#elif !defined(__amd64__) && !defined(__APPLE__)
+		/* FIXME: Yes, this is a big assumption */
+		#define HAVE_POSIX_MEMALIGN
+	#endif
+#endif
+
+#define opj_aligned_malloc(size) malloc(size)
+#define opj_aligned_free(m) free(m)
+
+#ifdef HAVE_MM_MALLOC
+	#undef opj_aligned_malloc
+	#define opj_aligned_malloc(size) _mm_malloc(size, 16)
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) _mm_free(m)
+#endif
+
+#ifdef HAVE_MEMALIGN
+	extern void* memalign(size_t, size_t);
+	#undef opj_aligned_malloc
+	#define opj_aligned_malloc(size) memalign(16, (size))
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) free(m)
+#endif
+
+#ifdef HAVE_POSIX_MEMALIGN
+	#undef opj_aligned_malloc
+	extern int posix_memalign(void**, size_t, size_t);
+
+	static INLINE void* __attribute__ ((malloc)) opj_aligned_malloc(size_t size){
+		void* mem = NULL;
+		posix_memalign(&mem, 16, size);
+		return mem;
+	}
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) free(m)
+#endif
+
+/**
+Reallocate memory blocks.
+@param memblock Pointer to previously allocated memory block
+@param size New size in bytes
+@return Returns a void pointer to the reallocated (and possibly moved) memory block
+*/
+#define opj_realloc(m, s) realloc(m, s)
+
+/**
+Deallocates or frees a memory block.
+@param memblock Previously allocated memory block to be freed
+*/
+#define opj_free(m) free(m)
+
+#ifdef __GNUC__
+#pragma GCC poison malloc calloc realloc free
+#endif
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __OPJ_MALLOC_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/pi.c ./libopenjpeg/pi.c
--- /home/robin/sldeb/trunk/libopenjpeg/pi.c	2007-04-04 14:40:32.000000000 +0100
+++ ./libopenjpeg/pi.c	2007-11-27 22:39:50.000000000 +0000
@@ -413,17 +413,15 @@
 	opj_pi_iterator_t *pi = NULL;
 	opj_tcp_t *tcp = NULL;
 	opj_tccp_t *tccp = NULL;
-	size_t array_size;
-	
+
 	tcp = &cp->tcps[tileno];
 
-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
 	if(!pi) {
 		/* TODO: throw an error */
 		return NULL;
 	}
-	
+
 	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
 		int maxres = 0;
 		int maxprec = 0;
@@ -436,14 +434,12 @@
 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
 		pi[pino].numcomps = image->numcomps;
 
-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
 		if(!pi[pino].comps) {
 			/* TODO: throw an error */
 			pi_destroy(pi, cp, tileno);
 			return NULL;
 		}
-		memset(pi[pino].comps, 0, array_size);
 		
 		for (compno = 0; compno < pi->numcomps; compno++) {
 			int tcx0, tcy0, tcx1, tcy1;
@@ -453,8 +449,7 @@
 			comp->dy = image->comps[compno].dy;
 			comp->numresolutions = tccp->numresolutions;
 
-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
+			comp->resolutions = (opj_pi_resolution_t*) opj_calloc(comp->numresolutions, sizeof(opj_pi_resolution_t));
 			if(!comp->resolutions) {
 				/* TODO: throw an error */
 				pi_destroy(pi, cp, tileno);
@@ -507,8 +502,7 @@
 		pi[pino].step_l = maxres * pi[pino].step_r;
 		
 		if (pino == 0) {
-			array_size = image->numcomps * maxres * tcp->numlayers * maxprec * sizeof(short int);
-			pi[pino].include = (short int *) opj_malloc(array_size);
+			pi[pino].include = (short int*) opj_calloc(image->numcomps * maxres * tcp->numlayers * maxprec, sizeof(short int));
 			if(!pi[pino].include) {
 				/* TODO: throw an error */
 				pi_destroy(pi, cp, tileno);
@@ -554,15 +548,13 @@
 	opj_pi_iterator_t *pi = NULL;
 	opj_tcp_t *tcp = NULL;
 	opj_tccp_t *tccp = NULL;
-	size_t array_size;
 	
 	tcp = &cp->tcps[tileno];
 
-	array_size = (tcp->numpocs + 1) * sizeof(opj_pi_iterator_t);
-	pi = (opj_pi_iterator_t *) opj_malloc(array_size);
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
 	if(!pi) {	return NULL;}
 	pi->tp_on = cp->tp_on;
-	
+
 	for(pino = 0;pino < tcp->numpocs+1 ; pino ++){
 		p = tileno % cp->tw;
 		q = tileno / cp->tw;
@@ -573,13 +565,11 @@
 		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
 		pi[pino].numcomps = image->numcomps;
 		
-		array_size = image->numcomps * sizeof(opj_pi_comp_t);
-		pi[pino].comps = (opj_pi_comp_t *) opj_malloc(array_size);
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
 		if(!pi[pino].comps) {
 			pi_destroy(pi, cp, tileno);
 			return NULL;
 		}
-		memset(pi[pino].comps, 0, array_size);
 		
 		for (compno = 0; compno < pi[pino].numcomps; compno++) {
 			int tcx0, tcy0, tcx1, tcy1;
@@ -589,8 +579,7 @@
 			comp->dy = image->comps[compno].dy;
 			comp->numresolutions = tccp->numresolutions;
 
-			array_size = comp->numresolutions * sizeof(opj_pi_resolution_t);
-			comp->resolutions =	(opj_pi_resolution_t *) opj_malloc(array_size);
+			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(comp->numresolutions * sizeof(opj_pi_resolution_t));
 			if(!comp->resolutions) {
 				pi_destroy(pi, cp, tileno);
 				return NULL;
@@ -653,8 +642,7 @@
 		}
 
 		if (pino == 0) {
-			array_size = tcp->numlayers * pi[pino].step_l * sizeof(short int);
-			pi[pino].include = (short int *) opj_malloc(array_size);
+			pi[pino].include = (short int*) opj_calloc(tcp->numlayers * pi[pino].step_l, sizeof(short int));
 			if(!pi[pino].include) {
 				pi_destroy(pi, cp, tileno);
 				return NULL;
@@ -665,7 +653,7 @@
 		}
 		
 		/* Generation of boundaries for each prog flag*/
-			if(tcp->POC & (t2_mode == FINAL_PASS)){
+			if(tcp->POC && ( cp->cinema || ((!cp->cinema) && (t2_mode == FINAL_PASS)))){
 				tcp->pocs[pino].compS= tcp->pocs[pino].compno0;
 				tcp->pocs[pino].compE= tcp->pocs[pino].compno1;
 				tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
@@ -820,7 +808,7 @@
 }
 
 
-void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos){
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode){
 	char *prog;
 	int i,l;
 	int incr_top=1,resetX=0;
@@ -831,7 +819,7 @@
 	pi[pino].first = 1;
 	pi[pino].poc.prg = tcp->prg;	
 	
-	if(!(cp->tp_on)){
+	if(!(cp->tp_on && ((!cp->cinema && (t2_mode == FINAL_PASS)) || cp->cinema))){
 		pi[pino].poc.resno0 = tcp->resS;
 		pi[pino].poc.resno1 = tcp->resE;
 		pi[pino].poc.compno0 = tcp->compS;
@@ -1076,3 +1064,4 @@
 }
 
 
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/pi.h ./libopenjpeg/pi.h
--- /home/robin/sldeb/trunk/libopenjpeg/pi.h	2007-04-04 14:40:32.000000000 +0100
+++ ./libopenjpeg/pi.h	2007-09-28 11:33:44.000000000 +0100
@@ -118,7 +118,7 @@
 @param tpnum Tile part number of the current tile
 @param tppos The position of the tile part flag in the progression order
 */
-void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos);
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode);
 /**
 Create a packet iterator for Decoder
 @param image Raw image for which the packets will be listed
diff -urN /home/robin/sldeb/trunk/libopenjpeg/raw.c ./libopenjpeg/raw.c
--- /home/robin/sldeb/trunk/libopenjpeg/raw.c	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/raw.c	2007-09-28 11:33:44.000000000 +0100
@@ -42,7 +42,7 @@
 ==========================================================
 */
 
-opj_raw_t* raw_create() {
+opj_raw_t* raw_create(void) {
 	opj_raw_t *raw = (opj_raw_t*)opj_malloc(sizeof(opj_raw_t));
 	return raw;
 }
diff -urN /home/robin/sldeb/trunk/libopenjpeg/raw.h ./libopenjpeg/raw.h
--- /home/robin/sldeb/trunk/libopenjpeg/raw.h	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/raw.h	2007-09-28 11:33:44.000000000 +0100
@@ -67,7 +67,7 @@
 Create a new RAW handle 
 @return Returns a new RAW handle if successful, returns NULL otherwise
 */
-opj_raw_t* raw_create();
+opj_raw_t* raw_create(void);
 /**
 Destroy a previously created RAW handle
 @param raw RAW handle to destroy
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/all-wcprops ./libopenjpeg/.svn/all-wcprops
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/all-wcprops	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,263 @@
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/482/trunk/libopenjpeg
+END
+raw.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/418/trunk/libopenjpeg/raw.h
+END
+dwt.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/476/trunk/libopenjpeg/dwt.c
+END
+tgt.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/467/trunk/libopenjpeg/tgt.c
+END
+t1_luts.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/424/trunk/libopenjpeg/t1_luts.h
+END
+dwt.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/476/trunk/libopenjpeg/dwt.h
+END
+tgt.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/330/trunk/libopenjpeg/tgt.h
+END
+openjpeg.c
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/469/trunk/libopenjpeg/openjpeg.c
+END
+openjpeg.h
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/480/trunk/libopenjpeg/openjpeg.h
+END
+image.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/467/trunk/libopenjpeg/image.c
+END
+opj_malloc.h
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/467/trunk/libopenjpeg/opj_malloc.h
+END
+j2k.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/482/trunk/libopenjpeg/j2k.c
+END
+image.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/418/trunk/libopenjpeg/image.h
+END
+jp2.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/467/trunk/libopenjpeg/jp2.c
+END
+j2k.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/482/trunk/libopenjpeg/j2k.h
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/462/trunk/libopenjpeg/CMakeLists.txt
+END
+jpt.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/330/trunk/libopenjpeg/jpt.c
+END
+int.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/330/trunk/libopenjpeg/int.h
+END
+jp2.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/453/trunk/libopenjpeg/jp2.h
+END
+jpt.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/330/trunk/libopenjpeg/jpt.h
+END
+t1_generate_luts.c
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/424/trunk/libopenjpeg/t1_generate_luts.c
+END
+pi.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/467/trunk/libopenjpeg/pi.c
+END
+bio.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/418/trunk/libopenjpeg/bio.c
+END
+cio.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/453/trunk/libopenjpeg/cio.c
+END
+tcd.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/482/trunk/libopenjpeg/tcd.c
+END
+j2k_lib.c
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/467/trunk/libopenjpeg/j2k_lib.c
+END
+pi.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/411/trunk/libopenjpeg/pi.h
+END
+bio.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/418/trunk/libopenjpeg/bio.h
+END
+cio.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/330/trunk/libopenjpeg/cio.h
+END
+tcd.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/479/trunk/libopenjpeg/tcd.h
+END
+mqc.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/421/trunk/libopenjpeg/mqc.c
+END
+j2k_lib.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/467/trunk/libopenjpeg/j2k_lib.h
+END
+event.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/306/trunk/libopenjpeg/event.c
+END
+opj_includes.h
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/476/trunk/libopenjpeg/opj_includes.h
+END
+mct.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/476/trunk/libopenjpeg/mct.c
+END
+t1.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/479/trunk/libopenjpeg/t1.c
+END
+mqc.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/421/trunk/libopenjpeg/mqc.h
+END
+t2.c
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/479/trunk/libopenjpeg/t2.c
+END
+event.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/223/trunk/libopenjpeg/event.h
+END
+mct.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/476/trunk/libopenjpeg/mct.h
+END
+raw.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/418/trunk/libopenjpeg/raw.c
+END
+t1.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/476/trunk/libopenjpeg/t1.h
+END
+t2.h
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/453/trunk/libopenjpeg/t2.h
+END
+fix.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/372/trunk/libopenjpeg/fix.h
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/dir-prop-base ./libopenjpeg/.svn/dir-prop-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/dir-prop-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/dir-prop-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,10 @@
+K 10
+svn:ignore
+V 35
+obj
+obj.w32
+bin
+bin.w32
+lib
+lib.w32
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/entries ./libopenjpeg/.svn/entries
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,584 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/libopenjpeg
+http://www.openjpeg.org/svn
+
+
+
+2007-11-27T14:00:45.535020Z
+482
+devaux
+has-props
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+raw.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+8a884c09841816c84714c9eab199d48a
+2007-08-21T12:02:23.517635Z
+418
+devaux
+has-props
+
+dwt.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+91111245da12962b5da46d3f98b4c9dd
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+tgt.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+7d2b0f43e8fa486669756266f94ee9fc
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+t1_luts.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+0523464ab01338f5935b5f385b66970f
+2007-08-21T12:51:57.203293Z
+424
+devaux
+
+dwt.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+58c8b0f09689c09faeb429d233a9d4b4
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+tgt.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+47b8e51ab6590291317949553685f650
+2007-01-15T09:55:40.370636Z
+330
+devaux
+has-props
+
+openjpeg.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+c7587eb54cf0d52c6085e8d0f979ee75
+2007-11-05T13:05:07.639602Z
+469
+unipg
+has-props
+
+openjpeg.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+f086ed4acf931cb4e63c55b00c10d46b
+2007-11-14T11:34:48.065882Z
+480
+devaux
+has-props
+
+image.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+4f83ff3ccc69b068827ebd11c9700603
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+opj_malloc.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+8ad3b8de07d90ef2afb93224cd041754
+2007-10-18T12:26:11.065274Z
+467
+devaux
+
+j2k.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+c9361f37ea7c338258606f5aaf2819dd
+2007-11-27T14:00:45.535020Z
+482
+devaux
+has-props
+
+image.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+1c64ac8496ca0432766df953aa360e0d
+2007-08-21T12:02:23.517635Z
+418
+devaux
+has-props
+
+jp2.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+036a35dca551dda8b4f838ee26d21188
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+j2k.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+87a97863c41f8ac34867352c5f8b0ae1
+2007-11-27T14:00:45.535020Z
+482
+devaux
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+b0df8302f9704aa49c01dd6c0ff198e8
+2007-09-25T14:54:49.286868Z
+462
+gdcm
+has-props
+
+jpt.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+b431cdbc5ac3fcca7d081b4612e610a1
+2007-01-15T09:55:40.370636Z
+330
+devaux
+has-props
+
+int.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+973d2f6c68017ea8b32a2e0648b9e3eb
+2007-01-15T09:55:40.370636Z
+330
+devaux
+has-props
+
+jp2.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+dae7df2cfe89d82a27f2735253a703e6
+2007-09-07T15:01:55.096985Z
+453
+devaux
+has-props
+
+jpt.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+357d69e915352edf153abaac1720a5cc
+2007-01-15T09:55:40.370636Z
+330
+devaux
+has-props
+
+t1_generate_luts.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+a29f57b59236d14f7ee51b72bc84dec7
+2007-08-21T12:51:57.203293Z
+424
+devaux
+
+pi.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+23d63509c636732a6e71fbfc9cc4bc82
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+bio.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+c967ce421846b4aba5d14b6241b2dc00
+2007-08-21T12:02:23.517635Z
+418
+devaux
+has-props
+
+cio.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+6cafdc1edf336ca9c304706f83d54f57
+2007-09-07T15:01:55.096985Z
+453
+devaux
+has-props
+
+tcd.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+e2b81ae81909604e10be591070bc96ba
+2007-11-27T14:00:45.535020Z
+482
+devaux
+has-props
+
+j2k_lib.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+e7052f402269efd1fac6b328b23f4f49
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+pi.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+7b32a73946d2ddce2d08bc707af906da
+2007-08-08T09:41:16.064953Z
+411
+devaux
+has-props
+
+bio.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+34554a1889a3830f2c720a9561ecba5b
+2007-08-21T12:02:23.517635Z
+418
+devaux
+has-props
+
+cio.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+a804e59ff0f739810532510d22e2241a
+2007-01-15T09:55:40.370636Z
+330
+devaux
+has-props
+
+tcd.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+7929853adb23453de8a49e1b92de835b
+2007-11-14T10:52:02.601561Z
+479
+devaux
+has-props
+
+mqc.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+74cf6dde1288c8fdf63c162d6b78b0bd
+2007-08-21T12:30:08.789517Z
+421
+devaux
+has-props
+
+j2k_lib.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+8f300160c548c40892eb2392a5f3b75e
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+event.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+11aa6b68dcdd3975ab30520806b586df
+2006-12-04T14:57:09.403049Z
+306
+devaux
+has-props
+
+opj_includes.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+d84a4c84aef35677e4f9494bd627160a
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+mct.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+171eb644b2e0b003040c21c7a16820a1
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+t1.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+c22a16c8d11db8f482c8772020f1f28e
+2007-11-14T10:52:02.601561Z
+479
+devaux
+has-props
+
+mqc.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+37342c6ccd11981d865154b03bbc3e4c
+2007-08-21T12:30:08.789517Z
+421
+devaux
+has-props
+
+t2.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+4d382d001a0fa6c08ff880b210b6f645
+2007-11-14T10:52:02.601561Z
+479
+devaux
+has-props
+
+event.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+4fd9a39faaa67b5222cc1f85ff2c555a
+2006-01-25T09:17:16.000000Z
+223
+descampe
+has-props
+
+mct.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+56a35d724d1258bb138a23e47a9f0188
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+raw.c
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+b5ceacfc944788a96621791fd258725f
+2007-08-21T12:02:23.517635Z
+418
+devaux
+has-props
+
+t1.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+e594edfee24a0ce253dbca4003096d4e
+2007-11-13T17:35:12.457590Z
+476
+devaux
+has-props
+
+t2.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+b6d87ad29c3d3fa6846f689c3128595c
+2007-09-07T15:01:55.096985Z
+453
+devaux
+has-props
+
+fix.h
+file
+
+
+
+
+2007-09-28T10:33:44.000000Z
+1ed0d0553a647a83d105482a6a669230
+2007-04-05T14:24:19.038490Z
+372
+devaux
+has-props
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/format ./libopenjpeg/.svn/format
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/format	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/bio.c.svn-base ./libopenjpeg/.svn/prop-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/bio.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/bio.h.svn-base ./libopenjpeg/.svn/prop-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/bio.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/cio.c.svn-base ./libopenjpeg/.svn/prop-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/cio.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/cio.h.svn-base ./libopenjpeg/.svn/prop-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/cio.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/CMakeLists.txt.svn-base ./libopenjpeg/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/dwt.c.svn-base ./libopenjpeg/.svn/prop-base/dwt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/dwt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/dwt.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/dwt.h.svn-base ./libopenjpeg/.svn/prop-base/dwt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/dwt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/dwt.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/event.c.svn-base ./libopenjpeg/.svn/prop-base/event.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/event.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/event.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/event.h.svn-base ./libopenjpeg/.svn/prop-base/event.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/event.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/event.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/fix.h.svn-base ./libopenjpeg/.svn/prop-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/fix.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/image.c.svn-base ./libopenjpeg/.svn/prop-base/image.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/image.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/image.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/image.h.svn-base ./libopenjpeg/.svn/prop-base/image.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/image.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/image.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/int.h.svn-base ./libopenjpeg/.svn/prop-base/int.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/int.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k.c.svn-base ./libopenjpeg/.svn/prop-base/j2k.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/j2k.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k.h.svn-base ./libopenjpeg/.svn/prop-base/j2k.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/j2k.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k_lib.c.svn-base ./libopenjpeg/.svn/prop-base/j2k_lib.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/j2k_lib.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k_lib.h.svn-base ./libopenjpeg/.svn/prop-base/j2k_lib.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/j2k_lib.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/j2k_lib.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jp2.c.svn-base ./libopenjpeg/.svn/prop-base/jp2.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jp2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/jp2.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jp2.h.svn-base ./libopenjpeg/.svn/prop-base/jp2.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jp2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/jp2.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jpt.c.svn-base ./libopenjpeg/.svn/prop-base/jpt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jpt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/jpt.c.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jpt.h.svn-base ./libopenjpeg/.svn/prop-base/jpt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/jpt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/jpt.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mct.c.svn-base ./libopenjpeg/.svn/prop-base/mct.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mct.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/mct.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mct.h.svn-base ./libopenjpeg/.svn/prop-base/mct.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mct.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/mct.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mqc.c.svn-base ./libopenjpeg/.svn/prop-base/mqc.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mqc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/mqc.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mqc.h.svn-base ./libopenjpeg/.svn/prop-base/mqc.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/mqc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/mqc.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/openjpeg.c.svn-base ./libopenjpeg/.svn/prop-base/openjpeg.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/openjpeg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/openjpeg.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/openjpeg.h.svn-base ./libopenjpeg/.svn/prop-base/openjpeg.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/openjpeg.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/openjpeg.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/opj_includes.h.svn-base ./libopenjpeg/.svn/prop-base/opj_includes.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/opj_includes.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/opj_includes.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/pi.c.svn-base ./libopenjpeg/.svn/prop-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/pi.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/pi.h.svn-base ./libopenjpeg/.svn/prop-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/pi.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/raw.c.svn-base ./libopenjpeg/.svn/prop-base/raw.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/raw.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/raw.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/raw.h.svn-base ./libopenjpeg/.svn/prop-base/raw.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/raw.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/raw.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t1.c.svn-base ./libopenjpeg/.svn/prop-base/t1.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t1.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/t1.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t1.h.svn-base ./libopenjpeg/.svn/prop-base/t1.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t1.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/t1.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t2.c.svn-base ./libopenjpeg/.svn/prop-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/t2.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t2.h.svn-base ./libopenjpeg/.svn/prop-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/t2.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tcd.c.svn-base ./libopenjpeg/.svn/prop-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/tcd.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tcd.h.svn-base ./libopenjpeg/.svn/prop-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/tcd.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tgt.c.svn-base ./libopenjpeg/.svn/prop-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/tgt.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tgt.h.svn-base ./libopenjpeg/.svn/prop-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/prop-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/prop-base/tgt.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/bio.c.svn-base ./libopenjpeg/.svn/text-base/bio.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/bio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/bio.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,187 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup BIO BIO - Individual bit input-output stream */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Write a bit
+@param bio BIO handle
+@param b Bit to write (0 or 1)
+*/
+static void bio_putbit(opj_bio_t *bio, int b);
+/**
+Read a bit
+@param bio BIO handle
+@return Returns the read bit
+*/
+static int bio_getbit(opj_bio_t *bio);
+/**
+Write a byte
+@param bio BIO handle
+@return Returns 0 if successful, returns 1 otherwise
+*/
+static int bio_byteout(opj_bio_t *bio);
+/**
+Read a byte
+@param bio BIO handle
+@return Returns 0 if successful, returns 1 otherwise
+*/
+static int bio_bytein(opj_bio_t *bio);
+
+/*@}*/
+
+/*@}*/
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static int bio_byteout(opj_bio_t *bio) {
+	bio->buf = (bio->buf << 8) & 0xffff;
+	bio->ct = bio->buf == 0xff00 ? 7 : 8;
+	if (bio->bp >= bio->end) {
+		return 1;
+	}
+	*bio->bp++ = bio->buf >> 8;
+	return 0;
+}
+
+static int bio_bytein(opj_bio_t *bio) {
+	bio->buf = (bio->buf << 8) & 0xffff;
+	bio->ct = bio->buf == 0xff00 ? 7 : 8;
+	if (bio->bp >= bio->end) {
+		return 1;
+	}
+	bio->buf |= *bio->bp++;
+	return 0;
+}
+
+static void bio_putbit(opj_bio_t *bio, int b) {
+	if (bio->ct == 0) {
+		bio_byteout(bio);
+	}
+	bio->ct--;
+	bio->buf |= b << bio->ct;
+}
+
+static int bio_getbit(opj_bio_t *bio) {
+	if (bio->ct == 0) {
+		bio_bytein(bio);
+	}
+	bio->ct--;
+	return (bio->buf >> bio->ct) & 1;
+}
+
+/* 
+==========================================================
+   Bit Input/Output interface
+==========================================================
+*/
+
+opj_bio_t* bio_create(void) {
+	opj_bio_t *bio = (opj_bio_t*)opj_malloc(sizeof(opj_bio_t));
+	return bio;
+}
+
+void bio_destroy(opj_bio_t *bio) {
+	if(bio) {
+		opj_free(bio);
+	}
+}
+
+int bio_numbytes(opj_bio_t *bio) {
+	return (bio->bp - bio->start);
+}
+
+void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len) {
+	bio->start = bp;
+	bio->end = bp + len;
+	bio->bp = bp;
+	bio->buf = 0;
+	bio->ct = 8;
+}
+
+void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len) {
+	bio->start = bp;
+	bio->end = bp + len;
+	bio->bp = bp;
+	bio->buf = 0;
+	bio->ct = 0;
+}
+
+void bio_write(opj_bio_t *bio, int v, int n) {
+	int i;
+	for (i = n - 1; i >= 0; i--) {
+		bio_putbit(bio, (v >> i) & 1);
+	}
+}
+
+int bio_read(opj_bio_t *bio, int n) {
+	int i, v;
+	v = 0;
+	for (i = n - 1; i >= 0; i--) {
+		v += bio_getbit(bio) << i;
+	}
+	return v;
+}
+
+int bio_flush(opj_bio_t *bio) {
+	bio->ct = 0;
+	if (bio_byteout(bio)) {
+		return 1;
+	}
+	if (bio->ct == 7) {
+		bio->ct = 0;
+		if (bio_byteout(bio)) {
+			return 1;
+		}
+	}
+	return 0;
+}
+
+int bio_inalign(opj_bio_t *bio) {
+	bio->ct = 0;
+	if ((bio->buf & 0xff) == 0xff) {
+		if (bio_bytein(bio)) {
+			return 1;
+		}
+		bio->ct = 0;
+	}
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/bio.h.svn-base ./libopenjpeg/.svn/text-base/bio.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/bio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/bio.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,125 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __BIO_H
+#define __BIO_H
+/** 
+@file bio.h
+@brief Implementation of an individual bit input-output (BIO)
+
+The functions in BIO.C have for goal to realize an individual bit input - output.
+*/
+
+/** @defgroup BIO BIO - Individual bit input-output stream */
+/*@{*/
+
+/**
+Individual bit input-output stream (BIO)
+*/
+typedef struct opj_bio {
+	/** pointer to the start of the buffer */
+	unsigned char *start;
+	/** pointer to the end of the buffer */
+	unsigned char *end;
+	/** pointer to the present position in the buffer */
+	unsigned char *bp;
+	/** temporary place where each byte is read or written */
+	unsigned int buf;
+	/** coder : number of bits free to write. decoder : number of bits read */
+	int ct;
+} opj_bio_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new BIO handle 
+@return Returns a new BIO handle if successful, returns NULL otherwise
+*/
+opj_bio_t* bio_create(void);
+/**
+Destroy a previously created BIO handle
+@param bio BIO handle to destroy
+*/
+void bio_destroy(opj_bio_t *bio);
+/**
+Number of bytes written.
+@param bio BIO handle
+@return Returns the number of bytes written
+*/
+int bio_numbytes(opj_bio_t *bio);
+/**
+Init encoder
+@param bio BIO handle
+@param bp Output buffer
+@param len Output buffer length 
+*/
+void bio_init_enc(opj_bio_t *bio, unsigned char *bp, int len);
+/**
+Init decoder
+@param bio BIO handle
+@param bp Input buffer
+@param len Input buffer length 
+*/
+void bio_init_dec(opj_bio_t *bio, unsigned char *bp, int len);
+/**
+Write bits
+@param bio BIO handle
+@param v Value of bits
+@param n Number of bits to write
+*/
+void bio_write(opj_bio_t *bio, int v, int n);
+/**
+Read bits
+@param bio BIO handle
+@param n Number of bits to read 
+@return Returns the corresponding read number
+*/
+int bio_read(opj_bio_t *bio, int n);
+/**
+Flush bits
+@param bio BIO handle
+@return Returns 1 if successful, returns 0 otherwise
+*/
+int bio_flush(opj_bio_t *bio);
+/**
+Passes the ending bits (coming from flushing)
+@param bio BIO handle
+@return Returns 1 if successful, returns 0 otherwise
+*/
+int bio_inalign(opj_bio_t *bio);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __BIO_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/cio.c.svn-base ./libopenjpeg/.svn/text-base/cio.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/cio.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/cio.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,191 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* ----------------------------------------------------------------------- */
+
+opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length) {
+	opj_cp_t *cp = NULL;
+	opj_cio_t *cio = (opj_cio_t*)opj_malloc(sizeof(opj_cio_t));
+	if(!cio) return NULL;
+	cio->cinfo = cinfo;
+	if(buffer && length) {
+		/* wrap a user buffer containing the encoded image */
+		cio->openmode = OPJ_STREAM_READ;
+		cio->buffer = buffer;
+		cio->length = length;
+	}
+	else if(!buffer && !length && cinfo) {
+		/* allocate a buffer for the encoded image */
+		cio->openmode = OPJ_STREAM_WRITE;
+		switch(cinfo->codec_format) {
+			case CODEC_J2K:
+				cp = ((opj_j2k_t*)cinfo->j2k_handle)->cp;
+				break;
+			case CODEC_JP2:
+				cp = ((opj_jp2_t*)cinfo->jp2_handle)->j2k->cp;
+				break;
+			default:
+				opj_free(cio);
+				return NULL;
+		}
+		cio->length = (unsigned int) (0.1625 * cp->img_size + 2000); /* 0.1625 = 1.3/8 and 2000 bytes as a minimum for headers */
+		cio->buffer = (unsigned char *)opj_malloc(cio->length);
+		if(!cio->buffer) {
+			opj_event_msg(cio->cinfo, EVT_ERROR, "Error allocating memory for compressed bitstream\n");
+			opj_free(cio);
+			return NULL;
+		}
+	}
+	else {
+		opj_free(cio);
+		return NULL;
+	}
+
+	/* Initialize byte IO */
+	cio->start = cio->buffer;
+	cio->end = cio->buffer + cio->length;
+	cio->bp = cio->buffer;
+
+	return cio;
+}
+
+void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio) {
+	if(cio) {
+		if(cio->openmode == OPJ_STREAM_WRITE) {
+			/* destroy the allocated buffer */
+			opj_free(cio->buffer);
+		}
+		/* destroy the cio */
+		opj_free(cio);
+	}
+}
+
+
+/* ----------------------------------------------------------------------- */
+
+/*
+ * Get position in byte stream.
+ */
+int OPJ_CALLCONV cio_tell(opj_cio_t *cio) {
+	return cio->bp - cio->start;
+}
+
+/*
+ * Set position in byte stream.
+ *
+ * pos : position, in number of bytes, from the beginning of the stream
+ */
+void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos) {
+	cio->bp = cio->start + pos;
+}
+
+/*
+ * Number of bytes left before the end of the stream.
+ */
+int cio_numbytesleft(opj_cio_t *cio) {
+	return cio->end - cio->bp;
+}
+
+/*
+ * Get pointer to the current position in the stream.
+ */
+unsigned char *cio_getbp(opj_cio_t *cio) {
+	return cio->bp;
+}
+
+/*
+ * Write a byte.
+ */
+bool cio_byteout(opj_cio_t *cio, unsigned char v) {
+	if (cio->bp >= cio->end) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "write error\n");
+		return false;
+	}
+	*cio->bp++ = v;
+	return true;
+}
+
+/*
+ * Read a byte.
+ */
+unsigned char cio_bytein(opj_cio_t *cio) {
+	if (cio->bp >= cio->end) {
+		opj_event_msg(cio->cinfo, EVT_ERROR, "read error: passed the end of the codestream (start = %d, current = %d, end = %d\n", cio->start, cio->bp, cio->end);
+		return 0;
+	}
+	return *cio->bp++;
+}
+
+/*
+ * Write some bytes.
+ *
+ * v : value to write
+ * n : number of bytes to write
+ */
+unsigned int cio_write(opj_cio_t *cio, unsigned int v, int n) {
+	int i;
+	for (i = n - 1; i >= 0; i--) {
+		if( !cio_byteout(cio, (unsigned char) ((v >> (i << 3)) & 0xff)) )
+			return 0;
+	}
+	return n;
+}
+
+/*
+ * Read some bytes.
+ *
+ * n : number of bytes to read
+ *
+ * return : value of the n bytes read
+ */
+unsigned int cio_read(opj_cio_t *cio, int n) {
+	int i;
+	unsigned int v;
+	v = 0;
+	for (i = n - 1; i >= 0; i--) {
+		v += cio_bytein(cio) << (i << 3);
+	}
+	return v;
+}
+
+/* 
+ * Skip some bytes.
+ *
+ * n : number of bytes to skip
+ */
+void cio_skip(opj_cio_t *cio, int n) {
+	cio->bp += n;
+}
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/cio.h.svn-base ./libopenjpeg/.svn/text-base/cio.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/cio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/cio.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,86 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __CIO_H
+#define __CIO_H
+/**
+@file cio.h
+@brief Implementation of a byte input-output process (CIO)
+
+The functions in CIO.C have for goal to realize a byte input / output process.
+*/
+
+/** @defgroup CIO CIO - byte input-output stream */
+/*@{*/
+
+/** @name Exported functions (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Number of bytes left before the end of the stream
+@param cio CIO handle
+@return Returns the number of bytes before the end of the stream
+*/
+int cio_numbytesleft(opj_cio_t *cio);
+/**
+Get pointer to the current position in the stream
+@param cio CIO handle
+@return Returns a pointer to the current position
+*/
+unsigned char *cio_getbp(opj_cio_t *cio);
+/**
+Write some bytes
+@param cio CIO handle
+@param v Value to write
+@param n Number of bytes to write
+@return Returns the number of bytes written or 0 if an error occured
+*/
+unsigned int cio_write(opj_cio_t *cio, unsigned int v, int n);
+/**
+Read some bytes
+@param cio CIO handle
+@param n Number of bytes to read
+@return Returns the value of the n bytes read
+*/
+unsigned int cio_read(opj_cio_t *cio, int n);
+/**
+Skip some bytes
+@param cio CIO handle
+@param n Number of bytes to skip
+*/
+void cio_skip(opj_cio_t *cio, int n);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __CIO_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/CMakeLists.txt.svn-base ./libopenjpeg/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,44 @@
+INCLUDE_REGULAR_EXPRESSION("^.*$")
+# Defines the source code for the library
+SET(OPENJPEG_SRCS
+  bio.c
+  cio.c
+  dwt.c
+  event.c
+  image.c
+  j2k.c
+  j2k_lib.c
+  jp2.c
+  jpt.c
+  mct.c
+  mqc.c
+  openjpeg.c
+  pi.c
+  raw.c
+  t1.c
+  t2.c
+  tcd.c
+  tgt.c
+)
+
+# Pass proper definition to preprocessor to generate shared lib
+IF(WIN32)
+  IF(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_EXPORTS)
+  ELSE(BUILD_SHARED_LIBS)
+    ADD_DEFINITIONS(-DOPJ_STATIC)
+  ENDIF(BUILD_SHARED_LIBS)
+ENDIF(WIN32)
+
+# Create the library
+ADD_LIBRARY(${OPENJPEG_LIBRARY_NAME} ${OPENJPEG_SRCS})
+SET_TARGET_PROPERTIES(${OPENJPEG_LIBRARY_NAME} PROPERTIES
+	${OPENJPEG_LIBRARY_PROPERTIES})
+
+# Install library
+INSTALL(TARGETS ${OPENJPEG_LIBRARY_NAME}
+	DESTINATION lib)
+
+# Install includes files
+INSTALL(FILES openjpeg.h
+	DESTINATION ${INCLUDE_INSTALL_DIR}/openjpeg)
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/dwt.c.svn-base ./libopenjpeg/.svn/text-base/dwt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/dwt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/dwt.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,825 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Jonathan Ballard <dzonatas@dzonux.net>
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef __SSE__
+#include <xmmintrin.h>
+#endif
+
+#include "opj_includes.h"
+
+/** @defgroup DWT DWT - Implementation of a discrete wavelet transform */
+/*@{*/
+
+#define WS(i) v->mem[(i)*2]
+#define WD(i) v->mem[(1+(i)*2)]
+
+/** @name Local data structures */
+/*@{*/
+
+typedef struct dwt_local {
+	int* mem;
+	int dn;
+	int sn;
+	int cas;
+} dwt_t;
+
+typedef union {
+	float	f[4];
+} v4;
+
+typedef struct v4dwt_local {
+	v4*	wavelet ;
+	int		dn ;
+	int		sn ;
+	int		cas ;
+} v4dwt_t ;
+
+static const float alpha =  1.586134342f; //  12994
+static const float beta  =  0.052980118f; //    434
+static const float gamma = -0.882911075f; //  -7233
+static const float delta = -0.443506852f; //  -3633
+
+static const float K      = 1.230174105f; //  10078
+/* FIXME: What is this constant? */
+static const float c13318 = 1.625732422f;
+
+/*@}*/
+
+/**
+Virtual function type for wavelet transform in 1-D 
+*/
+typedef void (*DWT1DFN)(dwt_t* v);
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Forward lazy transform (horizontal)
+*/
+static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas);
+/**
+Forward lazy transform (vertical)
+*/
+static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas);
+/**
+Inverse lazy transform (horizontal)
+*/
+static void dwt_interleave_h(dwt_t* h, int *a);
+/**
+Inverse lazy transform (vertical)
+*/
+static void dwt_interleave_v(dwt_t* v, int *a, int x);
+/**
+Forward 5-3 wavelet transform in 1-D
+*/
+static void dwt_encode_1(int *a, int dn, int sn, int cas);
+/**
+Inverse 5-3 wavelet transform in 1-D
+*/
+static void dwt_decode_1(dwt_t *v);
+/**
+Forward 9-7 wavelet transform in 1-D
+*/
+static void dwt_encode_1_real(int *a, int dn, int sn, int cas);
+/**
+Explicit calculation of the Quantization Stepsizes 
+*/
+static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize);
+/**
+Inverse wavelet transform in 2-D.
+*/
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int i, DWT1DFN fn);
+
+/*@}*/
+
+/*@}*/
+
+#define S(i) a[(i)*2]
+#define D(i) a[(1+(i)*2)]
+#define S_(i) ((i)<0?S(0):((i)>=sn?S(sn-1):S(i)))
+#define D_(i) ((i)<0?D(0):((i)>=dn?D(dn-1):D(i)))
+/* new */
+#define SS_(i) ((i)<0?S(0):((i)>=dn?S(dn-1):S(i)))
+#define DD_(i) ((i)<0?D(0):((i)>=sn?D(sn-1):D(i)))
+
+/* <summary>                                                              */
+/* This table contains the norms of the 5-3 wavelets for different bands. */
+/* </summary>                                                             */
+static const double dwt_norms[4][10] = {
+	{1.000, 1.500, 2.750, 5.375, 10.68, 21.34, 42.67, 85.33, 170.7, 341.3},
+	{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+	{1.038, 1.592, 2.919, 5.703, 11.33, 22.64, 45.25, 90.48, 180.9},
+	{.7186, .9218, 1.586, 3.043, 6.019, 12.01, 24.00, 47.97, 95.93}
+};
+
+/* <summary>                                                              */
+/* This table contains the norms of the 9-7 wavelets for different bands. */
+/* </summary>                                                             */
+static const double dwt_norms_real[4][10] = {
+	{1.000, 1.965, 4.177, 8.403, 16.90, 33.84, 67.69, 135.3, 270.6, 540.9},
+	{2.022, 3.989, 8.355, 17.04, 34.27, 68.63, 137.3, 274.6, 549.0},
+	{2.022, 3.989, 8.355, 17.04, 34.27, 68.63, 137.3, 274.6, 549.0},
+	{2.080, 3.865, 8.307, 17.18, 34.71, 69.59, 139.3, 278.6, 557.2}
+};
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+/* <summary>			                 */
+/* Forward lazy transform (horizontal).  */
+/* </summary>                            */ 
+static void dwt_deinterleave_h(int *a, int *b, int dn, int sn, int cas) {
+	int i;
+    for (i=0; i<sn; i++) b[i]=a[2*i+cas];
+    for (i=0; i<dn; i++) b[sn+i]=a[(2*i+1-cas)];
+}
+
+/* <summary>                             */  
+/* Forward lazy transform (vertical).    */
+/* </summary>                            */ 
+static void dwt_deinterleave_v(int *a, int *b, int dn, int sn, int x, int cas) {
+    int i;
+    for (i=0; i<sn; i++) b[i*x]=a[2*i+cas];
+    for (i=0; i<dn; i++) b[(sn+i)*x]=a[(2*i+1-cas)];
+}
+
+/* <summary>                             */
+/* Inverse lazy transform (horizontal).  */
+/* </summary>                            */
+static void dwt_interleave_h(dwt_t* h, int *a) {
+    int *ai = a;
+    int *bi = h->mem + h->cas;
+    int  i	= h->sn;
+    while( i-- ) {
+      *bi = *(ai++);
+	  bi += 2;
+    }
+    ai	= a + h->sn;
+    bi	= h->mem + 1 - h->cas;
+    i	= h->dn ;
+    while( i-- ) {
+      *bi = *(ai++);
+	  bi += 2;
+    }
+}
+
+/* <summary>                             */  
+/* Inverse lazy transform (vertical).    */
+/* </summary>                            */ 
+static void dwt_interleave_v(dwt_t* v, int *a, int x) {
+    int *ai = a;
+    int *bi = v->mem + v->cas;
+    int  i = v->sn;
+    while( i-- ) {
+      *bi = *ai;
+	  bi += 2;
+	  ai += x;
+    }
+    ai = a + (v->sn * x);
+    bi = v->mem + 1 - v->cas;
+    i = v->dn ;
+    while( i-- ) {
+      *bi = *ai;
+	  bi += 2;  
+	  ai += x;
+    }
+}
+
+
+/* <summary>                            */
+/* Forward 5-3 wavelet transform in 1-D. */
+/* </summary>                           */
+static void dwt_encode_1(int *a, int dn, int sn, int cas) {
+	int i;
+	
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < dn; i++) D(i) -= (S_(i) + S_(i + 1)) >> 1;
+			for (i = 0; i < sn; i++) S(i) += (D_(i - 1) + D_(i) + 2) >> 2;
+		}
+	} else {
+		if (!sn && dn == 1)		    /* NEW :  CASE ONE ELEMENT */
+			S(0) *= 2;
+		else {
+			for (i = 0; i < dn; i++) S(i) -= (DD_(i) + DD_(i - 1)) >> 1;
+			for (i = 0; i < sn; i++) D(i) += (SS_(i) + SS_(i + 1) + 2) >> 2;
+		}
+	}
+}
+
+/* <summary>                            */
+/* Inverse 5-3 wavelet transform in 1-D. */
+/* </summary>                           */ 
+static void dwt_decode_1_(int *a, int dn, int sn, int cas) {
+	int i;
+	
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) { /* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < sn; i++) S(i) -= (D_(i - 1) + D_(i) + 2) >> 2;
+			for (i = 0; i < dn; i++) D(i) += (S_(i) + S_(i + 1)) >> 1;
+		}
+	} else {
+		if (!sn  && dn == 1)          /* NEW :  CASE ONE ELEMENT */
+			S(0) /= 2;
+		else {
+			for (i = 0; i < sn; i++) D(i) -= (SS_(i) + SS_(i + 1) + 2) >> 2;
+			for (i = 0; i < dn; i++) S(i) += (DD_(i) + DD_(i - 1)) >> 1;
+		}
+	}
+}
+
+/* <summary>                            */
+/* Inverse 5-3 wavelet transform in 1-D. */
+/* </summary>                           */ 
+static void dwt_decode_1(dwt_t *v) {
+	dwt_decode_1_(v->mem, v->dn, v->sn, v->cas);
+}
+
+/* <summary>                             */
+/* Forward 9-7 wavelet transform in 1-D. */
+/* </summary>                            */
+static void dwt_encode_1_real(int *a, int dn, int sn, int cas) {
+	int i;
+	if (!cas) {
+		if ((dn > 0) || (sn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < dn; i++)
+				D(i) -= fix_mul(S_(i) + S_(i + 1), 12993);
+			for (i = 0; i < sn; i++)
+				S(i) -= fix_mul(D_(i - 1) + D_(i), 434);
+			for (i = 0; i < dn; i++)
+				D(i) += fix_mul(S_(i) + S_(i + 1), 7233);
+			for (i = 0; i < sn; i++)
+				S(i) += fix_mul(D_(i - 1) + D_(i), 3633);
+			for (i = 0; i < dn; i++)
+				D(i) = fix_mul(D(i), 5038);	/*5038 */
+			for (i = 0; i < sn; i++)
+				S(i) = fix_mul(S(i), 6659);	/*6660 */
+		}
+	} else {
+		if ((sn > 0) || (dn > 1)) {	/* NEW :  CASE ONE ELEMENT */
+			for (i = 0; i < dn; i++)
+				S(i) -= fix_mul(DD_(i) + DD_(i - 1), 12993);
+			for (i = 0; i < sn; i++)
+				D(i) -= fix_mul(SS_(i) + SS_(i + 1), 434);
+			for (i = 0; i < dn; i++)
+				S(i) += fix_mul(DD_(i) + DD_(i - 1), 7233);
+			for (i = 0; i < sn; i++)
+				D(i) += fix_mul(SS_(i) + SS_(i + 1), 3633);
+			for (i = 0; i < dn; i++)
+				S(i) = fix_mul(S(i), 5038);	/*5038 */
+			for (i = 0; i < sn; i++)
+				D(i) = fix_mul(D(i), 6659);	/*6660 */
+		}
+	}
+}
+
+static void dwt_encode_stepsize(int stepsize, int numbps, opj_stepsize_t *bandno_stepsize) {
+	int p, n;
+	p = int_floorlog2(stepsize) - 13;
+	n = 11 - int_floorlog2(stepsize);
+	bandno_stepsize->mant = (n < 0 ? stepsize >> -n : stepsize << n) & 0x7ff;
+	bandno_stepsize->expn = numbps - p;
+}
+
+/* 
+==========================================================
+   DWT interface
+==========================================================
+*/
+
+/* <summary>                            */
+/* Forward 5-3 wavelet transform in 2-D. */
+/* </summary>                           */
+void dwt_encode(opj_tcd_tilecomp_t * tilec) {
+	int i, j, k;
+	int *a = NULL;
+	int *aj = NULL;
+	int *bj = NULL;
+	int w, l;
+	
+	w = tilec->x1-tilec->x0;
+	l = tilec->numresolutions-1;
+	a = tilec->data;
+	
+	for (i = 0; i < l; i++) {
+		int rw;			/* width of the resolution level computed                                                           */
+		int rh;			/* height of the resolution level computed                                                          */
+		int rw1;		/* width of the resolution level once lower than computed one                                       */
+		int rh1;		/* height of the resolution level once lower than computed one                                      */
+		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		int dn, sn;
+		
+		rw = tilec->resolutions[l - i].x1 - tilec->resolutions[l - i].x0;
+		rh = tilec->resolutions[l - i].y1 - tilec->resolutions[l - i].y0;
+		rw1= tilec->resolutions[l - i - 1].x1 - tilec->resolutions[l - i - 1].x0;
+		rh1= tilec->resolutions[l - i - 1].y1 - tilec->resolutions[l - i - 1].y0;
+		
+		cas_row = tilec->resolutions[l - i].x0 % 2;
+		cas_col = tilec->resolutions[l - i].y0 % 2;
+        
+		sn = rh1;
+		dn = rh - rh1;
+		bj = (int*)opj_malloc(rh * sizeof(int));
+		for (j = 0; j < rw; j++) {
+			aj = a + j;
+			for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
+			dwt_encode_1(bj, dn, sn, cas_col);
+			dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
+		}
+		opj_free(bj);
+		
+		sn = rw1;
+		dn = rw - rw1;
+		bj = (int*)opj_malloc(rw * sizeof(int));
+		for (j = 0; j < rh; j++) {
+			aj = a + j * w;
+			for (k = 0; k < rw; k++)  bj[k] = aj[k];
+			dwt_encode_1(bj, dn, sn, cas_row);
+			dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
+		}
+		opj_free(bj);
+	}
+}
+
+
+/* <summary>                            */
+/* Inverse 5-3 wavelet transform in 2-D. */
+/* </summary>                           */
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres) {
+	dwt_decode_tile(tilec, numres, &dwt_decode_1);
+}
+
+
+/* <summary>                          */
+/* Get gain of 5-3 wavelet transform. */
+/* </summary>                         */
+int dwt_getgain(int orient) {
+	if (orient == 0)
+		return 0;
+	if (orient == 1 || orient == 2)
+		return 1;
+	return 2;
+}
+
+/* <summary>                */
+/* Get norm of 5-3 wavelet. */
+/* </summary>               */
+double dwt_getnorm(int level, int orient) {
+	return dwt_norms[orient][level];
+}
+
+/* <summary>                             */
+/* Forward 9-7 wavelet transform in 2-D. */
+/* </summary>                            */
+
+void dwt_encode_real(opj_tcd_tilecomp_t * tilec) {
+	int i, j, k;
+	int *a = NULL;
+	int *aj = NULL;
+	int *bj = NULL;
+	int w, l;
+	
+	w = tilec->x1-tilec->x0;
+	l = tilec->numresolutions-1;
+	a = tilec->data;
+	
+	for (i = 0; i < l; i++) {
+		int rw;			/* width of the resolution level computed                                                     */
+		int rh;			/* height of the resolution level computed                                                    */
+		int rw1;		/* width of the resolution level once lower than computed one                                 */
+		int rh1;		/* height of the resolution level once lower than computed one                                */
+		int cas_col;	/* 0 = non inversion on horizontal filtering 1 = inversion between low-pass and high-pass filtering */
+		int cas_row;	/* 0 = non inversion on vertical filtering 1 = inversion between low-pass and high-pass filtering   */
+		int dn, sn;
+		
+		rw = tilec->resolutions[l - i].x1 - tilec->resolutions[l - i].x0;
+		rh = tilec->resolutions[l - i].y1 - tilec->resolutions[l - i].y0;
+		rw1= tilec->resolutions[l - i - 1].x1 - tilec->resolutions[l - i - 1].x0;
+		rh1= tilec->resolutions[l - i - 1].y1 - tilec->resolutions[l - i - 1].y0;
+		
+		cas_row = tilec->resolutions[l - i].x0 % 2;
+		cas_col = tilec->resolutions[l - i].y0 % 2;
+		
+		sn = rh1;
+		dn = rh - rh1;
+		bj = (int*)opj_malloc(rh * sizeof(int));
+		for (j = 0; j < rw; j++) {
+			aj = a + j;
+			for (k = 0; k < rh; k++)  bj[k] = aj[k*w];
+			dwt_encode_1_real(bj, dn, sn, cas_col);
+			dwt_deinterleave_v(bj, aj, dn, sn, w, cas_col);
+		}
+		opj_free(bj);
+		
+		sn = rw1;
+		dn = rw - rw1;
+		bj = (int*)opj_malloc(rw * sizeof(int));
+		for (j = 0; j < rh; j++) {
+			aj = a + j * w;
+			for (k = 0; k < rw; k++)  bj[k] = aj[k];
+			dwt_encode_1_real(bj, dn, sn, cas_row);
+			dwt_deinterleave_h(bj, aj, dn, sn, cas_row);
+		}
+		opj_free(bj);
+	}
+}
+
+
+/* <summary>                          */
+/* Get gain of 9-7 wavelet transform. */
+/* </summary>                         */
+int dwt_getgain_real(int orient) {
+	(void)orient;
+	return 0;
+}
+
+/* <summary>                */
+/* Get norm of 9-7 wavelet. */
+/* </summary>               */
+double dwt_getnorm_real(int level, int orient) {
+	return dwt_norms_real[orient][level];
+}
+
+void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec) {
+	int numbands, bandno;
+	numbands = 3 * tccp->numresolutions - 2;
+	for (bandno = 0; bandno < numbands; bandno++) {
+		double stepsize;
+		int resno, level, orient, gain;
+
+		resno = (bandno == 0) ? 0 : ((bandno - 1) / 3 + 1);
+		orient = (bandno == 0) ? 0 : ((bandno - 1) % 3 + 1);
+		level = tccp->numresolutions - 1 - resno;
+		gain = (tccp->qmfbid == 0) ? 0 : ((orient == 0) ? 0 : (((orient == 1) || (orient == 2)) ? 1 : 2));
+		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
+			stepsize = 1.0;
+		} else {
+			double norm = dwt_norms_real[orient][level];
+			stepsize = (1 << (gain)) / norm;
+		}
+		dwt_encode_stepsize((int) floor(stepsize * 8192.0), prec + gain, &tccp->stepsizes[bandno]);
+	}
+}
+
+
+/* <summary>                             */
+/* Determine maximum computed resolution level for inverse wavelet transform */
+/* </summary>                            */
+static int dwt_decode_max_resolution(opj_tcd_resolution_t* restrict r, int i) {
+	int mr	= 1;
+	int w;
+	while( --i ) {
+		r++;
+		if( mr < ( w = r->x1 - r->x0 ) )
+			mr = w ;
+		if( mr < ( w = r->y1 - r->y0 ) )
+			mr = w ;
+	}
+	return mr ;
+}
+
+
+/* <summary>                            */
+/* Inverse wavelet transform in 2-D.     */
+/* </summary>                           */
+static void dwt_decode_tile(opj_tcd_tilecomp_t* tilec, int numres, DWT1DFN dwt_1D) {
+	dwt_t h;
+	dwt_t v;
+
+	opj_tcd_resolution_t* tr = tilec->resolutions;
+
+	int rw = tr->x1 - tr->x0;	/* width of the resolution level computed */
+	int rh = tr->y1 - tr->y0;	/* height of the resolution level computed */
+
+	int w = tilec->x1 - tilec->x0;
+
+	h.mem = opj_aligned_malloc(dwt_decode_max_resolution(tr, numres) * sizeof(int));
+	v.mem = h.mem;
+
+	while( --numres) {
+		int * restrict tiledp = tilec->data;
+		int j;
+
+		++tr;
+		h.sn = rw;
+		v.sn = rh;
+
+		rw = tr->x1 - tr->x0;
+		rh = tr->y1 - tr->y0;
+
+		h.dn = rw - h.sn;
+		h.cas = tr->x0 % 2;
+
+		for(j = 0; j < rh; ++j) {
+			dwt_interleave_h(&h, &tiledp[j*w]);
+			(dwt_1D)(&h);
+			memcpy(&tiledp[j*w], h.mem, rw * sizeof(int));
+		}
+
+		v.dn = rh - v.sn;
+		v.cas = tr->y0 % 2;
+
+		for(j = 0; j < rw; ++j){
+			int k;
+			dwt_interleave_v(&v, &tiledp[j], w);
+			(dwt_1D)(&v);
+			for(k = 0; k < rh; ++k) {
+				tiledp[k * w + j] = v.mem[k];
+			}
+		}
+	}
+	opj_aligned_free(h.mem);
+}
+
+static void v4dwt_interleave_h(v4dwt_t* restrict w, float* restrict a, int x, int size){
+	float* restrict bi = (float*) (w->wavelet + w->cas);
+	int count = w->sn;
+	int i, k;
+	for(k = 0; k < 2; ++k){
+		for(i = 0; i < count; ++i){
+			int j = i;
+			bi[i*8    ] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 1] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 2] = a[j];
+			j += x;
+			if(j > size) continue;
+			bi[i*8 + 3] = a[j];
+		}
+		bi = (float*) (w->wavelet + 1 - w->cas);
+		a += w->sn;
+		size -= w->sn;
+		count = w->dn;
+	}
+}
+
+static void v4dwt_interleave_v(v4dwt_t* restrict v , float* restrict a , int x){
+	v4* restrict bi = v->wavelet + v->cas;
+	int i;
+	for(i = 0; i < v->sn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+	a += v->sn * x;
+	bi = v->wavelet + 1 - v->cas;
+	for(i = 0; i < v->dn; ++i){
+		memcpy(&bi[i*2], &a[i*x], 4 * sizeof(float));
+	}
+}
+
+#ifdef __SSE__
+
+static void v4dwt_decode_step1_sse(v4* w, int count, const __m128 c){
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		__m128 tmp = vw[i*2];
+		vw[i*2] = tmp * c;
+	}
+}
+
+static void v4dwt_decode_step2_sse(v4* l, v4* w, int k, int m, __m128 c){
+	__m128* restrict vl = (__m128*) l;
+	__m128* restrict vw = (__m128*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		__m128 tmp1 = vl[ 0];
+		__m128 tmp2 = vw[-1];
+		__m128 tmp3 = vw[ 0];
+		vw[-1] = tmp2 + ((tmp1 + tmp3) * c);
+		vl = vw;
+		vw += 2;
+	}
+	if(m >= k){
+		return;
+	}
+	c += c;
+	c *= vl[0];
+	for(; m < k; ++m){
+		__m128 tmp = vw[-1];
+		vw[-1] = tmp + c;
+		vw += 2;
+	}
+}
+
+#else
+
+static void v4dwt_decode_step1(v4* w, int count, const float c){
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < count; ++i){
+		float tmp1 = fw[i*8    ];
+		float tmp2 = fw[i*8 + 1];
+		float tmp3 = fw[i*8 + 2];
+		float tmp4 = fw[i*8 + 3];
+		fw[i*8    ] = tmp1 * c;
+		fw[i*8 + 1] = tmp2 * c;
+		fw[i*8 + 2] = tmp3 * c;
+		fw[i*8 + 3] = tmp4 * c;
+	}
+}
+
+static void v4dwt_decode_step2(v4* l, v4* w, int k, int m, float c){
+	float* restrict fl = (float*) l;
+	float* restrict fw = (float*) w;
+	int i;
+	for(i = 0; i < m; ++i){
+		float tmp1_1 = fl[0];
+		float tmp1_2 = fl[1];
+		float tmp1_3 = fl[2];
+		float tmp1_4 = fl[3];
+		float tmp2_1 = fw[-4];
+		float tmp2_2 = fw[-3];
+		float tmp2_3 = fw[-2];
+		float tmp2_4 = fw[-1];
+		float tmp3_1 = fw[0];
+		float tmp3_2 = fw[1];
+		float tmp3_3 = fw[2];
+		float tmp3_4 = fw[3];
+		fw[-4] = tmp2_1 + ((tmp1_1 + tmp3_1) * c);
+		fw[-3] = tmp2_2 + ((tmp1_2 + tmp3_2) * c);
+		fw[-2] = tmp2_3 + ((tmp1_3 + tmp3_3) * c);
+		fw[-1] = tmp2_4 + ((tmp1_4 + tmp3_4) * c);
+		fl = fw;
+		fw += 8;
+	}
+	if(m < k){
+		float c1;
+		float c2;
+		float c3;
+		float c4;
+		c += c;
+		c1 = fl[0] * c;
+		c2 = fl[1] * c;
+		c3 = fl[2] * c;
+		c4 = fl[3] * c;
+		for(; m < k; ++m){
+			float tmp1 = fw[-4];
+			float tmp2 = fw[-3];
+			float tmp3 = fw[-2];
+			float tmp4 = fw[-1];
+			fw[-4] = tmp1 + c1;
+			fw[-3] = tmp2 + c2;
+			fw[-2] = tmp3 + c3;
+			fw[-1] = tmp4 + c4;
+			fw += 8;
+		}
+	}
+}
+
+#endif
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 1-D. */
+/* </summary>                            */
+static void v4dwt_decode(v4dwt_t* restrict dwt){
+	int a, b;
+	if(dwt->cas == 0) {
+		if(!((dwt->dn > 0) || (dwt->sn > 1))){
+			return;
+		}
+		a = 0;
+		b = 1;
+	}else{
+		if(!((dwt->sn > 0) || (dwt->dn > 1))) {
+			return;
+		}
+		a = 1;
+		b = 0;
+	}
+#ifdef __SSE__
+	v4dwt_decode_step1_sse(dwt->wavelet+a, dwt->sn, _mm_set1_ps(K));
+	v4dwt_decode_step1_sse(dwt->wavelet+b, dwt->dn, _mm_set1_ps(c13318));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(delta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(gamma));
+	v4dwt_decode_step2_sse(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), _mm_set1_ps(beta));
+	v4dwt_decode_step2_sse(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), _mm_set1_ps(alpha));
+#else
+	v4dwt_decode_step1(dwt->wavelet+a, dwt->sn, K);
+	v4dwt_decode_step1(dwt->wavelet+b, dwt->dn, c13318);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), delta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), gamma);
+	v4dwt_decode_step2(dwt->wavelet+b, dwt->wavelet+a+1, dwt->sn, int_min(dwt->sn, dwt->dn-a), beta);
+	v4dwt_decode_step2(dwt->wavelet+a, dwt->wavelet+b+1, dwt->dn, int_min(dwt->dn, dwt->sn-b), alpha);
+#endif
+}
+
+/* <summary>                             */
+/* Inverse 9-7 wavelet transform in 2-D. */
+/* </summary>                            */
+void dwt_decode_real(opj_tcd_tilecomp_t* restrict tilec, int numres){
+	v4dwt_t h;
+	v4dwt_t v;
+
+	opj_tcd_resolution_t* res = tilec->resolutions;
+
+	int rw = res->x1 - res->x0;	/* width of the resolution level computed */
+	int rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+	int w = tilec->x1 - tilec->x0;
+
+	h.wavelet = (v4*) opj_aligned_malloc((dwt_decode_max_resolution(res, numres)+5) * sizeof(v4));
+	v.wavelet = h.wavelet;
+
+	while( --numres) {
+		float * restrict aj = (float*) tilec->data;
+		int bufsize = (tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0);
+		int j;
+
+		h.sn = rw;
+		v.sn = rh;
+
+		++res;
+
+		rw = res->x1 - res->x0;	/* width of the resolution level computed */
+		rh = res->y1 - res->y0;	/* height of the resolution level computed */
+
+		h.dn = rw - h.sn;
+		h.cas = res->x0 % 2;
+
+		for(j = rh; j > 0; j -= 4){
+			v4dwt_interleave_h(&h, aj, w, bufsize);
+			v4dwt_decode(&h);
+			if(j >= 4){
+				int k;
+				for(k = rw; --k >= 0;){
+					aj[k    ] = h.wavelet[k].f[0];
+					aj[k+w  ] = h.wavelet[k].f[1];
+					aj[k+w*2] = h.wavelet[k].f[2];
+					aj[k+w*3] = h.wavelet[k].f[3];
+				}
+			}else{
+				int k;
+				for(k = rw; --k >= 0;){
+					switch(j) {
+						case 3: aj[k+w*2] = h.wavelet[k].f[2];
+						case 2: aj[k+w  ] = h.wavelet[k].f[1];
+						case 1: aj[k    ] = h.wavelet[k].f[0];
+					}
+				}
+			}
+			aj += w*4;
+			bufsize -= w*4;
+		}
+
+		v.dn = rh - v.sn;
+		v.cas = res->y0 % 2;
+
+		aj = (float*) tilec->data;
+		for(j = rw; j > 0; j -= 4){
+			v4dwt_interleave_v(&v, aj, w);
+			v4dwt_decode(&v);
+			if(j >= 4){
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], 4 * sizeof(float));
+				}
+			}else{
+				int k;
+				for(k = 0; k < rh; ++k){
+					memcpy(&aj[k*w], &v.wavelet[k], j * sizeof(float));
+				}
+			}
+			aj += 4;
+		}
+	}
+
+	opj_aligned_free(h.wavelet);
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/dwt.h.svn-base ./libopenjpeg/.svn/text-base/dwt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/dwt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/dwt.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,113 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __DWT_H
+#define __DWT_H
+/**
+@file dwt.h
+@brief Implementation of a discrete wavelet transform (DWT)
+
+The functions in DWT.C have for goal to realize forward and inverse discret wavelet
+transform with filter 5-3 (reversible) and filter 9-7 (irreversible). The functions in
+DWT.C are used by some function in TCD.C.
+*/
+
+/** @defgroup DWT DWT - Implementation of a discrete wavelet transform */
+/*@{*/
+
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Forward 5-3 wavelet tranform in 2-D. 
+Apply a reversible DWT transform to a component of an image.
+@param tilec Tile component information (current tile)
+*/
+void dwt_encode(opj_tcd_tilecomp_t * tilec);
+/**
+Inverse 5-3 wavelet tranform in 2-D.
+Apply a reversible inverse DWT transform to a component of an image.
+@param tilec Tile component information (current tile)
+@param numres Number of resolution levels to decode
+*/
+void dwt_decode(opj_tcd_tilecomp_t* tilec, int numres);
+/**
+Get the gain of a subband for the reversible 5-3 DWT.
+@param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
+@return Returns 0 if orient = 0, returns 1 if orient = 1 or 2, returns 2 otherwise
+*/
+int dwt_getgain(int orient);
+/**
+Get the norm of a wavelet function of a subband at a specified level for the reversible 5-3 DWT.
+@param level Level of the wavelet function
+@param orient Band of the wavelet function
+@return Returns the norm of the wavelet function
+*/
+double dwt_getnorm(int level, int orient);
+/**
+Forward 9-7 wavelet transform in 2-D. 
+Apply an irreversible DWT transform to a component of an image.
+@param tilec Tile component information (current tile)
+*/
+void dwt_encode_real(opj_tcd_tilecomp_t * tilec);
+/**
+Inverse 9-7 wavelet transform in 2-D. 
+Apply an irreversible inverse DWT transform to a component of an image.
+@param tilec Tile component information (current tile)
+@param numres Number of resolution levels to decode
+*/
+void dwt_decode_real(opj_tcd_tilecomp_t* tilec, int numres);
+/**
+Get the gain of a subband for the irreversible 9-7 DWT.
+@param orient Number that identifies the subband (0->LL, 1->HL, 2->LH, 3->HH)
+@return Returns the gain of the 9-7 wavelet transform
+*/
+int dwt_getgain_real(int orient);
+/**
+Get the norm of a wavelet function of a subband at a specified level for the irreversible 9-7 DWT
+@param level Level of the wavelet function
+@param orient Band of the wavelet function
+@return Returns the norm of the 9-7 wavelet
+*/
+double dwt_getnorm_real(int level, int orient);
+/**
+Explicit calculation of the Quantization Stepsizes 
+@param tccp Tile-component coding parameters
+@param prec Precint analyzed
+*/
+void dwt_calc_explicit_stepsizes(opj_tccp_t * tccp, int prec);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __DWT_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/event.c.svn-base ./libopenjpeg/.svn/text-base/event.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/event.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/event.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,121 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* ==========================================================
+     Utility functions
+   ==========================================================*/
+
+#if !defined(_MSC_VER) && !defined(__MINGW32__)
+static char*
+i2a(unsigned i, char *a, unsigned r) {
+	if (i/r > 0) a = i2a(i/r,a,r);
+	*a = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ"[i%r];
+	return a+1;
+}
+
+/** 
+ Transforms integer i into an ascii string and stores the result in a; 
+ string is encoded in the base indicated by r.
+ @param i Number to be converted
+ @param a String result
+ @param r Base of value; must be in the range 2 - 36
+ @return Returns a
+*/
+static char *
+_itoa(int i, char *a, int r) {
+	r = ((r < 2) || (r > 36)) ? 10 : r;
+	if(i < 0) {
+		*a = '-';
+		*i2a(-i, a+1, r) = 0;
+	}
+	else *i2a(i, a, r) = 0;
+	return a;
+}
+
+#endif /* !WIN32 */
+
+/* ----------------------------------------------------------------------- */
+
+opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context) {
+	if(cinfo) {
+		opj_event_mgr_t *previous = cinfo->event_mgr;
+		cinfo->event_mgr = event_mgr;
+		cinfo->client_data = context;
+		return previous;
+	}
+
+	return NULL;
+}
+
+bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...) {
+#define MSG_SIZE 512 /* 512 bytes should be more than enough for a short message */
+	opj_msg_callback msg_handler = NULL;
+
+	opj_event_mgr_t *event_mgr = cinfo->event_mgr;
+	if(event_mgr != NULL) {
+		switch(event_type) {
+			case EVT_ERROR:
+				msg_handler = event_mgr->error_handler;
+				break;
+			case EVT_WARNING:
+				msg_handler = event_mgr->warning_handler;
+				break;
+			case EVT_INFO:
+				msg_handler = event_mgr->info_handler;
+				break;
+			default:
+				break;
+		}
+		if(msg_handler == NULL) {
+			return false;
+		}
+	} else {
+		return false;
+	}
+
+	if ((fmt != NULL) && (event_mgr != NULL)) {
+		va_list arg;
+		int str_length/*, i, j*/; /* UniPG */
+		char message[MSG_SIZE];
+		memset(message, 0, MSG_SIZE);
+		/* initialize the optional parameter list */
+		va_start(arg, fmt);
+		/* check the length of the format string */
+		str_length = (strlen(fmt) > MSG_SIZE) ? MSG_SIZE : strlen(fmt);
+		/* parse the format string and put the result in 'message' */
+		vsprintf(message, fmt, arg); /* UniPG */
+		/* deinitialize the optional parameter list */
+		va_end(arg);
+
+		/* output the message to the user program */
+		msg_handler(message, cinfo->client_data);
+	}
+
+	return true;
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/event.h.svn-base ./libopenjpeg/.svn/text-base/event.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/event.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/event.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,58 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __EVENT_H
+#define __EVENT_H
+/**
+@file event.h
+@brief Implementation of a event callback system
+
+The functions in EVENT.C have for goal to send output messages (errors, warnings, debug) to the user.
+*/
+
+#define EVT_ERROR	1	/**< Error event type */
+#define EVT_WARNING	2	/**< Warning event type */
+#define EVT_INFO	4	/**< Debug event type */
+
+/** @defgroup EVENT EVENT - Implementation of a event callback system */
+/*@{*/
+
+/** @name Exported functions (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Write formatted data to a string and send the string to a user callback. 
+@param cinfo Codec context info
+@param event_type Event type or callback to use to send the message
+@param fmt Format-control string (plus optionnal arguments)
+@return Returns true if successful, returns false otherwise
+*/
+bool opj_event_msg(opj_common_ptr cinfo, int event_type, const char *fmt, ...);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __EVENT_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/fix.h.svn-base ./libopenjpeg/.svn/text-base/fix.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/fix.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/fix.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,64 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __FIX_H
+#define __FIX_H
+
+#if defined(_MSC_VER) || defined(__BORLANDC__)
+#define int64 __int64
+#else
+#define int64 long long
+#endif
+
+/**
+@file fix.h
+@brief Implementation of operations of specific multiplication (FIX)
+
+The functions in FIX.H have for goal to realize specific multiplication.
+*/
+
+/** @defgroup FIX FIX - Implementation of operations of specific multiplication */
+/*@{*/
+
+/**
+Multiply two fixed-precision rational numbers.
+@param a
+@param b
+@return Returns a * b
+*/
+static INLINE int fix_mul(int a, int b) {
+    int64 temp = (int64) a * (int64) b ;
+    temp += temp & 4096;
+    return (int) (temp >> 13) ;
+}
+
+/*@}*/
+
+#endif /* __FIX_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/image.c.svn-base ./libopenjpeg/.svn/text-base/image.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/image.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/image.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,89 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+opj_image_t* opj_image_create0(void) {
+	opj_image_t *image = (opj_image_t*)opj_malloc(sizeof(opj_image_t));
+	return image;
+}
+
+opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc) {
+	int compno;
+	opj_image_t *image = NULL;
+
+	image = (opj_image_t*) opj_calloc(1, sizeof(opj_image_t));
+	if(image) {
+		image->color_space = clrspc;
+		image->numcomps = numcmpts;
+		/* allocate memory for the per-component information */
+		image->comps = (opj_image_comp_t*)opj_malloc(image->numcomps * sizeof(opj_image_comp_t));
+		if(!image->comps) {
+			fprintf(stderr,"Unable to allocate memory for image.\n");
+			opj_image_destroy(image);
+			return NULL;
+		}
+		/* create the individual image components */
+		for(compno = 0; compno < numcmpts; compno++) {
+			opj_image_comp_t *comp = &image->comps[compno];
+			comp->dx = cmptparms[compno].dx;
+			comp->dy = cmptparms[compno].dy;
+			comp->w = cmptparms[compno].w;
+			comp->h = cmptparms[compno].h;
+			comp->x0 = cmptparms[compno].x0;
+			comp->y0 = cmptparms[compno].y0;
+			comp->prec = cmptparms[compno].prec;
+			comp->bpp = cmptparms[compno].bpp;
+			comp->sgnd = cmptparms[compno].sgnd;
+			comp->data = (int*) opj_calloc(comp->w * comp->h, sizeof(int));
+			if(!comp->data) {
+				fprintf(stderr,"Unable to allocate memory for image.\n");
+				opj_image_destroy(image);
+				return NULL;
+			}
+		}
+	}
+
+	return image;
+}
+
+void OPJ_CALLCONV opj_image_destroy(opj_image_t *image) {
+	int i;
+	if(image) {
+		if(image->comps) {
+			/* image components */
+			for(i = 0; i < image->numcomps; i++) {
+				opj_image_comp_t *image_comp = &image->comps[i];
+				if(image_comp->data) {
+					opj_free(image_comp->data);
+				}
+			}
+			opj_free(image->comps);
+		}
+		opj_free(image);
+	}
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/image.h.svn-base ./libopenjpeg/.svn/text-base/image.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/image.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/image.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,48 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __IMAGE_H
+#define __IMAGE_H
+/**
+@file image.h
+@brief Implementation of operations on images (IMAGE)
+
+The functions in IMAGE.C have for goal to realize operations on images.
+*/
+
+/** @defgroup IMAGE IMAGE - Implementation of operations on images */
+/*@{*/
+
+/**
+Create an empty image
+@todo this function should be removed
+@return returns an empty image if successful, returns NULL otherwise
+*/
+opj_image_t* opj_image_create0(void);
+
+/*@}*/
+
+#endif /* __IMAGE_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/int.h.svn-base ./libopenjpeg/.svn/text-base/int.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/int.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/int.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,119 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __INT_H
+#define __INT_H
+/**
+@file int.h
+@brief Implementation of operations on integers (INT)
+
+The functions in INT.H have for goal to realize operations on integers.
+*/
+
+/** @defgroup INT INT - Implementation of operations on integers */
+/*@{*/
+
+/** @name Exported functions (see also openjpeg.h) */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Get the minimum of two integers
+@return Returns a if a < b else b
+*/
+static INLINE int int_min(int a, int b) {
+	return a < b ? a : b;
+}
+/**
+Get the maximum of two integers
+@return Returns a if a > b else b
+*/
+static INLINE int int_max(int a, int b) {
+	return (a > b) ? a : b;
+}
+/**
+Clamp an integer inside an interval
+@return
+<ul>
+<li>Returns a if (min < a < max)
+<li>Returns max if (a > max)
+<li>Returns min if (a < min) 
+</ul>
+*/
+static INLINE int int_clamp(int a, int min, int max) {
+	if (a < min)
+		return min;
+	if (a > max)
+		return max;
+	return a;
+}
+/**
+@return Get absolute value of integer
+*/
+static INLINE int int_abs(int a) {
+	return a < 0 ? -a : a;
+}
+/**
+Divide an integer and round upwards
+@return Returns a divided by b
+*/
+static INLINE int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+/**
+Divide an integer by a power of 2 and round upwards
+@return Returns a divided by 2^b
+*/
+static INLINE int int_ceildivpow2(int a, int b) {
+	return (a + (1 << b) - 1) >> b;
+}
+/**
+Divide an integer by a power of 2 and round downwards
+@return Returns a divided by 2^b
+*/
+static INLINE int int_floordivpow2(int a, int b) {
+	return a >> b;
+}
+/**
+Get logarithm of an integer and round downwards
+@return Returns log2(a)
+*/
+static INLINE int int_floorlog2(int a) {
+	int l;
+	for (l = 0; a > 1; l++) {
+		a >>= 1;
+	}
+	return l;
+}
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k.c.svn-base ./libopenjpeg/.svn/text-base/j2k.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/j2k.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,2535 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Write the SOC marker (Start Of Codestream)
+@param j2k J2K handle
+*/
+static void j2k_write_soc(opj_j2k_t *j2k);
+/**
+Read the SOC marker (Start of Codestream)
+@param j2k J2K handle
+*/
+static void j2k_read_soc(opj_j2k_t *j2k);
+/**
+Write the SIZ marker (image and tile size)
+@param j2k J2K handle
+*/
+static void j2k_write_siz(opj_j2k_t *j2k);
+/**
+Read the SIZ marker (image and tile size)
+@param j2k J2K handle
+*/
+static void j2k_read_siz(opj_j2k_t *j2k);
+/**
+Write the COM marker (comment)
+@param j2k J2K handle
+*/
+static void j2k_write_com(opj_j2k_t *j2k);
+/**
+Read the COM marker (comment)
+@param j2k J2K handle
+*/
+static void j2k_read_com(opj_j2k_t *j2k);
+/**
+Write the value concerning the specified component in the marker COD and COC
+@param j2k J2K handle
+@param compno Number of the component concerned by the information written
+*/
+static void j2k_write_cox(opj_j2k_t *j2k, int compno);
+/**
+Read the value concerning the specified component in the marker COD and COC
+@param j2k J2K handle
+@param compno Number of the component concerned by the information read
+*/
+static void j2k_read_cox(opj_j2k_t *j2k, int compno);
+/**
+Write the COD marker (coding style default)
+@param j2k J2K handle
+*/
+static void j2k_write_cod(opj_j2k_t *j2k);
+/**
+Read the COD marker (coding style default)
+@param j2k J2K handle
+*/
+static void j2k_read_cod(opj_j2k_t *j2k);
+/**
+Write the COC marker (coding style component)
+@param j2k J2K handle
+@param compno Number of the component concerned by the information written
+*/
+static void j2k_write_coc(opj_j2k_t *j2k, int compno);
+/**
+Read the COC marker (coding style component)
+@param j2k J2K handle
+*/
+static void j2k_read_coc(opj_j2k_t *j2k);
+/**
+Write the value concerning the specified component in the marker QCD and QCC
+@param j2k J2K handle
+@param compno Number of the component concerned by the information written
+*/
+static void j2k_write_qcx(opj_j2k_t *j2k, int compno);
+/**
+Read the value concerning the specified component in the marker QCD and QCC
+@param j2k J2K handle
+@param compno Number of the component concern by the information read
+@param len Length of the information in the QCX part of the marker QCD/QCC
+*/
+static void j2k_read_qcx(opj_j2k_t *j2k, int compno, int len);
+/**
+Write the QCD marker (quantization default)
+@param j2k J2K handle
+*/
+static void j2k_write_qcd(opj_j2k_t *j2k);
+/**
+Read the QCD marker (quantization default)
+@param j2k J2K handle
+*/
+static void j2k_read_qcd(opj_j2k_t *j2k);
+/**
+Write the QCC marker (quantization component)
+@param j2k J2K handle
+@param compno Number of the component concerned by the information written
+*/
+static void j2k_write_qcc(opj_j2k_t *j2k, int compno);
+/**
+Read the QCC marker (quantization component)
+@param j2k J2K handle
+*/
+static void j2k_read_qcc(opj_j2k_t *j2k);
+/**
+Write the POC marker (progression order change)
+@param j2k J2K handle
+*/
+static void j2k_write_poc(opj_j2k_t *j2k);
+/**
+Read the POC marker (progression order change)
+@param j2k J2K handle
+*/
+static void j2k_read_poc(opj_j2k_t *j2k);
+/**
+Read the CRG marker (component registration)
+@param j2k J2K handle
+*/
+static void j2k_read_crg(opj_j2k_t *j2k);
+/**
+Read the TLM marker (tile-part lengths)
+@param j2k J2K handle
+*/
+static void j2k_read_tlm(opj_j2k_t *j2k);
+/**
+Read the PLM marker (packet length, main header)
+@param j2k J2K handle
+*/
+static void j2k_read_plm(opj_j2k_t *j2k);
+/**
+Read the PLT marker (packet length, tile-part header)
+@param j2k J2K handle
+*/
+static void j2k_read_plt(opj_j2k_t *j2k);
+/**
+Read the PPM marker (packet packet headers, main header)
+@param j2k J2K handle
+*/
+static void j2k_read_ppm(opj_j2k_t *j2k);
+/**
+Read the PPT marker (packet packet headers, tile-part header)
+@param j2k J2K handle
+*/
+static void j2k_read_ppt(opj_j2k_t *j2k);
+/**
+Write the TLM marker (Mainheader)
+@param j2k J2K handle
+*/
+static void j2k_write_tlm(opj_j2k_t *j2k);
+/**
+Write the SOT marker (start of tile-part)
+@param j2k J2K handle
+*/
+static void j2k_write_sot(opj_j2k_t *j2k);
+/**
+Read the SOT marker (start of tile-part)
+@param j2k J2K handle
+*/
+static void j2k_read_sot(opj_j2k_t *j2k);
+/**
+Write the SOD marker (start of data)
+@param j2k J2K handle
+@param tile_coder Pointer to a TCD handle
+*/
+static void j2k_write_sod(opj_j2k_t *j2k, void *tile_coder);
+/**
+Read the SOD marker (start of data)
+@param j2k J2K handle
+*/
+static void j2k_read_sod(opj_j2k_t *j2k);
+/**
+Write the RGN marker (region-of-interest)
+@param j2k J2K handle
+@param compno Number of the component concerned by the information written
+@param tileno Number of the tile concerned by the information written
+*/
+static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno);
+/**
+Read the RGN marker (region-of-interest)
+@param j2k J2K handle
+*/
+static void j2k_read_rgn(opj_j2k_t *j2k);
+/**
+Write the EOC marker (end of codestream)
+@param j2k J2K handle
+*/
+static void j2k_write_eoc(opj_j2k_t *j2k);
+/**
+Read the EOC marker (end of codestream)
+@param j2k J2K handle
+*/
+static void j2k_read_eoc(opj_j2k_t *j2k);
+/**
+Read an unknown marker
+@param j2k J2K handle
+*/
+static void j2k_read_unk(opj_j2k_t *j2k);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+typedef struct j2k_prog_order{
+	OPJ_PROG_ORDER enum_prog;
+	char str_prog[4];
+}j2k_prog_order_t;
+
+j2k_prog_order_t j2k_prog_order_list[] = {
+	{CPRL, "CPRL"},
+	{LRCP, "LRCP"},
+	{PCRL, "PCRL"},
+	{RLCP, "RLCP"},
+	{RPCL, "RPCL"},
+	{-1, ""}
+};
+
+char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order){
+	j2k_prog_order_t *po;
+	for(po = j2k_prog_order_list; po->enum_prog != -1; po++ ){
+		if(po->enum_prog == prg_order){
+			break;
+		}
+	}
+	return po->str_prog;
+}
+
+static void j2k_check_poc_val(opj_cparameters_t *parameters, int numcomps, int numlayers){
+	int* packet_array;
+	int index, resno, compno, layno, i;
+	int step_c = 1;
+	int step_r = numcomps * step_c;
+	int step_l = parameters->numresolution * step_r;
+	bool loss = false;
+	packet_array = (int*) opj_calloc(step_l * numlayers, sizeof(int));
+	
+	for (i = 0; i < parameters->numpocs ; i++) {
+		int layno0 = 0;
+		if(i > 0)
+			layno0 = (parameters->POC[i].layno1 > parameters->POC[i-1].layno1 )? parameters->POC[i-1].layno1 : 0;
+		for (resno = parameters->POC[i].resno0 ; resno < parameters->POC[i].resno1 ; resno++) {
+			for (compno = parameters->POC[i].compno0 ; compno < parameters->POC[i].compno1 ; compno++) {
+				for (layno = layno0; layno < parameters->POC[i].layno1 ; layno++) {
+					index = step_r * resno + step_c * compno + step_l * layno;
+					packet_array[index]= 1;
+				}
+			}
+		}
+	}
+	for (resno = 0; resno < parameters->numresolution; resno++) {
+		for (compno = 0; compno < numcomps; compno++) {
+			for (layno = 0; layno < numlayers ; layno++) {
+				index = step_r * resno + step_c * compno + step_l * layno;
+				if(!(	packet_array[index]== 1)){
+					loss = true;
+				}
+			}
+		}
+	}
+	if(loss)
+		fprintf(stdout,"Missing packets possible loss of data\n");
+	opj_free(packet_array);
+}
+
+void j2k_dump_image(FILE *fd, opj_image_t * img) {
+	int compno;
+	fprintf(fd, "image {\n");
+	fprintf(fd, "  x0=%d, y0=%d, x1=%d, y1=%d\n", img->x0, img->y0, img->x1, img->y1);
+	fprintf(fd, "  numcomps=%d\n", img->numcomps);
+	for (compno = 0; compno < img->numcomps; compno++) {
+		opj_image_comp_t *comp = &img->comps[compno];
+		fprintf(fd, "  comp %d {\n", compno);
+		fprintf(fd, "    dx=%d, dy=%d\n", comp->dx, comp->dy);
+		fprintf(fd, "    prec=%d\n", comp->prec);
+		fprintf(fd, "    sgnd=%d\n", comp->sgnd);
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+void j2k_dump_cp(FILE *fd, opj_image_t * img, opj_cp_t * cp) {
+	int tileno, compno, layno, bandno, resno, numbands;
+	fprintf(fd, "coding parameters {\n");
+	fprintf(fd, "  tx0=%d, ty0=%d\n", cp->tx0, cp->ty0);
+	fprintf(fd, "  tdx=%d, tdy=%d\n", cp->tdx, cp->tdy);
+	fprintf(fd, "  tw=%d, th=%d\n", cp->tw, cp->th);
+	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		fprintf(fd, "  tile %d {\n", tileno);
+		fprintf(fd, "    csty=%x\n", tcp->csty);
+		fprintf(fd, "    prg=%d\n", tcp->prg);
+		fprintf(fd, "    numlayers=%d\n", tcp->numlayers);
+		fprintf(fd, "    mct=%d\n", tcp->mct);
+		fprintf(fd, "    rates=");
+		for (layno = 0; layno < tcp->numlayers; layno++) {
+			fprintf(fd, "%.1f ", tcp->rates[layno]);
+		}
+		fprintf(fd, "\n");
+		for (compno = 0; compno < img->numcomps; compno++) {
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			fprintf(fd, "    comp %d {\n", compno);
+			fprintf(fd, "      csty=%x\n", tccp->csty);
+			fprintf(fd, "      numresolutions=%d\n", tccp->numresolutions);
+			fprintf(fd, "      cblkw=%d\n", tccp->cblkw);
+			fprintf(fd, "      cblkh=%d\n", tccp->cblkh);
+			fprintf(fd, "      cblksty=%x\n", tccp->cblksty);
+			fprintf(fd, "      qmfbid=%d\n", tccp->qmfbid);
+			fprintf(fd, "      qntsty=%d\n", tccp->qntsty);
+			fprintf(fd, "      numgbits=%d\n", tccp->numgbits);
+			fprintf(fd, "      roishift=%d\n", tccp->roishift);
+			fprintf(fd, "      stepsizes=");
+			numbands = tccp->qntsty == J2K_CCP_QNTSTY_SIQNT ? 1 : tccp->numresolutions * 3 - 2;
+			for (bandno = 0; bandno < numbands; bandno++) {
+				fprintf(fd, "(%d,%d) ", tccp->stepsizes[bandno].mant,
+					tccp->stepsizes[bandno].expn);
+			}
+			fprintf(fd, "\n");
+			
+			if (tccp->csty & J2K_CCP_CSTY_PRT) {
+				fprintf(fd, "      prcw=");
+				for (resno = 0; resno < tccp->numresolutions; resno++) {
+					fprintf(fd, "%d ", tccp->prcw[resno]);
+				}
+				fprintf(fd, "\n");
+				fprintf(fd, "      prch=");
+				for (resno = 0; resno < tccp->numresolutions; resno++) {
+					fprintf(fd, "%d ", tccp->prch[resno]);
+				}
+				fprintf(fd, "\n");
+			}
+			fprintf(fd, "    }\n");
+		}
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+/* ----------------------------------------------------------------------- */
+static int j2k_get_num_tp(opj_cp_t *cp,int pino,int tileno){
+	char *prog;
+	int i;
+	int tpnum=1,tpend=0;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	prog = j2k_convert_progression_order(tcp->prg);
+	
+	if(cp->tp_on == 1){
+		for(i=0;i<4;i++){
+			if(tpend!=1){
+				if( cp->tp_flag == prog[i] ){
+					tpend=1;cp->tp_pos=i;
+				}
+				switch(prog[i]){
+				case 'C':
+					tpnum= tpnum * tcp->pocs[pino].compE;
+					break;
+				case 'R':
+					tpnum= tpnum * tcp->pocs[pino].resE;
+					break;
+				case 'P':
+					tpnum= tpnum * tcp->pocs[pino].prcE;
+					break;
+				case 'L':
+					tpnum= tpnum * tcp->pocs[pino].layE;
+					break;
+				}
+			}
+		}
+	}else{
+		tpnum=1;
+	}
+	return tpnum;
+}
+
+/**	mem allocation for TLM marker*/
+int j2k_calculate_tp(opj_cp_t *cp,int img_numcomp,opj_image_t *image,opj_j2k_t *j2k ){
+	int pino,tileno,totnum_tp=0;
+	j2k->cur_totnum_tp = (int *) opj_malloc(cp->tw * cp->th * sizeof(int));
+	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+		int cur_totnum_tp = 0;
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		for(pino = 0; pino <= tcp->numpocs; pino++) {
+			int tp_num=0;
+			opj_pi_iterator_t *pi = pi_initialise_encode(image, cp, tileno,FINAL_PASS);
+			if(!pi) { return -1;}
+			tp_num = j2k_get_num_tp(cp,pino,tileno);
+			totnum_tp = totnum_tp + tp_num;
+			cur_totnum_tp = cur_totnum_tp + tp_num;
+			pi_destroy(pi, cp, tileno);
+		}
+		j2k->cur_totnum_tp[tileno] = cur_totnum_tp;
+		/* INDEX >> */
+		if (j2k->cstr_info) {
+			j2k->cstr_info->tile[tileno].num_tps = cur_totnum_tp;
+			j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(cur_totnum_tp * sizeof(opj_tp_info_t));
+		}
+		/* << INDEX */
+	}
+	return totnum_tp;
+}
+
+static void j2k_write_soc(opj_j2k_t *j2k) {
+	opj_cio_t *cio = j2k->cio;
+	cio_write(cio, J2K_MS_SOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOC, cio_tell(cio) - 2, 2);
+
+#endif /* USE_JPWL */
+/* <<UniPG */
+}
+
+static void j2k_read_soc(opj_j2k_t *j2k) {	
+	j2k->state = J2K_STATE_MHSIZ;
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->main_head_start = cio_tell(j2k->cio) - 2;
+		j2k->cstr_info->codestream_size = cio_numbytesleft(j2k->cio) + 2 - j2k->cstr_info->main_head_start;
+	}
+}
+
+static void j2k_write_siz(opj_j2k_t *j2k) {
+	int i;
+	int lenp, len;
+
+	opj_cio_t *cio = j2k->cio;
+	opj_image_t *image = j2k->image;
+	opj_cp_t *cp = j2k->cp;
+	
+	cio_write(cio, J2K_MS_SIZ, 2);	/* SIZ */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, cp->rsiz, 2);			/* Rsiz (capabilities) */
+	cio_write(cio, image->x1, 4);	/* Xsiz */
+	cio_write(cio, image->y1, 4);	/* Ysiz */
+	cio_write(cio, image->x0, 4);	/* X0siz */
+	cio_write(cio, image->y0, 4);	/* Y0siz */
+	cio_write(cio, cp->tdx, 4);		/* XTsiz */
+	cio_write(cio, cp->tdy, 4);		/* YTsiz */
+	cio_write(cio, cp->tx0, 4);		/* XT0siz */
+	cio_write(cio, cp->ty0, 4);		/* YT0siz */
+	cio_write(cio, image->numcomps, 2);	/* Csiz */
+	for (i = 0; i < image->numcomps; i++) {
+		cio_write(cio, image->comps[i].prec - 1 + (image->comps[i].sgnd << 7), 1);	/* Ssiz_i */
+		cio_write(cio, image->comps[i].dx, 1);	/* XRsiz_i */
+		cio_write(cio, image->comps[i].dy, 1);	/* YRsiz_i */
+	}
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lsiz */
+	cio_seek(cio, lenp + len);
+}
+
+static void j2k_read_siz(opj_j2k_t *j2k) {
+	int len, i;
+	
+	opj_cio_t *cio = j2k->cio;
+	opj_image_t *image = j2k->image;
+	opj_cp_t *cp = j2k->cp;
+	
+	len = cio_read(cio, 2);			/* Lsiz */
+	cio_read(cio, 2);				/* Rsiz (capabilities) */
+	image->x1 = cio_read(cio, 4);	/* Xsiz */
+	image->y1 = cio_read(cio, 4);	/* Ysiz */
+	image->x0 = cio_read(cio, 4);	/* X0siz */
+	image->y0 = cio_read(cio, 4);	/* Y0siz */
+	cp->tdx = cio_read(cio, 4);		/* XTsiz */
+	cp->tdy = cio_read(cio, 4);		/* YTsiz */
+	cp->tx0 = cio_read(cio, 4);		/* XT0siz */
+	cp->ty0 = cio_read(cio, 4);		/* YT0siz */
+	
+	image->numcomps = cio_read(cio, 2);	/* Csiz */
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+		/* if JPWL is on, we check whether TX errors have damaged
+		  too much the SIZ parameters */
+		if (!(image->x1 * image->y1)) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"JPWL: bad image size (%d x %d)\n",
+				image->x1, image->y1);
+			if (!JPWL_ASSUME || JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+		}
+		if (image->numcomps != ((len - 38) / 3)) {
+			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+				"JPWL: Csiz is %d => space in SIZ only for %d comps.!!!\n",
+				image->numcomps, ((len - 38) / 3));
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n");
+			if (image->numcomps < ((len - 38) / 3)) {
+				len = 38 + 3 * image->numcomps;
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting Lsiz to %d => HYPOTHESIS!!!\n",
+					len);				
+			} else {
+				image->numcomps = ((len - 38) / 3);
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting Csiz to %d => HYPOTHESIS!!!\n",
+					image->numcomps);				
+			}
+		}
+
+		/* update components number in the jpwl_exp_comps filed */
+		cp->exp_comps = image->numcomps;
+	}
+#endif /* USE_JPWL */
+
+	image->comps = (opj_image_comp_t*) opj_calloc(image->numcomps, sizeof(opj_image_comp_t));
+	for (i = 0; i < image->numcomps; i++) {
+		int tmp, w, h;
+		tmp = cio_read(cio, 1);		/* Ssiz_i */
+		image->comps[i].prec = (tmp & 0x7f) + 1;
+		image->comps[i].sgnd = tmp >> 7;
+		image->comps[i].dx = cio_read(cio, 1);	/* XRsiz_i */
+		image->comps[i].dy = cio_read(cio, 1);	/* YRsiz_i */
+		
+#ifdef USE_JPWL
+		if (j2k->cp->correct) {
+		/* if JPWL is on, we check whether TX errors have damaged
+			too much the SIZ parameters, again */
+			if (!(image->comps[i].dx * image->comps[i].dy)) {
+				opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+					"JPWL: bad XRsiz_%d/YRsiz_%d (%d x %d)\n",
+					i, i, image->comps[i].dx, image->comps[i].dy);
+				if (!JPWL_ASSUME) {
+					opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+					return;
+				}
+				/* we try to correct */
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n");
+				if (!image->comps[i].dx) {
+					image->comps[i].dx = 1;
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting XRsiz_%d to %d => HYPOTHESIS!!!\n",
+						i, image->comps[i].dx);
+				}
+				if (!image->comps[i].dy) {
+					image->comps[i].dy = 1;
+					opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting YRsiz_%d to %d => HYPOTHESIS!!!\n",
+						i, image->comps[i].dy);
+				}
+			}
+			
+		}
+#endif /* USE_JPWL */
+
+		/* TODO: unused ? */
+		w = int_ceildiv(image->x1 - image->x0, image->comps[i].dx);
+		h = int_ceildiv(image->y1 - image->y0, image->comps[i].dy);
+
+		image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
+		image->comps[i].factor = cp->reduce; /* reducing factor per component */
+	}
+	
+	cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
+	cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+		/* if JPWL is on, we check whether TX errors have damaged
+		  too much the SIZ parameters */
+		if ((cp->tw < 1) || (cp->th < 1) || (cp->tw > cp->max_tiles) || (cp->th > cp->max_tiles)) {
+			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+				"JPWL: bad number of tiles (%d x %d)\n",
+				cp->tw, cp->th);
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n");
+			if (cp->tw < 1) {
+				cp->tw= 1;
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting %d tiles in x => HYPOTHESIS!!!\n",
+					cp->tw);
+			}
+			if (cp->tw > cp->max_tiles) {
+				cp->tw= 1;
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- too large x, increase expectance of %d\n"
+					"- setting %d tiles in x => HYPOTHESIS!!!\n",
+					cp->max_tiles, cp->tw);
+			}
+			if (cp->th < 1) {
+				cp->th= 1;
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- setting %d tiles in y => HYPOTHESIS!!!\n",
+					cp->th);
+			}
+			if (cp->th > cp->max_tiles) {
+				cp->th= 1;
+				opj_event_msg(j2k->cinfo, EVT_WARNING, "- too large y, increase expectance of %d to continue\n",
+					"- setting %d tiles in y => HYPOTHESIS!!!\n",
+					cp->max_tiles, cp->th);
+			}
+		}
+	}
+#endif /* USE_JPWL */
+
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+	cp->tileno = (int*) opj_malloc(cp->tw * cp->th * sizeof(int));
+	cp->tileno_size = 0;
+	
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+		if (!cp->tcps) {
+			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+				"JPWL: could not alloc tcps field of cp\n");
+			if (!JPWL_ASSUME || JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+		}
+	}
+#endif /* USE_JPWL */
+
+	for (i = 0; i < cp->tw * cp->th; i++) {
+		cp->tcps[i].POC = 0;
+		cp->tcps[i].numpocs = 0;
+		cp->tcps[i].first = 1;
+	}
+	
+	/* Initialization for PPM marker */
+	cp->ppm = 0;
+	cp->ppm_data = NULL;
+	cp->ppm_data_first = NULL;
+	cp->ppm_previous = 0;
+	cp->ppm_store = 0;
+
+	j2k->default_tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+	for (i = 0; i < cp->tw * cp->th; i++) {
+		cp->tcps[i].tccps = (opj_tccp_t*) opj_malloc(image->numcomps * sizeof(opj_tccp_t));
+	}	
+	j2k->tile_data = (unsigned char**) opj_calloc(cp->tw * cp->th, sizeof(unsigned char*));
+	j2k->tile_len = (int*) opj_calloc(cp->tw * cp->th, sizeof(int));
+	j2k->state = J2K_STATE_MH;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	
+		cstr_info->tile_y = cp->tdy;	
+		cstr_info->tile_Ox = cp->tx0;	
+		cstr_info->tile_Oy = cp->ty0;			
+		cstr_info->tile = (opj_tile_info_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tile_info_t));		
+	}
+}
+
+static void j2k_write_com(opj_j2k_t *j2k) {
+	unsigned int i;
+	int lenp, len;
+
+	if(j2k->cp->comment) {
+		opj_cio_t *cio = j2k->cio;
+		char *comment = j2k->cp->comment;
+
+		cio_write(cio, J2K_MS_COM, 2);
+		lenp = cio_tell(cio);
+		cio_skip(cio, 2);
+		cio_write(cio, 1, 2);		/* General use (IS 8859-15:1999 (Latin) values) */
+		for (i = 0; i < strlen(comment); i++) {
+			cio_write(cio, comment[i], 1);
+		}
+		len = cio_tell(cio) - lenp;
+		cio_seek(cio, lenp);
+		cio_write(cio, len, 2);
+		cio_seek(cio, lenp + len);
+	}
+}
+
+static void j2k_read_com(opj_j2k_t *j2k) {
+	int len;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	len = cio_read(cio, 2);
+	cio_skip(cio, len - 2);  
+}
+
+static void j2k_write_cox(opj_j2k_t *j2k, int compno) {
+	int i;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, tccp->numresolutions - 1, 1);	/* SPcox (D) */
+	cio_write(cio, tccp->cblkw - 2, 1);				/* SPcox (E) */
+	cio_write(cio, tccp->cblkh - 2, 1);				/* SPcox (F) */
+	cio_write(cio, tccp->cblksty, 1);				/* SPcox (G) */
+	cio_write(cio, tccp->qmfbid, 1);				/* SPcox (H) */
+	
+	if (tccp->csty & J2K_CCP_CSTY_PRT) {
+		for (i = 0; i < tccp->numresolutions; i++) {
+			cio_write(cio, tccp->prcw[i] + (tccp->prch[i] << 4), 1);	/* SPcox (I_i) */
+		}
+	}
+}
+
+static void j2k_read_cox(opj_j2k_t *j2k, int compno) {
+	int i;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j2k->cio;
+
+	tccp->numresolutions = cio_read(cio, 1) + 1;	/* SPcox (D) */
+
+	// If user wants to remove more resolutions than the codestream contains, return error
+	if (cp->reduce >= tccp->numresolutions) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Error decoding component %d.\nThe number of resolutions to remove is higher than the number "
+					"of resolutions of this component\nModify the cp_reduce parameter.\n\n", compno);
+		j2k->state |= J2K_STATE_ERR;
+	}
+
+	tccp->cblkw = cio_read(cio, 1) + 2;	/* SPcox (E) */
+	tccp->cblkh = cio_read(cio, 1) + 2;	/* SPcox (F) */
+	tccp->cblksty = cio_read(cio, 1);	/* SPcox (G) */
+	tccp->qmfbid = cio_read(cio, 1);	/* SPcox (H) */
+	if (tccp->csty & J2K_CP_CSTY_PRT) {
+		for (i = 0; i < tccp->numresolutions; i++) {
+			int tmp = cio_read(cio, 1);	/* SPcox (I_i) */
+			tccp->prcw[i] = tmp & 0xf;
+			tccp->prch[i] = tmp >> 4;
+		}
+	}
+
+	/* INDEX >> */
+	if(j2k->cstr_info && compno == 0) {
+		for (i = 0; i < tccp->numresolutions; i++) {
+			if (tccp->csty & J2K_CP_CSTY_PRT) {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = tccp->prcw[i];
+				j2k->cstr_info->tile[j2k->curtileno].pdy[i] = tccp->prch[i];
+			}
+			else {
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+				j2k->cstr_info->tile[j2k->curtileno].pdx[i] = 15;
+			}
+		}
+	}
+	/* << INDEX */
+}
+
+static void j2k_write_cod(opj_j2k_t *j2k) {
+	opj_cp_t *cp = NULL;
+	opj_tcp_t *tcp = NULL;
+	int lenp, len;
+
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, J2K_MS_COD, 2);	/* COD */
+	
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	
+	cp = j2k->cp;
+	tcp = &cp->tcps[j2k->curtileno];
+
+	cio_write(cio, tcp->csty, 1);		/* Scod */
+	cio_write(cio, tcp->prg, 1);		/* SGcod (A) */
+	cio_write(cio, tcp->numlayers, 2);	/* SGcod (B) */
+	cio_write(cio, tcp->mct, 1);		/* SGcod (C) */
+	
+	j2k_write_cox(j2k, 0);
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);		/* Lcod */
+	cio_seek(cio, lenp + len);
+}
+
+static void j2k_read_cod(opj_j2k_t *j2k) {
+	int len, i, pos;
+	
+	opj_cio_t *cio = j2k->cio;
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_image_t *image = j2k->image;
+	
+	len = cio_read(cio, 2);				/* Lcod */
+	tcp->csty = cio_read(cio, 1);		/* Scod */
+	tcp->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);		/* SGcod (A) */
+	tcp->numlayers = cio_read(cio, 2);	/* SGcod (B) */
+	tcp->mct = cio_read(cio, 1);		/* SGcod (C) */
+	
+	pos = cio_tell(cio);
+	for (i = 0; i < image->numcomps; i++) {
+		tcp->tccps[i].csty = tcp->csty & J2K_CP_CSTY_PRT;
+		cio_seek(cio, pos);
+		j2k_read_cox(j2k, i);
+	}
+
+	/* Index */
+	if (j2k->cstr_info) {
+		opj_codestream_info_t *cstr_info = j2k->cstr_info;
+		cstr_info->prog = tcp->prg;
+		cstr_info->numlayers = tcp->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (i = 0; i < image->numcomps; i++) {
+			cstr_info->numdecompos[i] = tcp->tccps[i].numresolutions - 1;
+		}
+	}
+}
+
+static void j2k_write_coc(opj_j2k_t *j2k, int compno) {
+	int lenp, len;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
+	opj_image_t *image = j2k->image;
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, J2K_MS_COC, 2);	/* COC */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, compno, image->numcomps <= 256 ? 1 : 2);	/* Ccoc */
+	cio_write(cio, tcp->tccps[compno].csty, 1);	/* Scoc */
+	j2k_write_cox(j2k, compno);
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lcoc */
+	cio_seek(cio, lenp + len);
+}
+
+static void j2k_read_coc(opj_j2k_t *j2k) {
+	int len, compno;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_image_t *image = j2k->image;
+	opj_cio_t *cio = j2k->cio;
+	
+	len = cio_read(cio, 2);		/* Lcoc */
+	compno = cio_read(cio, image->numcomps <= 256 ? 1 : 2);	/* Ccoc */
+	tcp->tccps[compno].csty = cio_read(cio, 1);	/* Scoc */
+	j2k_read_cox(j2k, compno);
+}
+
+static void j2k_write_qcx(opj_j2k_t *j2k, int compno) {
+	int bandno, numbands;
+	int expn, mant;
+	
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, tccp->qntsty + (tccp->numgbits << 5), 1);	/* Sqcx */
+	numbands = tccp->qntsty == J2K_CCP_QNTSTY_SIQNT ? 1 : tccp->numresolutions * 3 - 2;
+	
+	for (bandno = 0; bandno < numbands; bandno++) {
+		expn = tccp->stepsizes[bandno].expn;
+		mant = tccp->stepsizes[bandno].mant;
+		
+		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
+			cio_write(cio, expn << 3, 1);	/* SPqcx_i */
+		} else {
+			cio_write(cio, (expn << 11) + mant, 2);	/* SPqcx_i */
+		}
+	}
+}
+
+static void j2k_read_qcx(opj_j2k_t *j2k, int compno, int len) {
+	int tmp;
+	int bandno, numbands;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_tccp_t *tccp = &tcp->tccps[compno];
+	opj_cio_t *cio = j2k->cio;
+
+	tmp = cio_read(cio, 1);		/* Sqcx */
+	tccp->qntsty = tmp & 0x1f;
+	tccp->numgbits = tmp >> 5;
+	numbands = (tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) ? 
+		1 : ((tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) ? len - 1 : (len - 1) / 2);
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+
+		/* if JPWL is on, we check whether there are too many subbands */
+		if ((numbands < 0) || (numbands >= J2K_MAXBANDS)) {
+			opj_event_msg(j2k->cinfo, JPWL_ASSUME ? EVT_WARNING : EVT_ERROR,
+				"JPWL: bad number of subbands in Sqcx (%d)\n",
+				numbands);
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			numbands = 1;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust them\n"
+				"- setting number of bands to %d => HYPOTHESIS!!!\n",
+				numbands);
+		};
+
+	};
+#endif /* USE_JPWL */
+
+	for (bandno = 0; bandno < numbands; bandno++) {
+		int expn, mant;
+		if (tccp->qntsty == J2K_CCP_QNTSTY_NOQNT) {
+			expn = cio_read(cio, 1) >> 3;	/* SPqcx_i */
+			mant = 0;
+		} else {
+			tmp = cio_read(cio, 2);	/* SPqcx_i */
+			expn = tmp >> 11;
+			mant = tmp & 0x7ff;
+		}
+		tccp->stepsizes[bandno].expn = expn;
+		tccp->stepsizes[bandno].mant = mant;
+	}
+	
+	/* Add Antonin : if scalar_derived -> compute other stepsizes */
+	if (tccp->qntsty == J2K_CCP_QNTSTY_SIQNT) {
+		for (bandno = 1; bandno < J2K_MAXBANDS; bandno++) {
+			tccp->stepsizes[bandno].expn = 
+				((tccp->stepsizes[0].expn) - ((bandno - 1) / 3) > 0) ? 
+					(tccp->stepsizes[0].expn) - ((bandno - 1) / 3) : 0;
+			tccp->stepsizes[bandno].mant = tccp->stepsizes[0].mant;
+		}
+	}
+	/* ddA */
+}
+
+static void j2k_write_qcd(opj_j2k_t *j2k) {
+	int lenp, len;
+
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, J2K_MS_QCD, 2);	/* QCD */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	j2k_write_qcx(j2k, 0);
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lqcd */
+	cio_seek(cio, lenp + len);
+}
+
+static void j2k_read_qcd(opj_j2k_t *j2k) {
+	int len, i, pos;
+
+	opj_cio_t *cio = j2k->cio;
+	opj_image_t *image = j2k->image;
+	
+	len = cio_read(cio, 2);		/* Lqcd */
+	pos = cio_tell(cio);
+	for (i = 0; i < image->numcomps; i++) {
+		cio_seek(cio, pos);
+		j2k_read_qcx(j2k, i, len - 2);
+	}
+}
+
+static void j2k_write_qcc(opj_j2k_t *j2k, int compno) {
+	int lenp, len;
+
+	opj_cio_t *cio = j2k->cio;
+	
+	cio_write(cio, J2K_MS_QCC, 2);	/* QCC */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);
+	cio_write(cio, compno, j2k->image->numcomps <= 256 ? 1 : 2);	/* Cqcc */
+	j2k_write_qcx(j2k, compno);
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);			/* Lqcc */
+	cio_seek(cio, lenp + len);
+}
+
+static void j2k_read_qcc(opj_j2k_t *j2k) {
+	int len, compno;
+	int numcomp = j2k->image->numcomps;
+	opj_cio_t *cio = j2k->cio;
+	
+	len = cio_read(cio, 2);	/* Lqcc */
+	compno = cio_read(cio, numcomp <= 256 ? 1 : 2);	/* Cqcc */
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+
+		static int backup_compno = 0;
+
+		/* compno is negative or larger than the number of components!!! */
+		if ((compno < 0) || (compno >= numcomp)) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"JPWL: bad component number in QCC (%d out of a maximum of %d)\n",
+				compno, numcomp);
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			compno = backup_compno % numcomp;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
+				"- setting component number to %d\n",
+				compno);
+		}
+
+		/* keep your private count of tiles */
+		backup_compno++;
+	};
+#endif /* USE_JPWL */
+
+	j2k_read_qcx(j2k, compno, len - 2 - (numcomp <= 256 ? 1 : 2));
+}
+
+static void j2k_write_poc(opj_j2k_t *j2k) {
+	int len, numpchgs, i;
+
+	int numcomps = j2k->image->numcomps;
+	
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = &cp->tcps[j2k->curtileno];
+	opj_tccp_t *tccp = &tcp->tccps[0];
+	opj_cio_t *cio = j2k->cio;
+
+	numpchgs = 1 + tcp->numpocs;
+	cio_write(cio, J2K_MS_POC, 2);	/* POC  */
+	len = 2 + (5 + 2 * (numcomps <= 256 ? 1 : 2)) * numpchgs;
+	cio_write(cio, len, 2);		/* Lpoc */
+	for (i = 0; i < numpchgs; i++) {
+		opj_poc_t *poc = &tcp->pocs[i];
+		cio_write(cio, poc->resno0, 1);	/* RSpoc_i */
+		cio_write(cio, poc->compno0, (numcomps <= 256 ? 1 : 2));	/* CSpoc_i */
+		cio_write(cio, poc->layno1, 2);	/* LYEpoc_i */
+		poc->layno1 = int_min(poc->layno1, tcp->numlayers);
+		cio_write(cio, poc->resno1, 1);	/* REpoc_i */
+		poc->resno1 = int_min(poc->resno1, tccp->numresolutions);
+		cio_write(cio, poc->compno1, (numcomps <= 256 ? 1 : 2));	/* CEpoc_i */
+		poc->compno1 = int_min(poc->compno1, numcomps);
+		cio_write(cio, poc->prg, 1);	/* Ppoc_i */
+	}
+}
+
+static void j2k_read_poc(opj_j2k_t *j2k) {
+	int len, numpchgs, i, old_poc;
+
+	int numcomps = j2k->image->numcomps;
+	
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_cio_t *cio = j2k->cio;
+	
+	old_poc = tcp->POC ? tcp->numpocs + 1 : 0;
+	tcp->POC = 1;
+	len = cio_read(cio, 2);		/* Lpoc */
+	numpchgs = (len - 2) / (5 + 2 * (numcomps <= 256 ? 1 : 2));
+	
+	for (i = old_poc; i < numpchgs + old_poc; i++) {
+		opj_poc_t *poc;
+		poc = &tcp->pocs[i];
+		poc->resno0 = cio_read(cio, 1);	/* RSpoc_i */
+		poc->compno0 = cio_read(cio, numcomps <= 256 ? 1 : 2);	/* CSpoc_i */
+		poc->layno1 = cio_read(cio, 2);    /* LYEpoc_i */
+		poc->resno1 = cio_read(cio, 1);    /* REpoc_i */
+		poc->compno1 = int_min(
+			cio_read(cio, numcomps <= 256 ? 1 : 2), (unsigned int) numcomps);	/* CEpoc_i */
+		poc->prg = (OPJ_PROG_ORDER)cio_read(cio, 1);	/* Ppoc_i */
+	}
+	
+	tcp->numpocs = numpchgs + old_poc - 1;
+}
+
+static void j2k_read_crg(opj_j2k_t *j2k) {
+	int len, i, Xcrg_i, Ycrg_i;
+	
+	opj_cio_t *cio = j2k->cio;
+	int numcomps = j2k->image->numcomps;
+	
+	len = cio_read(cio, 2);			/* Lcrg */
+	for (i = 0; i < numcomps; i++) {
+		Xcrg_i = cio_read(cio, 2);	/* Xcrg_i */
+		Ycrg_i = cio_read(cio, 2);	/* Ycrg_i */
+	}
+}
+
+static void j2k_read_tlm(opj_j2k_t *j2k) {
+	int len, Ztlm, Stlm, ST, SP, tile_tlm, i;
+	long int Ttlm_i, Ptlm_i;
+
+	opj_cio_t *cio = j2k->cio;
+	
+	len = cio_read(cio, 2);		/* Ltlm */
+	Ztlm = cio_read(cio, 1);	/* Ztlm */
+	Stlm = cio_read(cio, 1);	/* Stlm */
+	ST = ((Stlm >> 4) & 0x01) + ((Stlm >> 4) & 0x02);
+	SP = (Stlm >> 6) & 0x01;
+	tile_tlm = (len - 4) / ((SP + 1) * 2 + ST);
+	for (i = 0; i < tile_tlm; i++) {
+		Ttlm_i = cio_read(cio, ST);	/* Ttlm_i */
+		Ptlm_i = cio_read(cio, SP ? 4 : 2);	/* Ptlm_i */
+	}
+}
+
+static void j2k_read_plm(opj_j2k_t *j2k) {
+	int len, i, Zplm, Nplm, add, packet_len = 0;
+	
+	opj_cio_t *cio = j2k->cio;
+
+	len = cio_read(cio, 2);		/* Lplm */
+	Zplm = cio_read(cio, 1);	/* Zplm */
+	len -= 3;
+	while (len > 0) {
+		Nplm = cio_read(cio, 4);		/* Nplm */
+		len -= 4;
+		for (i = Nplm; i > 0; i--) {
+			add = cio_read(cio, 1);
+			len--;
+			packet_len = (packet_len << 7) + add;	/* Iplm_ij */
+			if ((add & 0x80) == 0) {
+				/* New packet */
+				packet_len = 0;
+			}
+			if (len <= 0)
+				break;
+		}
+	}
+}
+
+static void j2k_read_plt(opj_j2k_t *j2k) {
+	int len, i, Zplt, packet_len = 0, add;
+	
+	opj_cio_t *cio = j2k->cio;
+	
+	len = cio_read(cio, 2);		/* Lplt */
+	Zplt = cio_read(cio, 1);	/* Zplt */
+	for (i = len - 3; i > 0; i--) {
+		add = cio_read(cio, 1);
+		packet_len = (packet_len << 7) + add;	/* Iplt_i */
+		if ((add & 0x80) == 0) {
+			/* New packet */
+			packet_len = 0;
+		}
+	}
+}
+
+static void j2k_read_ppm(opj_j2k_t *j2k) {
+	int len, Z_ppm, i, j;
+	int N_ppm;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_cio_t *cio = j2k->cio;
+	
+	len = cio_read(cio, 2);
+	cp->ppm = 1;
+	
+	Z_ppm = cio_read(cio, 1);	/* Z_ppm */
+	len -= 3;
+	while (len > 0) {
+		if (cp->ppm_previous == 0) {
+			N_ppm = cio_read(cio, 4);	/* N_ppm */
+			len -= 4;
+		} else {
+			N_ppm = cp->ppm_previous;
+		}
+		j = cp->ppm_store;
+		if (Z_ppm == 0) {	/* First PPM marker */
+			cp->ppm_data = (unsigned char *) opj_malloc(N_ppm * sizeof(unsigned char));
+			cp->ppm_data_first = cp->ppm_data;
+			cp->ppm_len = N_ppm;
+		} else {			/* NON-first PPM marker */
+			cp->ppm_data = (unsigned char *) opj_realloc(cp->ppm_data, (N_ppm +	cp->ppm_store) * sizeof(unsigned char));
+
+#ifdef USE_JPWL
+			/* this memory allocation check could be done even in non-JPWL cases */
+			if (cp->correct) {
+				if (!cp->ppm_data) {
+					opj_event_msg(j2k->cinfo, EVT_ERROR,
+						"JPWL: failed memory allocation during PPM marker parsing (pos. %x)\n",
+						cio_tell(cio));
+					if (!JPWL_ASSUME || JPWL_ASSUME) {
+						opj_free(cp->ppm_data);
+						opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+						return;
+					}
+				}
+			}
+#endif
+
+			cp->ppm_data_first = cp->ppm_data;
+			cp->ppm_len = N_ppm + cp->ppm_store;
+		}
+		for (i = N_ppm; i > 0; i--) {	/* Read packet header */
+			cp->ppm_data[j] = cio_read(cio, 1);
+			j++;
+			len--;
+			if (len == 0)
+				break;			/* Case of non-finished packet header in present marker but finished in next one */
+		}
+		cp->ppm_previous = i - 1;
+		cp->ppm_store = j;
+	}
+}
+
+static void j2k_read_ppt(opj_j2k_t *j2k) {
+	int len, Z_ppt, i, j = 0;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = cp->tcps + j2k->curtileno;
+	opj_cio_t *cio = j2k->cio;
+
+	len = cio_read(cio, 2);
+	Z_ppt = cio_read(cio, 1);
+	tcp->ppt = 1;
+	if (Z_ppt == 0) {		/* First PPT marker */
+		tcp->ppt_data = (unsigned char *) opj_malloc((len - 3) * sizeof(unsigned char));
+		tcp->ppt_data_first = tcp->ppt_data;
+		tcp->ppt_store = 0;
+		tcp->ppt_len = len - 3;
+	} else {			/* NON-first PPT marker */
+		tcp->ppt_data =	(unsigned char *) opj_realloc(tcp->ppt_data, (len - 3 + tcp->ppt_store) * sizeof(unsigned char));
+		tcp->ppt_data_first = tcp->ppt_data;
+		tcp->ppt_len = len - 3 + tcp->ppt_store;
+	}
+	j = tcp->ppt_store;
+	for (i = len - 3; i > 0; i--) {
+		tcp->ppt_data[j] = cio_read(cio, 1);
+		j++;
+	}
+	tcp->ppt_store = j;
+}
+
+static void j2k_write_tlm(opj_j2k_t *j2k){
+	int lenp;
+	opj_cio_t *cio = j2k->cio;
+	j2k->tlm_start = cio_tell(cio);
+	cio_write(cio, J2K_MS_TLM, 2);/* TLM */
+	lenp = 4 + (5*j2k->totnum_tp);
+	cio_write(cio,lenp,2);				/* Ltlm */
+	cio_write(cio, 0,1);					/* Ztlm=0*/
+	cio_write(cio,80,1);					/* Stlm ST=1(8bits-255 tiles max),SP=1(Ptlm=32bits) */
+	cio_skip(cio,5*j2k->totnum_tp);
+}
+
+static void j2k_write_sot(opj_j2k_t *j2k) {
+	int lenp, len;
+
+	opj_cio_t *cio = j2k->cio;
+
+	j2k->sot_start = cio_tell(cio);
+	cio_write(cio, J2K_MS_SOT, 2);		/* SOT */
+	lenp = cio_tell(cio);
+	cio_skip(cio, 2);					/* Lsot (further) */
+	cio_write(cio, j2k->curtileno, 2);	/* Isot */
+	cio_skip(cio, 4);					/* Psot (further in j2k_write_sod) */
+	cio_write(cio, j2k->cur_tp_num , 1);	/* TPsot */
+	cio_write(cio, j2k->cur_totnum_tp[j2k->curtileno], 1);		/* TNsot */
+	len = cio_tell(cio) - lenp;
+	cio_seek(cio, lenp);
+	cio_write(cio, len, 2);				/* Lsot */
+	cio_seek(cio, lenp + len);
+
+	/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_SOT, j2k->sot_start, len + 2);
+#endif /* USE_JPWL */
+	/* <<UniPG */
+}
+
+static void j2k_read_sot(opj_j2k_t *j2k) {
+	int len, tileno, totlen, partno, numparts, i;
+	opj_tcp_t *tcp = NULL;
+	char status = 0;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_cio_t *cio = j2k->cio;
+
+	len = cio_read(cio, 2);
+	tileno = cio_read(cio, 2);
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+
+		static int backup_tileno = 0;
+
+		/* tileno is negative or larger than the number of tiles!!! */
+		if ((tileno < 0) || (tileno > (cp->tw * cp->th))) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"JPWL: bad tile number (%d out of a maximum of %d)\n",
+				tileno, (cp->tw * cp->th));
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			tileno = backup_tileno;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
+				"- setting tile number to %d\n",
+				tileno);
+		}
+
+		/* keep your private count of tiles */
+		backup_tileno++;
+	};
+#endif /* USE_JPWL */
+	
+	if (cp->tileno_size == 0) {
+		cp->tileno[cp->tileno_size] = tileno;
+		cp->tileno_size++;
+	} else {
+		i = 0;
+		while (i < cp->tileno_size && status == 0) {
+			status = cp->tileno[i] == tileno ? 1 : 0;
+			i++;
+		}
+		if (status == 0) {
+			cp->tileno[cp->tileno_size] = tileno;
+			cp->tileno_size++;
+		}
+	}
+	
+	totlen = cio_read(cio, 4);
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+
+		/* totlen is negative or larger than the bytes left!!! */
+		if ((totlen < 0) || (totlen > (cio_numbytesleft(cio) + 8))) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"JPWL: bad tile byte size (%d bytes against %d bytes left)\n",
+				totlen, cio_numbytesleft(cio) + 8);
+			if (!JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+			/* we try to correct */
+			totlen = 0;
+			opj_event_msg(j2k->cinfo, EVT_WARNING, "- trying to adjust this\n"
+				"- setting Psot to %d => assuming it is the last tile\n",
+				totlen);
+		}
+
+	};
+#endif /* USE_JPWL */
+
+	if (!totlen)
+		totlen = cio_numbytesleft(cio) + 8;
+	
+	partno = cio_read(cio, 1);
+	numparts = cio_read(cio, 1);
+	
+	j2k->curtileno = tileno;
+	j2k->cur_tp_num = partno;
+	j2k->eot = cio_getbp(cio) - 12 + totlen;
+	j2k->state = J2K_STATE_TPH;
+	tcp = &cp->tcps[j2k->curtileno];
+
+	/* Index */
+	if (j2k->cstr_info) {
+		if (tcp->first) {
+			if (tileno == 0) 
+				j2k->cstr_info->main_head_end = cio_tell(cio) - 13;
+			j2k->cstr_info->tile[tileno].tileno = tileno;
+			j2k->cstr_info->tile[tileno].start_pos = cio_tell(cio) - 12;
+			j2k->cstr_info->tile[tileno].end_pos = j2k->cstr_info->tile[tileno].start_pos + totlen - 1;				
+			j2k->cstr_info->tile[tileno].num_tps = numparts;
+			if (numparts)
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(numparts * sizeof(opj_tp_info_t));
+			else
+				j2k->cstr_info->tile[tileno].tp = (opj_tp_info_t *) opj_malloc(10 * sizeof(opj_tp_info_t)); // Fixme (10)
+		}
+		else {
+			j2k->cstr_info->tile[tileno].end_pos += totlen;
+		}		
+		j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos = cio_tell(cio) - 12;
+		j2k->cstr_info->tile[tileno].tp[partno].tp_end_pos = 
+			j2k->cstr_info->tile[tileno].tp[partno].tp_start_pos + totlen - 1;
+	}
+	
+	if (tcp->first == 1) {		
+		/* Initialization PPT */
+		opj_tccp_t *tmp = tcp->tccps;
+		memcpy(tcp, j2k->default_tcp, sizeof(opj_tcp_t));
+		tcp->ppt = 0;
+		tcp->ppt_data = NULL;
+		tcp->ppt_data_first = NULL;
+		tcp->tccps = tmp;
+
+		for (i = 0; i < j2k->image->numcomps; i++) {
+			tcp->tccps[i] = j2k->default_tcp->tccps[i];
+		}
+		cp->tcps[j2k->curtileno].first = 0;
+	}
+}
+
+static void j2k_write_sod(opj_j2k_t *j2k, void *tile_coder) {
+	int l, layno;
+	int totlen;
+	opj_tcp_t *tcp = NULL;
+	opj_codestream_info_t *cstr_info = NULL;
+	
+	opj_tcd_t *tcd = (opj_tcd_t*)tile_coder;	/* cast is needed because of conflicts in header inclusions */
+	opj_cp_t *cp = j2k->cp;
+	opj_cio_t *cio = j2k->cio;
+
+	tcd->tp_num = j2k->tp_num ;
+	tcd->cur_tp_num = j2k->cur_tp_num;
+	
+	cio_write(cio, J2K_MS_SOD, 2);
+	if (j2k->curtileno == 0) {
+		j2k->sod_start = cio_tell(cio) + j2k->pos_correction;
+	}
+
+	/* INDEX >> */
+	cstr_info = j2k->cstr_info;
+	if (cstr_info) {
+		if (!j2k->cur_tp_num ) {
+			cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+			j2k->cstr_info->tile[j2k->curtileno].tileno = j2k->curtileno;
+		}
+		else{
+			if(cstr_info->tile[j2k->curtileno].packet[cstr_info->packno - 1].end_pos < cio_tell(cio))
+				cstr_info->tile[j2k->curtileno].packet[cstr_info->packno].start_pos = cio_tell(cio);
+		}
+		/* UniPG>> */
+#ifdef USE_JPWL
+		/* update markers struct */
+		j2k_add_marker(j2k->cstr_info, J2K_MS_SOD, j2k->sod_start, 2);
+#endif /* USE_JPWL */
+		/* <<UniPG */
+	}
+	/* << INDEX */
+	
+	tcp = &cp->tcps[j2k->curtileno];
+	for (layno = 0; layno < tcp->numlayers; layno++) {
+		tcp->rates[layno] -= tcp->rates[layno] ? (j2k->sod_start / (cp->th * cp->tw)) : 0;
+	}
+	if(j2k->cur_tp_num == 0){
+		tcd->tcd_image->tiles->packno = 0;
+		if(cstr_info)
+			cstr_info->packno = 0;
+	}
+	
+	l = tcd_encode_tile(tcd, j2k->curtileno, cio_getbp(cio), cio_numbytesleft(cio) - 2, cstr_info);
+	
+	/* Writing Psot in SOT marker */
+	totlen = cio_tell(cio) + l - j2k->sot_start;
+	cio_seek(cio, j2k->sot_start + 6);
+	cio_write(cio, totlen, 4);
+	cio_seek(cio, j2k->sot_start + totlen);
+	/* Writing Ttlm and Ptlm in TLM marker */
+	if(cp->cinema){
+		cio_seek(cio, j2k->tlm_start + 6 + (5*j2k->cur_tp_num));
+		cio_write(cio, j2k->curtileno, 1);
+		cio_write(cio, totlen, 4);
+	}
+	cio_seek(cio, j2k->sot_start + totlen);
+}
+
+static void j2k_read_sod(opj_j2k_t *j2k) {
+	int len, truncate = 0, i;
+	unsigned char *data = NULL, *data_ptr = NULL;
+
+	opj_cio_t *cio = j2k->cio;
+	int curtileno = j2k->curtileno;
+
+	/* Index */
+	if (j2k->cstr_info) {
+		j2k->cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+			cio_tell(cio) + j2k->pos_correction - 1;
+		if (j2k->cur_tp_num == 0)
+			j2k->cstr_info->tile[j2k->curtileno].end_header = cio_tell(cio) + j2k->pos_correction - 1;
+		j2k->cstr_info->packno = 0;
+	}
+	
+	len = int_min(j2k->eot - cio_getbp(cio), cio_numbytesleft(cio) + 1);
+
+	if (len == cio_numbytesleft(cio) + 1) {
+		truncate = 1;		/* Case of a truncate codestream */
+	}	
+
+	data = j2k->tile_data[curtileno];
+	data = (unsigned char*) opj_realloc(data, (j2k->tile_len[curtileno] + len) * sizeof(unsigned char));
+
+	data_ptr = data + j2k->tile_len[curtileno];
+	for (i = 0; i < len; i++) {
+		data_ptr[i] = cio_read(cio, 1);
+	}
+
+	j2k->tile_len[curtileno] += len;
+	j2k->tile_data[curtileno] = data;
+	
+	if (!truncate) {
+		j2k->state = J2K_STATE_TPHSOT;
+	} else {
+		j2k->state = J2K_STATE_NEOC;	/* RAJOUTE !! */
+	}
+	j2k->cur_tp_num++;
+}
+
+static void j2k_write_rgn(opj_j2k_t *j2k, int compno, int tileno) {
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	opj_cio_t *cio = j2k->cio;
+	int numcomps = j2k->image->numcomps;
+	
+	cio_write(cio, J2K_MS_RGN, 2);						/* RGN  */
+	cio_write(cio, numcomps <= 256 ? 5 : 6, 2);			/* Lrgn */
+	cio_write(cio, compno, numcomps <= 256 ? 1 : 2);	/* Crgn */
+	cio_write(cio, 0, 1);								/* Srgn */
+	cio_write(cio, tcp->tccps[compno].roishift, 1);		/* SPrgn */
+}
+
+static void j2k_read_rgn(opj_j2k_t *j2k) {
+	int len, compno, roisty;
+
+	opj_cp_t *cp = j2k->cp;
+	opj_tcp_t *tcp = j2k->state == J2K_STATE_TPH ? &cp->tcps[j2k->curtileno] : j2k->default_tcp;
+	opj_cio_t *cio = j2k->cio;
+	int numcomps = j2k->image->numcomps;
+
+	len = cio_read(cio, 2);										/* Lrgn */
+	compno = cio_read(cio, numcomps <= 256 ? 1 : 2);			/* Crgn */
+	roisty = cio_read(cio, 1);									/* Srgn */
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+		/* totlen is negative or larger than the bytes left!!! */
+		if (compno >= numcomps) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"JPWL: bad component number in RGN (%d when there are only %d)\n",
+				compno, numcomps);
+			if (!JPWL_ASSUME || JPWL_ASSUME) {
+				opj_event_msg(j2k->cinfo, EVT_ERROR, "JPWL: giving up\n");
+				return;
+			}
+		}
+	};
+#endif /* USE_JPWL */
+
+	tcp->tccps[compno].roishift = cio_read(cio, 1);				/* SPrgn */
+}
+
+static void j2k_write_eoc(opj_j2k_t *j2k) {
+	opj_cio_t *cio = j2k->cio;
+	/* opj_event_msg(j2k->cinfo, "%.8x: EOC\n", cio_tell(cio) + j2k->pos_correction); */
+	cio_write(cio, J2K_MS_EOC, 2);
+
+/* UniPG>> */
+#ifdef USE_JPWL
+	/* update markers struct */
+	j2k_add_marker(j2k->cstr_info, J2K_MS_EOC, cio_tell(cio) - 2, 2);
+#endif /* USE_JPWL */
+/* <<UniPG */
+}
+
+static void j2k_read_eoc(opj_j2k_t *j2k) {
+	int i, tileno;
+	bool success;
+
+	/* if packets should be decoded */
+	if (j2k->cp->limit_decoding != DECODE_ALL_BUT_PACKETS) {
+		opj_tcd_t *tcd = tcd_create(j2k->cinfo);
+		tcd_malloc_decode(tcd, j2k->image, j2k->cp);
+		for (i = 0; i < j2k->cp->tileno_size; i++) {
+			tcd_malloc_decode_tile(tcd, j2k->image, j2k->cp, i, j2k->cstr_info);
+			tileno = j2k->cp->tileno[i];
+			success = tcd_decode_tile(tcd, j2k->tile_data[tileno], j2k->tile_len[tileno], tileno, j2k->cstr_info);
+			opj_free(j2k->tile_data[tileno]);
+			j2k->tile_data[tileno] = NULL;
+			tcd_free_decode_tile(tcd, i);
+			if (success == false) {
+				j2k->state |= J2K_STATE_ERR;
+				break;
+			}
+		}
+		tcd_free_decode(tcd);
+		tcd_destroy(tcd);
+	}
+	/* if packets should not be decoded  */
+	else {
+		for (i = 0; i < j2k->cp->tileno_size; i++) {
+			tileno = j2k->cp->tileno[i];
+			opj_free(j2k->tile_data[tileno]);
+			j2k->tile_data[tileno] = NULL;
+		}
+	}	
+	if (j2k->state & J2K_STATE_ERR)
+		j2k->state = J2K_STATE_MT + J2K_STATE_ERR;
+	else
+		j2k->state = J2K_STATE_MT; 
+}
+
+typedef struct opj_dec_mstabent {
+	/** marker value */
+	int id;
+	/** value of the state when the marker can appear */
+	int states;
+	/** action linked to the marker */
+	void (*handler) (opj_j2k_t *j2k);
+} opj_dec_mstabent_t;
+
+opj_dec_mstabent_t j2k_dec_mstab[] = {
+  {J2K_MS_SOC, J2K_STATE_MHSOC, j2k_read_soc},
+  {J2K_MS_SOT, J2K_STATE_MH | J2K_STATE_TPHSOT, j2k_read_sot},
+  {J2K_MS_SOD, J2K_STATE_TPH, j2k_read_sod},
+  {J2K_MS_EOC, J2K_STATE_TPHSOT, j2k_read_eoc},
+  {J2K_MS_SIZ, J2K_STATE_MHSIZ, j2k_read_siz},
+  {J2K_MS_COD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_cod},
+  {J2K_MS_COC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_coc},
+  {J2K_MS_RGN, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_rgn},
+  {J2K_MS_QCD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_qcd},
+  {J2K_MS_QCC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_qcc},
+  {J2K_MS_POC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_poc},
+  {J2K_MS_TLM, J2K_STATE_MH, j2k_read_tlm},
+  {J2K_MS_PLM, J2K_STATE_MH, j2k_read_plm},
+  {J2K_MS_PLT, J2K_STATE_TPH, j2k_read_plt},
+  {J2K_MS_PPM, J2K_STATE_MH, j2k_read_ppm},
+  {J2K_MS_PPT, J2K_STATE_TPH, j2k_read_ppt},
+  {J2K_MS_SOP, 0, 0},
+  {J2K_MS_CRG, J2K_STATE_MH, j2k_read_crg},
+  {J2K_MS_COM, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_com},
+
+#ifdef USE_JPWL
+  {J2K_MS_EPC, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epc},
+  {J2K_MS_EPB, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_epb},
+  {J2K_MS_ESD, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_esd},
+  {J2K_MS_RED, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_red},
+#endif /* USE_JPWL */
+#ifdef USE_JPSEC
+  {J2K_MS_SEC, J2K_STATE_MH, j2k_read_sec},
+  {J2K_MS_INSEC, 0, j2k_read_insec},
+#endif /* USE_JPSEC */
+
+  {0, J2K_STATE_MH | J2K_STATE_TPH, j2k_read_unk}
+};
+
+static void j2k_read_unk(opj_j2k_t *j2k) {
+	opj_event_msg(j2k->cinfo, EVT_WARNING, "Unknown marker\n");
+
+#ifdef USE_JPWL
+	if (j2k->cp->correct) {
+		int m = 0, id, i;
+		int min_id = 0, min_dist = 17, cur_dist = 0, tmp_id;
+		cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
+		id = cio_read(j2k->cio, 2);
+		opj_event_msg(j2k->cinfo, EVT_ERROR,
+			"JPWL: really don't know this marker %x\n",
+			id);
+		if (!JPWL_ASSUME) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"- possible synch loss due to uncorrectable codestream errors => giving up\n");
+			return;
+		}
+		/* OK, activate this at your own risk!!! */
+		/* we look for the marker at the minimum hamming distance from this */
+		while (j2k_dec_mstab[m].id) {
+			
+			/* 1's where they differ */
+			tmp_id = j2k_dec_mstab[m].id ^ id;
+
+			/* compute the hamming distance between our id and the current */
+			cur_dist = 0;
+			for (i = 0; i < 16; i++) {
+				if ((tmp_id >> i) & 0x0001) {
+					cur_dist++;
+				}
+			}
+
+			/* if current distance is smaller, set the minimum */
+			if (cur_dist < min_dist) {
+				min_dist = cur_dist;
+				min_id = j2k_dec_mstab[m].id;
+			}
+			
+			/* jump to the next marker */
+			m++;
+		}
+
+		/* do we substitute the marker? */
+		if (min_dist < JPWL_MAXIMUM_HAMMING) {
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"- marker %x is at distance %d from the read %x\n",
+				min_id, min_dist, id);
+			opj_event_msg(j2k->cinfo, EVT_ERROR,
+				"- trying to substitute in place and crossing fingers!\n");
+			cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
+			cio_write(j2k->cio, min_id, 2);
+
+			/* rewind */
+			cio_seek(j2k->cio, cio_tell(j2k->cio) - 2);
+
+		}
+
+	};
+#endif /* USE_JPWL */
+
+}
+
+/**
+Read the lookup table containing all the marker, status and action
+@param id Marker value
+*/
+static opj_dec_mstabent_t *j2k_dec_mstab_lookup(int id) {
+	opj_dec_mstabent_t *e;
+	for (e = j2k_dec_mstab; e->id != 0; e++) {
+		if (e->id == id) {
+			break;
+		}
+	}
+	return e;
+}
+
+/* ----------------------------------------------------------------------- */
+/* J2K / JPT decoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo) {
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
+	if(!j2k)
+		return NULL;
+
+	j2k->default_tcp = (opj_tcp_t*) opj_calloc(1, sizeof(opj_tcp_t));
+	if(!j2k->default_tcp) {
+		opj_free(j2k);
+		return NULL;
+	}
+
+	j2k->cinfo = cinfo;
+	j2k->tile_data = NULL;
+
+	return j2k;
+}
+
+void j2k_destroy_decompress(opj_j2k_t *j2k) {
+	int i = 0;
+
+	if(j2k->tile_len != NULL) {
+		opj_free(j2k->tile_len);
+	}
+	if(j2k->tile_data != NULL) {
+		opj_free(j2k->tile_data);
+	}
+	if(j2k->default_tcp != NULL) {
+		opj_tcp_t *default_tcp = j2k->default_tcp;
+		if(default_tcp->ppt_data_first != NULL) {
+			opj_free(default_tcp->ppt_data_first);
+		}
+		if(j2k->default_tcp->tccps != NULL) {
+			opj_free(j2k->default_tcp->tccps);
+		}
+		opj_free(j2k->default_tcp);
+	}
+	if(j2k->cp != NULL) {
+		opj_cp_t *cp = j2k->cp;
+		if(cp->tcps != NULL) {
+			for(i = 0; i < cp->tw * cp->th; i++) {
+				if(cp->tcps[i].ppt_data_first != NULL) {
+					opj_free(cp->tcps[i].ppt_data_first);
+				}
+				if(cp->tcps[i].tccps != NULL) {
+					opj_free(cp->tcps[i].tccps);
+				}
+			}
+			opj_free(cp->tcps);
+		}
+		if(cp->ppm_data_first != NULL) {
+			opj_free(cp->ppm_data_first);
+		}
+		if(cp->tileno != NULL) {
+			opj_free(cp->tileno);  
+		}
+		if(cp->comment != NULL) {
+			opj_free(cp->comment);
+		}
+
+		opj_free(cp);
+	}
+	opj_free(j2k);
+}
+
+void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters) {
+	if(j2k && parameters) {
+		/* create and initialize the coding parameters structure */
+		opj_cp_t *cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
+		cp->reduce = parameters->cp_reduce;	
+		cp->layer = parameters->cp_layer;
+		cp->limit_decoding = parameters->cp_limit_decoding;
+
+#ifdef USE_JPWL
+		cp->correct = parameters->jpwl_correct;
+		cp->exp_comps = parameters->jpwl_exp_comps;
+		cp->max_tiles = parameters->jpwl_max_tiles;
+#endif /* USE_JPWL */
+
+
+		/* keep a link to cp so that we can destroy it later in j2k_destroy_decompress */
+		j2k->cp = cp;
+	}
+}
+
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
+	opj_image_t *image = NULL;
+
+	opj_common_ptr cinfo = j2k->cinfo;	
+
+	j2k->cio = cio;
+	j2k->cstr_info = cstr_info;
+	if (cstr_info)
+		memset(cstr_info, 0, sizeof(opj_codestream_info_t));
+
+	/* create an empty image */
+	image = opj_image_create0();
+	j2k->image = image;
+
+	j2k->state = J2K_STATE_MHSOC;
+
+	for (;;) {
+		opj_dec_mstabent_t *e;
+		int id = cio_read(cio, 2);
+
+#ifdef USE_JPWL
+		/* we try to honor JPWL correction power */
+		if (j2k->cp->correct) {
+
+			int orig_pos = cio_tell(cio);
+			bool status;
+
+			/* call the corrector */
+			status = jpwl_correct(j2k);
+
+			/* go back to where you were */
+			cio_seek(cio, orig_pos - 2);
+
+			/* re-read the marker */
+			id = cio_read(cio, 2);
+
+			/* check whether it begins with ff */
+			if (id >> 8 != 0xff) {
+				opj_event_msg(cinfo, EVT_ERROR,
+					"JPWL: possible bad marker %x at %d\n",
+					id, cio_tell(cio) - 2);
+				if (!JPWL_ASSUME) {
+					opj_image_destroy(image);
+					opj_event_msg(cinfo, EVT_ERROR, "JPWL: giving up\n");
+					return 0;
+				}
+				/* we try to correct */
+				id = id | 0xff00;
+				cio_seek(cio, cio_tell(cio) - 2);
+				cio_write(cio, id, 2);
+				opj_event_msg(cinfo, EVT_WARNING, "- trying to adjust this\n"
+					"- setting marker to %x\n",
+					id);
+			}
+
+		}
+#endif /* USE_JPWL */
+
+		if (id >> 8 != 0xff) {
+			opj_image_destroy(image);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		e = j2k_dec_mstab_lookup(id);
+		// Check if the marker is known
+		if (!(j2k->state & e->states)) {
+			opj_image_destroy(image);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: unexpected marker %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		// Check if the decoding is limited to the main header
+		if (e->id == J2K_MS_SOT && j2k->cp->limit_decoding == LIMIT_TO_MAIN_HEADER) {
+			opj_event_msg(cinfo, EVT_INFO, "Main Header decoded.\n");
+			return image;
+		}		
+
+		if (e->handler) {
+			(*e->handler)(j2k);
+		}
+		if (j2k->state & J2K_STATE_ERR) 
+			return NULL;	
+
+		if (j2k->state == J2K_STATE_MT) {
+			break;
+		}
+		if (j2k->state == J2K_STATE_NEOC) {
+			break;
+		}
+	}
+	if (j2k->state == J2K_STATE_NEOC) {
+		j2k_read_eoc(j2k);
+	}
+
+	if (j2k->state != J2K_STATE_MT) {
+		opj_event_msg(cinfo, EVT_WARNING, "Incomplete bitstream\n");
+	}
+
+	return image;
+}
+
+/*
+* Read a JPT-stream and decode file
+*
+*/
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio,  opj_codestream_info_t *cstr_info) {
+	opj_image_t *image = NULL;
+	opj_jpt_msg_header_t header;
+	int position;
+
+	opj_common_ptr cinfo = j2k->cinfo;
+	
+	j2k->cio = cio;
+
+	/* create an empty image */
+	image = opj_image_create0();
+	j2k->image = image;
+
+	j2k->state = J2K_STATE_MHSOC;
+	
+	/* Initialize the header */
+	jpt_init_msg_header(&header);
+	/* Read the first header of the message */
+	jpt_read_msg_header(cinfo, cio, &header);
+	
+	position = cio_tell(cio);
+	if (header.Class_Id != 6) {	/* 6 : Main header data-bin message */
+		opj_image_destroy(image);
+		opj_event_msg(cinfo, EVT_ERROR, "[JPT-stream] : Expecting Main header first [class_Id %d] !\n", header.Class_Id);
+		return 0;
+	}
+	
+	for (;;) {
+		opj_dec_mstabent_t *e = NULL;
+		int id;
+		
+		if (!cio_numbytesleft(cio)) {
+			j2k_read_eoc(j2k);
+			return image;
+		}
+		/* data-bin read -> need to read a new header */
+		if ((unsigned int) (cio_tell(cio) - position) == header.Msg_length) {
+			jpt_read_msg_header(cinfo, cio, &header);
+			position = cio_tell(cio);
+			if (header.Class_Id != 4) {	/* 4 : Tile data-bin message */
+				opj_image_destroy(image);
+				opj_event_msg(cinfo, EVT_ERROR, "[JPT-stream] : Expecting Tile info !\n");
+				return 0;
+			}
+		}
+		
+		id = cio_read(cio, 2);
+		if (id >> 8 != 0xff) {
+			opj_image_destroy(image);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: expected a marker instead of %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		e = j2k_dec_mstab_lookup(id);
+		if (!(j2k->state & e->states)) {
+			opj_image_destroy(image);
+			opj_event_msg(cinfo, EVT_ERROR, "%.8x: unexpected marker %x\n", cio_tell(cio) - 2, id);
+			return 0;
+		}
+		if (e->handler) {
+			(*e->handler)(j2k);
+		}
+		if (j2k->state == J2K_STATE_MT) {
+			break;
+		}
+		if (j2k->state == J2K_STATE_NEOC) {
+			break;
+		}
+	}
+	if (j2k->state == J2K_STATE_NEOC) {
+		j2k_read_eoc(j2k);
+	}
+	
+	if (j2k->state != J2K_STATE_MT) {
+		opj_event_msg(cinfo, EVT_WARNING, "Incomplete bitstream\n");
+	}
+
+	return image;
+}
+
+/* ----------------------------------------------------------------------- */
+/* J2K encoder interface                                                       */
+/* ----------------------------------------------------------------------- */
+
+opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo) {
+	opj_j2k_t *j2k = (opj_j2k_t*) opj_calloc(1, sizeof(opj_j2k_t));
+	if(j2k) {
+		j2k->cinfo = cinfo;
+	}
+	return j2k;
+}
+
+void j2k_destroy_compress(opj_j2k_t *j2k) {
+	int tileno;
+
+	if(!j2k) return;
+	if(j2k->cp != NULL) {
+		opj_cp_t *cp = j2k->cp;
+
+		if(cp->comment) {
+			opj_free(cp->comment);
+		}
+		if(cp->matrice) {
+			opj_free(cp->matrice);
+		}
+		for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+			opj_free(cp->tcps[tileno].tccps);
+		}
+		opj_free(cp->tcps);
+		opj_free(cp);
+	}
+
+	opj_free(j2k);
+}
+
+void j2k_setup_encoder(opj_j2k_t *j2k, opj_cparameters_t *parameters, opj_image_t *image) {
+	int i, j, tileno, numpocs_tile;
+	opj_cp_t *cp = NULL;
+
+	if(!j2k || !parameters || ! image) {
+		return;
+	}
+
+	/* create and initialize the coding parameters structure */
+	cp = (opj_cp_t*) opj_calloc(1, sizeof(opj_cp_t));
+
+	/* keep a link to cp so that we can destroy it later in j2k_destroy_compress */
+	j2k->cp = cp;
+
+	/* set default values for cp */
+	cp->tw = 1;
+	cp->th = 1;
+
+	/* 
+	copy user encoding parameters 
+	*/
+	cp->cinema = parameters->cp_cinema;
+	cp->max_comp_size =	parameters->max_comp_size;
+	cp->rsiz   = parameters->cp_rsiz;
+	cp->disto_alloc = parameters->cp_disto_alloc;
+	cp->fixed_alloc = parameters->cp_fixed_alloc;
+	cp->fixed_quality = parameters->cp_fixed_quality;
+
+	/* mod fixed_quality */
+	if(parameters->cp_matrice) {
+		size_t array_size = parameters->tcp_numlayers * parameters->numresolution * 3 * sizeof(int);
+		cp->matrice = (int *) opj_malloc(array_size);
+		memcpy(cp->matrice, parameters->cp_matrice, array_size);
+	}
+
+	/* tiles */
+	cp->tdx = parameters->cp_tdx;
+	cp->tdy = parameters->cp_tdy;
+
+	/* tile offset */
+	cp->tx0 = parameters->cp_tx0;
+	cp->ty0 = parameters->cp_ty0;
+
+	/* comment string */
+	if(parameters->cp_comment) {
+		cp->comment = (char*)opj_malloc(strlen(parameters->cp_comment) + 1);
+		if(cp->comment) {
+			strcpy(cp->comment, parameters->cp_comment);
+		}
+	}
+
+	/*
+	calculate other encoding parameters
+	*/
+
+	if (parameters->tile_size_on) {
+		cp->tw = int_ceildiv(image->x1 - cp->tx0, cp->tdx);
+		cp->th = int_ceildiv(image->y1 - cp->ty0, cp->tdy);
+	} else {
+		cp->tdx = image->x1 - cp->tx0;
+		cp->tdy = image->y1 - cp->ty0;
+	}
+
+	if(parameters->tp_on){
+		cp->tp_flag = parameters->tp_flag;
+		cp->tp_on = 1;
+	}
+	
+	cp->img_size = 0;
+	for(i=0;i<image->numcomps ;i++){
+	cp->img_size += (image->comps[i].w *image->comps[i].h * image->comps[i].prec);
+	}
+
+
+#ifdef USE_JPWL
+	/*
+	calculate JPWL encoding parameters
+	*/
+
+	if (parameters->jpwl_epc_on) {
+		int i;
+
+		/* set JPWL on */
+		cp->epc_on = true;
+		cp->info_on = false; /* no informative technique */
+
+		/* set EPB on */
+		if ((parameters->jpwl_hprot_MH > 0) || (parameters->jpwl_hprot_TPH[0] > 0)) {
+			cp->epb_on = true;
+			
+			cp->hprot_MH = parameters->jpwl_hprot_MH;
+			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+				cp->hprot_TPH_tileno[i] = parameters->jpwl_hprot_TPH_tileno[i];
+				cp->hprot_TPH[i] = parameters->jpwl_hprot_TPH[i];
+			}
+			/* if tile specs are not specified, copy MH specs */
+			if (cp->hprot_TPH[0] == -1) {
+				cp->hprot_TPH_tileno[0] = 0;
+				cp->hprot_TPH[0] = parameters->jpwl_hprot_MH;
+			}
+			for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {
+				cp->pprot_tileno[i] = parameters->jpwl_pprot_tileno[i];
+				cp->pprot_packno[i] = parameters->jpwl_pprot_packno[i];
+				cp->pprot[i] = parameters->jpwl_pprot[i];
+			}
+		}
+
+		/* set ESD writing */
+		if ((parameters->jpwl_sens_size == 1) || (parameters->jpwl_sens_size == 2)) {
+			cp->esd_on = true;
+
+			cp->sens_size = parameters->jpwl_sens_size;
+			cp->sens_addr = parameters->jpwl_sens_addr;
+			cp->sens_range = parameters->jpwl_sens_range;
+
+			cp->sens_MH = parameters->jpwl_sens_MH;
+			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+				cp->sens_TPH_tileno[i] = parameters->jpwl_sens_TPH_tileno[i];
+				cp->sens_TPH[i] = parameters->jpwl_sens_TPH[i];
+			}
+		}
+
+		/* always set RED writing to false: we are at the encoder */
+		cp->red_on = false;
+
+	} else {
+		cp->epc_on = false;
+	}
+#endif /* USE_JPWL */
+
+
+	/* initialize the mutiple tiles */
+	/* ---------------------------- */
+	cp->tcps = (opj_tcp_t*) opj_calloc(cp->tw * cp->th, sizeof(opj_tcp_t));
+
+	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		tcp->numlayers = parameters->tcp_numlayers;
+		for (j = 0; j < tcp->numlayers; j++) {
+			if(cp->cinema){
+				if (cp->fixed_quality) {
+					tcp->distoratio[j] = parameters->tcp_distoratio[j];
+				}
+				tcp->rates[j] = parameters->tcp_rates[j];
+			}else{
+				if (cp->fixed_quality) {	/* add fixed_quality */
+					tcp->distoratio[j] = parameters->tcp_distoratio[j];
+				} else {
+					tcp->rates[j] = parameters->tcp_rates[j];
+				}
+			}
+		}
+		tcp->csty = parameters->csty;
+		tcp->prg = parameters->prog_order;
+		tcp->mct = parameters->tcp_mct; 
+
+		numpocs_tile = 0;
+		tcp->POC = 0;
+		if (parameters->numpocs) {
+			/* initialisation of POC */
+			tcp->POC = 1;
+			j2k_check_poc_val(parameters, image->numcomps, tcp->numlayers);
+			for (i = 0; i < parameters->numpocs; i++) {
+				if((tileno == parameters->POC[i].tile - 1) || (parameters->POC[i].tile == -1)) {
+					opj_poc_t *tcp_poc = &tcp->pocs[numpocs_tile];
+					tcp_poc->resno0		= parameters->POC[numpocs_tile].resno0;
+					tcp_poc->compno0	= parameters->POC[numpocs_tile].compno0;
+					tcp_poc->layno1		= parameters->POC[numpocs_tile].layno1;
+					tcp_poc->resno1		= parameters->POC[numpocs_tile].resno1;
+					tcp_poc->compno1	= parameters->POC[numpocs_tile].compno1;
+					tcp_poc->prg1		= parameters->POC[numpocs_tile].prg1;
+					tcp_poc->tile		= parameters->POC[numpocs_tile].tile;
+					numpocs_tile++;
+				}
+			}
+			tcp->numpocs = numpocs_tile -1 ;
+		}else{ 
+			tcp->numpocs = 0;
+		}
+
+		tcp->tccps = (opj_tccp_t*) opj_calloc(image->numcomps, sizeof(opj_tccp_t));
+
+		for (i = 0; i < image->numcomps; i++) {
+			opj_tccp_t *tccp = &tcp->tccps[i];
+			tccp->csty = parameters->csty & 0x01;	/* 0 => one precinct || 1 => custom precinct  */
+			tccp->numresolutions = parameters->numresolution;
+			tccp->cblkw = int_floorlog2(parameters->cblockw_init);
+			tccp->cblkh = int_floorlog2(parameters->cblockh_init);
+			tccp->cblksty = parameters->mode;
+			tccp->qmfbid = parameters->irreversible ? 0 : 1;
+			tccp->qntsty = parameters->irreversible ? J2K_CCP_QNTSTY_SEQNT : J2K_CCP_QNTSTY_NOQNT;
+			tccp->numgbits = 2;
+			if (i == parameters->roi_compno) {
+				tccp->roishift = parameters->roi_shift;
+			} else {
+				tccp->roishift = 0;
+			}
+
+			if(parameters->cp_cinema)
+			{
+				//Precinct size for lowest frequency subband=128
+				tccp->prcw[0] = 7;
+				tccp->prch[0] = 7;
+				//Precinct size at all other resolutions = 256
+				for (j = 1; j < tccp->numresolutions; j++) {
+					tccp->prcw[j] = 8;
+					tccp->prch[j] = 8;
+				}
+			}else{
+				if (parameters->csty & J2K_CCP_CSTY_PRT) {
+					int p = 0;
+					for (j = tccp->numresolutions - 1; j >= 0; j--) {
+						if (p < parameters->res_spec) {
+							
+							if (parameters->prcw_init[p] < 1) {
+								tccp->prcw[j] = 1;
+							} else {
+								tccp->prcw[j] = int_floorlog2(parameters->prcw_init[p]);
+							}
+							
+							if (parameters->prch_init[p] < 1) {
+								tccp->prch[j] = 1;
+							}else {
+								tccp->prch[j] = int_floorlog2(parameters->prch_init[p]);
+							}
+
+						} else {
+							int res_spec = parameters->res_spec;
+							int size_prcw = parameters->prcw_init[res_spec - 1] >> (p - (res_spec - 1));
+							int size_prch = parameters->prch_init[res_spec - 1] >> (p - (res_spec - 1));
+							
+							if (size_prcw < 1) {
+								tccp->prcw[j] = 1;
+							} else {
+								tccp->prcw[j] = int_floorlog2(size_prcw);
+							}
+							
+							if (size_prch < 1) {
+								tccp->prch[j] = 1;
+							} else {
+								tccp->prch[j] = int_floorlog2(size_prch);
+							}
+						}
+						p++;
+						/*printf("\nsize precinct for level %d : %d,%d\n", j,tccp->prcw[j], tccp->prch[j]); */
+					}	//end for
+				} else {
+					for (j = 0; j < tccp->numresolutions; j++) {
+						tccp->prcw[j] = 15;
+						tccp->prch[j] = 15;
+					}
+				}
+			}
+
+			dwt_calc_explicit_stepsizes(tccp, image->comps[i].prec);
+		}
+	}
+}
+
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
+	int tileno, compno;
+	opj_cp_t *cp = NULL;
+
+	opj_tcd_t *tcd = NULL;	/* TCD component */
+
+	j2k->cio = cio;	
+	j2k->image = image;
+
+	cp = j2k->cp;
+
+	/* j2k_dump_cp(stdout, image, cp); */
+
+	/* INDEX >> */
+	j2k->cstr_info = cstr_info;
+	if (cstr_info) {
+		int compno;
+		cstr_info->tile = (opj_tile_info_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tile_info_t));
+		cstr_info->image_w = image->x1 - image->x0;
+		cstr_info->image_h = image->y1 - image->y0;
+		cstr_info->prog = (&cp->tcps[0])->prg;
+		cstr_info->tw = cp->tw;
+		cstr_info->th = cp->th;
+		cstr_info->tile_x = cp->tdx;	/* new version parser */
+		cstr_info->tile_y = cp->tdy;	/* new version parser */
+		cstr_info->tile_Ox = cp->tx0;	/* new version parser */
+		cstr_info->tile_Oy = cp->ty0;	/* new version parser */
+		cstr_info->numcomps = image->numcomps;
+		cstr_info->numlayers = (&cp->tcps[0])->numlayers;
+		cstr_info->numdecompos = (int*) opj_malloc(image->numcomps * sizeof(int));
+		for (compno=0; compno < image->numcomps; compno++) {
+			cstr_info->numdecompos[compno] = (&cp->tcps[0])->tccps->numresolutions - 1;
+		}
+		cstr_info->D_max = 0.0;		/* ADD Marcela */
+		cstr_info->main_head_start = cio_tell(cio); /* position of SOC */
+		cstr_info->maxmarknum = 100;
+		cstr_info->marker = (opj_marker_info_t *) opj_malloc(cstr_info->maxmarknum * sizeof(opj_marker_info_t));
+		cstr_info->marknum = 0;
+	}
+	/* << INDEX */
+
+	j2k_write_soc(j2k);
+	j2k_write_siz(j2k);
+	j2k_write_cod(j2k);
+	j2k_write_qcd(j2k);
+
+	if(cp->cinema){
+		for (compno = 1; compno < image->numcomps; compno++) {
+			j2k_write_coc(j2k, compno);
+			j2k_write_qcc(j2k, compno);
+		}
+	}
+
+	for (compno = 0; compno < image->numcomps; compno++) {
+		opj_tcp_t *tcp = &cp->tcps[0];
+		if (tcp->tccps[compno].roishift)
+			j2k_write_rgn(j2k, compno, 0);
+	}
+	if (cp->comment != NULL) {
+		j2k_write_com(j2k);
+	}
+
+	j2k->totnum_tp = j2k_calculate_tp(cp,image->numcomps,image,j2k);
+	/* TLM Marker*/
+	if(cp->cinema){
+		j2k_write_tlm(j2k);
+		if (cp->cinema == CINEMA4K_24) {
+			j2k_write_poc(j2k);
+		}
+	}
+
+	/* uncomment only for testing JPSEC marker writing */
+	/* j2k_write_sec(j2k); */
+
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->main_head_end = cio_tell(cio) - 1;
+	}
+	/* << INDEX */
+	/**** Main Header ENDS here ***/
+
+	/* create the tile encoder */
+	tcd = tcd_create(j2k->cinfo);
+
+	/* encode each tile */
+	for (tileno = 0; tileno < cp->tw * cp->th; tileno++) {
+		int pino;
+		int tilepartno=0;
+		/* UniPG>> */
+		int acc_pack_num = 0;
+		/* <<UniPG */
+
+
+		opj_tcp_t *tcp = &cp->tcps[tileno];
+		opj_event_msg(j2k->cinfo, EVT_INFO, "tile number %d / %d\n", tileno + 1, cp->tw * cp->th);
+
+		j2k->curtileno = tileno;
+		j2k->cur_tp_num = 0;
+		tcd->cur_totnum_tp = j2k->cur_totnum_tp[j2k->curtileno];
+		/* initialisation before tile encoding  */
+		if (tileno == 0) {
+			tcd_malloc_encode(tcd, image, cp, j2k->curtileno);
+		} else {
+			tcd_init_encode(tcd, image, cp, j2k->curtileno);
+		}
+
+		/* INDEX >> */
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].start_pos = cio_tell(cio) + j2k->pos_correction;
+		}
+		/* << INDEX */
+
+		for(pino = 0; pino <= tcp->numpocs; pino++) {
+			int tot_num_tp;
+			tcd->cur_pino=pino;
+
+			/*Get number of tile parts*/
+			tot_num_tp = j2k_get_num_tp(cp,pino,tileno);
+			tcd->tp_pos = cp->tp_pos;
+
+			for(tilepartno = 0; tilepartno < tot_num_tp ; tilepartno++){
+				j2k->tp_num = tilepartno;
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pos =
+					cio_tell(cio) + j2k->pos_correction;
+				/* << INDEX */
+				j2k_write_sot(j2k);
+
+				if(j2k->cur_tp_num == 0 && cp->cinema == 0){
+					for (compno = 1; compno < image->numcomps; compno++) {
+						j2k_write_coc(j2k, compno);
+						j2k_write_qcc(j2k, compno);
+					}
+					if (cp->tcps[tileno].numpocs) {
+						j2k_write_poc(j2k);
+					}
+				}
+
+				/* INDEX >> */
+				if(cstr_info)
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_header =
+					cio_tell(cio) + j2k->pos_correction + 1;
+				/* << INDEX */
+
+				j2k_write_sod(j2k, tcd);
+
+				/* INDEX >> */
+				if(cstr_info) {
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_end_pos =
+						cio_tell(cio) + j2k->pos_correction - 1;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_start_pack =
+						acc_pack_num;
+					cstr_info->tile[j2k->curtileno].tp[j2k->cur_tp_num].tp_numpacks =
+						cstr_info->packno - acc_pack_num;
+					acc_pack_num = cstr_info->packno;
+				}
+				/* << INDEX */
+
+				j2k->cur_tp_num++;
+			}			
+		}
+		if(cstr_info) {
+			cstr_info->tile[j2k->curtileno].end_pos = cio_tell(cio) + j2k->pos_correction - 1;
+		}
+
+
+		/*
+		if (tile->PPT) { // BAD PPT !!! 
+		FILE *PPT_file;
+		int i;
+		PPT_file=fopen("PPT","rb");
+		fprintf(stderr,"%c%c%c%c",255,97,tile->len_ppt/256,tile->len_ppt%256);
+		for (i=0;i<tile->len_ppt;i++) {
+		unsigned char elmt;
+		fread(&elmt, 1, 1, PPT_file);
+		fwrite(&elmt,1,1,f);
+		}
+		fclose(PPT_file);
+		unlink("PPT");
+		}
+		*/
+
+	}
+
+	/* destroy the tile encoder */
+	tcd_free_encode(tcd);
+	tcd_destroy(tcd);
+
+	opj_free(j2k->cur_totnum_tp);
+
+	j2k_write_eoc(j2k);
+
+	if(cstr_info) {
+		cstr_info->codestream_size = cio_tell(cio) + j2k->pos_correction;
+		/* UniPG>> */
+		/* The following adjustment is done to adjust the codestream size */
+		/* if SOD is not at 0 in the buffer. Useful in case of JP2, where */
+		/* the first bunch of bytes is not in the codestream              */
+		cstr_info->codestream_size -= cstr_info->main_head_start;
+		/* <<UniPG */
+	}
+
+#ifdef USE_JPWL
+	/*
+	preparation of JPWL marker segments
+	*/
+	if(cp->epc_on) {
+
+		/* encode according to JPWL */
+		jpwl_encode(j2k, cio, image);
+
+	}
+#endif /* USE_JPWL */
+
+	return true;
+}
+
+
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k.h.svn-base ./libopenjpeg/.svn/text-base/j2k.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/j2k.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,446 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __J2K_H
+#define __J2K_H
+/**
+@file j2k.h
+@brief The JPEG-2000 Codestream Reader/Writer (J2K)
+
+The functions in J2K.C have for goal to read/write the several parts of the codestream: markers and data.
+*/
+
+/** @defgroup J2K J2K - JPEG-2000 codestream reader/writer */
+/*@{*/
+
+#define J2K_CP_CSTY_PRT 0x01
+#define J2K_CP_CSTY_SOP 0x02
+#define J2K_CP_CSTY_EPH 0x04
+#define J2K_CCP_CSTY_PRT 0x01
+#define J2K_CCP_CBLKSTY_LAZY 0x01
+#define J2K_CCP_CBLKSTY_RESET 0x02
+#define J2K_CCP_CBLKSTY_TERMALL 0x04
+#define J2K_CCP_CBLKSTY_VSC 0x08
+#define J2K_CCP_CBLKSTY_PTERM 0x10
+#define J2K_CCP_CBLKSTY_SEGSYM 0x20
+#define J2K_CCP_QNTSTY_NOQNT 0
+#define J2K_CCP_QNTSTY_SIQNT 1
+#define J2K_CCP_QNTSTY_SEQNT 2
+
+/* ----------------------------------------------------------------------- */
+
+#define J2K_MS_SOC 0xff4f	/**< SOC marker value */
+#define J2K_MS_SOT 0xff90	/**< SOT marker value */
+#define J2K_MS_SOD 0xff93	/**< SOD marker value */
+#define J2K_MS_EOC 0xffd9	/**< EOC marker value */
+#define J2K_MS_SIZ 0xff51	/**< SIZ marker value */
+#define J2K_MS_COD 0xff52	/**< COD marker value */
+#define J2K_MS_COC 0xff53	/**< COC marker value */
+#define J2K_MS_RGN 0xff5e	/**< RGN marker value */
+#define J2K_MS_QCD 0xff5c	/**< QCD marker value */
+#define J2K_MS_QCC 0xff5d	/**< QCC marker value */
+#define J2K_MS_POC 0xff5f	/**< POC marker value */
+#define J2K_MS_TLM 0xff55	/**< TLM marker value */
+#define J2K_MS_PLM 0xff57	/**< PLM marker value */
+#define J2K_MS_PLT 0xff58	/**< PLT marker value */
+#define J2K_MS_PPM 0xff60	/**< PPM marker value */
+#define J2K_MS_PPT 0xff61	/**< PPT marker value */
+#define J2K_MS_SOP 0xff91	/**< SOP marker value */
+#define J2K_MS_EPH 0xff92	/**< EPH marker value */
+#define J2K_MS_CRG 0xff63	/**< CRG marker value */
+#define J2K_MS_COM 0xff64	/**< COM marker value */
+/* UniPG>> */
+#ifdef USE_JPWL
+#define J2K_MS_EPC 0xff68	/**< EPC marker value (Part 11: JPEG 2000 for Wireless) */
+#define J2K_MS_EPB 0xff66	/**< EPB marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_ESD 0xff67	/**< ESD marker value (Part 11: JPEG 2000 for Wireless) */ 
+#define J2K_MS_RED 0xff69	/**< RED marker value (Part 11: JPEG 2000 for Wireless) */
+#endif /* USE_JPWL */
+#ifdef USE_JPSEC
+#define J2K_MS_SEC 0xff65    /**< SEC marker value (Part 8: Secure JPEG 2000) */
+#define J2K_MS_INSEC 0xff94  /**< INSEC marker value (Part 8: Secure JPEG 2000) */
+#endif /* USE_JPSEC */
+/* <<UniPG */
+
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Values that specify the status of the decoding process when decoding the main header. 
+These values may be combined with a | operator. 
+*/
+typedef enum J2K_STATUS {
+	J2K_STATE_MHSOC  = 0x0001, /**< a SOC marker is expected */
+	J2K_STATE_MHSIZ  = 0x0002, /**< a SIZ marker is expected */
+	J2K_STATE_MH     = 0x0004, /**< the decoding process is in the main header */
+	J2K_STATE_TPHSOT = 0x0008, /**< the decoding process is in a tile part header and expects a SOT marker */
+	J2K_STATE_TPH    = 0x0010, /**< the decoding process is in a tile part header */
+	J2K_STATE_MT     = 0x0020, /**< the EOC marker has just been read */
+	J2K_STATE_NEOC   = 0x0040, /**< the decoding process must not expect a EOC marker because the codestream is truncated */
+	J2K_STATE_ERR    = 0x0080  /**< the decoding process has encountered an error */
+} J2K_STATUS;
+
+/* ----------------------------------------------------------------------- */
+
+/** 
+T2 encoding mode 
+*/
+typedef enum T2_MODE {
+	THRESH_CALC = 0,	/** Function called in Rate allocation process*/
+	FINAL_PASS = 1		/** Function called in Tier 2 process*/
+}J2K_T2_MODE;
+
+/**
+Quantization stepsize
+*/
+typedef struct opj_stepsize {
+	/** exponent */
+	int expn;
+	/** mantissa */
+	int mant;
+} opj_stepsize_t;
+
+/**
+Tile-component coding parameters
+*/
+typedef struct opj_tccp {
+	/** coding style */
+	int csty;
+	/** number of resolutions */
+	int numresolutions;
+	/** code-blocks width */
+	int cblkw;
+	/** code-blocks height */
+	int cblkh;
+	/** code-block coding style */
+	int cblksty;
+	/** discrete wavelet transform identifier */
+	int qmfbid;
+	/** quantisation style */
+	int qntsty;
+	/** stepsizes used for quantization */
+	opj_stepsize_t stepsizes[J2K_MAXBANDS];
+	/** number of guard bits */
+	int numgbits;
+	/** Region Of Interest shift */
+	int roishift;
+	/** precinct width */
+	int prcw[J2K_MAXRLVLS];
+	/** precinct height */
+	int prch[J2K_MAXRLVLS];	
+} opj_tccp_t;
+
+/**
+Tile coding parameters : 
+this structure is used to store coding/decoding parameters common to all
+tiles (information like COD, COC in main header)
+*/
+typedef struct opj_tcp {
+	/** 1 : first part-tile of a tile */
+	int first;
+	/** coding style */
+	int csty;
+	/** progression order */
+	OPJ_PROG_ORDER prg;
+	/** number of layers */
+	int numlayers;
+	/** multi-component transform identifier */
+	int mct;
+	/** rates of layers */
+	float rates[100];
+	/** number of progression order changes */
+	int numpocs;
+	/** indicates if a POC marker has been used O:NO, 1:YES */
+	int POC;
+	/** progression order changes */
+	opj_poc_t pocs[32];
+	/** packet header store there for futur use in t2_decode_packet */
+	unsigned char *ppt_data;
+	/** pointer remaining on the first byte of the first header if ppt is used */
+	unsigned char *ppt_data_first;
+	/** If ppt == 1 --> there was a PPT marker for the present tile */
+	int ppt;
+	/** used in case of multiple marker PPT (number of info already stored) */
+	int ppt_store;
+	/** ppmbug1 */
+	int ppt_len;
+	/** add fixed_quality */
+	float distoratio[100];
+	/** tile-component coding parameters */
+	opj_tccp_t *tccps;
+} opj_tcp_t;
+
+/**
+Coding parameters
+*/
+typedef struct opj_cp {
+	/** Digital cinema profile*/
+	OPJ_CINEMA_MODE cinema;
+	/** Maximum rate for each component. If == 0, component size limitation is not considered */
+	int max_comp_size;
+	/** Size of the image in bits*/
+	int img_size;
+	/** Rsiz*/
+	OPJ_RSIZ_CAPABILITIES rsiz;
+	/** Enabling Tile part generation*/
+	char tp_on;
+	/** Flag determining tile part generation*/
+	char tp_flag;
+	/** Position of tile part flag in progression order*/
+	int tp_pos;
+	/** allocation by rate/distortion */
+	int disto_alloc;
+	/** allocation by fixed layer */
+	int fixed_alloc;
+	/** add fixed_quality */
+	int fixed_quality;
+	/** if != 0, then original dimension divided by 2^(reduce); if == 0 or not used, image is decoded to the full resolution */
+	int reduce;
+	/** if != 0, then only the first "layer" layers are decoded; if == 0 or not used, all the quality layers are decoded */
+	int layer;
+	/** if == NO_LIMITATION, decode entire codestream; if == LIMIT_TO_MAIN_HEADER then only decode the main header */
+	OPJ_LIMIT_DECODING limit_decoding;
+	/** XTOsiz */
+	int tx0;
+	/** YTOsiz */
+	int ty0;
+	/** XTsiz */
+	int tdx;
+	/** YTsiz */
+	int tdy;
+	/** comment for coding */
+	char *comment;
+	/** number of tiles in width */
+	int tw;
+	/** number of tiles in heigth */
+	int th;
+	/** ID number of the tiles present in the codestream */
+	int *tileno;
+	/** size of the vector tileno */
+	int tileno_size;
+	/** packet header store there for futur use in t2_decode_packet */
+	unsigned char *ppm_data;
+	/** pointer remaining on the first byte of the first header if ppm is used */
+	unsigned char *ppm_data_first;
+	/** if ppm == 1 --> there was a PPM marker for the present tile */
+	int ppm;
+	/** use in case of multiple marker PPM (number of info already store) */
+	int ppm_store;
+	/** use in case of multiple marker PPM (case on non-finished previous info) */
+	int ppm_previous;
+	/** ppmbug1 */
+	int ppm_len;
+	/** tile coding parameters */
+	opj_tcp_t *tcps;
+	/** fixed layer */
+	int *matrice;
+/* UniPG>> */
+#ifdef USE_JPWL
+	/** enables writing of EPC in MH, thus activating JPWL */
+	bool epc_on;
+	/** enables writing of EPB, in case of activated JPWL */
+	bool epb_on;
+	/** enables writing of ESD, in case of activated JPWL */
+	bool esd_on;
+	/** enables writing of informative techniques of ESD, in case of activated JPWL */
+	bool info_on;
+	/** enables writing of RED, in case of activated JPWL */
+	bool red_on;
+	/** error protection method for MH (0,1,16,32,37-128) */
+	int hprot_MH;
+	/** tile number of header protection specification (>=0) */
+	int hprot_TPH_tileno[JPWL_MAX_NO_TILESPECS];
+	/** error protection methods for TPHs (0,1,16,32,37-128) */
+	int hprot_TPH[JPWL_MAX_NO_TILESPECS];
+	/** tile number of packet protection specification (>=0) */
+	int pprot_tileno[JPWL_MAX_NO_PACKSPECS];
+	/** packet number of packet protection specification (>=0) */
+	int pprot_packno[JPWL_MAX_NO_PACKSPECS];
+	/** error protection methods for packets (0,1,16,32,37-128) */
+	int pprot[JPWL_MAX_NO_PACKSPECS];
+	/** enables writing of ESD, (0/2/4 bytes) */
+	int sens_size;
+	/** sensitivity addressing size (0=auto/2/4 bytes) */
+	int sens_addr;
+	/** sensitivity range (0-3) */
+	int sens_range;
+	/** sensitivity method for MH (-1,0-7) */
+	int sens_MH;
+	/** tile number of sensitivity specification (>=0) */
+	int sens_TPH_tileno[JPWL_MAX_NO_TILESPECS];
+	/** sensitivity methods for TPHs (-1,0-7) */
+	int sens_TPH[JPWL_MAX_NO_TILESPECS];
+	/** enables JPWL correction at the decoder */
+	bool correct;
+	/** expected number of components at the decoder */
+	int exp_comps;
+	/** maximum number of tiles at the decoder */
+	int max_tiles;
+#endif /* USE_JPWL */
+/* <<UniPG */
+} opj_cp_t;
+
+/**
+JPEG-2000 codestream reader/writer
+*/
+typedef struct opj_j2k {
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** locate in which part of the codestream the decoder is (main header, tile header, end) */
+	int state;
+	/** number of the tile curently concern by coding/decoding */
+	int curtileno;
+	/** Tile part number*/
+	int tp_num;
+	/** Tilepart number currently coding*/
+	int cur_tp_num;
+	/** Total number of tileparts of the current tile*/
+	int *cur_totnum_tp;
+	/**
+	locate the start position of the TLM marker  
+	after encoding the tilepart, a jump (in j2k_write_sod) is done to the TLM marker to store the value of its length. 
+	*/
+	int tlm_start;
+	/** Total num of tile parts in whole image = num tiles* num tileparts in each tile*/
+	/** used in TLMmarker*/
+	int totnum_tp;	
+	/** 
+	locate the position of the end of the tile in the codestream, 
+	used to detect a truncated codestream (in j2k_read_sod)
+	*/
+	unsigned char *eot;
+	/**
+	locate the start position of the SOT marker of the current coded tile:  
+	after encoding the tile, a jump (in j2k_write_sod) is done to the SOT marker to store the value of its length. 
+	*/
+	int sot_start;
+	int sod_start;
+	/**
+	as the J2K-file is written in several parts during encoding, 
+	it enables to make the right correction in position return by cio_tell
+	*/
+	int pos_correction;
+	/** array used to store the data of each tile */
+	unsigned char **tile_data;
+	/** array used to store the length of each tile */
+	int *tile_len;
+	/** 
+	decompression only : 
+	store decoding parameters common to all tiles (information like COD, COC in main header)
+	*/
+	opj_tcp_t *default_tcp;
+	/** pointer to the encoded / decoded image */
+	opj_image_t *image;
+	/** pointer to the coding parameters */
+	opj_cp_t *cp;
+	/** helper used to write the index file */
+	opj_codestream_info_t *cstr_info;
+	/** pointer to the byte i/o stream */
+	opj_cio_t *cio;
+} opj_j2k_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Creates a J2K decompression structure
+@param cinfo Codec context info
+@return Returns a handle to a J2K decompressor if successful, returns NULL otherwise
+*/
+opj_j2k_t* j2k_create_decompress(opj_common_ptr cinfo);
+/**
+Destroy a J2K decompressor handle
+@param j2k J2K decompressor handle to destroy
+*/
+void j2k_destroy_decompress(opj_j2k_t *j2k);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in j2k->cp. 
+@param j2k J2K decompressor handle
+@param parameters decompression parameters
+*/
+void j2k_setup_decoder(opj_j2k_t *j2k, opj_dparameters_t *parameters);
+/**
+Decode an image from a JPEG-2000 codestream
+@param j2k J2K decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+opj_image_t* j2k_decode(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+/**
+Decode an image form a JPT-stream (JPEG 2000, JPIP)
+@param j2k J2K decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+opj_image_t* j2k_decode_jpt_stream(opj_j2k_t *j2k, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+/**
+Creates a J2K compression structure
+@param cinfo Codec context info
+@return Returns a handle to a J2K compressor if successful, returns NULL otherwise
+*/
+opj_j2k_t* j2k_create_compress(opj_common_ptr cinfo);
+/**
+Destroy a J2K compressor handle
+@param j2k J2K compressor handle to destroy
+*/
+void j2k_destroy_compress(opj_j2k_t *j2k);
+/**
+Setup the encoder parameters using the current image and using user parameters. 
+Coding parameters are returned in j2k->cp. 
+@param j2k J2K compressor handle
+@param parameters compression parameters
+@param image input filled image
+*/
+void j2k_setup_encoder(opj_j2k_t *j2k, opj_cparameters_t *parameters, opj_image_t *image);
+/**
+Converts an enum type progression order to string type
+*/
+char *j2k_convert_progression_order(OPJ_PROG_ORDER prg_order);
+/**
+Encode an image into a JPEG-2000 codestream
+@param j2k J2K compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param cstr_info Codestream information structure if required, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+bool j2k_encode(opj_j2k_t *j2k, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __J2K_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k_lib.c.svn-base ./libopenjpeg/.svn/text-base/j2k_lib.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k_lib.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/j2k_lib.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,59 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef WIN32
+#include <windows.h>
+#else
+#include <sys/time.h>
+#include <sys/resource.h>
+#include <sys/times.h>
+#endif /* WIN32 */
+#include "opj_includes.h"
+
+double opj_clock(void) {
+#ifdef WIN32
+	/* WIN32: use QueryPerformance (very accurate) */
+    LARGE_INTEGER freq , t ;
+    /* freq is the clock speed of the CPU */
+    QueryPerformanceFrequency(&freq) ;
+	/* cout << "freq = " << ((double) freq.QuadPart) << endl; */
+    /* t is the high resolution performance counter (see MSDN) */
+    QueryPerformanceCounter ( & t ) ;
+    return ( t.QuadPart /(double) freq.QuadPart ) ;
+#else
+	/* Unix or Linux: use resource usage */
+    struct rusage t;
+    double procTime;
+    /* (1) Get the rusage data structure at this moment (man getrusage) */
+    getrusage(0,&t);
+    /* (2) What is the elapsed time ? - CPU time = User time + System time */
+	/* (2a) Get the seconds */
+    procTime = t.ru_utime.tv_sec + t.ru_stime.tv_sec;
+    /* (2b) More precisely! Get the microseconds part ! */
+    return ( procTime + (t.ru_utime.tv_usec + t.ru_stime.tv_usec) * 1e-6 ) ;
+#endif
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k_lib.h.svn-base ./libopenjpeg/.svn/text-base/j2k_lib.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/j2k_lib.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/j2k_lib.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,54 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __J2K_LIB_H
+#define __J2K_LIB_H
+/**
+@file j2k_lib.h
+@brief Internal functions
+
+The functions in J2K_LIB.C are internal utilities mainly used for timing.
+*/
+
+/** @defgroup MISC MISC - Miscellaneous internal functions */
+/*@{*/
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Difference in successive opj_clock() calls tells you the elapsed time
+@return Returns time in seconds
+*/
+double opj_clock(void);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __J2K_LIB_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jp2.c.svn-base ./libopenjpeg/.svn/text-base/jp2.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jp2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/jp2.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,710 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup JP2 JP2 - JPEG-2000 file format reader/writer */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Read box headers
+@param cinfo Codec context info
+@param cio Input stream
+@param box
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_boxhdr(opj_common_ptr cinfo, opj_cio_t *cio, opj_jp2_box_t *box);
+/*static void jp2_write_url(opj_cio_t *cio, char *Idx_file);*/
+/**
+Read the IHDR box - Image Header box
+@param jp2 JP2 handle
+@param cio Input buffer stream
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_ihdr(opj_jp2_t *jp2, opj_cio_t *cio);
+static void jp2_write_ihdr(opj_jp2_t *jp2, opj_cio_t *cio);
+static void jp2_write_bpcc(opj_jp2_t *jp2, opj_cio_t *cio);
+static bool jp2_read_bpcc(opj_jp2_t *jp2, opj_cio_t *cio);
+static void jp2_write_colr(opj_jp2_t *jp2, opj_cio_t *cio);
+static bool jp2_read_colr(opj_jp2_t *jp2, opj_cio_t *cio);
+/**
+Write the FTYP box - File type box
+@param jp2 JP2 handle
+@param cio Output buffer stream
+*/
+static void jp2_write_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
+/**
+Read the FTYP box - File type box
+@param jp2 JP2 handle
+@param cio Input buffer stream
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio);
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+static bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset);
+static void jp2_write_jp(opj_cio_t *cio);
+/**
+Read the JP box - JPEG 2000 signature
+@param jp2 JP2 handle
+@param cio Input buffer stream
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_jp(opj_jp2_t *jp2, opj_cio_t *cio);
+/**
+Decode the structure of a JP2 file
+@param jp2 JP2 handle
+@param cio Input buffer stream
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_struct(opj_jp2_t *jp2, opj_cio_t *cio);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+static bool jp2_read_boxhdr(opj_common_ptr cinfo, opj_cio_t *cio, opj_jp2_box_t *box) {
+	box->init_pos = cio_tell(cio);
+	box->length = cio_read(cio, 4);
+	box->type = cio_read(cio, 4);
+	if (box->length == 1) {
+		if (cio_read(cio, 4) != 0) {
+			opj_event_msg(cinfo, EVT_ERROR, "Cannot handle box sizes higher than 2^32\n");
+			return false;
+		}
+		box->length = cio_read(cio, 4);
+		if (box->length == 0) 
+			box->length = cio_numbytesleft(cio) + 12;
+	}
+	else if (box->length == 0) {
+		box->length = cio_numbytesleft(cio) + 8;
+	}
+	
+	return true;
+}
+
+#if 0
+static void jp2_write_url(opj_cio_t *cio, char *Idx_file) {
+	unsigned int i;
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_URL, 4);	/* DBTL */
+	cio_write(cio, 0, 1);		/* VERS */
+	cio_write(cio, 0, 3);		/* FLAG */
+
+	if(Idx_file) {
+		for (i = 0; i < strlen(Idx_file); i++) {
+			cio_write(cio, Idx_file[i], 1);
+		}
+	}
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+#endif
+
+static bool jp2_read_ihdr(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	if (JP2_IHDR != box.type) {
+		opj_event_msg(cinfo, EVT_ERROR, "Expected IHDR Marker\n");
+		return false;
+	}
+
+	jp2->h = cio_read(cio, 4);			/* HEIGHT */
+	jp2->w = cio_read(cio, 4);			/* WIDTH */
+	jp2->numcomps = cio_read(cio, 2);	/* NC */
+	jp2->comps = (opj_jp2_comps_t*) opj_malloc(jp2->numcomps * sizeof(opj_jp2_comps_t));
+
+	jp2->bpc = cio_read(cio, 1);		/* BPC */
+
+	jp2->C = cio_read(cio, 1);			/* C */
+	jp2->UnkC = cio_read(cio, 1);		/* UnkC */
+	jp2->IPR = cio_read(cio, 1);		/* IPR */
+
+	if (cio_tell(cio) - box.init_pos != box.length) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with IHDR Box\n");
+		return false;
+	}
+
+	return true;
+}
+
+static void jp2_write_ihdr(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_IHDR, 4);		/* IHDR */
+
+	cio_write(cio, jp2->h, 4);			/* HEIGHT */
+	cio_write(cio, jp2->w, 4);			/* WIDTH */
+	cio_write(cio, jp2->numcomps, 2);	/* NC */
+
+	cio_write(cio, jp2->bpc, 1);		/* BPC */
+
+	cio_write(cio, jp2->C, 1);			/* C : Always 7 */
+	cio_write(cio, jp2->UnkC, 1);		/* UnkC, colorspace unknown */
+	cio_write(cio, jp2->IPR, 1);		/* IPR, no intellectual property */
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+static void jp2_write_bpcc(opj_jp2_t *jp2, opj_cio_t *cio) {
+	unsigned int i;
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_BPCC, 4);	/* BPCC */
+
+	for (i = 0; i < jp2->numcomps; i++) {
+		cio_write(cio, jp2->comps[i].bpcc, 1);
+	}
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+
+static bool jp2_read_bpcc(opj_jp2_t *jp2, opj_cio_t *cio) {
+	unsigned int i;
+	opj_jp2_box_t box;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	if (JP2_BPCC != box.type) {
+		opj_event_msg(cinfo, EVT_ERROR, "Expected BPCC Marker\n");
+		return false;
+	}
+
+	for (i = 0; i < jp2->numcomps; i++) {
+		jp2->comps[i].bpcc = cio_read(cio, 1);
+	}
+
+	if (cio_tell(cio) - box.init_pos != box.length) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with BPCC Box\n");
+		return false;
+	}
+
+	return true;
+}
+
+static void jp2_write_colr(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_COLR, 4);		/* COLR */
+
+	cio_write(cio, jp2->meth, 1);		/* METH */
+	cio_write(cio, jp2->precedence, 1);	/* PRECEDENCE */
+	cio_write(cio, jp2->approx, 1);		/* APPROX */
+
+	if (jp2->meth == 1) {
+		cio_write(cio, jp2->enumcs, 4);	/* EnumCS */
+	} else {
+		cio_write(cio, 0, 1);			/* PROFILE (??) */
+	}
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+static bool jp2_read_colr(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+	int skip_len;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	do {
+		if (JP2_COLR != box.type) {
+			cio_skip(cio, box.length - 8);
+			jp2_read_boxhdr(cinfo, cio, &box);
+		}
+	} while(JP2_COLR != box.type);
+
+	jp2->meth = cio_read(cio, 1);		/* METH */
+	jp2->precedence = cio_read(cio, 1);	/* PRECEDENCE */
+	jp2->approx = cio_read(cio, 1);		/* APPROX */
+
+	if (jp2->meth == 1) {
+		jp2->enumcs = cio_read(cio, 4);	/* EnumCS */
+	} else {
+		/* skip PROFILE */
+		skip_len = box.init_pos + box.length - cio_tell(cio);
+		if (skip_len < 0) {
+			opj_event_msg(cinfo, EVT_ERROR, "Error with JP2H box size\n");
+			return false;
+		}
+		cio_skip(cio, box.init_pos + box.length - cio_tell(cio));
+	}
+
+	if (cio_tell(cio) - box.init_pos != box.length) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with BPCC Box\n");
+		return false;
+	}
+	return true;
+}
+
+void jp2_write_jp2h(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_JP2H, 4);	/* JP2H */
+
+	jp2_write_ihdr(jp2, cio);
+
+	if (jp2->bpc == 255) {
+		jp2_write_bpcc(jp2, cio);
+	}
+	jp2_write_colr(jp2, cio);
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+bool jp2_read_jp2h(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+	int skip_len;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	do {
+		if (JP2_JP2H != box.type) {
+			if (box.type == JP2_JP2C) {
+				opj_event_msg(cinfo, EVT_ERROR, "Expected JP2H Marker\n");
+				return false;
+			}
+			cio_skip(cio, box.length - 8);
+			jp2_read_boxhdr(cinfo, cio, &box);
+		}
+	} while(JP2_JP2H != box.type);
+
+	if (!jp2_read_ihdr(jp2, cio))
+		return false;
+
+	if (jp2->bpc == 255) {
+		if (!jp2_read_bpcc(jp2, cio))
+			return false;
+	}
+	if (!jp2_read_colr(jp2, cio))
+		return false;
+
+	skip_len = box.init_pos + box.length - cio_tell(cio);
+	if (skip_len < 0) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with JP2H Box\n");
+		return false;
+	}
+	cio_skip(cio, box.init_pos + box.length - cio_tell(cio));
+
+	return true;
+}
+
+static void jp2_write_ftyp(opj_jp2_t *jp2, opj_cio_t *cio) {
+	unsigned int i;
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_FTYP, 4);		/* FTYP */
+
+	cio_write(cio, jp2->brand, 4);		/* BR */
+	cio_write(cio, jp2->minversion, 4);	/* MinV */
+
+	for (i = 0; i < jp2->numcl; i++) {
+		cio_write(cio, jp2->cl[i], 4);	/* CL */
+	}
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+static bool jp2_read_ftyp(opj_jp2_t *jp2, opj_cio_t *cio) {
+	int i;
+	opj_jp2_box_t box;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+
+	if (JP2_FTYP != box.type) {
+		opj_event_msg(cinfo, EVT_ERROR, "Expected FTYP Marker\n");
+		return false;
+	}
+
+	jp2->brand = cio_read(cio, 4);		/* BR */
+	jp2->minversion = cio_read(cio, 4);	/* MinV */
+	jp2->numcl = (box.length - 16) / 4;
+	jp2->cl = (unsigned int *) opj_malloc(jp2->numcl * sizeof(unsigned int));
+
+	for (i = 0; i < (int)jp2->numcl; i++) {
+		jp2->cl[i] = cio_read(cio, 4);	/* CLi */
+	}
+
+	if (cio_tell(cio) - box.init_pos != box.length) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with FTYP Box\n");
+		return false;
+	}
+
+	return true;
+}
+
+static int jp2_write_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
+	unsigned int j2k_codestream_offset, j2k_codestream_length;
+	opj_jp2_box_t box;
+
+	opj_j2k_t *j2k = jp2->j2k;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_JP2C, 4);	/* JP2C */
+
+	/* J2K encoding */
+	j2k_codestream_offset = cio_tell(cio);
+	if(!j2k_encode(j2k, cio, image, cstr_info)) {
+		opj_event_msg(j2k->cinfo, EVT_ERROR, "Failed to encode image\n");
+		return 0;
+	}
+	j2k_codestream_length = cio_tell(cio) - j2k_codestream_offset;
+
+	jp2->j2k_codestream_offset = j2k_codestream_offset;
+	jp2->j2k_codestream_length = j2k_codestream_length;
+
+	box.length = 8 + jp2->j2k_codestream_length;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+
+	return box.length;
+}
+
+static bool jp2_read_jp2c(opj_jp2_t *jp2, opj_cio_t *cio, unsigned int *j2k_codestream_length, unsigned int *j2k_codestream_offset) {
+	opj_jp2_box_t box;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	do {
+		if(JP2_JP2C != box.type) {
+			cio_skip(cio, box.length - 8);
+			jp2_read_boxhdr(cinfo, cio, &box);
+		}
+	} while(JP2_JP2C != box.type);
+
+	*j2k_codestream_offset = cio_tell(cio);
+	*j2k_codestream_length = box.length - 8;
+
+	return true;
+}
+
+static void jp2_write_jp(opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	box.init_pos = cio_tell(cio);
+	cio_skip(cio, 4);
+	cio_write(cio, JP2_JP, 4);		/* JP2 signature */
+	cio_write(cio, 0x0d0a870a, 4);
+
+	box.length = cio_tell(cio) - box.init_pos;
+	cio_seek(cio, box.init_pos);
+	cio_write(cio, box.length, 4);	/* L */
+	cio_seek(cio, box.init_pos + box.length);
+}
+
+static bool jp2_read_jp(opj_jp2_t *jp2, opj_cio_t *cio) {
+	opj_jp2_box_t box;
+
+	opj_common_ptr cinfo = jp2->cinfo;
+
+	jp2_read_boxhdr(cinfo, cio, &box);
+	if (JP2_JP != box.type) {
+		opj_event_msg(cinfo, EVT_ERROR, "Expected JP Marker\n");
+		return false;
+	}
+	if (0x0d0a870a != cio_read(cio, 4)) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with JP Marker\n");
+		return false;
+	}
+	if (cio_tell(cio) - box.init_pos != box.length) {
+		opj_event_msg(cinfo, EVT_ERROR, "Error with JP Box size\n");
+		return false;
+	}
+
+	return true;
+}
+
+
+static bool jp2_read_struct(opj_jp2_t *jp2, opj_cio_t *cio) {
+	if (!jp2_read_jp(jp2, cio))
+		return false;
+	if (!jp2_read_ftyp(jp2, cio))
+		return false;
+	if (!jp2_read_jp2h(jp2, cio))
+		return false;
+	if (!jp2_read_jp2c(jp2, cio, &jp2->j2k_codestream_length, &jp2->j2k_codestream_offset))
+		return false;
+	
+	return true;
+}
+
+/* ----------------------------------------------------------------------- */
+/* JP2 decoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo) {
+	opj_jp2_t *jp2 = (opj_jp2_t*) opj_calloc(1, sizeof(opj_jp2_t));
+	if(jp2) {
+		jp2->cinfo = cinfo;
+		/* create the J2K codec */
+		jp2->j2k = j2k_create_decompress(cinfo);
+		if(jp2->j2k == NULL) {
+			jp2_destroy_decompress(jp2);
+			return NULL;
+		}
+	}
+	return jp2;
+}
+
+void jp2_destroy_decompress(opj_jp2_t *jp2) {
+	if(jp2) {
+		/* destroy the J2K codec */
+		j2k_destroy_decompress(jp2->j2k);
+
+		if(jp2->comps) {
+			opj_free(jp2->comps);
+		}
+		if(jp2->cl) {
+			opj_free(jp2->cl);
+		}
+		opj_free(jp2);
+	}
+}
+
+void jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters) {
+	/* setup the J2K codec */
+	j2k_setup_decoder(jp2->j2k, parameters);
+	/* further JP2 initializations go here */
+}
+
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
+	opj_common_ptr cinfo;
+	opj_image_t *image = NULL;
+
+	if(!jp2 || !cio) {
+		return NULL;
+	}
+
+	cinfo = jp2->cinfo;
+
+	/* JP2 decoding */
+	if(!jp2_read_struct(jp2, cio)) {
+		opj_event_msg(cinfo, EVT_ERROR, "Failed to decode jp2 structure\n");
+		return NULL;
+	}
+
+	/* J2K decoding */
+	image = j2k_decode(jp2->j2k, cio, cstr_info);
+	if(!image) {
+		opj_event_msg(cinfo, EVT_ERROR, "Failed to decode J2K image\n");
+	}
+
+	/* Set Image Color Space */
+	if (jp2->enumcs == 16)
+		image->color_space = CLRSPC_SRGB;
+	else if (jp2->enumcs == 17)
+		image->color_space = CLRSPC_GRAY;
+	else if (jp2->enumcs == 18)
+		image->color_space = CLRSPC_SYCC;
+	else
+		image->color_space = CLRSPC_UNKNOWN;
+
+	return image;
+}
+
+/* ----------------------------------------------------------------------- */
+/* JP2 encoder interface                                             */
+/* ----------------------------------------------------------------------- */
+
+opj_jp2_t* jp2_create_compress(opj_common_ptr cinfo) {
+	opj_jp2_t *jp2 = (opj_jp2_t*)opj_malloc(sizeof(opj_jp2_t));
+	if(jp2) {
+		jp2->cinfo = cinfo;
+		/* create the J2K codec */
+		jp2->j2k = j2k_create_compress(cinfo);
+		if(jp2->j2k == NULL) {
+			jp2_destroy_compress(jp2);
+			return NULL;
+		}
+	}
+	return jp2;
+}
+
+void jp2_destroy_compress(opj_jp2_t *jp2) {
+	if(jp2) {
+		/* destroy the J2K codec */
+		j2k_destroy_compress(jp2->j2k);
+
+		if(jp2->comps) {
+			opj_free(jp2->comps);
+		}
+		if(jp2->cl) {
+			opj_free(jp2->cl);
+		}
+		opj_free(jp2);
+	}
+}
+
+void jp2_setup_encoder(opj_jp2_t *jp2, opj_cparameters_t *parameters, opj_image_t *image) {
+	int i;
+	int depth_0, sign;
+
+	if(!jp2 || !parameters || !image)
+		return;
+
+	/* setup the J2K codec */
+	/* ------------------- */
+
+	/* Check if number of components respects standard */
+	if (image->numcomps < 1 || image->numcomps > 16384) {
+		opj_event_msg(jp2->cinfo, EVT_ERROR, "Invalid number of components specified while setting up JP2 encoder\n");
+		return;
+	}
+
+	j2k_setup_encoder(jp2->j2k, parameters, image);
+
+	/* setup the JP2 codec */
+	/* ------------------- */
+	
+	/* Profile box */
+
+	jp2->brand = JP2_JP2;	/* BR */
+	jp2->minversion = 0;	/* MinV */
+	jp2->numcl = 1;
+	jp2->cl = (unsigned int*) opj_malloc(jp2->numcl * sizeof(unsigned int));
+	jp2->cl[0] = JP2_JP2;	/* CL0 : JP2 */
+
+	/* Image Header box */
+
+	jp2->numcomps = image->numcomps;	/* NC */
+	jp2->comps = (opj_jp2_comps_t*) opj_malloc(jp2->numcomps * sizeof(opj_jp2_comps_t));
+	jp2->h = image->y1 - image->y0;		/* HEIGHT */
+	jp2->w = image->x1 - image->x0;		/* WIDTH */
+	/* BPC */
+	depth_0 = image->comps[0].prec - 1;
+	sign = image->comps[0].sgnd;
+	jp2->bpc = depth_0 + (sign << 7);
+	for (i = 1; i < image->numcomps; i++) {
+		int depth = image->comps[i].prec - 1;
+		sign = image->comps[i].sgnd;
+		if (depth_0 != depth)
+			jp2->bpc = 255;
+	}
+	jp2->C = 7;			/* C : Always 7 */
+	jp2->UnkC = 0;		/* UnkC, colorspace specified in colr box */
+	jp2->IPR = 0;		/* IPR, no intellectual property */
+	
+	/* BitsPerComponent box */
+
+	for (i = 0; i < image->numcomps; i++) {
+		jp2->comps[i].bpcc = image->comps[i].prec - 1 + (image->comps[i].sgnd << 7);
+	}
+
+	/* Colour Specification box */
+
+	if ((image->numcomps == 1 || image->numcomps == 3) && (jp2->bpc != 255)) {
+		jp2->meth = 1;	/* METH: Enumerated colourspace */
+	} else {
+		jp2->meth = 2;	/* METH: Restricted ICC profile */
+	}
+	if (jp2->meth == 1) {
+		if (image->color_space == 1)
+			jp2->enumcs = 16;	/* sRGB as defined by IEC 6196621 */
+		else if (image->color_space == 2)
+			jp2->enumcs = 17;	/* greyscale */
+		else if (image->color_space == 3)
+			jp2->enumcs = 18;	/* YUV */
+	} else {
+		jp2->enumcs = 0;		/* PROFILE (??) */
+	}
+	jp2->precedence = 0;	/* PRECEDENCE */
+	jp2->approx = 0;		/* APPROX */
+
+}
+
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
+
+	/* JP2 encoding */
+
+	/* JPEG 2000 Signature box */
+	jp2_write_jp(cio);
+	/* File Type box */
+	jp2_write_ftyp(jp2, cio);
+	/* JP2 Header box */
+	jp2_write_jp2h(jp2, cio);
+
+	/* J2K encoding */
+
+	if(!jp2_write_jp2c(jp2, cio, image, cstr_info)) {
+		opj_event_msg(jp2->cinfo, EVT_ERROR, "Failed to encode image\n");
+		return false;
+	}
+
+	return true;
+}
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jp2.h.svn-base ./libopenjpeg/.svn/text-base/jp2.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jp2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/jp2.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,177 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __JP2_H
+#define __JP2_H
+/**
+@file jp2.h
+@brief The JPEG-2000 file format Reader/Writer (JP2)
+
+*/
+
+/** @defgroup JP2 JP2 - JPEG-2000 file format reader/writer */
+/*@{*/
+
+#define JPIP_JPIP 0x6a706970
+
+#define JP2_JP   0x6a502020		/**< JPEG 2000 signature box */
+#define JP2_FTYP 0x66747970		/**< File type box */
+#define JP2_JP2H 0x6a703268		/**< JP2 header box */
+#define JP2_IHDR 0x69686472		/**< Image header box */
+#define JP2_COLR 0x636f6c72		/**< Colour specification box */
+#define JP2_JP2C 0x6a703263		/**< Contiguous codestream box */
+#define JP2_URL  0x75726c20		/**< URL box */
+#define JP2_DBTL 0x6474626c		/**< ??? */
+#define JP2_BPCC 0x62706363		/**< Bits per component box */
+#define JP2_JP2  0x6a703220		/**< File type fields */
+
+/* ----------------------------------------------------------------------- */
+
+/** 
+JP2 component
+*/
+typedef struct opj_jp2_comps {
+  int depth;		  
+  int sgnd;		   
+  int bpcc;
+} opj_jp2_comps_t;
+
+/**
+JPEG-2000 file format reader/writer
+*/
+typedef struct opj_jp2 {
+	/** codec context */
+	opj_common_ptr cinfo;
+	/** handle to the J2K codec  */
+	opj_j2k_t *j2k;
+	unsigned int w;
+	unsigned int h;
+	unsigned int numcomps;
+	unsigned int bpc;
+	unsigned int C;
+	unsigned int UnkC;
+	unsigned int IPR;
+	unsigned int meth;
+	unsigned int approx;
+	unsigned int enumcs;
+	unsigned int precedence;
+	unsigned int brand;
+	unsigned int minversion;
+	unsigned int numcl;
+	unsigned int *cl;
+	opj_jp2_comps_t *comps;
+	unsigned int j2k_codestream_offset;
+	unsigned int j2k_codestream_length;
+} opj_jp2_t;
+
+/**
+JP2 Box
+*/
+typedef struct opj_jp2_box {
+  int length;
+  int type;
+  int init_pos;
+} opj_jp2_box_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Write the JP2H box - JP2 Header box (used in MJ2)
+@param jp2 JP2 handle
+@param cio Output buffer stream
+*/
+void jp2_write_jp2h(opj_jp2_t *jp2, opj_cio_t *cio);
+/**
+Read the JP2H box - JP2 Header box (used in MJ2)
+@param jp2 JP2 handle
+@param cio Input buffer stream
+@return Returns true if successful, returns false otherwise
+*/
+bool jp2_read_jp2h(opj_jp2_t *jp2, opj_cio_t *cio);
+/**
+Creates a JP2 decompression structure
+@param cinfo Codec context info
+@return Returns a handle to a JP2 decompressor if successful, returns NULL otherwise
+*/
+opj_jp2_t* jp2_create_decompress(opj_common_ptr cinfo);
+/**
+Destroy a JP2 decompressor handle
+@param jp2 JP2 decompressor handle to destroy
+*/
+void jp2_destroy_decompress(opj_jp2_t *jp2);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in jp2->j2k->cp. 
+@param jp2 JP2 decompressor handle
+@param parameters decompression parameters
+*/
+void jp2_setup_decoder(opj_jp2_t *jp2, opj_dparameters_t *parameters);
+/**
+Decode an image from a JPEG-2000 file stream
+@param jp2 JP2 decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if required, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+opj_image_t* jp2_decode(opj_jp2_t *jp2, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+/**
+Creates a JP2 compression structure
+@param cinfo Codec context info
+@return Returns a handle to a JP2 compressor if successful, returns NULL otherwise
+*/
+opj_jp2_t* jp2_create_compress(opj_common_ptr cinfo);
+/**
+Destroy a JP2 compressor handle
+@param jp2 JP2 compressor handle to destroy
+*/
+void jp2_destroy_compress(opj_jp2_t *jp2);
+/**
+Setup the encoder parameters using the current image and using user parameters. 
+Coding parameters are returned in jp2->j2k->cp. 
+@param jp2 JP2 compressor handle
+@param parameters compression parameters
+@param image input filled image
+*/
+void jp2_setup_encoder(opj_jp2_t *jp2, opj_cparameters_t *parameters, opj_image_t *image);
+/**
+Encode an image into a JPEG-2000 file stream
+@param jp2 JP2 compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param cstr_info Codestream information structure if required, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+bool jp2_encode(opj_jp2_t *jp2, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __JP2_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jpt.c.svn-base ./libopenjpeg/.svn/text-base/jpt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jpt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/jpt.c.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,155 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/*
+ * Read the information contains in VBAS [JPP/JPT stream message header]
+ * Store information (7 bits) in value
+ *
+ */
+unsigned int jpt_read_VBAS_info(opj_cio_t *cio, unsigned int value) {
+	unsigned char elmt;
+
+	elmt = cio_read(cio, 1);
+	while ((elmt >> 7) == 1) {
+		value = (value << 7);
+		value |= (elmt & 0x7f);
+		elmt = cio_read(cio, 1);
+	}
+	value = (value << 7);
+	value |= (elmt & 0x7f);
+
+	return value;
+}
+
+/*
+ * Initialize the value of the message header structure 
+ *
+ */
+void jpt_init_msg_header(opj_jpt_msg_header_t * header) {
+	header->Id = 0;		/* In-class Identifier    */
+	header->last_byte = 0;	/* Last byte information  */
+	header->Class_Id = 0;		/* Class Identifier       */
+	header->CSn_Id = 0;		/* CSn : index identifier */
+	header->Msg_offset = 0;	/* Message offset         */
+	header->Msg_length = 0;	/* Message length         */
+	header->Layer_nb = 0;		/* Auxiliary for JPP case */
+}
+
+/*
+ * Re-initialize the value of the message header structure
+ *
+ * Only parameters always present in message header
+ *
+ */
+void jpt_reinit_msg_header(opj_jpt_msg_header_t * header) {
+	header->Id = 0;		/* In-class Identifier    */
+	header->last_byte = 0;	/* Last byte information  */
+	header->Msg_offset = 0;	/* Message offset         */
+	header->Msg_length = 0;	/* Message length         */
+}
+
+/*
+ * Read the message header for a JPP/JPT - stream
+ *
+ */
+void jpt_read_msg_header(opj_common_ptr cinfo, opj_cio_t *cio, opj_jpt_msg_header_t *header) {
+	unsigned char elmt, Class = 0, CSn = 0;
+	jpt_reinit_msg_header(header);
+
+	/* ------------- */
+	/* VBAS : Bin-ID */
+	/* ------------- */
+	elmt = cio_read(cio, 1);
+
+	/* See for Class and CSn */
+	switch ((elmt >> 5) & 0x03) {
+		case 0:
+			opj_event_msg(cinfo, EVT_ERROR, "Forbidden value encounter in message header !!\n");
+			break;
+		case 1:
+			Class = 0;
+			CSn = 0;
+			break;
+		case 2:
+			Class = 1;
+			CSn = 0;
+			break;
+		case 3:
+			Class = 1;
+			CSn = 1;
+			break;
+		default:
+			break;
+	}
+
+	/* see information on bits 'c' [p 10 : A.2.1 general, ISO/IEC FCD 15444-9] */
+	if (((elmt >> 4) & 0x01) == 1)
+		header->last_byte = 1;
+
+	/* In-class identifier */
+	header->Id |= (elmt & 0x0f);
+	if ((elmt >> 7) == 1)
+		header->Id = jpt_read_VBAS_info(cio, header->Id);
+
+	/* ------------ */
+	/* VBAS : Class */
+	/* ------------ */
+	if (Class == 1) {
+		header->Class_Id = 0;
+		header->Class_Id = jpt_read_VBAS_info(cio, header->Class_Id);
+	}
+
+	/* ---------- */
+	/* VBAS : CSn */
+	/* ---------- */
+	if (CSn == 1) {
+		header->CSn_Id = 0;
+		header->CSn_Id = jpt_read_VBAS_info(cio, header->CSn_Id);
+	}
+
+	/* ----------------- */
+	/* VBAS : Msg_offset */
+	/* ----------------- */
+	header->Msg_offset = jpt_read_VBAS_info(cio, header->Msg_offset);
+
+	/* ----------------- */
+	/* VBAS : Msg_length */
+	/* ----------------- */
+	header->Msg_length = jpt_read_VBAS_info(cio, header->Msg_length);
+
+	/* ---------- */
+	/* VBAS : Aux */
+	/* ---------- */
+	if ((header->Class_Id & 0x01) == 1) {
+		header->Layer_nb = 0;
+		header->Layer_nb = jpt_read_VBAS_info(cio, header->Layer_nb);
+	}
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jpt.h.svn-base ./libopenjpeg/.svn/text-base/jpt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/jpt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/jpt.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,75 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __JPT_H
+#define __JPT_H
+/**
+@file jpt.h
+@brief JPT-stream reader (JPEG 2000, JPIP)
+
+JPT-stream functions are implemented in J2K.C. 
+*/
+
+/**
+Message Header JPT stream structure
+*/
+typedef struct opj_jpt_msg_header {
+	/** In-class Identifier */
+	unsigned int Id;
+	/** Last byte information */
+	unsigned int last_byte;	
+	/** Class Identifier */
+	unsigned int Class_Id;	
+	/** CSn : index identifier */
+	unsigned int CSn_Id;
+	/** Message offset */
+	unsigned int Msg_offset;
+	/** Message length */
+	unsigned int Msg_length;
+	/** Auxiliary for JPP case */
+	unsigned int Layer_nb;
+} opj_jpt_msg_header_t;
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Initialize the value of the message header structure 
+@param header Message header structure
+*/
+void jpt_init_msg_header(opj_jpt_msg_header_t * header);
+
+/**
+Read the message header for a JPP/JPT - stream
+@param cinfo Codec context info
+@param cio CIO handle
+@param header Message header structure
+*/
+void jpt_read_msg_header(opj_common_ptr cinfo, opj_cio_t *cio, opj_jpt_msg_header_t *header);
+
+#endif
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mct.c.svn-base ./libopenjpeg/.svn/text-base/mct.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mct.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/mct.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* <summary> */
+/* This table contains the norms of the basis function of the reversible MCT. */
+/* </summary> */
+static const double mct_norms[3] = { 1.732, .8292, .8292 };
+
+/* <summary> */
+/* This table contains the norms of the basis function of the irreversible MCT. */
+/* </summary> */
+static const double mct_norms_real[3] = { 1.732, 1.805, 1.573 };
+
+/* <summary> */
+/* Foward reversible MCT. */
+/* </summary> */
+void mct_encode(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
+	int i;
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y = (r + (g * 2) + b) >> 2;
+		int u = b - g;
+		int v = r - g;
+		c0[i] = y;
+		c1[i] = u;
+		c2[i] = v;
+	}
+}
+
+/* <summary> */
+/* Inverse reversible MCT. */
+/* </summary> */
+void mct_decode(
+		int* restrict c0,
+		int* restrict c1, 
+		int* restrict c2, 
+		int n)
+{
+	int i;
+	for (i = 0; i < n; ++i) {
+		int y = c0[i];
+		int u = c1[i];
+		int v = c2[i];
+		int g = y - ((u + v) >> 2);
+		int r = v + g;
+		int b = u + g;
+		c0[i] = r;
+		c1[i] = g;
+		c2[i] = b;
+	}
+}
+
+/* <summary> */
+/* Get norm of basis function of reversible MCT. */
+/* </summary> */
+double mct_getnorm(int compno) {
+	return mct_norms[compno];
+}
+
+/* <summary> */
+/* Foward irreversible MCT. */
+/* </summary> */
+void mct_encode_real(
+		int* restrict c0,
+		int* restrict c1,
+		int* restrict c2,
+		int n)
+{
+	int i;
+	for(i = 0; i < n; ++i) {
+		int r = c0[i];
+		int g = c1[i];
+		int b = c2[i];
+		int y =  fix_mul(r, 2449) + fix_mul(g, 4809) + fix_mul(b, 934);
+		int u = -fix_mul(r, 1382) - fix_mul(g, 2714) + fix_mul(b, 4096);
+		int v =  fix_mul(r, 4096) - fix_mul(g, 3430) - fix_mul(b, 666);
+		c0[i] = y;
+		c1[i] = u;
+		c2[i] = v;
+	}
+}
+
+/* <summary> */
+/* Inverse irreversible MCT. */
+/* </summary> */
+void mct_decode_real(
+		float* restrict c0,
+		float* restrict c1,
+		float* restrict c2,
+		int n)
+{
+	int i;
+	for(i = 0; i < n; ++i) {
+		float y = c0[i];
+		float u = c1[i];
+		float v = c2[i];
+		float r = y + (v * 1.402f);
+		float g = y - (u * 0.34413f) - (v * (0.71414f));
+		float b = y + (u * 1.772f);
+		c0[i] = r;
+		c1[i] = g;
+		c2[i] = b;
+	}
+}
+
+/* <summary> */
+/* Get norm of basis function of irreversible MCT. */
+/* </summary> */
+double mct_getnorm_real(int compno) {
+	return mct_norms_real[compno];
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mct.h.svn-base ./libopenjpeg/.svn/text-base/mct.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mct.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/mct.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,98 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MCT_H
+#define __MCT_H
+/**
+@file mct.h
+@brief Implementation of a multi-component transforms (MCT)
+
+The functions in MCT.C have for goal to realize reversible and irreversible multicomponent
+transform. The functions in MCT.C are used by some function in TCD.C.
+*/
+
+/** @defgroup MCT MCT - Implementation of a multi-component transform */
+/*@{*/
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Apply a reversible multi-component transform to an image
+@param c0 Samples for red component
+@param c1 Samples for green component
+@param c2 Samples blue component
+@param n Number of samples for each component
+*/
+void mct_encode(int *c0, int *c1, int *c2, int n);
+/**
+Apply a reversible multi-component inverse transform to an image
+@param c0 Samples for luminance component
+@param c1 Samples for red chrominance component
+@param c2 Samples for blue chrominance component
+@param n Number of samples for each component
+*/
+void mct_decode(int *c0, int *c1, int *c2, int n);
+/**
+Get norm of the basis function used for the reversible multi-component transform
+@param compno Number of the component (0->Y, 1->U, 2->V)
+@return 
+*/
+double mct_getnorm(int compno);
+
+/**
+Apply an irreversible multi-component transform to an image
+@param c0 Samples for red component
+@param c1 Samples for green component
+@param c2 Samples blue component
+@param n Number of samples for each component
+*/
+void mct_encode_real(int *c0, int *c1, int *c2, int n);
+/**
+Apply an irreversible multi-component inverse transform to an image
+@param c0 Samples for luminance component
+@param c1 Samples for red chrominance component
+@param c2 Samples for blue chrominance component
+@param n Number of samples for each component
+*/
+void mct_decode_real(float* c0, float* c1, float* c2, int n);
+/**
+Get norm of the basis function used for the irreversible multi-component transform
+@param compno Number of the component (0->Y, 1->U, 2->V)
+@return 
+*/
+double mct_getnorm_real(int compno);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __MCT_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mqc.c.svn-base ./libopenjpeg/.svn/text-base/mqc.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mqc.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/mqc.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,538 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup MQC MQC - Implementation of an MQ-Coder */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Output a byte, doing bit-stuffing if necessary.
+After a 0xff byte, the next byte must be smaller than 0x90.
+@param mqc MQC handle
+*/
+static void mqc_byteout(opj_mqc_t *mqc);
+/**
+Renormalize mqc->a and mqc->c while encoding, so that mqc->a stays between 0x8000 and 0x10000
+@param mqc MQC handle
+*/
+static void mqc_renorme(opj_mqc_t *mqc);
+/**
+Encode the most probable symbol
+@param mqc MQC handle
+*/
+static void mqc_codemps(opj_mqc_t *mqc);
+/**
+Encode the most least symbol
+@param mqc MQC handle
+*/
+static void mqc_codelps(opj_mqc_t *mqc);
+/**
+Fill mqc->c with 1's for flushing
+@param mqc MQC handle
+*/
+static void mqc_setbits(opj_mqc_t *mqc);
+/**
+FIXME: documentation ???
+@param mqc MQC handle
+@return 
+*/
+static int mqc_mpsexchange(opj_mqc_t *mqc);
+/**
+FIXME: documentation ???
+@param mqc MQC handle
+@return 
+*/
+static int mqc_lpsexchange(opj_mqc_t *mqc);
+/**
+Input a byte
+@param mqc MQC handle
+*/
+static void mqc_bytein(opj_mqc_t *mqc);
+/**
+Renormalize mqc->a and mqc->c while decoding
+@param mqc MQC handle
+*/
+static void mqc_renormd(opj_mqc_t *mqc);
+
+/*@}*/
+
+/*@}*/
+
+/* <summary> */
+/* This array defines all the possible states for a context. */
+/* </summary> */
+static opj_mqc_state_t mqc_states[47 * 2] = {
+	{0x5601, 0, &mqc_states[2], &mqc_states[3]},
+	{0x5601, 1, &mqc_states[3], &mqc_states[2]},
+	{0x3401, 0, &mqc_states[4], &mqc_states[12]},
+	{0x3401, 1, &mqc_states[5], &mqc_states[13]},
+	{0x1801, 0, &mqc_states[6], &mqc_states[18]},
+	{0x1801, 1, &mqc_states[7], &mqc_states[19]},
+	{0x0ac1, 0, &mqc_states[8], &mqc_states[24]},
+	{0x0ac1, 1, &mqc_states[9], &mqc_states[25]},
+	{0x0521, 0, &mqc_states[10], &mqc_states[58]},
+	{0x0521, 1, &mqc_states[11], &mqc_states[59]},
+	{0x0221, 0, &mqc_states[76], &mqc_states[66]},
+	{0x0221, 1, &mqc_states[77], &mqc_states[67]},
+	{0x5601, 0, &mqc_states[14], &mqc_states[13]},
+	{0x5601, 1, &mqc_states[15], &mqc_states[12]},
+	{0x5401, 0, &mqc_states[16], &mqc_states[28]},
+	{0x5401, 1, &mqc_states[17], &mqc_states[29]},
+	{0x4801, 0, &mqc_states[18], &mqc_states[28]},
+	{0x4801, 1, &mqc_states[19], &mqc_states[29]},
+	{0x3801, 0, &mqc_states[20], &mqc_states[28]},
+	{0x3801, 1, &mqc_states[21], &mqc_states[29]},
+	{0x3001, 0, &mqc_states[22], &mqc_states[34]},
+	{0x3001, 1, &mqc_states[23], &mqc_states[35]},
+	{0x2401, 0, &mqc_states[24], &mqc_states[36]},
+	{0x2401, 1, &mqc_states[25], &mqc_states[37]},
+	{0x1c01, 0, &mqc_states[26], &mqc_states[40]},
+	{0x1c01, 1, &mqc_states[27], &mqc_states[41]},
+	{0x1601, 0, &mqc_states[58], &mqc_states[42]},
+	{0x1601, 1, &mqc_states[59], &mqc_states[43]},
+	{0x5601, 0, &mqc_states[30], &mqc_states[29]},
+	{0x5601, 1, &mqc_states[31], &mqc_states[28]},
+	{0x5401, 0, &mqc_states[32], &mqc_states[28]},
+	{0x5401, 1, &mqc_states[33], &mqc_states[29]},
+	{0x5101, 0, &mqc_states[34], &mqc_states[30]},
+	{0x5101, 1, &mqc_states[35], &mqc_states[31]},
+	{0x4801, 0, &mqc_states[36], &mqc_states[32]},
+	{0x4801, 1, &mqc_states[37], &mqc_states[33]},
+	{0x3801, 0, &mqc_states[38], &mqc_states[34]},
+	{0x3801, 1, &mqc_states[39], &mqc_states[35]},
+	{0x3401, 0, &mqc_states[40], &mqc_states[36]},
+	{0x3401, 1, &mqc_states[41], &mqc_states[37]},
+	{0x3001, 0, &mqc_states[42], &mqc_states[38]},
+	{0x3001, 1, &mqc_states[43], &mqc_states[39]},
+	{0x2801, 0, &mqc_states[44], &mqc_states[38]},
+	{0x2801, 1, &mqc_states[45], &mqc_states[39]},
+	{0x2401, 0, &mqc_states[46], &mqc_states[40]},
+	{0x2401, 1, &mqc_states[47], &mqc_states[41]},
+	{0x2201, 0, &mqc_states[48], &mqc_states[42]},
+	{0x2201, 1, &mqc_states[49], &mqc_states[43]},
+	{0x1c01, 0, &mqc_states[50], &mqc_states[44]},
+	{0x1c01, 1, &mqc_states[51], &mqc_states[45]},
+	{0x1801, 0, &mqc_states[52], &mqc_states[46]},
+	{0x1801, 1, &mqc_states[53], &mqc_states[47]},
+	{0x1601, 0, &mqc_states[54], &mqc_states[48]},
+	{0x1601, 1, &mqc_states[55], &mqc_states[49]},
+	{0x1401, 0, &mqc_states[56], &mqc_states[50]},
+	{0x1401, 1, &mqc_states[57], &mqc_states[51]},
+	{0x1201, 0, &mqc_states[58], &mqc_states[52]},
+	{0x1201, 1, &mqc_states[59], &mqc_states[53]},
+	{0x1101, 0, &mqc_states[60], &mqc_states[54]},
+	{0x1101, 1, &mqc_states[61], &mqc_states[55]},
+	{0x0ac1, 0, &mqc_states[62], &mqc_states[56]},
+	{0x0ac1, 1, &mqc_states[63], &mqc_states[57]},
+	{0x09c1, 0, &mqc_states[64], &mqc_states[58]},
+	{0x09c1, 1, &mqc_states[65], &mqc_states[59]},
+	{0x08a1, 0, &mqc_states[66], &mqc_states[60]},
+	{0x08a1, 1, &mqc_states[67], &mqc_states[61]},
+	{0x0521, 0, &mqc_states[68], &mqc_states[62]},
+	{0x0521, 1, &mqc_states[69], &mqc_states[63]},
+	{0x0441, 0, &mqc_states[70], &mqc_states[64]},
+	{0x0441, 1, &mqc_states[71], &mqc_states[65]},
+	{0x02a1, 0, &mqc_states[72], &mqc_states[66]},
+	{0x02a1, 1, &mqc_states[73], &mqc_states[67]},
+	{0x0221, 0, &mqc_states[74], &mqc_states[68]},
+	{0x0221, 1, &mqc_states[75], &mqc_states[69]},
+	{0x0141, 0, &mqc_states[76], &mqc_states[70]},
+	{0x0141, 1, &mqc_states[77], &mqc_states[71]},
+	{0x0111, 0, &mqc_states[78], &mqc_states[72]},
+	{0x0111, 1, &mqc_states[79], &mqc_states[73]},
+	{0x0085, 0, &mqc_states[80], &mqc_states[74]},
+	{0x0085, 1, &mqc_states[81], &mqc_states[75]},
+	{0x0049, 0, &mqc_states[82], &mqc_states[76]},
+	{0x0049, 1, &mqc_states[83], &mqc_states[77]},
+	{0x0025, 0, &mqc_states[84], &mqc_states[78]},
+	{0x0025, 1, &mqc_states[85], &mqc_states[79]},
+	{0x0015, 0, &mqc_states[86], &mqc_states[80]},
+	{0x0015, 1, &mqc_states[87], &mqc_states[81]},
+	{0x0009, 0, &mqc_states[88], &mqc_states[82]},
+	{0x0009, 1, &mqc_states[89], &mqc_states[83]},
+	{0x0005, 0, &mqc_states[90], &mqc_states[84]},
+	{0x0005, 1, &mqc_states[91], &mqc_states[85]},
+	{0x0001, 0, &mqc_states[90], &mqc_states[86]},
+	{0x0001, 1, &mqc_states[91], &mqc_states[87]},
+	{0x5601, 0, &mqc_states[92], &mqc_states[92]},
+	{0x5601, 1, &mqc_states[93], &mqc_states[93]},
+};
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static void mqc_byteout(opj_mqc_t *mqc) {
+	if (*mqc->bp == 0xff) {
+		mqc->bp++;
+		*mqc->bp = mqc->c >> 20;
+		mqc->c &= 0xfffff;
+		mqc->ct = 7;
+	} else {
+		if ((mqc->c & 0x8000000) == 0) {	/* ((mqc->c&0x8000000)==0) CHANGE */
+			mqc->bp++;
+			*mqc->bp = mqc->c >> 19;
+			mqc->c &= 0x7ffff;
+			mqc->ct = 8;
+		} else {
+			(*mqc->bp)++;
+			if (*mqc->bp == 0xff) {
+				mqc->c &= 0x7ffffff;
+				mqc->bp++;
+				*mqc->bp = mqc->c >> 20;
+				mqc->c &= 0xfffff;
+				mqc->ct = 7;
+			} else {
+				mqc->bp++;
+				*mqc->bp = mqc->c >> 19;
+				mqc->c &= 0x7ffff;
+				mqc->ct = 8;
+			}
+		}
+	}
+}
+
+static void mqc_renorme(opj_mqc_t *mqc) {
+	do {
+		mqc->a <<= 1;
+		mqc->c <<= 1;
+		mqc->ct--;
+		if (mqc->ct == 0) {
+			mqc_byteout(mqc);
+		}
+	} while ((mqc->a & 0x8000) == 0);
+}
+
+static void mqc_codemps(opj_mqc_t *mqc) {
+	mqc->a -= (*mqc->curctx)->qeval;
+	if ((mqc->a & 0x8000) == 0) {
+		if (mqc->a < (*mqc->curctx)->qeval) {
+			mqc->a = (*mqc->curctx)->qeval;
+		} else {
+			mqc->c += (*mqc->curctx)->qeval;
+		}
+		*mqc->curctx = (*mqc->curctx)->nmps;
+		mqc_renorme(mqc);
+	} else {
+		mqc->c += (*mqc->curctx)->qeval;
+	}
+}
+
+static void mqc_codelps(opj_mqc_t *mqc) {
+	mqc->a -= (*mqc->curctx)->qeval;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		mqc->c += (*mqc->curctx)->qeval;
+	} else {
+		mqc->a = (*mqc->curctx)->qeval;
+	}
+	*mqc->curctx = (*mqc->curctx)->nlps;
+	mqc_renorme(mqc);
+}
+
+static void mqc_setbits(opj_mqc_t *mqc) {
+	unsigned int tempc = mqc->c + mqc->a;
+	mqc->c |= 0xffff;
+	if (mqc->c >= tempc) {
+		mqc->c -= 0x8000;
+	}
+}
+
+static int mqc_mpsexchange(opj_mqc_t *mqc) {
+	int d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		d = 1 - (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	} else {
+		d = (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	}
+	
+	return d;
+}
+
+static int mqc_lpsexchange(opj_mqc_t *mqc) {
+	int d;
+	if (mqc->a < (*mqc->curctx)->qeval) {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nmps;
+	} else {
+		mqc->a = (*mqc->curctx)->qeval;
+		d = 1 - (*mqc->curctx)->mps;
+		*mqc->curctx = (*mqc->curctx)->nlps;
+	}
+	
+	return d;
+}
+
+static void mqc_bytein(opj_mqc_t *mqc) {
+	if (mqc->bp != mqc->end) {
+		unsigned int c;
+		if (mqc->bp + 1 != mqc->end) {
+			c = *(mqc->bp + 1);
+		} else {
+			c = 0xff;
+		}
+		if (*mqc->bp == 0xff) {
+			if (c > 0x8f) {
+				mqc->c += 0xff00;
+				mqc->ct = 8;
+			} else {
+				mqc->bp++;
+				mqc->c += c << 9;
+				mqc->ct = 7;
+			}
+		} else {
+			mqc->bp++;
+			mqc->c += c << 8;
+			mqc->ct = 8;
+		}
+	} else {
+		mqc->c += 0xff00;
+		mqc->ct = 8;
+	}
+}
+
+static void mqc_renormd(opj_mqc_t *mqc) {
+	do {
+		if (mqc->ct == 0) {
+			mqc_bytein(mqc);
+		}
+		mqc->a <<= 1;
+		mqc->c <<= 1;
+		mqc->ct--;
+	} while (mqc->a < 0x8000);
+}
+
+/* 
+==========================================================
+   MQ-Coder interface
+==========================================================
+*/
+
+opj_mqc_t* mqc_create(void) {
+	opj_mqc_t *mqc = (opj_mqc_t*)opj_malloc(sizeof(opj_mqc_t));
+	return mqc;
+}
+
+void mqc_destroy(opj_mqc_t *mqc) {
+	if(mqc) {
+		opj_free(mqc);
+	}
+}
+
+int mqc_numbytes(opj_mqc_t *mqc) {
+	return mqc->bp - mqc->start;
+}
+
+void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp) {
+	mqc_setcurctx(mqc, 0);
+	mqc->a = 0x8000;
+	mqc->c = 0;
+	mqc->bp = bp - 1;
+	mqc->ct = 12;
+	if (*mqc->bp == 0xff) {
+		mqc->ct = 13;
+	}
+	mqc->start = bp;
+}
+
+void mqc_encode(opj_mqc_t *mqc, int d) {
+	if ((*mqc->curctx)->mps == d) {
+		mqc_codemps(mqc);
+	} else {
+		mqc_codelps(mqc);
+	}
+}
+
+void mqc_flush(opj_mqc_t *mqc) {
+	mqc_setbits(mqc);
+	mqc->c <<= mqc->ct;
+	mqc_byteout(mqc);
+	mqc->c <<= mqc->ct;
+	mqc_byteout(mqc);
+	
+	if (*mqc->bp != 0xff) {
+		mqc->bp++;
+	}
+}
+
+void mqc_bypass_init_enc(opj_mqc_t *mqc) {
+	mqc->c = 0;
+	mqc->ct = 8;
+	/*if (*mqc->bp == 0xff) {
+	mqc->ct = 7;
+     } */
+}
+
+void mqc_bypass_enc(opj_mqc_t *mqc, int d) {
+	mqc->ct--;
+	mqc->c = mqc->c + (d << mqc->ct);
+	if (mqc->ct == 0) {
+		mqc->bp++;
+		*mqc->bp = mqc->c;
+		mqc->ct = 8;
+		if (*mqc->bp == 0xff) {
+			mqc->ct = 7;
+		}
+		mqc->c = 0;
+	}
+}
+
+int mqc_bypass_flush_enc(opj_mqc_t *mqc) {
+	unsigned char bit_padding;
+	
+	bit_padding = 0;
+	
+	if (mqc->ct != 0) {
+		while (mqc->ct > 0) {
+			mqc->ct--;
+			mqc->c += bit_padding << mqc->ct;
+			bit_padding = (bit_padding + 1) & 0x01;
+		}
+		mqc->bp++;
+		*mqc->bp = mqc->c;
+		mqc->ct = 8;
+		mqc->c = 0;
+	}
+	
+	return 1;
+}
+
+void mqc_reset_enc(opj_mqc_t *mqc) {
+	mqc_resetstates(mqc);
+	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+}
+
+int mqc_restart_enc(opj_mqc_t *mqc) {
+	int correction = 1;
+	
+	/* <flush part> */
+	int n = 27 - 15 - mqc->ct;
+	mqc->c <<= mqc->ct;
+	while (n > 0) {
+		mqc_byteout(mqc);
+		n -= mqc->ct;
+		mqc->c <<= mqc->ct;
+	}
+	mqc_byteout(mqc);
+	
+	return correction;
+}
+
+void mqc_restart_init_enc(opj_mqc_t *mqc) {
+	/* <Re-init part> */
+	mqc_setcurctx(mqc, 0);
+	mqc->a = 0x8000;
+	mqc->c = 0;
+	mqc->ct = 12;
+	mqc->bp--;
+	if (*mqc->bp == 0xff) {
+		mqc->ct = 13;
+	}
+}
+
+void mqc_erterm_enc(opj_mqc_t *mqc) {
+	int k = 11 - mqc->ct + 1;
+	
+	while (k > 0) {
+		mqc->c <<= mqc->ct;
+		mqc->ct = 0;
+		mqc_byteout(mqc);
+		k -= mqc->ct;
+	}
+	
+	if (*mqc->bp != 0xff) {
+		mqc_byteout(mqc);
+	}
+}
+
+void mqc_segmark_enc(opj_mqc_t *mqc) {
+	int i;
+	mqc_setcurctx(mqc, 18);
+	
+	for (i = 1; i < 5; i++) {
+		mqc_encode(mqc, i % 2);
+	}
+}
+
+void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len) {
+	mqc_setcurctx(mqc, 0);
+	mqc->start = bp;
+	mqc->end = bp + len;
+	mqc->bp = bp;
+	if (len==0) mqc->c = 0xff << 16;
+	else mqc->c = *mqc->bp << 16;
+	mqc_bytein(mqc);
+	mqc->c <<= 7;
+	mqc->ct -= 7;
+	mqc->a = 0x8000;
+}
+
+int mqc_decode(opj_mqc_t *mqc) {
+	int d;
+	mqc->a -= (*mqc->curctx)->qeval;
+	if ((mqc->c >> 16) < (*mqc->curctx)->qeval) {
+		d = mqc_lpsexchange(mqc);
+		mqc_renormd(mqc);
+	} else {
+		mqc->c -= (*mqc->curctx)->qeval << 16;
+		if ((mqc->a & 0x8000) == 0) {
+			d = mqc_mpsexchange(mqc);
+			mqc_renormd(mqc);
+		} else {
+			d = (*mqc->curctx)->mps;
+		}
+	}
+
+	return d;
+}
+
+void mqc_resetstates(opj_mqc_t *mqc) {
+	int i;
+	for (i = 0; i < MQC_NUMCTXS; i++) {
+		mqc->ctxs[i] = mqc_states;
+	}
+}
+
+void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob) {
+	mqc->ctxs[ctxno] = &mqc_states[msb + (prob << 1)];
+}
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mqc.h.svn-base ./libopenjpeg/.svn/text-base/mqc.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/mqc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/mqc.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,197 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MQC_H
+#define __MQC_H
+/**
+@file mqc.h
+@brief Implementation of an MQ-Coder (MQC)
+
+The functions in MQC.C have for goal to realize the MQ-coder operations. The functions
+in MQC.C are used by some function in T1.C.
+*/
+
+/** @defgroup MQC MQC - Implementation of an MQ-Coder */
+/*@{*/
+
+/**
+This struct defines the state of a context.
+*/
+typedef struct opj_mqc_state {
+	/** the probability of the Least Probable Symbol (0.75->0x8000, 1.5->0xffff) */
+	unsigned int qeval;
+	/** the Most Probable Symbol (0 or 1) */
+	int mps;
+	/** next state if the next encoded symbol is the MPS */
+	struct opj_mqc_state *nmps;
+	/** next state if the next encoded symbol is the LPS */
+	struct opj_mqc_state *nlps;
+} opj_mqc_state_t;
+
+#define MQC_NUMCTXS 32
+
+/**
+MQ coder
+*/
+typedef struct opj_mqc {
+	unsigned int c;
+	unsigned int a;
+	unsigned int ct;
+	unsigned char *bp;
+	unsigned char *start;
+	unsigned char *end;
+	opj_mqc_state_t *ctxs[MQC_NUMCTXS];
+	opj_mqc_state_t **curctx;
+} opj_mqc_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new MQC handle 
+@return Returns a new MQC handle if successful, returns NULL otherwise
+*/
+opj_mqc_t* mqc_create(void);
+/**
+Destroy a previously created MQC handle
+@param mqc MQC handle to destroy
+*/
+void mqc_destroy(opj_mqc_t *mqc);
+/**
+Return the number of bytes written/read since initialisation
+@param mqc MQC handle
+@return Returns the number of bytes already encoded
+*/
+int mqc_numbytes(opj_mqc_t *mqc);
+/**
+Reset the states of all the context of the coder/decoder 
+(each context is set to a state where 0 and 1 are more or less equiprobable)
+@param mqc MQC handle
+*/
+void mqc_resetstates(opj_mqc_t *mqc);
+/**
+Set the state of a particular context
+@param mqc MQC handle
+@param ctxno Number that identifies the context
+@param msb The MSB of the new state of the context
+@param prob Number that identifies the probability of the symbols for the new state of the context
+*/
+void mqc_setstate(opj_mqc_t *mqc, int ctxno, int msb, int prob);
+/**
+Initialize the encoder
+@param mqc MQC handle
+@param bp Pointer to the start of the buffer where the bytes will be written
+*/
+void mqc_init_enc(opj_mqc_t *mqc, unsigned char *bp);
+/**
+Set the current context used for coding/decoding
+@param mqc MQC handle
+@param ctxno Number that identifies the context
+*/
+#define mqc_setcurctx(mqc, ctxno)	(mqc)->curctx = &(mqc)->ctxs[(int)(ctxno)]
+/**
+Encode a symbol using the MQ-coder
+@param mqc MQC handle
+@param d The symbol to be encoded (0 or 1)
+*/
+void mqc_encode(opj_mqc_t *mqc, int d);
+/**
+Flush the encoder, so that all remaining data is written
+@param mqc MQC handle
+*/
+void mqc_flush(opj_mqc_t *mqc);
+/**
+BYPASS mode switch, initialization operation. 
+JPEG 2000 p 505. 
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+*/
+void mqc_bypass_init_enc(opj_mqc_t *mqc);
+/**
+BYPASS mode switch, coding operation. 
+JPEG 2000 p 505. 
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+@param d The symbol to be encoded (0 or 1)
+*/
+void mqc_bypass_enc(opj_mqc_t *mqc, int d);
+/**
+BYPASS mode switch, flush operation
+<h2>Not fully implemented and tested !!</h2>
+@param mqc MQC handle
+@return Returns 1 (always)
+*/
+int mqc_bypass_flush_enc(opj_mqc_t *mqc);
+/**
+RESET mode switch
+@param mqc MQC handle
+*/
+void mqc_reset_enc(opj_mqc_t *mqc);
+/**
+RESTART mode switch (TERMALL)
+@param mqc MQC handle
+@return Returns 1 (always)
+*/
+int mqc_restart_enc(opj_mqc_t *mqc);
+/**
+RESTART mode switch (TERMALL) reinitialisation
+@param mqc MQC handle
+*/
+void mqc_restart_init_enc(opj_mqc_t *mqc);
+/**
+ERTERM mode switch (PTERM)
+@param mqc MQC handle
+*/
+void mqc_erterm_enc(opj_mqc_t *mqc);
+/**
+SEGMARK mode switch (SEGSYM)
+@param mqc MQC handle
+*/
+void mqc_segmark_enc(opj_mqc_t *mqc);
+/**
+Initialize the decoder
+@param mqc MQC handle
+@param bp Pointer to the start of the buffer from which the bytes will be read
+@param len Length of the input buffer
+*/
+void mqc_init_dec(opj_mqc_t *mqc, unsigned char *bp, int len);
+/**
+Decode a symbol
+@param mqc MQC handle
+@return Returns the decoded symbol (0 or 1)
+*/
+int mqc_decode(opj_mqc_t *mqc);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __MQC_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/openjpeg.c.svn-base ./libopenjpeg/.svn/text-base/openjpeg.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/openjpeg.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/openjpeg.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,329 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifdef WIN32
+#include <windows.h>
+#endif /* WIN32 */
+
+#include "opj_includes.h"
+
+/* ---------------------------------------------------------------------- */
+#ifdef WIN32
+#ifndef OPJ_STATIC
+BOOL APIENTRY
+DllMain(HANDLE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
+	switch (ul_reason_for_call) {
+		case DLL_PROCESS_ATTACH :
+			break;
+		case DLL_PROCESS_DETACH :
+			break;
+		case DLL_THREAD_ATTACH :
+		case DLL_THREAD_DETACH :
+			break;
+    }
+
+    return TRUE;
+}
+#endif /* OPJ_STATIC */
+#endif /* WIN32 */
+
+/* ---------------------------------------------------------------------- */
+
+
+const char* OPJ_CALLCONV opj_version(void) {
+    return OPENJPEG_VERSION;
+}
+
+opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format) {
+	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_malloc(sizeof(opj_dinfo_t));
+	if(!dinfo) return NULL;
+	dinfo->is_decompressor = true;
+	switch(format) {
+		case CODEC_J2K:
+		case CODEC_JPT:
+			/* get a J2K decoder handle */
+			dinfo->j2k_handle = (void*)j2k_create_decompress((opj_common_ptr)dinfo);
+			if(!dinfo->j2k_handle) {
+				opj_free(dinfo);
+				return NULL;
+			}
+			break;
+		case CODEC_JP2:
+			/* get a JP2 decoder handle */
+			dinfo->jp2_handle = (void*)jp2_create_decompress((opj_common_ptr)dinfo);
+			if(!dinfo->jp2_handle) {
+				opj_free(dinfo);
+				return NULL;
+			}
+			break;
+		case CODEC_UNKNOWN:
+		default:
+			opj_free(dinfo);
+			return NULL;
+	}
+
+	dinfo->codec_format = format;
+
+	return dinfo;
+}
+
+void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo) {
+	if(dinfo) {
+		/* destroy the codec */
+		switch(dinfo->codec_format) {
+			case CODEC_J2K:
+			case CODEC_JPT:
+				j2k_destroy_decompress((opj_j2k_t*)dinfo->j2k_handle);
+				break;
+			case CODEC_JP2:
+				jp2_destroy_decompress((opj_jp2_t*)dinfo->jp2_handle);
+				break;
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+		/* destroy the decompressor */
+		opj_free(dinfo);
+	}
+}
+
+void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters) {
+	if(parameters) {
+		memset(parameters, 0, sizeof(opj_dparameters_t));
+		/* default decoding parameters */
+		parameters->cp_layer = 0;
+		parameters->cp_reduce = 0;
+		parameters->cp_limit_decoding = NO_LIMITATION;
+
+		parameters->decod_format = -1;
+		parameters->cod_format = -1;
+/* UniPG>> */
+#ifdef USE_JPWL
+		parameters->jpwl_correct = false;
+		parameters->jpwl_exp_comps = JPWL_EXPECTED_COMPONENTS;
+		parameters->jpwl_max_tiles = JPWL_MAXIMUM_TILES;
+#endif /* USE_JPWL */
+/* <<UniPG */
+	}
+}
+
+void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters) {
+	if(dinfo && parameters) {
+		switch(dinfo->codec_format) {
+			case CODEC_J2K:
+			case CODEC_JPT:
+				j2k_setup_decoder((opj_j2k_t*)dinfo->j2k_handle, parameters);
+				break;
+			case CODEC_JP2:
+				jp2_setup_decoder((opj_jp2_t*)dinfo->jp2_handle, parameters);
+				break;
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+	}
+}
+
+opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio) {
+	return opj_decode_with_info(dinfo, cio, NULL);
+}
+
+opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info) {
+	if(dinfo && cio) {
+		switch(dinfo->codec_format) {
+			case CODEC_J2K:
+				return j2k_decode((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
+			case CODEC_JPT:
+				return j2k_decode_jpt_stream((opj_j2k_t*)dinfo->j2k_handle, cio, cstr_info);
+			case CODEC_JP2:
+				return jp2_decode((opj_jp2_t*)dinfo->jp2_handle, cio, cstr_info);
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+	}
+	return NULL;
+}
+
+opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format) {
+	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_malloc(sizeof(opj_cinfo_t));
+	if(!cinfo) return NULL;
+	cinfo->is_decompressor = false;
+	switch(format) {
+		case CODEC_J2K:
+			/* get a J2K coder handle */
+			cinfo->j2k_handle = (void*)j2k_create_compress((opj_common_ptr)cinfo);
+			if(!cinfo->j2k_handle) {
+				opj_free(cinfo);
+				return NULL;
+			}
+			break;
+		case CODEC_JP2:
+			/* get a JP2 coder handle */
+			cinfo->jp2_handle = (void*)jp2_create_compress((opj_common_ptr)cinfo);
+			if(!cinfo->jp2_handle) {
+				opj_free(cinfo);
+				return NULL;
+			}
+			break;
+		case CODEC_JPT:
+		case CODEC_UNKNOWN:
+		default:
+			opj_free(cinfo);
+			return NULL;
+	}
+
+	cinfo->codec_format = format;
+
+	return cinfo;
+}
+
+void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo) {
+	if(cinfo) {
+		/* destroy the codec */
+		switch(cinfo->codec_format) {
+			case CODEC_J2K:
+				j2k_destroy_compress((opj_j2k_t*)cinfo->j2k_handle);
+				break;
+			case CODEC_JP2:
+				jp2_destroy_compress((opj_jp2_t*)cinfo->jp2_handle);
+				break;
+			case CODEC_JPT:
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+		/* destroy the decompressor */
+		opj_free(cinfo);
+	}
+}
+
+void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters) {
+	if(parameters) {
+		memset(parameters, 0, sizeof(opj_cparameters_t));
+		/* default coding parameters */
+		parameters->cp_cinema = OFF; 
+		parameters->max_comp_size = 0;
+		parameters->numresolution = 6;
+		parameters->cp_rsiz = STD_RSIZ;
+		parameters->cblockw_init = 64;
+		parameters->cblockh_init = 64;
+		parameters->prog_order = LRCP;
+		parameters->roi_compno = -1;		/* no ROI */
+		parameters->subsampling_dx = 1;
+		parameters->subsampling_dy = 1;
+		parameters->tp_on = 0;
+		parameters->decod_format = -1;
+		parameters->cod_format = -1;
+/* UniPG>> */
+#ifdef USE_JPWL
+		parameters->jpwl_epc_on = false;
+		parameters->jpwl_hprot_MH = -1; /* -1 means unassigned */
+		{
+			int i;
+			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+				parameters->jpwl_hprot_TPH_tileno[i] = -1; /* unassigned */
+				parameters->jpwl_hprot_TPH[i] = 0; /* absent */
+			}
+		};
+		{
+			int i;
+			for (i = 0; i < JPWL_MAX_NO_PACKSPECS; i++) {
+				parameters->jpwl_pprot_tileno[i] = -1; /* unassigned */
+				parameters->jpwl_pprot_packno[i] = -1; /* unassigned */
+				parameters->jpwl_pprot[i] = 0; /* absent */
+			}
+		};
+		parameters->jpwl_sens_size = 0; /* 0 means no ESD */
+		parameters->jpwl_sens_addr = 0; /* 0 means auto */
+		parameters->jpwl_sens_range = 0; /* 0 means packet */
+		parameters->jpwl_sens_MH = -1; /* -1 means unassigned */
+		{
+			int i;
+			for (i = 0; i < JPWL_MAX_NO_TILESPECS; i++) {
+				parameters->jpwl_sens_TPH_tileno[i] = -1; /* unassigned */
+				parameters->jpwl_sens_TPH[i] = -1; /* absent */
+			}
+		};
+#endif /* USE_JPWL */
+/* <<UniPG */
+	}
+}
+
+void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image) {
+	if(cinfo && parameters && image) {
+		switch(cinfo->codec_format) {
+			case CODEC_J2K:
+				j2k_setup_encoder((opj_j2k_t*)cinfo->j2k_handle, parameters, image);
+				break;
+			case CODEC_JP2:
+				jp2_setup_encoder((opj_jp2_t*)cinfo->jp2_handle, parameters, image);
+				break;
+			case CODEC_JPT:
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+	}
+}
+
+bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index) {
+	if (index != NULL)
+		opj_event_msg((opj_common_ptr)cinfo, EVT_WARNING, "Set index to NULL when calling the opj_encode function.\n"
+		"To extract the index, use the opj_encode_with_info() function.\n"
+		"No index will be generated during this encoding\n");
+	return opj_encode_with_info(cinfo, cio, image, NULL);
+}
+
+bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info) {
+	if(cinfo && cio && image) {
+		switch(cinfo->codec_format) {
+			case CODEC_J2K:
+				return j2k_encode((opj_j2k_t*)cinfo->j2k_handle, cio, image, cstr_info);
+			case CODEC_JP2:
+				return jp2_encode((opj_jp2_t*)cinfo->jp2_handle, cio, image, cstr_info);
+			case CODEC_JPT:
+			case CODEC_UNKNOWN:
+			default:
+				break;
+		}
+	}
+	return false;
+}
+
+void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info) {
+	if (cstr_info) {
+		int tileno;
+		for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+			opj_tile_info_t *tile_info = &cstr_info->tile[tileno];
+			opj_free(tile_info->thresh);
+			opj_free(tile_info->packet);
+			opj_free(tile_info->tp);
+		}
+		opj_free(cstr_info->tile);
+		opj_free(cstr_info->marker);
+	}
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/openjpeg.h.svn-base ./libopenjpeg/.svn/text-base/openjpeg.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/openjpeg.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/openjpeg.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,911 @@
+ /*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPENJPEG_H
+#define OPENJPEG_H
+
+#define OPENJPEG_VERSION "1.2.0"
+
+/* 
+==========================================================
+   Compiler directives
+==========================================================
+*/
+
+#if defined(OPJ_STATIC) || !(defined(WIN32) || defined(__WIN32__))
+#define OPJ_API
+#define OPJ_CALLCONV
+#else
+#define OPJ_CALLCONV __stdcall
+/*
+The following ifdef block is the standard way of creating macros which make exporting 
+from a DLL simpler. All files within this DLL are compiled with the OPJ_EXPORTS
+symbol defined on the command line. this symbol should not be defined on any project
+that uses this DLL. This way any other project whose source files include this file see 
+OPJ_API functions as being imported from a DLL, wheras this DLL sees symbols
+defined with this macro as being exported.
+*/
+#ifdef OPJ_EXPORTS
+#define OPJ_API __declspec(dllexport)
+#else
+#define OPJ_API __declspec(dllimport)
+#endif /* OPJ_EXPORTS */
+#endif /* !OPJ_STATIC || !WIN32 */
+
+#ifndef __cplusplus
+#if defined(HAVE_STDBOOL_H)
+/*
+The C language implementation does correctly provide the standard header
+file "stdbool.h".
+ */
+#include <stdbool.h>
+#else
+/*
+The C language implementation does not provide the standard header file
+"stdbool.h" as required by ISO/IEC 9899:1999.  Try to compensate for this
+braindamage below.
+*/
+#if !defined(bool)
+#define	bool	int
+#endif
+#if !defined(true)
+#define true	1
+#endif
+#if !defined(false)
+#define	false	0
+#endif
+#endif
+#endif /* __cplusplus */
+
+/* 
+==========================================================
+   Useful constant definitions
+==========================================================
+*/
+
+#define OPJ_PATH_LEN 4096 /**< Maximum allowed size for filenames */
+
+#define J2K_MAXRLVLS 33					/**< Number of maximum resolution level authorized */
+#define J2K_MAXBANDS (3*J2K_MAXRLVLS-2)	/**< Number of maximum sub-band linked to number of resolution level */
+
+/* UniPG>> */
+#define JPWL_MAX_NO_TILESPECS	16 /**< Maximum number of tile parts expected by JPWL: increase at your will */
+#define JPWL_MAX_NO_PACKSPECS	16 /**< Maximum number of packet parts expected by JPWL: increase at your will */
+#define JPWL_MAX_NO_MARKERS	512 /**< Maximum number of JPWL markers: increase at your will */
+#define JPWL_PRIVATEINDEX_NAME "jpwl_index_privatefilename" /**< index file name used when JPWL is on */
+#define JPWL_EXPECTED_COMPONENTS 3 /**< Expect this number of components, so you'll find better the first EPB */
+#define JPWL_MAXIMUM_TILES 8192 /**< Expect this maximum number of tiles, to avoid some crashes */
+#define JPWL_MAXIMUM_HAMMING 2 /**< Expect this maximum number of bit errors in marker id's */
+#define JPWL_MAXIMUM_EPB_ROOM 65450 /**< Expect this maximum number of bytes for composition of EPBs */
+/* <<UniPG */
+
+/* 
+==========================================================
+   enum definitions
+==========================================================
+*/
+/** 
+Rsiz Capabilities
+*/
+typedef enum RSIZ_CAPABILITIES {
+	STD_RSIZ = 0,		/** Standard JPEG2000 profile*/
+	CINEMA2K = 3,		/** Profile name for a 2K image*/
+	CINEMA4K = 4		/** Profile name for a 4K image*/
+} OPJ_RSIZ_CAPABILITIES;
+
+/** 
+Digital cinema operation mode 
+*/
+typedef enum CINEMA_MODE {
+	OFF = 0,					/** Not Digital Cinema*/
+	CINEMA2K_24 = 1,	/** 2K Digital Cinema at 24 fps*/
+	CINEMA2K_48 = 2,	/** 2K Digital Cinema at 48 fps*/
+	CINEMA4K_24 = 3		/** 4K Digital Cinema at 24 fps*/
+}OPJ_CINEMA_MODE;
+
+/** 
+Progression order 
+*/
+typedef enum PROG_ORDER {
+	PROG_UNKNOWN = -1,	/**< place-holder */
+	LRCP = 0,		/**< layer-resolution-component-precinct order */
+	RLCP = 1,		/**< resolution-layer-component-precinct order */
+	RPCL = 2,		/**< resolution-precinct-component-layer order */
+	PCRL = 3,		/**< precinct-component-resolution-layer order */
+	CPRL = 4		/**< component-precinct-resolution-layer order */
+} OPJ_PROG_ORDER;
+
+/**
+Supported image color spaces
+*/
+typedef enum COLOR_SPACE {
+	CLRSPC_UNKNOWN = -1,	/**< place-holder */
+	CLRSPC_SRGB = 1,		/**< sRGB */
+	CLRSPC_GRAY = 2,		/**< grayscale */
+	CLRSPC_SYCC = 3			/**< YUV */
+} OPJ_COLOR_SPACE;
+
+/**
+Supported codec
+*/
+typedef enum CODEC_FORMAT {
+	CODEC_UNKNOWN = -1,	/**< place-holder */
+	CODEC_J2K = 0,		/**< JPEG-2000 codestream : read/write */
+	CODEC_JPT = 1,		/**< JPT-stream (JPEG 2000, JPIP) : read only */
+	CODEC_JP2 = 2		/**< JPEG-2000 file format : read/write */
+} OPJ_CODEC_FORMAT;
+
+/** 
+Limit decoding to certain portions of the codestream. 
+*/
+typedef enum LIMIT_DECODING {
+	NO_LIMITATION = 0,				  /**< No limitation for the decoding. The entire codestream will de decoded */
+	LIMIT_TO_MAIN_HEADER = 1,		/**< The decoding is limited to the Main Header */
+	DECODE_ALL_BUT_PACKETS = 2	/**< Decode everything except the JPEG 2000 packets */
+} OPJ_LIMIT_DECODING;
+
+/* 
+==========================================================
+   event manager typedef definitions
+==========================================================
+*/
+
+/**
+Callback function prototype for events
+@param msg Event message
+@param client_data 
+*/
+typedef void (*opj_msg_callback) (const char *msg, void *client_data);
+
+/**
+Message handler object
+used for 
+<ul>
+<li>Error messages
+<li>Warning messages
+<li>Debugging messages
+</ul>
+*/
+typedef struct opj_event_mgr {
+	/** Error message callback if available, NULL otherwise */
+	opj_msg_callback error_handler;
+	/** Warning message callback if available, NULL otherwise */
+	opj_msg_callback warning_handler;
+	/** Debug message callback if available, NULL otherwise */
+	opj_msg_callback info_handler;
+} opj_event_mgr_t;
+
+
+/* 
+==========================================================
+   codec typedef definitions
+==========================================================
+*/
+
+/**
+Progression order changes
+*/
+typedef struct opj_poc {
+	/** Resolution num start, Component num start, given by POC */
+	int resno0, compno0;
+	/** Layer num end,Resolution num end, Component num end, given by POC */
+	int layno1, resno1, compno1;
+	/** Layer num start,Precinct num start, Precinct num end */
+	int layno0, precno0, precno1;
+	/** Progression order enum*/
+	OPJ_PROG_ORDER prg1,prg;
+	/** Progression order string*/
+	char progorder[5];
+	/** Tile number */
+	int tile;
+	/** Start and end values for Tile width and height*/
+	int tx0,tx1,ty0,ty1;
+	/** Start value, initialised in pi_initialise_encode*/
+	int layS, resS, compS, prcS;
+	/** End value, initialised in pi_initialise_encode */
+	int layE, resE, compE, prcE;
+	/** Start and end values of Tile width and height, initialised in pi_initialise_encode*/
+	int txS,txE,tyS,tyE,dx,dy;
+	/** Temporary values for Tile parts, initialised in pi_create_encode */
+	int lay_t, res_t, comp_t, prc_t,tx0_t,ty0_t;
+} opj_poc_t;
+
+/**
+Compression parameters
+*/
+typedef struct opj_cparameters {
+	/** size of tile: tile_size_on = false (not in argument) or = true (in argument) */
+	bool tile_size_on;
+	/** XTOsiz */
+	int cp_tx0;
+	/** YTOsiz */
+	int cp_ty0;
+	/** XTsiz */
+	int cp_tdx;
+	/** YTsiz */
+	int cp_tdy;
+	/** allocation by rate/distortion */
+	int cp_disto_alloc;
+	/** allocation by fixed layer */
+	int cp_fixed_alloc;
+	/** add fixed_quality */
+	int cp_fixed_quality;
+	/** fixed layer */
+	int *cp_matrice;
+	/** comment for coding */
+	char *cp_comment;
+	/** csty : coding style */
+	int csty;
+	/** progression order (default LRCP) */
+	OPJ_PROG_ORDER prog_order;
+	/** progression order changes */
+	opj_poc_t POC[32];
+	/** number of progression order changes (POC), default to 0 */
+	int numpocs;
+	/** number of layers */
+	int tcp_numlayers;
+	/** rates of layers */
+	float tcp_rates[100];
+	/** different psnr for successive layers */
+	float tcp_distoratio[100];
+	/** number of resolutions */
+	int numresolution;
+	/** initial code block width, default to 64 */
+ 	int cblockw_init;
+	/** initial code block height, default to 64 */
+	int cblockh_init;
+	/** mode switch (cblk_style) */
+	int mode;
+	/** 1 : use the irreversible DWT 9-7, 0 : use lossless compression (default) */
+	int irreversible;
+	/** region of interest: affected component in [0..3], -1 means no ROI */
+	int roi_compno;
+	/** region of interest: upshift value */
+	int roi_shift;
+	/* number of precinct size specifications */
+	int res_spec;
+	/** initial precinct width */
+	int prcw_init[J2K_MAXRLVLS];
+	/** initial precinct height */
+	int prch_init[J2K_MAXRLVLS];
+
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+	/** input file name */
+	char infile[OPJ_PATH_LEN];
+	/** output file name */
+	char outfile[OPJ_PATH_LEN];
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
+	int index_on;
+	/** DEPRECATED. Index generation is now handeld with the opj_encode_with_info() function. Set to NULL */
+	char index[OPJ_PATH_LEN];
+	/** subimage encoding: origin image offset in x direction */
+	int image_offset_x0;
+	/** subimage encoding: origin image offset in y direction */
+	int image_offset_y0;
+	/** subsampling value for dx */
+	int subsampling_dx;
+	/** subsampling value for dy */
+	int subsampling_dy;
+	/** input file format 0: PGX, 1: PxM, 2: BMP 3:TIF*/
+	int decod_format;
+	/** output file format 0: J2K, 1: JP2, 2: JPT */
+	int cod_format;
+	/*@}*/
+
+/* UniPG>> */
+	/**@name JPWL encoding parameters */
+	/*@{*/
+	/** enables writing of EPC in MH, thus activating JPWL */
+	bool jpwl_epc_on;
+	/** error protection method for MH (0,1,16,32,37-128) */
+	int jpwl_hprot_MH;
+	/** tile number of header protection specification (>=0) */
+	int jpwl_hprot_TPH_tileno[JPWL_MAX_NO_TILESPECS];
+	/** error protection methods for TPHs (0,1,16,32,37-128) */
+	int jpwl_hprot_TPH[JPWL_MAX_NO_TILESPECS];
+	/** tile number of packet protection specification (>=0) */
+	int jpwl_pprot_tileno[JPWL_MAX_NO_PACKSPECS];
+	/** packet number of packet protection specification (>=0) */
+	int jpwl_pprot_packno[JPWL_MAX_NO_PACKSPECS];
+	/** error protection methods for packets (0,1,16,32,37-128) */
+	int jpwl_pprot[JPWL_MAX_NO_PACKSPECS];
+	/** enables writing of ESD, (0=no/1/2 bytes) */
+	int jpwl_sens_size;
+	/** sensitivity addressing size (0=auto/2/4 bytes) */
+	int jpwl_sens_addr;
+	/** sensitivity range (0-3) */
+	int jpwl_sens_range;
+	/** sensitivity method for MH (-1=no,0-7) */
+	int jpwl_sens_MH;
+	/** tile number of sensitivity specification (>=0) */
+	int jpwl_sens_TPH_tileno[JPWL_MAX_NO_TILESPECS];
+	/** sensitivity methods for TPHs (-1=no,0-7) */
+	int jpwl_sens_TPH[JPWL_MAX_NO_TILESPECS];
+	/*@}*/
+/* <<UniPG */
+
+	/** Digital Cinema compliance 0-not compliant, 1-compliant*/
+	OPJ_CINEMA_MODE cp_cinema;
+	/** Maximum rate for each component. If == 0, component size limitation is not considered */
+	int max_comp_size;
+	/** Profile name*/
+	OPJ_RSIZ_CAPABILITIES cp_rsiz;
+	/** Tile part generation*/
+	char tp_on;
+	/** Flag for Tile part generation*/
+	char tp_flag;
+	/** MCT (multiple component transform) */
+	char tcp_mct;
+} opj_cparameters_t;
+
+/**
+Decompression parameters
+*/
+typedef struct opj_dparameters {
+	/** 
+	Set the number of highest resolution levels to be discarded. 
+	The image resolution is effectively divided by 2 to the power of the number of discarded levels. 
+	The reduce factor is limited by the smallest total number of decomposition levels among tiles.
+	if != 0, then original dimension divided by 2^(reduce); 
+	if == 0 or not used, image is decoded to the full resolution 
+	*/
+	int cp_reduce;
+	/** 
+	Set the maximum number of quality layers to decode. 
+	If there are less quality layers than the specified number, all the quality layers are decoded.
+	if != 0, then only the first "layer" layers are decoded; 
+	if == 0 or not used, all the quality layers are decoded 
+	*/
+	int cp_layer;
+
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+	/** input file name */
+	char infile[OPJ_PATH_LEN];
+	/** output file name */
+	char outfile[OPJ_PATH_LEN];
+	/** input file format 0: J2K, 1: JP2, 2: JPT */
+	int decod_format;
+	/** output file format 0: PGX, 1: PxM, 2: BMP */
+	int cod_format;
+	/*@}*/
+
+/* UniPG>> */
+	/**@name JPWL decoding parameters */
+	/*@{*/
+	/** activates the JPWL correction capabilities */
+	bool jpwl_correct;
+	/** expected number of components */
+	int jpwl_exp_comps;
+	/** maximum number of tiles */
+	int jpwl_max_tiles;
+	/*@}*/
+/* <<UniPG */
+
+	/** 
+	Specify whether the decoding should be done on the entire codestream, or be limited to the main header
+	Limiting the decoding to the main header makes it possible to extract the characteristics of the codestream
+	if == NO_LIMITATION, the entire codestream is decoded; 
+	if == LIMIT_TO_MAIN_HEADER, only the main header is decoded; 
+	*/
+	OPJ_LIMIT_DECODING cp_limit_decoding;
+
+} opj_dparameters_t;
+
+/** Common fields between JPEG-2000 compression and decompression master structs. */
+
+#define opj_common_fields \
+	opj_event_mgr_t *event_mgr;	/**< pointer to the event manager */\
+	void * client_data;			/**< Available for use by application */\
+	bool is_decompressor;		/**< So common code can tell which is which */\
+	OPJ_CODEC_FORMAT codec_format;	/**< selected codec */\
+	void *j2k_handle;			/**< pointer to the J2K codec */\
+	void *jp2_handle;			/**< pointer to the JP2 codec */\
+	void *mj2_handle			/**< pointer to the MJ2 codec */
+	
+/* Routines that are to be used by both halves of the library are declared
+ * to receive a pointer to this structure.  There are no actual instances of
+ * opj_common_struct_t, only of opj_cinfo_t and opj_dinfo_t.
+ */
+typedef struct opj_common_struct {
+  opj_common_fields;		/* Fields common to both master struct types */
+  /* Additional fields follow in an actual opj_cinfo_t or
+   * opj_dinfo_t.  All three structs must agree on these
+   * initial fields!  (This would be a lot cleaner in C++.)
+   */
+} opj_common_struct_t;
+
+typedef opj_common_struct_t * opj_common_ptr;
+
+/**
+Compression context info
+*/
+typedef struct opj_cinfo {
+	/** Fields shared with opj_dinfo_t */
+	opj_common_fields;	
+	/* other specific fields go here */
+} opj_cinfo_t;
+
+/**
+Decompression context info
+*/
+typedef struct opj_dinfo {
+	/** Fields shared with opj_cinfo_t */
+	opj_common_fields;	
+	/* other specific fields go here */
+} opj_dinfo_t;
+
+/* 
+==========================================================
+   I/O stream typedef definitions
+==========================================================
+*/
+
+/*
+ * Stream open flags.
+ */
+/** The stream was opened for reading. */
+#define OPJ_STREAM_READ	0x0001
+/** The stream was opened for writing. */
+#define OPJ_STREAM_WRITE 0x0002
+
+/**
+Byte input-output stream (CIO)
+*/
+typedef struct opj_cio {
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** open mode (read/write) either OPJ_STREAM_READ or OPJ_STREAM_WRITE */
+	int openmode;
+	/** pointer to the start of the buffer */
+	unsigned char *buffer;
+	/** buffer size in bytes */
+	int length;
+
+	/** pointer to the start of the stream */
+	unsigned char *start;
+	/** pointer to the end of the stream */
+	unsigned char *end;
+	/** pointer to the current position */
+	unsigned char *bp;
+} opj_cio_t;
+
+/* 
+==========================================================
+   image typedef definitions
+==========================================================
+*/
+
+/**
+Defines a single image component
+*/
+typedef struct opj_image_comp {
+	/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
+	int dx;
+	/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
+	int dy;
+	/** data width */
+	int w;
+	/** data height */
+	int h;
+	/** x component offset compared to the whole image */
+	int x0;
+	/** y component offset compared to the whole image */
+	int y0;
+	/** precision */
+	int prec;
+	/** image depth in bits */
+	int bpp;
+	/** signed (1) / unsigned (0) */
+	int sgnd;
+	/** number of decoded resolution */
+	int resno_decoded;
+	/** number of division by 2 of the out image compared to the original size of image */
+	int factor;
+	/** image component data */
+	int *data;
+} opj_image_comp_t;
+
+/** 
+Defines image data and characteristics
+*/
+typedef struct opj_image {
+	/** XOsiz: horizontal offset from the origin of the reference grid to the left side of the image area */
+	int x0;
+	/** YOsiz: vertical offset from the origin of the reference grid to the top side of the image area */
+	int y0;
+	/** Xsiz: width of the reference grid */
+	int x1;
+	/** Ysiz: height of the reference grid */
+	int y1;
+	/** number of components in the image */
+	int numcomps;
+	/** color space: sRGB, Greyscale or YUV */
+	OPJ_COLOR_SPACE color_space;
+	/** image components */
+	opj_image_comp_t *comps;
+} opj_image_t;
+
+/**
+Component parameters structure used by the opj_image_create function
+*/
+typedef struct opj_image_comptparm {
+	/** XRsiz: horizontal separation of a sample of ith component with respect to the reference grid */
+	int dx;
+	/** YRsiz: vertical separation of a sample of ith component with respect to the reference grid */
+	int dy;
+	/** data width */
+	int w;
+	/** data height */
+	int h;
+	/** x component offset compared to the whole image */
+	int x0;
+	/** y component offset compared to the whole image */
+	int y0;
+	/** precision */
+	int prec;
+	/** image depth in bits */
+	int bpp;
+	/** signed (1) / unsigned (0) */
+	int sgnd;
+} opj_image_cmptparm_t;
+
+/* 
+==========================================================
+   Information on the JPEG 2000 codestream
+==========================================================
+*/
+
+/**
+Index structure : Information concerning a packet inside tile
+*/
+typedef struct opj_packet_info {
+	/** packet start position (including SOP marker if it exists) */
+	int start_pos;
+	/** end of packet header position (including EPH marker if it exists)*/
+	int end_ph_pos;
+	/** packet end position */
+	int end_pos;
+	/** packet distorsion */
+	double disto;
+} opj_packet_info_t;
+
+/**
+Index structure : Information concerning tile-parts
+*/
+typedef struct opj_tp_info {
+	/** start position of tile part */
+	int tp_start_pos;
+	/** end position of tile part header */
+	int tp_end_header;
+	/** end position of tile part */
+	int tp_end_pos;
+	/** start packet of tile part */
+	int tp_start_pack;
+	/** number of packets of tile part */
+	int tp_numpacks;
+} opj_tp_info_t;
+
+/**
+Index structure : information regarding tiles 
+*/
+typedef struct opj_tile_info {
+	/** value of thresh for each layer by tile cfr. Marcela   */
+	double *thresh;
+	/** number of tile */
+	int tileno;
+	/** start position */
+	int start_pos;
+	/** end position of the header */
+	int end_header;
+	/** end position */
+	int end_pos;
+	/** precinct number for each resolution level (width) */
+	int pw[33];
+	/** precinct number for each resolution level (height) */
+	int ph[33];
+	/** precinct size (in power of 2), in X for each resolution level */
+	int pdx[33];
+	/** precinct size (in power of 2), in Y for each resolution level */
+	int pdy[33];
+	/** information concerning packets inside tile */
+	opj_packet_info_t *packet;
+	/** add fixed_quality */
+	int numpix;
+	/** add fixed_quality */
+	double distotile;
+	/** number of tile parts */
+	int num_tps;
+	/** information concerning tile parts */
+	opj_tp_info_t *tp;
+} opj_tile_info_t;
+
+/* UniPG>> */
+/**
+Marker structure
+*/
+typedef struct opj_marker_info_t {
+	/** marker type */
+	unsigned short int type;
+	/** position in codestream */
+	int pos;
+	/** length, marker val included */
+	int len;
+} opj_marker_info_t;
+/* <<UniPG */
+
+/**
+Index structure of the codestream
+*/
+typedef struct opj_codestream_info {
+	/** maximum distortion reduction on the whole image (add for Marcela) */
+	double D_max;
+	/** packet number */
+	int packno;
+	/** writing the packet in the index with t2_encode_packets */
+	int index_write;
+	/** image width */
+	int image_w;
+	/** image height */
+	int image_h;
+	/** progression order */
+	OPJ_PROG_ORDER prog;
+	/** tile size in x */
+	int tile_x;
+	/** tile size in y */
+	int tile_y;
+	/** */
+	int tile_Ox;
+	/** */
+	int tile_Oy;
+	/** number of tiles in X */
+	int tw;
+	/** number of tiles in Y */
+	int th;
+	/** component numbers */
+	int numcomps;
+	/** number of layer */
+	int numlayers;
+	/** number of decomposition for each component */
+	int *numdecompos;
+/* UniPG>> */
+	/** number of markers */
+	int marknum;
+	/** list of markers */
+	opj_marker_info_t *marker;
+	/** actual size of markers array */
+	int maxmarknum;
+/* <<UniPG */
+	/** main header position */
+	int main_head_start;
+	/** main header position */
+	int main_head_end;
+	/** codestream's size */
+	int codestream_size;
+	/** information regarding tiles inside image */
+	opj_tile_info_t *tile;
+} opj_codestream_info_t;
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* 
+==========================================================
+   openjpeg version
+==========================================================
+*/
+
+OPJ_API const char * OPJ_CALLCONV opj_version(void);
+
+/* 
+==========================================================
+   image functions definitions
+==========================================================
+*/
+
+/**
+Create an image
+@param numcmpts number of components
+@param cmptparms components parameters
+@param clrspc image color space
+@return returns a new image structure if successful, returns NULL otherwise
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_image_create(int numcmpts, opj_image_cmptparm_t *cmptparms, OPJ_COLOR_SPACE clrspc);
+
+/**
+Deallocate any resources associated with an image
+@param image image to be destroyed
+*/
+OPJ_API void OPJ_CALLCONV opj_image_destroy(opj_image_t *image);
+
+/* 
+==========================================================
+   stream functions definitions
+==========================================================
+*/
+
+/**
+Open and allocate a memory stream for read / write. 
+On reading, the user must provide a buffer containing encoded data. The buffer will be 
+wrapped by the returned CIO handle. 
+On writing, buffer parameters must be set to 0: a buffer will be allocated by the library 
+to contain encoded data. 
+@param cinfo Codec context info
+@param buffer Reading: buffer address. Writing: NULL
+@param length Reading: buffer length. Writing: 0
+@return Returns a CIO handle if successful, returns NULL otherwise
+*/
+OPJ_API opj_cio_t* OPJ_CALLCONV opj_cio_open(opj_common_ptr cinfo, unsigned char *buffer, int length);
+
+/**
+Close and free a CIO handle
+@param cio CIO handle to free
+*/
+OPJ_API void OPJ_CALLCONV opj_cio_close(opj_cio_t *cio);
+
+/**
+Get position in byte stream
+@param cio CIO handle
+@return Returns the position in bytes
+*/
+OPJ_API int OPJ_CALLCONV cio_tell(opj_cio_t *cio);
+/**
+Set position in byte stream
+@param cio CIO handle
+@param pos Position, in number of bytes, from the beginning of the stream
+*/
+OPJ_API void OPJ_CALLCONV cio_seek(opj_cio_t *cio, int pos);
+
+/* 
+==========================================================
+   event manager functions definitions
+==========================================================
+*/
+
+OPJ_API opj_event_mgr_t* OPJ_CALLCONV opj_set_event_mgr(opj_common_ptr cinfo, opj_event_mgr_t *event_mgr, void *context);
+
+/* 
+==========================================================
+   codec functions definitions
+==========================================================
+*/
+/**
+Creates a J2K/JPT/JP2 decompression structure
+@param format Decoder to select
+@return Returns a handle to a decompressor if successful, returns NULL otherwise
+*/
+OPJ_API opj_dinfo_t* OPJ_CALLCONV opj_create_decompress(OPJ_CODEC_FORMAT format);
+/**
+Destroy a decompressor handle
+@param dinfo decompressor handle to destroy
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_decompress(opj_dinfo_t *dinfo);
+/**
+Set decoding parameters to default values
+@param parameters Decompression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_set_default_decoder_parameters(opj_dparameters_t *parameters);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in j2k->cp. 
+@param dinfo decompressor handle
+@param parameters decompression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_setup_decoder(opj_dinfo_t *dinfo, opj_dparameters_t *parameters);
+/**
+Decode an image from a JPEG-2000 codestream 
+@param dinfo decompressor handle
+@param cio Input buffer stream
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_decode(opj_dinfo_t *dinfo, opj_cio_t *cio);
+
+/**
+Decode an image from a JPEG-2000 codestream and extract the codestream information
+@param dinfo decompressor handle
+@param cio Input buffer stream
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+OPJ_API opj_image_t* OPJ_CALLCONV opj_decode_with_info(opj_dinfo_t *dinfo, opj_cio_t *cio, opj_codestream_info_t *cstr_info);
+/**
+Creates a J2K/JP2 compression structure
+@param format Coder to select
+@return Returns a handle to a compressor if successful, returns NULL otherwise
+*/
+OPJ_API opj_cinfo_t* OPJ_CALLCONV opj_create_compress(OPJ_CODEC_FORMAT format);
+/**
+Destroy a compressor handle
+@param cinfo compressor handle to destroy
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_compress(opj_cinfo_t *cinfo);
+/**
+Set encoding parameters to default values, that means : 
+<ul>
+<li>Lossless
+<li>1 tile
+<li>Size of precinct : 2^15 x 2^15 (means 1 precinct)
+<li>Size of code-block : 64 x 64
+<li>Number of resolutions: 6
+<li>No SOP marker in the codestream
+<li>No EPH marker in the codestream
+<li>No sub-sampling in x or y direction
+<li>No mode switch activated
+<li>Progression order: LRCP
+<li>No index file
+<li>No ROI upshifted
+<li>No offset of the origin of the image
+<li>No offset of the origin of the tiles
+<li>Reversible DWT 5-3
+</ul>
+@param parameters Compression parameters
+*/
+OPJ_API void OPJ_CALLCONV opj_set_default_encoder_parameters(opj_cparameters_t *parameters);
+/**
+Setup the encoder parameters using the current image and using user parameters. 
+@param cinfo Compressor handle
+@param parameters Compression parameters
+@param image Input filled image
+*/
+OPJ_API void OPJ_CALLCONV opj_setup_encoder(opj_cinfo_t *cinfo, opj_cparameters_t *parameters, opj_image_t *image);
+/**
+Encode an image into a JPEG-2000 codestream
+@param cinfo compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param index Depreacted -> Set to NULL. To extract index, used opj_encode_wci()
+@return Returns true if successful, returns false otherwise
+*/
+OPJ_API bool OPJ_CALLCONV opj_encode(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, char *index);
+/**
+Encode an image into a JPEG-2000 codestream and extract the codestream information
+@param cinfo compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param cstr_info Codestream information structure if needed afterwards, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+OPJ_API bool OPJ_CALLCONV opj_encode_with_info(opj_cinfo_t *cinfo, opj_cio_t *cio, opj_image_t *image, opj_codestream_info_t *cstr_info);
+/**
+Destroy Codestream information after compression or decompression
+@param cstr_info Codestream information structure
+*/
+OPJ_API void OPJ_CALLCONV opj_destroy_cstr_info(opj_codestream_info_t *cstr_info);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* OPENJPEG_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/opj_includes.h.svn-base ./libopenjpeg/.svn/text-base/opj_includes.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/opj_includes.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/opj_includes.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,132 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef OPJ_INCLUDES_H
+#define OPJ_INCLUDES_H
+
+/*
+ ==========================================================
+   Standard includes used by the library
+ ==========================================================
+*/
+#include <memory.h>
+#include <stdlib.h>
+#include <string.h>
+#include <math.h>
+#include <float.h>
+#include <time.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <ctype.h>
+
+/*
+ ==========================================================
+   OpenJPEG interface
+ ==========================================================
+ */
+#include "openjpeg.h"
+
+/*
+ ==========================================================
+   OpenJPEG modules
+ ==========================================================
+*/
+
+/* Ignore GCC attributes if this is not GCC */
+#ifndef __GNUC__
+	#define __attribute__(x) /* __attribute__(x) */
+#endif
+
+/*
+The inline keyword is supported by C99 but not by C90. 
+Most compilers implement their own version of this keyword ... 
+*/
+#ifndef INLINE
+	#if defined(_MSC_VER)
+		#define INLINE __inline
+	#elif defined(__GNUC__)
+		#define INLINE __inline__
+	#elif defined(__MWERKS__)
+		#define INLINE inline
+	#else 
+		/* add other compilers here ... */
+		#define INLINE 
+	#endif /* defined(<Compiler>) */
+#endif /* INLINE */
+
+/* Are restricted pointers available? (C99) */
+#if (__STDC_VERSION__ != 199901L)
+	/* Not a C99 compiler */
+	#ifdef __GNUC__
+		#define restrict __restrict__
+	#else
+		#define restrict /* restrict */
+	#endif
+#endif
+
+/* MSVC does not have lrintf */
+#ifdef _MSC_VER
+static INLINE long lrintf(float f){
+	int i;
+
+	_asm{
+		fld f
+		fistp i
+	};
+
+	return i;
+}
+#endif
+
+#include "j2k_lib.h"
+#include "opj_malloc.h"
+#include "event.h"
+#include "cio.h"
+
+#include "image.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "jpt.h"
+
+#include "mqc.h"
+#include "raw.h"
+#include "bio.h"
+#include "tgt.h"
+#include "pi.h"
+#include "tcd.h"
+#include "t1.h"
+#include "dwt.h"
+#include "t2.h"
+#include "mct.h"
+#include "int.h"
+#include "fix.h"
+
+/* JPWL>> */
+#ifdef USE_JPWL
+#include "../jpwl/jpwl.h"
+#endif /* USE_JPWL */
+/* <<JPWL */
+
+#endif /* OPJ_INCLUDES_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/opj_malloc.h.svn-base ./libopenjpeg/.svn/text-base/opj_malloc.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/opj_malloc.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/opj_malloc.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,140 @@
+/*
+ * Copyright (c) 2005, Hervé Drolon, FreeImage Team
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __OPJ_MALLOC_H
+#define __OPJ_MALLOC_H
+/**
+@file opj_malloc.h
+@brief Internal functions
+
+The functions in opj_malloc.h are internal utilities used for memory management.
+*/
+
+/** @defgroup MISC MISC - Miscellaneous internal functions */
+/*@{*/
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Allocate an uninitialized memory block
+@param size Bytes to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+#define opj_malloc(size) malloc(size)
+
+/**
+Allocate a memory block with elements initialized to 0
+@param num Blocks to allocate
+@param size Bytes per block to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+#define opj_calloc(num, size) calloc(num, size)
+
+/**
+Allocate memory aligned to a 16 byte boundry
+@param size Bytes to allocate
+@return Returns a void pointer to the allocated space, or NULL if there is insufficient memory available
+*/
+/* FIXME: These should be set with cmake tests, but we're currently not requiring use of cmake */
+#ifdef WIN32
+	/* Someone should tell the mingw people that their malloc.h ought to provide _mm_malloc() */
+	#ifdef __GNUC__
+		#include <mm_malloc.h>
+		#define HAVE_MM_MALLOC
+	#else /* MSVC, Intel C++ */
+		#include <malloc.h>
+		#ifdef _mm_malloc
+			#define HAVE_MM_MALLOC
+		#endif
+	#endif
+#else /* Not WIN32 */
+	#if defined(__sun)
+		#define HAVE_MEMALIGN
+	/* Linux x86_64 and OSX always align allocations to 16 bytes */
+	#elif !defined(__amd64__) && !defined(__APPLE__)
+		/* FIXME: Yes, this is a big assumption */
+		#define HAVE_POSIX_MEMALIGN
+	#endif
+#endif
+
+#define opj_aligned_malloc(size) malloc(size)
+#define opj_aligned_free(m) free(m)
+
+#ifdef HAVE_MM_MALLOC
+	#undef opj_aligned_malloc
+	#define opj_aligned_malloc(size) _mm_malloc(size, 16)
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) _mm_free(m)
+#endif
+
+#ifdef HAVE_MEMALIGN
+	extern void* memalign(size_t, size_t);
+	#undef opj_aligned_malloc
+	#define opj_aligned_malloc(size) memalign(16, (size))
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) free(m)
+#endif
+
+#ifdef HAVE_POSIX_MEMALIGN
+	#undef opj_aligned_malloc
+	extern int posix_memalign(void**, size_t, size_t);
+
+	static INLINE void* __attribute__ ((malloc)) opj_aligned_malloc(size_t size){
+		void* mem = NULL;
+		posix_memalign(&mem, 16, size);
+		return mem;
+	}
+	#undef opj_aligned_free
+	#define opj_aligned_free(m) free(m)
+#endif
+
+/**
+Reallocate memory blocks.
+@param memblock Pointer to previously allocated memory block
+@param size New size in bytes
+@return Returns a void pointer to the reallocated (and possibly moved) memory block
+*/
+#define opj_realloc(m, s) realloc(m, s)
+
+/**
+Deallocates or frees a memory block.
+@param memblock Previously allocated memory block to be freed
+*/
+#define opj_free(m) free(m)
+
+#ifdef __GNUC__
+#pragma GCC poison malloc calloc realloc free
+#endif
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __OPJ_MALLOC_H */
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/pi.c.svn-base ./libopenjpeg/.svn/text-base/pi.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/pi.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/pi.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1067 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup PI PI - Implementation of a packet iterator */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Get next packet in layer-resolution-component-precinct order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_lrcp(opj_pi_iterator_t * pi);
+/**
+Get next packet in resolution-layer-component-precinct order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_rlcp(opj_pi_iterator_t * pi);
+/**
+Get next packet in resolution-precinct-component-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_rpcl(opj_pi_iterator_t * pi);
+/**
+Get next packet in precinct-component-resolution-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_pcrl(opj_pi_iterator_t * pi);
+/**
+Get next packet in component-precinct-resolution-layer order.
+@param pi packet iterator to modify
+@return returns false if pi pointed to the last packet or else returns true 
+*/
+static bool pi_next_cprl(opj_pi_iterator_t * pi);
+
+/*@}*/
+
+/*@}*/
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+static bool pi_next_lrcp(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+	
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
+		for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1;
+		pi->resno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolutions) {
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				if (!pi->tp_on){
+					pi->poc.precno1 = res->pw * res->ph;
+				}
+				for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
+					index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+					if (!pi->include[index]) {
+						pi->include[index] = 1;
+						return true;
+					}
+LABEL_SKIP:;
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_rlcp(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		res = &comp->resolutions[pi->resno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				if (pi->resno >= comp->numresolutions) {
+					continue;
+				}
+				res = &comp->resolutions[pi->resno];
+				if(!pi->tp_on){
+					pi->poc.precno1 = res->pw * res->ph;
+				}
+				for (pi->precno = pi->poc.precno0; pi->precno < pi->poc.precno1; pi->precno++) {
+					index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+					if (!pi->include[index]) {
+						pi->include[index] = 1;
+						return true;
+					}
+LABEL_SKIP:;
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_rpcl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		goto LABEL_SKIP;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int dx, dy;
+				res = &comp->resolutions[resno];
+				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			}
+		}
+	}
+if (!pi->tp_on){
+			pi->poc.ty0 = pi->ty0;
+			pi->poc.tx0 = pi->tx0;
+			pi->poc.ty1 = pi->ty1;
+			pi->poc.tx1 = pi->tx1;
+		}
+	for (pi->resno = pi->poc.resno0; pi->resno < pi->poc.resno1; pi->resno++) {
+		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+				for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+					int levelno;
+					int trx0, try0;
+					int trx1, try1;
+					int rpx, rpy;
+					int prci, prcj;
+					comp = &pi->comps[pi->compno];
+					if (pi->resno >= comp->numresolutions) {
+						continue;
+					}
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
+					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpx))))){
+						continue;	
+					}
+					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue; 
+					}
+					
+					if ((res->pw==0)||(res->pw==0)) continue;
+					
+					if ((trx0==trx1)||(try0==try1)) continue;
+					
+					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
+						 - int_floordivpow2(trx0, res->pdx);
+					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
+						 - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
+						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+						if (!pi->include[index]) {
+							pi->include[index] = 1;
+							return true;
+						}
+LABEL_SKIP:;
+					}
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_pcrl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto LABEL_SKIP;
+	} else {
+		int compno, resno;
+		pi->first = 0;
+		pi->dx = 0;
+		pi->dy = 0;
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int dx, dy;
+				res = &comp->resolutions[resno];
+				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+				pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			}
+		}
+	}
+	if (!pi->tp_on){
+			pi->poc.ty0 = pi->ty0;
+			pi->poc.tx0 = pi->tx0;
+			pi->poc.ty1 = pi->ty1;
+			pi->poc.tx1 = pi->tx1;
+		}
+	for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+		for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+			for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+				comp = &pi->comps[pi->compno];
+				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
+					int levelno;
+					int trx0, try0;
+					int trx1, try1;
+					int rpx, rpy;
+					int prci, prcj;
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
+					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpx))))){
+						continue;	
+					}
+					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue; 
+					}
+					
+					if ((res->pw==0)||(res->pw==0)) continue;
+					
+					if ((trx0==trx1)||(try0==try1)) continue;
+					
+					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
+						 - int_floordivpow2(trx0, res->pdx);
+					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
+						 - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
+						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+						if (!pi->include[index]) {
+							pi->include[index] = 1;
+							return true;
+						}	
+LABEL_SKIP:;
+					}
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+static bool pi_next_cprl(opj_pi_iterator_t * pi) {
+	opj_pi_comp_t *comp = NULL;
+	opj_pi_resolution_t *res = NULL;
+	long index = 0;
+
+	if (!pi->first) {
+		comp = &pi->comps[pi->compno];
+		goto LABEL_SKIP;
+	} else {
+		pi->first = 0;
+	}
+
+	for (pi->compno = pi->poc.compno0; pi->compno < pi->poc.compno1; pi->compno++) {
+		int resno;
+		comp = &pi->comps[pi->compno];
+		pi->dx = 0;
+		pi->dy = 0;
+		for (resno = 0; resno < comp->numresolutions; resno++) {
+			int dx, dy;
+			res = &comp->resolutions[resno];
+			dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+			dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+			pi->dx = !pi->dx ? dx : int_min(pi->dx, dx);
+			pi->dy = !pi->dy ? dy : int_min(pi->dy, dy);
+		}
+		if (!pi->tp_on){
+			pi->poc.ty0 = pi->ty0;
+			pi->poc.tx0 = pi->tx0;
+			pi->poc.ty1 = pi->ty1;
+			pi->poc.tx1 = pi->tx1;
+		}
+		for (pi->y = pi->poc.ty0; pi->y < pi->poc.ty1; pi->y += pi->dy - (pi->y % pi->dy)) {
+			for (pi->x = pi->poc.tx0; pi->x < pi->poc.tx1; pi->x += pi->dx - (pi->x % pi->dx)) {
+				for (pi->resno = pi->poc.resno0; pi->resno < int_min(pi->poc.resno1, comp->numresolutions); pi->resno++) {
+					int levelno;
+					int trx0, try0;
+					int trx1, try1;
+					int rpx, rpy;
+					int prci, prcj;
+					res = &comp->resolutions[pi->resno];
+					levelno = comp->numresolutions - 1 - pi->resno;
+					trx0 = int_ceildiv(pi->tx0, comp->dx << levelno);
+					try0 = int_ceildiv(pi->ty0, comp->dy << levelno);
+					trx1 = int_ceildiv(pi->tx1, comp->dx << levelno);
+					try1 = int_ceildiv(pi->ty1, comp->dy << levelno);
+					rpx = res->pdx + levelno;
+					rpy = res->pdy + levelno;
+					if (!((pi->y % (comp->dy << rpy) == 0) || ((pi->y == pi->ty0) && ((try0 << levelno) % (1 << rpx))))){
+						continue;	
+					}
+					if (!((pi->x % (comp->dx << rpx) == 0) || ((pi->x == pi->tx0) && ((trx0 << levelno) % (1 << rpx))))){
+						continue; 
+					}
+					
+					if ((res->pw==0)||(res->pw==0)) continue;
+					
+					if ((trx0==trx1)||(try0==try1)) continue;
+					
+					prci = int_floordivpow2(int_ceildiv(pi->x, comp->dx << levelno), res->pdx) 
+						 - int_floordivpow2(trx0, res->pdx);
+					prcj = int_floordivpow2(int_ceildiv(pi->y, comp->dy << levelno), res->pdy) 
+						 - int_floordivpow2(try0, res->pdy);
+					pi->precno = prci + prcj * res->pw;
+					for (pi->layno = pi->poc.layno0; pi->layno < pi->poc.layno1; pi->layno++) {
+						index = pi->layno * pi->step_l + pi->resno * pi->step_r + pi->compno * pi->step_c + pi->precno * pi->step_p;
+						if (!pi->include[index]) {
+							pi->include[index] = 1;
+							return true;
+						}
+LABEL_SKIP:;
+					}
+				}
+			}
+		}
+	}
+	
+	return false;
+}
+
+/* 
+==========================================================
+   Packet iterator interface
+==========================================================
+*/
+
+opj_pi_iterator_t *pi_create_decode(opj_image_t *image, opj_cp_t *cp, int tileno) {
+	int p, q;
+	int compno, resno, pino;
+	opj_pi_iterator_t *pi = NULL;
+	opj_tcp_t *tcp = NULL;
+	opj_tccp_t *tccp = NULL;
+
+	tcp = &cp->tcps[tileno];
+
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
+	if(!pi) {
+		/* TODO: throw an error */
+		return NULL;
+	}
+
+	for (pino = 0; pino < tcp->numpocs + 1; pino++) {	/* change */
+		int maxres = 0;
+		int maxprec = 0;
+		p = tileno % cp->tw;
+		q = tileno / cp->tw;
+
+		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+		pi[pino].numcomps = image->numcomps;
+
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
+		if(!pi[pino].comps) {
+			/* TODO: throw an error */
+			pi_destroy(pi, cp, tileno);
+			return NULL;
+		}
+		
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			int tcx0, tcy0, tcx1, tcy1;
+			opj_pi_comp_t *comp = &pi[pino].comps[compno];
+			tccp = &tcp->tccps[compno];
+			comp->dx = image->comps[compno].dx;
+			comp->dy = image->comps[compno].dy;
+			comp->numresolutions = tccp->numresolutions;
+
+			comp->resolutions = (opj_pi_resolution_t*) opj_calloc(comp->numresolutions, sizeof(opj_pi_resolution_t));
+			if(!comp->resolutions) {
+				/* TODO: throw an error */
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+
+			tcx0 = int_ceildiv(pi->tx0, comp->dx);
+			tcy0 = int_ceildiv(pi->ty0, comp->dy);
+			tcx1 = int_ceildiv(pi->tx1, comp->dx);
+			tcy1 = int_ceildiv(pi->ty1, comp->dy);
+			if (comp->numresolutions > maxres) {
+				maxres = comp->numresolutions;
+			}
+
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int levelno;
+				int rx0, ry0, rx1, ry1;
+				int px0, py0, px1, py1;
+				opj_pi_resolution_t *res = &comp->resolutions[resno];
+				if (tccp->csty & J2K_CCP_CSTY_PRT) {
+					res->pdx = tccp->prcw[resno];
+					res->pdy = tccp->prch[resno];
+				} else {
+					res->pdx = 15;
+					res->pdy = 15;
+				}
+				levelno = comp->numresolutions - 1 - resno;
+				rx0 = int_ceildivpow2(tcx0, levelno);
+				ry0 = int_ceildivpow2(tcy0, levelno);
+				rx1 = int_ceildivpow2(tcx1, levelno);
+				ry1 = int_ceildivpow2(tcy1, levelno);
+				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
+				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
+				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
+				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
+				res->pw = (rx0==rx1)?0:((px1 - px0) >> res->pdx);
+				res->ph = (ry0==ry1)?0:((py1 - py0) >> res->pdy);
+				
+				if (res->pw*res->ph > maxprec) {
+					maxprec = res->pw*res->ph;
+				}
+				
+			}
+		}
+		
+		tccp = &tcp->tccps[0];
+		pi[pino].step_p = 1;
+		pi[pino].step_c = maxprec * pi[pino].step_p;
+		pi[pino].step_r = image->numcomps * pi[pino].step_c;
+		pi[pino].step_l = maxres * pi[pino].step_r;
+		
+		if (pino == 0) {
+			pi[pino].include = (short int*) opj_calloc(image->numcomps * maxres * tcp->numlayers * maxprec, sizeof(short int));
+			if(!pi[pino].include) {
+				/* TODO: throw an error */
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+		}
+		else {
+			pi[pino].include = pi[pino - 1].include;
+		}
+		
+		if (tcp->POC == 0) {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = 0;
+			pi[pino].poc.compno0 = 0;
+			pi[pino].poc.layno1 = tcp->numlayers;
+			pi[pino].poc.resno1 = maxres;
+			pi[pino].poc.compno1 = image->numcomps;
+			pi[pino].poc.prg = tcp->prg;
+		} else {
+			pi[pino].first = 1;
+			pi[pino].poc.resno0 = tcp->pocs[pino].resno0;
+			pi[pino].poc.compno0 = tcp->pocs[pino].compno0;
+			pi[pino].poc.layno1 = tcp->pocs[pino].layno1;
+			pi[pino].poc.resno1 = tcp->pocs[pino].resno1;
+			pi[pino].poc.compno1 = tcp->pocs[pino].compno1;
+			pi[pino].poc.prg = tcp->pocs[pino].prg;
+		}
+		pi[pino].poc.layno0  = 0;
+		pi[pino].poc.precno0 = 0; 
+		pi[pino].poc.precno1 = maxprec;
+			
+	}
+	
+	return pi;
+}
+
+
+opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image, opj_cp_t *cp, int tileno, J2K_T2_MODE t2_mode){ 
+	int p, q, pino;
+	int compno, resno;
+	int maxres = 0;
+	int maxprec = 0;
+	opj_pi_iterator_t *pi = NULL;
+	opj_tcp_t *tcp = NULL;
+	opj_tccp_t *tccp = NULL;
+	
+	tcp = &cp->tcps[tileno];
+
+	pi = (opj_pi_iterator_t*) opj_calloc((tcp->numpocs + 1), sizeof(opj_pi_iterator_t));
+	if(!pi) {	return NULL;}
+	pi->tp_on = cp->tp_on;
+
+	for(pino = 0;pino < tcp->numpocs+1 ; pino ++){
+		p = tileno % cp->tw;
+		q = tileno / cp->tw;
+
+		pi[pino].tx0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+		pi[pino].ty0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+		pi[pino].tx1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+		pi[pino].ty1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+		pi[pino].numcomps = image->numcomps;
+		
+		pi[pino].comps = (opj_pi_comp_t*) opj_calloc(image->numcomps, sizeof(opj_pi_comp_t));
+		if(!pi[pino].comps) {
+			pi_destroy(pi, cp, tileno);
+			return NULL;
+		}
+		
+		for (compno = 0; compno < pi[pino].numcomps; compno++) {
+			int tcx0, tcy0, tcx1, tcy1;
+			opj_pi_comp_t *comp = &pi[pino].comps[compno];
+			tccp = &tcp->tccps[compno];
+			comp->dx = image->comps[compno].dx;
+			comp->dy = image->comps[compno].dy;
+			comp->numresolutions = tccp->numresolutions;
+
+			comp->resolutions = (opj_pi_resolution_t*) opj_malloc(comp->numresolutions * sizeof(opj_pi_resolution_t));
+			if(!comp->resolutions) {
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+
+			tcx0 = int_ceildiv(pi[pino].tx0, comp->dx);
+			tcy0 = int_ceildiv(pi[pino].ty0, comp->dy);
+			tcx1 = int_ceildiv(pi[pino].tx1, comp->dx);
+			tcy1 = int_ceildiv(pi[pino].ty1, comp->dy);
+			if (comp->numresolutions > maxres) {
+				maxres = comp->numresolutions;
+			}
+
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int levelno;
+				int rx0, ry0, rx1, ry1;
+				int px0, py0, px1, py1;
+				opj_pi_resolution_t *res = &comp->resolutions[resno];
+				if (tccp->csty & J2K_CCP_CSTY_PRT) {
+					res->pdx = tccp->prcw[resno];
+					res->pdy = tccp->prch[resno];
+				} else {
+					res->pdx = 15;
+					res->pdy = 15;
+				}
+				levelno = comp->numresolutions - 1 - resno;
+				rx0 = int_ceildivpow2(tcx0, levelno);
+				ry0 = int_ceildivpow2(tcy0, levelno);
+				rx1 = int_ceildivpow2(tcx1, levelno);
+				ry1 = int_ceildivpow2(tcy1, levelno);
+				px0 = int_floordivpow2(rx0, res->pdx) << res->pdx;
+				py0 = int_floordivpow2(ry0, res->pdy) << res->pdy;
+				px1 = int_ceildivpow2(rx1, res->pdx) << res->pdx;
+				py1 = int_ceildivpow2(ry1, res->pdy) << res->pdy;
+				res->pw = (rx0==rx1)?0:((px1 - px0) >> res->pdx);
+				res->ph = (ry0==ry1)?0:((py1 - py0) >> res->pdy);
+
+				if (res->pw*res->ph > maxprec) {
+					maxprec = res->pw * res->ph;
+				}
+			}
+		}
+		
+		tccp = &tcp->tccps[0];
+		pi[pino].step_p = 1;
+		pi[pino].step_c = maxprec * pi[pino].step_p;
+		pi[pino].step_r = image->numcomps * pi[pino].step_c;
+		pi[pino].step_l = maxres * pi[pino].step_r;
+		
+		for (compno = 0; compno < pi->numcomps; compno++) {
+			opj_pi_comp_t *comp = &pi->comps[compno];
+			for (resno = 0; resno < comp->numresolutions; resno++) {
+				int dx, dy;
+				opj_pi_resolution_t *res = &comp->resolutions[resno];
+				dx = comp->dx * (1 << (res->pdx + comp->numresolutions - 1 - resno));
+				dy = comp->dy * (1 << (res->pdy + comp->numresolutions - 1 - resno));
+				pi[pino].dx = !pi->dx ? dx : int_min(pi->dx, dx);
+				pi[pino].dy = !pi->dy ? dy : int_min(pi->dy, dy);
+			}
+		}
+
+		if (pino == 0) {
+			pi[pino].include = (short int*) opj_calloc(tcp->numlayers * pi[pino].step_l, sizeof(short int));
+			if(!pi[pino].include) {
+				pi_destroy(pi, cp, tileno);
+				return NULL;
+			}
+		}
+		else {
+			pi[pino].include = pi[pino - 1].include;
+		}
+		
+		/* Generation of boundaries for each prog flag*/
+			if(tcp->POC && ( cp->cinema || ((!cp->cinema) && (t2_mode == FINAL_PASS)))){
+				tcp->pocs[pino].compS= tcp->pocs[pino].compno0;
+				tcp->pocs[pino].compE= tcp->pocs[pino].compno1;
+				tcp->pocs[pino].resS = tcp->pocs[pino].resno0;
+				tcp->pocs[pino].resE = tcp->pocs[pino].resno1;
+				tcp->pocs[pino].layE = tcp->pocs[pino].layno1;
+				tcp->pocs[pino].prg  = tcp->pocs[pino].prg1;
+				if (pino > 0)
+					tcp->pocs[pino].layS = (tcp->pocs[pino].layE > tcp->pocs[pino - 1].layE) ? tcp->pocs[pino - 1].layE : 0;
+			}else {
+				tcp->pocs[pino].compS= 0;
+				tcp->pocs[pino].compE= image->numcomps;
+				tcp->pocs[pino].resS = 0;
+				tcp->pocs[pino].resE = maxres;
+				tcp->pocs[pino].layS = 0;
+				tcp->pocs[pino].layE = tcp->numlayers;
+				tcp->pocs[pino].prg  = tcp->prg;
+			}
+			tcp->pocs[pino].prcS = 0;
+			tcp->pocs[pino].prcE = maxprec;;
+			tcp->pocs[pino].txS = pi[pino].tx0;
+			tcp->pocs[pino].txE = pi[pino].tx1;
+			tcp->pocs[pino].tyS = pi[pino].ty0;
+			tcp->pocs[pino].tyE = pi[pino].ty1;
+			tcp->pocs[pino].dx = pi[pino].dx;
+			tcp->pocs[pino].dy = pi[pino].dy;
+		}
+			return pi;
+	}
+
+
+
+void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno) {
+	int compno, pino;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	if(pi) {
+		for (pino = 0; pino < tcp->numpocs + 1; pino++) {	
+			if(pi[pino].comps) {
+				for (compno = 0; compno < pi->numcomps; compno++) {
+					opj_pi_comp_t *comp = &pi[pino].comps[compno];
+					if(comp->resolutions) {
+						opj_free(comp->resolutions);
+					}
+				}
+				opj_free(pi[pino].comps);
+			}
+		}
+		if(pi->include) {
+			opj_free(pi->include);
+		}
+		opj_free(pi);
+	}
+}
+
+bool pi_next(opj_pi_iterator_t * pi) {
+	switch (pi->poc.prg) {
+		case LRCP:
+			return pi_next_lrcp(pi);
+		case RLCP:
+			return pi_next_rlcp(pi);
+		case RPCL:
+			return pi_next_rpcl(pi);
+		case PCRL:
+			return pi_next_pcrl(pi);
+		case CPRL:
+			return pi_next_cprl(pi);
+		case PROG_UNKNOWN:
+			return false;
+	}
+	
+	return false;
+}
+
+int pi_check_next_level(int pos,opj_cp_t *cp,int tileno, int pino, char *prog){
+	int i,l;
+	opj_tcp_t *tcps =&cp->tcps[tileno];
+	opj_poc_t *tcp = &tcps->pocs[pino];
+	if(pos>=0){
+		for(i=pos;pos>=0;i--){
+			switch(prog[i]){
+		case 'R':
+			if(tcp->res_t==tcp->resE){
+				l=pi_check_next_level(pos-1,cp,tileno,pino,prog);
+				if(l==1){
+					return 1;
+				}else{
+					return 0;
+				}
+			}else{
+				return 1;
+			}
+			break;
+		case 'C':
+			if(tcp->comp_t==tcp->compE){
+				l=pi_check_next_level(pos-1,cp,tileno,pino,prog);
+				if(l==1){
+					return 1;
+				}else{
+					return 0;
+				}
+			}else{
+				return 1;
+			}
+			break;
+		case 'L':
+			if(tcp->lay_t==tcp->layE){
+				l=pi_check_next_level(pos-1,cp,tileno,pino,prog);
+				if(l==1){
+					return 1;
+				}else{
+					return 0;
+				}
+			}else{
+				return 1;
+			}
+			break;
+		case 'P':
+			switch(tcp->prg){
+				case LRCP||RLCP:
+					if(tcp->prc_t == tcp->prcE){
+						l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+						if(l==1){
+							return 1;
+						}else{
+							return 0;
+						}
+					}else{
+						return 1;
+					}
+					break;
+			default:
+				if(tcp->tx0_t == tcp->txE){
+					//TY 
+					if(tcp->ty0_t == tcp->tyE){
+						l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+						if(l==1){
+							return 1;
+						}else{
+							return 0;
+						}
+					}else{
+						return 1;
+					}//TY
+				}else{
+					return 1;
+				}
+				break;
+			}//end case P
+		}//end switch
+		}//end for
+	}//end if
+	return 0;
+}
+
+
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode){
+	char *prog;
+	int i,l;
+	int incr_top=1,resetX=0;
+	opj_tcp_t *tcps =&cp->tcps[tileno];
+	opj_poc_t *tcp= &tcps->pocs[pino];
+	prog = j2k_convert_progression_order(tcp->prg);
+
+	pi[pino].first = 1;
+	pi[pino].poc.prg = tcp->prg;	
+	
+	if(!(cp->tp_on && ((!cp->cinema && (t2_mode == FINAL_PASS)) || cp->cinema))){
+		pi[pino].poc.resno0 = tcp->resS;
+		pi[pino].poc.resno1 = tcp->resE;
+		pi[pino].poc.compno0 = tcp->compS;
+		pi[pino].poc.compno1 = tcp->compE;
+		pi[pino].poc.layno0 = tcp->layS;
+		pi[pino].poc.layno1 = tcp->layE;
+		pi[pino].poc.precno0 = tcp->prcS;
+		pi[pino].poc.precno1 = tcp->prcE;
+		pi[pino].poc.tx0 = tcp->txS;
+		pi[pino].poc.ty0 = tcp->tyS;
+		pi[pino].poc.tx1 = tcp->txE;
+		pi[pino].poc.ty1 = tcp->tyE;
+	}else {
+		for(i=tppos+1;i<4;i++){
+			switch(prog[i]){
+			case 'R':
+				pi[pino].poc.resno0 = tcp->resS;
+				pi[pino].poc.resno1 = tcp->resE;
+				break;
+			case 'C':
+				pi[pino].poc.compno0 = tcp->compS;
+				pi[pino].poc.compno1 = tcp->compE;
+				break;
+			case 'L':
+				pi[pino].poc.layno0 = tcp->layS;
+				pi[pino].poc.layno1 = tcp->layE;
+				break;
+			case 'P':
+				switch(tcp->prg){
+					case LRCP:
+					case RLCP:
+						pi[pino].poc.precno0 = tcp->prcS;
+						pi[pino].poc.precno1 = tcp->prcE;
+						break;
+					default:
+						pi[pino].poc.tx0 = tcp->txS;
+						pi[pino].poc.ty0 = tcp->tyS;
+						pi[pino].poc.tx1 = tcp->txE;
+						pi[pino].poc.ty1 = tcp->tyE;
+						break;
+				}
+				break;
+			}
+		}
+
+		if(tpnum==0){
+			for(i=tppos;i>=0;i--){
+				switch(prog[i]){
+						case 'C':
+							tcp->comp_t = tcp->compS;
+							pi[pino].poc.compno0 = tcp->comp_t;
+							pi[pino].poc.compno1 = tcp->comp_t+1;
+							tcp->comp_t+=1;
+							break;
+						case 'R':
+							tcp->res_t = tcp->resS;
+							pi[pino].poc.resno0 = tcp->res_t;
+							pi[pino].poc.resno1 = tcp->res_t+1;
+							tcp->res_t+=1;
+							break;
+						case 'L':
+							tcp->lay_t = tcp->layS;
+							pi[pino].poc.layno0 = tcp->lay_t;
+							pi[pino].poc.layno1 = tcp->lay_t+1;
+							tcp->lay_t+=1;
+							break;
+						case 'P':
+							switch(tcp->prg){
+								case LRCP:
+								case RLCP:
+									tcp->prc_t = tcp->prcS;
+									pi[pino].poc.precno0 = tcp->prc_t;
+									pi[pino].poc.precno1 = tcp->prc_t+1;
+									tcp->prc_t+=1; 
+									break;
+								default:
+									tcp->tx0_t = tcp->txS;
+									tcp->ty0_t = tcp->tyS;
+									pi[pino].poc.tx0 = tcp->tx0_t;
+									pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx - (tcp->tx0_t % tcp->dx);
+									pi[pino].poc.ty0 = tcp->ty0_t;
+									pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
+									tcp->tx0_t = pi[pino].poc.tx1;
+									tcp->ty0_t = pi[pino].poc.ty1;
+									break;
+							}
+							break;
+				}
+			}
+			incr_top=1;
+		}else{
+			for(i=tppos;i>=0;i--){
+				switch(prog[i]){
+						case 'C':
+							pi[pino].poc.compno0 = tcp->comp_t-1;
+							pi[pino].poc.compno1 = tcp->comp_t;
+							break;
+						case 'R':
+							pi[pino].poc.resno0 = tcp->res_t-1;
+							pi[pino].poc.resno1 = tcp->res_t;
+							break;
+						case 'L':
+							pi[pino].poc.layno0 = tcp->lay_t-1;
+							pi[pino].poc.layno1 = tcp->lay_t;
+							break;
+						case 'P':
+							switch(tcp->prg){
+								case LRCP:
+								case RLCP:
+									pi[pino].poc.precno0 = tcp->prc_t-1;
+									pi[pino].poc.precno1 = tcp->prc_t;
+									break;
+								default:
+									pi[pino].poc.tx0 = tcp->tx0_t - tcp->dx - (tcp->tx0_t % tcp->dx);
+									pi[pino].poc.tx1 = tcp->tx0_t ;
+									pi[pino].poc.ty0 = tcp->ty0_t - tcp->dy - (tcp->ty0_t % tcp->dy);
+									pi[pino].poc.ty1 = tcp->ty0_t ;
+									break;
+							}
+							break;
+				}
+				if(incr_top==1){
+					switch(prog[i]){
+							case 'R':
+								if(tcp->res_t==tcp->resE){
+									l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+									if(l==1){
+										tcp->res_t = tcp->resS;
+										pi[pino].poc.resno0 = tcp->res_t;
+										pi[pino].poc.resno1 = tcp->res_t+1;
+										tcp->res_t+=1;
+										incr_top=1;
+									}else{
+										incr_top=0;
+									}
+								}else{
+									pi[pino].poc.resno0 = tcp->res_t;
+									pi[pino].poc.resno1 = tcp->res_t+1;
+									tcp->res_t+=1;
+									incr_top=0;
+								}
+								break;
+							case 'C':
+								if(tcp->comp_t ==tcp->compE){
+									l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+									if(l==1){
+										tcp->comp_t = tcp->compS;
+										pi[pino].poc.compno0 = tcp->comp_t;
+										pi[pino].poc.compno1 = tcp->comp_t+1;
+										tcp->comp_t+=1;
+										incr_top=1;
+									}else{
+										incr_top=0;
+									}
+								}else{
+									pi[pino].poc.compno0 = tcp->comp_t;
+									pi[pino].poc.compno1 = tcp->comp_t+1;
+									tcp->comp_t+=1;
+									incr_top=0;
+								}
+								break;	
+							case 'L':
+								if(tcp->lay_t == tcp->layE){
+									l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+									if(l==1){
+										tcp->lay_t = tcp->layS;
+										pi[pino].poc.layno0 = tcp->lay_t;
+										pi[pino].poc.layno1 = tcp->lay_t+1;
+										tcp->lay_t+=1;
+										incr_top=1;
+									}else{
+										incr_top=0;
+									}
+								}else{
+									pi[pino].poc.layno0 = tcp->lay_t;
+									pi[pino].poc.layno1 = tcp->lay_t+1;
+									tcp->lay_t+=1;
+									incr_top=0;
+								}
+								break;
+							case 'P':
+								switch(tcp->prg){
+									case LRCP:
+									case RLCP:
+										if(tcp->prc_t == tcp->prcE){
+											l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+											if(l==1){
+												tcp->prc_t = tcp->prcS;
+												pi[pino].poc.precno0 = tcp->prc_t;
+												pi[pino].poc.precno1 = tcp->prc_t+1;
+												tcp->prc_t+=1;
+												incr_top=1;
+											}else{
+												incr_top=0;
+											}
+										}else{
+											pi[pino].poc.precno0 = tcp->prc_t;
+											pi[pino].poc.precno1 = tcp->prc_t+1;
+											tcp->prc_t+=1;
+											incr_top=0;
+										}
+										break;
+									default:
+										if(tcp->tx0_t >= tcp->txE){
+											if(tcp->ty0_t >= tcp->tyE){
+												l=pi_check_next_level(i-1,cp,tileno,pino,prog);
+												if(l==1){
+													tcp->ty0_t = tcp->tyS;
+													pi[pino].poc.ty0 = tcp->ty0_t;
+													pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
+													tcp->ty0_t = pi[pino].poc.ty1;
+													incr_top=1;resetX=1;
+												}else{
+													incr_top=0;resetX=0;
+												}
+											}else{
+												pi[pino].poc.ty0 = tcp->ty0_t;
+												pi[pino].poc.ty1 = tcp->ty0_t + tcp->dy - (tcp->ty0_t % tcp->dy);
+												tcp->ty0_t = pi[pino].poc.ty1;
+												incr_top=0;resetX=1;
+											}
+											if(resetX==1){
+												tcp->tx0_t = tcp->txS;
+												pi[pino].poc.tx0 = tcp->tx0_t;
+												pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx);
+												tcp->tx0_t = pi[pino].poc.tx1;
+											}
+										}else{
+											pi[pino].poc.tx0 = tcp->tx0_t;
+											pi[pino].poc.tx1 = tcp->tx0_t + tcp->dx- (tcp->tx0_t % tcp->dx);
+											tcp->tx0_t = pi[pino].poc.tx1;
+											incr_top=0;
+										}
+										break;
+								}
+								break;
+					}
+				}
+			}
+		}
+	}
+}
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/pi.h.svn-base ./libopenjpeg/.svn/text-base/pi.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/pi.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/pi.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __PI_H
+#define __PI_H
+/**
+@file pi.h
+@brief Implementation of a packet iterator (PI)
+
+The functions in PI.C have for goal to realize a packet iterator that permits to get the next
+packet following the progression order and change of it. The functions in PI.C are used
+by some function in T2.C.
+*/
+
+/** @defgroup PI PI - Implementation of a packet iterator */
+/*@{*/
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_pi_resolution {
+  int pdx, pdy;
+  int pw, ph;
+} opj_pi_resolution_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_pi_comp {
+  int dx, dy;
+  /** number of resolution levels */
+  int numresolutions;
+  opj_pi_resolution_t *resolutions;
+} opj_pi_comp_t;
+
+/** 
+Packet iterator 
+*/
+typedef struct opj_pi_iterator {
+	/** Enabling Tile part generation*/
+	char tp_on;
+	/** precise if the packet has been already used (usefull for progression order change) */
+	short int *include;
+	/** layer step used to localize the packet in the include vector */
+	int step_l;
+	/** resolution step used to localize the packet in the include vector */
+	int step_r;	
+	/** component step used to localize the packet in the include vector */
+	int step_c;	
+	/** precinct step used to localize the packet in the include vector */
+	int step_p;	
+	/** component that identify the packet */
+	int compno;
+	/** resolution that identify the packet */
+	int resno;
+	/** precinct that identify the packet */
+	int precno;
+	/** layer that identify the packet */
+	int layno;   
+	/** 0 if the first packet */
+	int first;
+	/** progression order change information */
+	opj_poc_t poc;
+	/** number of components in the image */
+	int numcomps;
+	/** Components*/
+	opj_pi_comp_t *comps;
+	int tx0, ty0, tx1, ty1;
+	int x, y, dx, dy;
+} opj_pi_iterator_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a packet iterator for Encoder
+@param image Raw image for which the packets will be listed
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which to list the packets
+@param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
+@return Returns a packet iterator that points to the first packet of the tile
+@see pi_destroy
+*/
+opj_pi_iterator_t *pi_initialise_encode(opj_image_t *image, opj_cp_t *cp, int tileno,J2K_T2_MODE t2_mode);
+/**
+Modify the packet iterator for enabling tile part generation
+@param pi Handle to the packet iterator generated in pi_initialise_encode  
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which to list the packets
+@param tpnum Tile part number of the current tile
+@param tppos The position of the tile part flag in the progression order
+*/
+void pi_create_encode( opj_pi_iterator_t *pi, opj_cp_t *cp,int tileno, int pino,int tpnum, int tppos, J2K_T2_MODE t2_mode);
+/**
+Create a packet iterator for Decoder
+@param image Raw image for which the packets will be listed
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which to list the packets
+@return Returns a packet iterator that points to the first packet of the tile
+@see pi_destroy
+*/
+opj_pi_iterator_t *pi_create_decode(opj_image_t * image, opj_cp_t * cp, int tileno);
+
+/**
+Destroy a packet iterator
+@param pi Previously created packet iterator
+@param cp Coding parameters
+@param tileno Number that identifies the tile for which the packets were listed
+@see pi_create
+*/
+void pi_destroy(opj_pi_iterator_t *pi, opj_cp_t *cp, int tileno);
+
+/**
+Modify the packet iterator to point to the next packet
+@param pi Packet iterator to modify
+@return Returns false if pi pointed to the last packet or else returns true 
+*/
+bool pi_next(opj_pi_iterator_t * pi);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __PI_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/raw.c.svn-base ./libopenjpeg/.svn/text-base/raw.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/raw.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/raw.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,87 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* 
+==========================================================
+   local functions
+==========================================================
+*/
+
+
+/* 
+==========================================================
+   RAW encoding interface
+==========================================================
+*/
+
+opj_raw_t* raw_create(void) {
+	opj_raw_t *raw = (opj_raw_t*)opj_malloc(sizeof(opj_raw_t));
+	return raw;
+}
+
+void raw_destroy(opj_raw_t *raw) {
+	if(raw) {
+		opj_free(raw);
+	}
+}
+
+int raw_numbytes(opj_raw_t *raw) {
+	return raw->bp - raw->start;
+}
+
+void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len) {
+	raw->start = bp;
+	raw->lenmax = len;
+	raw->len = 0;
+	raw->c = 0;
+	raw->ct = 0;
+}
+
+int raw_decode(opj_raw_t *raw) {
+	int d;
+	if (raw->ct == 0) {
+		raw->ct = 8;
+		if (raw->len == raw->lenmax) {
+			raw->c = 0xff;
+		} else {
+			if (raw->c == 0xff) {
+				raw->ct = 7;
+			}
+			raw->c = *(raw->start + raw->len);
+			raw->len++;
+		}
+	}
+	raw->ct--;
+	d = (raw->c >> raw->ct) & 0x01;
+	
+	return d;
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/raw.h.svn-base ./libopenjpeg/.svn/text-base/raw.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/raw.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/raw.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,100 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __RAW_H
+#define __RAW_H
+/**
+@file raw.h
+@brief Implementation of operations for raw encoding (RAW)
+
+The functions in RAW.C have for goal to realize the operation of raw encoding linked
+with the corresponding mode switch.
+*/
+
+/** @defgroup RAW RAW - Implementation of operations for raw encoding */
+/*@{*/
+
+/**
+RAW encoding operations
+*/
+typedef struct opj_raw {
+	/** temporary buffer where bits are coded or decoded */
+	unsigned char c;
+	/** number of bits already read or free to write */
+	unsigned int ct;
+	/** maximum length to decode */
+	unsigned int lenmax;
+	/** length decoded */
+	unsigned int len;
+	/** pointer to the current position in the buffer */
+	unsigned char *bp;
+	/** pointer to the start of the buffer */
+	unsigned char *start;
+	/** pointer to the end of the buffer */
+	unsigned char *end;
+} opj_raw_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new RAW handle 
+@return Returns a new RAW handle if successful, returns NULL otherwise
+*/
+opj_raw_t* raw_create(void);
+/**
+Destroy a previously created RAW handle
+@param raw RAW handle to destroy
+*/
+void raw_destroy(opj_raw_t *raw);
+/**
+Return the number of bytes written/read since initialisation
+@param raw RAW handle to destroy
+@return Returns the number of bytes already encoded
+*/
+int raw_numbytes(opj_raw_t *raw);
+/**
+Initialize the decoder
+@param raw RAW handle
+@param bp Pointer to the start of the buffer from which the bytes will be read
+@param len Length of the input buffer
+*/
+void raw_init_dec(opj_raw_t *raw, unsigned char *bp, int len);
+/**
+Decode a symbol using raw-decoder. Cfr p.506 TAUBMAN
+@param raw RAW handle
+@return Returns the decoded symbol (0 or 1)
+*/
+int raw_decode(opj_raw_t *raw);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __RAW_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1.c.svn-base ./libopenjpeg/.svn/text-base/t1.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t1.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1208 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+#include "t1_luts.h"
+
+/** @defgroup T1 T1 - Implementation of the tier-1 coding */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+static INLINE char t1_getctxno_zc(int f, int orient);
+static char t1_getctxno_sc(int f);
+static INLINE int t1_getctxno_mag(int f);
+static char t1_getspb(int f);
+static short t1_getnmsedec_sig(int x, int bitpos);
+static short t1_getnmsedec_ref(int x, int bitpos);
+static void t1_updateflags(flag_t *flagsp, int s, int stride);
+/**
+Encode significant pass
+*/
+static void t1_enc_sigpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		char type,
+		int vsc);
+/**
+Decode significant pass
+*/
+static void t1_dec_sigpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int oneplushalf,
+		char type,
+		int vsc);
+/**
+Encode significant pass
+*/
+static void t1_enc_sigpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		char type,
+		int cblksty);
+/**
+Decode significant pass
+*/
+static void t1_dec_sigpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		char type,
+		int cblksty);
+/**
+Encode refinement pass
+*/
+static void t1_enc_refpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int bpno,
+		int one,
+		int *nmsedec,
+		char type,
+		int vsc);
+/**
+Decode refinement pass
+*/
+static void t1_dec_refpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int poshalf,
+		int neghalf,
+		char type,
+		int vsc);
+/**
+Encode refinement pass
+*/
+static void t1_enc_refpass(
+		opj_t1_t *t1,
+		int bpno,
+		int *nmsedec,
+		char type,
+		int cblksty);
+/**
+Decode refinement pass
+*/
+static void t1_dec_refpass(
+		opj_t1_t *t1,
+		int bpno,
+		char type,
+		int cblksty);
+/**
+Encode clean-up pass
+*/
+static void t1_enc_clnpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		int partial,
+		int vsc);
+/**
+Decode clean-up pass
+*/
+static void t1_dec_clnpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int oneplushalf,
+		int partial,
+		int vsc);
+/**
+Encode clean-up pass
+*/
+static void t1_enc_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		int cblksty);
+/**
+Decode clean-up pass
+*/
+static void t1_dec_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int cblksty);
+static double t1_getwmsedec(
+		int nmsedec,
+		int compno,
+		int level,
+		int orient,
+		int bpno,
+		int qmfbid,
+		double stepsize,
+		int numcomps);
+/**
+Encode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param compno Component number
+@param level
+@param qmfbid
+@param stepsize
+@param cblksty Code-block style
+@param numcomps
+@param tile
+*/
+static void t1_encode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_enc_t* cblk,
+		int orient,
+		int compno,
+		int level,
+		int qmfbid,
+		double stepsize,
+		int cblksty,
+		int numcomps,
+		opj_tcd_tile_t * tile);
+/**
+Decode 1 code-block
+@param t1 T1 handle
+@param cblk Code-block coding parameters
+@param orient
+@param roishift Region of interest shifting value
+@param cblksty Code-block style
+*/
+static void t1_decode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_dec_t* cblk,
+		int orient,
+		int roishift,
+		int cblksty);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+static char t1_getctxno_zc(int f, int orient) {
+	return lut_ctxno_zc[(orient << 8) | (f & T1_SIG_OTH)];
+}
+
+static char t1_getctxno_sc(int f) {
+	return lut_ctxno_sc[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
+}
+
+static int t1_getctxno_mag(int f) {
+	int tmp1 = (f & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+	int tmp2 = (f & T1_REFINE) ? T1_CTXNO_MAG + 2 : tmp1;
+	return (tmp2);
+}
+
+static char t1_getspb(int f) {
+	return lut_spb[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
+}
+
+static short t1_getnmsedec_sig(int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return lut_nmsedec_sig[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+	
+	return lut_nmsedec_sig0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static short t1_getnmsedec_ref(int x, int bitpos) {
+	if (bitpos > T1_NMSEDEC_FRACBITS) {
+		return lut_nmsedec_ref[(x >> (bitpos - T1_NMSEDEC_FRACBITS)) & ((1 << T1_NMSEDEC_BITS) - 1)];
+	}
+
+    return lut_nmsedec_ref0[x & ((1 << T1_NMSEDEC_BITS) - 1)];
+}
+
+static void t1_updateflags(flag_t *flagsp, int s, int stride) {
+	flag_t *np = flagsp - stride;
+	flag_t *sp = flagsp + stride;
+
+	static const flag_t mod[] = {
+		T1_SIG_S, T1_SIG_S|T1_SGN_S,
+		T1_SIG_E, T1_SIG_E|T1_SGN_E,
+		T1_SIG_W, T1_SIG_W|T1_SGN_W,
+		T1_SIG_N, T1_SIG_N|T1_SGN_N
+	};
+
+	np[-1] |= T1_SIG_SE;
+	np[0]  |= mod[s];
+	np[1]  |= T1_SIG_SW;
+
+	flagsp[-1] |= mod[s+2];
+	flagsp[0]  |= T1_SIG;
+	flagsp[1]  |= mod[s+4];
+
+	sp[-1] |= T1_SIG_NE;
+	sp[0]  |= mod[s+6];
+	sp[1]  |= T1_SIG_NW;
+}
+
+static void t1_enc_sigpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		char type,
+		int vsc)
+{
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_encode(mqc, v);
+		}
+		if (v) {
+			v = *datap < 0 ? 1 : 0;
+			*nmsedec +=	t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
+			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+				mqc_bypass_enc(mqc, v);
+			} else {
+				mqc_encode(mqc, v ^ t1_getspb(flag));
+			}
+			t1_updateflags(flagsp, v, t1->flags_stride);
+		}
+		*flagsp |= T1_VISIT;
+	}
+}
+
+static void t1_dec_sigpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int oneplushalf,
+		char type,
+		int vsc)
+{
+	int v, flag;
+	
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
+		if (type == T1_TYPE_RAW) {
+			if (raw_decode(raw)) {
+				v = raw_decode(raw);	/* ESSAI */
+				*datap = v ? -oneplushalf : oneplushalf;
+				t1_updateflags(flagsp, v, t1->flags_stride);
+			}
+		} else {
+			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
+			if (mqc_decode(mqc)) {
+				mqc_setcurctx(mqc, t1_getctxno_sc(flag));
+				v = mqc_decode(mqc) ^ t1_getspb(flag);
+				*datap = v ? -oneplushalf : oneplushalf;
+				t1_updateflags(flagsp, v, t1->flags_stride);
+			}
+		}
+		*flagsp |= T1_VISIT;
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_sigpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		char type,
+		int cblksty)
+{
+	int i, j, k, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_sigpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						orient,
+						bpno,
+						one,
+						nmsedec,
+						type,
+						vsc);
+			}
+		}
+	}
+}
+
+static void t1_dec_sigpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		char type,
+		int cblksty)
+{
+	int i, j, k, one, half, oneplushalf, vsc;
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_sigpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						orient,
+						oneplushalf,
+						type,
+						vsc);
+			}
+		}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_refpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int bpno,
+		int one,
+		int *nmsedec,
+		char type,
+		int vsc)
+{
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		*nmsedec += t1_getnmsedec_ref(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
+		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
+		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
+			mqc_bypass_enc(mqc, v);
+		} else {
+			mqc_encode(mqc, v);
+		}
+		*flagsp |= T1_REFINE;
+	}
+}
+
+static void t1_dec_refpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int poshalf,
+		int neghalf,
+		char type,
+		int vsc)
+{
+	int v, t, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
+		if (type == T1_TYPE_RAW) {
+			v = raw_decode(raw);
+		} else {
+			v = mqc_decode(mqc);
+		}
+		t = v ? poshalf : neghalf;
+		*datap += *datap < 0 ? -t : t;
+		*flagsp |= T1_REFINE;
+	}
+}				/* VSC and  BYPASS by Antonin  */
+
+static void t1_enc_refpass(
+		opj_t1_t *t1,
+		int bpno,
+		int *nmsedec,
+		char type,
+		int cblksty)
+{
+	int i, j, k, one, vsc;
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_refpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						bpno,
+						one,
+						nmsedec,
+						type,
+						vsc);
+			}
+		}
+	}
+}
+
+static void t1_dec_refpass(
+		opj_t1_t *t1,
+		int bpno,
+		char type,
+		int cblksty)
+{
+	int i, j, k, one, poshalf, neghalf;
+	int vsc;
+	one = 1 << bpno;
+	poshalf = one >> 1;
+	neghalf = bpno > 0 ? -poshalf : -1;
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			for (j = k; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_refpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						poshalf,
+						neghalf,
+						type,
+						vsc);
+			}
+		}
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_clnpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int bpno,
+		int one,
+		int *nmsedec,
+		int partial,
+		int vsc)
+{
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(*flagsp & (T1_SIG | T1_VISIT))) {
+		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
+		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_encode(mqc, v);
+		if (v) {
+LABEL_PARTIAL:
+			*nmsedec += t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
+			v = *datap < 0 ? 1 : 0;
+			mqc_encode(mqc, v ^ t1_getspb(flag));
+			t1_updateflags(flagsp, v, t1->flags_stride);
+		}
+	}
+	*flagsp &= ~T1_VISIT;
+}
+
+static void t1_dec_clnpass_step(
+		opj_t1_t *t1,
+		flag_t *flagsp,
+		int *datap,
+		int orient,
+		int oneplushalf,
+		int partial,
+		int vsc)
+{
+	int v, flag;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
+	if (partial) {
+		goto LABEL_PARTIAL;
+	}
+	if (!(flag & (T1_SIG | T1_VISIT))) {
+		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
+		if (mqc_decode(mqc)) {
+LABEL_PARTIAL:
+			mqc_setcurctx(mqc, t1_getctxno_sc(flag));
+			v = mqc_decode(mqc) ^ t1_getspb(flag);
+			*datap = v ? -oneplushalf : oneplushalf;
+			t1_updateflags(flagsp, v, t1->flags_stride);
+		}
+	}
+	*flagsp &= ~T1_VISIT;
+}				/* VSC and  BYPASS by Antonin */
+
+static void t1_enc_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int *nmsedec,
+		int cblksty)
+{
+	int i, j, k, one, agg, runlen, vsc;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	*nmsedec = 0;
+	one = 1 << (bpno + T1_NMSEDEC_FRACBITS);
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			if (k + 3 < t1->h) {
+				if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| (MACRO_t1_flags(1 + k + 3,1 + i) 
+						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				} else {
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 3,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				}
+			} else {
+				agg = 0;
+			}
+			if (agg) {
+				for (runlen = 0; runlen < 4; ++runlen) {
+					if (int_abs(t1->data[((k + runlen)*t1->w) + i]) & one)
+						break;
+				}
+				mqc_setcurctx(mqc, T1_CTXNO_AGG);
+				mqc_encode(mqc, runlen != 4);
+				if (runlen == 4) {
+					continue;
+				}
+				mqc_setcurctx(mqc, T1_CTXNO_UNI);
+				mqc_encode(mqc, runlen >> 1);
+				mqc_encode(mqc, runlen & 1);
+			} else {
+				runlen = 0;
+			}
+			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_enc_clnpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						orient,
+						bpno,
+						one,
+						nmsedec,
+						agg && (j == k + runlen),
+						vsc);
+			}
+		}
+	}
+}
+
+static void t1_dec_clnpass(
+		opj_t1_t *t1,
+		int bpno,
+		int orient,
+		int cblksty)
+{
+	int i, j, k, one, half, oneplushalf, agg, runlen, vsc;
+	int segsym = cblksty & J2K_CCP_CBLKSTY_SEGSYM;
+	
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+	
+	one = 1 << bpno;
+	half = one >> 1;
+	oneplushalf = one | half;
+	for (k = 0; k < t1->h; k += 4) {
+		for (i = 0; i < t1->w; ++i) {
+			if (k + 3 < t1->h) {
+				if (cblksty & J2K_CCP_CBLKSTY_VSC) {
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| (MACRO_t1_flags(1 + k + 3,1 + i) 
+						& (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW |	T1_SGN_S))) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				} else {
+					agg = !(MACRO_t1_flags(1 + k,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 1,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 2,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH)
+						|| MACRO_t1_flags(1 + k + 3,1 + i) & (T1_SIG | T1_VISIT | T1_SIG_OTH));
+				}
+			} else {
+				agg = 0;
+			}
+			if (agg) {
+				mqc_setcurctx(mqc, T1_CTXNO_AGG);
+				if (!mqc_decode(mqc)) {
+					continue;
+				}
+				mqc_setcurctx(mqc, T1_CTXNO_UNI);
+				runlen = mqc_decode(mqc);
+				runlen = (runlen << 1) | mqc_decode(mqc);
+			} else {
+				runlen = 0;
+			}
+			for (j = k + runlen; j < k + 4 && j < t1->h; ++j) {
+				vsc = ((cblksty & J2K_CCP_CBLKSTY_VSC) && (j == k + 3 || j == t1->h - 1)) ? 1 : 0;
+				t1_dec_clnpass_step(
+						t1,
+						&t1->flags[((j+1) * t1->flags_stride) + i + 1],
+						&t1->data[(j * t1->w) + i],
+						orient,
+						oneplushalf,
+						agg && (j == k + runlen),
+						vsc);
+			}
+		}
+	}
+	if (segsym) {
+		int v = 0;
+		mqc_setcurctx(mqc, T1_CTXNO_UNI);
+		v = mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		v = (v << 1) | mqc_decode(mqc);
+		/*
+		if (v!=0xa) {
+			opj_event_msg(t1->cinfo, EVT_WARNING, "Bad segmentation symbol %x\n", v);
+		} 
+		*/
+	}
+}				/* VSC and  BYPASS by Antonin */
+
+
+/** mod fixed_quality */
+static double t1_getwmsedec(
+		int nmsedec,
+		int compno,
+		int level,
+		int orient,
+		int bpno,
+		int qmfbid,
+		double stepsize,
+		int numcomps)
+{
+	double w1, w2, wmsedec;
+	if (qmfbid == 1) {
+		w1 = (numcomps > 1) ? mct_getnorm(compno) : 1.0;
+		w2 = dwt_getnorm(level, orient);
+	} else {			/* if (qmfbid == 0) */
+		w1 = (numcomps > 1) ? mct_getnorm_real(compno) : 1.0;
+		w2 = dwt_getnorm_real(level, orient);
+	}
+	wmsedec = w1 * w2 * stepsize * (1 << bpno);
+	wmsedec *= wmsedec * nmsedec / 8192.0;
+	
+	return wmsedec;
+}
+
+static bool allocate_buffers(
+		opj_t1_t *t1,
+		int w,
+		int h)
+{
+	int datasize=w * h;
+	int flagssize;
+
+	if(datasize > t1->datasize){
+		opj_aligned_free(t1->data);
+		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
+		if(!t1->data){
+			return false;
+		}
+		t1->datasize=datasize;
+	}
+	memset(t1->data,0,datasize * sizeof(int));
+
+	t1->flags_stride=w+2;
+	flagssize=t1->flags_stride * (h+2);
+
+	if(flagssize > t1->flagssize){
+		opj_aligned_free(t1->flags);
+		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
+		if(!t1->flags){
+			return false;
+		}
+		t1->flagssize=flagssize;
+	}
+	memset(t1->flags,0,flagssize * sizeof(flag_t));
+
+	t1->w=w;
+	t1->h=h;
+
+	return true;
+}
+
+/** mod fixed_quality */
+static void t1_encode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_enc_t* cblk,
+		int orient,
+		int compno,
+		int level,
+		int qmfbid,
+		double stepsize,
+		int cblksty,
+		int numcomps,
+		opj_tcd_tile_t * tile)
+{
+	double cumwmsedec = 0.0;
+
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+
+	int passno, bpno, passtype;
+	int nmsedec = 0;
+	int i, max;
+	char type = T1_TYPE_MQ;
+	double tempwmsedec;
+
+	max = 0;
+	for (i = 0; i < t1->w * t1->h; ++i) {
+		int tmp = abs(t1->data[i]);
+		max = int_max(max, tmp);
+	}
+
+	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
+	
+	bpno = cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_resetstates(mqc);
+	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+	mqc_init_enc(mqc, cblk->data);
+	
+	for (passno = 0; bpno >= 0; ++passno) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		int correction = 3;
+		type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		
+		switch (passtype) {
+			case 0:
+				t1_enc_sigpass(t1, bpno, orient, &nmsedec, type, cblksty);
+				break;
+			case 1:
+				t1_enc_refpass(t1, bpno, &nmsedec, type, cblksty);
+				break;
+			case 2:
+				t1_enc_clnpass(t1, bpno, orient, &nmsedec, cblksty);
+				/* code switch SEGMARK (i.e. SEGSYM) */
+				if (cblksty & J2K_CCP_CBLKSTY_SEGSYM)
+					mqc_segmark_enc(mqc);
+				break;
+		}
+		
+		/* fixed_quality */
+		tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+		cumwmsedec += tempwmsedec;
+		tile->distotile += tempwmsedec;
+		
+		/* Code switch "RESTART" (i.e. TERMALL) */
+		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
+			if (type == T1_TYPE_RAW) {
+				mqc_flush(mqc);
+				correction = 1;
+				/* correction = mqc_bypass_flush_enc(); */
+			} else {			/* correction = mqc_restart_enc(); */
+				mqc_flush(mqc);
+				correction = 1;
+			}
+			pass->term = 1;
+		} else {
+			if (((bpno < (cblk->numbps - 4) && (passtype > 0)) 
+				|| ((bpno == (cblk->numbps - 4)) && (passtype == 2))) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) {
+				if (type == T1_TYPE_RAW) {
+					mqc_flush(mqc);
+					correction = 1;
+					/* correction = mqc_bypass_flush_enc(); */
+				} else {		/* correction = mqc_restart_enc(); */
+					mqc_flush(mqc);
+					correction = 1;
+				}
+				pass->term = 1;
+			} else {
+				pass->term = 0;
+			}
+		}
+		
+		if (++passtype == 3) {
+			passtype = 0;
+			bpno--;
+		}
+		
+		if (pass->term && bpno > 0) {
+			type = ((bpno < (cblk->numbps - 4)) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+			if (type == T1_TYPE_RAW)
+				mqc_bypass_init_enc(mqc);
+			else
+				mqc_restart_init_enc(mqc);
+		}
+		
+		pass->distortiondec = cumwmsedec;
+		pass->rate = mqc_numbytes(mqc) + correction;	/* FIXME */
+		
+		/* Code-switch "RESET" */
+		if (cblksty & J2K_CCP_CBLKSTY_RESET)
+			mqc_reset_enc(mqc);
+	}
+	
+	/* Code switch "ERTERM" (i.e. PTERM) */
+	if (cblksty & J2K_CCP_CBLKSTY_PTERM)
+		mqc_erterm_enc(mqc);
+	else /* Default coding */ if (!(cblksty & J2K_CCP_CBLKSTY_LAZY))
+		mqc_flush(mqc);
+	
+	cblk->totalpasses = passno;
+
+	for (passno = 0; passno<cblk->totalpasses; passno++) {
+		opj_tcd_pass_t *pass = &cblk->passes[passno];
+		if (pass->rate > mqc_numbytes(mqc))
+			pass->rate = mqc_numbytes(mqc);
+		/*Preventing generation of FF as last data byte of a pass*/
+		if((pass->rate>1) && (cblk->data[pass->rate - 1] == 0xFF)){
+			pass->rate--;
+		}
+		pass->len = pass->rate - (passno == 0 ? 0 : cblk->passes[passno - 1].rate);		
+	}
+}
+
+static void t1_decode_cblk(
+		opj_t1_t *t1,
+		opj_tcd_cblk_dec_t* cblk,
+		int orient,
+		int roishift,
+		int cblksty)
+{
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+
+	int bpno, passtype;
+	int segno, passno;
+	char type = T1_TYPE_MQ; /* BYPASS mode */
+
+	if(!allocate_buffers(
+				t1,
+				cblk->x1 - cblk->x0,
+				cblk->y1 - cblk->y0))
+	{
+		return;
+	}
+
+	bpno = roishift + cblk->numbps - 1;
+	passtype = 2;
+	
+	mqc_resetstates(mqc);
+	mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);
+	mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+	mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+	
+	for (segno = 0; segno < cblk->numsegs; ++segno) {
+		opj_tcd_seg_t *seg = &cblk->segs[segno];
+		
+		/* BYPASS mode */
+		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		/* FIXME: slviewer gets here with a null pointer. Why? Partially downloaded and/or corrupt textures? */
+		if(seg->data == NULL){
+			continue;
+		}
+		if (type == T1_TYPE_RAW) {
+			raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
+		} else {
+			mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len);
+		}
+		
+		for (passno = 0; passno < seg->numpasses; ++passno) {
+			switch (passtype) {
+				case 0:
+					t1_dec_sigpass(t1, bpno+1, orient, type, cblksty);
+					break;
+				case 1:
+					t1_dec_refpass(t1, bpno+1, type, cblksty);
+					break;
+				case 2:
+					t1_dec_clnpass(t1, bpno+1, orient, cblksty);
+					break;
+			}
+			
+			if ((cblksty & J2K_CCP_CBLKSTY_RESET) && type == T1_TYPE_MQ) {
+				mqc_resetstates(mqc);
+				mqc_setstate(mqc, T1_CTXNO_UNI, 0, 46);				
+				mqc_setstate(mqc, T1_CTXNO_AGG, 0, 3);
+				mqc_setstate(mqc, T1_CTXNO_ZC, 0, 4);
+			}
+			if (++passtype == 3) {
+				passtype = 0;
+				bpno--;
+			}
+		}
+	}
+}
+
+/* ----------------------------------------------------------------------- */
+
+opj_t1_t* t1_create(opj_common_ptr cinfo) {
+	opj_t1_t *t1 = (opj_t1_t*) opj_malloc(sizeof(opj_t1_t));
+	if(!t1)
+		return NULL;
+
+	t1->cinfo = cinfo;
+	/* create MQC and RAW handles */
+	t1->mqc = mqc_create();
+	t1->raw = raw_create();
+
+	t1->data=NULL;
+	t1->flags=NULL;
+	t1->datasize=0;
+	t1->flagssize=0;
+
+	return t1;
+}
+
+void t1_destroy(opj_t1_t *t1) {
+	if(t1) {
+		/* destroy MQC and RAW handles */
+		mqc_destroy(t1->mqc);
+		raw_destroy(t1->raw);
+		opj_aligned_free(t1->data);
+		opj_aligned_free(t1->flags);
+		opj_free(t1);
+	}
+}
+
+void t1_encode_cblks(
+		opj_t1_t *t1,
+		opj_tcd_tile_t *tile,
+		opj_tcp_t *tcp)
+{
+	int compno, resno, bandno, precno, cblkno;
+
+	tile->distotile = 0;		/* fixed_quality */
+
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_tccp_t* tccp = &tcp->tccps[compno];
+		int tile_w = tilec->x1 - tilec->x0;
+
+		for (resno = 0; resno < tilec->numresolutions; ++resno) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+			for (bandno = 0; bandno < res->numbands; ++bandno) {
+				opj_tcd_band_t* restrict band = &res->bands[bandno];
+
+				for (precno = 0; precno < res->pw * res->ph; ++precno) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
+						opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+						int* restrict datap;
+						int* restrict tiledp;
+						int cblk_w;
+						int cblk_h;
+						int i, j;
+
+						int x = cblk->x0 - band->x0;
+						int y = cblk->y0 - band->y0;
+						if (band->bandno & 1) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							x += pres->x1 - pres->x0;
+						}
+						if (band->bandno & 2) {
+							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
+							y += pres->y1 - pres->y0;
+						}
+
+						if(!allocate_buffers(
+									t1,
+									cblk->x1 - cblk->x0,
+									cblk->y1 - cblk->y0))
+						{
+							return;
+						}
+
+						datap=t1->data;
+						cblk_w = t1->w;
+						cblk_h = t1->h;
+
+						tiledp=&tilec->data[(y * tile_w) + x];
+						if (tccp->qmfbid == 1) {
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] = tmp << T1_NMSEDEC_FRACBITS;
+								}
+							}
+						} else {		/* if (tccp->qmfbid == 0) */
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] =
+										fix_mul(
+										tmp,
+										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (11 - T1_NMSEDEC_FRACBITS);
+								}
+							}
+						}
+
+						t1_encode_cblk(
+								t1,
+								cblk,
+								band->bandno,
+								compno,
+								tilec->numresolutions - 1 - resno,
+								tccp->qmfbid,
+								band->stepsize,
+								tccp->cblksty,
+								tile->numcomps,
+								tile);
+
+					} /* cblkno */
+				} /* precno */
+			} /* bandno */
+		} /* resno  */
+	} /* compno  */
+}
+
+void t1_decode_cblks(
+		opj_t1_t* t1,
+		opj_tcd_tilecomp_t* tilec,
+		opj_tccp_t* tccp)
+{
+	int resno, bandno, precno, cblkno;
+
+	int tile_w = tilec->x1 - tilec->x0;
+
+	for (resno = 0; resno < tilec->numresolutions; ++resno) {
+		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
+
+		for (bandno = 0; bandno < res->numbands; ++bandno) {
+			opj_tcd_band_t* restrict band = &res->bands[bandno];
+
+			for (precno = 0; precno < res->pw * res->ph; ++precno) {
+				opj_tcd_precinct_t* precinct = &band->precincts[precno];
+
+				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
+					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
+					int* restrict datap;
+					void* restrict tiledp;
+					int cblk_w, cblk_h;
+					int x, y;
+					int i, j;
+
+					t1_decode_cblk(
+							t1,
+							cblk,
+							band->bandno,
+							tccp->roishift,
+							tccp->cblksty);
+
+					x = cblk->x0 - band->x0;
+					y = cblk->y0 - band->y0;
+					if (band->bandno & 1) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						x += pres->x1 - pres->x0;
+					}
+					if (band->bandno & 2) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						y += pres->y1 - pres->y0;
+					}
+
+					datap=t1->data;
+					cblk_w = t1->w;
+					cblk_h = t1->h;
+
+					if (tccp->roishift) {
+						int thresh = 1 << tccp->roishift;
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int val = datap[(j * cblk_w) + i];
+								int mag = abs(val);
+								if (mag >= thresh) {
+									mag >>= tccp->roishift;
+									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
+								}
+							}
+						}
+					}
+
+					tiledp=(void*)&tilec->data[(y * tile_w) + x];
+					if (tccp->qmfbid == 1) {
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int tmp = datap[(j * cblk_w) + i];
+								((int*)tiledp)[(j * tile_w) + i] = tmp / 2;
+							}
+						}
+					} else {		/* if (tccp->qmfbid == 0) */
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								float tmp = datap[(j * cblk_w) + i] * band->stepsize;
+								((float*)tiledp)[(j * tile_w) + i] = tmp;
+							}
+						}
+					}
+					opj_free(cblk->data);
+					opj_free(cblk->segs);
+				} /* cblkno */
+				opj_free(precinct->cblks.dec);
+			} /* precno */
+		} /* bandno */
+	} /* resno */
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1_generate_luts.c.svn-base ./libopenjpeg/.svn/text-base/t1_generate_luts.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1_generate_luts.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t1_generate_luts.c.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,275 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2007, Callum Lerwick <seg@haxxed.com>
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+#include <math.h>
+
+static int t1_init_ctxno_zc(int f, int orient) {
+	int h, v, d, n, t, hv;
+	n = 0;
+	h = ((f & T1_SIG_W) != 0) + ((f & T1_SIG_E) != 0);
+	v = ((f & T1_SIG_N) != 0) + ((f & T1_SIG_S) != 0);
+	d = ((f & T1_SIG_NW) != 0) + ((f & T1_SIG_NE) != 0) + ((f & T1_SIG_SE) != 0) + ((f & T1_SIG_SW) != 0);
+
+	switch (orient) {
+		case 2:
+			t = h;
+			h = v;
+			v = t;
+		case 0:
+		case 1:
+			if (!h) {
+				if (!v) {
+					if (!d)
+						n = 0;
+					else if (d == 1)
+						n = 1;
+					else
+						n = 2;
+				} else if (v == 1) {
+					n = 3;
+				} else {
+					n = 4;
+				}
+			} else if (h == 1) {
+				if (!v) {
+					if (!d)
+						n = 5;
+					else
+						n = 6;
+				} else {
+					n = 7;
+				}
+			} else
+				n = 8;
+			break;
+		case 3:
+			hv = h + v;
+			if (!d) {
+				if (!hv) {
+					n = 0;
+				} else if (hv == 1) {
+					n = 1;
+				} else {
+					n = 2;
+				}
+			} else if (d == 1) {
+				if (!hv) {
+					n = 3;
+				} else if (hv == 1) {
+					n = 4;
+				} else {
+					n = 5;
+				}
+			} else if (d == 2) {
+				if (!hv) {
+					n = 6;
+				} else {
+					n = 7;
+				}
+			} else {
+				n = 8;
+			}
+			break;
+	}
+
+	return (T1_CTXNO_ZC + n);
+}
+
+static int t1_init_ctxno_sc(int f) {
+	int hc, vc, n;
+	n = 0;
+
+	hc = int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+				T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+			1) - int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+					(T1_SIG_E | T1_SGN_E)) +
+				((f & (T1_SIG_W | T1_SGN_W)) ==
+				 (T1_SIG_W | T1_SGN_W)), 1);
+
+	vc = int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+				T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+			1) - int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+					(T1_SIG_N | T1_SGN_N)) +
+				((f & (T1_SIG_S | T1_SGN_S)) ==
+				 (T1_SIG_S | T1_SGN_S)), 1);
+
+	if (hc < 0) {
+		hc = -hc;
+		vc = -vc;
+	}
+	if (!hc) {
+		if (vc == -1)
+			n = 1;
+		else if (!vc)
+			n = 0;
+		else
+			n = 1;
+	} else if (hc == 1) {
+		if (vc == -1)
+			n = 2;
+		else if (!vc)
+			n = 3;
+		else
+			n = 4;
+	}
+
+	return (T1_CTXNO_SC + n);
+}
+
+static int t1_init_spb(int f) {
+	int hc, vc, n;
+
+	hc = int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+				T1_SIG_E) + ((f & (T1_SIG_W | T1_SGN_W)) == T1_SIG_W),
+			1) - int_min(((f & (T1_SIG_E | T1_SGN_E)) ==
+					(T1_SIG_E | T1_SGN_E)) +
+				((f & (T1_SIG_W | T1_SGN_W)) ==
+				 (T1_SIG_W | T1_SGN_W)), 1);
+
+	vc = int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+				T1_SIG_N) + ((f & (T1_SIG_S | T1_SGN_S)) == T1_SIG_S),
+			1) - int_min(((f & (T1_SIG_N | T1_SGN_N)) ==
+					(T1_SIG_N | T1_SGN_N)) +
+				((f & (T1_SIG_S | T1_SGN_S)) ==
+				 (T1_SIG_S | T1_SGN_S)), 1);
+
+	if (!hc && !vc)
+		n = 0;
+	else
+		n = (!(hc > 0 || (!hc && vc > 0)));
+
+	return n;
+}
+
+void dump_array16(int array[],int size){
+	int i;
+	--size;
+	for (i = 0; i < size; ++i) {
+		printf("0x%04x, ", array[i]);
+		if(!((i+1)&0x7))
+			printf("\n  ");
+	}
+	printf("0x%04x\n};\n\n", array[size]);
+}
+
+int main(){
+	int i, j;
+	double u, v, t;
+
+	int lut_ctxno_zc[1024];
+	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
+	int lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS];
+
+	printf("/* This file was automatically generated by t1_generate_luts.c */\n\n");
+
+	// lut_ctxno_zc
+	for (j = 0; j < 4; ++j) {
+		for (i = 0; i < 256; ++i) {
+			int orient = j;
+			if (orient == 2) {
+				orient = 1;
+			} else if (orient == 1) {
+				orient = 2;
+			}
+			lut_ctxno_zc[(orient << 8) | i] = t1_init_ctxno_zc(i, j);
+		}
+	}
+
+	printf("static char lut_ctxno_zc[1024] = {\n  ");
+	for (i = 0; i < 1023; ++i) {
+		printf("%i, ", lut_ctxno_zc[i]);
+		if(!((i+1)&0x1f))
+			printf("\n  ");
+	}
+	printf("%i\n};\n\n", lut_ctxno_zc[1023]);
+
+	// lut_ctxno_sc
+	printf("static char lut_ctxno_sc[256] = {\n  ");
+	for (i = 0; i < 255; ++i) {
+		printf("0x%x, ", t1_init_ctxno_sc(i << 4));
+		if(!((i+1)&0xf))
+			printf("\n  ");
+	}
+	printf("0x%x\n};\n\n", t1_init_ctxno_sc(255 << 4));
+
+	// lut_spb
+	printf("static char lut_spb[256] = {\n  ");
+	for (i = 0; i < 255; ++i) {
+		printf("%i, ", t1_init_spb(i << 4));
+		if(!((i+1)&0x1f))
+			printf("\n  ");
+	}
+	printf("%i\n};\n\n", t1_init_spb(255 << 4));
+
+	/* FIXME FIXME FIXME */
+	/* fprintf(stdout,"nmsedec luts:\n"); */
+	for (i = 0; i < (1 << T1_NMSEDEC_BITS); ++i) {
+		t = i / pow(2, T1_NMSEDEC_FRACBITS);
+		u = t;
+		v = t - 1.5;
+		lut_nmsedec_sig[i] = 
+			int_max(0, 
+					(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		lut_nmsedec_sig0[i] =
+			int_max(0,
+					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		u = t - 1.0;
+		if (i & (1 << (T1_NMSEDEC_BITS - 1))) {
+			v = t - 1.5;
+		} else {
+			v = t - 0.5;
+		}
+		lut_nmsedec_ref[i] =
+			int_max(0,
+					(int) (floor((u * u - v * v) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+		lut_nmsedec_ref0[i] =
+			int_max(0,
+					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
+	}
+
+	printf("static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(&lut_nmsedec_sig, 1 << T1_NMSEDEC_BITS);
+
+	printf("static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(&lut_nmsedec_sig0, 1 << T1_NMSEDEC_BITS);
+
+	printf("static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(&lut_nmsedec_ref, 1 << T1_NMSEDEC_BITS);
+
+	printf("static short lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	dump_array16(&lut_nmsedec_ref0, 1 << T1_NMSEDEC_BITS);
+
+	return 0;
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1.h.svn-base ./libopenjpeg/.svn/text-base/t1.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t1.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,147 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __T1_H
+#define __T1_H
+/**
+@file t1.h
+@brief Implementation of the tier-1 coding (coding of code-block coefficients) (T1)
+
+The functions in T1.C have for goal to realize the tier-1 coding operation. The functions
+in T1.C are used by some function in TCD.C.
+*/
+
+/** @defgroup T1 T1 - Implementation of the tier-1 coding */
+/*@{*/
+
+/* ----------------------------------------------------------------------- */
+#define T1_NMSEDEC_BITS 7
+
+#define T1_SIG_NE 0x0001	/**< Context orientation : North-East direction */
+#define T1_SIG_SE 0x0002	/**< Context orientation : South-East direction */
+#define T1_SIG_SW 0x0004	/**< Context orientation : South-West direction */
+#define T1_SIG_NW 0x0008	/**< Context orientation : North-West direction */
+#define T1_SIG_N 0x0010		/**< Context orientation : North direction */
+#define T1_SIG_E 0x0020		/**< Context orientation : East direction */
+#define T1_SIG_S 0x0040		/**< Context orientation : South direction */
+#define T1_SIG_W 0x0080		/**< Context orientation : West direction */
+#define T1_SIG_OTH (T1_SIG_N|T1_SIG_NE|T1_SIG_E|T1_SIG_SE|T1_SIG_S|T1_SIG_SW|T1_SIG_W|T1_SIG_NW)
+#define T1_SIG_PRIM (T1_SIG_N|T1_SIG_E|T1_SIG_S|T1_SIG_W)
+
+#define T1_SGN_N 0x0100
+#define T1_SGN_E 0x0200
+#define T1_SGN_S 0x0400
+#define T1_SGN_W 0x0800
+#define T1_SGN (T1_SGN_N|T1_SGN_E|T1_SGN_S|T1_SGN_W)
+
+#define T1_SIG 0x1000
+#define T1_REFINE 0x2000
+#define T1_VISIT 0x4000
+
+#define T1_NUMCTXS_ZC 9
+#define T1_NUMCTXS_SC 5
+#define T1_NUMCTXS_MAG 3
+#define T1_NUMCTXS_AGG 1
+#define T1_NUMCTXS_UNI 1
+
+#define T1_CTXNO_ZC 0
+#define T1_CTXNO_SC (T1_CTXNO_ZC+T1_NUMCTXS_ZC)
+#define T1_CTXNO_MAG (T1_CTXNO_SC+T1_NUMCTXS_SC)
+#define T1_CTXNO_AGG (T1_CTXNO_MAG+T1_NUMCTXS_MAG)
+#define T1_CTXNO_UNI (T1_CTXNO_AGG+T1_NUMCTXS_AGG)
+#define T1_NUMCTXS (T1_CTXNO_UNI+T1_NUMCTXS_UNI)
+
+#define T1_NMSEDEC_FRACBITS (T1_NMSEDEC_BITS-1)
+
+#define T1_TYPE_MQ 0	/**< Normal coding using entropy coder */
+#define T1_TYPE_RAW 1	/**< No encoding the information is store under raw format in codestream (mode switch RAW)*/
+
+/* ----------------------------------------------------------------------- */
+
+typedef short flag_t;
+
+/**
+Tier-1 coding (coding of code-block coefficients)
+*/
+typedef struct opj_t1 {
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** MQC component */
+	opj_mqc_t *mqc;
+	/** RAW component */
+	opj_raw_t *raw;
+
+	int *data;
+	flag_t *flags;
+	int w;
+	int h;
+	int datasize;
+	int flagssize;
+	int flags_stride;
+} opj_t1_t;
+
+#define MACRO_t1_flags(x,y) t1->flags[((x)*(t1->flags_stride))+(y)]
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a new T1 handle 
+and initialize the look-up tables of the Tier-1 coder/decoder
+@return Returns a new T1 handle if successful, returns NULL otherwise
+@see t1_init_luts
+*/
+opj_t1_t* t1_create(opj_common_ptr cinfo);
+/**
+Destroy a previously created T1 handle
+@param t1 T1 handle to destroy
+*/
+void t1_destroy(opj_t1_t *t1);
+/**
+Encode the code-blocks of a tile
+@param t1 T1 handle
+@param tile The tile to encode
+@param tcp Tile coding parameters
+*/
+void t1_encode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+/**
+Decode the code-blocks of a tile
+@param t1 T1 handle
+@param tile The tile to decode
+@param tcp Tile coding parameters
+*/
+void t1_decode_cblks(opj_t1_t* t1, opj_tcd_tilecomp_t* tilec, opj_tccp_t* tccp);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __T1_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1_luts.h.svn-base ./libopenjpeg/.svn/text-base/t1_luts.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t1_luts.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t1_luts.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,143 @@
+/* This file was automatically generated by t1_generate_luts.c */
+
+static char lut_ctxno_zc[1024] = {
+  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  0, 3, 3, 6, 3, 6, 6, 8, 3, 6, 6, 8, 6, 8, 8, 8, 1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 
+  1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
+  2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8
+};
+
+static char lut_ctxno_sc[256] = {
+  0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xb, 0xc, 0xb, 0xd, 0xc, 0xd, 0xc, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xd, 0x9, 0xa, 0xd, 0xd, 0xa, 0xa, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0x9, 0xb, 0xc, 0xc, 0xb, 0x9, 0xa, 0xd, 0xc, 0xa, 0x9, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0x9, 0xb, 0xc, 0xc, 0xd, 0xc, 0xd, 0xb, 0xc, 0xb, 0xc, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xb, 0xc, 0xb, 0xb, 0xb, 0xb, 0xb, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xd, 0x9, 0xa, 0xb, 0xc, 0xa, 0x9, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xb, 0x9, 0xa, 0xb, 0xb, 0xa, 0xa, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xb, 0x9, 0xa, 0xb, 0xb, 0xa, 0xa, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xd, 0x9, 0xa, 0xb, 0xc, 0xa, 0x9, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xb, 0xc, 0xb, 0xb, 0xb, 0xb, 0xb, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0x9, 0xb, 0xc, 0xc, 0xd, 0xc, 0xd, 0xb, 0xc, 0xb, 0xc, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0x9, 0xb, 0xc, 0xc, 0xb, 0x9, 0xa, 0xd, 0xc, 0xa, 0x9, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0xa, 0xb, 0xb, 0xc, 0xd, 0x9, 0xa, 0xd, 0xd, 0xa, 0xa, 
+  0x9, 0xa, 0xc, 0xb, 0xa, 0x9, 0xd, 0xc, 0xc, 0xb, 0xc, 0xb, 0xd, 0xc, 0xd, 0xc, 
+  0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd
+};
+
+static char lut_spb[256] = {
+  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+  0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 
+  0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
+  0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 0, 1, 1, 
+  0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 
+  0, 0, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 
+  0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 1, 
+  0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
+};
+
+static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0180, 0x0300, 0x0480, 0x0600, 0x0780, 0x0900, 0x0a80, 
+  0x0c00, 0x0d80, 0x0f00, 0x1080, 0x1200, 0x1380, 0x1500, 0x1680, 
+  0x1800, 0x1980, 0x1b00, 0x1c80, 0x1e00, 0x1f80, 0x2100, 0x2280, 
+  0x2400, 0x2580, 0x2700, 0x2880, 0x2a00, 0x2b80, 0x2d00, 0x2e80, 
+  0x3000, 0x3180, 0x3300, 0x3480, 0x3600, 0x3780, 0x3900, 0x3a80, 
+  0x3c00, 0x3d80, 0x3f00, 0x4080, 0x4200, 0x4380, 0x4500, 0x4680, 
+  0x4800, 0x4980, 0x4b00, 0x4c80, 0x4e00, 0x4f80, 0x5100, 0x5280, 
+  0x5400, 0x5580, 0x5700, 0x5880, 0x5a00, 0x5b80, 0x5d00, 0x5e80, 
+  0x6000, 0x6180, 0x6300, 0x6480, 0x6600, 0x6780, 0x6900, 0x6a80, 
+  0x6c00, 0x6d80, 0x6f00, 0x7080, 0x7200, 0x7380, 0x7500, 0x7680
+};
+
+static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0080, 
+  0x0080, 0x0080, 0x0100, 0x0100, 0x0100, 0x0180, 0x0180, 0x0200, 
+  0x0200, 0x0280, 0x0280, 0x0300, 0x0300, 0x0380, 0x0400, 0x0400, 
+  0x0480, 0x0500, 0x0580, 0x0580, 0x0600, 0x0680, 0x0700, 0x0780, 
+  0x0800, 0x0880, 0x0900, 0x0980, 0x0a00, 0x0a80, 0x0b80, 0x0c00, 
+  0x0c80, 0x0d00, 0x0e00, 0x0e80, 0x0f00, 0x1000, 0x1080, 0x1180, 
+  0x1200, 0x1300, 0x1380, 0x1480, 0x1500, 0x1600, 0x1700, 0x1780, 
+  0x1880, 0x1980, 0x1a80, 0x1b00, 0x1c00, 0x1d00, 0x1e00, 0x1f00, 
+  0x2000, 0x2100, 0x2200, 0x2300, 0x2400, 0x2500, 0x2680, 0x2780, 
+  0x2880, 0x2980, 0x2b00, 0x2c00, 0x2d00, 0x2e80, 0x2f80, 0x3100, 
+  0x3200, 0x3380, 0x3480, 0x3600, 0x3700, 0x3880, 0x3a00, 0x3b00, 
+  0x3c80, 0x3e00, 0x3f80, 0x4080, 0x4200, 0x4380, 0x4500, 0x4680, 
+  0x4800, 0x4980, 0x4b00, 0x4c80, 0x4e00, 0x4f80, 0x5180, 0x5300, 
+  0x5480, 0x5600, 0x5800, 0x5980, 0x5b00, 0x5d00, 0x5e80, 0x6080, 
+  0x6200, 0x6400, 0x6580, 0x6780, 0x6900, 0x6b00, 0x6d00, 0x6e80, 
+  0x7080, 0x7280, 0x7480, 0x7600, 0x7800, 0x7a00, 0x7c00, 0x7e00
+};
+
+static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {
+  0x1800, 0x1780, 0x1700, 0x1680, 0x1600, 0x1580, 0x1500, 0x1480, 
+  0x1400, 0x1380, 0x1300, 0x1280, 0x1200, 0x1180, 0x1100, 0x1080, 
+  0x1000, 0x0f80, 0x0f00, 0x0e80, 0x0e00, 0x0d80, 0x0d00, 0x0c80, 
+  0x0c00, 0x0b80, 0x0b00, 0x0a80, 0x0a00, 0x0980, 0x0900, 0x0880, 
+  0x0800, 0x0780, 0x0700, 0x0680, 0x0600, 0x0580, 0x0500, 0x0480, 
+  0x0400, 0x0380, 0x0300, 0x0280, 0x0200, 0x0180, 0x0100, 0x0080, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0080, 0x0100, 0x0180, 0x0200, 0x0280, 0x0300, 0x0380, 
+  0x0400, 0x0480, 0x0500, 0x0580, 0x0600, 0x0680, 0x0700, 0x0780, 
+  0x0800, 0x0880, 0x0900, 0x0980, 0x0a00, 0x0a80, 0x0b00, 0x0b80, 
+  0x0c00, 0x0c80, 0x0d00, 0x0d80, 0x0e00, 0x0e80, 0x0f00, 0x0f80, 
+  0x1000, 0x1080, 0x1100, 0x1180, 0x1200, 0x1280, 0x1300, 0x1380, 
+  0x1400, 0x1480, 0x1500, 0x1580, 0x1600, 0x1680, 0x1700, 0x1780
+};
+
+static short lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {
+  0x2000, 0x1f00, 0x1e00, 0x1d00, 0x1c00, 0x1b00, 0x1a80, 0x1980, 
+  0x1880, 0x1780, 0x1700, 0x1600, 0x1500, 0x1480, 0x1380, 0x1300, 
+  0x1200, 0x1180, 0x1080, 0x1000, 0x0f00, 0x0e80, 0x0e00, 0x0d00, 
+  0x0c80, 0x0c00, 0x0b80, 0x0a80, 0x0a00, 0x0980, 0x0900, 0x0880, 
+  0x0800, 0x0780, 0x0700, 0x0680, 0x0600, 0x0580, 0x0580, 0x0500, 
+  0x0480, 0x0400, 0x0400, 0x0380, 0x0300, 0x0300, 0x0280, 0x0280, 
+  0x0200, 0x0200, 0x0180, 0x0180, 0x0100, 0x0100, 0x0100, 0x0080, 
+  0x0080, 0x0080, 0x0080, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 
+  0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0000, 0x0080, 0x0080, 
+  0x0080, 0x0080, 0x0100, 0x0100, 0x0100, 0x0180, 0x0180, 0x0200, 
+  0x0200, 0x0280, 0x0280, 0x0300, 0x0300, 0x0380, 0x0400, 0x0400, 
+  0x0480, 0x0500, 0x0580, 0x0580, 0x0600, 0x0680, 0x0700, 0x0780, 
+  0x0800, 0x0880, 0x0900, 0x0980, 0x0a00, 0x0a80, 0x0b80, 0x0c00, 
+  0x0c80, 0x0d00, 0x0e00, 0x0e80, 0x0f00, 0x1000, 0x1080, 0x1180, 
+  0x1200, 0x1300, 0x1380, 0x1480, 0x1500, 0x1600, 0x1700, 0x1780, 
+  0x1880, 0x1980, 0x1a80, 0x1b00, 0x1c00, 0x1d00, 0x1e00, 0x1f00
+};
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t2.c.svn-base ./libopenjpeg/.svn/text-base/t2.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t2.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,783 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/** @defgroup T2 T2 - Implementation of a tier-2 coding */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+static void t2_putcommacode(opj_bio_t *bio, int n);
+static int t2_getcommacode(opj_bio_t *bio);
+/**
+Variable length code for signalling delta Zil (truncation point)
+@param bio Bit Input/Output component
+@param n delta Zil
+*/
+static void t2_putnumpasses(opj_bio_t *bio, int n);
+static int t2_getnumpasses(opj_bio_t *bio);
+/**
+Encode a packet of a tile to a destination buffer
+@param tile Tile for which to write the packets
+@param tcp Tile coding parameters
+@param pi Packet identity
+@param dest Destination buffer
+@param len Length of the destination buffer
+@param cstr_info Codestream information structure 
+@param tileno Number of the tile encoded
+@return 
+*/
+static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_codestream_info_t *cstr_info, int tileno);
+/**
+@param seg
+@param cblksty
+@param first
+*/
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first);
+/**
+Decode a packet of a tile from a source buffer
+@param t2 T2 handle
+@param src Source buffer
+@param len Length of the source buffer
+@param tile Tile for which to write the packets
+@param tcp Tile coding parameters
+@param pi Packet identity
+@return 
+*/
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info);
+
+/*@}*/
+
+/*@}*/
+
+/* ----------------------------------------------------------------------- */
+
+/* #define RESTART 0x04 */
+
+static void t2_putcommacode(opj_bio_t *bio, int n) {
+	while (--n >= 0) {
+		bio_write(bio, 1, 1);
+	}
+	bio_write(bio, 0, 1);
+}
+
+static int t2_getcommacode(opj_bio_t *bio) {
+	int n;
+	for (n = 0; bio_read(bio, 1); n++) {
+		;
+	}
+	return n;
+}
+
+static void t2_putnumpasses(opj_bio_t *bio, int n) {
+	if (n == 1) {
+		bio_write(bio, 0, 1);
+	} else if (n == 2) {
+		bio_write(bio, 2, 2);
+	} else if (n <= 5) {
+		bio_write(bio, 0xc | (n - 3), 4);
+	} else if (n <= 36) {
+		bio_write(bio, 0x1e0 | (n - 6), 9);
+	} else if (n <= 164) {
+		bio_write(bio, 0xff80 | (n - 37), 16);
+	}
+}
+
+static int t2_getnumpasses(opj_bio_t *bio) {
+	int n;
+	if (!bio_read(bio, 1))
+		return 1;
+	if (!bio_read(bio, 1))
+		return 2;
+	if ((n = bio_read(bio, 2)) != 3)
+		return (3 + n);
+	if ((n = bio_read(bio, 5)) != 31)
+		return (6 + n);
+	return (37 + bio_read(bio, 7));
+}
+
+static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_codestream_info_t *cstr_info, int tileno) {
+	int bandno, cblkno;
+	unsigned char *c = dest;
+
+	int compno = pi->compno;	/* component value */
+	int resno  = pi->resno;		/* resolution level value */
+	int precno = pi->precno;	/* precinct value */
+	int layno  = pi->layno;		/* quality layer value */
+
+	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+	
+	opj_bio_t *bio = NULL;	/* BIO component */
+	
+	/* <SOP 0xff91> */
+	if (tcp->csty & J2K_CP_CSTY_SOP) {
+		c[0] = 255;
+		c[1] = 145;
+		c[2] = 0;
+		c[3] = 4;
+		c[4] = (tile->packno % 65536) / 256;
+		c[5] = (tile->packno % 65536) % 256;
+		c += 6;
+	}
+	/* </SOP> */
+	
+	if (!layno) {
+		for (bandno = 0; bandno < res->numbands; bandno++) {
+			opj_tcd_band_t *band = &res->bands[bandno];
+			opj_tcd_precinct_t *prc = &band->precincts[precno];
+			tgt_reset(prc->incltree);
+			tgt_reset(prc->imsbtree);
+			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+				opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+				cblk->numpasses = 0;
+				tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
+			}
+		}
+	}
+	
+	bio = bio_create();
+	bio_init_enc(bio, c, length);
+	bio_write(bio, 1, 1);		/* Empty header bit */
+	
+	/* Writing Packet header */
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			if (!cblk->numpasses && layer->numpasses) {
+				tgt_setvalue(prc->incltree, cblkno, layno);
+			}
+		}
+		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			int increment = 0;
+			int nump = 0;
+			int len = 0, passno;
+			/* cblk inclusion bits */
+			if (!cblk->numpasses) {
+				tgt_encode(bio, prc->incltree, cblkno, layno + 1);
+			} else {
+				bio_write(bio, layer->numpasses != 0, 1);
+			}
+			/* if cblk not included, go to the next cblk  */
+			if (!layer->numpasses) {
+				continue;
+			}
+			/* if first instance of cblk --> zero bit-planes information */
+			if (!cblk->numpasses) {
+				cblk->numlenbits = 3;
+				tgt_encode(bio, prc->imsbtree, cblkno, 999);
+			}
+			/* number of coding passes included */
+			t2_putnumpasses(bio, layer->numpasses);
+			
+			/* computation of the increase of the length indicator and insertion in the header     */
+			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
+				opj_tcd_pass_t *pass = &cblk->passes[passno];
+				nump++;
+				len += pass->len;
+				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+					increment = int_max(increment, int_floorlog2(len) + 1 - (cblk->numlenbits + int_floorlog2(nump)));
+					len = 0;
+					nump = 0;
+				}
+			}
+			t2_putcommacode(bio, increment);
+
+			/* computation of the new Length indicator */
+			cblk->numlenbits += increment;
+
+			/* insertion of the codeword segment length */
+			for (passno = cblk->numpasses; passno < cblk->numpasses + layer->numpasses; passno++) {
+				opj_tcd_pass_t *pass = &cblk->passes[passno];
+				nump++;
+				len += pass->len;
+				if (pass->term || passno == (cblk->numpasses + layer->numpasses) - 1) {
+					bio_write(bio, len, cblk->numlenbits + int_floorlog2(nump));
+					len = 0;
+					nump = 0;
+				}
+			}
+		}
+	}
+
+	if (bio_flush(bio)) {
+		bio_destroy(bio);
+		return -999;		/* modified to eliminate longjmp !! */
+	}
+
+	c += bio_numbytes(bio);
+	bio_destroy(bio);
+	
+	/* <EPH 0xff92> */
+	if (tcp->csty & J2K_CP_CSTY_EPH) {
+		c[0] = 255;
+		c[1] = 146;
+		c += 2;
+	}
+	/* </EPH> */
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(cstr_info && cstr_info->index_write) {
+		opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+		info_PK->end_ph_pos = (int)(c - dest);
+	}
+	/* INDEX >> */
+	
+	/* Writing the packet body */
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+			opj_tcd_layer_t *layer = &cblk->layers[layno];
+			if (!layer->numpasses) {
+				continue;
+			}
+			if (c + layer->len > dest + length) {
+				return -999;
+			}
+			
+			memcpy(c, layer->data, layer->len);
+			cblk->numpasses += layer->numpasses;
+			c += layer->len;
+			/* << INDEX */ 
+			if(cstr_info && cstr_info->index_write) {
+				opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+				info_PK->disto += layer->disto;
+				if (cstr_info->D_max < info_PK->disto) {
+					cstr_info->D_max = info_PK->disto;
+				}
+			}
+			/* INDEX >> */
+		}
+	}
+	
+	return (c - dest);
+}
+
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first) {
+	opj_tcd_seg_t* seg;
+	cblk->segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, (index + 1) * sizeof(opj_tcd_seg_t));
+	seg = &cblk->segs[index];
+	seg->data = NULL;
+	seg->dataindex = 0;
+	seg->numpasses = 0;
+	seg->len = 0;
+	if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
+		seg->maxpasses = 1;
+	}
+	else if (cblksty & J2K_CCP_CBLKSTY_LAZY) {
+		if (first) {
+			seg->maxpasses = 10;
+		} else {
+			seg->maxpasses = (((seg - 1)->maxpasses == 1) || ((seg - 1)->maxpasses == 10)) ? 2 : 1;
+		}
+	} else {
+		seg->maxpasses = 109;
+	}
+}
+
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info) {
+	int bandno, cblkno;
+	unsigned char *c = src;
+
+	opj_cp_t *cp = t2->cp;
+
+	int compno = pi->compno;	/* component value */
+	int resno  = pi->resno;		/* resolution level value */
+	int precno = pi->precno;	/* precinct value */
+	int layno  = pi->layno;		/* quality layer value */
+
+	opj_tcd_resolution_t* res = &tile->comps[compno].resolutions[resno];
+
+	unsigned char *hd = NULL;
+	int present;
+	
+	opj_bio_t *bio = NULL;	/* BIO component */
+	
+	if (layno == 0) {
+		for (bandno = 0; bandno < res->numbands; bandno++) {
+			opj_tcd_band_t *band = &res->bands[bandno];
+			opj_tcd_precinct_t *prc = &band->precincts[precno];
+			
+			if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
+			
+			tgt_reset(prc->incltree);
+			tgt_reset(prc->imsbtree);
+			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+				opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+				cblk->numsegs = 0;
+			}
+		}
+	}
+	
+	/* SOP markers */
+	
+	if (tcp->csty & J2K_CP_CSTY_SOP) {
+		if ((*c) != 0xff || (*(c + 1) != 0x91)) {
+			opj_event_msg(t2->cinfo, EVT_WARNING, "Expected SOP marker\n");
+		} else {
+			c += 6;
+		}
+		
+		/** TODO : check the Nsop value */
+	}
+	
+	/* 
+	When the marker PPT/PPM is used the packet header are store in PPT/PPM marker
+	This part deal with this caracteristic
+	step 1: Read packet header in the saved structure
+	step 2: Return to codestream for decoding 
+	*/
+
+	bio = bio_create();
+	
+	if (cp->ppm == 1) {		/* PPM */
+		hd = cp->ppm_data;
+		bio_init_dec(bio, hd, cp->ppm_len);
+	} else if (tcp->ppt == 1) {	/* PPT */
+		hd = tcp->ppt_data;
+		bio_init_dec(bio, hd, tcp->ppt_len);
+	} else {			/* Normal Case */
+		hd = c;
+		bio_init_dec(bio, hd, src+len-hd);
+	}
+	
+	present = bio_read(bio, 1);
+	
+	if (!present) {
+		bio_inalign(bio);
+		hd += bio_numbytes(bio);
+		bio_destroy(bio);
+		
+		/* EPH markers */
+		
+		if (tcp->csty & J2K_CP_CSTY_EPH) {
+			if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
+				printf("Error : expected EPH marker\n");
+			} else {
+				hd += 2;
+			}
+		}
+
+		/* << INDEX */
+		// End of packet header position. Currently only represents the distance to start of packet
+		// Will be updated later by incrementing with packet start value
+		if(pack_info) {
+			pack_info->end_ph_pos = (int)(c - src);
+		}
+		/* INDEX >> */
+		
+		if (cp->ppm == 1) {		/* PPM case */
+			cp->ppm_len += cp->ppm_data-hd;
+			cp->ppm_data = hd;
+			return (c - src);
+		}
+		if (tcp->ppt == 1) {	/* PPT case */
+			tcp->ppt_len+=tcp->ppt_data-hd;
+			tcp->ppt_data = hd;
+			return (c - src);
+		}
+		
+		return (hd - src);
+	}
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		
+		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
+		
+		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+			int included, increment, n, segno;
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+			/* if cblk not yet included before --> inclusion tagtree */
+			if (!cblk->numsegs) {
+				included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
+				/* else one bit */
+			} else {
+				included = bio_read(bio, 1);
+			}
+			/* if cblk not included */
+			if (!included) {
+				cblk->numnewpasses = 0;
+				continue;
+			}
+			/* if cblk not yet included --> zero-bitplane tagtree */
+			if (!cblk->numsegs) {
+				int i, numimsbs;
+				for (i = 0; !tgt_decode(bio, prc->imsbtree, cblkno, i); i++) {
+					;
+				}
+				numimsbs = i - 1;
+				cblk->numbps = band->numbps - numimsbs;
+				cblk->numlenbits = 3;
+			}
+			/* number of coding passes */
+			cblk->numnewpasses = t2_getnumpasses(bio);
+			increment = t2_getcommacode(bio);
+			/* length indicator increment */
+			cblk->numlenbits += increment;
+			segno = 0;
+			if (!cblk->numsegs) {
+				t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 1);
+			} else {
+				segno = cblk->numsegs - 1;
+				if (cblk->segs[segno].numpasses == cblk->segs[segno].maxpasses) {
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
+				}
+			}
+			n = cblk->numnewpasses;
+			
+			do {
+				cblk->segs[segno].numnewpasses = int_min(cblk->segs[segno].maxpasses - cblk->segs[segno].numpasses, n);
+				cblk->segs[segno].newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(cblk->segs[segno].numnewpasses));
+				n -= cblk->segs[segno].numnewpasses;
+				if (n > 0) {
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
+				}
+			} while (n > 0);
+		}
+	}
+	
+	if (bio_inalign(bio)) {
+		bio_destroy(bio);
+		return -999;
+	}
+	
+	hd += bio_numbytes(bio);
+	bio_destroy(bio);
+	
+	/* EPH markers */
+	if (tcp->csty & J2K_CP_CSTY_EPH) {
+		if ((*hd) != 0xff || (*(hd + 1) != 0x92)) {
+			opj_event_msg(t2->cinfo, EVT_ERROR, "Expected EPH marker\n");
+		} else {
+			hd += 2;
+		}
+	}
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(pack_info) {
+		pack_info->end_ph_pos = (int)(hd - src);
+	}
+	/* INDEX >> */
+	
+	if (cp->ppm==1) {
+		cp->ppm_len+=cp->ppm_data-hd;
+		cp->ppm_data = hd;
+	} else if (tcp->ppt == 1) {
+		tcp->ppt_len+=tcp->ppt_data-hd;
+		tcp->ppt_data = hd;
+	} else {
+		c=hd;
+	}
+	
+	for (bandno = 0; bandno < res->numbands; bandno++) {
+		opj_tcd_band_t *band = &res->bands[bandno];
+		opj_tcd_precinct_t *prc = &band->precincts[precno];
+		
+		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
+		
+		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+			opj_tcd_seg_t *seg = NULL;
+			if (!cblk->numnewpasses)
+				continue;
+			if (!cblk->numsegs) {
+				seg = &cblk->segs[0];
+				cblk->numsegs++;
+				cblk->len = 0;
+			} else {
+				seg = &cblk->segs[cblk->numsegs - 1];
+				if (seg->numpasses == seg->maxpasses) {
+					seg++;
+					cblk->numsegs++;
+				}
+			}
+			
+			do {
+				if (c + seg->newlen > src + len) {
+					return -999;
+				}
+
+#ifdef USE_JPWL
+			/* we need here a j2k handle to verify if making a check to
+			the validity of cblocks parameters is selected from user (-W) */
+
+				/* let's check that we are not exceeding */
+				if ((cblk->len + seg->newlen) > 8192) {
+					opj_event_msg(t2->cinfo, EVT_WARNING,
+						"JPWL: segment too long (%d) for codeblock %d (p=%d, b=%d, r=%d, c=%d)\n",
+						seg->newlen, cblkno, precno, bandno, resno, compno);
+					if (!JPWL_ASSUME) {
+						opj_event_msg(t2->cinfo, EVT_ERROR, "JPWL: giving up\n");
+						return -999;
+					}
+					seg->newlen = 8192 - cblk->len;
+					opj_event_msg(t2->cinfo, EVT_WARNING, "      - truncating segment to %d\n", seg->newlen);
+					break;
+				};
+
+#endif /* USE_JPWL */
+				
+				cblk->data = (unsigned char*) opj_realloc(cblk->data, (cblk->len + seg->newlen) * sizeof(unsigned char*));
+				memcpy(cblk->data + cblk->len, c, seg->newlen);
+				if (seg->numpasses == 0) {
+					seg->data = &cblk->data;
+					seg->dataindex = cblk->len;
+				}
+				c += seg->newlen;
+				cblk->len += seg->newlen;
+				seg->len += seg->newlen;
+				seg->numpasses += seg->numnewpasses;
+				cblk->numnewpasses -= seg->numnewpasses;
+				if (cblk->numnewpasses > 0) {
+					seg++;
+					cblk->numsegs++;
+				}
+			} while (cblk->numnewpasses > 0);
+		}
+	}
+	
+	return (c - src);
+}
+
+/* ----------------------------------------------------------------------- */
+
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode){
+	unsigned char *c = dest;
+	int e = 0;
+	int compno;
+	opj_pi_iterator_t *pi = NULL;
+	int poc;
+	opj_image_t *image = t2->image;
+	opj_cp_t *cp = t2->cp;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
+	int pocno = cp->cinema == CINEMA4K_24? 2: 1;
+	int maxcomp = cp->max_comp_size > 0 ? image->numcomps : 1;
+	
+	pi = pi_initialise_encode(image, cp, tileno, t2_mode);
+	if(!pi) {
+		/* TODO: throw an error */
+		return -999;
+	}
+	
+	if(t2_mode == THRESH_CALC ){ /* Calculating threshold */
+		for(compno = 0; compno < maxcomp; compno++ ){
+			for(poc = 0; poc < pocno ; poc++){
+				int comp_len = 0;
+				int tpnum = compno;
+				pi_create_encode(pi, cp,tileno,poc,tpnum,tppos,t2_mode); 
+				while (pi_next(&pi[poc])) {
+					if (pi[poc].layno < maxlayers) {
+						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, cstr_info, tileno);
+						comp_len = comp_len + e;
+						if (e == -999) {
+							break;
+						} else {
+							c += e;
+						}
+					}
+				}
+				if (e == -999) break;
+				if (cp->max_comp_size){
+					if (comp_len > cp->max_comp_size){
+						e = -999;
+						break;
+					}
+				}
+			}
+			if (e == -999)  break;
+		}
+	}else{  /* t2_mode == FINAL_PASS  */
+		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos,t2_mode);
+		while (pi_next(&pi[pino])) {
+			if (pi[pino].layno < maxlayers) {
+				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, cstr_info, tileno);
+				if (e == -999) {
+					break;
+				} else {
+					c += e;
+				}
+				/* INDEX >> */
+				if(cstr_info) {
+					if(cstr_info->index_write) {
+						opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+						opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+						if (!cstr_info->packno) {
+							info_PK->start_pos = info_TL->end_header + 1;
+						} else {
+							info_PK->start_pos = ((cp->tp_on | tcp->POC)&& info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+						}
+						info_PK->end_pos = info_PK->start_pos + e - 1;
+						info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																														// to start of packet is incremented by value of start of packet
+					}
+					
+					cstr_info->packno++;
+				}
+				/* << INDEX */
+				tile->packno++;
+			}
+		}
+	}
+	
+	pi_destroy(pi, cp, tileno);
+	
+	if (e == -999) {
+		return e;
+	}
+	
+  return (c - dest);
+}
+
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info) {
+	unsigned char *c = src;
+	opj_pi_iterator_t *pi;
+	int pino, e = 0;
+	int n = 0, curtp = 0;
+	int tp_start_packno;
+
+	opj_image_t *image = t2->image;
+	opj_cp_t *cp = t2->cp;
+	
+	/* create a packet iterator */
+	pi = pi_create_decode(image, cp, tileno);
+	if(!pi) {
+		/* TODO: throw an error */
+		return -999;
+	}
+
+	tp_start_packno = 0;
+	
+	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
+		while (pi_next(&pi[pino])) {
+			if ((cp->layer==0) || (cp->layer>=((pi[pino].layno)+1))) {
+				opj_packet_info_t *pack_info;
+				if (cstr_info)
+					pack_info = &cstr_info->tile[tileno].packet[cstr_info->packno];
+				else
+					pack_info = NULL;
+				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino], pack_info);
+			} else {
+				e = 0;
+			}
+			
+			/* progression in resolution */
+			image->comps[pi[pino].compno].resno_decoded =	
+				(e > 0) ? 
+				int_max(pi[pino].resno, image->comps[pi[pino].compno].resno_decoded) 
+				: image->comps[pi[pino].compno].resno_decoded;
+			n++;
+
+			/* INDEX >> */
+			if(cstr_info) {
+				opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+				opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+				if (!cstr_info->packno) {
+					info_PK->start_pos = info_TL->end_header + 1;
+				} else if (info_TL->packet[cstr_info->packno-1].end_pos >= (int)cstr_info->tile[tileno].tp[curtp].tp_end_pos){ // New tile part
+					info_TL->tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in previous tile-part
+					tp_start_packno = cstr_info->packno;
+					curtp++;
+					info_PK->start_pos = cstr_info->tile[tileno].tp[curtp].tp_end_header+1;
+				} else {
+					info_PK->start_pos = (cp->tp_on && info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+				}
+				info_PK->end_pos = info_PK->start_pos + e - 1;
+				info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																												// to start of packet is incremented by value of start of packet
+				cstr_info->packno++;
+			}
+			/* << INDEX */
+			
+			if (e == -999) {		/* ADD */
+				break;
+			} else {
+				c += e;
+			}			
+		}
+	}
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->tile[tileno].tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in last tile-part
+	}
+	/* << INDEX */
+
+	/* don't forget to release pi */
+	pi_destroy(pi, cp, tileno);
+	
+	if (e == -999) {
+		return e;
+	}
+	
+	return (c - src);
+}
+
+/* ----------------------------------------------------------------------- */
+
+opj_t2_t* t2_create(opj_common_ptr cinfo, opj_image_t *image, opj_cp_t *cp) {
+	/* create the tcd structure */
+	opj_t2_t *t2 = (opj_t2_t*)opj_malloc(sizeof(opj_t2_t));
+	if(!t2) return NULL;
+	t2->cinfo = cinfo;
+	t2->image = image;
+	t2->cp = cp;
+
+	return t2;
+}
+
+void t2_destroy(opj_t2_t *t2) {
+	if(t2) {
+		opj_free(t2);
+	}
+}
+
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t2.h.svn-base ./libopenjpeg/.svn/text-base/t2.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/t2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/t2.h.svn-base	2007-09-28 11:33:44.000000000 +0100
@@ -0,0 +1,102 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __T2_H
+#define __T2_H
+/**
+@file t2.h
+@brief Implementation of a tier-2 coding (packetization of code-block data) (T2)
+
+*/
+
+/** @defgroup T2 T2 - Implementation of a tier-2 coding */
+/*@{*/
+
+/**
+Tier-2 coding
+*/
+typedef struct opj_t2 {
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** Encoding: pointer to the src image. Decoding: pointer to the dst image. */
+	opj_image_t *image;
+	/** pointer to the image coding parameters */
+	opj_cp_t *cp;
+} opj_t2_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Encode the packets of a tile to a destination buffer
+@param t2 T2 handle
+@param tileno number of the tile encoded
+@param tile the tile for which to write the packets
+@param maxlayers maximum number of layers
+@param dest the destination buffer
+@param len the length of the destination buffer
+@param cstr_info Codestream information structure 
+@param tpnum Tile part number of the current tile
+@param tppos The position of the tile part flag in the progression order
+@param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
+*/
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode);
+/**
+Decode the packets of a tile from a source buffer
+@param t2 T2 handle
+@param src the source buffer
+@param len length of the source buffer
+@param tileno number that identifies the tile for which to decode the packets
+@param tile tile for which to decode the packets
+ */
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info);
+
+/**
+Create a T2 handle
+@param cinfo Codec context info
+@param image Source or destination image
+@param cp Image coding parameters
+@return Returns a new T2 handle if successful, returns NULL otherwise
+*/
+opj_t2_t* t2_create(opj_common_ptr cinfo, opj_image_t *image, opj_cp_t *cp);
+/**
+Destroy a T2 handle
+@param t2 T2 handle to destroy
+*/
+void t2_destroy(opj_t2_t *t2);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __T2_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tcd.c.svn-base ./libopenjpeg/.svn/text-base/tcd.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tcd.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/tcd.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1505 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * Copyright (c) 2006-2007, Parvatha Elangovan
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {
+	int tileno, compno, resno, bandno, precno;//, cblkno;
+
+	fprintf(fd, "image {\n");
+	fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
+		img->tw, img->th, tcd->image->x0, tcd->image->x1, tcd->image->y0, tcd->image->y1);
+
+	for (tileno = 0; tileno < img->th * img->tw; tileno++) {
+		opj_tcd_tile_t *tile = &tcd->tcd_image->tiles[tileno];
+		fprintf(fd, "  tile {\n");
+		fprintf(fd, "    x0=%d, y0=%d, x1=%d, y1=%d, numcomps=%d\n",
+			tile->x0, tile->y0, tile->x1, tile->y1, tile->numcomps);
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			fprintf(fd, "    tilec {\n");
+			fprintf(fd,
+				"      x0=%d, y0=%d, x1=%d, y1=%d, numresolutions=%d\n",
+				tilec->x0, tilec->y0, tilec->x1, tilec->y1, tilec->numresolutions);
+			for (resno = 0; resno < tilec->numresolutions; resno++) {
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+				fprintf(fd, "\n   res {\n");
+				fprintf(fd,
+					"          x0=%d, y0=%d, x1=%d, y1=%d, pw=%d, ph=%d, numbands=%d\n",
+					res->x0, res->y0, res->x1, res->y1, res->pw, res->ph, res->numbands);
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					opj_tcd_band_t *band = &res->bands[bandno];
+					fprintf(fd, "        band {\n");
+					fprintf(fd,
+						"          x0=%d, y0=%d, x1=%d, y1=%d, stepsize=%f, numbps=%d\n",
+						band->x0, band->y0, band->x1, band->y1, band->stepsize, band->numbps);
+					for (precno = 0; precno < res->pw * res->ph; precno++) {
+						opj_tcd_precinct_t *prec = &band->precincts[precno];
+						fprintf(fd, "          prec {\n");
+						fprintf(fd,
+							"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
+							prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
+						/*
+						for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
+							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
+							fprintf(fd, "            cblk {\n");
+							fprintf(fd,
+								"              x0=%d, y0=%d, x1=%d, y1=%d\n",
+								cblk->x0, cblk->y0, cblk->x1, cblk->y1);
+							fprintf(fd, "            }\n");
+						}
+						*/
+						fprintf(fd, "          }\n");
+					}
+					fprintf(fd, "        }\n");
+				}
+				fprintf(fd, "      }\n");
+			}
+			fprintf(fd, "    }\n");
+		}
+		fprintf(fd, "  }\n");
+	}
+	fprintf(fd, "}\n");
+}
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Create a new TCD handle
+*/
+opj_tcd_t* tcd_create(opj_common_ptr cinfo) {
+	/* create the tcd structure */
+	opj_tcd_t *tcd = (opj_tcd_t*)opj_malloc(sizeof(opj_tcd_t));
+	if(!tcd) return NULL;
+	tcd->cinfo = cinfo;
+	tcd->tcd_image = (opj_tcd_image_t*)opj_malloc(sizeof(opj_tcd_image_t));
+	if(!tcd->tcd_image) {
+		opj_free(tcd);
+		return NULL;
+	}
+
+	return tcd;
+}
+
+/**
+Destroy a previously created TCD handle
+*/
+void tcd_destroy(opj_tcd_t *tcd) {
+	if(tcd) {
+		opj_free(tcd->tcd_image);
+		opj_free(tcd);
+	}
+}
+
+/* ----------------------------------------------------------------------- */
+
+void tcd_malloc_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno) {
+	int tileno, compno, resno, bandno, precno, cblkno;
+
+	tcd->image = image;
+	tcd->cp = cp;
+	tcd->tcd_image->tw = cp->tw;
+	tcd->tcd_image->th = cp->th;
+	tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(sizeof(opj_tcd_tile_t));
+	
+	for (tileno = 0; tileno < 1; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[curtileno];
+		int j;
+
+		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
+		int p = curtileno % cp->tw;	/* si numerotation matricielle .. */
+		int q = curtileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
+
+		/* opj_tcd_tile_t *tile=&tcd->tcd_image->tiles[tileno]; */
+		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
+
+		/* 4 borders of the tile rescale on the image if necessary */
+		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+		tile->numcomps = image->numcomps;
+		/* tile->PPT=image->PPT;  */
+
+		/* Modification of the RATE >> */
+		for (j = 0; j < tcp->numlayers; j++) {
+			tcp->rates[j] = tcp->rates[j] ? 
+				cp->tp_on ? 
+					(((float) (tile->numcomps 
+					* (tile->x1 - tile->x0) 
+					* (tile->y1 - tile->y0)
+					* image->comps[0].prec))
+					/(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)) - (((tcd->cur_totnum_tp - 1) * 14 )/ tcp->numlayers)
+					:
+				((float) (tile->numcomps 
+					* (tile->x1 - tile->x0) 
+					* (tile->y1 - tile->y0) 
+					* image->comps[0].prec))/ 
+					(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)
+					: 0;
+
+			if (tcp->rates[j]) {
+				if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
+					tcp->rates[j] = tcp->rates[j - 1] + 20;
+				} else {
+					if (!j && tcp->rates[j] < 30)
+						tcp->rates[j] = 30;
+				}
+				
+				if(j == (tcp->numlayers-1)){
+					tcp->rates[j] = tcp->rates[j]- 2;
+				}
+			}
+		}
+		/* << Modification of the RATE */
+		
+		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(image->numcomps * sizeof(opj_tcd_tilecomp_t));
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+			/* border of each tile component (global) */
+			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
+			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+			
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->numresolutions = tccp->numresolutions;
+
+			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+			
+			for (resno = 0; resno < tilec->numresolutions; resno++) {
+				int pdx, pdy;
+				int levelno = tilec->numresolutions - 1 - resno;
+				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+				int cbgwidthexpn, cbgheightexpn;
+				int cblkwidthexpn, cblkheightexpn;
+
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+				
+				/* border for each resolution level (global) */
+				res->x0 = int_ceildivpow2(tilec->x0, levelno);
+				res->y0 = int_ceildivpow2(tilec->y0, levelno);
+				res->x1 = int_ceildivpow2(tilec->x1, levelno);
+				res->y1 = int_ceildivpow2(tilec->y1, levelno);
+				
+				res->numbands = resno == 0 ? 1 : 3;
+				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
+				if (tccp->csty & J2K_CCP_CSTY_PRT) {
+					pdx = tccp->prcw[resno];
+					pdy = tccp->prch[resno];
+				} else {
+					pdx = 15;
+					pdy = 15;
+				}
+				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
+				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+				
+				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+				
+				res->pw = (brprcxend - tlprcxstart) >> pdx;
+				res->ph = (brprcyend - tlprcystart) >> pdy;
+				
+				if (resno == 0) {
+					tlcbgxstart = tlprcxstart;
+					tlcbgystart = tlprcystart;
+					brcbgxend = brprcxend;
+					brcbgyend = brprcyend;
+					cbgwidthexpn = pdx;
+					cbgheightexpn = pdy;
+				} else {
+					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+					brcbgxend = int_ceildivpow2(brprcxend, 1);
+					brcbgyend = int_ceildivpow2(brprcyend, 1);
+					cbgwidthexpn = pdx - 1;
+					cbgheightexpn = pdy - 1;
+				}
+				
+				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
+				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+				
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					int x0b, y0b, i;
+					int gain, numbps;
+					opj_stepsize_t *ss = NULL;
+
+					opj_tcd_band_t *band = &res->bands[bandno];
+
+					band->bandno = resno == 0 ? 0 : bandno + 1;
+					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
+					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
+					
+					if (band->bandno == 0) {
+						/* band border (global) */
+						band->x0 = int_ceildivpow2(tilec->x0, levelno);
+						band->y0 = int_ceildivpow2(tilec->y0, levelno);
+						band->x1 = int_ceildivpow2(tilec->x1, levelno);
+						band->y1 = int_ceildivpow2(tilec->y1, levelno);
+					} else {
+						/* band border (global) */
+						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
+						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
+						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
+						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
+					}
+					
+					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);					
+					numbps = image->comps[compno].prec + gain;
+					
+					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
+					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+					
+					band->precincts = (opj_tcd_precinct_t *) opj_malloc(3 * res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+					
+					for (i = 0; i < res->pw * res->ph * 3; i++) {
+						band->precincts[i].imsbtree = NULL;
+						band->precincts[i].incltree = NULL;
+					}
+					
+					for (precno = 0; precno < res->pw * res->ph; precno++) {
+						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+
+						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
+						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
+						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+						int cbgyend = cbgystart + (1 << cbgheightexpn);
+
+						opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+						/* precinct size (global) */
+						prc->x0 = int_max(cbgxstart, band->x0);
+						prc->y0 = int_max(cbgystart, band->y0);
+						prc->x1 = int_min(cbgxend, band->x1);
+						prc->y1 = int_min(cbgyend, band->y1);
+
+						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc((prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t));
+						prc->incltree = tgt_create(prc->cw, prc->ch);
+						prc->imsbtree = tgt_create(prc->cw, prc->ch);
+						
+						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
+							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+							int cblkyend = cblkystart + (1 << cblkheightexpn);
+							
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+
+							/* code-block size (global) */
+							cblk->x0 = int_max(cblkxstart, prc->x0);
+							cblk->y0 = int_max(cblkystart, prc->y0);
+							cblk->x1 = int_min(cblkxend, prc->x1);
+							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192+2, sizeof(unsigned char));
+							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
+							cblk->data += 2;
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+}
+
+void tcd_free_encode(opj_tcd_t *tcd) {
+	int tileno, compno, resno, bandno, precno, cblkno;
+
+	for (tileno = 0; tileno < 1; tileno++) {
+		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
+
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+			for (resno = 0; resno < tilec->numresolutions; resno++) {
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					opj_tcd_band_t *band = &res->bands[bandno];
+
+					for (precno = 0; precno < res->pw * res->ph; precno++) {
+						opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+						if (prc->incltree != NULL) {
+							tgt_destroy(prc->incltree);
+							prc->incltree = NULL;
+						}
+						if (prc->imsbtree != NULL) {
+							tgt_destroy(prc->imsbtree);	
+							prc->imsbtree = NULL;
+						}
+						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+							opj_free(prc->cblks.enc[cblkno].data - 2);
+							opj_free(prc->cblks.enc[cblkno].layers);
+							opj_free(prc->cblks.enc[cblkno].passes);
+						}
+						opj_free(prc->cblks.enc);
+					} /* for (precno */
+					opj_free(band->precincts);
+					band->precincts = NULL;
+				} /* for (bandno */
+			} /* for (resno */
+			opj_free(tilec->resolutions);
+			tilec->resolutions = NULL;
+		} /* for (compno */
+		opj_free(tile->comps);
+		tile->comps = NULL;
+	} /* for (tileno */
+	opj_free(tcd->tcd_image->tiles);
+	tcd->tcd_image->tiles = NULL;
+}
+
+void tcd_init_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno) {
+	int tileno, compno, resno, bandno, precno, cblkno;
+
+	for (tileno = 0; tileno < 1; tileno++) {
+		opj_tcp_t *tcp = &cp->tcps[curtileno];
+		int j;
+		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
+		int p = curtileno % cp->tw;
+		int q = curtileno / cp->tw;
+
+		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
+		
+		/* 4 borders of the tile rescale on the image if necessary */
+		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+		
+		tile->numcomps = image->numcomps;
+		/* tile->PPT=image->PPT; */
+
+		/* Modification of the RATE >> */
+		for (j = 0; j < tcp->numlayers; j++) {
+			tcp->rates[j] = tcp->rates[j] ? 
+						((float) (tile->numcomps 
+								* (tile->x1 - tile->x0) 
+								* (tile->y1 - tile->y0) 
+								* image->comps[0].prec))/ 
+						(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy) 
+						: 0;
+
+			if (tcp->rates[j]) {
+				if (j && tcp->rates[j] < tcp->rates[j - 1] + 10) {
+					tcp->rates[j] = tcp->rates[j - 1] + 20;
+				} else {
+					if (!j && tcp->rates[j] < 30)
+						tcp->rates[j] = 30;
+				}
+			}
+		}
+		/* << Modification of the RATE */
+
+		/* tile->comps=(opj_tcd_tilecomp_t*)opj_realloc(tile->comps,image->numcomps*sizeof(opj_tcd_tilecomp_t)); */
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+
+			/* border of each tile component (global) */
+			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
+			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+			
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->numresolutions = tccp->numresolutions;
+			/* tilec->resolutions=(opj_tcd_resolution_t*)opj_realloc(tilec->resolutions,tilec->numresolutions*sizeof(opj_tcd_resolution_t)); */
+			for (resno = 0; resno < tilec->numresolutions; resno++) {
+				int pdx, pdy;
+
+				int levelno = tilec->numresolutions - 1 - resno;
+				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+				int cbgwidthexpn, cbgheightexpn;
+				int cblkwidthexpn, cblkheightexpn;
+				
+				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+				/* border for each resolution level (global) */
+				res->x0 = int_ceildivpow2(tilec->x0, levelno);
+				res->y0 = int_ceildivpow2(tilec->y0, levelno);
+				res->x1 = int_ceildivpow2(tilec->x1, levelno);
+				res->y1 = int_ceildivpow2(tilec->y1, levelno);	
+				res->numbands = resno == 0 ? 1 : 3;
+
+				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
+				if (tccp->csty & J2K_CCP_CSTY_PRT) {
+					pdx = tccp->prcw[resno];
+					pdy = tccp->prch[resno];
+				} else {
+					pdx = 15;
+					pdy = 15;
+				}
+				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
+				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+				
+				res->pw = (brprcxend - tlprcxstart) >> pdx;
+				res->ph = (brprcyend - tlprcystart) >> pdy;
+				
+				if (resno == 0) {
+					tlcbgxstart = tlprcxstart;
+					tlcbgystart = tlprcystart;
+					brcbgxend = brprcxend;
+					brcbgyend = brprcyend;
+					cbgwidthexpn = pdx;
+					cbgheightexpn = pdy;
+				} else {
+					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+					brcbgxend = int_ceildivpow2(brprcxend, 1);
+					brcbgyend = int_ceildivpow2(brprcyend, 1);
+					cbgwidthexpn = pdx - 1;
+					cbgheightexpn = pdy - 1;
+				}
+				
+				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
+				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+				
+				for (bandno = 0; bandno < res->numbands; bandno++) {
+					int x0b, y0b;
+					int gain, numbps;
+					opj_stepsize_t *ss = NULL;
+
+					opj_tcd_band_t *band = &res->bands[bandno];
+
+					band->bandno = resno == 0 ? 0 : bandno + 1;
+					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
+					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
+					
+					if (band->bandno == 0) {
+						/* band border */
+						band->x0 = int_ceildivpow2(tilec->x0, levelno);
+						band->y0 = int_ceildivpow2(tilec->y0, levelno);
+						band->x1 = int_ceildivpow2(tilec->x1, levelno);
+						band->y1 = int_ceildivpow2(tilec->y1, levelno);
+					} else {
+						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
+						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
+						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
+						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
+					}
+					
+					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
+					numbps = image->comps[compno].prec + gain;
+					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
+					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+					
+					for (precno = 0; precno < res->pw * res->ph; precno++) {
+						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+
+						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
+						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
+						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+						int cbgyend = cbgystart + (1 << cbgheightexpn);
+						
+						opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+						/* precinct size (global) */
+						prc->x0 = int_max(cbgxstart, band->x0);
+						prc->y0 = int_max(cbgystart, band->y0);
+						prc->x1 = int_min(cbgxend, band->x1);
+						prc->y1 = int_min(cbgyend, band->y1);
+
+						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+
+						opj_free(prc->cblks.enc);
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc(prc->cw * prc->ch, sizeof(opj_tcd_cblk_enc_t));
+
+						if (prc->incltree != NULL) {
+							tgt_destroy(prc->incltree);
+						}
+						if (prc->imsbtree != NULL) {
+							tgt_destroy(prc->imsbtree);
+						}
+						
+						prc->incltree = tgt_create(prc->cw, prc->ch);
+						prc->imsbtree = tgt_create(prc->cw, prc->ch);
+
+						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
+							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+							int cblkyend = cblkystart + (1 << cblkheightexpn);
+
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+
+							/* code-block size (global) */
+							cblk->x0 = int_max(cblkxstart, prc->x0);
+							cblk->y0 = int_max(cblkystart, prc->y0);
+							cblk->x1 = int_min(cblkxend, prc->x1);
+							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192, sizeof(unsigned char));
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
+						}
+					} /* precno */
+				} /* bandno */
+			} /* resno */
+		} /* compno */
+	} /* tileno */
+
+	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+}
+
+void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp) {
+	int i, j, tileno, p, q;
+	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0, w, h;
+
+	tcd->image = image;
+	tcd->tcd_image->tw = cp->tw;
+	tcd->tcd_image->th = cp->th;
+	tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcd_tile_t));
+
+	/* 
+	Allocate place to store the decoded data = final image
+	Place limited by the tile really present in the codestream 
+	*/
+
+	for (j = 0; j < cp->tileno_size; j++) {
+		opj_tcd_tile_t *tile;
+		
+		tileno = cp->tileno[j];		
+		tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);		
+		tile->numcomps = image->numcomps;
+		tile->comps = (opj_tcd_tilecomp_t*) opj_calloc(image->numcomps, sizeof(opj_tcd_tilecomp_t));
+	}
+
+	for (i = 0; i < image->numcomps; i++) {
+		for (j = 0; j < cp->tileno_size; j++) {
+			opj_tcd_tile_t *tile;
+			opj_tcd_tilecomp_t *tilec;
+			
+			/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
+			
+			tileno = cp->tileno[j];
+			
+			tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+			tilec = &tile->comps[i];
+			
+			p = tileno % cp->tw;	/* si numerotation matricielle .. */
+			q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
+			
+			/* 4 borders of the tile rescale on the image if necessary */
+			tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+			tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+			tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+			tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+
+			tilec->x0 = int_ceildiv(tile->x0, image->comps[i].dx);
+			tilec->y0 = int_ceildiv(tile->y0, image->comps[i].dy);
+			tilec->x1 = int_ceildiv(tile->x1, image->comps[i].dx);
+			tilec->y1 = int_ceildiv(tile->y1, image->comps[i].dy);
+
+			x0 = j == 0 ? tilec->x0 : int_min(x0, (unsigned int) tilec->x0);
+			y0 = j == 0 ? tilec->y0 : int_min(y0,	(unsigned int) tilec->x0);
+			x1 = j == 0 ? tilec->x1 : int_max(x1,	(unsigned int) tilec->x1);
+			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
+		}
+
+		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
+		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
+
+		image->comps[i].w = w;
+		image->comps[i].h = h;
+		image->comps[i].x0 = x0;
+		image->comps[i].y0 = y0;
+	}
+}
+
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info) {
+	int compno, resno, bandno, precno, cblkno;
+	opj_tcp_t *tcp;
+	opj_tcd_tile_t *tile;
+
+	tcd->cp = cp;
+	
+	tcp = &(cp->tcps[cp->tileno[tileno]]);
+	tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+	
+	tileno = cp->tileno[tileno];
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tccp_t *tccp = &tcp->tccps[compno];
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		
+		/* border of each tile component (global) */
+		tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
+		tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+		tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+		tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+
+		tilec->numresolutions = tccp->numresolutions;
+		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+		
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			int pdx, pdy;
+			int levelno = tilec->numresolutions - 1 - resno;
+			int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+			int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+			int cbgwidthexpn, cbgheightexpn;
+			int cblkwidthexpn, cblkheightexpn;
+			
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			
+			/* border for each resolution level (global) */
+			res->x0 = int_ceildivpow2(tilec->x0, levelno);
+			res->y0 = int_ceildivpow2(tilec->y0, levelno);
+			res->x1 = int_ceildivpow2(tilec->x1, levelno);
+			res->y1 = int_ceildivpow2(tilec->y1, levelno);
+			res->numbands = resno == 0 ? 1 : 3;
+			
+			/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
+			if (tccp->csty & J2K_CCP_CSTY_PRT) {
+				pdx = tccp->prcw[resno];
+				pdy = tccp->prch[resno];
+			} else {
+				pdx = 15;
+				pdy = 15;
+			}			
+			
+			/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
+			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+			
+			res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
+			res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+			
+			if (resno == 0) {
+				tlcbgxstart = tlprcxstart;
+				tlcbgystart = tlprcystart;
+				brcbgxend = brprcxend;
+				brcbgyend = brprcyend;
+				cbgwidthexpn = pdx;
+				cbgheightexpn = pdy;
+			} else {
+				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+				brcbgxend = int_ceildivpow2(brprcxend, 1);
+				brcbgyend = int_ceildivpow2(brprcyend, 1);
+				cbgwidthexpn = pdx - 1;
+				cbgheightexpn = pdy - 1;
+			}
+			
+			cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
+			cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+			
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				int x0b, y0b;
+				int gain, numbps;
+				opj_stepsize_t *ss = NULL;
+				
+				opj_tcd_band_t *band = &res->bands[bandno];
+				band->bandno = resno == 0 ? 0 : bandno + 1;
+				x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
+				y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
+				
+				if (band->bandno == 0) {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0, levelno);
+					band->y0 = int_ceildivpow2(tilec->y0, levelno);
+					band->x1 = int_ceildivpow2(tilec->x1, levelno);
+					band->y1 = int_ceildivpow2(tilec->y1, levelno);
+				} else {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
+					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
+					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
+					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
+				}
+				
+				ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+				gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
+				numbps = image->comps[compno].prec + gain;
+				band->stepsize = (float)(((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn)) * 0.5);
+				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+				
+				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+				
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+					int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
+					int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
+					int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+					int cbgyend = cbgystart + (1 << cbgheightexpn);
+					
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					/* precinct size (global) */
+					prc->x0 = int_max(cbgxstart, band->x0);
+					prc->y0 = int_max(cbgystart, band->y0);
+					prc->x1 = int_min(cbgxend, band->x1);
+					prc->y1 = int_min(cbgyend, band->y1);
+					
+					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+					prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+					prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
+
+					prc->cblks.dec = (opj_tcd_cblk_dec_t*) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_dec_t));
+
+					prc->incltree = tgt_create(prc->cw, prc->ch);
+					prc->imsbtree = tgt_create(prc->cw, prc->ch);
+					
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
+						int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+						int cblkyend = cblkystart + (1 << cblkheightexpn);					
+
+						opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+						cblk->data = NULL;
+						cblk->segs = NULL;
+						/* code-block size (global) */
+						cblk->x0 = int_max(cblkxstart, prc->x0);
+						cblk->y0 = int_max(cblkystart, prc->y0);
+						cblk->x1 = int_min(cblkxend, prc->x1);
+						cblk->y1 = int_min(cblkyend, prc->y1);
+						cblk->numsegs = 0;
+					}
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
+	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
+}
+
+void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final) {
+	int compno, resno, bandno, precno, cblkno;
+	int value;			/*, matrice[tcd_tcp->numlayers][tcd_tile->comps[0].numresolutions][3]; */
+	int matrice[10][10][3];
+	int i, j, k;
+
+	opj_cp_t *cp = tcd->cp;
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+	opj_tcp_t *tcd_tcp = tcd->tcp;
+
+	/*matrice=(int*)opj_malloc(tcd_tcp->numlayers*tcd_tile->comps[0].numresolutions*3*sizeof(int)); */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		for (i = 0; i < tcd_tcp->numlayers; i++) {
+			for (j = 0; j < tilec->numresolutions; j++) {
+				for (k = 0; k < 3; k++) {
+					matrice[i][j][k] =
+						(int) (cp->matrice[i * tilec->numresolutions * 3 + j * 3 + k] 
+						* (float) (tcd->image->comps[compno].prec / 16.0));
+				}
+			}
+		}
+        
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+						opj_tcd_layer_t *layer = &cblk->layers[layno];
+						int n;
+						int imsb = tcd->image->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
+						/* Correction of the matrix of coefficient to include the IMSB information */
+						if (layno == 0) {
+							value = matrice[layno][resno][bandno];
+							if (imsb >= value) {
+								value = 0;
+							} else {
+								value -= imsb;
+							}
+						} else {
+							value =	matrice[layno][resno][bandno] -	matrice[layno - 1][resno][bandno];
+							if (imsb >= matrice[layno - 1][resno][bandno]) {
+								value -= (imsb - matrice[layno - 1][resno][bandno]);
+								if (value < 0) {
+									value = 0;
+								}
+							}
+						}
+						
+						if (layno == 0) {
+							cblk->numpassesinlayers = 0;
+						}
+						
+						n = cblk->numpassesinlayers;
+						if (cblk->numpassesinlayers == 0) {
+							if (value != 0) {
+								n = 3 * value - 2 + cblk->numpassesinlayers;
+							} else {
+								n = cblk->numpassesinlayers;
+							}
+						} else {
+							n = 3 * value + cblk->numpassesinlayers;
+						}
+						
+						layer->numpasses = n - cblk->numpassesinlayers;
+						
+						if (!layer->numpasses)
+							continue;
+						
+						if (cblk->numpassesinlayers == 0) {
+							layer->len = cblk->passes[n - 1].rate;
+							layer->data = cblk->data;
+						} else {
+							layer->len = cblk->passes[n - 1].rate - cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+						}
+						if (final)
+							cblk->numpassesinlayers = n;
+					}
+				}
+			}
+		}
+	}
+}
+
+void tcd_rateallocate_fixed(opj_tcd_t *tcd) {
+	int layno;
+	for (layno = 0; layno < tcd->tcp->numlayers; layno++) {
+		tcd_makelayer_fixed(tcd, layno, 1);
+	}
+}
+
+void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final) {
+	int compno, resno, bandno, precno, cblkno, passno;
+	
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+
+	tcd_tile->distolayer[layno] = 0;	/* fixed_quality */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+						opj_tcd_layer_t *layer = &cblk->layers[layno];
+						
+						int n;
+						if (layno == 0) {
+							cblk->numpassesinlayers = 0;
+						}
+						n = cblk->numpassesinlayers;
+						for (passno = cblk->numpassesinlayers; passno < cblk->totalpasses; passno++) {
+							int dr;
+							double dd;
+							opj_tcd_pass_t *pass = &cblk->passes[passno];
+							if (n == 0) {
+								dr = pass->rate;
+								dd = pass->distortiondec;
+							} else {
+								dr = pass->rate - cblk->passes[n - 1].rate;
+								dd = pass->distortiondec - cblk->passes[n - 1].distortiondec;
+							}
+							if (!dr) {
+								if (dd != 0)
+									n = passno + 1;
+								continue;
+							}
+							if (dd / dr >= thresh)
+								n = passno + 1;
+						}
+						layer->numpasses = n - cblk->numpassesinlayers;
+						
+						if (!layer->numpasses) {
+							layer->disto = 0;
+							continue;
+						}
+						if (cblk->numpassesinlayers == 0) {
+							layer->len = cblk->passes[n - 1].rate;
+							layer->data = cblk->data;
+							layer->disto = cblk->passes[n - 1].distortiondec;
+						} else {
+							layer->len = cblk->passes[n - 1].rate -	cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->data = cblk->data + cblk->passes[cblk->numpassesinlayers - 1].rate;
+							layer->disto = cblk->passes[n - 1].distortiondec - cblk->passes[cblk->numpassesinlayers - 1].distortiondec;
+						}
+						
+						tcd_tile->distolayer[layno] += layer->disto;	/* fixed_quality */
+						
+						if (final)
+							cblk->numpassesinlayers = n;
+					}
+				}
+			}
+		}
+	}
+}
+
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
+	int compno, resno, bandno, precno, cblkno, passno, layno;
+	double min, max;
+	double cumdisto[100];	/* fixed_quality */
+	const double K = 1;		/* 1.1; fixed_quality */
+	double maxSE = 0;
+
+	opj_cp_t *cp = tcd->cp;
+	opj_tcd_tile_t *tcd_tile = tcd->tcd_tile;
+	opj_tcp_t *tcd_tcp = tcd->tcp;
+
+	min = DBL_MAX;
+	max = 0;
+	
+	tcd_tile->numpix = 0;		/* fixed_quality */
+	
+	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
+		tilec->numpix = 0;
+
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
+
+						for (passno = 0; passno < cblk->totalpasses; passno++) {
+							opj_tcd_pass_t *pass = &cblk->passes[passno];
+							int dr;
+							double dd, rdslope;
+							if (passno == 0) {
+								dr = pass->rate;
+								dd = pass->distortiondec;
+							} else {
+								dr = pass->rate - cblk->passes[passno - 1].rate;
+								dd = pass->distortiondec - cblk->passes[passno - 1].distortiondec;
+							}
+							if (dr == 0) {
+								continue;
+							}
+							rdslope = dd / dr;
+							if (rdslope < min) {
+								min = rdslope;
+							}
+							if (rdslope > max) {
+								max = rdslope;
+							}
+						} /* passno */
+						
+						/* fixed_quality */
+						tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+						tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+					} /* cbklno */
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+		
+		maxSE += (((double)(1 << tcd->image->comps[compno].prec) - 1.0) 
+			* ((double)(1 << tcd->image->comps[compno].prec) -1.0)) 
+			* ((double)(tilec->numpix));
+	} /* compno */
+	
+	/* index file */
+	if(cstr_info) {
+		opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];
+		tile_info->numpix = tcd_tile->numpix;
+		tile_info->distotile = tcd_tile->distotile;
+		tile_info->thresh = (double *) opj_malloc(tcd_tcp->numlayers * sizeof(double));
+	}
+	
+	for (layno = 0; layno < tcd_tcp->numlayers; layno++) {
+		double lo = min;
+		double hi = max;
+		int success = 0;
+		int maxlen = tcd_tcp->rates[layno] ? int_min(((int) ceil(tcd_tcp->rates[layno])), len) : len;
+		double goodthresh = 0;
+		double stable_thresh = 0;
+		int i;
+		double distotarget;		/* fixed_quality */
+		
+		/* fixed_quality */
+		distotarget = tcd_tile->distotile - ((K * maxSE) / pow((float)10, tcd_tcp->distoratio[layno] / 10));
+        
+		/* Don't try to find an optimal threshold but rather take everything not included yet, if
+		  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
+		  -q xx,yy,zz,0	  (fixed_quality == 1 and distoratio == 0)
+		  ==> possible to have some lossy layers and the last layer for sure lossless */
+		if ( ((cp->disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {
+			opj_t2_t *t2 = t2_create(tcd->cinfo, tcd->image, cp);
+			double thresh = 0;
+
+			for (i = 0; i < 32; i++) {
+				int l = 0;
+				double distoachieved = 0;	/* fixed_quality */
+				thresh = (lo + hi) / 2;
+				
+				tcd_makelayer(tcd, layno, thresh, 0);
+				
+				if (cp->fixed_quality) {	/* fixed_quality */
+					if(cp->cinema){
+						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+						if (l == -999) {
+							lo = thresh;
+							continue;
+						}else{
+           		distoachieved =	layno == 0 ? 
+							tcd_tile->distolayer[0]	: cumdisto[layno - 1] + tcd_tile->distolayer[layno];
+							if (distoachieved < distotarget) {
+								hi=thresh; 
+								stable_thresh = thresh;
+								continue;
+							}else{
+								lo=thresh;
+							}
+						}
+					}else{
+						distoachieved =	(layno == 0) ? 
+							tcd_tile->distolayer[0]	: (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);
+						if (distoachieved < distotarget) {
+							hi = thresh;
+							stable_thresh = thresh;
+							continue;
+						}
+						lo = thresh;
+					}
+				} else {
+					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+					/* TODO: what to do with l ??? seek / tell ??? */
+					/* opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen); */
+					if (l == -999) {
+						lo = thresh;
+						continue;
+					}
+					hi = thresh;
+					stable_thresh = thresh;
+				}
+			}
+			success = 1;
+			goodthresh = stable_thresh == 0? thresh : stable_thresh;
+			t2_destroy(t2);
+		} else {
+			success = 1;
+			goodthresh = min;
+		}
+		
+		if (!success) {
+			return false;
+		}
+		
+		if(cstr_info) {	/* Threshold for Marcela Index */
+			cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
+		}
+		tcd_makelayer(tcd, layno, goodthresh, 1);
+        
+		/* fixed_quality */
+		cumdisto[layno] = (layno == 0) ? tcd_tile->distolayer[0] : (cumdisto[layno - 1] + tcd_tile->distolayer[layno]);	
+	}
+
+	return true;
+}
+
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
+	int compno;
+	int l, i, numpacks = 0;
+	opj_tcd_tile_t *tile = NULL;
+	opj_tcp_t *tcd_tcp = NULL;
+	opj_cp_t *cp = NULL;
+
+	opj_tcp_t *tcp = &tcd->cp->tcps[0];
+	opj_tccp_t *tccp = &tcp->tccps[0];
+	opj_image_t *image = tcd->image;
+	
+	opj_t1_t *t1 = NULL;		/* T1 component */
+	opj_t2_t *t2 = NULL;		/* T2 component */
+
+	tcd->tcd_tileno = tileno;
+	tcd->tcd_tile = tcd->tcd_image->tiles;
+	tcd->tcp = &tcd->cp->tcps[tileno];
+
+	tile = tcd->tcd_tile;
+	tcd_tcp = tcd->tcp;
+	cp = tcd->cp;
+
+	if(tcd->cur_tp_num == 0){
+		tcd->encoding_time = opj_clock();	/* time needed to encode a tile */
+		/* INDEX >> "Precinct_nb_X et Precinct_nb_Y" */
+		if(cstr_info) {
+			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[0];	/* based on component 0 */
+			for (i = 0; i < tilec_idx->numresolutions; i++) {
+				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[i];
+				
+				cstr_info->tile[tileno].pw[i] = res_idx->pw;
+				cstr_info->tile[tileno].ph[i] = res_idx->ph;
+				
+				numpacks += res_idx->pw * res_idx->ph;
+				
+				cstr_info->tile[tileno].pdx[i] = tccp->prcw[i];
+				cstr_info->tile[tileno].pdy[i] = tccp->prch[i];
+			}
+			cstr_info->tile[tileno].packet = (opj_packet_info_t*) opj_calloc(cstr_info->numcomps * cstr_info->numlayers * numpacks, sizeof(opj_packet_info_t));
+		}
+		/* << INDEX */
+		
+		/*---------------TILE-------------------*/
+		
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			int x, y;
+			
+			int adjust = image->comps[compno].sgnd ? 0 : 1 << (image->comps[compno].prec - 1);
+			int offset_x = int_ceildiv(image->x0, image->comps[compno].dx);
+			int offset_y = int_ceildiv(image->y0, image->comps[compno].dy);
+			
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			int tw = tilec->x1 - tilec->x0;
+			int w = int_ceildiv(image->x1 - image->x0, image->comps[compno].dx);
+			
+			/* extract tile data */
+			
+			if (tcd_tcp->tccps[compno].qmfbid == 1) {
+				for (y = tilec->y0; y < tilec->y1; y++) {
+					/* start of the src tile scanline */
+					int *data = &image->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w];
+					/* start of the dst tile scanline */
+					int *tile_data = &tilec->data[(y - tilec->y0) * tw];
+					for (x = tilec->x0; x < tilec->x1; x++) {
+						*tile_data++ = *data++ - adjust;
+					}
+				}
+			} else if (tcd_tcp->tccps[compno].qmfbid == 0) {
+				for (y = tilec->y0; y < tilec->y1; y++) {
+					/* start of the src tile scanline */
+					int *data = &image->comps[compno].data[(tilec->x0 - offset_x) + (y - offset_y) * w];
+					/* start of the dst tile scanline */
+					int *tile_data = &tilec->data[(y - tilec->y0) * tw];
+					for (x = tilec->x0; x < tilec->x1; x++) {
+						*tile_data++ = (*data++ - adjust) << 11;
+					}
+					
+				}
+			}
+		}
+		
+		/*----------------MCT-------------------*/
+		if (tcd_tcp->mct) {
+			int samples = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
+			if (tcd_tcp->tccps[0].qmfbid == 0) {
+				mct_encode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
+			} else {
+				mct_encode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, samples);
+			}
+		}
+		
+		/*----------------DWT---------------------*/
+		
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			if (tcd_tcp->tccps[compno].qmfbid == 1) {
+				dwt_encode(tilec);
+			} else if (tcd_tcp->tccps[compno].qmfbid == 0) {
+				dwt_encode_real(tilec);
+			}
+		}
+		
+		/*------------------TIER1-----------------*/
+		t1 = t1_create(tcd->cinfo);
+		t1_encode_cblks(t1, tile, tcd_tcp);
+		t1_destroy(t1);
+		
+		/*-----------RATE-ALLOCATE------------------*/
+		
+		/* INDEX */
+		if(cstr_info) {
+			cstr_info->index_write = 0;
+		}
+		if (cp->disto_alloc || cp->fixed_quality) {	/* fixed_quality */
+			/* Normal Rate/distortion allocation */
+			tcd_rateallocate(tcd, dest, len, cstr_info);
+		} else {
+			/* Fixed layer allocation */
+			tcd_rateallocate_fixed(tcd);
+		}
+	}
+	/*--------------TIER2------------------*/
+
+	/* INDEX */
+	if(cstr_info) {
+		cstr_info->index_write = 1;
+	}
+
+	t2 = t2_create(tcd->cinfo, image, cp);
+	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS);
+	t2_destroy(t2);
+	
+	/*---------------CLEAN-------------------*/
+
+	
+	if(tcd->cur_tp_num == tcd->cur_totnum_tp - 1){
+		tcd->encoding_time = opj_clock() - tcd->encoding_time;
+		opj_event_msg(tcd->cinfo, EVT_INFO, "- tile encoded in %f s\n", tcd->encoding_time);
+
+		/* cleaning memory */
+		for (compno = 0; compno < tile->numcomps; compno++) {
+			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+			opj_aligned_free(tilec->data);
+		}
+	}
+
+	return l;
+}
+
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info) {
+	int l;
+	int compno;
+	int eof = 0;
+	double tile_time, t1_time, dwt_time;
+	opj_tcd_tile_t *tile = NULL;
+
+	opj_t1_t *t1 = NULL;		/* T1 component */
+	opj_t2_t *t2 = NULL;		/* T2 component */
+	
+	tcd->tcd_tileno = tileno;
+	tcd->tcd_tile = &(tcd->tcd_image->tiles[tileno]);
+	tcd->tcp = &(tcd->cp->tcps[tileno]);
+	tile = tcd->tcd_tile;
+	
+	tile_time = opj_clock();	/* time needed to decode a tile */
+	opj_event_msg(tcd->cinfo, EVT_INFO, "tile %d of %d\n", tileno + 1, tcd->cp->tw * tcd->cp->th);
+
+	/* INDEX >>  */
+	if(cstr_info) {
+		int resno, compno, numprec = 0;
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			opj_tcp_t *tcp = &tcd->cp->tcps[0];
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[compno];	
+			for (resno = 0; resno < tilec_idx->numresolutions; resno++) {
+				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];
+				cstr_info->tile[tileno].pw[resno] = res_idx->pw;
+				cstr_info->tile[tileno].ph[resno] = res_idx->ph;
+				numprec += res_idx->pw * res_idx->ph;
+				if (tccp->csty & J2K_CP_CSTY_PRT) {
+					cstr_info->tile[tileno].pdx[resno] = tccp->prcw[resno];
+					cstr_info->tile[tileno].pdy[resno] = tccp->prch[resno];
+				}
+				else {
+					cstr_info->tile[tileno].pdx[resno] = 15;
+					cstr_info->tile[tileno].pdx[resno] = 15;
+				}
+			}
+		}
+		cstr_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));
+		cstr_info->packno = 0;
+	}
+	/* << INDEX */
+	
+	/*--------------TIER2------------------*/
+	
+	t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
+	l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
+	t2_destroy(t2);
+
+	if (l == -999) {
+		eof = 1;
+		opj_event_msg(tcd->cinfo, EVT_ERROR, "tcd_decode: incomplete bistream\n");
+	}
+	
+	/*------------------TIER1-----------------*/
+	
+	t1_time = opj_clock();	/* time needed to decode a tile */
+	t1 = t1_create(tcd->cinfo);
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		/* The +3 is headroom required by the vectorized DWT */
+		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
+		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
+	}
+	t1_destroy(t1);
+	t1_time = opj_clock() - t1_time;
+	opj_event_msg(tcd->cinfo, EVT_INFO, "- tiers-1 took %f s\n", t1_time);
+	
+	/*----------------DWT---------------------*/
+
+	dwt_time = opj_clock();	/* time needed to decode a tile */
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		int numres2decode;
+
+		if (tcd->cp->reduce != 0) {
+			tcd->image->comps[compno].resno_decoded =
+				tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
+			if (tcd->image->comps[compno].resno_decoded < 0) {
+				opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. The number of resolutions to remove is higher than the number "
+					"of resolutions in the original codestream\nModify the cp_reduce parameter.\n");
+				return false;
+			}
+		}
+
+		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
+		if(numres2decode > 0){
+			if (tcd->tcp->tccps[compno].qmfbid == 1) {
+				dwt_decode(tilec, numres2decode);
+			} else {
+				dwt_decode_real(tilec, numres2decode);
+			}
+		}
+	}
+	dwt_time = opj_clock() - dwt_time;
+	opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
+
+	/*----------------MCT-------------------*/
+
+	if (tcd->tcp->mct) {
+		int n = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
+		if (tcd->tcp->tccps[0].qmfbid == 1) {
+			mct_decode(
+					tile->comps[0].data,
+					tile->comps[1].data,
+					tile->comps[2].data, 
+					n);
+		} else {
+			mct_decode_real(
+					(float*)tile->comps[0].data,
+					(float*)tile->comps[1].data,
+					(float*)tile->comps[2].data, 
+					n);
+		}
+	}
+
+	/*---------------TILE-------------------*/
+
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_image_comp_t* imagec = &tcd->image->comps[compno];
+		opj_tcd_resolution_t* res = &tilec->resolutions[imagec->resno_decoded];
+		int adjust = imagec->sgnd ? 0 : 1 << (imagec->prec - 1);
+		int min = imagec->sgnd ? -(1 << (imagec->prec - 1)) : 0;
+		int max = imagec->sgnd ?  (1 << (imagec->prec - 1)) - 1 : (1 << imagec->prec) - 1;
+
+		int tw = tilec->x1 - tilec->x0;
+		int w = imagec->w;
+
+		int offset_x = int_ceildivpow2(imagec->x0, imagec->factor);
+		int offset_y = int_ceildivpow2(imagec->y0, imagec->factor);
+
+		int i, j;
+		if(!imagec->data){
+			imagec->data = (int*) opj_malloc(imagec->w * imagec->h * sizeof(int));
+		}
+		if(tcd->tcp->tccps[compno].qmfbid == 1) {
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					int v = tilec->data[i - res->x0 + (j - res->y0) * tw];
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+				}
+			}
+		}else{
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					float tmp = ((float*)tilec->data)[i - res->x0 + (j - res->y0) * tw];
+					int v = lrintf(tmp);
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+				}
+			}
+		}
+		opj_aligned_free(tilec->data);
+	}
+
+	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
+	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
+
+	if (eof) {
+		return false;
+	}
+	
+	return true;
+}
+
+void tcd_free_decode(opj_tcd_t *tcd) {
+	opj_tcd_image_t *tcd_image = tcd->tcd_image;	
+	opj_free(tcd_image->tiles);
+}
+
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
+	int compno,resno,bandno,precno;
+
+	opj_tcd_image_t *tcd_image = tcd->tcd_image;
+
+	opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->ph * res->pw; precno++) {
+					opj_tcd_precinct_t *prec = &band->precincts[precno];
+					if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+					if (prec->incltree != NULL) tgt_destroy(prec->incltree);
+				}
+				opj_free(band->precincts);
+			}
+		}
+		opj_free(tilec->resolutions);
+	}
+	opj_free(tile->comps);
+}
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tcd.h.svn-base ./libopenjpeg/.svn/text-base/tcd.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tcd.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/tcd.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,285 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#ifndef __TCD_H
+#define __TCD_H
+/**
+@file tcd.h
+@brief Implementation of a tile coder/decoder (TCD)
+
+The functions in TCD.C have for goal to encode or decode each tile independently from
+each other. The functions in TCD.C are used by some function in J2K.C.
+*/
+
+/** @defgroup TCD TCD - Implementation of a tile coder/decoder */
+/*@{*/
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_seg {
+  unsigned char** data;
+  int dataindex;
+  int numpasses;
+  int len;
+  int maxpasses;
+  int numnewpasses;
+  int newlen;
+} opj_tcd_seg_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_pass {
+  int rate;
+  double distortiondec;
+  int term, len;
+} opj_tcd_pass_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_layer {
+  int numpasses;		/* Number of passes in the layer */
+  int len;			/* len of information */
+  double disto;			/* add for index (Cfr. Marcela) */
+  unsigned char *data;		/* data */
+} opj_tcd_layer_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_cblk_enc {
+  unsigned char* data;	/* Data */
+  opj_tcd_layer_t* layers;	/* layer information */
+  opj_tcd_pass_t* passes;	/* information about the passes */
+  int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numbps;
+  int numlenbits;
+  int numpasses;		/* number of pass already done for the code-blocks */
+  int numpassesinlayers;	/* number of passes in the layer */
+  int totalpasses;		/* total number of passes */
+} opj_tcd_cblk_enc_t;
+
+typedef struct opj_tcd_cblk_dec {
+  unsigned char* data;	/* Data */
+  opj_tcd_seg_t* segs;		/* segments informations */
+	int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numbps;
+  int numlenbits;
+  int len;			/* length */
+  int numnewpasses;		/* number of pass added to the code-blocks */
+  int numsegs;			/* number of segments */
+} opj_tcd_cblk_dec_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_precinct {
+  int x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
+  int cw, ch;			/* number of precinct in width and heigth */
+  union{		/* code-blocks informations */
+	  opj_tcd_cblk_enc_t* enc;
+	  opj_tcd_cblk_dec_t* dec;
+  } cblks;
+  opj_tgt_tree_t *incltree;		/* inclusion tree */
+  opj_tgt_tree_t *imsbtree;		/* IMSB tree */
+} opj_tcd_precinct_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_band {
+  int x0, y0, x1, y1;		/* dimension of the subband : left upper corner (x0, y0) right low corner (x1,y1) */
+  int bandno;
+  opj_tcd_precinct_t *precincts;	/* precinct information */
+  int numbps;
+  float stepsize;
+} opj_tcd_band_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_resolution {
+  int x0, y0, x1, y1;		/* dimension of the resolution level : left upper corner (x0, y0) right low corner (x1,y1) */
+  int pw, ph;
+  int numbands;			/* number sub-band for the resolution level */
+  opj_tcd_band_t bands[3];		/* subband information */
+} opj_tcd_resolution_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_tilecomp {
+  int x0, y0, x1, y1;		/* dimension of component : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numresolutions;		/* number of resolutions level */
+  opj_tcd_resolution_t *resolutions;	/* resolutions information */
+  int *data;			/* data of the component */
+  int numpix;			/* add fixed_quality */
+} opj_tcd_tilecomp_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_tile {
+  int x0, y0, x1, y1;		/* dimension of the tile : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numcomps;			/* number of components in tile */
+  opj_tcd_tilecomp_t *comps;	/* Components information */
+  int numpix;			/* add fixed_quality */
+  double distotile;		/* add fixed_quality */
+  double distolayer[100];	/* add fixed_quality */
+  /** packet number */
+  int packno;
+} opj_tcd_tile_t;
+
+/**
+FIXME: documentation
+*/
+typedef struct opj_tcd_image {
+  int tw, th;			/* number of tiles in width and heigth */
+  opj_tcd_tile_t *tiles;		/* Tiles information */
+} opj_tcd_image_t;
+
+/**
+Tile coder/decoder
+*/
+typedef struct opj_tcd {
+	/** Position of the tilepart flag in Progression order*/
+	int tp_pos;
+	/** Tile part number*/
+	int tp_num;
+	/** Current tile part number*/
+	int cur_tp_num;
+	/** Total number of tileparts of the current tile*/
+	int cur_totnum_tp;
+	/** Current Packet iterator number */
+	int cur_pino;
+	/** codec context */
+	opj_common_ptr cinfo;
+
+	/** info on each image tile */
+	opj_tcd_image_t *tcd_image;
+	/** image */
+	opj_image_t *image;
+	/** coding parameters */
+	opj_cp_t *cp;
+	/** pointer to the current encoded/decoded tile */
+	opj_tcd_tile_t *tcd_tile;
+	/** coding/decoding parameters common to all tiles */
+	opj_tcp_t *tcp;
+	/** current encoded/decoded tile */
+	int tcd_tileno;
+	/** Time taken to encode a tile*/
+	double encoding_time;
+} opj_tcd_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+
+/**
+Dump the content of a tcd structure
+*/
+void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t *img);
+/**
+Create a new TCD handle
+@param cinfo Codec context info
+@return Returns a new TCD handle if successful returns NULL otherwise
+*/
+opj_tcd_t* tcd_create(opj_common_ptr cinfo);
+/**
+Destroy a previously created TCD handle
+@param tcd TCD handle to destroy
+*/
+void tcd_destroy(opj_tcd_t *tcd);
+/**
+Initialize the tile coder (allocate the memory)
+@param tcd TCD handle
+@param image Raw image
+@param cp Coding parameters
+@param curtileno Number that identifies the tile that will be encoded
+*/
+void tcd_malloc_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno);
+/**
+Free the memory allocated for encoding
+@param tcd TCD handle
+*/
+void tcd_free_encode(opj_tcd_t *tcd);
+/**
+Initialize the tile coder (reuses the memory allocated by tcd_malloc_encode)
+@param tcd TCD handle
+@param image Raw image
+@param cp Coding parameters
+@param curtileno Number that identifies the tile that will be encoded
+*/
+void tcd_init_encode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int curtileno);
+/**
+Initialize the tile decoder
+@param tcd TCD handle
+@param image Raw image
+@param cp Coding parameters
+*/
+void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp);
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info);
+void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final);
+void tcd_rateallocate_fixed(opj_tcd_t *tcd);
+void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final);
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
+/**
+Encode a tile from the raw image into a buffer
+@param tcd TCD handle
+@param tileno Number that identifies one of the tiles to be encoded
+@param dest Destination buffer
+@param len Length of destination buffer
+@param cstr_info Codestream information structure 
+@return 
+*/
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
+/**
+Decode a tile from a buffer into a raw image
+@param tcd TCD handle
+@param src Source buffer
+@param len Length of source buffer
+@param tileno Number that identifies one of the tiles to be decoded
+*/
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info);
+/**
+Free the memory allocated for decoding
+@param tcd TCD handle
+*/
+void tcd_free_decode(opj_tcd_t *tcd);
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno);
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __TCD_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tgt.c.svn-base ./libopenjpeg/.svn/text-base/tgt.c.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tgt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/tgt.c.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,213 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+
+/* 
+==========================================================
+   Tag-tree coder interface
+==========================================================
+*/
+
+opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv) {
+	int nplh[32];
+	int nplv[32];
+	opj_tgt_node_t *node = NULL;
+	opj_tgt_node_t *parentnode = NULL;
+	opj_tgt_node_t *parentnode0 = NULL;
+	opj_tgt_tree_t *tree = NULL;
+	int i, j, k;
+	int numlvls;
+	int n;
+
+	tree = (opj_tgt_tree_t *) opj_malloc(sizeof(opj_tgt_tree_t));
+	if(!tree) return NULL;
+	tree->numleafsh = numleafsh;
+	tree->numleafsv = numleafsv;
+
+	numlvls = 0;
+	nplh[0] = numleafsh;
+	nplv[0] = numleafsv;
+	tree->numnodes = 0;
+	do {
+		n = nplh[numlvls] * nplv[numlvls];
+		nplh[numlvls + 1] = (nplh[numlvls] + 1) / 2;
+		nplv[numlvls + 1] = (nplv[numlvls] + 1) / 2;
+		tree->numnodes += n;
+		++numlvls;
+	} while (n > 1);
+	
+	/* ADD */
+	if (tree->numnodes == 0) {
+		opj_free(tree);
+		return NULL;
+	}
+
+	tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
+	if(!tree->nodes) {
+		opj_free(tree);
+		return NULL;
+	}
+
+	node = tree->nodes;
+	parentnode = &tree->nodes[tree->numleafsh * tree->numleafsv];
+	parentnode0 = parentnode;
+	
+	for (i = 0; i < numlvls - 1; ++i) {
+		for (j = 0; j < nplv[i]; ++j) {
+			k = nplh[i];
+			while (--k >= 0) {
+				node->parent = parentnode;
+				++node;
+				if (--k >= 0) {
+					node->parent = parentnode;
+					++node;
+				}
+				++parentnode;
+			}
+			if ((j & 1) || j == nplv[i] - 1) {
+				parentnode0 = parentnode;
+			} else {
+				parentnode = parentnode0;
+				parentnode0 += nplh[i];
+			}
+		}
+	}
+	node->parent = 0;
+	
+	tgt_reset(tree);
+	
+	return tree;
+}
+
+void tgt_destroy(opj_tgt_tree_t *tree) {
+	opj_free(tree->nodes);
+	opj_free(tree);
+}
+
+void tgt_reset(opj_tgt_tree_t *tree) {
+	int i;
+
+	if (NULL == tree)
+		return;
+	
+	for (i = 0; i < tree->numnodes; i++) {
+		tree->nodes[i].value = 999;
+		tree->nodes[i].low = 0;
+		tree->nodes[i].known = 0;
+	}
+}
+
+void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value) {
+	opj_tgt_node_t *node;
+	node = &tree->nodes[leafno];
+	while (node && node->value > value) {
+		node->value = value;
+		node = node->parent;
+	}
+}
+
+void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
+	opj_tgt_node_t *stk[31];
+	opj_tgt_node_t **stkptr;
+	opj_tgt_node_t *node;
+	int low;
+
+	stkptr = stk;
+	node = &tree->nodes[leafno];
+	while (node->parent) {
+		*stkptr++ = node;
+		node = node->parent;
+	}
+	
+	low = 0;
+	for (;;) {
+		if (low > node->low) {
+			node->low = low;
+		} else {
+			low = node->low;
+		}
+		
+		while (low < threshold) {
+			if (low >= node->value) {
+				if (!node->known) {
+					bio_write(bio, 1, 1);
+					node->known = 1;
+				}
+				break;
+			}
+			bio_write(bio, 0, 1);
+			++low;
+		}
+		
+		node->low = low;
+		if (stkptr == stk)
+			break;
+		node = *--stkptr;
+	}
+}
+
+int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold) {
+	opj_tgt_node_t *stk[31];
+	opj_tgt_node_t **stkptr;
+	opj_tgt_node_t *node;
+	int low;
+
+	stkptr = stk;
+	node = &tree->nodes[leafno];
+	while (node->parent) {
+		*stkptr++ = node;
+		node = node->parent;
+	}
+	
+	low = 0;
+	for (;;) {
+		if (low > node->low) {
+			node->low = low;
+		} else {
+			low = node->low;
+		}
+		while (low < threshold && low < node->value) {
+			if (bio_read(bio, 1)) {
+				node->value = low;
+			} else {
+				++low;
+			}
+		}
+		node->low = low;
+		if (stkptr == stk) {
+			break;
+		}
+		node = *--stkptr;
+	}
+	
+	return (node->value < threshold) ? 1 : 0;
+}
diff -urN /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tgt.h.svn-base ./libopenjpeg/.svn/text-base/tgt.h.svn-base
--- /home/robin/sldeb/trunk/libopenjpeg/.svn/text-base/tgt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libopenjpeg/.svn/text-base/tgt.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,114 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2001-2003, David Janssens
+ * Copyright (c) 2002-2003, Yannick Verschueren
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+ * Copyright (c) 2005, Herve Drolon, FreeImage Team
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __TGT_H
+#define __TGT_H
+/**
+@file tgt.h
+@brief Implementation of a tag-tree coder (TGT)
+
+The functions in TGT.C have for goal to realize a tag-tree coder. The functions in TGT.C
+are used by some function in T2.C.
+*/
+
+/** @defgroup TGT TGT - Implementation of a tag-tree coder */
+/*@{*/
+
+/**
+Tag node
+*/
+typedef struct opj_tgt_node {
+  struct opj_tgt_node *parent;
+  int value;
+  int low;
+  int known;
+} opj_tgt_node_t;
+
+/**
+Tag tree
+*/
+typedef struct opj_tgt_tree {
+  int numleafsh;
+  int numleafsv;
+  int numnodes;
+  opj_tgt_node_t *nodes;
+} opj_tgt_tree_t;
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Create a tag-tree
+@param numleafsh Width of the array of leafs of the tree
+@param numleafsv Height of the array of leafs of the tree
+@return Returns a new tag-tree if successful, returns NULL otherwise
+*/
+opj_tgt_tree_t *tgt_create(int numleafsh, int numleafsv);
+/**
+Destroy a tag-tree, liberating memory
+@param tree Tag-tree to destroy
+*/
+void tgt_destroy(opj_tgt_tree_t *tree);
+/**
+Reset a tag-tree (set all leaves to 0)
+@param tree Tag-tree to reset
+*/
+void tgt_reset(opj_tgt_tree_t *tree);
+/**
+Set the value of a leaf of a tag-tree
+@param tree Tag-tree to modify
+@param leafno Number that identifies the leaf to modify
+@param value New value of the leaf
+*/
+void tgt_setvalue(opj_tgt_tree_t *tree, int leafno, int value);
+/**
+Encode the value of a leaf of the tag-tree up to a given threshold
+@param bio Pointer to a BIO handle
+@param tree Tag-tree to modify
+@param leafno Number that identifies the leaf to encode
+@param threshold Threshold to use when encoding value of the leaf
+*/
+void tgt_encode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+/**
+Decode the value of a leaf of the tag-tree up to a given threshold
+@param bio Pointer to a BIO handle
+@param tree Tag-tree to decode
+@param leafno Number that identifies the leaf to decode
+@param threshold Threshold to use when decoding value of the leaf
+@return Returns 1 if the node's value < threshold, returns 0 otherwise
+*/
+int tgt_decode(opj_bio_t *bio, opj_tgt_tree_t *tree, int leafno, int threshold);
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __TGT_H */
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t1.c ./libopenjpeg/t1.c
--- /home/robin/sldeb/trunk/libopenjpeg/t1.c	2007-06-04 14:23:26.000000000 +0100
+++ ./libopenjpeg/t1.c	2007-11-27 22:39:50.000000000 +0000
@@ -39,9 +39,9 @@
 /** @name Local static functions */
 /*@{*/
 
-static char t1_getctxno_zc(int f, int orient);
+static INLINE char t1_getctxno_zc(int f, int orient);
 static char t1_getctxno_sc(int f);
-static char t1_getctxno_mag(int f);
+static INLINE int t1_getctxno_mag(int f);
 static char t1_getspb(int f);
 static short t1_getnmsedec_sig(int x, int bitpos);
 static short t1_getnmsedec_ref(int x, int bitpos);
@@ -194,7 +194,7 @@
 */
 static void t1_encode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_enc_t* cblk,
 		int orient,
 		int compno,
 		int level,
@@ -213,7 +213,7 @@
 */
 static void t1_decode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_dec_t* cblk,
 		int orient,
 		int roishift,
 		int cblksty);
@@ -232,8 +232,10 @@
 	return lut_ctxno_sc[(f & (T1_SIG_PRIM | T1_SGN)) >> 4];
 }
 
-static char t1_getctxno_mag(int f) {
-	return lut_ctxno_mag[(f & T1_SIG_OTH) | (((f & T1_REFINE) != 0) << 11)];
+static int t1_getctxno_mag(int f) {
+	int tmp1 = (f & T1_SIG_OTH) ? T1_CTXNO_MAG + 1 : T1_CTXNO_MAG;
+	int tmp2 = (f & T1_REFINE) ? T1_CTXNO_MAG + 2 : tmp1;
+	return (tmp2);
 }
 
 static char t1_getspb(int f) {
@@ -261,21 +263,22 @@
 	flag_t *sp = flagsp + stride;
 
 	static const flag_t mod[] = {
-		T1_SIG_S,            T1_SIG_N,            T1_SIG_E,            T1_SIG_W,
-		T1_SIG_S | T1_SGN_S, T1_SIG_N | T1_SGN_N, T1_SIG_E | T1_SGN_E, T1_SIG_W | T1_SGN_W
+		T1_SIG_S, T1_SIG_S|T1_SGN_S,
+		T1_SIG_E, T1_SIG_E|T1_SGN_E,
+		T1_SIG_W, T1_SIG_W|T1_SGN_W,
+		T1_SIG_N, T1_SIG_N|T1_SGN_N
 	};
 
-	s <<= 2;
-
 	np[-1] |= T1_SIG_SE;
 	np[0]  |= mod[s];
 	np[1]  |= T1_SIG_SW;
 
 	flagsp[-1] |= mod[s+2];
-	flagsp[1]  |= mod[s+3];
+	flagsp[0]  |= T1_SIG;
+	flagsp[1]  |= mod[s+4];
 
 	sp[-1] |= T1_SIG_NE;
-	sp[0]  |= mod[s+1];
+	sp[0]  |= mod[s+6];
 	sp[1]  |= T1_SIG_NW;
 }
 
@@ -297,25 +300,22 @@
 	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
 	if ((flag & T1_SIG_OTH) && !(flag & (T1_SIG | T1_VISIT))) {
 		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));	/* ESSAI */
 			mqc_bypass_enc(mqc, v);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
 			mqc_encode(mqc, v);
 		}
 		if (v) {
 			v = *datap < 0 ? 1 : 0;
 			*nmsedec +=	t1_getnmsedec_sig(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
+			mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
 			if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-				mqc_setcurctx(mqc, t1_getctxno_sc(flag));	/* ESSAI */
 				mqc_bypass_enc(mqc, v);
 			} else {
-				mqc_setcurctx(mqc, t1_getctxno_sc(flag));
 				mqc_encode(mqc, v ^ t1_getspb(flag));
 			}
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 		*flagsp |= T1_VISIT;
 	}
@@ -342,7 +342,6 @@
 				v = raw_decode(raw);	/* ESSAI */
 				*datap = v ? -oneplushalf : oneplushalf;
 				t1_updateflags(flagsp, v, t1->flags_stride);
-				*flagsp |= T1_SIG;
 			}
 		} else {
 			mqc_setcurctx(mqc, t1_getctxno_zc(flag, orient));
@@ -351,7 +350,6 @@
 				v = mqc_decode(mqc) ^ t1_getspb(flag);
 				*datap = v ? -oneplushalf : oneplushalf;
 				t1_updateflags(flagsp, v, t1->flags_stride);
-				*flagsp |= T1_SIG;
 			}
 		}
 		*flagsp |= T1_VISIT;
@@ -434,11 +432,10 @@
 	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
 		*nmsedec += t1_getnmsedec_ref(int_abs(*datap), bpno + T1_NMSEDEC_FRACBITS);
 		v = int_abs(*datap) & one ? 1 : 0;
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {	/* BYPASS/LAZY MODE */
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 			mqc_bypass_enc(mqc, v);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));
 			mqc_encode(mqc, v);
 		}
 		*flagsp |= T1_REFINE;
@@ -461,11 +458,10 @@
 	
 	flag = vsc ? ((*flagsp) & (~(T1_SIG_S | T1_SIG_SE | T1_SIG_SW | T1_SGN_S))) : (*flagsp);
 	if ((flag & (T1_SIG | T1_VISIT)) == T1_SIG) {
+		mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 		if (type == T1_TYPE_RAW) {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));	/* ESSAI */
 			v = raw_decode(raw);
 		} else {
-			mqc_setcurctx(mqc, t1_getctxno_mag(flag));
 			v = mqc_decode(mqc);
 		}
 		t = v ? poshalf : neghalf;
@@ -560,7 +556,6 @@
 			v = *datap < 0 ? 1 : 0;
 			mqc_encode(mqc, v ^ t1_getspb(flag));
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 	}
 	*flagsp &= ~T1_VISIT;
@@ -591,7 +586,6 @@
 			v = mqc_decode(mqc) ^ t1_getspb(flag);
 			*datap = v ? -oneplushalf : oneplushalf;
 			t1_updateflags(flagsp, v, t1->flags_stride);
-			*flagsp |= T1_SIG;
 		}
 	}
 	*flagsp &= ~T1_VISIT;
@@ -758,53 +752,47 @@
 	return wmsedec;
 }
 
-static void allocate_buffers(
+static bool allocate_buffers(
 		opj_t1_t *t1,
 		int w,
 		int h)
 {
-	int datasize;
+	int datasize=w * h;
 	int flagssize;
 
-	datasize=w * h;
-	//fprintf(stderr,"w=%i h=%i datasize=%i flagssize=%i\n",w,h,datasize,flagssize);
-
 	if(datasize > t1->datasize){
-		//fprintf(stderr,"Allocating t1->data: datasize=%i\n",datasize);
-		free(t1->data);
-		t1->data=malloc(datasize * sizeof(int));
+		opj_aligned_free(t1->data);
+		t1->data = (int*) opj_aligned_malloc(datasize * sizeof(int));
 		if(!t1->data){
-			return;
+			return false;
 		}
 		t1->datasize=datasize;
 	}
-	//memset(t1->data,0xff,t1->datasize);
 	memset(t1->data,0,datasize * sizeof(int));
 
 	t1->flags_stride=w+2;
 	flagssize=t1->flags_stride * (h+2);
 
 	if(flagssize > t1->flagssize){
-		//fprintf(stderr,"Allocating t1->flags: flagssize=%i\n",flagssize);
-		free(t1->flags);
-		t1->flags=malloc(flagssize * sizeof(flag_t));
+		opj_aligned_free(t1->flags);
+		t1->flags = (flag_t*) opj_aligned_malloc(flagssize * sizeof(flag_t));
 		if(!t1->flags){
-			fprintf(stderr,"Allocating t1->flags FAILED!\n");
-			return;
+			return false;
 		}
 		t1->flagssize=flagssize;
 	}
-	//memset(t1->flags,0xff,t1->flagssize);
 	memset(t1->flags,0,flagssize * sizeof(flag_t));
 
 	t1->w=w;
 	t1->h=h;
+
+	return true;
 }
 
 /** mod fixed_quality */
 static void t1_encode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_enc_t* cblk,
 		int orient,
 		int compno,
 		int level,
@@ -814,23 +802,22 @@
 		int numcomps,
 		opj_tcd_tile_t * tile)
 {
-	int i, j;
-	int passno;
-	int bpno, passtype;
-	int max;
-	int nmsedec = 0;
 	double cumwmsedec = 0.0;
-	char type = T1_TYPE_MQ;
-	
+
 	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
+
+	int passno, bpno, passtype;
+	int nmsedec = 0;
+	int i, max;
+	char type = T1_TYPE_MQ;
+	double tempwmsedec;
+
 	max = 0;
-	for (j = 0; j < t1->h; ++j) {
-		for (i = 0; i < t1->w; ++i) {
-			max = int_max(max, int_abs(t1->data[(j * t1->w) + i]));
-		}
+	for (i = 0; i < t1->w * t1->h; ++i) {
+		int tmp = abs(t1->data[i]);
+		max = int_max(max, tmp);
 	}
-	
+
 	cblk->numbps = max ? (int_floorlog2(max) + 1) - T1_NMSEDEC_FRACBITS : 0;
 	
 	bpno = cblk->numbps - 1;
@@ -863,8 +850,9 @@
 		}
 		
 		/* fixed_quality */
-		cumwmsedec += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
-		tile->distotile += t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+		tempwmsedec = t1_getwmsedec(nmsedec, compno, level, orient, bpno, qmfbid, stepsize, numcomps);
+		cumwmsedec += tempwmsedec;
+		tile->distotile += tempwmsedec;
 		
 		/* Code switch "RESTART" (i.e. TERMALL) */
 		if ((cblksty & J2K_CCP_CBLKSTY_TERMALL)	&& !((passtype == 2) && (bpno - 1 < 0))) {
@@ -937,23 +925,26 @@
 
 static void t1_decode_cblk(
 		opj_t1_t *t1,
-		opj_tcd_cblk_t * cblk,
+		opj_tcd_cblk_dec_t* cblk,
 		int orient,
 		int roishift,
 		int cblksty)
 {
+	opj_raw_t *raw = t1->raw;	/* RAW component */
+	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
+
 	int bpno, passtype;
 	int segno, passno;
 	char type = T1_TYPE_MQ; /* BYPASS mode */
-	
-	opj_raw_t *raw = t1->raw;	/* RAW component */
-	opj_mqc_t *mqc = t1->mqc;	/* MQC component */
-	
-	allocate_buffers(
-			t1,
-			cblk->x1 - cblk->x0,
-			cblk->y1 - cblk->y0);
-	
+
+	if(!allocate_buffers(
+				t1,
+				cblk->x1 - cblk->x0,
+				cblk->y1 - cblk->y0))
+	{
+		return;
+	}
+
 	bpno = roishift + cblk->numbps - 1;
 	passtype = 2;
 	
@@ -967,10 +958,14 @@
 		
 		/* BYPASS mode */
 		type = ((bpno <= (cblk->numbps - 1) - 4) && (passtype < 2) && (cblksty & J2K_CCP_CBLKSTY_LAZY)) ? T1_TYPE_RAW : T1_TYPE_MQ;
+		/* FIXME: slviewer gets here with a null pointer. Why? Partially downloaded and/or corrupt textures? */
+		if(seg->data == NULL){
+			continue;
+		}
 		if (type == T1_TYPE_RAW) {
-			raw_init_dec(raw, seg->data, seg->len);
+			raw_init_dec(raw, (*seg->data) + seg->dataindex, seg->len);
 		} else {
-			mqc_init_dec(mqc, seg->data, seg->len);
+			mqc_init_dec(mqc, (*seg->data) + seg->dataindex, seg->len);
 		}
 		
 		for (passno = 0; passno < seg->numpasses; ++passno) {
@@ -1003,19 +998,19 @@
 /* ----------------------------------------------------------------------- */
 
 opj_t1_t* t1_create(opj_common_ptr cinfo) {
-	opj_t1_t *t1 = (opj_t1_t*) malloc(sizeof(opj_t1_t));
+	opj_t1_t *t1 = (opj_t1_t*) opj_malloc(sizeof(opj_t1_t));
 	if(!t1)
 		return NULL;
 
-		t1->cinfo = cinfo;
-		/* create MQC and RAW handles */
-		t1->mqc = mqc_create();
-		t1->raw = raw_create();
+	t1->cinfo = cinfo;
+	/* create MQC and RAW handles */
+	t1->mqc = mqc_create();
+	t1->raw = raw_create();
 
-	t1->datasize=0;
 	t1->data=NULL;
-	t1->flagssize=0;
 	t1->flags=NULL;
+	t1->datasize=0;
+	t1->flagssize=0;
 
 	return t1;
 }
@@ -1025,9 +1020,9 @@
 		/* destroy MQC and RAW handles */
 		mqc_destroy(t1->mqc);
 		raw_destroy(t1->raw);
-		free(t1->data);
-		free(t1->flags);
-		free(t1);
+		opj_aligned_free(t1->data);
+		opj_aligned_free(t1->flags);
+		opj_free(t1);
 	}
 }
 
@@ -1041,23 +1036,29 @@
 	tile->distotile = 0;		/* fixed_quality */
 
 	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_tccp_t* tccp = &tcp->tccps[compno];
+		int tile_w = tilec->x1 - tilec->x0;
 
 		for (resno = 0; resno < tilec->numresolutions; ++resno) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
 
 			for (bandno = 0; bandno < res->numbands; ++bandno) {
-				opj_tcd_band_t *band = &res->bands[bandno];
+				opj_tcd_band_t* restrict band = &res->bands[bandno];
 
 				for (precno = 0; precno < res->pw * res->ph; ++precno) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
-						int x, y, w, i, j, orient;
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+						int* restrict datap;
+						int* restrict tiledp;
+						int cblk_w;
+						int cblk_h;
+						int i, j;
 
-						x = cblk->x0 - band->x0;
-						y = cblk->y0 - band->y0;
+						int x = cblk->x0 - band->x0;
+						int y = cblk->y0 - band->y0;
 						if (band->bandno & 1) {
 							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
 							x += pres->x1 - pres->x0;
@@ -1067,45 +1068,47 @@
 							y += pres->y1 - pres->y0;
 						}
 
-						allocate_buffers(
-								t1,
-								cblk->x1 - cblk->x0,
-								cblk->y1 - cblk->y0);
+						if(!allocate_buffers(
+									t1,
+									cblk->x1 - cblk->x0,
+									cblk->y1 - cblk->y0))
+						{
+							return;
+						}
 
-						w = tilec->x1 - tilec->x0;
-						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < t1->h; ++j) {
-								for (i = 0; i < t1->w; ++i) {
-									t1->data[(j * t1->w) + i] =
-										tilec->data[(x + i) + (y + j) * w] << T1_NMSEDEC_FRACBITS;
+						datap=t1->data;
+						cblk_w = t1->w;
+						cblk_h = t1->h;
+
+						tiledp=&tilec->data[(y * tile_w) + x];
+						if (tccp->qmfbid == 1) {
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] = tmp << T1_NMSEDEC_FRACBITS;
 								}
 							}
-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < t1->h; ++j) {
-								for (i = 0; i < t1->w; ++i) {
-									t1->data[(j * t1->w) + i] = 
+						} else {		/* if (tccp->qmfbid == 0) */
+							for (j = 0; j < cblk_h; ++j) {
+								for (i = 0; i < cblk_w; ++i) {
+									int tmp = tiledp[(j * tile_w) + i];
+									datap[(j * cblk_w) + i] =
 										fix_mul(
-										tilec->data[x + i + (y + j) * w],
+										tmp,
 										8192 * 8192 / ((int) floor(band->stepsize * 8192))) >> (11 - T1_NMSEDEC_FRACBITS);
 								}
 							}
 						}
-						orient = band->bandno;	/* FIXME */
-						if (orient == 2) {
-							orient = 1;
-						} else if (orient == 1) {
-							orient = 2;
-						}
 
 						t1_encode_cblk(
 								t1,
 								cblk,
-								orient,
+								band->bandno,
 								compno,
 								tilec->numresolutions - 1 - resno,
-								tcp->tccps[compno].qmfbid,
+								tccp->qmfbid,
 								band->stepsize,
-								tcp->tccps[compno].cblksty,
+								tccp->cblksty,
 								tile->numcomps,
 								tile);
 
@@ -1117,94 +1120,89 @@
 }
 
 void t1_decode_cblks(
-		opj_t1_t *t1,
-		opj_tcd_tile_t *tile,
-		opj_tcp_t *tcp)
+		opj_t1_t* t1,
+		opj_tcd_tilecomp_t* tilec,
+		opj_tccp_t* tccp)
 {
-	int compno, resno, bandno, precno, cblkno;
-
-	for (compno = 0; compno < tile->numcomps; ++compno) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-
-		for (resno = 0; resno < tilec->numresolutions; ++resno) {
-			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-
-			for (bandno = 0; bandno < res->numbands; ++bandno) {
-				opj_tcd_band_t *band = &res->bands[bandno];
-
-				for (precno = 0; precno < res->pw * res->ph; ++precno) {
-					opj_tcd_precinct_t *prc = &band->precincts[precno];
-
-					for (cblkno = 0; cblkno < prc->cw * prc->ch; ++cblkno) {
-						int x, y, w, i, j, orient, cblk_w, cblk_h;
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-
-						orient = band->bandno;	/* FIXME */
-						if (orient == 2) {
-							orient = 1;
-						} else if (orient == 1) {
-							orient = 2;
-						}
-						
-						t1_decode_cblk(
-								t1,
-								cblk,
-								orient,
-								tcp->tccps[compno].roishift,
-								tcp->tccps[compno].cblksty);
+	int resno, bandno, precno, cblkno;
 
-						x = cblk->x0 - band->x0;
-						y = cblk->y0 - band->y0;
-						if (band->bandno & 1) {
-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
-							x += pres->x1 - pres->x0;
-						}
-						if (band->bandno & 2) {
-							opj_tcd_resolution_t *pres = &tilec->resolutions[resno - 1];
-							y += pres->y1 - pres->y0;
-						}
+	int tile_w = tilec->x1 - tilec->x0;
 
-						cblk_w = cblk->x1 - cblk->x0;
-						cblk_h = cblk->y1 - cblk->y0;
+	for (resno = 0; resno < tilec->numresolutions; ++resno) {
+		opj_tcd_resolution_t* res = &tilec->resolutions[resno];
 
-						if (tcp->tccps[compno].roishift) {
-							int thresh = 1 << tcp->tccps[compno].roishift;
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									int val = t1->data[(j * t1->w) + i];
-									int mag = int_abs(val);
-									if (mag >= thresh) {
-										mag >>= tcp->tccps[compno].roishift;
-										t1->data[(j * t1->w) + i] = val < 0 ? -mag : mag;
-									}
+		for (bandno = 0; bandno < res->numbands; ++bandno) {
+			opj_tcd_band_t* restrict band = &res->bands[bandno];
+
+			for (precno = 0; precno < res->pw * res->ph; ++precno) {
+				opj_tcd_precinct_t* precinct = &band->precincts[precno];
+
+				for (cblkno = 0; cblkno < precinct->cw * precinct->ch; ++cblkno) {
+					opj_tcd_cblk_dec_t* cblk = &precinct->cblks.dec[cblkno];
+					int* restrict datap;
+					void* restrict tiledp;
+					int cblk_w, cblk_h;
+					int x, y;
+					int i, j;
+
+					t1_decode_cblk(
+							t1,
+							cblk,
+							band->bandno,
+							tccp->roishift,
+							tccp->cblksty);
+
+					x = cblk->x0 - band->x0;
+					y = cblk->y0 - band->y0;
+					if (band->bandno & 1) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						x += pres->x1 - pres->x0;
+					}
+					if (band->bandno & 2) {
+						opj_tcd_resolution_t* pres = &tilec->resolutions[resno - 1];
+						y += pres->y1 - pres->y0;
+					}
+
+					datap=t1->data;
+					cblk_w = t1->w;
+					cblk_h = t1->h;
+
+					if (tccp->roishift) {
+						int thresh = 1 << tccp->roishift;
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int val = datap[(j * cblk_w) + i];
+								int mag = abs(val);
+								if (mag >= thresh) {
+									mag >>= tccp->roishift;
+									datap[(j * cblk_w) + i] = val < 0 ? -mag : mag;
 								}
 							}
 						}
-						
-						w = tilec->x1 - tilec->x0;
-						if (tcp->tccps[compno].qmfbid == 1) {
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									tilec->data[x + i + (y + j) * w] = t1->data[(j * t1->w) + i]/2;
-								}
+					}
+
+					tiledp=(void*)&tilec->data[(y * tile_w) + x];
+					if (tccp->qmfbid == 1) {
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								int tmp = datap[(j * cblk_w) + i];
+								((int*)tiledp)[(j * tile_w) + i] = tmp / 2;
 							}
-						} else {		/* if (tcp->tccps[compno].qmfbid == 0) */
-							for (j = 0; j < cblk_h; ++j) {
-								for (i = 0; i < cblk_w; ++i) {
-									if (t1->data[(j * t1->w) + i] >> 1 == 0) {
-										tilec->data[x + i + (y + j) * w] = 0;
-									} else {
-										double tmp = (double)(t1->data[(j * t1->w) + i] * band->stepsize * 4096.0);
-										int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);									
-										tilec->data[x + i + (y + j) * w] = ((tmp<0)?-tmp2:tmp2);
-									}
-								}
+						}
+					} else {		/* if (tccp->qmfbid == 0) */
+						for (j = 0; j < cblk_h; ++j) {
+							for (i = 0; i < cblk_w; ++i) {
+								float tmp = datap[(j * cblk_w) + i] * band->stepsize;
+								((float*)tiledp)[(j * tile_w) + i] = tmp;
 							}
 						}
-					} /* cblkno */
-				} /* precno */
-			} /* bandno */
-		} /* resno */
-	} /* compno */
+					}
+					opj_free(cblk->data);
+					opj_free(cblk->segs);
+				} /* cblkno */
+				opj_free(precinct->cblks.dec);
+			} /* precno */
+		} /* bandno */
+	} /* resno */
 }
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t1_generate_luts.c ./libopenjpeg/t1_generate_luts.c
--- /home/robin/sldeb/trunk/libopenjpeg/t1_generate_luts.c	2007-05-21 10:44:10.000000000 +0100
+++ ./libopenjpeg/t1_generate_luts.c	2007-09-28 11:33:44.000000000 +0100
@@ -146,16 +146,6 @@
 	return (T1_CTXNO_SC + n);
 }
 
-static int t1_init_ctxno_mag(int f) {
-	int n;
-	if (!(f & T1_REFINE))
-		n = (f & (T1_SIG_OTH)) ? 1 : 0;
-	else
-		n = 2;
-
-	return (T1_CTXNO_MAG + n);
-}
-
 static int t1_init_spb(int f) {
 	int hc, vc, n;
 
@@ -197,7 +187,6 @@
 	double u, v, t;
 
 	int lut_ctxno_zc[1024];
-	int lut_ctxno_mag[4096];
 	int lut_nmsedec_sig[1 << T1_NMSEDEC_BITS];
 	int lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS];
 	int lut_nmsedec_ref[1 << T1_NMSEDEC_BITS];
@@ -208,11 +197,17 @@
 	// lut_ctxno_zc
 	for (j = 0; j < 4; ++j) {
 		for (i = 0; i < 256; ++i) {
-			lut_ctxno_zc[(j << 8) | i] = t1_init_ctxno_zc(i, j);
+			int orient = j;
+			if (orient == 2) {
+				orient = 1;
+			} else if (orient == 1) {
+				orient = 2;
+			}
+			lut_ctxno_zc[(orient << 8) | i] = t1_init_ctxno_zc(i, j);
 		}
 	}
 
-	printf("static int8_t lut_ctxno_zc[1024] = {\n  ");
+	printf("static char lut_ctxno_zc[1024] = {\n  ");
 	for (i = 0; i < 1023; ++i) {
 		printf("%i, ", lut_ctxno_zc[i]);
 		if(!((i+1)&0x1f))
@@ -221,7 +216,7 @@
 	printf("%i\n};\n\n", lut_ctxno_zc[1023]);
 
 	// lut_ctxno_sc
-	printf("static int8_t lut_ctxno_sc[256] = {\n  ");
+	printf("static char lut_ctxno_sc[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("0x%x, ", t1_init_ctxno_sc(i << 4));
 		if(!((i+1)&0xf))
@@ -229,23 +224,8 @@
 	}
 	printf("0x%x\n};\n\n", t1_init_ctxno_sc(255 << 4));
 
-	// lut_ctxno_mag
-	for (j = 0; j < 2; ++j) {
-		for (i = 0; i < 2048; ++i) {
-			lut_ctxno_mag[(j << 11) + i] = t1_init_ctxno_mag((j ? T1_REFINE : 0) | i);
-		}
-	}
-
-	printf("static int8_t lut_ctxno_mag[4096] = {\n  ");
-	for (i = 0; i < 4095; ++i) {
-		printf("%i, ", lut_ctxno_mag[i]);
-		if(!((i+1)&0xf))
-			printf("\n  ");
-	}
-	printf("%i\n};\n\n", lut_ctxno_mag[4095]);
-
 	// lut_spb
-	printf("static int8_t lut_spb[256] = {\n  ");
+	printf("static char lut_spb[256] = {\n  ");
 	for (i = 0; i < 255; ++i) {
 		printf("%i, ", t1_init_spb(i << 4));
 		if(!((i+1)&0x1f))
@@ -279,16 +259,16 @@
 					(int) (floor((u * u) * pow(2, T1_NMSEDEC_FRACBITS) + 0.5) / pow(2, T1_NMSEDEC_FRACBITS) * 8192.0));
 	}
 
-	printf("static int16_t lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_sig[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_sig, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_sig0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_sig0, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_ref[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_ref, 1 << T1_NMSEDEC_BITS);
 
-	printf("static int16_t lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
+	printf("static short lut_nmsedec_ref0[1 << T1_NMSEDEC_BITS] = {\n  ");
 	dump_array16(&lut_nmsedec_ref0, 1 << T1_NMSEDEC_BITS);
 
 	return 0;
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t1.h ./libopenjpeg/t1.h
--- /home/robin/sldeb/trunk/libopenjpeg/t1.h	2007-05-22 14:14:13.000000000 +0100
+++ ./libopenjpeg/t1.h	2007-11-27 22:39:50.000000000 +0000
@@ -138,7 +138,7 @@
 @param tile The tile to decode
 @param tcp Tile coding parameters
 */
-void t1_decode_cblks(opj_t1_t *t1, opj_tcd_tile_t *tile, opj_tcp_t *tcp);
+void t1_decode_cblks(opj_t1_t* t1, opj_tcd_tilecomp_t* tilec, opj_tccp_t* tccp);
 /* ----------------------------------------------------------------------- */
 /*@}*/
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t1_luts.h ./libopenjpeg/t1_luts.h
--- /home/robin/sldeb/trunk/libopenjpeg/t1_luts.h	2007-05-21 10:44:10.000000000 +0100
+++ ./libopenjpeg/t1_luts.h	2007-09-28 11:33:44.000000000 +0100
@@ -9,14 +9,6 @@
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
-  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
-  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
-  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
-  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
   3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
@@ -25,6 +17,14 @@
   4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  0, 1, 1, 2, 1, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
+  7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
+  8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 
   0, 3, 3, 6, 3, 6, 6, 8, 3, 6, 6, 8, 6, 8, 8, 8, 1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 
   1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
   1, 4, 4, 7, 4, 7, 7, 8, 4, 7, 7, 8, 7, 8, 8, 8, 2, 5, 5, 7, 5, 7, 7, 8, 5, 7, 7, 8, 7, 8, 8, 8, 
@@ -54,265 +54,6 @@
   0x9, 0xa, 0xc, 0xd, 0xa, 0xa, 0xd, 0xd, 0xc, 0xd, 0xc, 0xd, 0xd, 0xd, 0xd, 0xd
 };
 
-static char lut_ctxno_mag[4096] = {
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  14, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 
-  16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16, 16
-};
-
 static char lut_spb[256] = {
   0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 
   0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t2.c ./libopenjpeg/t2.c
--- /home/robin/sldeb/trunk/libopenjpeg/t2.c	2007-04-10 17:23:48.000000000 +0100
+++ ./libopenjpeg/t2.c	2007-11-27 22:39:50.000000000 +0000
@@ -53,17 +53,17 @@
 @param pi Packet identity
 @param dest Destination buffer
 @param len Length of the destination buffer
-@param image_info Structure to create an index file
+@param cstr_info Codestream information structure 
 @param tileno Number of the tile encoded
 @return 
 */
-static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_image_info_t *image_info, int tileno);
+static int t2_encode_packet(opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi, unsigned char *dest, int len, opj_codestream_info_t *cstr_info, int tileno);
 /**
 @param seg
 @param cblksty
 @param first
 */
-static void t2_init_seg(opj_tcd_seg_t *seg, int cblksty, int first);
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first);
 /**
 Decode a packet of a tile from a source buffer
 @param t2 T2 handle
@@ -74,7 +74,8 @@
 @param pi Packet identity
 @return 
 */
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi);
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info);
 
 /*@}*/
 
@@ -126,9 +127,8 @@
 	return (37 + bio_read(bio, 7));
 }
 
-static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_image_info_t * image_info, int tileno) {
+static int t2_encode_packet(opj_tcd_tile_t * tile, opj_tcp_t * tcp, opj_pi_iterator_t *pi, unsigned char *dest, int length, opj_codestream_info_t *cstr_info, int tileno) {
 	int bandno, cblkno;
-	unsigned char *sop = 0, *eph = 0;
 	unsigned char *c = dest;
 
 	int compno = pi->compno;	/* component value */
@@ -143,15 +143,12 @@
 	
 	/* <SOP 0xff91> */
 	if (tcp->csty & J2K_CP_CSTY_SOP) {
-		sop = (unsigned char *) opj_malloc(6 * sizeof(unsigned char));
-		sop[0] = 255;
-		sop[1] = 145;
-		sop[2] = 0;
-		sop[3] = 4;
-		sop[4] = (image_info->num % 65536) / 256;
-		sop[5] = (image_info->num % 65536) % 256;
-		memcpy(c, sop, 6);
-		opj_free(sop);
+		c[0] = 255;
+		c[1] = 145;
+		c[2] = 0;
+		c[3] = 4;
+		c[4] = (tile->packno % 65536) / 256;
+		c[5] = (tile->packno % 65536) % 256;
 		c += 6;
 	}
 	/* </SOP> */
@@ -163,7 +160,7 @@
 			tgt_reset(prc->incltree);
 			tgt_reset(prc->imsbtree);
 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 				cblk->numpasses = 0;
 				tgt_setvalue(prc->imsbtree, cblkno, band->numbps - cblk->numbps);
 			}
@@ -179,14 +176,14 @@
 		opj_tcd_band_t *band = &res->bands[bandno];
 		opj_tcd_precinct_t *prc = &band->precincts[precno];
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			if (!cblk->numpasses && layer->numpasses) {
 				tgt_setvalue(prc->incltree, cblkno, layno);
 			}
 		}
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			int increment = 0;
 			int nump = 0;
@@ -238,25 +235,31 @@
 			}
 		}
 	}
-	
+
 	if (bio_flush(bio)) {
+		bio_destroy(bio);
 		return -999;		/* modified to eliminate longjmp !! */
 	}
-	
-	c += bio_numbytes(bio);
 
+	c += bio_numbytes(bio);
 	bio_destroy(bio);
 	
 	/* <EPH 0xff92> */
 	if (tcp->csty & J2K_CP_CSTY_EPH) {
-		eph = (unsigned char *) opj_malloc(2 * sizeof(unsigned char));
-		eph[0] = 255;
-		eph[1] = 146;
-		memcpy(c, eph, 2);
-		opj_free(eph);
+		c[0] = 255;
+		c[1] = 146;
 		c += 2;
 	}
 	/* </EPH> */
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(cstr_info && cstr_info->index_write) {
+		opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
+		info_PK->end_ph_pos = (int)(c - dest);
+	}
+	/* INDEX >> */
 	
 	/* Writing the packet body */
 	
@@ -264,7 +267,7 @@
 		opj_tcd_band_t *band = &res->bands[bandno];
 		opj_tcd_precinct_t *prc = &band->precincts[precno];
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 			opj_tcd_layer_t *layer = &cblk->layers[layno];
 			if (!layer->numpasses) {
 				continue;
@@ -276,23 +279,27 @@
 			memcpy(c, layer->data, layer->len);
 			cblk->numpasses += layer->numpasses;
 			c += layer->len;
-			/* ADD for index Cfr. Marcela --> delta disto by packet */
-			if(image_info && image_info->index_write && image_info->index_on) {
-				opj_tile_info_t *info_TL = &image_info->tile[tileno];
-				opj_packet_info_t *info_PK = &info_TL->packet[image_info->num];
+			/* << INDEX */ 
+			if(cstr_info && cstr_info->index_write) {
+				opj_packet_info_t *info_PK = &cstr_info->tile[tileno].packet[cstr_info->packno];
 				info_PK->disto += layer->disto;
-				if (image_info->D_max < info_PK->disto) {
-					image_info->D_max = info_PK->disto;
+				if (cstr_info->D_max < info_PK->disto) {
+					cstr_info->D_max = info_PK->disto;
 				}
 			}
-			/* </ADD> */
+			/* INDEX >> */
 		}
 	}
 	
 	return (c - dest);
 }
 
-static void t2_init_seg(opj_tcd_seg_t * seg, int cblksty, int first) {
+static void t2_init_seg(opj_tcd_cblk_dec_t* cblk, int index, int cblksty, int first) {
+	opj_tcd_seg_t* seg;
+	cblk->segs = (opj_tcd_seg_t*) opj_realloc(cblk->segs, (index + 1) * sizeof(opj_tcd_seg_t));
+	seg = &cblk->segs[index];
+	seg->data = NULL;
+	seg->dataindex = 0;
 	seg->numpasses = 0;
 	seg->len = 0;
 	if (cblksty & J2K_CCP_CBLKSTY_TERMALL) {
@@ -309,7 +316,8 @@
 	}
 }
 
-static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, opj_tcp_t *tcp, opj_pi_iterator_t *pi) {
+static int t2_decode_packet(opj_t2_t* t2, unsigned char *src, int len, opj_tcd_tile_t *tile, 
+														opj_tcp_t *tcp, opj_pi_iterator_t *pi, opj_packet_info_t *pack_info) {
 	int bandno, cblkno;
 	unsigned char *c = src;
 
@@ -320,9 +328,8 @@
 	int precno = pi->precno;	/* precinct value */
 	int layno  = pi->layno;		/* quality layer value */
 
-	opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-	opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-	
+	opj_tcd_resolution_t* res = &tile->comps[compno].resolutions[resno];
+
 	unsigned char *hd = NULL;
 	int present;
 	
@@ -338,7 +345,7 @@
 			tgt_reset(prc->incltree);
 			tgt_reset(prc->imsbtree);
 			for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-				opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+				opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 				cblk->numsegs = 0;
 			}
 		}
@@ -392,6 +399,14 @@
 				hd += 2;
 			}
 		}
+
+		/* << INDEX */
+		// End of packet header position. Currently only represents the distance to start of packet
+		// Will be updated later by incrementing with packet start value
+		if(pack_info) {
+			pack_info->end_ph_pos = (int)(c - src);
+		}
+		/* INDEX >> */
 		
 		if (cp->ppm == 1) {		/* PPM case */
 			cp->ppm_len += cp->ppm_data-hd;
@@ -414,9 +429,8 @@
 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
 		
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			int included, increment, n;
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-			opj_tcd_seg_t *seg = NULL;
+			int included, increment, n, segno;
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 			/* if cblk not yet included before --> inclusion tagtree */
 			if (!cblk->numsegs) {
 				included = tgt_decode(bio, prc->incltree, cblkno, layno + 1);
@@ -444,23 +458,25 @@
 			increment = t2_getcommacode(bio);
 			/* length indicator increment */
 			cblk->numlenbits += increment;
+			segno = 0;
 			if (!cblk->numsegs) {
-				seg = &cblk->segs[0];
-				t2_init_seg(seg, tcp->tccps[compno].cblksty, 1);
+				t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 1);
 			} else {
-				seg = &cblk->segs[cblk->numsegs - 1];
-				if (seg->numpasses == seg->maxpasses) {
-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+				segno = cblk->numsegs - 1;
+				if (cblk->segs[segno].numpasses == cblk->segs[segno].maxpasses) {
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
 				}
 			}
 			n = cblk->numnewpasses;
 			
 			do {
-				seg->numnewpasses = int_min(seg->maxpasses - seg->numpasses, n);
-				seg->newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(seg->numnewpasses));
-				n -= seg->numnewpasses;
+				cblk->segs[segno].numnewpasses = int_min(cblk->segs[segno].maxpasses - cblk->segs[segno].numpasses, n);
+				cblk->segs[segno].newlen = bio_read(bio, cblk->numlenbits + int_floorlog2(cblk->segs[segno].numnewpasses));
+				n -= cblk->segs[segno].numnewpasses;
 				if (n > 0) {
-					t2_init_seg(++seg, tcp->tccps[compno].cblksty, 0);
+					++segno;
+					t2_init_seg(cblk, segno, tcp->tccps[compno].cblksty, 0);
 				}
 			} while (n > 0);
 		}
@@ -482,6 +498,14 @@
 			hd += 2;
 		}
 	}
+
+	/* << INDEX */
+	// End of packet header position. Currently only represents the distance to start of packet
+	// Will be updated later by incrementing with packet start value
+	if(pack_info) {
+		pack_info->end_ph_pos = (int)(hd - src);
+	}
+	/* INDEX >> */
 	
 	if (cp->ppm==1) {
 		cp->ppm_len+=cp->ppm_data-hd;
@@ -500,7 +524,7 @@
 		if ((band->x1-band->x0 == 0)||(band->y1-band->y0 == 0)) continue;
 		
 		for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-			opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+			opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
 			opj_tcd_seg_t *seg = NULL;
 			if (!cblk->numnewpasses)
 				continue;
@@ -541,9 +565,11 @@
 
 #endif /* USE_JPWL */
 				
+				cblk->data = (unsigned char*) opj_realloc(cblk->data, (cblk->len + seg->newlen) * sizeof(unsigned char*));
 				memcpy(cblk->data + cblk->len, c, seg->newlen);
 				if (seg->numpasses == 0) {
-					seg->data = cblk->data + cblk->len;
+					seg->data = &cblk->data;
+					seg->dataindex = cblk->len;
 				}
 				c += seg->newlen;
 				cblk->len += seg->newlen;
@@ -563,15 +589,15 @@
 
 /* ----------------------------------------------------------------------- */
 
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_image_info_t *image_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode){
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino, J2K_T2_MODE t2_mode){
 	unsigned char *c = dest;
 	int e = 0;
 	int compno;
-	int comp_len = 0;
 	opj_pi_iterator_t *pi = NULL;
 	int poc;
 	opj_image_t *image = t2->image;
 	opj_cp_t *cp = t2->cp;
+	opj_tcp_t *tcp = &cp->tcps[tileno];
 	int pocno = cp->cinema == CINEMA4K_24? 2: 1;
 	int maxcomp = cp->max_comp_size > 0 ? image->numcomps : 1;
 	
@@ -581,19 +607,15 @@
 		return -999;
 	}
 	
-	if(image_info) {
-		image_info->num = 0;
-	}
-	
-	if(t2_mode == THRESH_CALC ){
+	if(t2_mode == THRESH_CALC ){ /* Calculating threshold */
 		for(compno = 0; compno < maxcomp; compno++ ){
 			for(poc = 0; poc < pocno ; poc++){
 				int comp_len = 0;
 				int tpnum = compno;
-				pi_create_encode(pi, cp,tileno,poc,tpnum,tppos); 
+				pi_create_encode(pi, cp,tileno,poc,tpnum,tppos,t2_mode); 
 				while (pi_next(&pi[poc])) {
 					if (pi[poc].layno < maxlayers) {
-						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, image_info, tileno);
+						e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[poc], c, dest + len - c, cstr_info, tileno);
 						comp_len = comp_len + e;
 						if (e == -999) {
 							break;
@@ -605,57 +627,61 @@
 				if (e == -999) break;
 				if (cp->max_comp_size){
 					if (comp_len > cp->max_comp_size){
-								e = -999;
-								break;
+						e = -999;
+						break;
 					}
 				}
 			}
 			if (e == -999)  break;
 		}
-	}else{
-		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos); 
+	}else{  /* t2_mode == FINAL_PASS  */
+		pi_create_encode(pi, cp,tileno,pino,tpnum,tppos,t2_mode);
 		while (pi_next(&pi[pino])) {
 			if (pi[pino].layno < maxlayers) {
-				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, image_info, tileno);
+				e = t2_encode_packet(tile, &cp->tcps[tileno], &pi[pino], c, dest + len - c, cstr_info, tileno);
 				if (e == -999) {
 					break;
 				} else {
 					c += e;
 				}
-			}
-		}
-	}
-
-		/* INDEX >> */
-		if(image_info && image_info->index_on) {
-				if(image_info->index_write) {
-					opj_tile_info_t *info_TL = &image_info->tile[tileno];
-					opj_packet_info_t *info_PK = &info_TL->packet[image_info->num];
-					if (!image_info->num) {
-						info_PK->start_pos = info_TL->end_header + 1;
-					} else {
-						info_PK->start_pos = info_TL->packet[image_info->num - 1].end_pos + 1;
+				/* INDEX >> */
+				if(cstr_info) {
+					if(cstr_info->index_write) {
+						opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+						opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+						if (!cstr_info->packno) {
+							info_PK->start_pos = info_TL->end_header + 1;
+						} else {
+							info_PK->start_pos = ((cp->tp_on | tcp->POC)&& info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+						}
+						info_PK->end_pos = info_PK->start_pos + e - 1;
+						info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																														// to start of packet is incremented by value of start of packet
 					}
-					info_PK->end_pos = info_PK->start_pos + e - 1;
+					
+					cstr_info->packno++;
 				}
-
-				image_info->num++;
+				/* << INDEX */
+				tile->packno++;
 			}
-		/* << INDEX */
-		pi_destroy(pi, cp, tileno);
+		}
+	}
+	
+	pi_destroy(pi, cp, tileno);
 	
 	if (e == -999) {
 		return e;
 	}
-
-    return (c - dest);
+	
+  return (c - dest);
 }
 
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile) {
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info) {
 	unsigned char *c = src;
 	opj_pi_iterator_t *pi;
 	int pino, e = 0;
-	int n = 0;
+	int n = 0, curtp = 0;
+	int tp_start_packno;
 
 	opj_image_t *image = t2->image;
 	opj_cp_t *cp = t2->cp;
@@ -666,11 +692,18 @@
 		/* TODO: throw an error */
 		return -999;
 	}
+
+	tp_start_packno = 0;
 	
 	for (pino = 0; pino <= cp->tcps[tileno].numpocs; pino++) {
 		while (pi_next(&pi[pino])) {
 			if ((cp->layer==0) || (cp->layer>=((pi[pino].layno)+1))) {
-				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino]);
+				opj_packet_info_t *pack_info;
+				if (cstr_info)
+					pack_info = &cstr_info->tile[tileno].packet[cstr_info->packno];
+				else
+					pack_info = NULL;
+				e = t2_decode_packet(t2, c, src + len - c, tile, &cp->tcps[tileno], &pi[pino], pack_info);
 			} else {
 				e = 0;
 			}
@@ -681,14 +714,40 @@
 				int_max(pi[pino].resno, image->comps[pi[pino].compno].resno_decoded) 
 				: image->comps[pi[pino].compno].resno_decoded;
 			n++;
+
+			/* INDEX >> */
+			if(cstr_info) {
+				opj_tile_info_t *info_TL = &cstr_info->tile[tileno];
+				opj_packet_info_t *info_PK = &info_TL->packet[cstr_info->packno];
+				if (!cstr_info->packno) {
+					info_PK->start_pos = info_TL->end_header + 1;
+				} else if (info_TL->packet[cstr_info->packno-1].end_pos >= (int)cstr_info->tile[tileno].tp[curtp].tp_end_pos){ // New tile part
+					info_TL->tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in previous tile-part
+					tp_start_packno = cstr_info->packno;
+					curtp++;
+					info_PK->start_pos = cstr_info->tile[tileno].tp[curtp].tp_end_header+1;
+				} else {
+					info_PK->start_pos = (cp->tp_on && info_PK->start_pos) ? info_PK->start_pos : info_TL->packet[cstr_info->packno - 1].end_pos + 1;
+				}
+				info_PK->end_pos = info_PK->start_pos + e - 1;
+				info_PK->end_ph_pos += info_PK->start_pos - 1;	// End of packet header which now only represents the distance 
+																												// to start of packet is incremented by value of start of packet
+				cstr_info->packno++;
+			}
+			/* << INDEX */
 			
 			if (e == -999) {		/* ADD */
 				break;
 			} else {
 				c += e;
-			}
+			}			
 		}
 	}
+	/* INDEX >> */
+	if(cstr_info) {
+		cstr_info->tile[tileno].tp[curtp].tp_numpacks = cstr_info->packno - tp_start_packno; // Number of packets in last tile-part
+	}
+	/* << INDEX */
 
 	/* don't forget to release pi */
 	pi_destroy(pi, cp, tileno);
@@ -697,7 +756,7 @@
 		return e;
 	}
 	
-    return (c - src);
+	return (c - src);
 }
 
 /* ----------------------------------------------------------------------- */
@@ -719,3 +778,6 @@
 	}
 }
 
+
+
+
diff -urN /home/robin/sldeb/trunk/libopenjpeg/t2.h ./libopenjpeg/t2.h
--- /home/robin/sldeb/trunk/libopenjpeg/t2.h	2007-04-04 14:40:32.000000000 +0100
+++ ./libopenjpeg/t2.h	2007-09-28 11:33:44.000000000 +0100
@@ -64,12 +64,12 @@
 @param maxlayers maximum number of layers
 @param dest the destination buffer
 @param len the length of the destination buffer
-@param image_info structure to create an index file
+@param cstr_info Codestream information structure 
 @param tpnum Tile part number of the current tile
 @param tppos The position of the tile part flag in the progression order
 @param t2_mode If == 0 In Threshold calculation ,If == 1 Final pass
 */
-int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_image_info_t *image_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode);
+int t2_encode_packets(opj_t2_t* t2,int tileno, opj_tcd_tile_t *tile, int maxlayers, unsigned char *dest, int len, opj_codestream_info_t *cstr_info,int tpnum, int tppos,int pino,J2K_T2_MODE t2_mode);
 /**
 Decode the packets of a tile from a source buffer
 @param t2 T2 handle
@@ -78,7 +78,7 @@
 @param tileno number that identifies the tile for which to decode the packets
 @param tile tile for which to decode the packets
  */
-int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile);
+int t2_decode_packets(opj_t2_t *t2, unsigned char *src, int len, int tileno, opj_tcd_tile_t *tile, opj_codestream_info_t *cstr_info);
 
 /**
 Create a T2 handle
diff -urN /home/robin/sldeb/trunk/libopenjpeg/tcd.c ./libopenjpeg/tcd.c
--- /home/robin/sldeb/trunk/libopenjpeg/tcd.c	2007-06-04 14:23:26.000000000 +0100
+++ ./libopenjpeg/tcd.c	2007-11-27 22:39:50.000000000 +0000
@@ -33,7 +33,7 @@
 #include "opj_includes.h"
 
 void tcd_dump(FILE *fd, opj_tcd_t *tcd, opj_tcd_image_t * img) {
-	int tileno, compno, resno, bandno, precno, cblkno;
+	int tileno, compno, resno, bandno, precno;//, cblkno;
 
 	fprintf(fd, "image {\n");
 	fprintf(fd, "  tw=%d, th=%d x0=%d x1=%d y0=%d y1=%d\n", 
@@ -68,6 +68,7 @@
 						fprintf(fd,
 							"            x0=%d, y0=%d, x1=%d, y1=%d, cw=%d, ch=%d\n",
 							prec->x0, prec->y0, prec->x1, prec->y1, prec->cw, prec->ch);
+						/*
 						for (cblkno = 0; cblkno < prec->cw * prec->ch; cblkno++) {
 							opj_tcd_cblk_t *cblk = &prec->cblks[cblkno];
 							fprintf(fd, "            cblk {\n");
@@ -76,6 +77,7 @@
 								cblk->x0, cblk->y0, cblk->x1, cblk->y1);
 							fprintf(fd, "            }\n");
 						}
+						*/
 						fprintf(fd, "          }\n");
 					}
 					fprintf(fd, "        }\n");
@@ -151,6 +153,13 @@
 		/* Modification of the RATE >> */
 		for (j = 0; j < tcp->numlayers; j++) {
 			tcp->rates[j] = tcp->rates[j] ? 
+				cp->tp_on ? 
+					(((float) (tile->numcomps 
+					* (tile->x1 - tile->x0) 
+					* (tile->y1 - tile->y0)
+					* image->comps[0].prec))
+					/(tcp->rates[j] * 8 * image->comps[0].dx * image->comps[0].dy)) - (((tcd->cur_totnum_tp - 1) * 14 )/ tcp->numlayers)
+					:
 				((float) (tile->numcomps 
 					* (tile->x1 - tile->x0) 
 					* (tile->y1 - tile->y0) 
@@ -165,6 +174,10 @@
 					if (!j && tcp->rates[j] < 30)
 						tcp->rates[j] = 30;
 				}
+				
+				if(j == (tcp->numlayers-1)){
+					tcp->rates[j] = tcp->rates[j]- 2;
+				}
 			}
 		}
 		/* << Modification of the RATE */
@@ -181,7 +194,7 @@
 			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
 			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
 			tilec->numresolutions = tccp->numresolutions;
 
 			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
@@ -302,7 +315,7 @@
 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc((prc->cw * prc->ch) * sizeof(opj_tcd_cblk_t));
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc((prc->cw * prc->ch), sizeof(opj_tcd_cblk_enc_t));
 						prc->incltree = tgt_create(prc->cw, prc->ch);
 						prc->imsbtree = tgt_create(prc->cw, prc->ch);
 						
@@ -312,13 +325,18 @@
 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
 							int cblkyend = cblkystart + (1 << cblkheightexpn);
 							
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
 
 							/* code-block size (global) */
 							cblk->x0 = int_max(cblkxstart, prc->x0);
 							cblk->y0 = int_max(cblkystart, prc->y0);
 							cblk->x1 = int_min(cblkxend, prc->x1);
 							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192+2, sizeof(unsigned char));
+							/* FIXME: mqc_init_enc and mqc_byteout underrun the buffer if we don't do this. Why? */
+							cblk->data += 2;
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
 						}
 					}
 				}
@@ -330,7 +348,7 @@
 }
 
 void tcd_free_encode(opj_tcd_t *tcd) {
-	int tileno, compno, resno, bandno, precno;
+	int tileno, compno, resno, bandno, precno, cblkno;
 
 	for (tileno = 0; tileno < 1; tileno++) {
 		opj_tcd_tile_t *tile = tcd->tcd_image->tiles;
@@ -355,8 +373,12 @@
 							tgt_destroy(prc->imsbtree);	
 							prc->imsbtree = NULL;
 						}
-						opj_free(prc->cblks);
-						prc->cblks = NULL;
+						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+							opj_free(prc->cblks.enc[cblkno].data - 2);
+							opj_free(prc->cblks.enc[cblkno].layers);
+							opj_free(prc->cblks.enc[cblkno].passes);
+						}
+						opj_free(prc->cblks.enc);
 					} /* for (precno */
 					opj_free(band->precincts);
 					band->precincts = NULL;
@@ -426,7 +448,7 @@
 			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
 			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
+			tilec->data = (int *) opj_aligned_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
 			tilec->numresolutions = tccp->numresolutions;
 			/* tilec->resolutions=(opj_tcd_resolution_t*)opj_realloc(tilec->resolutions,tilec->numresolutions*sizeof(opj_tcd_resolution_t)); */
 			for (resno = 0; resno < tilec->numresolutions; resno++) {
@@ -536,8 +558,8 @@
 						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
 						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						opj_free(prc->cblks);
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
+						opj_free(prc->cblks.enc);
+						prc->cblks.enc = (opj_tcd_cblk_enc_t*) opj_calloc(prc->cw * prc->ch, sizeof(opj_tcd_cblk_enc_t));
 
 						if (prc->incltree != NULL) {
 							tgt_destroy(prc->incltree);
@@ -555,13 +577,16 @@
 							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
 							int cblkyend = cblkystart + (1 << cblkheightexpn);
 
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-							
+							opj_tcd_cblk_enc_t* cblk = &prc->cblks.enc[cblkno];
+
 							/* code-block size (global) */
 							cblk->x0 = int_max(cblkxstart, prc->x0);
 							cblk->y0 = int_max(cblkystart, prc->y0);
 							cblk->x1 = int_min(cblkxend, prc->x1);
 							cblk->y1 = int_min(cblkyend, prc->y1);
+							cblk->data = (unsigned char*) opj_calloc(8192, sizeof(unsigned char));
+							cblk->layers = (opj_tcd_layer_t*) opj_calloc(100, sizeof(opj_tcd_layer_t));
+							cblk->passes = (opj_tcd_pass_t*) opj_calloc(100, sizeof(opj_tcd_pass_t));
 						}
 					} /* precno */
 				} /* bandno */
@@ -573,206 +598,228 @@
 }
 
 void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp) {
-	int tileno, compno, resno, bandno, precno, cblkno, i, j, p, q;
+	int i, j, tileno, p, q;
 	unsigned int x0 = 0, y0 = 0, x1 = 0, y1 = 0, w, h;
 
 	tcd->image = image;
-	tcd->cp = cp;
 	tcd->tcd_image->tw = cp->tw;
 	tcd->tcd_image->th = cp->th;
 	tcd->tcd_image->tiles = (opj_tcd_tile_t *) opj_malloc(cp->tw * cp->th * sizeof(opj_tcd_tile_t));
-	
-	for (i = 0; i < cp->tileno_size; i++) {
-		opj_tcp_t *tcp = &(cp->tcps[cp->tileno[i]]);
-		opj_tcd_tile_t *tile = &(tcd->tcd_image->tiles[cp->tileno[i]]);
-	
-		/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
-		tileno = cp->tileno[i];
-		p = tileno % cp->tw;	/* si numerotation matricielle .. */
-		q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
 
-		/* 4 borders of the tile rescale on the image if necessary */
-		tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
-		tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
-		tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
-		tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+	/* 
+	Allocate place to store the decoded data = final image
+	Place limited by the tile really present in the codestream 
+	*/
+
+	for (j = 0; j < cp->tileno_size; j++) {
+		opj_tcd_tile_t *tile;
 		
+		tileno = cp->tileno[j];		
+		tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);		
 		tile->numcomps = image->numcomps;
-		tile->comps = (opj_tcd_tilecomp_t *) opj_malloc(image->numcomps * sizeof(opj_tcd_tilecomp_t));
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tccp_t *tccp = &tcp->tccps[compno];
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		tile->comps = (opj_tcd_tilecomp_t*) opj_calloc(image->numcomps, sizeof(opj_tcd_tilecomp_t));
+	}
 
-			/* border of each tile component (global) */
-			tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
-			tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
-			tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
-			tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
+	for (i = 0; i < image->numcomps; i++) {
+		for (j = 0; j < cp->tileno_size; j++) {
+			opj_tcd_tile_t *tile;
+			opj_tcd_tilecomp_t *tilec;
 			
-			tilec->data = (int *) opj_malloc((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0) * sizeof(int));
-			tilec->numresolutions = tccp->numresolutions;
-			tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+			/* cfr p59 ISO/IEC FDIS15444-1 : 2000 (18 august 2000) */
+			
+			tileno = cp->tileno[j];
+			
+			tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+			tilec = &tile->comps[i];
+			
+			p = tileno % cp->tw;	/* si numerotation matricielle .. */
+			q = tileno / cp->tw;	/* .. coordonnees de la tile (q,p) q pour ligne et p pour colonne */
+			
+			/* 4 borders of the tile rescale on the image if necessary */
+			tile->x0 = int_max(cp->tx0 + p * cp->tdx, image->x0);
+			tile->y0 = int_max(cp->ty0 + q * cp->tdy, image->y0);
+			tile->x1 = int_min(cp->tx0 + (p + 1) * cp->tdx, image->x1);
+			tile->y1 = int_min(cp->ty0 + (q + 1) * cp->tdy, image->y1);
+
+			tilec->x0 = int_ceildiv(tile->x0, image->comps[i].dx);
+			tilec->y0 = int_ceildiv(tile->y0, image->comps[i].dy);
+			tilec->x1 = int_ceildiv(tile->x1, image->comps[i].dx);
+			tilec->y1 = int_ceildiv(tile->y1, image->comps[i].dy);
+
+			x0 = j == 0 ? tilec->x0 : int_min(x0, (unsigned int) tilec->x0);
+			y0 = j == 0 ? tilec->y0 : int_min(y0,	(unsigned int) tilec->x0);
+			x1 = j == 0 ? tilec->x1 : int_max(x1,	(unsigned int) tilec->x1);
+			y1 = j == 0 ? tilec->y1 : int_max(y1,	(unsigned int) tilec->y1);
+		}
 
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				int pdx, pdy;
-				int levelno = tilec->numresolutions - 1 - resno;
-				int tlprcxstart, tlprcystart, brprcxend, brprcyend;
-				int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
-				int cbgwidthexpn, cbgheightexpn;
-				int cblkwidthexpn, cblkheightexpn;
+		w = int_ceildivpow2(x1 - x0, image->comps[i].factor);
+		h = int_ceildivpow2(y1 - y0, image->comps[i].factor);
 
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				
-				/* border for each resolution level (global) */
-				res->x0 = int_ceildivpow2(tilec->x0, levelno);
-				res->y0 = int_ceildivpow2(tilec->y0, levelno);
-				res->x1 = int_ceildivpow2(tilec->x1, levelno);
-				res->y1 = int_ceildivpow2(tilec->y1, levelno);
-				res->numbands = resno == 0 ? 1 : 3;
-				
-				/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
-				if (tccp->csty & J2K_CCP_CSTY_PRT) {
-					pdx = tccp->prcw[resno];
-					pdy = tccp->prch[resno];
-				} else {
-					pdx = 15;
-					pdy = 15;
-				}
-				
-				/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
-				tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
-				tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
-				brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
-				brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+		image->comps[i].w = w;
+		image->comps[i].h = h;
+		image->comps[i].x0 = x0;
+		image->comps[i].y0 = y0;
+	}
+}
+
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info) {
+	int compno, resno, bandno, precno, cblkno;
+	opj_tcp_t *tcp;
+	opj_tcd_tile_t *tile;
+
+	tcd->cp = cp;
+	
+	tcp = &(cp->tcps[cp->tileno[tileno]]);
+	tile = &(tcd->tcd_image->tiles[cp->tileno[tileno]]);
+	
+	tileno = cp->tileno[tileno];
+	
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tccp_t *tccp = &tcp->tccps[compno];
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		
+		/* border of each tile component (global) */
+		tilec->x0 = int_ceildiv(tile->x0, image->comps[compno].dx);
+		tilec->y0 = int_ceildiv(tile->y0, image->comps[compno].dy);
+		tilec->x1 = int_ceildiv(tile->x1, image->comps[compno].dx);
+		tilec->y1 = int_ceildiv(tile->y1, image->comps[compno].dy);
 
-				res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
-				res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+		tilec->numresolutions = tccp->numresolutions;
+		tilec->resolutions = (opj_tcd_resolution_t *) opj_malloc(tilec->numresolutions * sizeof(opj_tcd_resolution_t));
+		
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			int pdx, pdy;
+			int levelno = tilec->numresolutions - 1 - resno;
+			int tlprcxstart, tlprcystart, brprcxend, brprcyend;
+			int tlcbgxstart, tlcbgystart, brcbgxend, brcbgyend;
+			int cbgwidthexpn, cbgheightexpn;
+			int cblkwidthexpn, cblkheightexpn;
+			
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			
+			/* border for each resolution level (global) */
+			res->x0 = int_ceildivpow2(tilec->x0, levelno);
+			res->y0 = int_ceildivpow2(tilec->y0, levelno);
+			res->x1 = int_ceildivpow2(tilec->x1, levelno);
+			res->y1 = int_ceildivpow2(tilec->y1, levelno);
+			res->numbands = resno == 0 ? 1 : 3;
+			
+			/* p. 35, table A-23, ISO/IEC FDIS154444-1 : 2000 (18 august 2000) */
+			if (tccp->csty & J2K_CCP_CSTY_PRT) {
+				pdx = tccp->prcw[resno];
+				pdy = tccp->prch[resno];
+			} else {
+				pdx = 15;
+				pdy = 15;
+			}			
+			
+			/* p. 64, B.6, ISO/IEC FDIS15444-1 : 2000 (18 august 2000)  */
+			tlprcxstart = int_floordivpow2(res->x0, pdx) << pdx;
+			tlprcystart = int_floordivpow2(res->y0, pdy) << pdy;
+			brprcxend = int_ceildivpow2(res->x1, pdx) << pdx;
+			brprcyend = int_ceildivpow2(res->y1, pdy) << pdy;
+			
+			res->pw = (res->x0 == res->x1) ? 0 : ((brprcxend - tlprcxstart) >> pdx);
+			res->ph = (res->y0 == res->y1) ? 0 : ((brprcyend - tlprcystart) >> pdy);
+			
+			if (resno == 0) {
+				tlcbgxstart = tlprcxstart;
+				tlcbgystart = tlprcystart;
+				brcbgxend = brprcxend;
+				brcbgyend = brprcyend;
+				cbgwidthexpn = pdx;
+				cbgheightexpn = pdy;
+			} else {
+				tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
+				tlcbgystart = int_ceildivpow2(tlprcystart, 1);
+				brcbgxend = int_ceildivpow2(brprcxend, 1);
+				brcbgyend = int_ceildivpow2(brprcyend, 1);
+				cbgwidthexpn = pdx - 1;
+				cbgheightexpn = pdy - 1;
+			}
+			
+			cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
+			cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+			
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				int x0b, y0b;
+				int gain, numbps;
+				opj_stepsize_t *ss = NULL;
 				
-				if (resno == 0) {
-					tlcbgxstart = tlprcxstart;
-					tlcbgystart = tlprcystart;
-					brcbgxend = brprcxend;
-					brcbgyend = brprcyend;
-					cbgwidthexpn = pdx;
-					cbgheightexpn = pdy;
+				opj_tcd_band_t *band = &res->bands[bandno];
+				band->bandno = resno == 0 ? 0 : bandno + 1;
+				x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
+				y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
+				
+				if (band->bandno == 0) {
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0, levelno);
+					band->y0 = int_ceildivpow2(tilec->y0, levelno);
+					band->x1 = int_ceildivpow2(tilec->x1, levelno);
+					band->y1 = int_ceildivpow2(tilec->y1, levelno);
 				} else {
-					tlcbgxstart = int_ceildivpow2(tlprcxstart, 1);
-					tlcbgystart = int_ceildivpow2(tlprcystart, 1);
-					brcbgxend = int_ceildivpow2(brprcxend, 1);
-					brcbgyend = int_ceildivpow2(brprcyend, 1);
-					cbgwidthexpn = pdx - 1;
-					cbgheightexpn = pdy - 1;
+					/* band border (global) */
+					band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
+					band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
+					band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
+					band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
 				}
 				
-				cblkwidthexpn = int_min(tccp->cblkw, cbgwidthexpn);
-				cblkheightexpn = int_min(tccp->cblkh, cbgheightexpn);
+				ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
+				gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
+				numbps = image->comps[compno].prec + gain;
+				band->stepsize = (float)(((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn)) * 0.5);
+				band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
 				
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					int x0b, y0b;
-					int gain, numbps;
-					opj_stepsize_t *ss = NULL;
-
-					opj_tcd_band_t *band = &res->bands[bandno];
-					band->bandno = resno == 0 ? 0 : bandno + 1;
-					x0b = (band->bandno == 1) || (band->bandno == 3) ? 1 : 0;
-					y0b = (band->bandno == 2) || (band->bandno == 3) ? 1 : 0;
-					
-					if (band->bandno == 0) {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0, levelno);
-						band->y0 = int_ceildivpow2(tilec->y0, levelno);
-						band->x1 = int_ceildivpow2(tilec->x1, levelno);
-						band->y1 = int_ceildivpow2(tilec->y1, levelno);
-					} else {
-						/* band border (global) */
-						band->x0 = int_ceildivpow2(tilec->x0 - (1 << levelno) * x0b, levelno + 1);
-						band->y0 = int_ceildivpow2(tilec->y0 - (1 << levelno) * y0b, levelno + 1);
-						band->x1 = int_ceildivpow2(tilec->x1 - (1 << levelno) * x0b, levelno + 1);
-						band->y1 = int_ceildivpow2(tilec->y1 - (1 << levelno) * y0b, levelno + 1);
-					}
-					
-					ss = &tccp->stepsizes[resno == 0 ? 0 : 3 * (resno - 1) + bandno + 1];
-					gain = tccp->qmfbid == 0 ? dwt_getgain_real(band->bandno) : dwt_getgain(band->bandno);
-					numbps = image->comps[compno].prec + gain;
-					band->stepsize = (float)((1.0 + ss->mant / 2048.0) * pow(2.0, numbps - ss->expn));
-					band->numbps = ss->expn + tccp->numgbits - 1;	/* WHY -1 ? */
+				band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+				
+				for (precno = 0; precno < res->pw * res->ph; precno++) {
+					int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
+					int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
+					int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
+					int cbgxend = cbgxstart + (1 << cbgwidthexpn);
+					int cbgyend = cbgystart + (1 << cbgheightexpn);
 					
-					band->precincts = (opj_tcd_precinct_t *) opj_malloc(res->pw * res->ph * sizeof(opj_tcd_precinct_t));
+					opj_tcd_precinct_t *prc = &band->precincts[precno];
+					/* precinct size (global) */
+					prc->x0 = int_max(cbgxstart, band->x0);
+					prc->y0 = int_max(cbgystart, band->y0);
+					prc->x1 = int_min(cbgxend, band->x1);
+					prc->y1 = int_min(cbgyend, band->y1);
 					
-					for (precno = 0; precno < res->pw * res->ph; precno++) {
-						int tlcblkxstart, tlcblkystart, brcblkxend, brcblkyend;
-						int cbgxstart = tlcbgxstart + (precno % res->pw) * (1 << cbgwidthexpn);
-						int cbgystart = tlcbgystart + (precno / res->pw) * (1 << cbgheightexpn);
-						int cbgxend = cbgxstart + (1 << cbgwidthexpn);
-						int cbgyend = cbgystart + (1 << cbgheightexpn);
+					tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
+					tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
+					brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
+					brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
+					prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
+					prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
 
-						opj_tcd_precinct_t *prc = &band->precincts[precno];
-						/* precinct size (global) */
-						prc->x0 = int_max(cbgxstart, band->x0);
-						prc->y0 = int_max(cbgystart, band->y0);
-						prc->x1 = int_min(cbgxend, band->x1);
-						prc->y1 = int_min(cbgyend, band->y1);
-						
-						tlcblkxstart = int_floordivpow2(prc->x0, cblkwidthexpn) << cblkwidthexpn;
-						tlcblkystart = int_floordivpow2(prc->y0, cblkheightexpn) << cblkheightexpn;
-						brcblkxend = int_ceildivpow2(prc->x1, cblkwidthexpn) << cblkwidthexpn;
-						brcblkyend = int_ceildivpow2(prc->y1, cblkheightexpn) << cblkheightexpn;
-						prc->cw = (brcblkxend - tlcblkxstart) >> cblkwidthexpn;
-						prc->ch = (brcblkyend - tlcblkystart) >> cblkheightexpn;
-						
-						prc->cblks = (opj_tcd_cblk_t *) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_t));
-						
-						prc->incltree = tgt_create(prc->cw, prc->ch);
-						prc->imsbtree = tgt_create(prc->cw, prc->ch);
-						
-						for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-							int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
-							int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
-							int cblkxend = cblkxstart + (1 << cblkwidthexpn);
-							int cblkyend = cblkystart + (1 << cblkheightexpn);					
-							
-							/* code-block size (global) */
-							opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
-							cblk->x0 = int_max(cblkxstart, prc->x0);
-							cblk->y0 = int_max(cblkystart, prc->y0);
-							cblk->x1 = int_min(cblkxend, prc->x1);
-							cblk->y1 = int_min(cblkyend, prc->y1);
-						}
-					} /* precno */
-				} /* bandno */
-			} /* resno */
-		} /* compno */
-	} /* i = 0..cp->tileno_size */
+					prc->cblks.dec = (opj_tcd_cblk_dec_t*) opj_malloc(prc->cw * prc->ch * sizeof(opj_tcd_cblk_dec_t));
 
+					prc->incltree = tgt_create(prc->cw, prc->ch);
+					prc->imsbtree = tgt_create(prc->cw, prc->ch);
+					
+					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
+						int cblkxstart = tlcblkxstart + (cblkno % prc->cw) * (1 << cblkwidthexpn);
+						int cblkystart = tlcblkystart + (cblkno / prc->cw) * (1 << cblkheightexpn);
+						int cblkxend = cblkxstart + (1 << cblkwidthexpn);
+						int cblkyend = cblkystart + (1 << cblkheightexpn);					
+
+						opj_tcd_cblk_dec_t* cblk = &prc->cblks.dec[cblkno];
+						cblk->data = NULL;
+						cblk->segs = NULL;
+						/* code-block size (global) */
+						cblk->x0 = int_max(cblkxstart, prc->x0);
+						cblk->y0 = int_max(cblkystart, prc->y0);
+						cblk->x1 = int_min(cblkxend, prc->x1);
+						cblk->y1 = int_min(cblkyend, prc->y1);
+						cblk->numsegs = 0;
+					}
+				} /* precno */
+			} /* bandno */
+		} /* resno */
+	} /* compno */
 	/* tcd_dump(stdout, tcd, &tcd->tcd_image); */
-
-	/* 
-	Allocate place to store the decoded data = final image
-	Place limited by the tile really present in the codestream 
-	*/
-	
-	for (i = 0; i < image->numcomps; i++) {
-		for (j = 0; j < cp->tileno_size; j++) {
-			tileno = cp->tileno[j];
-			x0 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].x0 : int_min(x0,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].x0);
-			y0 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].y0 : int_min(y0,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].y0);
-			x1 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].x1 : int_max(x1,
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].x1);
-			y1 = j == 0 ? tcd->tcd_image->tiles[tileno].comps[i].y1 : int_max(y1, 
-				(unsigned int) tcd->tcd_image->tiles[tileno].comps[i].y1);
-		}
-		
-		w = x1 - x0;
-		h = y1 - y0;
-		
-		image->comps[i].data = (int *) opj_malloc(w * h * sizeof(int));
-		image->comps[i].w = w;
-		image->comps[i].h = h;
-		image->comps[i].x0 = x0;
-		image->comps[i].y0 = y0;
-	}
 }
 
 void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final) {
@@ -806,7 +853,7 @@
 				for (precno = 0; precno < res->pw * res->ph; precno++) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 						opj_tcd_layer_t *layer = &cblk->layers[layno];
 						int n;
 						int imsb = tcd->image->comps[compno].prec - cblk->numbps;	/* number of bit-plan equal to zero */
@@ -887,7 +934,7 @@
 				for (precno = 0; precno < res->pw * res->ph; precno++) {
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 						opj_tcd_layer_t *layer = &cblk->layers[layno];
 						
 						int n;
@@ -941,7 +988,7 @@
 	}
 }
 
-bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_image_info_t * image_info) {
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
 	int compno, resno, bandno, precno, cblkno, passno, layno;
 	double min, max;
 	double cumdisto[100];	/* fixed_quality */
@@ -955,11 +1002,11 @@
 	min = DBL_MAX;
 	max = 0;
 	
-	tcd_tile->nbpix = 0;		/* fixed_quality */
+	tcd_tile->numpix = 0;		/* fixed_quality */
 	
 	for (compno = 0; compno < tcd_tile->numcomps; compno++) {
 		opj_tcd_tilecomp_t *tilec = &tcd_tile->comps[compno];
-		tilec->nbpix = 0;
+		tilec->numpix = 0;
 
 		for (resno = 0; resno < tilec->numresolutions; resno++) {
 			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
@@ -971,7 +1018,7 @@
 					opj_tcd_precinct_t *prc = &band->precincts[precno];
 
 					for (cblkno = 0; cblkno < prc->cw * prc->ch; cblkno++) {
-						opj_tcd_cblk_t *cblk = &prc->cblks[cblkno];
+						opj_tcd_cblk_enc_t *cblk = &prc->cblks.enc[cblkno];
 
 						for (passno = 0; passno < cblk->totalpasses; passno++) {
 							opj_tcd_pass_t *pass = &cblk->passes[passno];
@@ -997,8 +1044,8 @@
 						} /* passno */
 						
 						/* fixed_quality */
-						tcd_tile->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
-						tilec->nbpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+						tcd_tile->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
+						tilec->numpix += ((cblk->x1 - cblk->x0) * (cblk->y1 - cblk->y0));
 					} /* cbklno */
 				} /* precno */
 			} /* bandno */
@@ -1006,13 +1053,13 @@
 		
 		maxSE += (((double)(1 << tcd->image->comps[compno].prec) - 1.0) 
 			* ((double)(1 << tcd->image->comps[compno].prec) -1.0)) 
-			* ((double)(tilec->nbpix));
+			* ((double)(tilec->numpix));
 	} /* compno */
 	
 	/* index file */
-	if(image_info && image_info->index_on) {
-		opj_tile_info_t *tile_info = &image_info->tile[tcd->tcd_tileno];
-		tile_info->nbpix = tcd_tile->nbpix;
+	if(cstr_info) {
+		opj_tile_info_t *tile_info = &cstr_info->tile[tcd->tcd_tileno];
+		tile_info->numpix = tcd_tile->numpix;
 		tile_info->distotile = tcd_tile->distotile;
 		tile_info->thresh = (double *) opj_malloc(tcd_tcp->numlayers * sizeof(double));
 	}
@@ -1021,7 +1068,6 @@
 		double lo = min;
 		double hi = max;
 		int success = 0;
-		/* TODO: remove maxlen */
 		int maxlen = tcd_tcp->rates[layno] ? int_min(((int) ceil(tcd_tcp->rates[layno])), len) : len;
 		double goodthresh = 0;
 		double stable_thresh = 0;
@@ -1031,19 +1077,24 @@
 		/* fixed_quality */
 		distotarget = tcd_tile->distotile - ((K * maxSE) / pow((float)10, tcd_tcp->distoratio[layno] / 10));
         
-		if ((tcd_tcp->rates[layno]) || (cp->disto_alloc == 0)) {
+		/* Don't try to find an optimal threshold but rather take everything not included yet, if
+		  -r xx,yy,zz,0   (disto_alloc == 1 and rates == 0)
+		  -q xx,yy,zz,0	  (fixed_quality == 1 and distoratio == 0)
+		  ==> possible to have some lossy layers and the last layer for sure lossless */
+		if ( ((cp->disto_alloc==1) && (tcd_tcp->rates[layno]>0)) || ((cp->fixed_quality==1) && (tcd_tcp->distoratio[layno]>0))) {
 			opj_t2_t *t2 = t2_create(tcd->cinfo, tcd->image, cp);
+			double thresh = 0;
 
 			for (i = 0; i < 32; i++) {
-				double thresh = (lo + hi) / 2;
 				int l = 0;
 				double distoachieved = 0;	/* fixed_quality */
+				thresh = (lo + hi) / 2;
 				
 				tcd_makelayer(tcd, layno, thresh, 0);
 				
 				if (cp->fixed_quality) {	/* fixed_quality */
 					if(cp->cinema){
-						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, image_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+						l = t2_encode_packets(t2,tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
 						if (l == -999) {
 							lo = thresh;
 							continue;
@@ -1069,7 +1120,7 @@
 						lo = thresh;
 					}
 				} else {
-					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, image_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
+					l = t2_encode_packets(t2, tcd->tcd_tileno, tcd_tile, layno + 1, dest, maxlen, cstr_info,tcd->cur_tp_num,tcd->tp_pos,tcd->cur_pino,THRESH_CALC);
 					/* TODO: what to do with l ??? seek / tell ??? */
 					/* opj_event_msg(tcd->cinfo, EVT_INFO, "rate alloc: len=%d, max=%d\n", l, maxlen); */
 					if (l == -999) {
@@ -1081,7 +1132,7 @@
 				}
 			}
 			success = 1;
-			goodthresh = stable_thresh;
+			goodthresh = stable_thresh == 0? thresh : stable_thresh;
 			t2_destroy(t2);
 		} else {
 			success = 1;
@@ -1092,8 +1143,8 @@
 			return false;
 		}
 		
-		if(image_info && image_info->index_on) {	/* Threshold for Marcela Index */
-			image_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
+		if(cstr_info) {	/* Threshold for Marcela Index */
+			cstr_info->tile[tcd->tcd_tileno].thresh[layno] = goodthresh;
 		}
 		tcd_makelayer(tcd, layno, goodthresh, 1);
         
@@ -1104,9 +1155,9 @@
 	return true;
 }
 
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_image_info_t * image_info) {
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info) {
 	int compno;
-	int l, i, npck = 0;
+	int l, i, numpacks = 0;
 	opj_tcd_tile_t *tile = NULL;
 	opj_tcp_t *tcd_tcp = NULL;
 	opj_cp_t *cp = NULL;
@@ -1129,20 +1180,20 @@
 	if(tcd->cur_tp_num == 0){
 		tcd->encoding_time = opj_clock();	/* time needed to encode a tile */
 		/* INDEX >> "Precinct_nb_X et Precinct_nb_Y" */
-		if(image_info && image_info->index_on) {
+		if(cstr_info) {
 			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[0];	/* based on component 0 */
 			for (i = 0; i < tilec_idx->numresolutions; i++) {
 				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[i];
 				
-				image_info->tile[tileno].pw[i] = res_idx->pw;
-				image_info->tile[tileno].ph[i] = res_idx->ph;
+				cstr_info->tile[tileno].pw[i] = res_idx->pw;
+				cstr_info->tile[tileno].ph[i] = res_idx->ph;
 				
-				npck += res_idx->pw * res_idx->ph;
+				numpacks += res_idx->pw * res_idx->ph;
 				
-				image_info->tile[tileno].pdx[i] = tccp->prcw[i];
-				image_info->tile[tileno].pdy[i] = tccp->prch[i];
+				cstr_info->tile[tileno].pdx[i] = tccp->prcw[i];
+				cstr_info->tile[tileno].pdy[i] = tccp->prch[i];
 			}
-			image_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(image_info->comp * image_info->layer * npck * sizeof(opj_packet_info_t));
+			cstr_info->tile[tileno].packet = (opj_packet_info_t*) opj_calloc(cstr_info->numcomps * cstr_info->numlayers * numpacks, sizeof(opj_packet_info_t));
 		}
 		/* << INDEX */
 		
@@ -1214,12 +1265,12 @@
 		/*-----------RATE-ALLOCATE------------------*/
 		
 		/* INDEX */
-		if(image_info) {
-			image_info->index_write = 0;
+		if(cstr_info) {
+			cstr_info->index_write = 0;
 		}
 		if (cp->disto_alloc || cp->fixed_quality) {	/* fixed_quality */
 			/* Normal Rate/distortion allocation */
-			tcd_rateallocate(tcd, dest, len, image_info);
+			tcd_rateallocate(tcd, dest, len, cstr_info);
 		} else {
 			/* Fixed layer allocation */
 			tcd_rateallocate_fixed(tcd);
@@ -1228,12 +1279,12 @@
 	/*--------------TIER2------------------*/
 
 	/* INDEX */
-	if(image_info) {
-		image_info->index_write = 1;
+	if(cstr_info) {
+		cstr_info->index_write = 1;
 	}
 
 	t2 = t2_create(tcd->cinfo, image, cp);
-	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, image_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS);
+	l = t2_encode_packets(t2,tileno, tile, tcd_tcp->numlayers, dest, len, cstr_info,tcd->tp_num,tcd->tp_pos,tcd->cur_pino,FINAL_PASS);
 	t2_destroy(t2);
 	
 	/*---------------CLEAN-------------------*/
@@ -1242,18 +1293,18 @@
 	if(tcd->cur_tp_num == tcd->cur_totnum_tp - 1){
 		tcd->encoding_time = opj_clock() - tcd->encoding_time;
 		opj_event_msg(tcd->cinfo, EVT_INFO, "- tile encoded in %f s\n", tcd->encoding_time);
-	
+
 		/* cleaning memory */
 		for (compno = 0; compno < tile->numcomps; compno++) {
 			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			opj_free(tilec->data);
+			opj_aligned_free(tilec->data);
 		}
 	}
-	
+
 	return l;
 }
 
-bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno) {
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info) {
 	int l;
 	int compno;
 	int eof = 0;
@@ -1270,11 +1321,38 @@
 	
 	tile_time = opj_clock();	/* time needed to decode a tile */
 	opj_event_msg(tcd->cinfo, EVT_INFO, "tile %d of %d\n", tileno + 1, tcd->cp->tw * tcd->cp->th);
+
+	/* INDEX >>  */
+	if(cstr_info) {
+		int resno, compno, numprec = 0;
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			opj_tcp_t *tcp = &tcd->cp->tcps[0];
+			opj_tccp_t *tccp = &tcp->tccps[compno];
+			opj_tcd_tilecomp_t *tilec_idx = &tile->comps[compno];	
+			for (resno = 0; resno < tilec_idx->numresolutions; resno++) {
+				opj_tcd_resolution_t *res_idx = &tilec_idx->resolutions[resno];
+				cstr_info->tile[tileno].pw[resno] = res_idx->pw;
+				cstr_info->tile[tileno].ph[resno] = res_idx->ph;
+				numprec += res_idx->pw * res_idx->ph;
+				if (tccp->csty & J2K_CP_CSTY_PRT) {
+					cstr_info->tile[tileno].pdx[resno] = tccp->prcw[resno];
+					cstr_info->tile[tileno].pdy[resno] = tccp->prch[resno];
+				}
+				else {
+					cstr_info->tile[tileno].pdx[resno] = 15;
+					cstr_info->tile[tileno].pdx[resno] = 15;
+				}
+			}
+		}
+		cstr_info->tile[tileno].packet = (opj_packet_info_t *) opj_malloc(cstr_info->numlayers * numprec * sizeof(opj_packet_info_t));
+		cstr_info->packno = 0;
+	}
+	/* << INDEX */
 	
 	/*--------------TIER2------------------*/
 	
 	t2 = t2_create(tcd->cinfo, tcd->image, tcd->cp);
-	l = t2_decode_packets(t2, src, len, tileno, tile);
+	l = t2_decode_packets(t2, src, len, tileno, tile, cstr_info);
 	t2_destroy(t2);
 
 	if (l == -999) {
@@ -1286,7 +1364,12 @@
 	
 	t1_time = opj_clock();	/* time needed to decode a tile */
 	t1 = t1_create(tcd->cinfo);
-	t1_decode_cblks(t1, tile, tcd->tcp);
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		/* The +3 is headroom required by the vectorized DWT */
+		tilec->data = (int*) opj_aligned_malloc((((tilec->x1 - tilec->x0) * (tilec->y1 - tilec->y0))+3) * sizeof(int));
+		t1_decode_cblks(t1, tilec, &tcd->tcp->tccps[compno]);
+	}
 	t1_destroy(t1);
 	t1_time = opj_clock() - t1_time;
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tiers-1 took %f s\n", t1_time);
@@ -1296,80 +1379,93 @@
 	dwt_time = opj_clock();	/* time needed to decode a tile */
 	for (compno = 0; compno < tile->numcomps; compno++) {
 		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		int numres2decode;
+
 		if (tcd->cp->reduce != 0) {
 			tcd->image->comps[compno].resno_decoded =
 				tile->comps[compno].numresolutions - tcd->cp->reduce - 1;
-		}
-        
-		if (tcd->tcp->tccps[compno].qmfbid == 1) {
-			dwt_decode(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
-		} else {
-			dwt_decode_real(tilec, tilec->numresolutions - 1 - tcd->image->comps[compno].resno_decoded);
+			if (tcd->image->comps[compno].resno_decoded < 0) {
+				opj_event_msg(tcd->cinfo, EVT_ERROR, "Error decoding tile. The number of resolutions to remove is higher than the number "
+					"of resolutions in the original codestream\nModify the cp_reduce parameter.\n");
+				return false;
+			}
 		}
 
-		if (tile->comps[compno].numresolutions > 0) {
-			tcd->image->comps[compno].factor = tile->comps[compno].numresolutions - (tcd->image->comps[compno].resno_decoded + 1);
+		numres2decode = tcd->image->comps[compno].resno_decoded + 1;
+		if(numres2decode > 0){
+			if (tcd->tcp->tccps[compno].qmfbid == 1) {
+				dwt_decode(tilec, numres2decode);
+			} else {
+				dwt_decode_real(tilec, numres2decode);
+			}
 		}
 	}
 	dwt_time = opj_clock() - dwt_time;
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- dwt took %f s\n", dwt_time);
-	
+
 	/*----------------MCT-------------------*/
-	
+
 	if (tcd->tcp->mct) {
+		int n = (tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0);
 		if (tcd->tcp->tccps[0].qmfbid == 1) {
-			mct_decode(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
+			mct_decode(
+					tile->comps[0].data,
+					tile->comps[1].data,
+					tile->comps[2].data, 
+					n);
 		} else {
-			mct_decode_real(tile->comps[0].data, tile->comps[1].data, tile->comps[2].data, 
-				(tile->comps[0].x1 - tile->comps[0].x0) * (tile->comps[0].y1 - tile->comps[0].y0));
+			mct_decode_real(
+					(float*)tile->comps[0].data,
+					(float*)tile->comps[1].data,
+					(float*)tile->comps[2].data, 
+					n);
 		}
 	}
-	
+
 	/*---------------TILE-------------------*/
-	
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-		opj_tcd_resolution_t *res =	&tilec->resolutions[tcd->image->comps[compno].resno_decoded];
-		int adjust = tcd->image->comps[compno].sgnd ? 0 : 1 << (tcd->image->comps[compno].prec - 1);
-		int min = tcd->image->comps[compno].sgnd ? 
-			-(1 << (tcd->image->comps[compno].prec - 1)) : 0;
-		int max = tcd->image->comps[compno].sgnd ? 
-			(1 << (tcd->image->comps[compno].prec - 1)) - 1 : (1 << tcd->image->comps[compno].prec) - 1;
-		
+
+	for (compno = 0; compno < tile->numcomps; ++compno) {
+		opj_tcd_tilecomp_t* tilec = &tile->comps[compno];
+		opj_image_comp_t* imagec = &tcd->image->comps[compno];
+		opj_tcd_resolution_t* res = &tilec->resolutions[imagec->resno_decoded];
+		int adjust = imagec->sgnd ? 0 : 1 << (imagec->prec - 1);
+		int min = imagec->sgnd ? -(1 << (imagec->prec - 1)) : 0;
+		int max = imagec->sgnd ?  (1 << (imagec->prec - 1)) - 1 : (1 << imagec->prec) - 1;
+
 		int tw = tilec->x1 - tilec->x0;
-		int w = tcd->image->comps[compno].w;
-		
-		int i, j;
-		int offset_x = int_ceildivpow2(tcd->image->comps[compno].x0, tcd->image->comps[compno].factor);
-		int offset_y = int_ceildivpow2(tcd->image->comps[compno].y0, tcd->image->comps[compno].factor);
-		
-		for (j = res->y0; j < res->y1; j++) {
-			for (i = res->x0; i < res->x1; i++) {
-				int v;
-				float tmp = (float)((tilec->data[i - res->x0 + (j - res->y0) * tw]) / 8192.0);
+		int w = imagec->w;
 
-				if (tcd->tcp->tccps[compno].qmfbid == 1) {
-					v = tilec->data[i - res->x0 + (j - res->y0) * tw];
-				} else {
-					int tmp2 = ((int) (floor(fabs(tmp)))) + ((int) floor(fabs(tmp*2))%2);
-					v = ((tmp < 0) ? -tmp2:tmp2);
+		int offset_x = int_ceildivpow2(imagec->x0, imagec->factor);
+		int offset_y = int_ceildivpow2(imagec->y0, imagec->factor);
+
+		int i, j;
+		if(!imagec->data){
+			imagec->data = (int*) opj_malloc(imagec->w * imagec->h * sizeof(int));
+		}
+		if(tcd->tcp->tccps[compno].qmfbid == 1) {
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					int v = tilec->data[i - res->x0 + (j - res->y0) * tw];
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
+				}
+			}
+		}else{
+			for(j = res->y0; j < res->y1; ++j) {
+				for(i = res->x0; i < res->x1; ++i) {
+					float tmp = ((float*)tilec->data)[i - res->x0 + (j - res->y0) * tw];
+					int v = lrintf(tmp);
+					v += adjust;
+					imagec->data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
 				}
-				v += adjust;
-				
-				tcd->image->comps[compno].data[(i - offset_x) + (j - offset_y) * w] = int_clamp(v, min, max);
 			}
 		}
+		opj_aligned_free(tilec->data);
 	}
-	
+
 	tile_time = opj_clock() - tile_time;	/* time needed to decode a tile */
 	opj_event_msg(tcd->cinfo, EVT_INFO, "- tile decoded in %f s\n", tile_time);
-		
-	for (compno = 0; compno < tile->numcomps; compno++) {
-		opj_free(tcd->tcd_image->tiles[tileno].comps[compno].data);
-		tcd->tcd_image->tiles[tileno].comps[compno].data = NULL;
-	}
-	
+
 	if (eof) {
 		return false;
 	}
@@ -1378,32 +1474,32 @@
 }
 
 void tcd_free_decode(opj_tcd_t *tcd) {
-	int tileno,compno,resno,bandno,precno;
+	opj_tcd_image_t *tcd_image = tcd->tcd_image;	
+	opj_free(tcd_image->tiles);
+}
+
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno) {
+	int compno,resno,bandno,precno;
 
 	opj_tcd_image_t *tcd_image = tcd->tcd_image;
-	
-	for (tileno = 0; tileno < tcd_image->tw * tcd_image->th; tileno++) {
-		opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
-		for (compno = 0; compno < tile->numcomps; compno++) {
-			opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
-			for (resno = 0; resno < tilec->numresolutions; resno++) {
-				opj_tcd_resolution_t *res = &tilec->resolutions[resno];
-				for (bandno = 0; bandno < res->numbands; bandno++) {
-					opj_tcd_band_t *band = &res->bands[bandno];
-					for (precno = 0; precno < res->ph * res->pw; precno++) {
-						opj_tcd_precinct_t *prec = &band->precincts[precno];
-						if (prec->cblks != NULL) opj_free(prec->cblks);
-						if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
-						if (prec->incltree != NULL) tgt_destroy(prec->incltree);
-					}
-					if (band->precincts != NULL) opj_free(band->precincts);
+
+	opj_tcd_tile_t *tile = &tcd_image->tiles[tileno];
+	for (compno = 0; compno < tile->numcomps; compno++) {
+		opj_tcd_tilecomp_t *tilec = &tile->comps[compno];
+		for (resno = 0; resno < tilec->numresolutions; resno++) {
+			opj_tcd_resolution_t *res = &tilec->resolutions[resno];
+			for (bandno = 0; bandno < res->numbands; bandno++) {
+				opj_tcd_band_t *band = &res->bands[bandno];
+				for (precno = 0; precno < res->ph * res->pw; precno++) {
+					opj_tcd_precinct_t *prec = &band->precincts[precno];
+					if (prec->imsbtree != NULL) tgt_destroy(prec->imsbtree);
+					if (prec->incltree != NULL) tgt_destroy(prec->incltree);
 				}
+				opj_free(band->precincts);
 			}
-			if (tilec->resolutions != NULL) opj_free(tilec->resolutions);
 		}
-		if (tile->comps != NULL) opj_free(tile->comps);
+		opj_free(tilec->resolutions);
 	}
-
-	if (tcd_image->tiles != NULL) opj_free(tcd_image->tiles);
+	opj_free(tile->comps);
 }
 
diff -urN /home/robin/sldeb/trunk/libopenjpeg/tcd.h ./libopenjpeg/tcd.h
--- /home/robin/sldeb/trunk/libopenjpeg/tcd.h	2007-06-04 14:23:26.000000000 +0100
+++ ./libopenjpeg/tcd.h	2007-11-27 22:39:50.000000000 +0000
@@ -45,9 +45,10 @@
 FIXME: documentation
 */
 typedef struct opj_tcd_seg {
+  unsigned char** data;
+  int dataindex;
   int numpasses;
   int len;
-  unsigned char *data;
   int maxpasses;
   int numnewpasses;
   int newlen;
@@ -75,21 +76,28 @@
 /**
 FIXME: documentation
 */
-typedef struct opj_tcd_cblk {
+typedef struct opj_tcd_cblk_enc {
+  unsigned char* data;	/* Data */
+  opj_tcd_layer_t* layers;	/* layer information */
+  opj_tcd_pass_t* passes;	/* information about the passes */
   int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
   int numbps;
   int numlenbits;
-  int len;			/* length */
   int numpasses;		/* number of pass already done for the code-blocks */
-  int numnewpasses;		/* number of pass added to the code-blocks */
-  int numsegs;			/* number of segments */
-  opj_tcd_seg_t segs[100];		/* segments informations */
-  unsigned char data[8192];	/* Data */
   int numpassesinlayers;	/* number of passes in the layer */
-  opj_tcd_layer_t layers[100];	/* layer information */
   int totalpasses;		/* total number of passes */
-  opj_tcd_pass_t passes[100];	/* information about the passes */
-} opj_tcd_cblk_t;
+} opj_tcd_cblk_enc_t;
+
+typedef struct opj_tcd_cblk_dec {
+  unsigned char* data;	/* Data */
+  opj_tcd_seg_t* segs;		/* segments informations */
+	int x0, y0, x1, y1;		/* dimension of the code-blocks : left upper corner (x0, y0) right low corner (x1,y1) */
+  int numbps;
+  int numlenbits;
+  int len;			/* length */
+  int numnewpasses;		/* number of pass added to the code-blocks */
+  int numsegs;			/* number of segments */
+} opj_tcd_cblk_dec_t;
 
 /**
 FIXME: documentation
@@ -97,7 +105,10 @@
 typedef struct opj_tcd_precinct {
   int x0, y0, x1, y1;		/* dimension of the precinct : left upper corner (x0, y0) right low corner (x1,y1) */
   int cw, ch;			/* number of precinct in width and heigth */
-  opj_tcd_cblk_t *cblks;		/* code-blocks informations */
+  union{		/* code-blocks informations */
+	  opj_tcd_cblk_enc_t* enc;
+	  opj_tcd_cblk_dec_t* dec;
+  } cblks;
   opj_tgt_tree_t *incltree;		/* inclusion tree */
   opj_tgt_tree_t *imsbtree;		/* IMSB tree */
 } opj_tcd_precinct_t;
@@ -131,7 +142,7 @@
   int numresolutions;		/* number of resolutions level */
   opj_tcd_resolution_t *resolutions;	/* resolutions information */
   int *data;			/* data of the component */
-  int nbpix;			/* add fixed_quality */
+  int numpix;			/* add fixed_quality */
 } opj_tcd_tilecomp_t;
 
 /**
@@ -141,9 +152,11 @@
   int x0, y0, x1, y1;		/* dimension of the tile : left upper corner (x0, y0) right low corner (x1,y1) */
   int numcomps;			/* number of components in tile */
   opj_tcd_tilecomp_t *comps;	/* Components information */
-  int nbpix;			/* add fixed_quality */
+  int numpix;			/* add fixed_quality */
   double distotile;		/* add fixed_quality */
   double distolayer[100];	/* add fixed_quality */
+  /** packet number */
+  int packno;
 } opj_tcd_tile_t;
 
 /**
@@ -234,20 +247,21 @@
 @param cp Coding parameters
 */
 void tcd_malloc_decode(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp);
+void tcd_malloc_decode_tile(opj_tcd_t *tcd, opj_image_t * image, opj_cp_t * cp, int tileno, opj_codestream_info_t *cstr_info);
 void tcd_makelayer_fixed(opj_tcd_t *tcd, int layno, int final);
 void tcd_rateallocate_fixed(opj_tcd_t *tcd);
 void tcd_makelayer(opj_tcd_t *tcd, int layno, double thresh, int final);
-bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_image_info_t * image_info);
+bool tcd_rateallocate(opj_tcd_t *tcd, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
 /**
 Encode a tile from the raw image into a buffer
 @param tcd TCD handle
 @param tileno Number that identifies one of the tiles to be encoded
 @param dest Destination buffer
 @param len Length of destination buffer
-@param image_info Creation of index file
+@param cstr_info Codestream information structure 
 @return 
 */
-int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_image_info_t * image_info);
+int tcd_encode_tile(opj_tcd_t *tcd, int tileno, unsigned char *dest, int len, opj_codestream_info_t *cstr_info);
 /**
 Decode a tile from a buffer into a raw image
 @param tcd TCD handle
@@ -255,12 +269,13 @@
 @param len Length of source buffer
 @param tileno Number that identifies one of the tiles to be decoded
 */
-bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno);
+bool tcd_decode_tile(opj_tcd_t *tcd, unsigned char *src, int len, int tileno, opj_codestream_info_t *cstr_info);
 /**
 Free the memory allocated for decoding
 @param tcd TCD handle
 */
 void tcd_free_decode(opj_tcd_t *tcd);
+void tcd_free_decode_tile(opj_tcd_t *tcd, int tileno);
 
 /* ----------------------------------------------------------------------- */
 /*@}*/
diff -urN /home/robin/sldeb/trunk/libopenjpeg/tgt.c ./libopenjpeg/tgt.c
--- /home/robin/sldeb/trunk/libopenjpeg/tgt.c	2007-01-15 09:55:40.000000000 +0000
+++ ./libopenjpeg/tgt.c	2007-11-27 22:39:50.000000000 +0000
@@ -71,7 +71,7 @@
 		return NULL;
 	}
 
-	tree->nodes = (opj_tgt_node_t *) opj_malloc(tree->numnodes * sizeof(opj_tgt_node_t));
+	tree->nodes = (opj_tgt_node_t*) opj_calloc(tree->numnodes, sizeof(opj_tgt_node_t));
 	if(!tree->nodes) {
 		opj_free(tree);
 		return NULL;
diff -urN /home/robin/sldeb/trunk/LibOpenJPEG.sln ./LibOpenJPEG.sln
--- /home/robin/sldeb/trunk/LibOpenJPEG.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./LibOpenJPEG.sln	2007-09-28 11:33:52.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "LibOpenJPEG.vcproj", "{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.Build.0 = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.ActiveCfg = Release|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/LibOpenJPEG.vcproj ./LibOpenJPEG.vcproj
--- /home/robin/sldeb/trunk/LibOpenJPEG.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./LibOpenJPEG.vcproj	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,642 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="LibOpenJPEG"
+	ProjectGUID="{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile=".\Release\LibOpenJPEG.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Release\LibOpenJPEG.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				InlineFunctionExpansion="0"
+				EnableIntrinsicFunctions="false"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\LibOpenJPEGd.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Debug\LibOpenJPEGd.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath=".\libopenjpeg\opj_malloc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1_luts.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
Binary files /home/robin/sldeb/trunk/libs/libtiff/libtiff.lib and ./libs/libtiff/libtiff.lib differ
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/all-wcprops ./libs/libtiff/.svn/all-wcprops
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/all-wcprops	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,35 @@
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/409/trunk/libs/libtiff
+END
+libtiff.lib
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/409/trunk/libs/libtiff/libtiff.lib
+END
+tiffconf.h
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/409/trunk/libs/libtiff/tiffconf.h
+END
+tiffio.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/407/trunk/libs/libtiff/tiffio.h
+END
+tiff.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/407/trunk/libs/libtiff/tiff.h
+END
+tiffvers.h
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/407/trunk/libs/libtiff/tiffvers.h
+END
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/entries ./libs/libtiff/.svn/entries
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,89 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/libs/libtiff
+http://www.openjpeg.org/svn
+
+
+
+2007-07-19T15:04:39.957648Z
+409
+devaux
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+libtiff.lib
+file
+
+
+
+
+2007-09-28T10:33:43.000000Z
+a00fe4b03a08003727e263bb1619560b
+2007-07-19T15:04:39.957648Z
+409
+devaux
+has-props
+
+tiffconf.h
+file
+
+
+
+
+2007-09-28T10:33:43.000000Z
+c6737ee7ee9dcb8a1a1e45f96e4c7649
+2007-07-19T15:04:39.957648Z
+409
+devaux
+
+tiffio.h
+file
+
+
+
+
+2007-09-28T10:33:43.000000Z
+319e6b7bfa24517bea4ba10b7cfd5a84
+2007-07-19T13:44:04.294274Z
+407
+devaux
+
+tiff.h
+file
+
+
+
+
+2007-09-28T10:33:43.000000Z
+c5c4154f6c85225a31ebf6b017ed235b
+2007-07-19T13:44:04.294274Z
+407
+devaux
+
+tiffvers.h
+file
+
+
+
+
+2007-09-28T10:33:43.000000Z
+d1ffd7b45171ae12c43c9e79cbf6cd00
+2007-07-19T13:44:04.294274Z
+407
+devaux
+
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/format ./libs/libtiff/.svn/format
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/format	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/prop-base/libtiff.lib.svn-base ./libs/libtiff/.svn/prop-base/libtiff.lib.svn-base
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/prop-base/libtiff.lib.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/prop-base/libtiff.lib.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
Binary files /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/libtiff.lib.svn-base and ./libs/libtiff/.svn/text-base/libtiff.lib.svn-base differ
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffconf.h.svn-base ./libs/libtiff/.svn/text-base/tiffconf.h.svn-base
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffconf.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/text-base/tiffconf.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,101 @@
+/* libtiff/tiffconf.h.  Generated by configure.  */
+/*
+  Configuration defines for installed libtiff.
+  This file maintained for backward compatibility. Do not use definitions
+  from this file in your programs.
+*/
+
+#ifndef _TIFFCONF_
+#define _TIFFCONF_
+
+/* Define to 1 if the system has the type `int16'. */
+/* #undef HAVE_INT16 */
+
+/* Define to 1 if the system has the type `int32'. */
+/* #undef HAVE_INT32 */
+
+/* Define to 1 if the system has the type `int8'. */
+/* #undef HAVE_INT8 */
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* Compatibility stuff. */
+
+/* Define as 0 or 1 according to the floating point format suported by the
+   machine */
+#define HAVE_IEEEFP 1
+
+/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
+#define HOST_FILLORDER FILLORDER_LSB2MSB
+
+/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
+   (Intel) */
+#define HOST_BIGENDIAN 0
+
+/* Support CCITT Group 3 & 4 algorithms */
+#define CCITT_SUPPORT 1
+
+/* Support JPEG compression (requires IJG JPEG library) */
+#undef JPEG_SUPPORT 
+
+/* Support LogLuv high dynamic range encoding */
+#define LOGLUV_SUPPORT 1
+
+/* Support LZW algorithm */
+#define LZW_SUPPORT 1
+
+/* Support NeXT 2-bit RLE algorithm */
+#define NEXT_SUPPORT 1
+
+/* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
+   fails with unpatched IJG JPEG library) */
+/* #undef OJPEG_SUPPORT */
+
+/* Support Macintosh PackBits algorithm */
+#define PACKBITS_SUPPORT 1
+
+/* Support Pixar log-format algorithm (requires Zlib) */
+#define PIXARLOG_SUPPORT 1
+
+/* Support ThunderScan 4-bit RLE algorithm */
+#define THUNDER_SUPPORT 1
+
+/* Support Deflate compression */
+#define ZIP_SUPPORT 1
+
+/* Support strip chopping (whether or not to convert single-strip uncompressed
+   images to mutiple strips of ~8Kb to reduce memory usage) */
+#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
+
+/* Enable SubIFD tag (330) support */
+#define SUBIFD_SUPPORT 1
+
+/* Treat extra sample as alpha (default enabled). The RGBA interface will
+   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
+   packages produce RGBA files but don't mark the alpha properly. */
+#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
+
+/* Pick up YCbCr subsampling info from the JPEG data stream to support files
+   lacking the tag (default enabled). */
+#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
+
+/* Support MS MDI magic number files as TIFF */
+#define MDI_SUPPORT 1
+
+/*
+ * Feature support definitions.
+ * XXX: These macros are obsoleted. Don't use them in your apps!
+ * Macros stays here for backward compatibility and should be always defined.
+ */
+#define COLORIMETRY_SUPPORT
+#define YCBCR_SUPPORT
+#define CMYK_SUPPORT
+#define ICC_SUPPORT
+#define PHOTOSHOP_SUPPORT
+#define IPTC_SUPPORT
+
+#endif /* _TIFFCONF_ */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiff.h.svn-base ./libs/libtiff/.svn/text-base/tiff.h.svn-base
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiff.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/text-base/tiff.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,647 @@
+/* $Id: tiff.h,v 1.42 2005/12/23 15:10:45 dron Exp $ */
+
+/*
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and 
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that (i) the above copyright notices and this permission notice appear in
+ * all copies of the software and related documentation, and (ii) the names of
+ * Sam Leffler and Silicon Graphics may not be used in any advertising or
+ * publicity relating to the software without the specific, prior written
+ * permission of Sam Leffler and Silicon Graphics.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+ * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+ * 
+ * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+ * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+ * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _TIFF_
+#define	_TIFF_
+
+#include "tiffconf.h"
+
+/*
+ * Tag Image File Format (TIFF)
+ *
+ * Based on Rev 6.0 from:
+ *    Developer's Desk
+ *    Aldus Corporation
+ *    411 First Ave. South
+ *    Suite 200
+ *    Seattle, WA  98104
+ *    206-622-5500
+ *    
+ *    (http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf)
+ *
+ * For Big TIFF design notes see the following link
+ *    http://gdal.maptools.org/twiki/bin/view/libtiff/BigTIFFDesign
+ */
+#define	TIFF_VERSION	        42
+#define TIFF_BIGTIFF_VERSION    43
+
+#define	TIFF_BIGENDIAN		0x4d4d
+#define	TIFF_LITTLEENDIAN	0x4949
+#define	MDI_LITTLEENDIAN        0x5045
+#define	MDI_BIGENDIAN           0x4550
+/*
+ * Intrinsic data types required by the file format:
+ *
+ * 8-bit quantities	int8/uint8
+ * 16-bit quantities	int16/uint16
+ * 32-bit quantities	int32/uint32
+ * strings		unsigned char*
+ */
+
+#ifndef HAVE_INT8
+typedef	signed char int8;	/* NB: non-ANSI compilers may not grok */
+#endif
+typedef	unsigned char uint8;
+#ifndef HAVE_INT16
+typedef	short int16;
+#endif
+typedef	unsigned short uint16;	/* sizeof (uint16) must == 2 */
+#if SIZEOF_INT == 4
+#ifndef HAVE_INT32
+typedef	int int32;
+#endif
+typedef	unsigned int uint32;	/* sizeof (uint32) must == 4 */
+#elif SIZEOF_LONG == 4
+#ifndef HAVE_INT32
+typedef	long int32;
+#endif
+typedef	unsigned long uint32;	/* sizeof (uint32) must == 4 */
+#endif
+
+/* For TIFFReassignTagToIgnore */
+enum TIFFIgnoreSense /* IGNORE tag table */
+{
+	TIS_STORE,
+	TIS_EXTRACT,
+	TIS_EMPTY
+};
+
+/*
+ * TIFF header.
+ */
+typedef	struct {
+	uint16	tiff_magic;	/* magic number (defines byte order) */
+#define TIFF_MAGIC_SIZE		2
+	uint16	tiff_version;	/* TIFF version number */
+#define TIFF_VERSION_SIZE	2
+	uint32	tiff_diroff;	/* byte offset to first directory */
+#define TIFF_DIROFFSET_SIZE	4
+} TIFFHeader;
+
+
+/*
+ * TIFF Image File Directories are comprised of a table of field
+ * descriptors of the form shown below.  The table is sorted in
+ * ascending order by tag.  The values associated with each entry are
+ * disjoint and may appear anywhere in the file (so long as they are
+ * placed on a word boundary).
+ *
+ * If the value is 4 bytes or less, then it is placed in the offset
+ * field to save space.  If the value is less than 4 bytes, it is
+ * left-justified in the offset field.
+ */
+typedef	struct {
+	uint16		tdir_tag;	/* see below */
+	uint16		tdir_type;	/* data type; see below */
+	uint32		tdir_count;	/* number of items; length in spec */
+	uint32		tdir_offset;	/* byte offset to field data */
+} TIFFDirEntry;
+
+/*
+ * NB: In the comments below,
+ *  - items marked with a + are obsoleted by revision 5.0,
+ *  - items marked with a ! are introduced in revision 6.0.
+ *  - items marked with a % are introduced post revision 6.0.
+ *  - items marked with a $ are obsoleted by revision 6.0.
+ *  - items marked with a & are introduced by Adobe DNG specification.
+ */
+
+/*
+ * Tag data type information.
+ *
+ * Note: RATIONALs are the ratio of two 32-bit integer values.
+ */
+typedef	enum {
+	TIFF_NOTYPE	= 0,	/* placeholder */
+	TIFF_BYTE	= 1,	/* 8-bit unsigned integer */
+	TIFF_ASCII	= 2,	/* 8-bit bytes w/ last byte null */
+	TIFF_SHORT	= 3,	/* 16-bit unsigned integer */
+	TIFF_LONG	= 4,	/* 32-bit unsigned integer */
+	TIFF_RATIONAL	= 5,	/* 64-bit unsigned fraction */
+	TIFF_SBYTE	= 6,	/* !8-bit signed integer */
+	TIFF_UNDEFINED	= 7,	/* !8-bit untyped data */
+	TIFF_SSHORT	= 8,	/* !16-bit signed integer */
+	TIFF_SLONG	= 9,	/* !32-bit signed integer */
+	TIFF_SRATIONAL	= 10,	/* !64-bit signed fraction */
+	TIFF_FLOAT	= 11,	/* !32-bit IEEE floating point */
+	TIFF_DOUBLE	= 12,	/* !64-bit IEEE floating point */
+	TIFF_IFD	= 13	/* %32-bit unsigned integer (offset) */
+} TIFFDataType;
+
+/*
+ * TIFF Tag Definitions.
+ */
+#define	TIFFTAG_SUBFILETYPE		254	/* subfile data descriptor */
+#define	    FILETYPE_REDUCEDIMAGE	0x1	/* reduced resolution version */
+#define	    FILETYPE_PAGE		0x2	/* one page of many */
+#define	    FILETYPE_MASK		0x4	/* transparency mask */
+#define	TIFFTAG_OSUBFILETYPE		255	/* +kind of data in subfile */
+#define	    OFILETYPE_IMAGE		1	/* full resolution image data */
+#define	    OFILETYPE_REDUCEDIMAGE	2	/* reduced size image data */
+#define	    OFILETYPE_PAGE		3	/* one page of many */
+#define	TIFFTAG_IMAGEWIDTH		256	/* image width in pixels */
+#define	TIFFTAG_IMAGELENGTH		257	/* image height in pixels */
+#define	TIFFTAG_BITSPERSAMPLE		258	/* bits per channel (sample) */
+#define	TIFFTAG_COMPRESSION		259	/* data compression technique */
+#define	    COMPRESSION_NONE		1	/* dump mode */
+#define	    COMPRESSION_CCITTRLE	2	/* CCITT modified Huffman RLE */
+#define	    COMPRESSION_CCITTFAX3	3	/* CCITT Group 3 fax encoding */
+#define     COMPRESSION_CCITT_T4        3       /* CCITT T.4 (TIFF 6 name) */
+#define	    COMPRESSION_CCITTFAX4	4	/* CCITT Group 4 fax encoding */
+#define     COMPRESSION_CCITT_T6        4       /* CCITT T.6 (TIFF 6 name) */
+#define	    COMPRESSION_LZW		5       /* Lempel-Ziv  & Welch */
+#define	    COMPRESSION_OJPEG		6	/* !6.0 JPEG */
+#define	    COMPRESSION_JPEG		7	/* %JPEG DCT compression */
+#define	    COMPRESSION_NEXT		32766	/* NeXT 2-bit RLE */
+#define	    COMPRESSION_CCITTRLEW	32771	/* #1 w/ word alignment */
+#define	    COMPRESSION_PACKBITS	32773	/* Macintosh RLE */
+#define	    COMPRESSION_THUNDERSCAN	32809	/* ThunderScan RLE */
+/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define	    COMPRESSION_IT8CTPAD	32895   /* IT8 CT w/padding */
+#define	    COMPRESSION_IT8LW		32896   /* IT8 Linework RLE */
+#define	    COMPRESSION_IT8MP		32897   /* IT8 Monochrome picture */
+#define	    COMPRESSION_IT8BL		32898   /* IT8 Binary line art */
+/* compression codes 32908-32911 are reserved for Pixar */
+#define     COMPRESSION_PIXARFILM	32908   /* Pixar companded 10bit LZW */
+#define	    COMPRESSION_PIXARLOG	32909   /* Pixar companded 11bit ZIP */
+#define	    COMPRESSION_DEFLATE		32946	/* Deflate compression */
+#define     COMPRESSION_ADOBE_DEFLATE   8       /* Deflate compression,
+						   as recognized by Adobe */
+/* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */
+#define     COMPRESSION_DCS             32947   /* Kodak DCS encoding */
+#define	    COMPRESSION_JBIG		34661	/* ISO JBIG */
+#define     COMPRESSION_SGILOG		34676	/* SGI Log Luminance RLE */
+#define     COMPRESSION_SGILOG24	34677	/* SGI Log 24-bit packed */
+#define     COMPRESSION_JP2000          34712   /* Leadtools JPEG2000 */
+#define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
+#define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
+#define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
+#define	    PHOTOMETRIC_RGB		2	/* RGB color model */
+#define	    PHOTOMETRIC_PALETTE		3	/* color map indexed */
+#define	    PHOTOMETRIC_MASK		4	/* $holdout mask */
+#define	    PHOTOMETRIC_SEPARATED	5	/* !color separations */
+#define	    PHOTOMETRIC_YCBCR		6	/* !CCIR 601 */
+#define	    PHOTOMETRIC_CIELAB		8	/* !1976 CIE L*a*b* */
+#define	    PHOTOMETRIC_ICCLAB		9	/* ICC L*a*b* [Adobe TIFF Technote 4] */
+#define	    PHOTOMETRIC_ITULAB		10	/* ITU L*a*b* */
+#define     PHOTOMETRIC_LOGL		32844	/* CIE Log2(L) */
+#define     PHOTOMETRIC_LOGLUV		32845	/* CIE Log2(L) (u',v') */
+#define	TIFFTAG_THRESHHOLDING		263	/* +thresholding used on data */
+#define	    THRESHHOLD_BILEVEL		1	/* b&w art scan */
+#define	    THRESHHOLD_HALFTONE		2	/* or dithered scan */
+#define	    THRESHHOLD_ERRORDIFFUSE	3	/* usually floyd-steinberg */
+#define	TIFFTAG_CELLWIDTH		264	/* +dithering matrix width */
+#define	TIFFTAG_CELLLENGTH		265	/* +dithering matrix height */
+#define	TIFFTAG_FILLORDER		266	/* data order within a byte */
+#define	    FILLORDER_MSB2LSB		1	/* most significant -> least */
+#define	    FILLORDER_LSB2MSB		2	/* least significant -> most */
+#define	TIFFTAG_DOCUMENTNAME		269	/* name of doc. image is from */
+#define	TIFFTAG_IMAGEDESCRIPTION	270	/* info about image */
+#define	TIFFTAG_MAKE			271	/* scanner manufacturer name */
+#define	TIFFTAG_MODEL			272	/* scanner model name/number */
+#define	TIFFTAG_STRIPOFFSETS		273	/* offsets to data strips */
+#define	TIFFTAG_ORIENTATION		274	/* +image orientation */
+#define	    ORIENTATION_TOPLEFT		1	/* row 0 top, col 0 lhs */
+#define	    ORIENTATION_TOPRIGHT	2	/* row 0 top, col 0 rhs */
+#define	    ORIENTATION_BOTRIGHT	3	/* row 0 bottom, col 0 rhs */
+#define	    ORIENTATION_BOTLEFT		4	/* row 0 bottom, col 0 lhs */
+#define	    ORIENTATION_LEFTTOP		5	/* row 0 lhs, col 0 top */
+#define	    ORIENTATION_RIGHTTOP	6	/* row 0 rhs, col 0 top */
+#define	    ORIENTATION_RIGHTBOT	7	/* row 0 rhs, col 0 bottom */
+#define	    ORIENTATION_LEFTBOT		8	/* row 0 lhs, col 0 bottom */
+#define	TIFFTAG_SAMPLESPERPIXEL		277	/* samples per pixel */
+#define	TIFFTAG_ROWSPERSTRIP		278	/* rows per strip of data */
+#define	TIFFTAG_STRIPBYTECOUNTS		279	/* bytes counts for strips */
+#define	TIFFTAG_MINSAMPLEVALUE		280	/* +minimum sample value */
+#define	TIFFTAG_MAXSAMPLEVALUE		281	/* +maximum sample value */
+#define	TIFFTAG_XRESOLUTION		282	/* pixels/resolution in x */
+#define	TIFFTAG_YRESOLUTION		283	/* pixels/resolution in y */
+#define	TIFFTAG_PLANARCONFIG		284	/* storage organization */
+#define	    PLANARCONFIG_CONTIG		1	/* single image plane */
+#define	    PLANARCONFIG_SEPARATE	2	/* separate planes of data */
+#define	TIFFTAG_PAGENAME		285	/* page name image is from */
+#define	TIFFTAG_XPOSITION		286	/* x page offset of image lhs */
+#define	TIFFTAG_YPOSITION		287	/* y page offset of image lhs */
+#define	TIFFTAG_FREEOFFSETS		288	/* +byte offset to free block */
+#define	TIFFTAG_FREEBYTECOUNTS		289	/* +sizes of free blocks */
+#define	TIFFTAG_GRAYRESPONSEUNIT	290	/* $gray scale curve accuracy */
+#define	    GRAYRESPONSEUNIT_10S	1	/* tenths of a unit */
+#define	    GRAYRESPONSEUNIT_100S	2	/* hundredths of a unit */
+#define	    GRAYRESPONSEUNIT_1000S	3	/* thousandths of a unit */
+#define	    GRAYRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
+#define	    GRAYRESPONSEUNIT_100000S	5	/* hundred-thousandths */
+#define	TIFFTAG_GRAYRESPONSECURVE	291	/* $gray scale response curve */
+#define	TIFFTAG_GROUP3OPTIONS		292	/* 32 flag bits */
+#define	TIFFTAG_T4OPTIONS		292	/* TIFF 6.0 proper name alias */
+#define	    GROUP3OPT_2DENCODING	0x1	/* 2-dimensional coding */
+#define	    GROUP3OPT_UNCOMPRESSED	0x2	/* data not compressed */
+#define	    GROUP3OPT_FILLBITS		0x4	/* fill to byte boundary */
+#define	TIFFTAG_GROUP4OPTIONS		293	/* 32 flag bits */
+#define TIFFTAG_T6OPTIONS               293     /* TIFF 6.0 proper name */
+#define	    GROUP4OPT_UNCOMPRESSED	0x2	/* data not compressed */
+#define	TIFFTAG_RESOLUTIONUNIT		296	/* units of resolutions */
+#define	    RESUNIT_NONE		1	/* no meaningful units */
+#define	    RESUNIT_INCH		2	/* english */
+#define	    RESUNIT_CENTIMETER		3	/* metric */
+#define	TIFFTAG_PAGENUMBER		297	/* page numbers of multi-page */
+#define	TIFFTAG_COLORRESPONSEUNIT	300	/* $color curve accuracy */
+#define	    COLORRESPONSEUNIT_10S	1	/* tenths of a unit */
+#define	    COLORRESPONSEUNIT_100S	2	/* hundredths of a unit */
+#define	    COLORRESPONSEUNIT_1000S	3	/* thousandths of a unit */
+#define	    COLORRESPONSEUNIT_10000S	4	/* ten-thousandths of a unit */
+#define	    COLORRESPONSEUNIT_100000S	5	/* hundred-thousandths */
+#define	TIFFTAG_TRANSFERFUNCTION	301	/* !colorimetry info */
+#define	TIFFTAG_SOFTWARE		305	/* name & release */
+#define	TIFFTAG_DATETIME		306	/* creation date and time */
+#define	TIFFTAG_ARTIST			315	/* creator of image */
+#define	TIFFTAG_HOSTCOMPUTER		316	/* machine where created */
+#define	TIFFTAG_PREDICTOR		317	/* prediction scheme w/ LZW */
+#define     PREDICTOR_NONE		1	/* no prediction scheme used */
+#define     PREDICTOR_HORIZONTAL	2	/* horizontal differencing */
+#define     PREDICTOR_FLOATINGPOINT	3	/* floating point predictor */
+#define	TIFFTAG_WHITEPOINT		318	/* image white point */
+#define	TIFFTAG_PRIMARYCHROMATICITIES	319	/* !primary chromaticities */
+#define	TIFFTAG_COLORMAP		320	/* RGB map for pallette image */
+#define	TIFFTAG_HALFTONEHINTS		321	/* !highlight+shadow info */
+#define	TIFFTAG_TILEWIDTH		322	/* !tile width in pixels */
+#define	TIFFTAG_TILELENGTH		323	/* !tile height in pixels */
+#define TIFFTAG_TILEOFFSETS		324	/* !offsets to data tiles */
+#define TIFFTAG_TILEBYTECOUNTS		325	/* !byte counts for tiles */
+#define	TIFFTAG_BADFAXLINES		326	/* lines w/ wrong pixel count */
+#define	TIFFTAG_CLEANFAXDATA		327	/* regenerated line info */
+#define	    CLEANFAXDATA_CLEAN		0	/* no errors detected */
+#define	    CLEANFAXDATA_REGENERATED	1	/* receiver regenerated lines */
+#define	    CLEANFAXDATA_UNCLEAN	2	/* uncorrected errors exist */
+#define	TIFFTAG_CONSECUTIVEBADFAXLINES	328	/* max consecutive bad lines */
+#define	TIFFTAG_SUBIFD			330	/* subimage descriptors */
+#define	TIFFTAG_INKSET			332	/* !inks in separated image */
+#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black color */
+#define	    INKSET_MULTIINK		2	/* !multi-ink or hi-fi color */
+#define	TIFFTAG_INKNAMES		333	/* !ascii names of inks */
+#define	TIFFTAG_NUMBEROFINKS		334	/* !number of inks */
+#define	TIFFTAG_DOTRANGE		336	/* !0% and 100% dot codes */
+#define	TIFFTAG_TARGETPRINTER		337	/* !separation target */
+#define	TIFFTAG_EXTRASAMPLES		338	/* !info about extra samples */
+#define	    EXTRASAMPLE_UNSPECIFIED	0	/* !unspecified data */
+#define	    EXTRASAMPLE_ASSOCALPHA	1	/* !associated alpha data */
+#define	    EXTRASAMPLE_UNASSALPHA	2	/* !unassociated alpha data */
+#define	TIFFTAG_SAMPLEFORMAT		339	/* !data sample format */
+#define	    SAMPLEFORMAT_UINT		1	/* !unsigned integer data */
+#define	    SAMPLEFORMAT_INT		2	/* !signed integer data */
+#define	    SAMPLEFORMAT_IEEEFP		3	/* !IEEE floating point data */
+#define	    SAMPLEFORMAT_VOID		4	/* !untyped data */
+#define	    SAMPLEFORMAT_COMPLEXINT	5	/* !complex signed int */
+#define	    SAMPLEFORMAT_COMPLEXIEEEFP	6	/* !complex ieee floating */
+#define	TIFFTAG_SMINSAMPLEVALUE		340	/* !variable MinSampleValue */
+#define	TIFFTAG_SMAXSAMPLEVALUE		341	/* !variable MaxSampleValue */
+#define	TIFFTAG_CLIPPATH		343	/* %ClipPath
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_XCLIPPATHUNITS		344	/* %XClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_YCLIPPATHUNITS		345	/* %YClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_INDEXED			346	/* %Indexed
+						   [Adobe TIFF Technote 3] */
+#define	TIFFTAG_JPEGTABLES		347	/* %JPEG table stream */
+#define	TIFFTAG_OPIPROXY		351	/* %OPI Proxy [Adobe TIFF technote] */
+/*
+ * Tags 512-521 are obsoleted by Technical Note #2 which specifies a
+ * revised JPEG-in-TIFF scheme.
+ */
+#define	TIFFTAG_JPEGPROC		512	/* !JPEG processing algorithm */
+#define	    JPEGPROC_BASELINE		1	/* !baseline sequential */
+#define	    JPEGPROC_LOSSLESS		14	/* !Huffman coded lossless */
+#define	TIFFTAG_JPEGIFOFFSET		513	/* !pointer to SOI marker */
+#define	TIFFTAG_JPEGIFBYTECOUNT		514	/* !JFIF stream length */
+#define	TIFFTAG_JPEGRESTARTINTERVAL	515	/* !restart interval length */
+#define	TIFFTAG_JPEGLOSSLESSPREDICTORS	517	/* !lossless proc predictor */
+#define	TIFFTAG_JPEGPOINTTRANSFORM	518	/* !lossless point transform */
+#define	TIFFTAG_JPEGQTABLES		519	/* !Q matrice offsets */
+#define	TIFFTAG_JPEGDCTABLES		520	/* !DCT table offsets */
+#define	TIFFTAG_JPEGACTABLES		521	/* !AC coefficient offsets */
+#define	TIFFTAG_YCBCRCOEFFICIENTS	529	/* !RGB -> YCbCr transform */
+#define	TIFFTAG_YCBCRSUBSAMPLING	530	/* !YCbCr subsampling factors */
+#define	TIFFTAG_YCBCRPOSITIONING	531	/* !subsample positioning */
+#define	    YCBCRPOSITION_CENTERED	1	/* !as in PostScript Level 2 */
+#define	    YCBCRPOSITION_COSITED	2	/* !as in CCIR 601-1 */
+#define	TIFFTAG_REFERENCEBLACKWHITE	532	/* !colorimetry info */
+#define	TIFFTAG_XMLPACKET		700	/* %XML packet
+						   [Adobe XMP Specification,
+						   January 2004 */
+#define TIFFTAG_OPIIMAGEID		32781	/* %OPI ImageID
+						   [Adobe TIFF technote] */
+/* tags 32952-32956 are private tags registered to Island Graphics */
+#define TIFFTAG_REFPTS			32953	/* image reference points */
+#define TIFFTAG_REGIONTACKPOINT		32954	/* region-xform tack point */
+#define TIFFTAG_REGIONWARPCORNERS	32955	/* warp quadrilateral */
+#define TIFFTAG_REGIONAFFINE		32956	/* affine transformation mat */
+/* tags 32995-32999 are private tags registered to SGI */
+#define	TIFFTAG_MATTEING		32995	/* $use ExtraSamples */
+#define	TIFFTAG_DATATYPE		32996	/* $use SampleFormat */
+#define	TIFFTAG_IMAGEDEPTH		32997	/* z depth of image */
+#define	TIFFTAG_TILEDEPTH		32998	/* z depth/data tile */
+/* tags 33300-33309 are private tags registered to Pixar */
+/*
+ * TIFFTAG_PIXAR_IMAGEFULLWIDTH and TIFFTAG_PIXAR_IMAGEFULLLENGTH
+ * are set when an image has been cropped out of a larger image.  
+ * They reflect the size of the original uncropped image.
+ * The TIFFTAG_XPOSITION and TIFFTAG_YPOSITION can be used
+ * to determine the position of the smaller image in the larger one.
+ */
+#define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   /* full image size in x */
+#define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   /* full image size in y */
+ /* Tags 33302-33306 are used to identify special image modes and data
+  * used by Pixar's texture formats.
+  */
+#define TIFFTAG_PIXAR_TEXTUREFORMAT	33302	/* texture map format */
+#define TIFFTAG_PIXAR_WRAPMODES		33303	/* s & t wrap modes */
+#define TIFFTAG_PIXAR_FOVCOT		33304	/* cotan(fov) for env. maps */
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN 33305
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA 33306
+/* tag 33405 is a private tag registered to Eastman Kodak */
+#define TIFFTAG_WRITERSERIALNUMBER      33405   /* device serial number */
+/* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
+#define	TIFFTAG_COPYRIGHT		33432	/* copyright string */
+/* IPTC TAG from RichTIFF specifications */
+#define TIFFTAG_RICHTIFFIPTC		33723
+/* 34016-34029 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define TIFFTAG_IT8SITE			34016	/* site name */
+#define TIFFTAG_IT8COLORSEQUENCE	34017	/* color seq. [RGB,CMYK,etc] */
+#define TIFFTAG_IT8HEADER		34018	/* DDES Header */
+#define TIFFTAG_IT8RASTERPADDING	34019	/* raster scanline padding */
+#define TIFFTAG_IT8BITSPERRUNLENGTH	34020	/* # of bits in short run */
+#define TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH 34021/* # of bits in long run */
+#define TIFFTAG_IT8COLORTABLE		34022	/* LW colortable */
+#define TIFFTAG_IT8IMAGECOLORINDICATOR	34023	/* BP/BL image color switch */
+#define TIFFTAG_IT8BKGCOLORINDICATOR	34024	/* BP/BL bg color switch */
+#define TIFFTAG_IT8IMAGECOLORVALUE	34025	/* BP/BL image color value */
+#define TIFFTAG_IT8BKGCOLORVALUE	34026	/* BP/BL bg color value */
+#define TIFFTAG_IT8PIXELINTENSITYRANGE	34027	/* MP pixel intensity value */
+#define TIFFTAG_IT8TRANSPARENCYINDICATOR 34028	/* HC transparency switch */
+#define TIFFTAG_IT8COLORCHARACTERIZATION 34029	/* color character. table */
+#define TIFFTAG_IT8HCUSAGE		34030	/* HC usage indicator */
+#define TIFFTAG_IT8TRAPINDICATOR	34031	/* Trapping indicator
+						   (untrapped=0, trapped=1) */
+#define TIFFTAG_IT8CMYKEQUIVALENT	34032	/* CMYK color equivalents */
+/* tags 34232-34236 are private tags registered to Texas Instruments */
+#define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
+/* tag 34377 is private tag registered to Adobe for PhotoShop */
+#define TIFFTAG_PHOTOSHOP		34377 
+/* tags 34665, 34853 and 40965 are documented in EXIF specification */
+#define TIFFTAG_EXIFIFD			34665	/* Pointer to EXIF private directory */
+/* tag 34750 is a private tag registered to Adobe? */
+#define TIFFTAG_ICCPROFILE		34675	/* ICC profile data */
+/* tag 34750 is a private tag registered to Pixel Magic */
+#define	TIFFTAG_JBIGOPTIONS		34750	/* JBIG options */
+#define TIFFTAG_GPSIFD			34853	/* Pointer to GPS private directory */
+/* tags 34908-34914 are private tags registered to SGI */
+#define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. parms */
+#define	TIFFTAG_FAXSUBADDRESS		34909	/* received SubAddr string */
+#define	TIFFTAG_FAXRECVTIME		34910	/* receive time (secs) */
+#define	TIFFTAG_FAXDCS			34911	/* encoded fax ses. params, Table 2/T.30 */
+/* tags 37439-37443 are registered to SGI <gregl@sgi.com> */
+#define TIFFTAG_STONITS			37439	/* Sample value to Nits */
+/* tag 34929 is a private tag registered to FedEx */
+#define	TIFFTAG_FEDEX_EDR		34929	/* unknown use */
+#define TIFFTAG_INTEROPERABILITYIFD	40965	/* Pointer to Interoperability private directory */
+/* Adobe Digital Negative (DNG) format tags */
+#define TIFFTAG_DNGVERSION		50706	/* &DNG version number */
+#define TIFFTAG_DNGBACKWARDVERSION	50707	/* &DNG compatibility version */
+#define TIFFTAG_UNIQUECAMERAMODEL	50708	/* &name for the camera model */
+#define TIFFTAG_LOCALIZEDCAMERAMODEL	50709	/* &localized camera model
+						   name */
+#define TIFFTAG_CFAPLANECOLOR		50710	/* &CFAPattern->LinearRaw space
+						   mapping */
+#define TIFFTAG_CFALAYOUT		50711	/* &spatial layout of the CFA */
+#define TIFFTAG_LINEARIZATIONTABLE	50712	/* &lookup table description */
+#define TIFFTAG_BLACKLEVELREPEATDIM	50713	/* &repeat pattern size for
+						   the BlackLevel tag */
+#define TIFFTAG_BLACKLEVEL		50714	/* &zero light encoding level */
+#define TIFFTAG_BLACKLEVELDELTAH	50715	/* &zero light encoding level
+						   differences (columns) */
+#define TIFFTAG_BLACKLEVELDELTAV	50716	/* &zero light encoding level
+						   differences (rows) */
+#define TIFFTAG_WHITELEVEL		50717	/* &fully saturated encoding
+						   level */
+#define TIFFTAG_DEFAULTSCALE		50718	/* &default scale factors */
+#define TIFFTAG_DEFAULTCROPORIGIN	50719	/* &origin of the final image
+						   area */
+#define TIFFTAG_DEFAULTCROPSIZE		50720	/* &size of the final image 
+						   area */
+#define TIFFTAG_COLORMATRIX1		50721	/* &XYZ->reference color space
+						   transformation matrix 1 */
+#define TIFFTAG_COLORMATRIX2		50722	/* &XYZ->reference color space
+						   transformation matrix 2 */
+#define TIFFTAG_CAMERACALIBRATION1	50723	/* &calibration matrix 1 */
+#define TIFFTAG_CAMERACALIBRATION2	50724	/* &calibration matrix 2 */
+#define TIFFTAG_REDUCTIONMATRIX1	50725	/* &dimensionality reduction
+						   matrix 1 */
+#define TIFFTAG_REDUCTIONMATRIX2	50726	/* &dimensionality reduction
+						   matrix 2 */
+#define TIFFTAG_ANALOGBALANCE		50727	/* &gain applied the stored raw
+						   values*/
+#define TIFFTAG_ASSHOTNEUTRAL		50728	/* &selected white balance in
+						   linear reference space */
+#define TIFFTAG_ASSHOTWHITEXY		50729	/* &selected white balance in
+						   x-y chromaticity
+						   coordinates */
+#define TIFFTAG_BASELINEEXPOSURE	50730	/* &how much to move the zero
+						   point */
+#define TIFFTAG_BASELINENOISE		50731	/* &relative noise level */
+#define TIFFTAG_BASELINESHARPNESS	50732	/* &relative amount of
+						   sharpening */
+#define TIFFTAG_BAYERGREENSPLIT		50733	/* &how closely the values of
+						   the green pixels in the
+						   blue/green rows track the
+						   values of the green pixels
+						   in the red/green rows */
+#define TIFFTAG_LINEARRESPONSELIMIT	50734	/* &non-linear encoding range */
+#define TIFFTAG_CAMERASERIALNUMBER	50735	/* &camera's serial number */
+#define TIFFTAG_LENSINFO		50736	/* info about the lens */
+#define TIFFTAG_CHROMABLURRADIUS	50737	/* &chroma blur radius */
+#define TIFFTAG_ANTIALIASSTRENGTH	50738	/* &relative strength of the
+						   camera's anti-alias filter */
+#define TIFFTAG_SHADOWSCALE		50739	/* &used by Adobe Camera Raw */
+#define TIFFTAG_DNGPRIVATEDATA		50740	/* &manufacturer's private data */
+#define TIFFTAG_MAKERNOTESAFETY		50741	/* &whether the EXIF MakerNote
+						   tag is safe to preserve
+						   along with the rest of the
+						   EXIF data */
+#define	TIFFTAG_CALIBRATIONILLUMINANT1	50778	/* &illuminant 1 */
+#define TIFFTAG_CALIBRATIONILLUMINANT2	50779	/* &illuminant 2 */
+#define TIFFTAG_BESTQUALITYSCALE	50780	/* &best quality multiplier */
+#define TIFFTAG_RAWDATAUNIQUEID		50781	/* &unique identifier for
+						   the raw image data */
+#define TIFFTAG_ORIGINALRAWFILENAME	50827	/* &file name of the original
+						   raw file */
+#define TIFFTAG_ORIGINALRAWFILEDATA	50828	/* &contents of the original
+						   raw file */
+#define TIFFTAG_ACTIVEAREA		50829	/* &active (non-masked) pixels
+						   of the sensor */
+#define TIFFTAG_MASKEDAREAS		50830	/* &list of coordinates
+						   of fully masked pixels */
+#define TIFFTAG_ASSHOTICCPROFILE	50831	/* &these two tags used to */
+#define TIFFTAG_ASSHOTPREPROFILEMATRIX	50832	/* map cameras's color space
+						   into ICC profile space */
+#define TIFFTAG_CURRENTICCPROFILE	50833	/* & */
+#define TIFFTAG_CURRENTPREPROFILEMATRIX	50834	/* & */
+/* tag 65535 is an undefined tag used by Eastman Kodak */
+#define TIFFTAG_DCSHUESHIFTVALUES       65535   /* hue shift correction data */
+
+/*
+ * The following are ``pseudo tags'' that can be used to control
+ * codec-specific functionality.  These tags are not written to file.
+ * Note that these values start at 0xffff+1 so that they'll never
+ * collide with Aldus-assigned tags.
+ *
+ * If you want your private pseudo tags ``registered'' (i.e. added to
+ * this file), please post a bug report via the tracking system at
+ * http://www.remotesensing.org/libtiff/bugs.html with the appropriate
+ * C definitions to add.
+ */
+#define	TIFFTAG_FAXMODE			65536	/* Group 3/4 format control */
+#define	    FAXMODE_CLASSIC	0x0000		/* default, include RTC */
+#define	    FAXMODE_NORTC	0x0001		/* no RTC at end of data */
+#define	    FAXMODE_NOEOL	0x0002		/* no EOL code at end of row */
+#define	    FAXMODE_BYTEALIGN	0x0004		/* byte align row */
+#define	    FAXMODE_WORDALIGN	0x0008		/* word align row */
+#define	    FAXMODE_CLASSF	FAXMODE_NORTC	/* TIFF Class F */
+#define	TIFFTAG_JPEGQUALITY		65537	/* Compression quality level */
+/* Note: quality level is on the IJG 0-100 scale.  Default value is 75 */
+#define	TIFFTAG_JPEGCOLORMODE		65538	/* Auto RGB<=>YCbCr convert? */
+#define	    JPEGCOLORMODE_RAW	0x0000		/* no conversion (default) */
+#define	    JPEGCOLORMODE_RGB	0x0001		/* do auto conversion */
+#define	TIFFTAG_JPEGTABLESMODE		65539	/* What to put in JPEGTables */
+#define	    JPEGTABLESMODE_QUANT 0x0001		/* include quantization tbls */
+#define	    JPEGTABLESMODE_HUFF	0x0002		/* include Huffman tbls */
+/* Note: default is JPEGTABLESMODE_QUANT | JPEGTABLESMODE_HUFF */
+#define	TIFFTAG_FAXFILLFUNC		65540	/* G3/G4 fill function */
+#define	TIFFTAG_PIXARLOGDATAFMT		65549	/* PixarLogCodec I/O data sz */
+#define	    PIXARLOGDATAFMT_8BIT	0	/* regular u_char samples */
+#define	    PIXARLOGDATAFMT_8BITABGR	1	/* ABGR-order u_chars */
+#define	    PIXARLOGDATAFMT_11BITLOG	2	/* 11-bit log-encoded (raw) */
+#define	    PIXARLOGDATAFMT_12BITPICIO	3	/* as per PICIO (1.0==2048) */
+#define	    PIXARLOGDATAFMT_16BIT	4	/* signed short samples */
+#define	    PIXARLOGDATAFMT_FLOAT	5	/* IEEE float samples */
+/* 65550-65556 are allocated to Oceana Matrix <dev@oceana.com> */
+#define TIFFTAG_DCSIMAGERTYPE           65550   /* imager model & filter */
+#define     DCSIMAGERMODEL_M3           0       /* M3 chip (1280 x 1024) */
+#define     DCSIMAGERMODEL_M5           1       /* M5 chip (1536 x 1024) */
+#define     DCSIMAGERMODEL_M6           2       /* M6 chip (3072 x 2048) */
+#define     DCSIMAGERFILTER_IR          0       /* infrared filter */
+#define     DCSIMAGERFILTER_MONO        1       /* monochrome filter */
+#define     DCSIMAGERFILTER_CFA         2       /* color filter array */
+#define     DCSIMAGERFILTER_OTHER       3       /* other filter */
+#define TIFFTAG_DCSINTERPMODE           65551   /* interpolation mode */
+#define     DCSINTERPMODE_NORMAL        0x0     /* whole image, default */
+#define     DCSINTERPMODE_PREVIEW       0x1     /* preview of image (384x256) */
+#define TIFFTAG_DCSBALANCEARRAY         65552   /* color balance values */
+#define TIFFTAG_DCSCORRECTMATRIX        65553   /* color correction values */
+#define TIFFTAG_DCSGAMMA                65554   /* gamma value */
+#define TIFFTAG_DCSTOESHOULDERPTS       65555   /* toe & shoulder points */
+#define TIFFTAG_DCSCALIBRATIONFD        65556   /* calibration file desc */
+/* Note: quality level is on the ZLIB 1-9 scale. Default value is -1 */
+#define	TIFFTAG_ZIPQUALITY		65557	/* compression quality level */
+#define	TIFFTAG_PIXARLOGQUALITY		65558	/* PixarLog uses same scale */
+/* 65559 is allocated to Oceana Matrix <dev@oceana.com> */
+#define TIFFTAG_DCSCLIPRECTANGLE	65559	/* area of image to acquire */
+#define TIFFTAG_SGILOGDATAFMT		65560	/* SGILog user data format */
+#define     SGILOGDATAFMT_FLOAT		0	/* IEEE float samples */
+#define     SGILOGDATAFMT_16BIT		1	/* 16-bit samples */
+#define     SGILOGDATAFMT_RAW		2	/* uninterpreted data */
+#define     SGILOGDATAFMT_8BIT		3	/* 8-bit RGB monitor values */
+#define TIFFTAG_SGILOGENCODE		65561 /* SGILog data encoding control*/
+#define     SGILOGENCODE_NODITHER	0     /* do not dither encoded values*/
+#define     SGILOGENCODE_RANDITHER	1     /* randomly dither encd values */
+
+/*
+ * EXIF tags
+ */
+#define EXIFTAG_EXPOSURETIME		33434	/* Exposure time */
+#define EXIFTAG_FNUMBER			33437	/* F number */
+#define EXIFTAG_EXPOSUREPROGRAM		34850	/* Exposure program */
+#define EXIFTAG_SPECTRALSENSITIVITY	34852	/* Spectral sensitivity */
+#define EXIFTAG_ISOSPEEDRATINGS		34855	/* ISO speed rating */
+#define EXIFTAG_OECF			34856	/* Optoelectric conversion
+						   factor */
+#define EXIFTAG_EXIFVERSION		36864	/* Exif version */
+#define EXIFTAG_DATETIMEORIGINAL	36867	/* Date and time of original
+						   data generation */
+#define EXIFTAG_DATETIMEDIGITIZED	36868	/* Date and time of digital
+						   data generation */
+#define EXIFTAG_COMPONENTSCONFIGURATION	37121	/* Meaning of each component */
+#define EXIFTAG_COMPRESSEDBITSPERPIXEL	37122	/* Image compression mode */
+#define EXIFTAG_SHUTTERSPEEDVALUE	37377	/* Shutter speed */
+#define EXIFTAG_APERTUREVALUE		37378	/* Aperture */
+#define EXIFTAG_BRIGHTNESSVALUE		37379	/* Brightness */
+#define EXIFTAG_EXPOSUREBIASVALUE	37380	/* Exposure bias */
+#define EXIFTAG_MAXAPERTUREVALUE	37381	/* Maximum lens aperture */
+#define EXIFTAG_SUBJECTDISTANCE		37382	/* Subject distance */
+#define EXIFTAG_METERINGMODE		37383	/* Metering mode */
+#define EXIFTAG_LIGHTSOURCE		37384	/* Light source */
+#define EXIFTAG_FLASH			37385	/* Flash */
+#define EXIFTAG_FOCALLENGTH		37386	/* Lens focal length */
+#define EXIFTAG_SUBJECTAREA		37396	/* Subject area */
+#define EXIFTAG_MAKERNOTE		37500	/* Manufacturer notes */
+#define EXIFTAG_USERCOMMENT		37510	/* User comments */
+#define EXIFTAG_SUBSECTIME		37520	/* DateTime subseconds */
+#define EXIFTAG_SUBSECTIMEORIGINAL	37521	/* DateTimeOriginal subseconds */
+#define EXIFTAG_SUBSECTIMEDIGITIZED	37522	/* DateTimeDigitized subseconds */
+#define EXIFTAG_FLASHPIXVERSION		40960	/* Supported Flashpix version */
+#define EXIFTAG_COLORSPACE		40961	/* Color space information */
+#define EXIFTAG_PIXELXDIMENSION		40962	/* Valid image width */
+#define EXIFTAG_PIXELYDIMENSION		40963	/* Valid image height */
+#define EXIFTAG_RELATEDSOUNDFILE	40964	/* Related audio file */
+#define EXIFTAG_FLASHENERGY		41483	/* Flash energy */
+#define EXIFTAG_SPATIALFREQUENCYRESPONSE 41484	/* Spatial frequency response */
+#define EXIFTAG_FOCALPLANEXRESOLUTION	41486	/* Focal plane X resolution */
+#define EXIFTAG_FOCALPLANEYRESOLUTION	41487	/* Focal plane Y resolution */
+#define EXIFTAG_FOCALPLANERESOLUTIONUNIT 41488	/* Focal plane resolution unit */
+#define EXIFTAG_SUBJECTLOCATION		41492	/* Subject location */
+#define EXIFTAG_EXPOSUREINDEX		41493	/* Exposure index */
+#define EXIFTAG_SENSINGMETHOD		41495	/* Sensing method */
+#define EXIFTAG_FILESOURCE		41728	/* File source */
+#define EXIFTAG_SCENETYPE		41729	/* Scene type */
+#define EXIFTAG_CFAPATTERN		41730	/* CFA pattern */
+#define EXIFTAG_CUSTOMRENDERED		41985	/* Custom image processing */
+#define EXIFTAG_EXPOSUREMODE		41986	/* Exposure mode */
+#define EXIFTAG_WHITEBALANCE		41987	/* White balance */
+#define EXIFTAG_DIGITALZOOMRATIO	41988	/* Digital zoom ratio */
+#define EXIFTAG_FOCALLENGTHIN35MMFILM	41989	/* Focal length in 35 mm film */
+#define EXIFTAG_SCENECAPTURETYPE	41990	/* Scene capture type */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_CONTRAST		41992	/* Contrast */
+#define EXIFTAG_SATURATION		41993	/* Saturation */
+#define EXIFTAG_SHARPNESS		41994	/* Sharpness */
+#define EXIFTAG_DEVICESETTINGDESCRIPTION 41995	/* Device settings description */
+#define EXIFTAG_SUBJECTDISTANCERANGE	41996	/* Subject distance range */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_IMAGEUNIQUEID		42016	/* Unique image ID */
+
+#endif /* _TIFF_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffio.h.svn-base ./libs/libtiff/.svn/text-base/tiffio.h.svn-base
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffio.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/text-base/tiffio.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,515 @@
+/* $Id: tiffio.h,v 1.50 2006/03/21 16:37:51 dron Exp $ */
+
+/*
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
+ *
+ * Permission to use, copy, modify, distribute, and sell this software and 
+ * its documentation for any purpose is hereby granted without fee, provided
+ * that (i) the above copyright notices and this permission notice appear in
+ * all copies of the software and related documentation, and (ii) the names of
+ * Sam Leffler and Silicon Graphics may not be used in any advertising or
+ * publicity relating to the software without the specific, prior written
+ * permission of Sam Leffler and Silicon Graphics.
+ * 
+ * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
+ * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
+ * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
+ * 
+ * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
+ * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
+ * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
+ * OF THIS SOFTWARE.
+ */
+
+#ifndef _TIFFIO_
+#define	_TIFFIO_
+
+/*
+ * TIFF I/O Library Definitions.
+ */
+#include "tiff.h"
+#include "tiffvers.h"
+
+/*
+ * TIFF is defined as an incomplete type to hide the
+ * library's internal data structures from clients.
+ */
+typedef	struct tiff TIFF;
+
+/*
+ * The following typedefs define the intrinsic size of
+ * data types used in the *exported* interfaces.  These
+ * definitions depend on the proper definition of types
+ * in tiff.h.  Note also that the varargs interface used
+ * to pass tag types and values uses the types defined in
+ * tiff.h directly.
+ *
+ * NB: ttag_t is unsigned int and not unsigned short because
+ *     ANSI C requires that the type before the ellipsis be a
+ *     promoted type (i.e. one of int, unsigned int, pointer,
+ *     or double) and because we defined pseudo-tags that are
+ *     outside the range of legal Aldus-assigned tags.
+ * NB: tsize_t is int32 and not uint32 because some functions
+ *     return -1.
+ * NB: toff_t is not off_t for many reasons; TIFFs max out at
+ *     32-bit file offsets being the most important, and to ensure
+ *     that it is unsigned, rather than signed.
+ */
+typedef	uint32 ttag_t;		/* directory tag */
+typedef	uint16 tdir_t;		/* directory index */
+typedef	uint16 tsample_t;	/* sample number */
+typedef	uint32 tstrip_t;	/* strip number */
+typedef uint32 ttile_t;		/* tile number */
+typedef	int32 tsize_t;		/* i/o size in bytes */
+typedef	void* tdata_t;		/* image data ref */
+typedef	uint32 toff_t;		/* file offset */
+
+#if !defined(__WIN32__) && (defined(_WIN32) || defined(WIN32))
+#define __WIN32__
+#endif
+
+/*
+ * On windows you should define USE_WIN32_FILEIO if you are using tif_win32.c
+ * or AVOID_WIN32_FILEIO if you are using something else (like tif_unix.c).
+ *
+ * By default tif_unix.c is assumed.
+ */
+
+#if defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
+#  if !defined(__CYGWIN) && !defined(AVOID_WIN32_FILEIO) && !defined(USE_WIN32_FILEIO)
+#    define AVOID_WIN32_FILEIO
+#  endif
+#endif
+
+#if defined(USE_WIN32_FILEIO)
+# define VC_EXTRALEAN
+# include <windows.h>
+# ifdef __WIN32__
+DECLARE_HANDLE(thandle_t);	/* Win32 file handle */
+# else
+typedef	HFILE thandle_t;	/* client data handle */
+# endif /* __WIN32__ */
+#else
+typedef	void* thandle_t;	/* client data handle */
+#endif /* USE_WIN32_FILEIO */
+
+#ifndef NULL
+# define NULL	(void *)0
+#endif
+
+/*
+ * Flags to pass to TIFFPrintDirectory to control
+ * printing of data structures that are potentially
+ * very large.   Bit-or these flags to enable printing
+ * multiple items.
+ */
+#define	TIFFPRINT_NONE		0x0		/* no extra info */
+#define	TIFFPRINT_STRIPS	0x1		/* strips/tiles info */
+#define	TIFFPRINT_CURVES	0x2		/* color/gray response curves */
+#define	TIFFPRINT_COLORMAP	0x4		/* colormap */
+#define	TIFFPRINT_JPEGQTABLES	0x100		/* JPEG Q matrices */
+#define	TIFFPRINT_JPEGACTABLES	0x200		/* JPEG AC tables */
+#define	TIFFPRINT_JPEGDCTABLES	0x200		/* JPEG DC tables */
+
+/* 
+ * Colour conversion stuff
+ */
+
+/* reference white */
+#define D65_X0 (95.0470F)
+#define D65_Y0 (100.0F)
+#define D65_Z0 (108.8827F)
+
+#define D50_X0 (96.4250F)
+#define D50_Y0 (100.0F)
+#define D50_Z0 (82.4680F)
+
+/* Structure for holding information about a display device. */
+
+typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
+
+typedef struct {
+	float d_mat[3][3]; 		/* XYZ -> luminance matrix */
+	float d_YCR;			/* Light o/p for reference white */
+	float d_YCG;
+	float d_YCB;
+	uint32 d_Vrwr;			/* Pixel values for ref. white */
+	uint32 d_Vrwg;
+	uint32 d_Vrwb;
+	float d_Y0R;			/* Residual light for black pixel */
+	float d_Y0G;
+	float d_Y0B;
+	float d_gammaR;			/* Gamma values for the three guns */
+	float d_gammaG;
+	float d_gammaB;
+} TIFFDisplay;
+
+typedef struct {				/* YCbCr->RGB support */
+	TIFFRGBValue* clamptab;			/* range clamping table */
+	int*	Cr_r_tab;
+	int*	Cb_b_tab;
+	int32*	Cr_g_tab;
+	int32*	Cb_g_tab;
+        int32*  Y_tab;
+} TIFFYCbCrToRGB;
+
+typedef struct {				/* CIE Lab 1976->RGB support */
+	int	range;				/* Size of conversion table */
+#define CIELABTORGB_TABLE_RANGE 1500
+	float	rstep, gstep, bstep;
+	float	X0, Y0, Z0;			/* Reference white point */
+	TIFFDisplay display;
+	float	Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */
+	float	Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */
+	float	Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */
+} TIFFCIELabToRGB;
+
+/*
+ * RGBA-style image support.
+ */
+typedef struct _TIFFRGBAImage TIFFRGBAImage;
+/*
+ * The image reading and conversion routines invoke
+ * ``put routines'' to copy/image/whatever tiles of
+ * raw image data.  A default set of routines are 
+ * provided to convert/copy raw image data to 8-bit
+ * packed ABGR format rasters.  Applications can supply
+ * alternate routines that unpack the data into a
+ * different format or, for example, unpack the data
+ * and draw the unpacked raster on the display.
+ */
+typedef void (*tileContigRoutine)
+    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
+	unsigned char*);
+typedef void (*tileSeparateRoutine)
+    (TIFFRGBAImage*, uint32*, uint32, uint32, uint32, uint32, int32, int32,
+	unsigned char*, unsigned char*, unsigned char*, unsigned char*);
+/*
+ * RGBA-reader state.
+ */
+struct _TIFFRGBAImage {
+	TIFF*	tif;				/* image handle */
+	int	stoponerr;			/* stop on read error */
+	int	isContig;			/* data is packed/separate */
+	int	alpha;				/* type of alpha data present */
+	uint32	width;				/* image width */
+	uint32	height;				/* image height */
+	uint16	bitspersample;			/* image bits/sample */
+	uint16	samplesperpixel;		/* image samples/pixel */
+	uint16	orientation;			/* image orientation */
+	uint16	req_orientation;		/* requested orientation */
+	uint16	photometric;			/* image photometric interp */
+	uint16*	redcmap;			/* colormap pallete */
+	uint16*	greencmap;
+	uint16*	bluecmap;
+						/* get image data routine */
+	int	(*get)(TIFFRGBAImage*, uint32*, uint32, uint32);
+	union {
+	    void (*any)(TIFFRGBAImage*);
+	    tileContigRoutine	contig;
+	    tileSeparateRoutine	separate;
+	} put;					/* put decoded strip/tile */
+	TIFFRGBValue* Map;			/* sample mapping array */
+	uint32** BWmap;				/* black&white map */
+	uint32** PALmap;			/* palette image map */
+	TIFFYCbCrToRGB* ycbcr;			/* YCbCr conversion state */
+        TIFFCIELabToRGB* cielab;		/* CIE L*a*b conversion state */
+
+        int	row_offset;
+        int     col_offset;
+};
+
+/*
+ * Macros for extracting components from the
+ * packed ABGR form returned by TIFFReadRGBAImage.
+ */
+#define	TIFFGetR(abgr)	((abgr) & 0xff)
+#define	TIFFGetG(abgr)	(((abgr) >> 8) & 0xff)
+#define	TIFFGetB(abgr)	(((abgr) >> 16) & 0xff)
+#define	TIFFGetA(abgr)	(((abgr) >> 24) & 0xff)
+
+/*
+ * A CODEC is a software package that implements decoding,
+ * encoding, or decoding+encoding of a compression algorithm.
+ * The library provides a collection of builtin codecs.
+ * More codecs may be registered through calls to the library
+ * and/or the builtin implementations may be overridden.
+ */
+typedef	int (*TIFFInitMethod)(TIFF*, int);
+typedef struct {
+	char*		name;
+	uint16		scheme;
+	TIFFInitMethod	init;
+} TIFFCodec;
+
+#include <stdio.h>
+#include <stdarg.h>
+
+/* share internal LogLuv conversion routines? */
+#ifndef LOGLUV_PUBLIC
+#define LOGLUV_PUBLIC		1
+#endif
+
+#if defined(c_plusplus) || defined(__cplusplus)
+extern "C" {
+#endif
+typedef	void (*TIFFErrorHandler)(const char*, const char*, va_list);
+typedef	void (*TIFFErrorHandlerExt)(thandle_t, const char*, const char*, va_list);
+typedef	tsize_t (*TIFFReadWriteProc)(thandle_t, tdata_t, tsize_t);
+typedef	toff_t (*TIFFSeekProc)(thandle_t, toff_t, int);
+typedef	int (*TIFFCloseProc)(thandle_t);
+typedef	toff_t (*TIFFSizeProc)(thandle_t);
+typedef	int (*TIFFMapFileProc)(thandle_t, tdata_t*, toff_t*);
+typedef	void (*TIFFUnmapFileProc)(thandle_t, tdata_t, toff_t);
+typedef	void (*TIFFExtendProc)(TIFF*); 
+
+extern	const char* TIFFGetVersion(void);
+
+extern	const TIFFCodec* TIFFFindCODEC(uint16);
+extern	TIFFCodec* TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod);
+extern	void TIFFUnRegisterCODEC(TIFFCodec*);
+extern  int TIFFIsCODECConfigured(uint16);
+extern	TIFFCodec* TIFFGetConfiguredCODECs(void);
+
+/*
+ * Auxiliary functions.
+ */
+
+extern	tdata_t _TIFFmalloc(tsize_t);
+extern	tdata_t _TIFFrealloc(tdata_t, tsize_t);
+extern	void _TIFFmemset(tdata_t, int, tsize_t);
+extern	void _TIFFmemcpy(tdata_t, const tdata_t, tsize_t);
+extern	int _TIFFmemcmp(const tdata_t, const tdata_t, tsize_t);
+extern	void _TIFFfree(tdata_t);
+
+/*
+** Stuff, related to tag handling and creating custom tags.
+*/
+extern  int  TIFFGetTagListCount( TIFF * );
+extern  ttag_t TIFFGetTagListEntry( TIFF *, int tag_index );
+    
+#define	TIFF_ANY	TIFF_NOTYPE	/* for field descriptor searching */
+#define	TIFF_VARIABLE	-1		/* marker for variable length tags */
+#define	TIFF_SPP	-2		/* marker for SamplesPerPixel tags */
+#define	TIFF_VARIABLE2	-3		/* marker for uint32 var-length tags */
+
+#define FIELD_CUSTOM    65    
+
+typedef	struct {
+	ttag_t	field_tag;		/* field's tag */
+	short	field_readcount;	/* read count/TIFF_VARIABLE/TIFF_SPP */
+	short	field_writecount;	/* write count/TIFF_VARIABLE */
+	TIFFDataType field_type;	/* type of associated data */
+        unsigned short field_bit;	/* bit in fieldsset bit vector */
+	unsigned char field_oktochange;	/* if true, can change while writing */
+	unsigned char field_passcount;	/* if true, pass dir count on set */
+	char	*field_name;		/* ASCII name */
+} TIFFFieldInfo;
+
+typedef struct _TIFFTagValue {
+    const TIFFFieldInfo  *info;
+    int             count;
+    void           *value;
+} TIFFTagValue;
+
+extern	void TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], int);
+extern	const TIFFFieldInfo* TIFFFindFieldInfo(TIFF*, ttag_t, TIFFDataType);
+extern  const TIFFFieldInfo* TIFFFindFieldInfoByName(TIFF* , const char *,
+						     TIFFDataType);
+extern	const TIFFFieldInfo* TIFFFieldWithTag(TIFF*, ttag_t);
+extern	const TIFFFieldInfo* TIFFFieldWithName(TIFF*, const char *);
+
+typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
+typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
+typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
+    
+typedef struct {
+    TIFFVSetMethod	vsetfield;	/* tag set routine */
+    TIFFVGetMethod	vgetfield;	/* tag get routine */
+    TIFFPrintMethod	printdir;	/* directory print routine */
+} TIFFTagMethods;
+        
+extern  TIFFTagMethods *TIFFAccessTagMethods( TIFF * );
+extern  void *TIFFGetClientInfo( TIFF *, const char * );
+extern  void TIFFSetClientInfo( TIFF *, void *, const char * );
+
+extern	void TIFFCleanup(TIFF*);
+extern	void TIFFClose(TIFF*);
+extern	int TIFFFlush(TIFF*);
+extern	int TIFFFlushData(TIFF*);
+extern	int TIFFGetField(TIFF*, ttag_t, ...);
+extern	int TIFFVGetField(TIFF*, ttag_t, va_list);
+extern	int TIFFGetFieldDefaulted(TIFF*, ttag_t, ...);
+extern	int TIFFVGetFieldDefaulted(TIFF*, ttag_t, va_list);
+extern	int TIFFReadDirectory(TIFF*);
+extern	int TIFFReadCustomDirectory(TIFF*, toff_t, const TIFFFieldInfo[],
+				    size_t);
+extern	int TIFFReadEXIFDirectory(TIFF*, toff_t);
+extern	tsize_t TIFFScanlineSize(TIFF*);
+extern	tsize_t TIFFRasterScanlineSize(TIFF*);
+extern	tsize_t TIFFStripSize(TIFF*);
+extern	tsize_t TIFFRawStripSize(TIFF*, tstrip_t);
+extern	tsize_t TIFFVStripSize(TIFF*, uint32);
+extern	tsize_t TIFFTileRowSize(TIFF*);
+extern	tsize_t TIFFTileSize(TIFF*);
+extern	tsize_t TIFFVTileSize(TIFF*, uint32);
+extern	uint32 TIFFDefaultStripSize(TIFF*, uint32);
+extern	void TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
+extern	int TIFFFileno(TIFF*);
+extern  int TIFFSetFileno(TIFF*, int);
+extern  thandle_t TIFFClientdata(TIFF*);
+extern  thandle_t TIFFSetClientdata(TIFF*, thandle_t);
+extern	int TIFFGetMode(TIFF*);
+extern	int TIFFSetMode(TIFF*, int);
+extern	int TIFFIsTiled(TIFF*);
+extern	int TIFFIsByteSwapped(TIFF*);
+extern	int TIFFIsUpSampled(TIFF*);
+extern	int TIFFIsMSB2LSB(TIFF*);
+extern	int TIFFIsBigEndian(TIFF*);
+extern	TIFFReadWriteProc TIFFGetReadProc(TIFF*);
+extern	TIFFReadWriteProc TIFFGetWriteProc(TIFF*);
+extern	TIFFSeekProc TIFFGetSeekProc(TIFF*);
+extern	TIFFCloseProc TIFFGetCloseProc(TIFF*);
+extern	TIFFSizeProc TIFFGetSizeProc(TIFF*);
+extern	TIFFMapFileProc TIFFGetMapFileProc(TIFF*);
+extern	TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF*);
+extern	uint32 TIFFCurrentRow(TIFF*);
+extern	tdir_t TIFFCurrentDirectory(TIFF*);
+extern	tdir_t TIFFNumberOfDirectories(TIFF*);
+extern	uint32 TIFFCurrentDirOffset(TIFF*);
+extern	tstrip_t TIFFCurrentStrip(TIFF*);
+extern	ttile_t TIFFCurrentTile(TIFF*);
+extern	int TIFFReadBufferSetup(TIFF*, tdata_t, tsize_t);
+extern	int TIFFWriteBufferSetup(TIFF*, tdata_t, tsize_t);
+extern	int TIFFSetupStrips(TIFF *);
+extern  int TIFFWriteCheck(TIFF*, int, const char *);
+extern	void TIFFFreeDirectory(TIFF*);
+extern  int TIFFCreateDirectory(TIFF*);
+extern	int TIFFLastDirectory(TIFF*);
+extern	int TIFFSetDirectory(TIFF*, tdir_t);
+extern	int TIFFSetSubDirectory(TIFF*, uint32);
+extern	int TIFFUnlinkDirectory(TIFF*, tdir_t);
+extern	int TIFFSetField(TIFF*, ttag_t, ...);
+extern	int TIFFVSetField(TIFF*, ttag_t, va_list);
+extern	int TIFFWriteDirectory(TIFF *);
+extern	int TIFFCheckpointDirectory(TIFF *);
+extern	int TIFFRewriteDirectory(TIFF *);
+extern	int TIFFReassignTagToIgnore(enum TIFFIgnoreSense, int);
+
+#if defined(c_plusplus) || defined(__cplusplus)
+extern	void TIFFPrintDirectory(TIFF*, FILE*, long = 0);
+extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
+extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
+extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,
+				      int = ORIENTATION_BOTLEFT, int = 0);
+#else
+extern	void TIFFPrintDirectory(TIFF*, FILE*, long);
+extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t);
+extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t);
+extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int);
+#endif
+
+extern	int TIFFReadRGBAStrip(TIFF*, tstrip_t, uint32 * );
+extern	int TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * );
+extern	int TIFFRGBAImageOK(TIFF*, char [1024]);
+extern	int TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024]);
+extern	int TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32);
+extern	void TIFFRGBAImageEnd(TIFFRGBAImage*);
+extern	TIFF* TIFFOpen(const char*, const char*);
+# ifdef __WIN32__
+extern	TIFF* TIFFOpenW(const wchar_t*, const char*);
+# endif /* __WIN32__ */
+extern	TIFF* TIFFFdOpen(int, const char*, const char*);
+extern	TIFF* TIFFClientOpen(const char*, const char*,
+	    thandle_t,
+	    TIFFReadWriteProc, TIFFReadWriteProc,
+	    TIFFSeekProc, TIFFCloseProc,
+	    TIFFSizeProc,
+	    TIFFMapFileProc, TIFFUnmapFileProc);
+extern	const char* TIFFFileName(TIFF*);
+extern	const char* TIFFSetFileName(TIFF*, const char *);
+extern	void TIFFError(const char*, const char*, ...);
+extern	void TIFFErrorExt(thandle_t, const char*, const char*, ...);
+extern	void TIFFWarning(const char*, const char*, ...);
+extern	void TIFFWarningExt(thandle_t, const char*, const char*, ...);
+extern	TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt);
+extern	TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt);
+extern	TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc);
+extern	ttile_t TIFFComputeTile(TIFF*, uint32, uint32, uint32, tsample_t);
+extern	int TIFFCheckTile(TIFF*, uint32, uint32, uint32, tsample_t);
+extern	ttile_t TIFFNumberOfTiles(TIFF*);
+extern	tsize_t TIFFReadTile(TIFF*,
+	    tdata_t, uint32, uint32, uint32, tsample_t);
+extern	tsize_t TIFFWriteTile(TIFF*,
+	    tdata_t, uint32, uint32, uint32, tsample_t);
+extern	tstrip_t TIFFComputeStrip(TIFF*, uint32, tsample_t);
+extern	tstrip_t TIFFNumberOfStrips(TIFF*);
+extern	tsize_t TIFFReadEncodedStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
+extern	tsize_t TIFFReadRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
+extern	tsize_t TIFFReadEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	tsize_t TIFFReadRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	tsize_t TIFFWriteEncodedStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
+extern	tsize_t TIFFWriteRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
+extern	tsize_t TIFFWriteEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	tsize_t TIFFWriteRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	int TIFFDataWidth(TIFFDataType);    /* table of tag datatype widths */
+extern	void TIFFSetWriteOffset(TIFF*, toff_t);
+extern	void TIFFSwabShort(uint16*);
+extern	void TIFFSwabLong(uint32*);
+extern	void TIFFSwabDouble(double*);
+extern	void TIFFSwabArrayOfShort(uint16*, unsigned long);
+extern	void TIFFSwabArrayOfTriples(uint8*, unsigned long);
+extern	void TIFFSwabArrayOfLong(uint32*, unsigned long);
+extern	void TIFFSwabArrayOfDouble(double*, unsigned long);
+extern	void TIFFReverseBits(unsigned char *, unsigned long);
+extern	const unsigned char* TIFFGetBitRevTable(int);
+
+#ifdef LOGLUV_PUBLIC
+#define U_NEU		0.210526316
+#define V_NEU		0.473684211
+#define UVSCALE		410.
+extern	double LogL16toY(int);
+extern	double LogL10toY(int);
+extern	void XYZtoRGB24(float*, uint8*);
+extern	int uv_decode(double*, double*, int);
+extern	void LogLuv24toXYZ(uint32, float*);
+extern	void LogLuv32toXYZ(uint32, float*);
+#if defined(c_plusplus) || defined(__cplusplus)
+extern	int LogL16fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int LogL10fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int uv_encode(double, double, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+#else
+extern	int LogL16fromY(double, int);
+extern	int LogL10fromY(double, int);
+extern	int uv_encode(double, double, int);
+extern	uint32 LogLuv24fromXYZ(float*, int);
+extern	uint32 LogLuv32fromXYZ(float*, int);
+#endif
+#endif /* LOGLUV_PUBLIC */
+    
+extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB*, TIFFDisplay *, float*);
+extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,
+			    float *, float *, float *);
+extern void TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,
+			 uint32 *, uint32 *, uint32 *);
+
+extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*);
+extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,
+			   uint32 *, uint32 *, uint32 *);
+
+#if defined(c_plusplus) || defined(__cplusplus)
+}
+#endif
+
+#endif /* _TIFFIO_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffvers.h.svn-base ./libs/libtiff/.svn/text-base/tiffvers.h.svn-base
--- /home/robin/sldeb/trunk/libs/libtiff/.svn/text-base/tiffvers.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/.svn/text-base/tiffvers.h.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+#define TIFFLIB_VERSION_STR "LIBTIFF, Version 3.8.2\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
+/*
+ * This define can be used in code that requires
+ * compilation-related definitions specific to a
+ * version or versions of the library.  Runtime
+ * version checking should be done based on the
+ * string returned by TIFFGetVersion.
+ */
+#define TIFFLIB_VERSION 20060323
diff -urN /home/robin/sldeb/trunk/libs/libtiff/Tiffcomp.h ./libs/libtiff/Tiffcomp.h
--- /home/robin/sldeb/trunk/libs/libtiff/Tiffcomp.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/Tiffcomp.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,214 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffcomp.h,v 1.49 1996/04/29 21:56:21 sam Rel $ */
-
-/*
- * Copyright (c) 1990-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _COMPAT_
-#define	_COMPAT_
-/*
- * This file contains a hodgepodge of definitions and
- * declarations that are needed to provide compatibility
- * between the native system and the base implementation
- * that the library assumes.
- *
- * NB: This file is a mess.
- */
-
-/*
- * Setup basic type definitions and function declaratations.
- */
-
-/*
- * Simplify Acorn RISC OS identifier (to avoid confusion with Acorn RISC iX
- * and with defunct Unix Risc OS)
- * No need to specify __arm - hey, Acorn might port the OS, no problem here!
- */
-#ifdef __acornriscos
-#undef __acornriscos
-#endif
-#if defined(__acorn) && defined(__riscos)
-#define __acornriscos
-#endif
-
-#if defined(__MWERKS__) || defined(THINK_C)
-#include <unix.h>
-#include <math.h>
-#endif
-
-#include <stdio.h>
-
-#if defined(__PPCC__) || defined(__SC__) || defined(__MRC__)
-#include <types.h>
-#elif !defined(__MWERKS__) && !defined(THINK_C) && !defined(__acornriscos) && !defined(applec)
-#include <sys/types.h>
-#endif
-
-#if defined(VMS)
-#include <file.h>
-#include <unixio.h>
-#elif !defined(__acornriscos)
-#include <fcntl.h>
-#endif
-
-/*
- * This maze of checks controls defines or not the
- * target system has BSD-style typdedefs declared in
- * an include file and/or whether or not to include
- * <unistd.h> to get the SEEK_* definitions.  Some
- * additional includes are also done to pull in the
- * appropriate definitions we're looking for.
- */
-#if defined(__MWERKS__) || defined(THINK_C) || defined(__PPCC__) || defined(__SC__) || defined(__MRC__)
-#include <stdlib.h>
-#define	BSDTYPES
-#define	HAVE_UNISTD_H	0
-#elif defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
-#define	BSDTYPES
-#elif defined(OS2_16) || defined(OS2_32)
-#define	BSDTYPES
-#elif defined(__acornriscos)
-#include <stdlib.h>
-#define	BSDTYPES
-#define	HAVE_UNISTD_H	0
-#elif defined(VMS)
-#define	HAVE_UNISTD_H	0
-#else
-#define	HAVE_UNISTD_H	1
-#endif
-
-/*
- * The library uses the ANSI C/POSIX SEEK_*
- * definitions that should be defined in unistd.h
- * (except on system where they are in stdio.h and
- * there is no unistd.h).
- */
-#if !defined(SEEK_SET) && HAVE_UNISTD_H
-#include <unistd.h>
-#endif
-
-/*
- * The library uses memset, memcpy, and memcmp.
- * ANSI C and System V define these in string.h.
- */
-#include <string.h>
-
-/*
- * The BSD typedefs are used throughout the library.
- * If your system doesn't have them in <sys/types.h>,
- * then define BSDTYPES in your Makefile.
- */
-#if defined(BSDTYPES)
-typedef	unsigned char u_char;
-typedef	unsigned short u_short;
-typedef	unsigned int u_int;
-typedef	unsigned long u_long;
-#endif
-
-/*
- * dblparam_t is the type that a double precision
- * floating point value will have on the parameter
- * stack (when coerced by the compiler).
- */
-/* Note: on MacPowerPC "extended" is undefined. So only use it for 68K-Macs */
-#if defined(__SC__) || defined(THINK_C)
-typedef extended dblparam_t;
-#else
-typedef double dblparam_t;
-#endif
-
-/*
- * If your compiler supports inline functions, then
- * set INLINE appropriately to get the known hotspots
- * in the library expanded inline.
- */
-#if defined(__GNUC__)
-#if defined(__STRICT_ANSI__)
-#define	INLINE	__inline__
-#else
-#define	INLINE	inline
-#endif
-#else /* !__GNUC__ */
-#define	INLINE
-#endif
-
-/*
- * GLOBALDATA is a macro that is used to define global variables
- * private to the library.  We use this indirection to hide
- * brain-damage in VAXC (and GCC) under VAX/VMS.  In these
- * environments the macro places the variable in a non-shareable
- * program section, which ought to be done by default (sigh!)
- *
- * Apparently DEC are aware of the problem as this behaviour is the
- * default under VMS on AXP.
- *
- * The GNU C variant is untested.
- */
-#if defined(VAX) && defined(VMS)
-#if defined(VAXC)
-#define GLOBALDATA(TYPE,NAME)	extern noshare TYPE NAME
-#endif
-#if defined(__GNUC__)
-#define GLOBALDATA(TYPE,NAME)	extern TYPE NAME \
-	asm("_$$PsectAttributes_NOSHR$$" #NAME)
-#endif
-#else	/* !VAX/VMS */
-#define GLOBALDATA(TYPE,NAME)	extern TYPE NAME
-#endif
-
-#if defined(__acornriscos)
-/*
- * osfcn.h is part of C++Lib on Acorn C/C++, and as such can't be used
- * on C alone. For that reason, the relevant functions are
- * implemented in tif_acorn.c, and the elements from the header
- * file are included here.
- */
-#if defined(__cplusplus)
-#include <osfcn.h>
-#else
-#define	O_RDONLY	0
-#define	O_WRONLY	1
-#define	O_RDWR		2
-#define	O_APPEND	8
-#define	O_CREAT		0x200
-#define	O_TRUNC		0x400
-typedef long off_t;
-extern int open(const char *name, int flags, int mode);
-extern int close(int fd);
-extern int write(int fd, const char *buf, int nbytes);
-extern int read(int fd, char *buf, int nbytes);
-extern off_t lseek(int fd, off_t offset, int whence);
-extern int creat(const char *path, int mode);
-#endif /* __cplusplus */
-#endif /* __acornriscos */
-
-/* Bit and byte order, the default is MSB to LSB */
-#ifdef VMS
-#undef HOST_FILLORDER
-#undef HOST_BIGENDIAN
-#define HOST_FILLORDER FILLORDER_LSB2MSB
-#define HOST_BIGENDIAN	0
-#endif
-
-
-#endif /* _COMPAT_ */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/tiffconf.h ./libs/libtiff/tiffconf.h
--- /home/robin/sldeb/trunk/libs/libtiff/tiffconf.h	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/tiffconf.h	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,101 @@
+/* libtiff/tiffconf.h.  Generated by configure.  */
+/*
+  Configuration defines for installed libtiff.
+  This file maintained for backward compatibility. Do not use definitions
+  from this file in your programs.
+*/
+
+#ifndef _TIFFCONF_
+#define _TIFFCONF_
+
+/* Define to 1 if the system has the type `int16'. */
+/* #undef HAVE_INT16 */
+
+/* Define to 1 if the system has the type `int32'. */
+/* #undef HAVE_INT32 */
+
+/* Define to 1 if the system has the type `int8'. */
+/* #undef HAVE_INT8 */
+
+/* The size of a `int', as computed by sizeof. */
+#define SIZEOF_INT 4
+
+/* The size of a `long', as computed by sizeof. */
+#define SIZEOF_LONG 4
+
+/* Compatibility stuff. */
+
+/* Define as 0 or 1 according to the floating point format suported by the
+   machine */
+#define HAVE_IEEEFP 1
+
+/* Set the native cpu bit order (FILLORDER_LSB2MSB or FILLORDER_MSB2LSB) */
+#define HOST_FILLORDER FILLORDER_LSB2MSB
+
+/* Native cpu byte order: 1 if big-endian (Motorola) or 0 if little-endian
+   (Intel) */
+#define HOST_BIGENDIAN 0
+
+/* Support CCITT Group 3 & 4 algorithms */
+#define CCITT_SUPPORT 1
+
+/* Support JPEG compression (requires IJG JPEG library) */
+#undef JPEG_SUPPORT 
+
+/* Support LogLuv high dynamic range encoding */
+#define LOGLUV_SUPPORT 1
+
+/* Support LZW algorithm */
+#define LZW_SUPPORT 1
+
+/* Support NeXT 2-bit RLE algorithm */
+#define NEXT_SUPPORT 1
+
+/* Support Old JPEG compresson (read contrib/ojpeg/README first! Compilation
+   fails with unpatched IJG JPEG library) */
+/* #undef OJPEG_SUPPORT */
+
+/* Support Macintosh PackBits algorithm */
+#define PACKBITS_SUPPORT 1
+
+/* Support Pixar log-format algorithm (requires Zlib) */
+#define PIXARLOG_SUPPORT 1
+
+/* Support ThunderScan 4-bit RLE algorithm */
+#define THUNDER_SUPPORT 1
+
+/* Support Deflate compression */
+#define ZIP_SUPPORT 1
+
+/* Support strip chopping (whether or not to convert single-strip uncompressed
+   images to mutiple strips of ~8Kb to reduce memory usage) */
+#define STRIPCHOP_DEFAULT TIFF_STRIPCHOP
+
+/* Enable SubIFD tag (330) support */
+#define SUBIFD_SUPPORT 1
+
+/* Treat extra sample as alpha (default enabled). The RGBA interface will
+   treat a fourth sample with no EXTRASAMPLE_ value as being ASSOCALPHA. Many
+   packages produce RGBA files but don't mark the alpha properly. */
+#define DEFAULT_EXTRASAMPLE_AS_ALPHA 1
+
+/* Pick up YCbCr subsampling info from the JPEG data stream to support files
+   lacking the tag (default enabled). */
+#define CHECK_JPEG_YCBCR_SUBSAMPLING 1
+
+/* Support MS MDI magic number files as TIFF */
+#define MDI_SUPPORT 1
+
+/*
+ * Feature support definitions.
+ * XXX: These macros are obsoleted. Don't use them in your apps!
+ * Macros stays here for backward compatibility and should be always defined.
+ */
+#define COLORIMETRY_SUPPORT
+#define YCBCR_SUPPORT
+#define CMYK_SUPPORT
+#define ICC_SUPPORT
+#define PHOTOSHOP_SUPPORT
+#define IPTC_SUPPORT
+
+#endif /* _TIFFCONF_ */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/Tiffconf.h ./libs/libtiff/Tiffconf.h
--- /home/robin/sldeb/trunk/libs/libtiff/Tiffconf.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/Tiffconf.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,131 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffconf.h,v 1.13 1996/04/05 17:36:53 sam Rel $ */
-/*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFCONF_
-#define	_TIFFCONF_
-/*
- * Library Configuration Definitions.
- *
- * This file defines the default configuration for the library.
- * If the target system does not have make or a way to specify
- * #defines on the command line, this file can be edited to
- * configure the library.  Otherwise, one can override portability
- * and configuration-related definitions from a Makefile or command
- * line by defining FEATURE_SUPPORT and COMPRESSION_SUPPORT (see below).
- */
-
-/*
- * General portability-related defines:
- *
- * HAVE_IEEEFP		define as 0 or 1 according to the floating point
- *			format suported by the machine
- * BSDTYPES		define this if your system does NOT define the
- *			usual 4BSD typedefs u_int et. al.
- * HAVE_MMAP		enable support for memory mapping read-only files;
- *			this is typically deduced by the configure script
- * HOST_FILLORDER	native cpu bit order: one of FILLORDER_MSB2LSB
- *			or FILLODER_LSB2MSB; this is typically set by the
- *			configure script
- * HOST_BIGENDIAN	native cpu byte order: 1 if big-endian (Motorola)
- *			or 0 if little-endian (Intel); this may be used
- *			in codecs to optimize code
- */
-#ifndef HAVE_IEEEFP
-#define	HAVE_IEEEFP	1
-#endif
-#ifndef HOST_FILLORDER
-#define	HOST_FILLORDER	FILLORDER_MSB2LSB
-#endif
-#ifndef	HOST_BIGENDIAN
-#define	HOST_BIGENDIAN	1
-#endif
-
-#ifndef FEATURE_SUPPORT
-/*
- * Feature support definitions:
- *
- *    COLORIMETRY_SUPPORT enable support for 6.0 colorimetry tags
- *    YCBCR_SUPPORT	enable support for 6.0 YCbCr tags
- *    CMYK_SUPPORT	enable support for 6.0 CMYK tags
- */
-#define	COLORIMETRY_SUPPORT
-#define	YCBCR_SUPPORT
-#define	CMYK_SUPPORT
-#endif /* FEATURE_SUPPORT */
-
-#ifndef COMPRESSION_SUPPORT
-/*
- * Compression support defines:
- *
- *    CCITT_SUPPORT	enable support for CCITT Group 3 & 4 algorithms
- *    PACKBITS_SUPPORT	enable support for Macintosh PackBits algorithm
- *    LZW_SUPPORT	enable support for LZW algorithm
- *    THUNDER_SUPPORT	enable support for ThunderScan 4-bit RLE algorithm
- *    NEXT_SUPPORT	enable support for NeXT 2-bit RLE algorithm
- *    OJPEG_SUPPORT	enable support for 6.0-style JPEG DCT algorithms
- *			(no builtin support, only a codec hook)
- *    JPEG_SUPPORT	enable support for post-6.0-style JPEG DCT algorithms
- *			(requires freely available IJG software, see tif_jpeg.c)
- *    ZIP_SUPPORT	enable support for Deflate algorithm
- *			(requires freely available zlib software, see tif_zip.c)
- *    PIXARLOG_SUPPORT	enable support for Pixar log-format algorithm
- */
-/* doesn't work with Windows makefile??? */
-#if 0
-#define	CCITT_SUPPORT
-#endif
-#define	PACKBITS_SUPPORT
-#define	LZW_SUPPORT
-#define	THUNDER_SUPPORT
-#define	NEXT_SUPPORT
-#endif /* COMPRESSION_SUPPORT */
-
-/*
- * If JPEG compression is enabled then we must also include
- * support for the colorimetry and YCbCr-related tags.
- */
-#ifdef JPEG_SUPPORT
-#ifndef YCBCR_SUPPORT
-#define	YCBCR_SUPPORT
-#endif
-#ifndef COLORIMETRY_SUPPORT
-#define	COLORIMETRY_SUPPORT
-#endif
-#endif /* JPEG_SUPPORT */
-
-/*
- * ``Orthogonal Features''
- *
- * STRIPCHOP_SUPPORT	automatically convert single-strip uncompressed images
- *			to mutiple strips of ~8Kb (for reducing memory use)
- * SUBIFD_SUPPORT	enable support for SubIFD tag (thumbnails and such)
- */
-#ifndef STRIPCHOP_SUPPORT
-#define	STRIPCHOP_SUPPORT	1	/* enable strip chopping */
-#endif
-#ifndef SUBIFD_SUPPORT
-#define	SUBIFD_SUPPORT		1	/* enable SubIFD tag (330) support */
-#endif
-#endif /* _TIFFCONF_ */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/tiff.h ./libs/libtiff/tiff.h
--- /home/robin/sldeb/trunk/libs/libtiff/tiff.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/tiff.h	2007-09-28 11:33:43.000000000 +0100
@@ -1,8 +1,8 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiff.h,v 1.71 1996/04/29 22:16:05 sam Rel $ */
+/* $Id: tiff.h,v 1.42 2005/12/23 15:10:45 dron Exp $ */
 
 /*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and 
  * its documentation for any purpose is hereby granted without fee, provided
@@ -26,6 +26,9 @@
 
 #ifndef _TIFF_
 #define	_TIFF_
+
+#include "tiffconf.h"
+
 /*
  * Tag Image File Format (TIFF)
  *
@@ -36,14 +39,19 @@
  *    Suite 200
  *    Seattle, WA  98104
  *    206-622-5500
+ *    
+ *    (http://partners.adobe.com/asn/developer/PDFS/TN/TIFF6.pdf)
+ *
+ * For Big TIFF design notes see the following link
+ *    http://gdal.maptools.org/twiki/bin/view/libtiff/BigTIFFDesign
  */
-#define	TIFF_VERSION	42
+#define	TIFF_VERSION	        42
+#define TIFF_BIGTIFF_VERSION    43
 
 #define	TIFF_BIGENDIAN		0x4d4d
 #define	TIFF_LITTLEENDIAN	0x4949
-
-#ifndef _TIFF_DATA_TYPEDEFS_
-#define _TIFF_DATA_TYPEDEFS_
+#define	MDI_LITTLEENDIAN        0x5045
+#define	MDI_BIGENDIAN           0x4550
 /*
  * Intrinsic data types required by the file format:
  *
@@ -52,47 +60,64 @@
  * 32-bit quantities	int32/uint32
  * strings		unsigned char*
  */
-#ifdef __STDC__
+
+#ifndef HAVE_INT8
 typedef	signed char int8;	/* NB: non-ANSI compilers may not grok */
-#else
-typedef	char int8;
 #endif
 typedef	unsigned char uint8;
+#ifndef HAVE_INT16
 typedef	short int16;
+#endif
 typedef	unsigned short uint16;	/* sizeof (uint16) must == 2 */
-#if defined(__alpha) || (defined(_MIPS_SZLONG) && _MIPS_SZLONG == 64)
+#if SIZEOF_INT == 4
+#ifndef HAVE_INT32
 typedef	int int32;
+#endif
 typedef	unsigned int uint32;	/* sizeof (uint32) must == 4 */
-#else
+#elif SIZEOF_LONG == 4
+#ifndef HAVE_INT32
 typedef	long int32;
+#endif
 typedef	unsigned long uint32;	/* sizeof (uint32) must == 4 */
 #endif
-#endif /* _TIFF_DATA_TYPEDEFS_ */
 
+/* For TIFFReassignTagToIgnore */
+enum TIFFIgnoreSense /* IGNORE tag table */
+{
+	TIS_STORE,
+	TIS_EXTRACT,
+	TIS_EMPTY
+};
+
+/*
+ * TIFF header.
+ */
 typedef	struct {
 	uint16	tiff_magic;	/* magic number (defines byte order) */
+#define TIFF_MAGIC_SIZE		2
 	uint16	tiff_version;	/* TIFF version number */
+#define TIFF_VERSION_SIZE	2
 	uint32	tiff_diroff;	/* byte offset to first directory */
+#define TIFF_DIROFFSET_SIZE	4
 } TIFFHeader;
 
+
 /*
- * TIFF Image File Directories are comprised of
- * a table of field descriptors of the form shown
- * below.  The table is sorted in ascending order
- * by tag.  The values associated with each entry
- * are disjoint and may appear anywhere in the file
- * (so long as they are placed on a word boundary).
+ * TIFF Image File Directories are comprised of a table of field
+ * descriptors of the form shown below.  The table is sorted in
+ * ascending order by tag.  The values associated with each entry are
+ * disjoint and may appear anywhere in the file (so long as they are
+ * placed on a word boundary).
  *
- * If the value is 4 bytes or less, then it is placed
- * in the offset field to save space.  If the value
- * is less than 4 bytes, it is left-justified in the
- * offset field.
+ * If the value is 4 bytes or less, then it is placed in the offset
+ * field to save space.  If the value is less than 4 bytes, it is
+ * left-justified in the offset field.
  */
 typedef	struct {
-	uint16	tdir_tag;	/* see below */
-	uint16	tdir_type;	/* data type; see below */
-	uint32  tdir_count;	/* number of items; length in spec */
-	uint32  tdir_offset;	/* byte offset to field data */
+	uint16		tdir_tag;	/* see below */
+	uint16		tdir_type;	/* data type; see below */
+	uint32		tdir_count;	/* number of items; length in spec */
+	uint32		tdir_offset;	/* byte offset to field data */
 } TIFFDirEntry;
 
 /*
@@ -101,6 +126,7 @@
  *  - items marked with a ! are introduced in revision 6.0.
  *  - items marked with a % are introduced post revision 6.0.
  *  - items marked with a $ are obsoleted by revision 6.0.
+ *  - items marked with a & are introduced by Adobe DNG specification.
  */
 
 /*
@@ -121,7 +147,8 @@
 	TIFF_SLONG	= 9,	/* !32-bit signed integer */
 	TIFF_SRATIONAL	= 10,	/* !64-bit signed fraction */
 	TIFF_FLOAT	= 11,	/* !32-bit IEEE floating point */
-	TIFF_DOUBLE	= 12	/* !64-bit IEEE floating point */
+	TIFF_DOUBLE	= 12,	/* !64-bit IEEE floating point */
+	TIFF_IFD	= 13	/* %32-bit unsigned integer (offset) */
 } TIFFDataType;
 
 /*
@@ -142,21 +169,33 @@
 #define	    COMPRESSION_NONE		1	/* dump mode */
 #define	    COMPRESSION_CCITTRLE	2	/* CCITT modified Huffman RLE */
 #define	    COMPRESSION_CCITTFAX3	3	/* CCITT Group 3 fax encoding */
+#define     COMPRESSION_CCITT_T4        3       /* CCITT T.4 (TIFF 6 name) */
 #define	    COMPRESSION_CCITTFAX4	4	/* CCITT Group 4 fax encoding */
-#define	    COMPRESSION_LZW		5	/* Lempel-Ziv  & Welch */
+#define     COMPRESSION_CCITT_T6        4       /* CCITT T.6 (TIFF 6 name) */
+#define	    COMPRESSION_LZW		5       /* Lempel-Ziv  & Welch */
 #define	    COMPRESSION_OJPEG		6	/* !6.0 JPEG */
 #define	    COMPRESSION_JPEG		7	/* %JPEG DCT compression */
 #define	    COMPRESSION_NEXT		32766	/* NeXT 2-bit RLE */
 #define	    COMPRESSION_CCITTRLEW	32771	/* #1 w/ word alignment */
 #define	    COMPRESSION_PACKBITS	32773	/* Macintosh RLE */
 #define	    COMPRESSION_THUNDERSCAN	32809	/* ThunderScan RLE */
+/* codes 32895-32898 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define	    COMPRESSION_IT8CTPAD	32895   /* IT8 CT w/padding */
+#define	    COMPRESSION_IT8LW		32896   /* IT8 Linework RLE */
+#define	    COMPRESSION_IT8MP		32897   /* IT8 Monochrome picture */
+#define	    COMPRESSION_IT8BL		32898   /* IT8 Binary line art */
 /* compression codes 32908-32911 are reserved for Pixar */
 #define     COMPRESSION_PIXARFILM	32908   /* Pixar companded 10bit LZW */
 #define	    COMPRESSION_PIXARLOG	32909   /* Pixar companded 11bit ZIP */
 #define	    COMPRESSION_DEFLATE		32946	/* Deflate compression */
+#define     COMPRESSION_ADOBE_DEFLATE   8       /* Deflate compression,
+						   as recognized by Adobe */
 /* compression code 32947 is reserved for Oceana Matrix <dev@oceana.com> */
 #define     COMPRESSION_DCS             32947   /* Kodak DCS encoding */
 #define	    COMPRESSION_JBIG		34661	/* ISO JBIG */
+#define     COMPRESSION_SGILOG		34676	/* SGI Log Luminance RLE */
+#define     COMPRESSION_SGILOG24	34677	/* SGI Log 24-bit packed */
+#define     COMPRESSION_JP2000          34712   /* Leadtools JPEG2000 */
 #define	TIFFTAG_PHOTOMETRIC		262	/* photometric interpretation */
 #define	    PHOTOMETRIC_MINISWHITE	0	/* min value is white */
 #define	    PHOTOMETRIC_MINISBLACK	1	/* min value is black */
@@ -166,6 +205,10 @@
 #define	    PHOTOMETRIC_SEPARATED	5	/* !color separations */
 #define	    PHOTOMETRIC_YCBCR		6	/* !CCIR 601 */
 #define	    PHOTOMETRIC_CIELAB		8	/* !1976 CIE L*a*b* */
+#define	    PHOTOMETRIC_ICCLAB		9	/* ICC L*a*b* [Adobe TIFF Technote 4] */
+#define	    PHOTOMETRIC_ITULAB		10	/* ITU L*a*b* */
+#define     PHOTOMETRIC_LOGL		32844	/* CIE Log2(L) */
+#define     PHOTOMETRIC_LOGLUV		32845	/* CIE Log2(L) (u',v') */
 #define	TIFFTAG_THRESHHOLDING		263	/* +thresholding used on data */
 #define	    THRESHHOLD_BILEVEL		1	/* b&w art scan */
 #define	    THRESHHOLD_HALFTONE		2	/* or dithered scan */
@@ -212,10 +255,12 @@
 #define	    GRAYRESPONSEUNIT_100000S	5	/* hundred-thousandths */
 #define	TIFFTAG_GRAYRESPONSECURVE	291	/* $gray scale response curve */
 #define	TIFFTAG_GROUP3OPTIONS		292	/* 32 flag bits */
+#define	TIFFTAG_T4OPTIONS		292	/* TIFF 6.0 proper name alias */
 #define	    GROUP3OPT_2DENCODING	0x1	/* 2-dimensional coding */
 #define	    GROUP3OPT_UNCOMPRESSED	0x2	/* data not compressed */
 #define	    GROUP3OPT_FILLBITS		0x4	/* fill to byte boundary */
 #define	TIFFTAG_GROUP4OPTIONS		293	/* 32 flag bits */
+#define TIFFTAG_T6OPTIONS               293     /* TIFF 6.0 proper name */
 #define	    GROUP4OPT_UNCOMPRESSED	0x2	/* data not compressed */
 #define	TIFFTAG_RESOLUTIONUNIT		296	/* units of resolutions */
 #define	    RESUNIT_NONE		1	/* no meaningful units */
@@ -234,12 +279,15 @@
 #define	TIFFTAG_ARTIST			315	/* creator of image */
 #define	TIFFTAG_HOSTCOMPUTER		316	/* machine where created */
 #define	TIFFTAG_PREDICTOR		317	/* prediction scheme w/ LZW */
+#define     PREDICTOR_NONE		1	/* no prediction scheme used */
+#define     PREDICTOR_HORIZONTAL	2	/* horizontal differencing */
+#define     PREDICTOR_FLOATINGPOINT	3	/* floating point predictor */
 #define	TIFFTAG_WHITEPOINT		318	/* image white point */
 #define	TIFFTAG_PRIMARYCHROMATICITIES	319	/* !primary chromaticities */
 #define	TIFFTAG_COLORMAP		320	/* RGB map for pallette image */
 #define	TIFFTAG_HALFTONEHINTS		321	/* !highlight+shadow info */
-#define	TIFFTAG_TILEWIDTH		322	/* !rows/data tile */
-#define	TIFFTAG_TILELENGTH		323	/* !cols/data tile */
+#define	TIFFTAG_TILEWIDTH		322	/* !tile width in pixels */
+#define	TIFFTAG_TILELENGTH		323	/* !tile height in pixels */
 #define TIFFTAG_TILEOFFSETS		324	/* !offsets to data tiles */
 #define TIFFTAG_TILEBYTECOUNTS		325	/* !byte counts for tiles */
 #define	TIFFTAG_BADFAXLINES		326	/* lines w/ wrong pixel count */
@@ -250,8 +298,10 @@
 #define	TIFFTAG_CONSECUTIVEBADFAXLINES	328	/* max consecutive bad lines */
 #define	TIFFTAG_SUBIFD			330	/* subimage descriptors */
 #define	TIFFTAG_INKSET			332	/* !inks in separated image */
-#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black */
+#define	    INKSET_CMYK			1	/* !cyan-magenta-yellow-black color */
+#define	    INKSET_MULTIINK		2	/* !multi-ink or hi-fi color */
 #define	TIFFTAG_INKNAMES		333	/* !ascii names of inks */
+#define	TIFFTAG_NUMBEROFINKS		334	/* !number of inks */
 #define	TIFFTAG_DOTRANGE		336	/* !0% and 100% dot codes */
 #define	TIFFTAG_TARGETPRINTER		337	/* !separation target */
 #define	TIFFTAG_EXTRASAMPLES		338	/* !info about extra samples */
@@ -263,12 +313,23 @@
 #define	    SAMPLEFORMAT_INT		2	/* !signed integer data */
 #define	    SAMPLEFORMAT_IEEEFP		3	/* !IEEE floating point data */
 #define	    SAMPLEFORMAT_VOID		4	/* !untyped data */
+#define	    SAMPLEFORMAT_COMPLEXINT	5	/* !complex signed int */
+#define	    SAMPLEFORMAT_COMPLEXIEEEFP	6	/* !complex ieee floating */
 #define	TIFFTAG_SMINSAMPLEVALUE		340	/* !variable MinSampleValue */
 #define	TIFFTAG_SMAXSAMPLEVALUE		341	/* !variable MaxSampleValue */
+#define	TIFFTAG_CLIPPATH		343	/* %ClipPath
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_XCLIPPATHUNITS		344	/* %XClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_YCLIPPATHUNITS		345	/* %YClipPathUnits
+						   [Adobe TIFF technote 2] */
+#define	TIFFTAG_INDEXED			346	/* %Indexed
+						   [Adobe TIFF Technote 3] */
 #define	TIFFTAG_JPEGTABLES		347	/* %JPEG table stream */
+#define	TIFFTAG_OPIPROXY		351	/* %OPI Proxy [Adobe TIFF technote] */
 /*
- * Tags 512-521 are obsoleted by Technical Note #2
- * which specifies a revised JPEG-in-TIFF scheme.
+ * Tags 512-521 are obsoleted by Technical Note #2 which specifies a
+ * revised JPEG-in-TIFF scheme.
  */
 #define	TIFFTAG_JPEGPROC		512	/* !JPEG processing algorithm */
 #define	    JPEGPROC_BASELINE		1	/* !baseline sequential */
@@ -287,6 +348,11 @@
 #define	    YCBCRPOSITION_CENTERED	1	/* !as in PostScript Level 2 */
 #define	    YCBCRPOSITION_COSITED	2	/* !as in CCIR 601-1 */
 #define	TIFFTAG_REFERENCEBLACKWHITE	532	/* !colorimetry info */
+#define	TIFFTAG_XMLPACKET		700	/* %XML packet
+						   [Adobe XMP Specification,
+						   January 2004 */
+#define TIFFTAG_OPIIMAGEID		32781	/* %OPI ImageID
+						   [Adobe TIFF technote] */
 /* tags 32952-32956 are private tags registered to Island Graphics */
 #define TIFFTAG_REFPTS			32953	/* image reference points */
 #define TIFFTAG_REGIONTACKPOINT		32954	/* region-xform tack point */
@@ -307,31 +373,154 @@
  */
 #define TIFFTAG_PIXAR_IMAGEFULLWIDTH    33300   /* full image size in x */
 #define TIFFTAG_PIXAR_IMAGEFULLLENGTH   33301   /* full image size in y */
+ /* Tags 33302-33306 are used to identify special image modes and data
+  * used by Pixar's texture formats.
+  */
+#define TIFFTAG_PIXAR_TEXTUREFORMAT	33302	/* texture map format */
+#define TIFFTAG_PIXAR_WRAPMODES		33303	/* s & t wrap modes */
+#define TIFFTAG_PIXAR_FOVCOT		33304	/* cotan(fov) for env. maps */
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOSCREEN 33305
+#define TIFFTAG_PIXAR_MATRIX_WORLDTOCAMERA 33306
 /* tag 33405 is a private tag registered to Eastman Kodak */
 #define TIFFTAG_WRITERSERIALNUMBER      33405   /* device serial number */
 /* tag 33432 is listed in the 6.0 spec w/ unknown ownership */
 #define	TIFFTAG_COPYRIGHT		33432	/* copyright string */
+/* IPTC TAG from RichTIFF specifications */
+#define TIFFTAG_RICHTIFFIPTC		33723
+/* 34016-34029 are reserved for ANSI IT8 TIFF/IT <dkelly@apago.com) */
+#define TIFFTAG_IT8SITE			34016	/* site name */
+#define TIFFTAG_IT8COLORSEQUENCE	34017	/* color seq. [RGB,CMYK,etc] */
+#define TIFFTAG_IT8HEADER		34018	/* DDES Header */
+#define TIFFTAG_IT8RASTERPADDING	34019	/* raster scanline padding */
+#define TIFFTAG_IT8BITSPERRUNLENGTH	34020	/* # of bits in short run */
+#define TIFFTAG_IT8BITSPEREXTENDEDRUNLENGTH 34021/* # of bits in long run */
+#define TIFFTAG_IT8COLORTABLE		34022	/* LW colortable */
+#define TIFFTAG_IT8IMAGECOLORINDICATOR	34023	/* BP/BL image color switch */
+#define TIFFTAG_IT8BKGCOLORINDICATOR	34024	/* BP/BL bg color switch */
+#define TIFFTAG_IT8IMAGECOLORVALUE	34025	/* BP/BL image color value */
+#define TIFFTAG_IT8BKGCOLORVALUE	34026	/* BP/BL bg color value */
+#define TIFFTAG_IT8PIXELINTENSITYRANGE	34027	/* MP pixel intensity value */
+#define TIFFTAG_IT8TRANSPARENCYINDICATOR 34028	/* HC transparency switch */
+#define TIFFTAG_IT8COLORCHARACTERIZATION 34029	/* color character. table */
+#define TIFFTAG_IT8HCUSAGE		34030	/* HC usage indicator */
+#define TIFFTAG_IT8TRAPINDICATOR	34031	/* Trapping indicator
+						   (untrapped=0, trapped=1) */
+#define TIFFTAG_IT8CMYKEQUIVALENT	34032	/* CMYK color equivalents */
 /* tags 34232-34236 are private tags registered to Texas Instruments */
 #define TIFFTAG_FRAMECOUNT              34232   /* Sequence Frame Count */
+/* tag 34377 is private tag registered to Adobe for PhotoShop */
+#define TIFFTAG_PHOTOSHOP		34377 
+/* tags 34665, 34853 and 40965 are documented in EXIF specification */
+#define TIFFTAG_EXIFIFD			34665	/* Pointer to EXIF private directory */
+/* tag 34750 is a private tag registered to Adobe? */
+#define TIFFTAG_ICCPROFILE		34675	/* ICC profile data */
 /* tag 34750 is a private tag registered to Pixel Magic */
 #define	TIFFTAG_JBIGOPTIONS		34750	/* JBIG options */
+#define TIFFTAG_GPSIFD			34853	/* Pointer to GPS private directory */
 /* tags 34908-34914 are private tags registered to SGI */
 #define	TIFFTAG_FAXRECVPARAMS		34908	/* encoded Class 2 ses. parms */
 #define	TIFFTAG_FAXSUBADDRESS		34909	/* received SubAddr string */
 #define	TIFFTAG_FAXRECVTIME		34910	/* receive time (secs) */
+#define	TIFFTAG_FAXDCS			34911	/* encoded fax ses. params, Table 2/T.30 */
+/* tags 37439-37443 are registered to SGI <gregl@sgi.com> */
+#define TIFFTAG_STONITS			37439	/* Sample value to Nits */
+/* tag 34929 is a private tag registered to FedEx */
+#define	TIFFTAG_FEDEX_EDR		34929	/* unknown use */
+#define TIFFTAG_INTEROPERABILITYIFD	40965	/* Pointer to Interoperability private directory */
+/* Adobe Digital Negative (DNG) format tags */
+#define TIFFTAG_DNGVERSION		50706	/* &DNG version number */
+#define TIFFTAG_DNGBACKWARDVERSION	50707	/* &DNG compatibility version */
+#define TIFFTAG_UNIQUECAMERAMODEL	50708	/* &name for the camera model */
+#define TIFFTAG_LOCALIZEDCAMERAMODEL	50709	/* &localized camera model
+						   name */
+#define TIFFTAG_CFAPLANECOLOR		50710	/* &CFAPattern->LinearRaw space
+						   mapping */
+#define TIFFTAG_CFALAYOUT		50711	/* &spatial layout of the CFA */
+#define TIFFTAG_LINEARIZATIONTABLE	50712	/* &lookup table description */
+#define TIFFTAG_BLACKLEVELREPEATDIM	50713	/* &repeat pattern size for
+						   the BlackLevel tag */
+#define TIFFTAG_BLACKLEVEL		50714	/* &zero light encoding level */
+#define TIFFTAG_BLACKLEVELDELTAH	50715	/* &zero light encoding level
+						   differences (columns) */
+#define TIFFTAG_BLACKLEVELDELTAV	50716	/* &zero light encoding level
+						   differences (rows) */
+#define TIFFTAG_WHITELEVEL		50717	/* &fully saturated encoding
+						   level */
+#define TIFFTAG_DEFAULTSCALE		50718	/* &default scale factors */
+#define TIFFTAG_DEFAULTCROPORIGIN	50719	/* &origin of the final image
+						   area */
+#define TIFFTAG_DEFAULTCROPSIZE		50720	/* &size of the final image 
+						   area */
+#define TIFFTAG_COLORMATRIX1		50721	/* &XYZ->reference color space
+						   transformation matrix 1 */
+#define TIFFTAG_COLORMATRIX2		50722	/* &XYZ->reference color space
+						   transformation matrix 2 */
+#define TIFFTAG_CAMERACALIBRATION1	50723	/* &calibration matrix 1 */
+#define TIFFTAG_CAMERACALIBRATION2	50724	/* &calibration matrix 2 */
+#define TIFFTAG_REDUCTIONMATRIX1	50725	/* &dimensionality reduction
+						   matrix 1 */
+#define TIFFTAG_REDUCTIONMATRIX2	50726	/* &dimensionality reduction
+						   matrix 2 */
+#define TIFFTAG_ANALOGBALANCE		50727	/* &gain applied the stored raw
+						   values*/
+#define TIFFTAG_ASSHOTNEUTRAL		50728	/* &selected white balance in
+						   linear reference space */
+#define TIFFTAG_ASSHOTWHITEXY		50729	/* &selected white balance in
+						   x-y chromaticity
+						   coordinates */
+#define TIFFTAG_BASELINEEXPOSURE	50730	/* &how much to move the zero
+						   point */
+#define TIFFTAG_BASELINENOISE		50731	/* &relative noise level */
+#define TIFFTAG_BASELINESHARPNESS	50732	/* &relative amount of
+						   sharpening */
+#define TIFFTAG_BAYERGREENSPLIT		50733	/* &how closely the values of
+						   the green pixels in the
+						   blue/green rows track the
+						   values of the green pixels
+						   in the red/green rows */
+#define TIFFTAG_LINEARRESPONSELIMIT	50734	/* &non-linear encoding range */
+#define TIFFTAG_CAMERASERIALNUMBER	50735	/* &camera's serial number */
+#define TIFFTAG_LENSINFO		50736	/* info about the lens */
+#define TIFFTAG_CHROMABLURRADIUS	50737	/* &chroma blur radius */
+#define TIFFTAG_ANTIALIASSTRENGTH	50738	/* &relative strength of the
+						   camera's anti-alias filter */
+#define TIFFTAG_SHADOWSCALE		50739	/* &used by Adobe Camera Raw */
+#define TIFFTAG_DNGPRIVATEDATA		50740	/* &manufacturer's private data */
+#define TIFFTAG_MAKERNOTESAFETY		50741	/* &whether the EXIF MakerNote
+						   tag is safe to preserve
+						   along with the rest of the
+						   EXIF data */
+#define	TIFFTAG_CALIBRATIONILLUMINANT1	50778	/* &illuminant 1 */
+#define TIFFTAG_CALIBRATIONILLUMINANT2	50779	/* &illuminant 2 */
+#define TIFFTAG_BESTQUALITYSCALE	50780	/* &best quality multiplier */
+#define TIFFTAG_RAWDATAUNIQUEID		50781	/* &unique identifier for
+						   the raw image data */
+#define TIFFTAG_ORIGINALRAWFILENAME	50827	/* &file name of the original
+						   raw file */
+#define TIFFTAG_ORIGINALRAWFILEDATA	50828	/* &contents of the original
+						   raw file */
+#define TIFFTAG_ACTIVEAREA		50829	/* &active (non-masked) pixels
+						   of the sensor */
+#define TIFFTAG_MASKEDAREAS		50830	/* &list of coordinates
+						   of fully masked pixels */
+#define TIFFTAG_ASSHOTICCPROFILE	50831	/* &these two tags used to */
+#define TIFFTAG_ASSHOTPREPROFILEMATRIX	50832	/* map cameras's color space
+						   into ICC profile space */
+#define TIFFTAG_CURRENTICCPROFILE	50833	/* & */
+#define TIFFTAG_CURRENTPREPROFILEMATRIX	50834	/* & */
 /* tag 65535 is an undefined tag used by Eastman Kodak */
 #define TIFFTAG_DCSHUESHIFTVALUES       65535   /* hue shift correction data */
 
 /*
- * The following are ``pseudo tags'' that can be
- * used to control codec-specific functionality.
- * These tags are not written to file.  Note that
- * these values start at 0xffff+1 so that they'll
- * never collide with Aldus-assigned tags.
+ * The following are ``pseudo tags'' that can be used to control
+ * codec-specific functionality.  These tags are not written to file.
+ * Note that these values start at 0xffff+1 so that they'll never
+ * collide with Aldus-assigned tags.
  *
- * If you want your private pseudo tags ``registered''
- * (i.e. added to this file), send mail to sam@sgi.com
- * with the appropriate C definitions to add.
+ * If you want your private pseudo tags ``registered'' (i.e. added to
+ * this file), please post a bug report via the tracking system at
+ * http://www.remotesensing.org/libtiff/bugs.html with the appropriate
+ * C definitions to add.
  */
 #define	TIFFTAG_FAXMODE			65536	/* Group 3/4 format control */
 #define	    FAXMODE_CLASSIC	0x0000		/* default, include RTC */
@@ -377,4 +566,82 @@
 /* Note: quality level is on the ZLIB 1-9 scale. Default value is -1 */
 #define	TIFFTAG_ZIPQUALITY		65557	/* compression quality level */
 #define	TIFFTAG_PIXARLOGQUALITY		65558	/* PixarLog uses same scale */
+/* 65559 is allocated to Oceana Matrix <dev@oceana.com> */
+#define TIFFTAG_DCSCLIPRECTANGLE	65559	/* area of image to acquire */
+#define TIFFTAG_SGILOGDATAFMT		65560	/* SGILog user data format */
+#define     SGILOGDATAFMT_FLOAT		0	/* IEEE float samples */
+#define     SGILOGDATAFMT_16BIT		1	/* 16-bit samples */
+#define     SGILOGDATAFMT_RAW		2	/* uninterpreted data */
+#define     SGILOGDATAFMT_8BIT		3	/* 8-bit RGB monitor values */
+#define TIFFTAG_SGILOGENCODE		65561 /* SGILog data encoding control*/
+#define     SGILOGENCODE_NODITHER	0     /* do not dither encoded values*/
+#define     SGILOGENCODE_RANDITHER	1     /* randomly dither encd values */
+
+/*
+ * EXIF tags
+ */
+#define EXIFTAG_EXPOSURETIME		33434	/* Exposure time */
+#define EXIFTAG_FNUMBER			33437	/* F number */
+#define EXIFTAG_EXPOSUREPROGRAM		34850	/* Exposure program */
+#define EXIFTAG_SPECTRALSENSITIVITY	34852	/* Spectral sensitivity */
+#define EXIFTAG_ISOSPEEDRATINGS		34855	/* ISO speed rating */
+#define EXIFTAG_OECF			34856	/* Optoelectric conversion
+						   factor */
+#define EXIFTAG_EXIFVERSION		36864	/* Exif version */
+#define EXIFTAG_DATETIMEORIGINAL	36867	/* Date and time of original
+						   data generation */
+#define EXIFTAG_DATETIMEDIGITIZED	36868	/* Date and time of digital
+						   data generation */
+#define EXIFTAG_COMPONENTSCONFIGURATION	37121	/* Meaning of each component */
+#define EXIFTAG_COMPRESSEDBITSPERPIXEL	37122	/* Image compression mode */
+#define EXIFTAG_SHUTTERSPEEDVALUE	37377	/* Shutter speed */
+#define EXIFTAG_APERTUREVALUE		37378	/* Aperture */
+#define EXIFTAG_BRIGHTNESSVALUE		37379	/* Brightness */
+#define EXIFTAG_EXPOSUREBIASVALUE	37380	/* Exposure bias */
+#define EXIFTAG_MAXAPERTUREVALUE	37381	/* Maximum lens aperture */
+#define EXIFTAG_SUBJECTDISTANCE		37382	/* Subject distance */
+#define EXIFTAG_METERINGMODE		37383	/* Metering mode */
+#define EXIFTAG_LIGHTSOURCE		37384	/* Light source */
+#define EXIFTAG_FLASH			37385	/* Flash */
+#define EXIFTAG_FOCALLENGTH		37386	/* Lens focal length */
+#define EXIFTAG_SUBJECTAREA		37396	/* Subject area */
+#define EXIFTAG_MAKERNOTE		37500	/* Manufacturer notes */
+#define EXIFTAG_USERCOMMENT		37510	/* User comments */
+#define EXIFTAG_SUBSECTIME		37520	/* DateTime subseconds */
+#define EXIFTAG_SUBSECTIMEORIGINAL	37521	/* DateTimeOriginal subseconds */
+#define EXIFTAG_SUBSECTIMEDIGITIZED	37522	/* DateTimeDigitized subseconds */
+#define EXIFTAG_FLASHPIXVERSION		40960	/* Supported Flashpix version */
+#define EXIFTAG_COLORSPACE		40961	/* Color space information */
+#define EXIFTAG_PIXELXDIMENSION		40962	/* Valid image width */
+#define EXIFTAG_PIXELYDIMENSION		40963	/* Valid image height */
+#define EXIFTAG_RELATEDSOUNDFILE	40964	/* Related audio file */
+#define EXIFTAG_FLASHENERGY		41483	/* Flash energy */
+#define EXIFTAG_SPATIALFREQUENCYRESPONSE 41484	/* Spatial frequency response */
+#define EXIFTAG_FOCALPLANEXRESOLUTION	41486	/* Focal plane X resolution */
+#define EXIFTAG_FOCALPLANEYRESOLUTION	41487	/* Focal plane Y resolution */
+#define EXIFTAG_FOCALPLANERESOLUTIONUNIT 41488	/* Focal plane resolution unit */
+#define EXIFTAG_SUBJECTLOCATION		41492	/* Subject location */
+#define EXIFTAG_EXPOSUREINDEX		41493	/* Exposure index */
+#define EXIFTAG_SENSINGMETHOD		41495	/* Sensing method */
+#define EXIFTAG_FILESOURCE		41728	/* File source */
+#define EXIFTAG_SCENETYPE		41729	/* Scene type */
+#define EXIFTAG_CFAPATTERN		41730	/* CFA pattern */
+#define EXIFTAG_CUSTOMRENDERED		41985	/* Custom image processing */
+#define EXIFTAG_EXPOSUREMODE		41986	/* Exposure mode */
+#define EXIFTAG_WHITEBALANCE		41987	/* White balance */
+#define EXIFTAG_DIGITALZOOMRATIO	41988	/* Digital zoom ratio */
+#define EXIFTAG_FOCALLENGTHIN35MMFILM	41989	/* Focal length in 35 mm film */
+#define EXIFTAG_SCENECAPTURETYPE	41990	/* Scene capture type */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_CONTRAST		41992	/* Contrast */
+#define EXIFTAG_SATURATION		41993	/* Saturation */
+#define EXIFTAG_SHARPNESS		41994	/* Sharpness */
+#define EXIFTAG_DEVICESETTINGDESCRIPTION 41995	/* Device settings description */
+#define EXIFTAG_SUBJECTDISTANCERANGE	41996	/* Subject distance range */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_GAINCONTROL		41991	/* Gain control */
+#define EXIFTAG_IMAGEUNIQUEID		42016	/* Unique image ID */
+
 #endif /* _TIFF_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/tiffio.h ./libs/libtiff/tiffio.h
--- /home/robin/sldeb/trunk/libs/libtiff/tiffio.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/tiffio.h	2007-09-28 11:33:43.000000000 +0100
@@ -1,8 +1,8 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffio.h,v 1.93 1996/03/07 17:00:14 sam Rel $ */
+/* $Id: tiffio.h,v 1.50 2006/03/21 16:37:51 dron Exp $ */
 
 /*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
+ * Copyright (c) 1988-1997 Sam Leffler
+ * Copyright (c) 1991-1997 Silicon Graphics, Inc.
  *
  * Permission to use, copy, modify, distribute, and sell this software and 
  * its documentation for any purpose is hereby granted without fee, provided
@@ -19,8 +19,8 @@
  * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
  * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
  * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
+ * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF
+ * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE
  * OF THIS SOFTWARE.
  */
 
@@ -31,15 +31,7 @@
  * TIFF I/O Library Definitions.
  */
 #include "tiff.h"
-
-/*
- * This define can be used in code that requires
- * compilation-related definitions specific to a
- * version or versions of the library.  Runtime
- * version checking should be done based on the
- * string returned by TIFFGetVersion.
- */
-#define	TIFFLIB_VERSION	19960307	/* March 7, 1996 */
+#include "tiffvers.h"
 
 /*
  * TIFF is defined as an incomplete type to hide the
@@ -52,7 +44,7 @@
  * data types used in the *exported* interfaces.  These
  * definitions depend on the proper definition of types
  * in tiff.h.  Note also that the varargs interface used
- * pass tag types and values uses the types defined in
+ * to pass tag types and values uses the types defined in
  * tiff.h directly.
  *
  * NB: ttag_t is unsigned int and not unsigned short because
@@ -63,29 +55,49 @@
  * NB: tsize_t is int32 and not uint32 because some functions
  *     return -1.
  * NB: toff_t is not off_t for many reasons; TIFFs max out at
- *     32-bit file offsets being the most important
+ *     32-bit file offsets being the most important, and to ensure
+ *     that it is unsigned, rather than signed.
  */
-typedef	unsigned int ttag_t;	/* directory tag */
+typedef	uint32 ttag_t;		/* directory tag */
 typedef	uint16 tdir_t;		/* directory index */
 typedef	uint16 tsample_t;	/* sample number */
 typedef	uint32 tstrip_t;	/* strip number */
 typedef uint32 ttile_t;		/* tile number */
 typedef	int32 tsize_t;		/* i/o size in bytes */
+typedef	void* tdata_t;		/* image data ref */
+typedef	uint32 toff_t;		/* file offset */
+
+#if !defined(__WIN32__) && (defined(_WIN32) || defined(WIN32))
+#define __WIN32__
+#endif
+
+/*
+ * On windows you should define USE_WIN32_FILEIO if you are using tif_win32.c
+ * or AVOID_WIN32_FILEIO if you are using something else (like tif_unix.c).
+ *
+ * By default tif_unix.c is assumed.
+ */
+
 #if defined(_WINDOWS) || defined(__WIN32__) || defined(_Windows)
-#include <windows.h>
-#ifdef __WIN32__
+#  if !defined(__CYGWIN) && !defined(AVOID_WIN32_FILEIO) && !defined(USE_WIN32_FILEIO)
+#    define AVOID_WIN32_FILEIO
+#  endif
+#endif
+
+#if defined(USE_WIN32_FILEIO)
+# define VC_EXTRALEAN
+# include <windows.h>
+# ifdef __WIN32__
 DECLARE_HANDLE(thandle_t);	/* Win32 file handle */
-#else
+# else
 typedef	HFILE thandle_t;	/* client data handle */
-#endif
+# endif /* __WIN32__ */
 #else
 typedef	void* thandle_t;	/* client data handle */
-#endif
-typedef	void* tdata_t;		/* image data ref */
-typedef	int32 toff_t;		/* file offset */
+#endif /* USE_WIN32_FILEIO */
 
 #ifndef NULL
-#define	NULL	0
+# define NULL	(void *)0
 #endif
 
 /*
@@ -102,10 +114,62 @@
 #define	TIFFPRINT_JPEGACTABLES	0x200		/* JPEG AC tables */
 #define	TIFFPRINT_JPEGDCTABLES	0x200		/* JPEG DC tables */
 
+/* 
+ * Colour conversion stuff
+ */
+
+/* reference white */
+#define D65_X0 (95.0470F)
+#define D65_Y0 (100.0F)
+#define D65_Z0 (108.8827F)
+
+#define D50_X0 (96.4250F)
+#define D50_Y0 (100.0F)
+#define D50_Z0 (82.4680F)
+
+/* Structure for holding information about a display device. */
+
+typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
+
+typedef struct {
+	float d_mat[3][3]; 		/* XYZ -> luminance matrix */
+	float d_YCR;			/* Light o/p for reference white */
+	float d_YCG;
+	float d_YCB;
+	uint32 d_Vrwr;			/* Pixel values for ref. white */
+	uint32 d_Vrwg;
+	uint32 d_Vrwb;
+	float d_Y0R;			/* Residual light for black pixel */
+	float d_Y0G;
+	float d_Y0B;
+	float d_gammaR;			/* Gamma values for the three guns */
+	float d_gammaG;
+	float d_gammaB;
+} TIFFDisplay;
+
+typedef struct {				/* YCbCr->RGB support */
+	TIFFRGBValue* clamptab;			/* range clamping table */
+	int*	Cr_r_tab;
+	int*	Cb_b_tab;
+	int32*	Cr_g_tab;
+	int32*	Cb_g_tab;
+        int32*  Y_tab;
+} TIFFYCbCrToRGB;
+
+typedef struct {				/* CIE Lab 1976->RGB support */
+	int	range;				/* Size of conversion table */
+#define CIELABTORGB_TABLE_RANGE 1500
+	float	rstep, gstep, bstep;
+	float	X0, Y0, Z0;			/* Reference white point */
+	TIFFDisplay display;
+	float	Yr2r[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yr to r */
+	float	Yg2g[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yg to g */
+	float	Yb2b[CIELABTORGB_TABLE_RANGE + 1];  /* Conversion of Yb to b */
+} TIFFCIELabToRGB;
+
 /*
  * RGBA-style image support.
  */
-typedef	unsigned char TIFFRGBValue;		/* 8-bit samples */
 typedef struct _TIFFRGBAImage TIFFRGBAImage;
 /*
  * The image reading and conversion routines invoke
@@ -126,15 +190,6 @@
 /*
  * RGBA-reader state.
  */
-typedef struct {				/* YCbCr->RGB support */
-	TIFFRGBValue* clamptab;			/* range clamping table */
-	int*	Cr_r_tab;
-	int*	Cb_b_tab;
-	int32*	Cr_g_tab;
-	int32*	Cb_g_tab;
-	float	coeffs[3];			/* cached for repeated use */
-} TIFFYCbCrToRGB;
-
 struct _TIFFRGBAImage {
 	TIFF*	tif;				/* image handle */
 	int	stoponerr;			/* stop on read error */
@@ -145,6 +200,7 @@
 	uint16	bitspersample;			/* image bits/sample */
 	uint16	samplesperpixel;		/* image samples/pixel */
 	uint16	orientation;			/* image orientation */
+	uint16	req_orientation;		/* requested orientation */
 	uint16	photometric;			/* image photometric interp */
 	uint16*	redcmap;			/* colormap pallete */
 	uint16*	greencmap;
@@ -160,6 +216,10 @@
 	uint32** BWmap;				/* black&white map */
 	uint32** PALmap;			/* palette image map */
 	TIFFYCbCrToRGB* ycbcr;			/* YCbCr conversion state */
+        TIFFCIELabToRGB* cielab;		/* CIE L*a*b conversion state */
+
+        int	row_offset;
+        int     col_offset;
 };
 
 /*
@@ -188,10 +248,16 @@
 #include <stdio.h>
 #include <stdarg.h>
 
-#if defined(__cplusplus)
+/* share internal LogLuv conversion routines? */
+#ifndef LOGLUV_PUBLIC
+#define LOGLUV_PUBLIC		1
+#endif
+
+#if defined(c_plusplus) || defined(__cplusplus)
 extern "C" {
 #endif
 typedef	void (*TIFFErrorHandler)(const char*, const char*, va_list);
+typedef	void (*TIFFErrorHandlerExt)(thandle_t, const char*, const char*, va_list);
 typedef	tsize_t (*TIFFReadWriteProc)(thandle_t, tdata_t, tsize_t);
 typedef	toff_t (*TIFFSeekProc)(thandle_t, toff_t, int);
 typedef	int (*TIFFCloseProc)(thandle_t);
@@ -205,6 +271,12 @@
 extern	const TIFFCodec* TIFFFindCODEC(uint16);
 extern	TIFFCodec* TIFFRegisterCODEC(uint16, const char*, TIFFInitMethod);
 extern	void TIFFUnRegisterCODEC(TIFFCodec*);
+extern  int TIFFIsCODECConfigured(uint16);
+extern	TIFFCodec* TIFFGetConfiguredCODECs(void);
+
+/*
+ * Auxiliary functions.
+ */
 
 extern	tdata_t _TIFFmalloc(tsize_t);
 extern	tdata_t _TIFFrealloc(tdata_t, tsize_t);
@@ -213,6 +285,58 @@
 extern	int _TIFFmemcmp(const tdata_t, const tdata_t, tsize_t);
 extern	void _TIFFfree(tdata_t);
 
+/*
+** Stuff, related to tag handling and creating custom tags.
+*/
+extern  int  TIFFGetTagListCount( TIFF * );
+extern  ttag_t TIFFGetTagListEntry( TIFF *, int tag_index );
+    
+#define	TIFF_ANY	TIFF_NOTYPE	/* for field descriptor searching */
+#define	TIFF_VARIABLE	-1		/* marker for variable length tags */
+#define	TIFF_SPP	-2		/* marker for SamplesPerPixel tags */
+#define	TIFF_VARIABLE2	-3		/* marker for uint32 var-length tags */
+
+#define FIELD_CUSTOM    65    
+
+typedef	struct {
+	ttag_t	field_tag;		/* field's tag */
+	short	field_readcount;	/* read count/TIFF_VARIABLE/TIFF_SPP */
+	short	field_writecount;	/* write count/TIFF_VARIABLE */
+	TIFFDataType field_type;	/* type of associated data */
+        unsigned short field_bit;	/* bit in fieldsset bit vector */
+	unsigned char field_oktochange;	/* if true, can change while writing */
+	unsigned char field_passcount;	/* if true, pass dir count on set */
+	char	*field_name;		/* ASCII name */
+} TIFFFieldInfo;
+
+typedef struct _TIFFTagValue {
+    const TIFFFieldInfo  *info;
+    int             count;
+    void           *value;
+} TIFFTagValue;
+
+extern	void TIFFMergeFieldInfo(TIFF*, const TIFFFieldInfo[], int);
+extern	const TIFFFieldInfo* TIFFFindFieldInfo(TIFF*, ttag_t, TIFFDataType);
+extern  const TIFFFieldInfo* TIFFFindFieldInfoByName(TIFF* , const char *,
+						     TIFFDataType);
+extern	const TIFFFieldInfo* TIFFFieldWithTag(TIFF*, ttag_t);
+extern	const TIFFFieldInfo* TIFFFieldWithName(TIFF*, const char *);
+
+typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
+typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
+typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
+    
+typedef struct {
+    TIFFVSetMethod	vsetfield;	/* tag set routine */
+    TIFFVGetMethod	vgetfield;	/* tag get routine */
+    TIFFPrintMethod	printdir;	/* directory print routine */
+} TIFFTagMethods;
+        
+extern  TIFFTagMethods *TIFFAccessTagMethods( TIFF * );
+extern  void *TIFFGetClientInfo( TIFF *, const char * );
+extern  void TIFFSetClientInfo( TIFF *, void *, const char * );
+
+extern	void TIFFCleanup(TIFF*);
 extern	void TIFFClose(TIFF*);
 extern	int TIFFFlush(TIFF*);
 extern	int TIFFFlushData(TIFF*);
@@ -221,9 +345,13 @@
 extern	int TIFFGetFieldDefaulted(TIFF*, ttag_t, ...);
 extern	int TIFFVGetFieldDefaulted(TIFF*, ttag_t, va_list);
 extern	int TIFFReadDirectory(TIFF*);
+extern	int TIFFReadCustomDirectory(TIFF*, toff_t, const TIFFFieldInfo[],
+				    size_t);
+extern	int TIFFReadEXIFDirectory(TIFF*, toff_t);
 extern	tsize_t TIFFScanlineSize(TIFF*);
 extern	tsize_t TIFFRasterScanlineSize(TIFF*);
 extern	tsize_t TIFFStripSize(TIFF*);
+extern	tsize_t TIFFRawStripSize(TIFF*, tstrip_t);
 extern	tsize_t TIFFVStripSize(TIFF*, uint32);
 extern	tsize_t TIFFTileRowSize(TIFF*);
 extern	tsize_t TIFFTileSize(TIFF*);
@@ -231,18 +359,35 @@
 extern	uint32 TIFFDefaultStripSize(TIFF*, uint32);
 extern	void TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
 extern	int TIFFFileno(TIFF*);
+extern  int TIFFSetFileno(TIFF*, int);
+extern  thandle_t TIFFClientdata(TIFF*);
+extern  thandle_t TIFFSetClientdata(TIFF*, thandle_t);
 extern	int TIFFGetMode(TIFF*);
+extern	int TIFFSetMode(TIFF*, int);
 extern	int TIFFIsTiled(TIFF*);
 extern	int TIFFIsByteSwapped(TIFF*);
 extern	int TIFFIsUpSampled(TIFF*);
 extern	int TIFFIsMSB2LSB(TIFF*);
+extern	int TIFFIsBigEndian(TIFF*);
+extern	TIFFReadWriteProc TIFFGetReadProc(TIFF*);
+extern	TIFFReadWriteProc TIFFGetWriteProc(TIFF*);
+extern	TIFFSeekProc TIFFGetSeekProc(TIFF*);
+extern	TIFFCloseProc TIFFGetCloseProc(TIFF*);
+extern	TIFFSizeProc TIFFGetSizeProc(TIFF*);
+extern	TIFFMapFileProc TIFFGetMapFileProc(TIFF*);
+extern	TIFFUnmapFileProc TIFFGetUnmapFileProc(TIFF*);
 extern	uint32 TIFFCurrentRow(TIFF*);
 extern	tdir_t TIFFCurrentDirectory(TIFF*);
+extern	tdir_t TIFFNumberOfDirectories(TIFF*);
 extern	uint32 TIFFCurrentDirOffset(TIFF*);
 extern	tstrip_t TIFFCurrentStrip(TIFF*);
 extern	ttile_t TIFFCurrentTile(TIFF*);
 extern	int TIFFReadBufferSetup(TIFF*, tdata_t, tsize_t);
 extern	int TIFFWriteBufferSetup(TIFF*, tdata_t, tsize_t);
+extern	int TIFFSetupStrips(TIFF *);
+extern  int TIFFWriteCheck(TIFF*, int, const char *);
+extern	void TIFFFreeDirectory(TIFF*);
+extern  int TIFFCreateDirectory(TIFF*);
 extern	int TIFFLastDirectory(TIFF*);
 extern	int TIFFSetDirectory(TIFF*, tdir_t);
 extern	int TIFFSetSubDirectory(TIFF*, uint32);
@@ -250,22 +395,35 @@
 extern	int TIFFSetField(TIFF*, ttag_t, ...);
 extern	int TIFFVSetField(TIFF*, ttag_t, va_list);
 extern	int TIFFWriteDirectory(TIFF *);
+extern	int TIFFCheckpointDirectory(TIFF *);
+extern	int TIFFRewriteDirectory(TIFF *);
+extern	int TIFFReassignTagToIgnore(enum TIFFIgnoreSense, int);
+
 #if defined(c_plusplus) || defined(__cplusplus)
 extern	void TIFFPrintDirectory(TIFF*, FILE*, long = 0);
 extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
 extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t = 0);
 extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int = 0);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*,
+				      int = ORIENTATION_BOTLEFT, int = 0);
 #else
 extern	void TIFFPrintDirectory(TIFF*, FILE*, long);
 extern	int TIFFReadScanline(TIFF*, tdata_t, uint32, tsample_t);
 extern	int TIFFWriteScanline(TIFF*, tdata_t, uint32, tsample_t);
 extern	int TIFFReadRGBAImage(TIFF*, uint32, uint32, uint32*, int);
+extern	int TIFFReadRGBAImageOriented(TIFF*, uint32, uint32, uint32*, int, int);
 #endif
+
+extern	int TIFFReadRGBAStrip(TIFF*, tstrip_t, uint32 * );
+extern	int TIFFReadRGBATile(TIFF*, uint32, uint32, uint32 * );
 extern	int TIFFRGBAImageOK(TIFF*, char [1024]);
 extern	int TIFFRGBAImageBegin(TIFFRGBAImage*, TIFF*, int, char [1024]);
 extern	int TIFFRGBAImageGet(TIFFRGBAImage*, uint32*, uint32, uint32);
 extern	void TIFFRGBAImageEnd(TIFFRGBAImage*);
 extern	TIFF* TIFFOpen(const char*, const char*);
+# ifdef __WIN32__
+extern	TIFF* TIFFOpenW(const wchar_t*, const char*);
+# endif /* __WIN32__ */
 extern	TIFF* TIFFFdOpen(int, const char*, const char*);
 extern	TIFF* TIFFClientOpen(const char*, const char*,
 	    thandle_t,
@@ -274,10 +432,15 @@
 	    TIFFSizeProc,
 	    TIFFMapFileProc, TIFFUnmapFileProc);
 extern	const char* TIFFFileName(TIFF*);
+extern	const char* TIFFSetFileName(TIFF*, const char *);
 extern	void TIFFError(const char*, const char*, ...);
+extern	void TIFFErrorExt(thandle_t, const char*, const char*, ...);
 extern	void TIFFWarning(const char*, const char*, ...);
+extern	void TIFFWarningExt(thandle_t, const char*, const char*, ...);
 extern	TIFFErrorHandler TIFFSetErrorHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetErrorHandlerExt(TIFFErrorHandlerExt);
 extern	TIFFErrorHandler TIFFSetWarningHandler(TIFFErrorHandler);
+extern	TIFFErrorHandlerExt TIFFSetWarningHandlerExt(TIFFErrorHandlerExt);
 extern	TIFFExtendProc TIFFSetTagExtender(TIFFExtendProc);
 extern	ttile_t TIFFComputeTile(TIFF*, uint32, uint32, uint32, tsample_t);
 extern	int TIFFCheckTile(TIFF*, uint32, uint32, uint32, tsample_t);
@@ -296,16 +459,57 @@
 extern	tsize_t TIFFWriteRawStrip(TIFF*, tstrip_t, tdata_t, tsize_t);
 extern	tsize_t TIFFWriteEncodedTile(TIFF*, ttile_t, tdata_t, tsize_t);
 extern	tsize_t TIFFWriteRawTile(TIFF*, ttile_t, tdata_t, tsize_t);
+extern	int TIFFDataWidth(TIFFDataType);    /* table of tag datatype widths */
 extern	void TIFFSetWriteOffset(TIFF*, toff_t);
 extern	void TIFFSwabShort(uint16*);
 extern	void TIFFSwabLong(uint32*);
 extern	void TIFFSwabDouble(double*);
 extern	void TIFFSwabArrayOfShort(uint16*, unsigned long);
+extern	void TIFFSwabArrayOfTriples(uint8*, unsigned long);
 extern	void TIFFSwabArrayOfLong(uint32*, unsigned long);
 extern	void TIFFSwabArrayOfDouble(double*, unsigned long);
 extern	void TIFFReverseBits(unsigned char *, unsigned long);
 extern	const unsigned char* TIFFGetBitRevTable(int);
-#if defined(__cplusplus)
+
+#ifdef LOGLUV_PUBLIC
+#define U_NEU		0.210526316
+#define V_NEU		0.473684211
+#define UVSCALE		410.
+extern	double LogL16toY(int);
+extern	double LogL10toY(int);
+extern	void XYZtoRGB24(float*, uint8*);
+extern	int uv_decode(double*, double*, int);
+extern	void LogLuv24toXYZ(uint32, float*);
+extern	void LogLuv32toXYZ(uint32, float*);
+#if defined(c_plusplus) || defined(__cplusplus)
+extern	int LogL16fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int LogL10fromY(double, int = SGILOGENCODE_NODITHER);
+extern	int uv_encode(double, double, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv24fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+extern	uint32 LogLuv32fromXYZ(float*, int = SGILOGENCODE_NODITHER);
+#else
+extern	int LogL16fromY(double, int);
+extern	int LogL10fromY(double, int);
+extern	int uv_encode(double, double, int);
+extern	uint32 LogLuv24fromXYZ(float*, int);
+extern	uint32 LogLuv32fromXYZ(float*, int);
+#endif
+#endif /* LOGLUV_PUBLIC */
+    
+extern int TIFFCIELabToRGBInit(TIFFCIELabToRGB*, TIFFDisplay *, float*);
+extern void TIFFCIELabToXYZ(TIFFCIELabToRGB *, uint32, int32, int32,
+			    float *, float *, float *);
+extern void TIFFXYZToRGB(TIFFCIELabToRGB *, float, float, float,
+			 uint32 *, uint32 *, uint32 *);
+
+extern int TIFFYCbCrToRGBInit(TIFFYCbCrToRGB*, float*, float*);
+extern void TIFFYCbCrtoRGB(TIFFYCbCrToRGB *, uint32, int32, int32,
+			   uint32 *, uint32 *, uint32 *);
+
+#if defined(c_plusplus) || defined(__cplusplus)
 }
 #endif
+
 #endif /* _TIFFIO_ */
+
+/* vim: set ts=8 sts=8 sw=8 noet: */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/Tiffiop.h ./libs/libtiff/Tiffiop.h
--- /home/robin/sldeb/trunk/libs/libtiff/Tiffiop.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/Tiffiop.h	1970-01-01 01:00:00.000000000 +0100
@@ -1,287 +0,0 @@
-/* $Header: /usr/people/sam/tiff/libtiff/RCS/tiffiop.h,v 1.80 1996/04/05 17:36:53 sam Rel $ */
-
-/*
- * Copyright (c) 1988-1996 Sam Leffler
- * Copyright (c) 1991-1996 Silicon Graphics, Inc.
- *
- * Permission to use, copy, modify, distribute, and sell this software and 
- * its documentation for any purpose is hereby granted without fee, provided
- * that (i) the above copyright notices and this permission notice appear in
- * all copies of the software and related documentation, and (ii) the names of
- * Sam Leffler and Silicon Graphics may not be used in any advertising or
- * publicity relating to the software without the specific, prior written
- * permission of Sam Leffler and Silicon Graphics.
- * 
- * THE SOFTWARE IS PROVIDED "AS-IS" AND WITHOUT WARRANTY OF ANY KIND, 
- * EXPRESS, IMPLIED OR OTHERWISE, INCLUDING WITHOUT LIMITATION, ANY 
- * WARRANTY OF MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE.  
- * 
- * IN NO EVENT SHALL SAM LEFFLER OR SILICON GRAPHICS BE LIABLE FOR
- * ANY SPECIAL, INCIDENTAL, INDIRECT OR CONSEQUENTIAL DAMAGES OF ANY KIND,
- * OR ANY DAMAGES WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS,
- * WHETHER OR NOT ADVISED OF THE POSSIBILITY OF DAMAGE, AND ON ANY THEORY OF 
- * LIABILITY, ARISING OUT OF OR IN CONNECTION WITH THE USE OR PERFORMANCE 
- * OF THIS SOFTWARE.
- */
-
-#ifndef _TIFFIOP_
-#define	_TIFFIOP_
-/*
- * ``Library-private'' definitions.
- */
-/*
- * UNIX systems should run the configure script to generate
- * a port.h file that reflects the system capabilities.
- * Doing this obviates all the dreck done in tiffcomp.h.
- */
-#if defined(unix) || defined(__unix)
-#include "port.h"
-#include "tiffconf.h"
-#else
-#include "tiffconf.h"
-#include "tiffcomp.h"
-#endif
-#include "tiffio.h"
-#include "tif_dir.h"
-
-#ifndef TRUE
-#define	TRUE	1
-#define	FALSE	0
-#endif
-
-/*
- * Typedefs for ``method pointers'' used internally.
- */
-typedef	unsigned char tidataval_t;	/* internal image data value type */
-typedef	tidataval_t* tidata_t;		/* reference to internal image data */
-
-typedef	void (*TIFFVoidMethod)(TIFF*);
-typedef	int (*TIFFBoolMethod)(TIFF*);
-typedef	int (*TIFFPreMethod)(TIFF*, tsample_t);
-typedef	int (*TIFFCodeMethod)(TIFF*, tidata_t, tsize_t, tsample_t);
-typedef	int (*TIFFSeekMethod)(TIFF*, uint32);
-typedef	void (*TIFFPostMethod)(TIFF*, tidata_t, tsize_t);
-typedef	int (*TIFFVSetMethod)(TIFF*, ttag_t, va_list);
-typedef	int (*TIFFVGetMethod)(TIFF*, ttag_t, va_list);
-typedef	void (*TIFFPrintMethod)(TIFF*, FILE*, long);
-typedef	uint32 (*TIFFStripMethod)(TIFF*, uint32);
-typedef	void (*TIFFTileMethod)(TIFF*, uint32*, uint32*);
-
-struct tiff {
-	char*		tif_name;	/* name of open file */
-	int		tif_fd;		/* open file descriptor */
-	int		tif_mode;	/* open mode (O_*) */
-	uint32		tif_flags;
-#define	TIFF_FILLORDER		0x0003	/* natural bit fill order for machine */
-#define	TIFF_DIRTYHEADER	0x0004	/* header must be written on close */
-#define	TIFF_DIRTYDIRECT	0x0008	/* current directory must be written */
-#define	TIFF_BUFFERSETUP	0x0010	/* data buffers setup */
-#define	TIFF_CODERSETUP		0x0020	/* encoder/decoder setup done */
-#define	TIFF_BEENWRITING	0x0040	/* written 1+ scanlines to file */
-#define	TIFF_SWAB		0x0080	/* byte swap file information */
-#define	TIFF_NOBITREV		0x0100	/* inhibit bit reversal logic */
-#define	TIFF_MYBUFFER		0x0200	/* my raw data buffer; free on close */
-#define	TIFF_ISTILED		0x0400	/* file is tile, not strip- based */
-#define	TIFF_MAPPED		0x0800	/* file is mapped into memory */
-#define	TIFF_POSTENCODE		0x1000	/* need call to postencode routine */
-#define	TIFF_INSUBIFD		0x2000	/* currently writing a subifd */
-#define	TIFF_UPSAMPLED		0x4000	/* library is doing data up-sampling */ 
-#define	TIFF_STRIPCHOP		0x8000	/* enable strip chopping support */
-	toff_t		tif_diroff;	/* file offset of current directory */
-	toff_t		tif_nextdiroff;	/* file offset of following directory */
-	TIFFDirectory	tif_dir;	/* internal rep of current directory */
-	TIFFHeader	tif_header;	/* file's header block */
-        tidata_t        tif_clientdir;  /* client TIFF directory */
-	const int*	tif_typeshift;	/* data type shift counts */
-	const long*	tif_typemask;	/* data type masks */
-	uint32		tif_row;	/* current scanline */
-	tdir_t		tif_curdir;	/* current directory (index) */
-	tstrip_t	tif_curstrip;	/* current strip for read/write */
-	toff_t		tif_curoff;	/* current offset for read/write */
-	toff_t		tif_dataoff;	/* current offset for writing dir */
-#if SUBIFD_SUPPORT
-	uint16		tif_nsubifd;	/* remaining subifds to write */
-	toff_t		tif_subifdoff;	/* offset for patching SubIFD link */
-#endif
-/* tiling support */
-	uint32 		tif_col;	/* current column (offset by row too) */
-	ttile_t		tif_curtile;	/* current tile for read/write */
-	tsize_t		tif_tilesize;	/* # of bytes in a tile */
-/* compression scheme hooks */
-	TIFFBoolMethod	tif_setupdecode;/* called once before predecode */
-	TIFFPreMethod	tif_predecode;	/* pre- row/strip/tile decoding */
-	TIFFBoolMethod	tif_setupencode;/* called once before preencode */
-	TIFFPreMethod	tif_preencode;	/* pre- row/strip/tile encoding */
-	TIFFBoolMethod	tif_postencode;	/* post- row/strip/tile encoding */
-	TIFFCodeMethod	tif_decoderow;	/* scanline decoding routine */
-	TIFFCodeMethod	tif_encoderow;	/* scanline encoding routine */
-	TIFFCodeMethod	tif_decodestrip;/* strip decoding routine */
-	TIFFCodeMethod	tif_encodestrip;/* strip encoding routine */
-	TIFFCodeMethod	tif_decodetile;	/* tile decoding routine */
-	TIFFCodeMethod	tif_encodetile;	/* tile encoding routine */
-	TIFFVoidMethod	tif_close;	/* cleanup-on-close routine */
-	TIFFSeekMethod	tif_seek;	/* position within a strip routine */
-	TIFFVoidMethod	tif_cleanup;	/* cleanup state routine */
-	TIFFStripMethod	tif_defstripsize;/* calculate/constrain strip size */
-	TIFFTileMethod	tif_deftilesize;/* calculate/constrain tile size */
-	tidata_t	tif_data;	/* compression scheme private data */
-/* input/output buffering */
-	tsize_t		tif_scanlinesize;/* # of bytes in a scanline */
-	tsize_t		tif_scanlineskew;/* scanline skew for reading strips */
-	tidata_t	tif_rawdata;	/* raw data buffer */
-	tsize_t		tif_rawdatasize;/* # of bytes in raw data buffer */
-	tidata_t	tif_rawcp;	/* current spot in raw buffer */
-	tsize_t		tif_rawcc;	/* bytes unread from raw buffer */
-/* memory-mapped file support */
-	tidata_t	tif_base;	/* base of mapped file */
-#ifdef __WIN32__
-	void*		pv_map_handle;	/* WIN32 file mapping handle;
-					 * must be contiguous with tif_base
-					 * since map & unmap only get tif_base
-					 * and assume 4 byte offset to
-					 * pv_map_handle. */
-#endif
-	toff_t		tif_size;	/* size of mapped file region (bytes) */
-	TIFFMapFileProc	tif_mapproc;	/* map file method */
-	TIFFUnmapFileProc tif_unmapproc;/* unmap file method */
-/* input/output callback methods */
-	thandle_t	tif_clientdata;	/* callback parameter */
-	TIFFReadWriteProc tif_readproc;	/* read method */
-	TIFFReadWriteProc tif_writeproc;/* write method */
-	TIFFSeekProc	tif_seekproc;	/* lseek method */
-	TIFFCloseProc	tif_closeproc;	/* close method */
-	TIFFSizeProc	tif_sizeproc;	/* filesize method */
-/* post-decoding support */
-	TIFFPostMethod	tif_postdecode;	/* post decoding routine */
-/* tag support */
-	TIFFFieldInfo**	tif_fieldinfo;	/* sorted table of registered tags */
-	int		tif_nfields;	/* # entries in registered tag table */
-	TIFFVSetMethod	tif_vsetfield;	/* tag set routine */
-	TIFFVGetMethod	tif_vgetfield;	/* tag get routine */
-	TIFFPrintMethod	tif_printdir;	/* directory print routine */
-};
-
-#define	isPseudoTag(t)	(t > 0xffff)	/* is tag value normal or pseudo */
-
-#define	isTiled(tif)	(((tif)->tif_flags & TIFF_ISTILED) != 0)
-#define	isMapped(tif)	(((tif)->tif_flags & TIFF_MAPPED) != 0)
-#define	isFillOrder(tif, o)	(((tif)->tif_flags & (o)) != 0)
-#define	isUpSampled(tif)	(((tif)->tif_flags & TIFF_UPSAMPLED) != 0)
-#define	TIFFReadFile(tif, buf, size) \
-	((*(tif)->tif_readproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFWriteFile(tif, buf, size) \
-	((*(tif)->tif_writeproc)((tif)->tif_clientdata,buf,size))
-#define	TIFFSeekFile(tif, off, whence) \
-	((*(tif)->tif_seekproc)((tif)->tif_clientdata,(toff_t)(off),whence))
-#define	TIFFCloseFile(tif) \
-	((*(tif)->tif_closeproc)((tif)->tif_clientdata))
-#define	TIFFGetFileSize(tif) \
-	((*(tif)->tif_sizeproc)((tif)->tif_clientdata))
-#define	TIFFMapFileContents(tif, paddr, psize) \
-	((*(tif)->tif_mapproc)((tif)->tif_clientdata,paddr,psize))
-#ifdef __WIN32__
-#define	TIFFUnmapFileContents(tif, addr, dummy) \
-	((*(tif)->tif_unmapproc)((tif)->tif_clientdata,addr,\
-	    (toff_t)(tif)->pv_map_handle))
-#else
-#define	TIFFUnmapFileContents(tif, addr, size) \
-	((*(tif)->tif_unmapproc)((tif)->tif_clientdata,addr,size))
-#endif
-
-/*
- * Default Read/Seek/Write definitions.
- */
-#ifndef ReadOK
-#define	ReadOK(tif, buf, size) \
-	(TIFFReadFile(tif, (tdata_t) buf, (tsize_t) size) == (tsize_t) size)
-#endif
-#ifndef SeekOK
-#define	SeekOK(tif, off) \
-	(TIFFSeekFile(tif, (toff_t) off, SEEK_SET) == (toff_t) off)
-#endif
-#ifndef WriteOK
-#define	WriteOK(tif, buf, size) \
-	(TIFFWriteFile(tif, (tdata_t) buf, (tsize_t) size) == (tsize_t) size)
-#endif
-
-/* NB: the uint32 casts are to silence certain ANSI-C compilers */
-#define	TIFFhowmany(x, y) ((((uint32)(x))+(((uint32)(y))-1))/((uint32)(y)))
-#define	TIFFroundup(x, y) (TIFFhowmany(x,y)*((uint32)(y)))
-
-#if defined(__cplusplus)
-extern "C" {
-#endif
-extern	int _TIFFgetMode(const char*, const char*);
-extern	int _TIFFNoRowEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileEncode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoRowDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoStripDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	int _TIFFNoTileDecode(TIFF*, tidata_t, tsize_t, tsample_t);
-extern	void _TIFFNoPostDecode(TIFF*, tidata_t, tsize_t);
-extern	int _TIFFNoSeek(TIFF*, uint32);
-extern	void _TIFFSwab16BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab32BitData(TIFF*, tidata_t, tsize_t);
-extern	void _TIFFSwab64BitData(TIFF*, tidata_t, tsize_t);
-extern	int TIFFFlushData1(TIFF*);
-extern	void TIFFFreeDirectory(TIFF*);
-extern	int TIFFDefaultDirectory(TIFF*);
-extern	int TIFFSetCompressionScheme(TIFF*, int);
-extern	uint32 _TIFFDefaultStripSize(TIFF*, uint32);
-extern	void _TIFFDefaultTileSize(TIFF*, uint32*, uint32*);
-
-extern	void _TIFFsetByteArray(void**, void*, long);
-extern	void _TIFFsetString(char**, char*);
-extern	void _TIFFsetShortArray(uint16**, uint16*, long);
-extern	void _TIFFsetLongArray(uint32**, uint32*, long);
-extern	void _TIFFsetFloatArray(float**, float*, long);
-extern	void _TIFFsetDoubleArray(double**, double*, long);
-
-extern	void _TIFFprintAscii(FILE*, const char*);
-extern	void _TIFFprintAsciiTag(FILE*, const char*, const char*);
-
-GLOBALDATA(TIFFErrorHandler,_TIFFwarningHandler);
-GLOBALDATA(TIFFErrorHandler,_TIFFerrorHandler);
-
-extern	int TIFFInitDumpMode(TIFF*, int);
-#ifdef PACKBITS_SUPPORT
-extern	int TIFFInitPackBits(TIFF*, int);
-#endif
-#ifdef CCITT_SUPPORT
-extern	int TIFFInitCCITTRLE(TIFF*, int), TIFFInitCCITTRLEW(TIFF*, int);
-extern	int TIFFInitCCITTFax3(TIFF*, int), TIFFInitCCITTFax4(TIFF*, int);
-#endif
-#ifdef THUNDER_SUPPORT
-extern	int TIFFInitThunderScan(TIFF*, int);
-#endif
-#ifdef NEXT_SUPPORT
-extern	int TIFFInitNeXT(TIFF*, int);
-#endif
-#ifdef LZW_SUPPORT
-extern	int TIFFInitLZW(TIFF*, int);
-#endif
-#ifdef OJPEG_SUPPORT
-extern	int TIFFInitOJPEG(TIFF*, int);
-#endif
-#ifdef JPEG_SUPPORT
-extern	int TIFFInitJPEG(TIFF*, int);
-#endif
-#ifdef JBIG_SUPPORT
-extern	int TIFFInitJBIG(TIFF*, int);
-#endif
-#ifdef ZIP_SUPPORT
-extern	int TIFFInitZIP(TIFF*, int);
-#endif
-#ifdef PIXARLOG_SUPPORT
-extern	int TIFFInitPixarLog(TIFF*, int);
-#endif
-#ifdef VMS
-extern	const TIFFCodec _TIFFBuiltinCODECS[];
-#else
-extern	TIFFCodec _TIFFBuiltinCODECS[];
-#endif
-
-#if defined(__cplusplus)
-}
-#endif
-#endif /* _TIFFIOP_ */
diff -urN /home/robin/sldeb/trunk/libs/libtiff/tiffvers.h ./libs/libtiff/tiffvers.h
--- /home/robin/sldeb/trunk/libs/libtiff/tiffvers.h	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/libtiff/tiffvers.h	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+#define TIFFLIB_VERSION_STR "LIBTIFF, Version 3.8.2\nCopyright (c) 1988-1996 Sam Leffler\nCopyright (c) 1991-1996 Silicon Graphics, Inc."
+/*
+ * This define can be used in code that requires
+ * compilation-related definitions specific to a
+ * version or versions of the library.  Runtime
+ * version checking should be done based on the
+ * string returned by TIFFGetVersion.
+ */
+#define TIFFLIB_VERSION 20060323
diff -urN /home/robin/sldeb/trunk/libs/libtiff/Version.h ./libs/libtiff/Version.h
--- /home/robin/sldeb/trunk/libs/libtiff/Version.h	2007-02-28 15:31:56.000000000 +0000
+++ ./libs/libtiff/Version.h	1970-01-01 01:00:00.000000000 +0100
@@ -1 +0,0 @@
-#define VERSION "LIBTIFF, Version 3.4beta024\nCopyright (c) 1988-1995 Sam Leffler\nCopyright (c) 1991-1995 Silicon Graphics, Inc."
diff -urN /home/robin/sldeb/trunk/libs/.svn/all-wcprops ./libs/.svn/all-wcprops
--- /home/robin/sldeb/trunk/libs/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/.svn/all-wcprops	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,5 @@
+K 25
+svn:wc:ra_dav:version-url
+V 28
+/svn/!svn/ver/409/trunk/libs
+END
diff -urN /home/robin/sldeb/trunk/libs/.svn/entries ./libs/.svn/entries
--- /home/robin/sldeb/trunk/libs/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,31 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/libs
+http://www.openjpeg.org/svn
+
+
+
+2007-07-19T15:04:39.957648Z
+409
+devaux
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+libtiff
+dir
+
diff -urN /home/robin/sldeb/trunk/libs/.svn/format ./libs/.svn/format
--- /home/robin/sldeb/trunk/libs/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./libs/.svn/format	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/Makefile ./Makefile
--- /home/robin/sldeb/trunk/Makefile	2007-06-04 14:27:25.000000000 +0100
+++ ./Makefile	2007-11-27 22:41:39.000000000 +0000
@@ -4,7 +4,7 @@
 VER_MINOR = 1.2.0
 
 SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
-INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_includes.h
+INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_malloc.h ./libopenjpeg/opj_includes.h 
 INCLUDE = -Ilibopenjpeg
 
 # General configuration variables:
@@ -18,7 +18,7 @@
 # Converts cr/lf to just lf
 DOS2UNIX = dos2unix
 
-COMPILERFLAGS = -O3 -fPIC
+COMPILERFLAGS = -Wall -O3 -ffast-math -std=c99 -fPIC
 LIBRARIES = -lstdc++
 
 MODULES = $(SRCS:.c=.o)
diff -urN /home/robin/sldeb/trunk/mj2/CMakeLists.txt ./mj2/CMakeLists.txt
--- /home/robin/sldeb/trunk/mj2/CMakeLists.txt	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/CMakeLists.txt	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,42 @@
+# Makefile for the MJ2 codecs of the OpenJPEG library: frames_to_mj2, mj2_to_frames, extract_j2k_from_mj2 and wrap_j2k_in_mj2
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+ADD_EXECUTABLE(frames_to_mj2
+  frames_to_mj2.c
+  compat/getopt.c 
+  mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(frames_to_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(frames_to_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(mj2_to_frames
+    mj2_to_frames.c
+    compat/getopt.c mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(mj2_to_frames ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(mj2_to_frames m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(extract_j2k_from_mj2
+    extract_j2k_from_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(wrap_j2k_in_mj2
+    wrap_j2k_in_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 m)
+ENDIF(UNIX)
+
+INSTALL(TARGETS frames_to_mj2 mj2_to_frames extract_j2k_from_mj2 wrap_j2k_in_mj2
+	DESTINATION bin)
diff -urN /home/robin/sldeb/trunk/mj2/compat/.svn/all-wcprops ./mj2/compat/.svn/all-wcprops
--- /home/robin/sldeb/trunk/mj2/compat/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/compat/.svn/all-wcprops	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,17 @@
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/381/trunk/mj2/compat
+END
+getopt.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/381/trunk/mj2/compat/getopt.c
+END
+getopt.h
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/381/trunk/mj2/compat/getopt.h
+END
diff -urN /home/robin/sldeb/trunk/mj2/compat/.svn/entries ./mj2/compat/.svn/entries
--- /home/robin/sldeb/trunk/mj2/compat/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/compat/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,52 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/mj2/compat
+http://www.openjpeg.org/svn
+
+
+
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+getopt.c
+file
+
+
+
+
+2007-09-28T10:33:41.000000Z
+0da20c0fb9d1e11c72c2c34da796edaf
+2006-12-08T17:11:50.435613Z
+324
+devaux
+
+getopt.h
+file
+
+
+
+
+2007-09-28T10:33:41.000000Z
+15e166c974ee564380d3684a22c08cce
+2006-12-08T17:11:50.435613Z
+324
+devaux
+
diff -urN /home/robin/sldeb/trunk/mj2/compat/.svn/format ./mj2/compat/.svn/format
--- /home/robin/sldeb/trunk/mj2/compat/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/compat/.svn/format	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/mj2/compat/.svn/text-base/getopt.c.svn-base ./mj2/compat/.svn/text-base/getopt.c.svn-base
--- /home/robin/sldeb/trunk/mj2/compat/.svn/text-base/getopt.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/compat/.svn/text-base/getopt.c.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,116 @@
+/*
+ * Copyright (c) 1987, 1993, 1994
+ *	The Regents of the University of California.  All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ * 3. All advertising materials mentioning features or use of this software
+ *    must display the following acknowledgement:
+ *	This product includes software developed by the University of
+ *	California, Berkeley and its contributors.
+ * 4. Neither the name of the University nor the names of its contributors
+ *    may be used to endorse or promote products derived from this software
+ *    without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE REGENTS AND CONTRIBUTORS ``AS IS'' AND
+ * ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE REGENTS OR CONTRIBUTORS BE LIABLE
+ * FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
+ * LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY
+ * OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
+ * SUCH DAMAGE.
+ */
+
+/* last review : october 29th, 2002 */
+
+#if defined(LIBC_SCCS) && !defined(lint)
+static char sccsid[] = "@(#)getopt.c	8.3 (Berkeley) 4/27/95";
+#endif				/* LIBC_SCCS and not lint */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+int opterr = 1,			/* if error message should be printed */
+  optind = 1,			/* index into parent argv vector */
+  optopt,			/* character checked for validity */
+  optreset;			/* reset getopt */
+char *optarg;			/* argument associated with option */
+
+#define	BADCH	(int)'?'
+#define	BADARG	(int)':'
+#define	EMSG	""
+
+/*
+ * getopt --
+ *	Parse argc/argv argument vector.
+ */
+int getopt(nargc, nargv, ostr)
+int nargc;
+char *const *nargv;
+const char *ostr;
+{
+#  define __progname nargv[0]
+  static char *place = EMSG;	/* option letter processing */
+  char *oli;			/* option letter list index */
+
+  if (optreset || !*place) {	/* update scanning pointer */
+    optreset = 0;
+    if (optind >= nargc || *(place = nargv[optind]) != '-') {
+      place = EMSG;
+      return (-1);
+    }
+    if (place[1] && *++place == '-') {	/* found "--" */
+      ++optind;
+      place = EMSG;
+      return (-1);
+    }
+  }				/* option letter okay? */
+  if ((optopt = (int) *place++) == (int) ':' ||
+      !(oli = strchr(ostr, optopt))) {
+    /*
+     * if the user didn't specify '-' as an option,
+     * assume it means -1.
+     */
+    if (optopt == (int) '-')
+      return (-1);
+    if (!*place)
+      ++optind;
+    if (opterr && *ostr != ':')
+      (void) fprintf(stderr,
+		     "%s: illegal option -- %c\n", __progname, optopt);
+    return (BADCH);
+  }
+  if (*++oli != ':') {		/* don't need argument */
+    optarg = NULL;
+    if (!*place)
+      ++optind;
+  } else {			/* need an argument */
+    if (*place)			/* no white space */
+      optarg = place;
+    else if (nargc <= ++optind) {	/* no arg */
+      place = EMSG;
+      if (*ostr == ':')
+	return (BADARG);
+      if (opterr)
+	(void) fprintf(stderr,
+		       "%s: option requires an argument -- %c\n",
+		       __progname, optopt);
+      return (BADCH);
+    } else			/* white space */
+      optarg = nargv[optind];
+    place = EMSG;
+    ++optind;
+  }
+  return (optopt);		/* dump back option letter */
+}
diff -urN /home/robin/sldeb/trunk/mj2/compat/.svn/text-base/getopt.h.svn-base ./mj2/compat/.svn/text-base/getopt.h.svn-base
--- /home/robin/sldeb/trunk/mj2/compat/.svn/text-base/getopt.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/compat/.svn/text-base/getopt.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,14 @@
+/* last review : october 29th, 2002 */
+
+#ifndef _GETOPT_H_
+#define _GETOPT_H_
+
+extern int opterr;
+extern int optind;
+extern int optopt;
+extern int optreset;
+extern char *optarg;
+
+extern int getopt(int nargc, char *const *nargv, const char *ostr);
+
+#endif				/* _GETOPT_H_ */
diff -urN /home/robin/sldeb/trunk/mj2/extract_j2k_from_mj2.c ./mj2/extract_j2k_from_mj2.c
--- /home/robin/sldeb/trunk/mj2/extract_j2k_from_mj2.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/extract_j2k_from_mj2.c	2007-11-27 22:39:49.000000000 +0000
@@ -26,7 +26,13 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
 #include "mj2.h"
 
 /* -------------------------------------------------------------------------- */
diff -urN /home/robin/sldeb/trunk/mj2/frames_to_mj2.c ./mj2/frames_to_mj2.c
--- /home/robin/sldeb/trunk/mj2/frames_to_mj2.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/frames_to_mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -25,7 +25,15 @@
 * POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
 #include "mj2.h"
 #include "mj2_convert.h"
 #include "compat/getopt.h"
@@ -78,13 +86,6 @@
   fprintf
     (stdout,"COD and QCD never appear in the tile_header.\n");
   fprintf(stdout,"\n");
-  fprintf
-    (stdout,"- This coder can encode a mega image, a test was made on a 24000x24000 pixels \n");
-  fprintf
-    (stdout,"color image.  You need enough disk space memory (twice the original) to encode \n");
-  fprintf
-    (stdout,"the image,i.e. for a 1.5 GB image you need a minimum of 3GB of disk memory)\n");
-  fprintf(stdout,"\n");
   fprintf(stdout,"By default:\n");
   fprintf(stdout,"------------\n");
   fprintf(stdout,"\n");
@@ -149,8 +150,6 @@
   fprintf
     (stdout,"                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
   fprintf
-    (stdout,"-x           : create an index file *.Idx (-x index_name.Idx) \n");
-  fprintf
     (stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
   fprintf
     (stdout,"               for component c=%%d [%%d = 0,1,2]\n");
@@ -248,7 +247,7 @@
 	opj_cinfo_t* cinfo;
   bool bSuccess;
 	int numframes;
-	double total_time = 0;
+	double total_time = 0;	
 
   /* default value */
   /* ------------- */
@@ -258,8 +257,7 @@
   mj2_parameters.h = 288;			// CIF default value
   mj2_parameters.CbCr_subsampling_dx = 2;	// CIF default value
   mj2_parameters.CbCr_subsampling_dy = 2;	// CIF default value
-  mj2_parameters.frame_rate = 25;
-  
+  mj2_parameters.frame_rate = 25;	  
 	/*
 	configure the event callbacks (not required)
 	setting of each callback is optionnal
@@ -282,10 +280,12 @@
 		sprintf(j2k_parameters->cp_comment,"%s%s", comment, version);
 	}
 
+	mj2_parameters.decod_format = 0;
+	mj2_parameters.cod_format = 0;
 
   while (1) {
     int c = getopt(argc, argv,
-      "i:o:r:q:f:t:n:c:b:x:p:s:d:h P:S:E:M:R:T:C:I:W:F:");
+      "i:o:r:q:f:t:n:c:b:p:s:d:h P:S:E:M:R:T:C:I:W:F:");
     if (c == -1)
       break;
     switch (c) {
@@ -468,14 +468,6 @@
 			}
 			break;
       /* ----------------------------------------------------- */
-    case 'x':			/* creation of index file */
-      {
-				char *index = optarg;
-				strncpy(j2k_parameters->index, index, sizeof(j2k_parameters->index)-1);
-				j2k_parameters->index_on = 1;
-			}
-			break;
-      /* ----------------------------------------------------- */
     case 'p':			/* progression order */
 			{
 				char progression[4];
@@ -617,7 +609,7 @@
     
   /* Error messages */
   /* -------------- */
-  if (!mj2_parameters.infile || !mj2_parameters.outfile) {
+	if (!mj2_parameters.cod_format || !mj2_parameters.decod_format) {
     fprintf(stderr,
       "Correct usage: mj2_encoder -i yuv-file -o mj2-file (+ options)\n");
     return 1;
@@ -688,8 +680,8 @@
 	mj2_setup_encoder(movie, &mj2_parameters);   
   
   movie->tk[0].num_samples = yuv_num_frames(&movie->tk[0],mj2_parameters.infile); 
-  if (!movie->tk[0].num_samples) {
-    fprintf(stderr,"Unable to count the number of frames in YUV input file\n");
+  if (movie->tk[0].num_samples == -1) {
+		return 1;
   }
   
   // One sample per chunk
@@ -712,8 +704,9 @@
   cio_write(cio, MJ2_MDAT, 4);	
   fwrite(buf,cio_tell(cio),1,mj2file);
   offset = cio_tell(cio);
-  opj_free(buf);
-  
+  opj_cio_close(cio);
+  free(buf);
+
   for (i = 0; i < movie->num_stk + movie->num_htk + movie->num_vtk; i++) {
     if (movie->tk[i].track_type != 0) {
       fprintf(stderr, "Unable to write sound or hint tracks\n");
@@ -734,7 +727,7 @@
       for (sampleno = 0; sampleno < numframes; sampleno++) {		
 				double init_time = opj_clock();
 				double elapsed_time;
-				if (!yuvtoimage(tk, img, sampleno, j2k_parameters, mj2_parameters.infile)) {
+				if (yuvtoimage(tk, img, sampleno, j2k_parameters, mj2_parameters.infile)) {
 					fprintf(stderr, "Error with frame number %d in YUV file\n", sampleno);
 					return 1;
 				}
@@ -748,7 +741,7 @@
 				cio_write(cio, JP2_JP2C, 4);	// JP2C
 
 				/* encode the image */
-				bSuccess = opj_encode(cinfo, cio, img, j2k_parameters->index);
+				bSuccess = opj_encode(cinfo, cio, img, NULL);
 				if (!bSuccess) {
 					opj_cio_close(cio);
 					fprintf(stderr, "failed to encode image\n");
@@ -758,6 +751,7 @@
 				len = cio_tell(cio) - 8;
 				cio_seek(cio, 0);
 				cio_write(cio, len+8,4);
+				opj_cio_close(cio);
 				tk->sample[sampleno].sample_size = len+8;				
 				tk->sample[sampleno].offset = offset;
 				tk->chunk[sampleno].offset = offset;	// There is one sample per chunk 
@@ -769,7 +763,7 @@
 
       }
 			/* free buffer data */
-			opj_free(buf);
+			free(buf);
 			/* free image data */
 			opj_image_destroy(img);
     }
@@ -784,13 +778,14 @@
   cio_write(cio, offset - mdat_initpos, 4);
   fwrite(buf, 4, 1, mj2file);
   fseek(mj2file,0,SEEK_END);
-  opj_free(buf);
-  
+  free(buf);
+
   // Writing MOOV box 
 	buf = (char*) malloc ((TEMP_BUF+numframes*20) * sizeof(char));
 	cio = opj_cio_open(movie->cinfo, buf, (TEMP_BUF+numframes*20));
 	mj2_write_moov(movie, cio);
   fwrite(buf,cio_tell(cio),1,mj2file);
+  free(buf);
 
 	fprintf(stdout,"Total encoding time: %.2f s for %d frames (%.1f fps)\n", total_time, numframes, (float)numframes/total_time);
   
Binary files /home/robin/sldeb/trunk/mj2/frames_to_mj2.sln and ./mj2/frames_to_mj2.sln differ
diff -urN /home/robin/sldeb/trunk/mj2/frames_to_mj2.vcproj ./mj2/frames_to_mj2.vcproj
--- /home/robin/sldeb/trunk/mj2/frames_to_mj2.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/frames_to_mj2.vcproj	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,406 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="frames_to_mj2"
+	ProjectGUID="{4C7685BB-E216-488C-8675-FF5A54FEDDDD}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/frames_to_mj2.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/frames_to_mj2.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\frames_to_mj2___Win32_Debug0"
+			IntermediateDirectory=".\frames_to_mj2___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pch"
+				AssemblerListingLocation=".\frames_to_mj2___Win32_Debug0/"
+				ObjectFile=".\frames_to_mj2___Win32_Debug0/"
+				ProgramDataBaseFileName=".\frames_to_mj2___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="frames_to_mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Libopenjpeg Header files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/mj2.c ./mj2/mj2.c
--- /home/robin/sldeb/trunk/mj2/mj2.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -96,9 +96,8 @@
   movie->brand = MJ2_MJ2;
   movie->minversion = 0;
   movie->num_cl = 2;
-  movie->cl =
-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
-	
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
   movie->cl[0] = MJ2_MJ2;
   movie->cl[1] = MJ2_MJ2S;
   time(&ltime);			/* Time since 1/1/70 */
@@ -139,9 +138,7 @@
       tk->same_sample_size = 0;
 			
       tk->num_samplestochunk = 1;	/* One sample per chunk                                      */
-      tk->sampletochunk =
-				(mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
-				sizeof(mj2_sampletochunk_t));
+		tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
       tk->sampletochunk[0].first_chunk = 1;
       tk->sampletochunk[0].samples_per_chunk = 1;
       tk->sampletochunk[0].sample_descr_idx = 1;
@@ -158,7 +155,7 @@
       }
 			
       tk->num_tts = 1;
-      tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
+		tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
       tk->tts[0].sample_count = tk->num_samples;
       tk->tts[0].sample_delta = tk->timescale / tk->sample_rate;
 			
@@ -196,7 +193,7 @@
       tk->or_fieldcount = 1;
       tk->or_fieldorder = 0;
       tk->num_br = 2;
-      tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
+		tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
       tk->br[0] = MJ2_JP2;
       tk->br[1] = MJ2_J2P0;
       tk->num_jp2x = 0;
@@ -226,10 +223,9 @@
   for (i = 0; i < tk->num_tts; i++) {
     tk->num_samples += tk->tts[i].sample_count;
   }
-	
-  tk->sample =
-    (mj2_sample_t *) malloc(tk->num_samples * sizeof(mj2_sample_t));
-	
+
+  tk->sample = (mj2_sample_t*) opj_malloc(tk->num_samples * sizeof(mj2_sample_t));
+
   for (i = 0; i < tk->num_tts; i++) {
     for (j = 0; j < tk->tts[i].sample_count; j++) {
       tk->sample[j].sample_delta = tk->tts[i].sample_delta;
@@ -251,15 +247,13 @@
     tk->num_chunks =
       (unsigned int) ceil((double) tk->num_samples /
       (double) tk->sampletochunk[0].samples_per_chunk);
-    tk->chunk =
-      (mj2_chunk_t *) malloc(tk->num_chunks * sizeof(mj2_chunk_t));
+	 tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_chunks * sizeof(mj2_chunk_t));
     for (k = 0; k < tk->num_chunks; k++) {
       tk->chunk[k].num_samples = tk->sampletochunk[0].samples_per_chunk;
     }
     
   } else {
-    tk->chunk =
-      (mj2_chunk_t *) malloc(tk->num_samples * sizeof(mj2_chunk_t));
+    tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_samples * sizeof(mj2_chunk_t));
     tk->num_chunks = 0;
     for (i = 0; i < tk->num_samplestochunk -1 ; i++) {
       for (j = tk->sampletochunk[i].first_chunk - 1;
@@ -275,7 +269,7 @@
       tk->chunk[k].num_samples =
 				tk->sampletochunk[tk->num_samplestochunk - 1].samples_per_chunk;
     }
-    tk->chunk = realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
+    tk->chunk = opj_realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
   }
   
 }
@@ -396,9 +390,8 @@
   movie->brand = cio_read(cio, 4);	/* BR              */
   movie->minversion = cio_read(cio, 4);	/* MinV            */
   movie->num_cl = (box.length - 16) / 4;
-  movie->cl =
-    (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
-	
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
   for (i = movie->num_cl - 1; i > -1; i--)
     movie->cl[i] = cio_read(cio, 4);	/* CLi */
 	
@@ -643,12 +636,9 @@
   }
 	
   tk->num_samplestochunk = cio_read(cio, 4);
-	
-  tk->sampletochunk =
-    (mj2_sampletochunk_t *) malloc(tk->num_samplestochunk *
-		sizeof(mj2_sampletochunk_t));
-	
-	
+
+  tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
+
   for (i = 0; i < tk->num_samplestochunk; i++) {
     tk->sampletochunk[i].first_chunk = cio_read(cio, 4);
     tk->sampletochunk[i].samples_per_chunk = cio_read(cio, 4);
@@ -725,9 +715,9 @@
   }
 	
   tk->num_tts = cio_read(cio, 4);
-	
-  tk->tts = (mj2_tts_t *) malloc(tk->num_tts * sizeof(mj2_tts_t));
-	
+
+  tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
+
   for (i = 0; i < tk->num_tts; i++) {
     tk->tts[i].sample_count = cio_read(cio, 4);
     tk->tts[i].sample_delta = cio_read(cio, 4);
@@ -905,8 +895,8 @@
 	
 	
   tk->num_br = (box.length - 12) / 4;
-  tk->br = (unsigned int *) malloc(tk->num_br * sizeof(unsigned int));
-	
+  tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
+
   for (i = 0; i < tk->num_br; i++) {
     tk->br[i] = cio_read(cio, 4);
   }
@@ -964,9 +954,8 @@
 	
 	
   tk->num_jp2x = (box.length - 8);
-  tk->jp2xdata =
-    (unsigned char *) malloc(tk->num_jp2x * sizeof(unsigned char));
-	
+  tk->jp2xdata = (unsigned char*) opj_malloc(tk->num_jp2x * sizeof(unsigned char));
+
   for (i = 0; i < tk->num_jp2x; i++) {
     tk->jp2xdata[i] = cio_read(cio, 1);
   }
@@ -1172,10 +1161,10 @@
 		opj_event_msg(tk->cinfo, EVT_ERROR, "Error reading JP2H Box\n");
     return 1;
   }
-  
-  tk->jp2_struct.comps = (opj_jp2_comps_t *) malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
-  tk->jp2_struct.cl = (int *) malloc(sizeof(int));
-	
+
+  tk->jp2_struct.comps = (opj_jp2_comps_t*) opj_malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
+  tk->jp2_struct.cl = (int*) opj_malloc(sizeof(int));
+
   tk->num_br = 0;
   tk->num_jp2x = 0;
 	
@@ -2046,8 +2035,8 @@
   cio_skip(cio,12);			/* Reserved */
 	
   tk->name_size = box.length - 32;
-	
-  tk->name = (char *) malloc(tk->name_size * sizeof(char));
+
+  tk->name = (char*) opj_malloc(tk->name_size * sizeof(char));
   for (i = 0; i < tk->name_size; i++) {
     tk->name[i] = cio_read(cio, 1);	/* Name */
   }
@@ -2081,7 +2070,7 @@
   cio_write(cio, tk->creation_time, 4);	/* Creation Time */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, modification_time, 4);	/* Modification Time */
 	
@@ -2224,7 +2213,7 @@
   cio_write(cio, 3, 4);		/* Version=0, flags=3 */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  tk->modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  tk->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, tk->creation_time, 4);	/* Creation Time */
 	
@@ -2416,7 +2405,7 @@
   cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
 	
   time(&ltime);			/* Time since 1/1/70 */
-  movie->modification_time = ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+  movie->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
 	
   cio_write(cio, movie->creation_time, 4);	/* Creation Time */
 	
@@ -2581,10 +2570,9 @@
 	
   if (mj2_read_mvhd(movie, cio))
     return 1;
-	
-  movie->tk =
-    (mj2_tk_t *) malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
-	
+
+  movie->tk = (mj2_tk_t*) opj_malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
+
   for (i = 0; cio_tell(cio) - box.init_pos < box.length; i++) {
 		mj2_tk_t *tk = &movie->tk[i];
 		tk->cinfo = movie->cinfo;
@@ -2622,8 +2610,8 @@
 	opj_cio_t *cio;
 	
 	/* open a byte stream for reading */	
-	src = (char*) malloc (300 * sizeof(char));	
-	  
+	src = (char*) opj_malloc(300 * sizeof(char));	
+
 	/* Assuming that jp and ftyp markers size do
      not exceed 300 bytes */
   fread(src,300,1, file);  
@@ -2706,7 +2694,7 @@
   }	
 
   fseek(file,foffset,SEEK_SET);
-  src = realloc(src,box.length);
+  src = opj_realloc(src,box.length);
   fsresult = fread(src,box.length,1,file);
   if (fsresult != 1) {
     opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MOOV box\n"); 
@@ -2717,8 +2705,8 @@
   
   if (mj2_read_moov(movie, &img, cio))
     return 1;
-  
-  free(src);
+
+  opj_free(src);
   return 0;
 }
 
@@ -2728,12 +2716,12 @@
 
 opj_dinfo_t* mj2_create_decompress() {
 	opj_mj2_t* mj2;
-	opj_dinfo_t *dinfo = (opj_dinfo_t*)opj_malloc(sizeof(opj_dinfo_t));
+	opj_dinfo_t *dinfo = (opj_dinfo_t*) opj_calloc(1, sizeof(opj_dinfo_t));
 	if(!dinfo) return NULL;
 
 	dinfo->is_decompressor = true;	
 
-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
 	dinfo->mj2_handle = mj2;
 	if(mj2) {
 		mj2->cinfo = (opj_common_ptr)dinfo;
@@ -2748,8 +2736,10 @@
 	movie->num_vtk=0;
   movie->num_stk=0;
   movie->num_htk=0;	
+
 	/* setup the J2K decoder parameters */
 	j2k_setup_decoder(movie->cinfo->j2k_handle, &mj2_parameters->j2k_parameters);
+
 }
 
 void mj2_destroy_decompress(opj_mj2_t *movie) {
@@ -2757,9 +2747,8 @@
 		int i;
 		mj2_tk_t *tk=NULL;
 
-		if (movie->cinfo->j2k_handle) {
+		if (movie->cinfo->j2k_handle) 
 			j2k_destroy_compress(movie->j2k);
-		}
 		
 		if (movie->num_cl != 0)
 			opj_free(movie->cl);
@@ -2805,10 +2794,10 @@
 
 opj_cinfo_t* mj2_create_compress() {
 	opj_mj2_t* mj2;
-	opj_cinfo_t *cinfo = (opj_cinfo_t*)opj_malloc(sizeof(opj_cinfo_t));
+	opj_cinfo_t *cinfo = (opj_cinfo_t*) opj_calloc(1, sizeof(opj_cinfo_t));
 	if(!cinfo) return NULL;
 
-  mj2 = (opj_mj2_t*)opj_malloc(sizeof(opj_mj2_t));
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
 	cinfo->mj2_handle = mj2;
 	if(mj2) {
 		mj2->cinfo = (opj_common_ptr)cinfo;
@@ -2830,16 +2819,14 @@
 
 		movie->brand = MJ2_MJ2;  // One brand: MJ2
 		movie->num_cl = 2;	  // Two compatible brands: MJ2 and MJ2S
-		movie->cl = (unsigned int *) malloc(movie->num_cl * sizeof(unsigned int));
+		movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
 		movie->cl[0] = MJ2_MJ2;
 		movie->cl[1] = MJ2_MJ2S;
 		movie->minversion = 0;	  // Minimum version: 0		
 
-		movie->tk = (mj2_tk_t*) malloc (sizeof(mj2_tk_t)); //Memory allocation for the video track
-		movie->tk[0].sample = (mj2_sample_t*) malloc (sizeof(mj2_sample_t));
-		movie->tk[0].chunk = (mj2_chunk_t *) malloc(sizeof(mj2_chunk_t));  
-		movie->tk[0].track_type = 0;	  // Video track
+		movie->tk = (mj2_tk_t*) opj_malloc(sizeof(mj2_tk_t)); //Memory allocation for the video track
 		movie->tk[0].track_ID = 1;	  // Track ID = 1 
+		movie->tk[0].track_type = 0;	  // Video track
 		movie->tk[0].Dim[0] = parameters->Dim[0];
 		movie->tk[0].Dim[1] = parameters->Dim[1];
 		movie->tk[0].w = parameters->w;
@@ -2847,17 +2834,19 @@
 		movie->tk[0].CbCr_subsampling_dx = parameters->CbCr_subsampling_dx;
 		movie->tk[0].CbCr_subsampling_dy = parameters->CbCr_subsampling_dy;
 		movie->tk[0].sample_rate = parameters->frame_rate;
-		
+		movie->tk[0].name_size = 0;
+		movie->tk[0].chunk = (mj2_chunk_t*) opj_malloc(sizeof(mj2_chunk_t));  
+		movie->tk[0].sample = (mj2_sample_t*) opj_malloc(sizeof(mj2_sample_t));
+
 		jp2_struct = &movie->tk[0].jp2_struct;
 		jp2_struct->numcomps = 3;	// NC  		
-		jp2_struct->comps =
-			(opj_jp2_comps_t *) malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
+		jp2_struct->comps = (opj_jp2_comps_t*) opj_malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
 		jp2_struct->precedence = 0;   /* PRECEDENCE*/
 		jp2_struct->approx = 0;   /* APPROX*/		
 		jp2_struct->brand = JP2_JP2;	/* BR         */
 		jp2_struct->minversion = 0;	/* MinV       */
 		jp2_struct->numcl = 1;
-		jp2_struct->cl = (unsigned int *) malloc(jp2_struct->numcl * sizeof(int));
+		jp2_struct->cl = (unsigned int*) opj_malloc(jp2_struct->numcl * sizeof(int));
 		jp2_struct->cl[0] = JP2_JP2;	/* CL0 : JP2  */		
 		jp2_struct->C = 7;      /* C : Always 7*/
 		jp2_struct->UnkC = 0;      /* UnkC, colorspace specified in colr box*/
diff -urN /home/robin/sldeb/trunk/mj2/mj2_convert.c ./mj2/mj2_convert.c
--- /home/robin/sldeb/trunk/mj2/mj2_convert.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2_convert.c	2007-09-28 11:33:42.000000000 +0100
@@ -46,7 +46,7 @@
   f = fopen(infile,"rb");
   if (!f) {  
     fprintf(stderr, "failed to open %s for reading\n",infile);
-    return 1;
+    return -1;
   }
 	
   frame_size = (int) (tk->w * tk->h * (1.0 + (double) 2 / (double) (tk->CbCr_subsampling_dx * tk->CbCr_subsampling_dy)));	/* Calculate frame size */
@@ -58,7 +58,7 @@
     fprintf(stderr,
 			"YUV does not contains any frame of %d x %d size\n", tk->w,
 			tk->h);
-    return 0;
+    return -1;
   }
 	
   numimages = end_of_f / frame_size;	/* Calculate number of images */
@@ -99,7 +99,7 @@
 	return img;
 }
 
-bool yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile)
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile)
 {
   int i, compno;
   int offset;
@@ -111,8 +111,8 @@
 	
   yuvfile = fopen(infile,"rb");
   if (!yuvfile) {  
-    fprintf(stderr, "failed to open %s for reading\n",parameters->infile);
-    return false;
+    fprintf(stderr, "failed to open %s for readings\n",parameters->infile);
+    return 1;
   }
 
   offset = (int) ((double) (frame_num * tk->w * tk->h) * (1.0 +
@@ -125,7 +125,7 @@
     fprintf(stderr, "Cannot reach frame number %d in yuv file !!\n",
 			frame_num);
 		fclose(yuvfile);
-    return false;
+    return 1;
   }
 	
   img->x0 = tk->Dim[0];
@@ -140,13 +140,13 @@
 			&& !feof(yuvfile); i++) {
 			if (!fread(&img->comps[compno].data[i], 1, 1, yuvfile)) {
 				fprintf(stderr, "Error reading %s file !!\n", infile);				
-				return false;
+				return 1;
 			}
 		}
 	}
 	fclose(yuvfile);
 	
-  return true;
+  return 0;
 }
 
 
diff -urN /home/robin/sldeb/trunk/mj2/mj2_convert.h ./mj2/mj2_convert.h
--- /home/robin/sldeb/trunk/mj2/mj2_convert.h	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2_convert.h	2007-09-28 11:33:42.000000000 +0100
@@ -37,7 +37,7 @@
 
 opj_image_t *mj2_image_create(mj2_tk_t * tk, opj_cparameters_t *parameters);
 
-bool yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile);
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile);
 
 int yuv_num_frames(mj2_tk_t * tk, char *infile);
 
diff -urN /home/robin/sldeb/trunk/mj2/MJ2_Extractor.sln ./mj2/MJ2_Extractor.sln
--- /home/robin/sldeb/trunk/mj2/MJ2_Extractor.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/MJ2_Extractor.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Extractor", "MJ2_Extractor.vcproj", "{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.Build.0 = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.ActiveCfg = Release|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/MJ2_Extractor.vcproj ./mj2/MJ2_Extractor.vcproj
--- /home/robin/sldeb/trunk/mj2/MJ2_Extractor.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/MJ2_Extractor.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,354 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Extractor"
+	ProjectGUID="{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/MJ2_Extractor.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Extractor___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Extractor___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\MJ2_Extractor___Win32_Debug/"
+				ObjectFile=".\MJ2_Extractor___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Extractor___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="extract_j2k_from_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/mj2.h ./mj2/mj2.h
--- /home/robin/sldeb/trunk/mj2/mj2.h	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2.h	2007-09-28 11:33:42.000000000 +0100
@@ -80,13 +80,13 @@
 Decompressed format used in parameters
 YUV = 0
 */
-#define YUV_DFMT 0 
+#define YUV_DFMT 1 
 
 /**
 Compressed format used in parameters
 MJ2 = 0
 */
-#define MJ2_CFMT 0
+#define MJ2_CFMT 2
 
 
 /* ----------------------------------------------------------------------- */
diff -urN /home/robin/sldeb/trunk/mj2/mj2_to_frames.c ./mj2/mj2_to_frames.c
--- /home/robin/sldeb/trunk/mj2/mj2_to_frames.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2_to_frames.c	2007-11-27 22:39:50.000000000 +0000
@@ -25,7 +25,14 @@
 * POSSIBILITY OF SUCH DAMAGE.
 */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
 #include "mj2.h"
 #include "mj2_convert.h"
 
@@ -145,6 +152,7 @@
   {
 		double init_time = opj_clock();
 		double elapsed_time;
+
     sample = &track->sample[snum];
 		if (sample->sample_size-8 > max_codstrm_size) {
 			max_codstrm_size =  sample->sample_size-8;
@@ -203,6 +211,7 @@
 	
 	free(frame_codestream);	
   fclose(file);	
+
 	/* free remaining structures */
 	if(dinfo) {
 		mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
diff -urN /home/robin/sldeb/trunk/mj2/mj2_to_frames.sln ./mj2/mj2_to_frames.sln
--- /home/robin/sldeb/trunk/mj2/mj2_to_frames.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/mj2_to_frames.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_frames", "mj2_to_frames.vcproj", "{64325EAD-A083-4C8E-B852-71006428881D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.Build.0 = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.ActiveCfg = Release|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/mj2_to_frames.vcproj ./mj2/mj2_to_frames.vcproj
--- /home/robin/sldeb/trunk/mj2/mj2_to_frames.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/mj2_to_frames.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,324 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="mj2_to_frames"
+	ProjectGUID="{64325EAD-A083-4C8E-B852-71006428881D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_frames___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_frames___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pch"
+				AssemblerListingLocation=".\mj2_to_frames___Win32_Debug0/"
+				ObjectFile=".\mj2_to_frames___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_frames___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib libcmtd.lib"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_frames.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_frames.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_frames.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Headers"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/mj2_to_metadata.sln ./mj2/mj2_to_metadata.sln
--- /home/robin/sldeb/trunk/mj2/mj2_to_metadata.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/mj2_to_metadata.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_metadata", "mj2_to_metadata.vcproj", "{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD} = {0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.Build.0 = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.ActiveCfg = Release|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.Build.0 = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.ActiveCfg = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.Build.0 = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.ActiveCfg = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/mj2_to_metadata.vcproj ./mj2/mj2_to_metadata.vcproj
--- /home/robin/sldeb/trunk/mj2/mj2_to_metadata.vcproj	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/mj2_to_metadata.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -1,134 +1,201 @@
 <?xml version="1.0" encoding="Windows-1252"?>
 <VisualStudioProject
 	ProjectType="Visual C++"
-	Version="7.10"
+	Version="8,00"
 	Name="mj2_to_metadata"
-	ProjectGUID="{338C1241-ACB9-469F-98DF-3B9D79ADD1A0}"
-	SccProjectName=""
-	SccLocalPath="">
+	ProjectGUID="{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	>
 	<Platforms>
 		<Platform
-			Name="Win32"/>
+			Name="Win32"
+		/>
 	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
 	<Configurations>
 		<Configuration
-			Name="Release|Win32"
-			OutputDirectory=".\Release"
-			IntermediateDirectory=".\Release"
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_metadata___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_metadata___Win32_Debug0"
 			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
 			<Tool
 				Name="VCCLCompilerTool"
-				InlineFunctionExpansion="1"
-				AdditionalIncludeDirectories="../libopenjpeg_097"
-				PreprocessorDefinitions="WIN32,NDEBUG,_CONSOLE,DONT_HAVE_GETOPT,NO_PACKETS_DECODING"
-				StringPooling="TRUE"
-				RuntimeLibrary="4"
-				EnableFunctionLevelLinking="TRUE"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\Release/mj2_to_metadata.pch"
-				AssemblerListingLocation=".\Release/"
-				ObjectFile=".\Release/"
-				ProgramDataBaseFileName=".\Release/"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\mj2_to_metadata___Win32_Debug0/"
+				ObjectFile=".\mj2_to_metadata___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_metadata___Win32_Debug0/"
+				BrowseInformation="1"
 				WarningLevel="3"
-				SuppressStartupBanner="TRUE"/>
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="odbc32.lib odbccp32.lib"
-				OutputFile=".\Release/mj2_to_metadata.exe"
-				LinkIncremental="1"
-				SuppressStartupBanner="TRUE"
-				ProgramDatabaseFile=".\Release/mj2_to_metadata.pdb"
-				SubSystem="1"/>
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
 			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\Release/mj2_to_metadata.tlb"/>
+				Name="VCPreLinkEventTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCLinkerTool"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCALinkTool"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCManifestTool"
+			/>
 			<Tool
-				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="NDEBUG"
-				Culture="2057"/>
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.bsc"
+			/>
 			<Tool
-				Name="VCXMLDataGeneratorTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCWebDeploymentTool"/>
+				Name="VCAppVerifierTool"
+			/>
 			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
+				Name="VCWebDeploymentTool"
+			/>
 			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 		<Configuration
-			Name="Debug|Win32"
-			OutputDirectory=".\mj2_to_metadata___Win32_Debug0"
-			IntermediateDirectory=".\mj2_to_metadata___Win32_Debug0"
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
 			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
 			UseOfMFC="0"
-			ATLMinimizesCRunTimeLibraryUsage="FALSE"
-			CharacterSet="2">
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
 			<Tool
-				Name="VCCLCompilerTool"
-				Optimization="0"
-				AdditionalIncludeDirectories="../libopenjpeg_097"
-				PreprocessorDefinitions="WIN32,_DEBUG,_CONSOLE,DONT_HAVE_GETOPT,NO_PACKETS_DECODING"
-				BasicRuntimeChecks="3"
-				RuntimeLibrary="5"
-				UsePrecompiledHeader="2"
-				PrecompiledHeaderFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pch"
-				AssemblerListingLocation=".\mj2_to_metadata___Win32_Debug0/"
-				ObjectFile=".\mj2_to_metadata___Win32_Debug0/"
-				ProgramDataBaseFileName=".\mj2_to_metadata___Win32_Debug0/"
-				WarningLevel="3"
-				SuppressStartupBanner="TRUE"
-				DebugInformationFormat="0"/>
+				Name="VCPreBuildEventTool"
+			/>
 			<Tool
-				Name="VCCustomBuildTool"/>
+				Name="VCCustomBuildTool"
+			/>
 			<Tool
-				Name="VCLinkerTool"
-				AdditionalOptions="/MACHINE:I386"
-				AdditionalDependencies="odbc32.lib odbccp32.lib"
-				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.exe"
-				LinkIncremental="2"
-				SuppressStartupBanner="TRUE"
-				GenerateDebugInformation="TRUE"
-				ProgramDatabaseFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pdb"
-				SubSystem="1"/>
+				Name="VCXMLDataGeneratorTool"
+			/>
 			<Tool
-				Name="VCMIDLTool"
-				TypeLibraryName=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.tlb"/>
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
 			<Tool
-				Name="VCPostBuildEventTool"/>
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
 			<Tool
-				Name="VCPreBuildEventTool"/>
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
 			<Tool
-				Name="VCPreLinkEventTool"/>
+				Name="VCManagedResourceCompilerTool"
+			/>
 			<Tool
 				Name="VCResourceCompilerTool"
-				PreprocessorDefinitions="_DEBUG"
+				PreprocessorDefinitions="NDEBUG"
 				Culture="2057"
-				AdditionalIncludeDirectories=""
-				ResourceOutputFileName=""/>
+			/>
 			<Tool
-				Name="VCWebServiceProxyGeneratorTool"/>
+				Name="VCPreLinkEventTool"
+			/>
 			<Tool
-				Name="VCXMLDataGeneratorTool"/>
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_metadata.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				ProgramDatabaseFile=".\Release/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
 			<Tool
-				Name="VCWebDeploymentTool"/>
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_metadata.bsc"
+			/>
 			<Tool
-				Name="VCManagedWrapperGeneratorTool"/>
+				Name="VCFxCopTool"
+			/>
 			<Tool
-				Name="VCAuxiliaryManagedWrapperGeneratorTool"/>
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
 		</Configuration>
 	</Configurations>
 	<References>
@@ -136,144 +203,146 @@
 	<Files>
 		<Filter
 			Name="MJ2"
-			Filter="">
-			<File
-				RelativePath=".\compat\getopt.c">
-			</File>
-			<File
-				RelativePath=".\compat\getopt.h">
-			</File>
-			<File
-				RelativePath=".\meta_out.c">
-			</File>
-			<File
-				RelativePath=".\meta_out.h">
-			</File>
-			<File
-				RelativePath=".\mj2.c">
-			</File>
-			<File
-				RelativePath=".\mj2.h">
-			</File>
-			<File
-				RelativePath=".\mj2_convert.c">
-			</File>
-			<File
-				RelativePath=".\mj2_convert.h">
-			</File>
-			<File
-				RelativePath=".\mj2_to_metadata.c">
-			</File>
-			<File
-				RelativePath=".\mj2_to_metadata.h">
-			</File>
-		</Filter>
-		<Filter
-			Name="libopenjpeg_097"
-			Filter="">
-			<File
-				RelativePath="..\libopenjpeg_097\bio.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\bio.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\cio.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\cio.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\dwt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\dwt.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\fix.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\fix.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\int.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\int.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\j2k.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\j2k.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jp2.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jp2.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jpt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\jpt.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mct.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mct.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mqc.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\mqc.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\openjpeg.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\pi.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\pi.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\raw.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\raw.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t1.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t1.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t2.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\t2.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tcd.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tcd.h">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tgt.c">
-			</File>
-			<File
-				RelativePath="..\libopenjpeg_097\tgt.h">
-			</File>
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="meta_out.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="meta_out.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
 		</Filter>
-		<File
-			RelativePath="resource.h">
-		</File>
 	</Files>
 	<Globals>
 	</Globals>
diff -urN /home/robin/sldeb/trunk/mj2/MJ2_Wrapper.sln ./mj2/MJ2_Wrapper.sln
--- /home/robin/sldeb/trunk/mj2/MJ2_Wrapper.sln	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/MJ2_Wrapper.sln	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Wrapper", "MJ2_Wrapper.vcproj", "{87C98B26-E658-4992-8810-201C3CE67011}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.ActiveCfg = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.Build.0 = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.ActiveCfg = Release|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/MJ2_Wrapper.vcproj ./mj2/MJ2_Wrapper.vcproj
--- /home/robin/sldeb/trunk/mj2/MJ2_Wrapper.vcproj	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/MJ2_Wrapper.vcproj	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,353 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Wrapper"
+	ProjectGUID="{87C98B26-E658-4992-8810-201C3CE67011}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/MJ2_Wrapper.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Wrapper___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Wrapper___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\MJ2_Wrapper___Win32_Debug/"
+				ObjectFile=".\MJ2_Wrapper___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Wrapper___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="wrap_j2k_in_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/all-wcprops ./mj2/.svn/all-wcprops
--- /home/robin/sldeb/trunk/mj2/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/all-wcprops	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,227 @@
+K 25
+svn:wc:ra_dav:version-url
+V 27
+/svn/!svn/ver/470/trunk/mj2
+END
+frames_to_mj2.sln
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/415/trunk/mj2/frames_to_mj2.sln
+END
+mj2_to_frames.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/mj2_to_frames.dsw
+END
+MJ2_Wrapper.sln
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/415/trunk/mj2/MJ2_Wrapper.sln
+END
+mj2_to_metadata.sln
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/456/trunk/mj2/mj2_to_metadata.sln
+END
+mj2_to_frames.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/415/trunk/mj2/mj2_to_frames.vcproj
+END
+MJ2_Wrapper.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 46
+/svn/!svn/ver/415/trunk/mj2/MJ2_Wrapper.vcproj
+END
+extract_j2k_from_mj2.c
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/467/trunk/mj2/extract_j2k_from_mj2.c
+END
+mj2_to_metadata.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/456/trunk/mj2/mj2_to_metadata.vcproj
+END
+meta_out.c
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/459/trunk/mj2/meta_out.c
+END
+meta_out.h
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/381/trunk/mj2/meta_out.h
+END
+mj2_to_metadata_Notes.doc
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata_Notes.doc
+END
+MJ2_Extractor.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/MJ2_Extractor.dsp
+END
+frames_to_mj2.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/467/trunk/mj2/frames_to_mj2.c
+END
+mj2.c
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/467/trunk/mj2/mj2.c
+END
+mj2_to_metadata.c
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata.c
+END
+frames_to_mj2.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/frames_to_mj2.dsp
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/457/trunk/mj2/CMakeLists.txt
+END
+MJ2_Wrapper.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/381/trunk/mj2/MJ2_Wrapper.dsp
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/381/trunk/mj2/Makefile
+END
+mj2.h
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/416/trunk/mj2/mj2.h
+END
+mj2_to_metadata.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata.dsp
+END
+MJ2_Extractor.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/MJ2_Extractor.dsw
+END
+mj2_to_metadata.h
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata.h
+END
+mj2_to_frames.sln
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/415/trunk/mj2/mj2_to_frames.sln
+END
+frames_to_mj2.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/frames_to_mj2.dsw
+END
+MJ2_Wrapper.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/381/trunk/mj2/MJ2_Wrapper.dsw
+END
+MJ2_Extractor.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/415/trunk/mj2/MJ2_Extractor.vcproj
+END
+mj2_to_metadata.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata.dsw
+END
+frames_to_mj2.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/467/trunk/mj2/frames_to_mj2.vcproj
+END
+wrap_j2k_in_mj2.c
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/470/trunk/mj2/wrap_j2k_in_mj2.c
+END
+mj2_to_metadata.dtd
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/381/trunk/mj2/mj2_to_metadata.dtd
+END
+mj2_to_frames.c
+K 25
+svn:wc:ra_dav:version-url
+V 43
+/svn/!svn/ver/467/trunk/mj2/mj2_to_frames.c
+END
+mj2_convert.c
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/416/trunk/mj2/mj2_convert.c
+END
+readme.txt
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/381/trunk/mj2/readme.txt
+END
+mj2_to_frames.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/381/trunk/mj2/mj2_to_frames.dsp
+END
+mj2_convert.h
+K 25
+svn:wc:ra_dav:version-url
+V 41
+/svn/!svn/ver/416/trunk/mj2/mj2_convert.h
+END
+MJ2_Extractor.sln
+K 25
+svn:wc:ra_dav:version-url
+V 45
+/svn/!svn/ver/415/trunk/mj2/MJ2_Extractor.sln
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/entries ./mj2/.svn/entries
--- /home/robin/sldeb/trunk/mj2/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,498 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/mj2
+http://www.openjpeg.org/svn
+
+
+
+2007-11-05T13:14:51.180032Z
+470
+unipg
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+frames_to_mj2.sln
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+2f700a5229ccc2ef264dedbfe7c22adc
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+mj2_to_frames.dsw
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+3641525b11fdbaf3c424f6c17776b186
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+MJ2_Wrapper.sln
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+5fcd91e9ce2e8a9ab0430bac961aaf4a
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+mj2_to_metadata.sln
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+e9c227628f33649435af4c905efe3fd9
+2007-09-12T08:52:18.479887Z
+456
+devaux
+
+mj2_to_frames.vcproj
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+a4718c1a2b2ce3a1762c8235bb3ccd9b
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+MJ2_Wrapper.vcproj
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+81745ccc93a228d0ad97c8a0096c0b00
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+extract_j2k_from_mj2.c
+file
+
+
+
+
+2007-11-27T22:39:49.000000Z
+2dc1a7fc5030e463d401aea4e8346acd
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+mj2_to_metadata.vcproj
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+ef91609fb93e91016039f70258e6aff8
+2007-09-12T08:52:18.479887Z
+456
+devaux
+has-props
+
+meta_out.c
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+e88c525a849e322da1cbee7a61bf9ec5
+2007-09-17T15:11:20.931490Z
+459
+devaux
+has-props
+
+meta_out.h
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+caeb27f9ef66d6b2ac6c383cdf49258d
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2_to_metadata_Notes.doc
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+95b2f518ef93b8b2d0cc8bff551664fe
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+MJ2_Extractor.dsp
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+9d65da44ef43a37afbfea4da357a9fd3
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+frames_to_mj2.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+6cfb8074fcade49e5c68ad09ce36965c
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+mj2.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+e9175ee448a6d6c31e9ed3d3644bb4b4
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+mj2_to_metadata.c
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+12ab87bdb61633a9204f21e8393b1b58
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+frames_to_mj2.dsp
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+ad55e7562e37e4d45e8243eb5107cf00
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+7a66fdd23ead36a5596d731514001342
+2007-09-12T09:04:03.780208Z
+457
+devaux
+has-props
+
+MJ2_Wrapper.dsp
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+d219d36d40a67b4c483a60395f51b8f2
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+Makefile
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+28484a4c2257b65e488fe1bf2d73c003
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2.h
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+8631251ee1f84fd8361222bafbeea4f3
+2007-08-21T10:18:40.000527Z
+416
+devaux
+has-props
+
+mj2_to_metadata.dsp
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+038d9d936a099cb6f7ec015ad3d0ce19
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+MJ2_Extractor.dsw
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+87f581e5f2fd13043cfeb9a0a8abc711
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+mj2_to_metadata.h
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+91a29fb150306edb6049d5e4c4c220e4
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2_to_frames.sln
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+62b039eeb423be938c30f2d5a2c8c1dd
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+compat
+dir
+
+frames_to_mj2.dsw
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+a2741fcc2b231841a11d9938ceba5be7
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+MJ2_Wrapper.dsw
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+330f05a867ab7b80f854a5f86640df0d
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+MJ2_Extractor.vcproj
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+256b6c6bcb7c14ad1044d73cbfa04dc2
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+mj2_to_metadata.dsw
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+dfab49e894a1030cc1cb43bb534f8997
+2007-05-10T14:21:09.469638Z
+381
+devaux
+
+frames_to_mj2.vcproj
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+2ea2b8e6fbb6d019fc214b632696c458
+2007-10-18T12:26:11.065274Z
+467
+devaux
+
+wrap_j2k_in_mj2.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+2c57c83d2bca651c855c250013dd0e15
+2007-11-05T13:14:51.180032Z
+470
+unipg
+has-props
+
+mj2_to_metadata.dtd
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+a679775a105a452812c7b6cd38b02b29
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2_to_frames.c
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+6f34657c2e2ea064461a68b65662e525
+2007-10-18T12:26:11.065274Z
+467
+devaux
+has-props
+
+mj2_convert.c
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+cfde540f7c1634da685ece765922d60b
+2007-08-21T10:18:40.000527Z
+416
+devaux
+has-props
+
+readme.txt
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+002b54343067491d60f9870b334d5ec2
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2_to_frames.dsp
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+f796f4719a080f9f27ffdd21e8145142
+2007-05-10T14:21:09.469638Z
+381
+devaux
+has-props
+
+mj2_convert.h
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+6c56eeddf0de2d69571a42bbbe581aea
+2007-08-21T10:18:40.000527Z
+416
+devaux
+has-props
+
+MJ2_Extractor.sln
+file
+
+
+
+
+2007-09-28T10:33:42.000000Z
+66cfa978aeb080d17ca206456d1ccf6c
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/format ./mj2/.svn/format
--- /home/robin/sldeb/trunk/mj2/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/format	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/CMakeLists.txt.svn-base ./mj2/.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/CMakeLists.txt.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 13
+svn:mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/extract_j2k_from_mj2.c.svn-base ./mj2/.svn/prop-base/extract_j2k_from_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/extract_j2k_from_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/extract_j2k_from_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/frames_to_mj2.c.svn-base ./mj2/.svn/prop-base/frames_to_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/frames_to_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/frames_to_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/frames_to_mj2.dsp.svn-base ./mj2/.svn/prop-base/frames_to_mj2.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/frames_to_mj2.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/frames_to_mj2.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/Makefile.svn-base ./mj2/.svn/prop-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/Makefile.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/meta_out.c.svn-base ./mj2/.svn/prop-base/meta_out.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/meta_out.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/meta_out.c.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/meta_out.h.svn-base ./mj2/.svn/prop-base/meta_out.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/meta_out.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/meta_out.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_convert.c.svn-base ./mj2/.svn/prop-base/mj2_convert.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_convert.c.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_convert.h.svn-base ./mj2/.svn/prop-base/mj2_convert.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_convert.h.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2.c.svn-base ./mj2/.svn/prop-base/mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/MJ2_Extractor.dsp.svn-base ./mj2/.svn/prop-base/MJ2_Extractor.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/MJ2_Extractor.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/MJ2_Extractor.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2.h.svn-base ./mj2/.svn/prop-base/mj2.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_frames.c.svn-base ./mj2/.svn/prop-base/mj2_to_frames.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_frames.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_frames.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_frames.dsp.svn-base ./mj2/.svn/prop-base/mj2_to_frames.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_frames.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_frames.dsp.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.c.svn-base ./mj2/.svn/prop-base/mj2_to_metadata.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata.c.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.dsp.svn-base ./mj2/.svn/prop-base/mj2_to_metadata.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.dtd.svn-base ./mj2/.svn/prop-base/mj2_to_metadata.dtd.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.dtd.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata.dtd.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.h.svn-base ./mj2/.svn/prop-base/mj2_to_metadata.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata_Notes.doc.svn-base ./mj2/.svn/prop-base/mj2_to_metadata_Notes.doc.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata_Notes.doc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata_Notes.doc.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.vcproj.svn-base ./mj2/.svn/prop-base/mj2_to_metadata.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/mj2_to_metadata.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/mj2_to_metadata.vcproj.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/MJ2_Wrapper.dsp.svn-base ./mj2/.svn/prop-base/MJ2_Wrapper.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/MJ2_Wrapper.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/MJ2_Wrapper.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/readme.txt.svn-base ./mj2/.svn/prop-base/readme.txt.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/readme.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/readme.txt.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/prop-base/wrap_j2k_in_mj2.c.svn-base ./mj2/.svn/prop-base/wrap_j2k_in_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/prop-base/wrap_j2k_in_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/prop-base/wrap_j2k_in_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/CMakeLists.txt.svn-base ./mj2/.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/CMakeLists.txt.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,42 @@
+# Makefile for the MJ2 codecs of the OpenJPEG library: frames_to_mj2, mj2_to_frames, extract_j2k_from_mj2 and wrap_j2k_in_mj2
+
+# Headers file are located here:
+INCLUDE_DIRECTORIES(
+  ${OPENJPEG_SOURCE_DIR}/libopenjpeg
+  )
+
+ADD_EXECUTABLE(frames_to_mj2
+  frames_to_mj2.c
+  compat/getopt.c 
+  mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(frames_to_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(frames_to_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(mj2_to_frames
+    mj2_to_frames.c
+    compat/getopt.c mj2_convert.c mj2.c )
+TARGET_LINK_LIBRARIES(mj2_to_frames ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(mj2_to_frames m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(extract_j2k_from_mj2
+    extract_j2k_from_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(extract_j2k_from_mj2 m)
+ENDIF(UNIX)
+
+ADD_EXECUTABLE(wrap_j2k_in_mj2
+    wrap_j2k_in_mj2.c
+    mj2.c )
+TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 ${OPJ_PREFIX}openjpeg)
+IF(UNIX)
+  TARGET_LINK_LIBRARIES(wrap_j2k_in_mj2 m)
+ENDIF(UNIX)
+
+INSTALL(TARGETS frames_to_mj2 mj2_to_frames extract_j2k_from_mj2 wrap_j2k_in_mj2
+	DESTINATION bin)
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/extract_j2k_from_mj2.c.svn-base ./mj2/.svn/text-base/extract_j2k_from_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/extract_j2k_from_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/extract_j2k_from_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,148 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "mj2.h"
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+int main(int argc, char *argv[]) {
+	opj_dinfo_t* dinfo; 
+	opj_event_mgr_t event_mgr;		/* event manager */
+  int tnum;
+  unsigned int snum;
+  opj_mj2_t *movie;
+  mj2_tk_t *track;
+  mj2_sample_t *sample;
+  unsigned char* frame_codestream;
+  FILE *file, *outfile;
+  char outfilename[50];
+	mj2_dparameters_t parameters;
+
+  if (argc != 3) {
+    printf("Bad syntax: Usage: MJ2_extractor mj2filename output_location\n"); 
+    printf("Example: MJ2_extractor foreman.mj2 output/foreman\n");
+    return 1;
+  }
+  
+  file = fopen(argv[1], "rb");
+  
+  if (!file) {
+    fprintf(stderr, "failed to open %s for reading\n", argv[1]);
+    return 1;
+  }
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* get a MJ2 decompressor handle */
+	dinfo = mj2_create_decompress();
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);		
+
+	/* setup the decoder decoding parameters using user parameters */
+	movie = (opj_mj2_t*) dinfo->mj2_handle;
+	mj2_setup_decoder(dinfo->mj2_handle, &parameters);
+
+  if (mj2_read_struct(file, movie)) // Creating the movie structure
+    return 1;
+
+  // Decode first video track 
+  tnum = 0;
+  while (movie->tk[tnum].track_type != 0)
+    tnum ++;
+
+  track = &movie->tk[tnum];
+
+  fprintf(stdout,"Extracting %d frames from file...\n",track->num_samples);
+
+  for (snum=0; snum < track->num_samples; snum++)
+  {
+    sample = &track->sample[snum];
+    frame_codestream = (unsigned char*) malloc (sample->sample_size-8); // Skipping JP2C marker
+    fseek(file,sample->offset+8,SEEK_SET);
+    fread(frame_codestream,sample->sample_size-8,1, file);  // Assuming that jp and ftyp markers size do
+
+    sprintf(outfilename,"%s_%05d.j2k",argv[2],snum);
+    outfile = fopen(outfilename, "wb");
+    if (!outfile) {
+      fprintf(stderr, "failed to open %s for writing\n",outfilename);
+      return 1;
+    }
+    fwrite(frame_codestream,sample->sample_size-8,1,outfile);
+    fclose(outfile);
+    free(frame_codestream);
+    }
+  fclose(file);
+  fprintf(stdout, "%d frames correctly extracted\n", snum);
+	
+	/* free remaining structures */
+	if(dinfo) {
+		mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
+	}
+	
+  return 0;
+}
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.c.svn-base ./mj2/.svn/text-base/frames_to_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/frames_to_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,806 @@
+/*
+* Copyright (c) 2003-2004, François-Olivier Devaux
+* Copyright (c) 2002-2004,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
+#include "mj2.h"
+#include "mj2_convert.h"
+#include "compat/getopt.h"
+
+/**
+Size of memory first allocated for MOOV box
+*/
+#define TEMP_BUF 10000 
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+void help_display()
+{
+  fprintf(stdout,"HELP\n----\n\n");
+  fprintf(stdout,"- the -h option displays this help information on screen\n\n");
+  
+  
+  fprintf(stdout,"List of parameters for the MJ2 encoder:\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"REMARKS:\n");
+  fprintf(stdout,"---------\n");
+  fprintf(stdout,"\n");
+  fprintf
+    (stdout,"The markers written to the main_header are : SOC SIZ COD QCD COM.\n");
+  fprintf
+    (stdout,"COD and QCD never appear in the tile_header.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"By default:\n");
+  fprintf(stdout,"------------\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout," * Lossless\n");
+  fprintf(stdout," * 1 tile\n");
+  fprintf(stdout," * Size of precinct : 2^15 x 2^15 (means 1 precinct)\n");
+  fprintf(stdout," * Size of code-block : 64 x 64\n");
+  fprintf(stdout," * Number of resolutions: 6\n");
+  fprintf(stdout," * No SOP marker in the codestream\n");
+  fprintf(stdout," * No EPH marker in the codestream\n");
+  fprintf(stdout," * No sub-sampling in x or y direction\n");
+  fprintf(stdout," * No mode switch activated\n");
+  fprintf(stdout," * Progression order: LRCP\n");
+  fprintf(stdout," * No index file\n");
+  fprintf(stdout," * No ROI upshifted\n");
+  fprintf(stdout," * No offset of the origin of the image\n");
+  fprintf(stdout," * No offset of the origin of the tiles\n");
+  fprintf(stdout," * Reversible DWT 5-3\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Parameters:\n");
+  fprintf(stdout,"------------\n");
+  fprintf(stdout,"\n");
+  fprintf
+    (stdout,"Required Parameters (except with -h):\n");
+  fprintf
+    (stdout,"-i           : source file  (-i source.yuv) \n");
+  fprintf
+    (stdout,"-o           : destination file (-o dest.mj2) \n");
+  fprintf
+    (stdout,"Optional Parameters:\n");
+  fprintf(stdout,"-h           : display the help information \n");
+  fprintf(stdout,"-r           : different compression ratios for successive layers (-r 20,10,5)\n ");
+  fprintf(stdout,"	         - The rate specified for each quality level is the desired \n");
+  fprintf(stdout,"	           compression factor.\n");
+  fprintf(stdout,"		   Example: -r 20,10,1 means quality 1: compress 20x, \n");
+  fprintf(stdout,"		     quality 2: compress 10x and quality 3: compress lossless\n");
+  fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+  
+  fprintf(stdout,"-q           : different psnr for successive layers (-q 30,40,50) \n ");
+  
+  fprintf(stdout,"               (options -r and -q cannot be used together)\n ");
+  
+  fprintf(stdout,"-n           : number of resolutions (-n 3) \n");
+  fprintf(stdout,"-b           : size of code block (-b 32,32) \n");
+  fprintf(stdout,"-c           : size of precinct (-c 128,128) \n");
+  fprintf(stdout,"-t           : size of tile (-t 512,512) \n");
+  fprintf
+    (stdout,"-p           : progression order (-p LRCP) [LRCP, RLCP, RPCL, PCRL, CPRL] \n");
+  fprintf
+    (stdout,"-s           : subsampling factor (-s 2,2) [-s X,Y] \n");
+  fprintf(stdout,"	     Remark: subsampling bigger than 2 can produce error\n");
+  fprintf
+    (stdout,"-SOP         : write SOP marker before each packet \n");
+  fprintf
+    (stdout,"-EPH         : write EPH marker after each header packet \n");
+  fprintf
+    (stdout,"-M           : mode switch (-M 3) [1=BYPASS(LAZY) 2=RESET 4=RESTART(TERMALL)\n");
+  fprintf
+    (stdout,"                 8=VSC 16=ERTERM(SEGTERM) 32=SEGMARK(SEGSYM)] \n");
+  fprintf
+    (stdout,"                 Indicate multiple modes by adding their values. \n");
+  fprintf
+    (stdout,"                 ex: RESTART(4) + RESET(2) + SEGMARK(32) = -M 38\n");
+  fprintf
+    (stdout,"-ROI         : c=%%d,U=%%d : quantization indices upshifted \n");
+  fprintf
+    (stdout,"               for component c=%%d [%%d = 0,1,2]\n");
+  fprintf
+    (stdout,"               with a value of U=%%d [0 <= %%d <= 37] (i.e. -ROI:c=0,U=25) \n");
+  fprintf
+    (stdout,"-d           : offset of the origin of the image (-d 150,300) \n");
+  fprintf
+    (stdout,"-T           : offset of the origin of the tiles (-T 100,75) \n");
+  fprintf(stdout,"-I           : use the irreversible DWT 9-7 (-I) \n");
+  fprintf(stdout,"-W           : image width, height and the dx and dy subsampling \n");
+  fprintf(stdout,"               of the Cb and Cr components for YUV files \n");
+  fprintf(stdout,"               (default is '352,288,2,2' for CIF format's 352x288 and 4:2:0)\n");
+  fprintf(stdout,"-F           : video frame rate (set to 25 by default)\n");
+  
+  fprintf(stdout,"\n");
+  fprintf(stdout,"IMPORTANT:\n");
+  fprintf(stdout,"-----------\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"The index file has the structure below:\n");
+  fprintf(stdout,"---------------------------------------\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Image_height Image_width\n");
+  fprintf(stdout,"progression order\n");
+  fprintf(stdout,"Tiles_size_X Tiles_size_Y\n");
+  fprintf(stdout,"Components_nb\n");
+  fprintf(stdout,"Layers_nb\n");
+  fprintf(stdout,"decomposition_levels\n");
+  fprintf(stdout,"[Precincts_size_X_res_Nr Precincts_size_Y_res_Nr]...\n");
+  fprintf(stdout,"   [Precincts_size_X_res_0 Precincts_size_Y_res_0]\n");
+  fprintf(stdout,"Main_header_end_position\n");
+  fprintf(stdout,"Codestream_size\n");
+  fprintf(stdout,"Tile_0 start_pos end_Theader end_pos TotalDisto NumPix MaxMSE\n");
+  fprintf(stdout,"Tile_1   ''           ''        ''        ''       ''    ''\n");
+  fprintf(stdout,"...\n");
+  fprintf(stdout,"Tile_Nt   ''           ''        ''        ''       ''    ''\n");
+  fprintf(stdout,"Tpacket_0 Tile layer res. comp. prec. start_pos end_pos disto\n");
+  fprintf(stdout,"...\n");
+  fprintf(stdout,"Tpacket_Np ''   ''    ''   ''    ''       ''       ''     ''\n");
+  
+  fprintf(stdout,"MaxDisto\n");
+  
+  fprintf(stdout,"TotalDisto\n\n");
+}
+
+int give_progression(char progression[4])
+{
+  if (progression[0] == 'L' && progression[1] == 'R'
+    && progression[2] == 'C' && progression[3] == 'P') {
+    return 0;
+  } else {
+    if (progression[0] == 'R' && progression[1] == 'L'
+      && progression[2] == 'C' && progression[3] == 'P') {
+      return 1;
+    } else {
+      if (progression[0] == 'R' && progression[1] == 'P'
+				&& progression[2] == 'C' && progression[3] == 'L') {
+				return 2;
+      } else {
+				if (progression[0] == 'P' && progression[1] == 'C'
+					&& progression[2] == 'R' && progression[3] == 'L') {
+					return 3;
+				} else {
+					if (progression[0] == 'C' && progression[1] == 'P'
+						&& progression[2] == 'R' && progression[3] == 'L') {
+						return 4;
+					} else {
+						return -1;
+					}
+				}
+      }
+    }
+  }
+}
+
+
+
+
+int main(int argc, char **argv)
+{
+	mj2_cparameters_t mj2_parameters;	/* MJ2 compression parameters */
+	opj_cparameters_t *j2k_parameters;	/* J2K compression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_cio_t *cio;
+	char value;
+  opj_mj2_t *movie;
+	opj_image_t *img;
+  int i, j;
+  char *s, S1, S2, S3;
+  char *buf;
+  int x1, y1,  len;
+  long mdat_initpos, offset;
+  FILE *mj2file;
+  int sampleno;  
+	opj_cinfo_t* cinfo;
+  bool bSuccess;
+	int numframes;
+	double total_time = 0;	
+
+  /* default value */
+  /* ------------- */
+  mj2_parameters.Dim[0] = 0;
+  mj2_parameters.Dim[1] = 0;
+  mj2_parameters.w = 352;			// CIF default value
+  mj2_parameters.h = 288;			// CIF default value
+  mj2_parameters.CbCr_subsampling_dx = 2;	// CIF default value
+  mj2_parameters.CbCr_subsampling_dy = 2;	// CIF default value
+  mj2_parameters.frame_rate = 25;	  
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = NULL;
+    
+	/* set J2K encoding parameters to default values */
+	opj_set_default_encoder_parameters(&mj2_parameters.j2k_parameters);
+	j2k_parameters = &mj2_parameters.j2k_parameters;
+
+	/* Create comment for codestream */
+	if(j2k_parameters->cp_comment == NULL) {
+    const char comment[] = "Created by OpenJPEG version ";
+		const size_t clen = strlen(comment);
+    const char *version = opj_version();
+		j2k_parameters->cp_comment = (char*)malloc(clen+strlen(version)+1);
+		sprintf(j2k_parameters->cp_comment,"%s%s", comment, version);
+	}
+
+	mj2_parameters.decod_format = 0;
+	mj2_parameters.cod_format = 0;
+
+  while (1) {
+    int c = getopt(argc, argv,
+      "i:o:r:q:f:t:n:c:b:p:s:d:h P:S:E:M:R:T:C:I:W:F:");
+    if (c == -1)
+      break;
+    switch (c) {
+    case 'i':			/* IN fill */
+			{
+				char *infile = optarg;
+				s = optarg;
+				while (*s) {
+					s++;
+				}
+				s--;
+				S3 = *s;
+				s--;
+				S2 = *s;
+				s--;
+				S1 = *s;
+				
+				if ((S1 == 'y' && S2 == 'u' && S3 == 'v')
+					|| (S1 == 'Y' && S2 == 'U' && S3 == 'V')) {
+					mj2_parameters.decod_format = YUV_DFMT;				
+				}
+				else {
+					fprintf(stderr,
+						"!! Unrecognized format for infile : %c%c%c [accept only *.yuv] !!\n\n",
+						S1, S2, S3);
+					return 1;
+				}
+				strncpy(mj2_parameters.infile, infile, sizeof(mj2_parameters.infile)-1);
+			}
+      break;
+      /* ----------------------------------------------------- */
+    case 'o':			/* OUT fill */
+			{
+				char *outfile = optarg;
+				while (*outfile) {
+					outfile++;
+				}
+				outfile--;
+				S3 = *outfile;
+				outfile--;
+				S2 = *outfile;
+				outfile--;
+				S1 = *outfile;
+				
+				outfile = optarg;
+				
+				if ((S1 == 'm' && S2 == 'j' && S3 == '2')
+					|| (S1 == 'M' && S2 == 'J' && S3 == '2'))
+					mj2_parameters.cod_format = MJ2_CFMT;
+				else {
+					fprintf(stderr,
+						"Unknown output format image *.%c%c%c [only *.mj2]!! \n",
+						S1, S2, S3);
+					return 1;
+				}
+				strncpy(mj2_parameters.outfile, outfile, sizeof(mj2_parameters.outfile)-1);      
+      }
+      break;
+      /* ----------------------------------------------------- */
+    case 'r':			/* rates rates/distorsion */
+			{
+				float rate;
+				s = optarg;
+				while (sscanf(s, "%f", &rate) == 1) {
+					j2k_parameters->tcp_rates[j2k_parameters->tcp_numlayers] = rate * 2;
+					j2k_parameters->tcp_numlayers++;
+					while (*s && *s != ',') {
+						s++;
+					}
+					if (!*s)
+						break;
+					s++;
+				}
+				j2k_parameters->cp_disto_alloc = 1;
+			}
+      break;
+      /* ----------------------------------------------------- */
+    case 'q':			/* add fixed_quality */
+      s = optarg;
+			while (sscanf(s, "%f", &j2k_parameters->tcp_distoratio[j2k_parameters->tcp_numlayers]) == 1) {
+				j2k_parameters->tcp_numlayers++;
+				while (*s && *s != ',') {
+					s++;
+				}
+				if (!*s)
+					break;
+				s++;
+			}
+			j2k_parameters->cp_fixed_quality = 1;
+      break;
+      /* dda */
+      /* ----------------------------------------------------- */
+    case 'f':			/* mod fixed_quality (before : -q) */
+			{
+				int *row = NULL, *col = NULL;
+				int numlayers = 0, numresolution = 0, matrix_width = 0;
+				
+				s = optarg;
+				sscanf(s, "%d", &numlayers);
+				s++;
+				if (numlayers > 9)
+					s++;
+				
+				j2k_parameters->tcp_numlayers = numlayers;
+				numresolution = j2k_parameters->numresolution;
+				matrix_width = numresolution * 3;
+				j2k_parameters->cp_matrice = (int *) malloc(numlayers * matrix_width * sizeof(int));
+				s = s + 2;
+				
+				for (i = 0; i < numlayers; i++) {
+					row = &j2k_parameters->cp_matrice[i * matrix_width];
+					col = row;
+					j2k_parameters->tcp_rates[i] = 1;
+					sscanf(s, "%d,", &col[0]);
+					s += 2;
+					if (col[0] > 9)
+						s++;
+					col[1] = 0;
+					col[2] = 0;
+					for (j = 1; j < numresolution; j++) {
+						col += 3;
+						sscanf(s, "%d,%d,%d", &col[0], &col[1], &col[2]);
+						s += 6;
+						if (col[0] > 9)
+							s++;
+						if (col[1] > 9)
+							s++;
+						if (col[2] > 9)
+							s++;
+					}
+					if (i < numlayers - 1)
+						s++;
+				}
+				j2k_parameters->cp_fixed_alloc = 1;
+			}
+			break;
+      /* ----------------------------------------------------- */
+    case 't':			/* tiles */
+      sscanf(optarg, "%d,%d", &j2k_parameters->cp_tdx, &j2k_parameters->cp_tdy);
+			j2k_parameters->tile_size_on = true;
+      break;
+      /* ----------------------------------------------------- */
+    case 'n':			/* resolution */
+      sscanf(optarg, "%d", &j2k_parameters->numresolution);
+      break;
+      /* ----------------------------------------------------- */
+    case 'c':			/* precinct dimension */
+			{
+				char sep;
+				int res_spec = 0;
+
+				char *s = optarg;
+				do {
+					sep = 0;
+					sscanf(s, "[%d,%d]%c", &j2k_parameters->prcw_init[res_spec],
+                                 &j2k_parameters->prch_init[res_spec], &sep);
+					j2k_parameters->csty |= 0x01;
+					res_spec++;
+					s = strpbrk(s, "]") + 2;
+				}
+				while (sep == ',');
+				j2k_parameters->res_spec = res_spec;
+			}
+			break;
+
+      /* ----------------------------------------------------- */
+    case 'b':			/* code-block dimension */
+			{
+				int cblockw_init = 0, cblockh_init = 0;
+				sscanf(optarg, "%d,%d", &cblockw_init, &cblockh_init);
+				if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024
+					|| cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+					fprintf(stderr,
+						"!! Size of code_block error (option -b) !!\n\nRestriction :\n"
+            "    * width*height<=4096\n    * 4<=width,height<= 1024\n\n");
+					return 1;
+				}
+				j2k_parameters->cblockw_init = cblockw_init;
+				j2k_parameters->cblockh_init = cblockh_init;
+			}
+			break;
+      /* ----------------------------------------------------- */
+    case 'p':			/* progression order */
+			{
+				char progression[4];
+				
+				strncpy(progression, optarg, 4);
+				j2k_parameters->prog_order = give_progression(progression);
+				if (j2k_parameters->prog_order == -1) {
+					fprintf(stderr, "Unrecognized progression order "
+            "[LRCP, RLCP, RPCL, PCRL, CPRL] !!\n");
+					return 1;
+				}
+			}
+			break;
+      /* ----------------------------------------------------- */
+    case 's':			/* subsampling factor */
+      {
+				if (sscanf(optarg, "%d,%d", &j2k_parameters->subsampling_dx,
+                                    &j2k_parameters->subsampling_dy) != 2) {
+					fprintf(stderr,	"'-s' sub-sampling argument error !  [-s dx,dy]\n");
+					return 1;
+				}
+			}
+			break;
+      /* ----------------------------------------------------- */
+    case 'd':			/* coordonnate of the reference grid */
+      {
+				if (sscanf(optarg, "%d,%d", &j2k_parameters->image_offset_x0,
+                                    &j2k_parameters->image_offset_y0) != 2) {
+					fprintf(stderr,	"-d 'coordonnate of the reference grid' argument "
+            "error !! [-d x0,y0]\n");
+					return 1;
+				}
+			}
+			break;
+      /* ----------------------------------------------------- */
+    case 'h':			/* Display an help description */
+      help_display();
+      return 0;
+      break;
+      /* ----------------------------------------------------- */
+    case 'P':			/* POC */
+      {
+				int numpocs = 0;		/* number of progression order change (POC) default 0 */
+				opj_poc_t *POC = NULL;	/* POC : used in case of Progression order change */
+
+				char *s = optarg;
+				POC = j2k_parameters->POC;
+
+				while (sscanf(s, "T%d=%d,%d,%d,%d,%d,%4s", &POC[numpocs].tile,
+					&POC[numpocs].resno0, &POC[numpocs].compno0,
+					&POC[numpocs].layno1, &POC[numpocs].resno1,
+					&POC[numpocs].compno1, &POC[numpocs].progorder) == 7) {
+					POC[numpocs].prg1 = give_progression(POC[numpocs].progorder);
+					numpocs++;
+					while (*s && *s != '/') {
+						s++;
+					}
+					if (!*s) {
+						break;
+					}
+					s++;
+				}
+				j2k_parameters->numpocs = numpocs;
+			}
+			break;
+      /* ------------------------------------------------------ */
+    case 'S':			/* SOP marker */
+      j2k_parameters->csty |= 0x02;
+      break;
+      /* ------------------------------------------------------ */
+    case 'E':			/* EPH marker */
+      j2k_parameters->csty |= 0x04;
+      break;
+      /* ------------------------------------------------------ */
+    case 'M':			/* Mode switch pas tous au point !! */
+      if (sscanf(optarg, "%d", &value) == 1) {
+				for (i = 0; i <= 5; i++) {
+					int cache = value & (1 << i);
+					if (cache)
+						j2k_parameters->mode |= (1 << i);
+				}
+      }
+      break;
+      /* ------------------------------------------------------ */
+    case 'R':			/* ROI */
+      {
+				if (sscanf(optarg, "OI:c=%d,U=%d", &j2k_parameters->roi_compno,
+                                           &j2k_parameters->roi_shift) != 2) {
+					fprintf(stderr, "ROI error !! [-ROI:c='compno',U='shift']\n");
+					return 1;
+				}
+			}
+			break;
+      /* ------------------------------------------------------ */
+    case 'T':			/* Tile offset */
+			{
+				if (sscanf(optarg, "%d,%d", &j2k_parameters->cp_tx0, &j2k_parameters->cp_ty0) != 2) {
+					fprintf(stderr, "-T 'tile offset' argument error !! [-T X0,Y0]");
+					return 1;
+				}
+			}
+			break;
+      /* ------------------------------------------------------ */
+    case 'C':			/* Add a comment */
+			{
+				j2k_parameters->cp_comment = (char*)malloc(strlen(optarg) + 1);
+				if(j2k_parameters->cp_comment) {
+					strcpy(j2k_parameters->cp_comment, optarg);
+				}
+			}
+			break;
+      /* ------------------------------------------------------ */
+    case 'I':			/* reversible or not */
+			{
+				j2k_parameters->irreversible = 1;
+			}
+			break;
+      /* ------------------------------------------------------ */
+    case 'W':			/* Width and Height and Cb and Cr subsampling in case of YUV format files */
+      if (sscanf
+				(optarg, "%d,%d,%d,%d", &mj2_parameters.w, &mj2_parameters.h, &mj2_parameters.CbCr_subsampling_dx,
+				&mj2_parameters.CbCr_subsampling_dy) != 4) {
+				fprintf(stderr, "-W argument error");
+				return 1;
+      }
+      break;
+      /* ------------------------------------------------------ */
+    case 'F':			/* Video frame rate */
+      if (sscanf(optarg, "%d", &mj2_parameters.frame_rate) != 1) {
+				fprintf(stderr, "-F argument error");
+				return 1;
+      }
+      break;
+      /* ------------------------------------------------------ */
+    default:
+      return 1;
+    }
+  }
+    
+  /* Error messages */
+  /* -------------- */
+	if (!mj2_parameters.cod_format || !mj2_parameters.decod_format) {
+    fprintf(stderr,
+      "Correct usage: mj2_encoder -i yuv-file -o mj2-file (+ options)\n");
+    return 1;
+  }
+  
+	if ((j2k_parameters->cp_disto_alloc || j2k_parameters->cp_fixed_alloc || j2k_parameters->cp_fixed_quality)
+		&& (!(j2k_parameters->cp_disto_alloc ^ j2k_parameters->cp_fixed_alloc ^ j2k_parameters->cp_fixed_quality))) {
+		fprintf(stderr, "Error: options -r -q and -f cannot be used together !!\n");
+		return 1;
+	}				/* mod fixed_quality */
+
+	/* if no rate entered, lossless by default */
+	if (j2k_parameters->tcp_numlayers == 0) {
+		j2k_parameters->tcp_rates[0] = 0;	/* MOD antonin : losslessbug */
+		j2k_parameters->tcp_numlayers++;
+		j2k_parameters->cp_disto_alloc = 1;
+	}
+
+	if((j2k_parameters->cp_tx0 > j2k_parameters->image_offset_x0) || (j2k_parameters->cp_ty0 > j2k_parameters->image_offset_y0)) {
+		fprintf(stderr,
+			"Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
+			j2k_parameters->cp_tx0, j2k_parameters->image_offset_x0, j2k_parameters->cp_ty0, j2k_parameters->image_offset_y0);
+		return 1;
+	}
+
+	for (i = 0; i < j2k_parameters->numpocs; i++) {
+		if (j2k_parameters->POC[i].prg == -1) {
+			fprintf(stderr,
+				"Unrecognized progression order in option -P (POC n %d) [LRCP, RLCP, RPCL, PCRL, CPRL] !!\n",
+				i + 1);
+		}
+	}
+  
+  if (j2k_parameters->cp_tdx > mj2_parameters.Dim[0] || j2k_parameters->cp_tdy > mj2_parameters.Dim[1]) {
+    fprintf(stderr,
+      "Error: Tile offset dimension is unnappropriate --> TX0(%d)<=IMG_X0(%d) TYO(%d)<=IMG_Y0(%d) \n",
+      j2k_parameters->cp_tdx, mj2_parameters.Dim[0], j2k_parameters->cp_tdy, mj2_parameters.Dim[1]);
+    return 1;
+  }
+    
+  /* to respect profile - 0 */
+  /* ---------------------- */
+  
+  x1 = !mj2_parameters.Dim[0] ? (mj2_parameters.w - 1) * j2k_parameters->subsampling_dx 
+		+ 1 : mj2_parameters.Dim[0] + (mj2_parameters.w - 1) * j2k_parameters->subsampling_dx + 1;
+  y1 = !mj2_parameters.Dim[1] ? (mj2_parameters.h - 1) * j2k_parameters->subsampling_dy 
+		+ 1 : mj2_parameters.Dim[1] + (mj2_parameters.h - 1) * j2k_parameters->subsampling_dy + 1;   
+  mj2_parameters.numcomps = 3;			/* Because YUV files only have 3 components */ 
+  mj2_parameters.prec = 8;			/* Because in YUV files, components have 8-bit depth */
+
+	j2k_parameters->tcp_mct = 0;
+    
+  mj2file = fopen(mj2_parameters.outfile, "wb");
+  
+  if (!mj2file) {
+    fprintf(stderr, "failed to open %s for writing\n", argv[2]);
+    return 1;
+  }
+    
+	/* get a MJ2 decompressor handle */
+	cinfo = mj2_create_compress();
+	movie = cinfo->mj2_handle;
+	
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+
+	/* setup encoder parameters */
+	mj2_setup_encoder(movie, &mj2_parameters);   
+  
+  movie->tk[0].num_samples = yuv_num_frames(&movie->tk[0],mj2_parameters.infile); 
+  if (movie->tk[0].num_samples == -1) {
+		return 1;
+  }
+  
+  // One sample per chunk
+  movie->tk[0].chunk = (mj2_chunk_t*) malloc(movie->tk[0].num_samples * sizeof(mj2_chunk_t));     
+  movie->tk[0].sample = (mj2_sample_t*) malloc(movie->tk[0].num_samples * sizeof(mj2_sample_t));
+  
+  if (mj2_init_stdmovie(movie)) {
+    fprintf(stderr, "Error with movie initialization");
+    return 1;
+  };    
+  
+  // Writing JP, FTYP and MDAT boxes 
+  buf = (char*) malloc (300 * sizeof(char)); // Assuming that the JP and FTYP
+  // boxes won't be longer than 300 bytes
+	cio = opj_cio_open((opj_common_ptr)movie->cinfo, buf, 300);
+  mj2_write_jp(cio);
+  mj2_write_ftyp(movie, cio);
+  mdat_initpos = cio_tell(cio);
+  cio_skip(cio, 4);
+  cio_write(cio, MJ2_MDAT, 4);	
+  fwrite(buf,cio_tell(cio),1,mj2file);
+  offset = cio_tell(cio);
+  opj_cio_close(cio);
+  free(buf);
+
+  for (i = 0; i < movie->num_stk + movie->num_htk + movie->num_vtk; i++) {
+    if (movie->tk[i].track_type != 0) {
+      fprintf(stderr, "Unable to write sound or hint tracks\n");
+    } else {
+      mj2_tk_t *tk;
+			int buflen = 0;
+      
+      tk = &movie->tk[i];     
+      tk->num_chunks = tk->num_samples;
+			numframes = tk->num_samples;
+
+      fprintf(stderr, "Video Track number %d\n", i + 1);
+			
+			img = mj2_image_create(tk, j2k_parameters);          
+			buflen = 2 * (tk->w * tk->h * 8);
+			buf = (char *) malloc(buflen*sizeof(char));	
+
+      for (sampleno = 0; sampleno < numframes; sampleno++) {		
+				double init_time = opj_clock();
+				double elapsed_time;
+				if (yuvtoimage(tk, img, sampleno, j2k_parameters, mj2_parameters.infile)) {
+					fprintf(stderr, "Error with frame number %d in YUV file\n", sampleno);
+					return 1;
+				}
+
+				/* setup the encoder parameters using the current image and user parameters */
+				opj_setup_encoder(cinfo, j2k_parameters, img);
+
+				cio = opj_cio_open((opj_common_ptr)movie->cinfo, buf, buflen);
+								
+				cio_skip(cio, 4);
+				cio_write(cio, JP2_JP2C, 4);	// JP2C
+
+				/* encode the image */
+				bSuccess = opj_encode(cinfo, cio, img, NULL);
+				if (!bSuccess) {
+					opj_cio_close(cio);
+					fprintf(stderr, "failed to encode image\n");
+					return 1;
+				}
+
+				len = cio_tell(cio) - 8;
+				cio_seek(cio, 0);
+				cio_write(cio, len+8,4);
+				opj_cio_close(cio);
+				tk->sample[sampleno].sample_size = len+8;				
+				tk->sample[sampleno].offset = offset;
+				tk->chunk[sampleno].offset = offset;	// There is one sample per chunk 
+				fwrite(buf, 1, len+8, mj2file);				
+				offset += len+8;				
+				elapsed_time = opj_clock()-init_time;
+				fprintf(stderr, "Frame number %d/%d encoded in %.2f mseconds\n", sampleno + 1, numframes, elapsed_time*1000);
+				total_time += elapsed_time;
+
+      }
+			/* free buffer data */
+			free(buf);
+			/* free image data */
+			opj_image_destroy(img);
+    }
+  }
+  
+  fseek(mj2file, mdat_initpos, SEEK_SET);
+	
+  buf = (char*) malloc(4*sizeof(char));
+
+	// Init a cio to write box length variable in a little endian way 
+	cio = opj_cio_open(NULL, buf, 4);
+  cio_write(cio, offset - mdat_initpos, 4);
+  fwrite(buf, 4, 1, mj2file);
+  fseek(mj2file,0,SEEK_END);
+  free(buf);
+
+  // Writing MOOV box 
+	buf = (char*) malloc ((TEMP_BUF+numframes*20) * sizeof(char));
+	cio = opj_cio_open(movie->cinfo, buf, (TEMP_BUF+numframes*20));
+	mj2_write_moov(movie, cio);
+  fwrite(buf,cio_tell(cio),1,mj2file);
+  free(buf);
+
+	fprintf(stdout,"Total encoding time: %.2f s for %d frames (%.1f fps)\n", total_time, numframes, (float)numframes/total_time);
+  
+  // Ending program 
+  
+  fclose(mj2file);
+	/* free remaining compression structures */
+	mj2_destroy_compress(movie);
+	free(cinfo);
+	/* free user parameters structure */
+  if(j2k_parameters->cp_comment) free(j2k_parameters->cp_comment);
+	if(j2k_parameters->cp_matrice) free(j2k_parameters->cp_matrice);
+	opj_cio_close(cio);
+
+  return 0;
+}
+
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.dsp.svn-base ./mj2/.svn/text-base/frames_to_mj2.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/frames_to_mj2.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,212 @@
+# Microsoft Developer Studio Project File - Name="frames_to_mj2" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=frames_to_mj2 - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "frames_to_mj2.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "frames_to_mj2.mak" CFG="frames_to_mj2 - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "frames_to_mj2 - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "frames_to_mj2 - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "frames_to_mj2 - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /c
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# SUBTRACT LINK32 /pdb:none /incremental:yes /debug
+
+!ELSEIF  "$(CFG)" == "frames_to_mj2 - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "frames_to_mj2___Win32_Debug0"
+# PROP BASE Intermediate_Dir "frames_to_mj2___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "frames_to_mj2___Win32_Debug0"
+# PROP Intermediate_Dir "frames_to_mj2___Win32_Debug0"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MT /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmt" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "frames_to_mj2 - Win32 Release"
+# Name "frames_to_mj2 - Win32 Debug"
+# Begin Group "MJ2"
+
+# PROP Default_Filter ""
+# Begin Group "MJ2 Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\mj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.h
+# End Source File
+# End Group
+# Begin Group "MJ2 Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\frames_to_mj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.c
+# End Source File
+# End Group
+# End Group
+# Begin Group "Libopenjpeg Header files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.dsw.svn-base ./mj2/.svn/text-base/frames_to_mj2.dsw.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/frames_to_mj2.dsw.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "frames_to_mj2"=".\frames_to_mj2.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Project: "LibOpenJPEG"="..\LibOpenJPEG.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
Binary files /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.sln.svn-base and ./mj2/.svn/text-base/frames_to_mj2.sln.svn-base differ
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.vcproj.svn-base ./mj2/.svn/text-base/frames_to_mj2.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/frames_to_mj2.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/frames_to_mj2.vcproj.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,406 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="frames_to_mj2"
+	ProjectGUID="{4C7685BB-E216-488C-8675-FF5A54FEDDDD}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/frames_to_mj2.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/frames_to_mj2.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC"
+				ProgramDatabaseFile=".\Release/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\frames_to_mj2___Win32_Debug0"
+			IntermediateDirectory=".\frames_to_mj2___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pch"
+				AssemblerListingLocation=".\frames_to_mj2___Win32_Debug0/"
+				ObjectFile=".\frames_to_mj2___Win32_Debug0/"
+				ProgramDataBaseFileName=".\frames_to_mj2___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBC,LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\frames_to_mj2___Win32_Debug0/frames_to_mj2.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="frames_to_mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="Libopenjpeg Header files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/Makefile.svn-base ./mj2/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/Makefile.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,20 @@
+# Makefile for the MJ2 codecs of the OpenJPEG library: frames_to_mj2, mj2_to_frames, extract_j2k_from_mj2 and wrap_j2k_in_mj2
+
+CFLAGS = -O3 -lstdc++ # -g -p -pg
+
+all: frames_to_mj2 mj2_to_frames extract_j2k_from_mj2 wrap_j2k_in_mj2
+
+frames_to_mj2: frames_to_mj2.c ../libopenjpeg.a
+	gcc $(CFLAGS) compat/getopt.c mj2_convert.c mj2.c frames_to_mj2.c -o frames_to_mj2 -L.. -lopenjpeg -I ../libopenjpeg/ -lm
+
+mj2_to_frames: mj2_to_frames.c ../libopenjpeg.a
+	gcc $(CFLAGS) compat/getopt.c mj2_convert.c mj2.c mj2_to_frames.c -o mj2_to_frames -L.. -lopenjpeg -I ../libopenjpeg/ -lm
+
+extract_j2k_from_mj2: extract_j2k_from_mj2.c ../libopenjpeg.a
+	gcc $(CFLAGS) mj2.c extract_j2k_from_mj2.c -o extract_j2k_from_mj2 -L.. -lopenjpeg -I ../libopenjpeg/ -lm
+
+wrap_j2k_in_mj2: wrap_j2k_in_mj2.c ../libopenjpeg.a
+	gcc $(CFLAGS) mj2.c wrap_j2k_in_mj2.c -o wrap_j2k_in_mj2 -L.. -lopenjpeg -I ../libopenjpeg/ -lm
+
+clean:
+	rm -f frames_to_mj2 mj2_to_frames extract_j2k_from_mj2 wrap_j2k_in_mj2
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/meta_out.c.svn-base ./mj2/.svn/text-base/meta_out.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/meta_out.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/meta_out.c.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,2181 @@
+/* meta_out.c */
+/* Dump MJ2, JP2 metadata (partial so far) to xml file */
+/* Callable from mj2_to_metadata */
+/* Contributed to Open JPEG by Glenn Pearson, contract software developer, U.S. National Library of Medicine.
+
+The base code in this file was developed by the author as part of a video archiving
+project for the U.S. National Library of Medicine, Bethesda, MD. 
+It is the policy of NLM (and U.S. government) to not assert copyright.
+
+A non-exclusive copy of this code has been contributed to the Open JPEG project.
+Except for copyright, inclusion of the code within Open JPEG for distribution and use
+can be bound by the Open JPEG open-source license and disclaimer, expressed elsewhere.
+*/
+
+#include <windows.h> /* for time functions */
+
+#include "opj_includes.h"
+#include "mj2.h"
+
+#include <time.h>
+#include "meta_out.h"
+
+static BOOL notes = TRUE;
+static BOOL sampletables = FALSE;
+static BOOL raw = TRUE;
+static BOOL derived = TRUE;
+
+opj_tcp_t *j2k_default_tcp;
+
+/* Forwards */
+int xml_write_overall_header(FILE *file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, opj_event_mgr_t *event_mgr);
+int xml_write_moov(FILE *file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, opj_event_mgr_t *event_mgr);
+
+void uint_to_chars(unsigned int value, char* buf);
+
+void xml_write_trak(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum, unsigned int sampleframe, opj_event_mgr_t *event_mgr);
+void xml_write_tkhd(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum);
+void xml_write_udta(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum);
+void xml_write_mdia(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum);
+void xml_write_stbl(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum);
+
+void UnixTimeToFileTime(time_t t, LPFILETIME pft);
+void UnixTimeToSystemTime(time_t t, LPSYSTEMTIME pst);
+void xml_time_out(FILE* xmlout, time_t t);
+
+void int16_to_3packedchars(short int value, char* buf);
+
+void xml_write_moov_udta(FILE* xmlout, opj_mj2_t * movie);
+void xml_write_free_and_skip(FILE* xmlout, opj_mj2_t * movie);
+void xml_write_uuid(FILE* xmlout, opj_mj2_t * movie);
+
+int xml_out_frame(FILE* file, FILE* xmlout, mj2_sample_t *sample, unsigned int snum, opj_event_mgr_t *event_mgr);
+
+void xml_out_frame_siz(FILE* xmlout, opj_image_t *img, opj_cp_t *cp);
+void xml_out_frame_cod(FILE* xmlout, opj_tcp_t *tcp);
+void xml_out_frame_coc(FILE* xmlout, opj_tcp_t *tcp, int numcomps); /* opj_image_t *img); */
+BOOL same_component_style(opj_tccp_t *tccp1, opj_tccp_t *tccp2);
+void xml_out_frame_qcd(FILE* xmlout, opj_tcp_t *tcp);
+void xml_out_frame_qcc(FILE* xmlout, opj_tcp_t *tcp, int numcomps); /* opj_image_t *img); */
+BOOL same_component_quantization(opj_tccp_t *tccp1, opj_tccp_t *tccp2);
+void xml_out_frame_rgn(FILE* xmlout, opj_tcp_t *tcp, int numcomps);/* opj_image_t *img);*/
+void xml_out_frame_poc(FILE* xmlout, opj_tcp_t *tcp);
+void xml_out_frame_ppm(FILE* xmlout, opj_cp_t *cp);
+void xml_out_frame_ppt(FILE* xmlout, opj_tcp_t *tcp);
+void xml_out_frame_tlm(FILE* xmlout); /* j2k_default_tcp is passed globally */ /* NO-OP.  TLM NOT SAVED IN DATA STRUCTURE */
+void xml_out_frame_plm(FILE* xmlout); /* j2k_default_tcp is passed globally */ /* NO-OP.  PLM NOT SAVED IN DATA STRUCTURE.  opt in main; can be used in conjunction with PLT */
+void xml_out_frame_plt(FILE* xmlout, opj_tcp_t *tcp); /* NO-OP.  PLM NOT SAVED IN DATA STRUCTURE.  opt in main; can be used in conjunction with PLT */
+void xml_out_frame_crg(FILE* xmlout); /* j2k_default_tcp is passed globally */ /* opt in main; */
+void xml_out_frame_com(FILE* xmlout, opj_tcp_t *tcp); /* NO-OP.  COM NOT SAVED IN DATA STRUCTURE */ /* opt in main; */
+void xml_out_dump_hex(FILE* xmlout, char *data, int data_len, char* s);
+void xml_out_dump_hex_and_ascii(FILE* xmlout, char *data, int data_len, char* s);
+void xml_out_frame_jp2h(FILE* xmlout, opj_jp2_t *jp2_struct);
+#ifdef NOTYET
+/* Shown with cp, extended, as data structure... but it could be a new different one */
+void xml_out_frame_jp2i(FILE* xmlout, opj_cp_t *cp);/* IntellectualProperty 'jp2i' (no restrictions on location) */
+void xml_out_frame_xml(FILE* xmlout, opj_cp_t *cp); /* XML 'xml\040' (0x786d6c20).  Can appear multiply */
+void xml_out_frame_uuid(FILE* xmlout, opj_cp_t *cp); /* UUID 'uuid' (top level only) */
+void xml_out_frame_uinf(FILE* xmlout, opj_cp_t *cp); /* UUIDInfo 'uinf', includes UUIDList 'ulst' and URL 'url\40' */
+void xml_out_frame_unknown_type(FILE* xmlout, opj_cp_t *cp);
+#endif
+
+
+void xml_write_init(BOOL n, BOOL t, BOOL r, BOOL d)
+{
+  /* Init file globals */
+  notes = n;
+  sampletables = t;
+  raw = r;
+  derived = d;
+}
+
+int xml_write_struct(FILE* file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, char* stringDTD, opj_event_mgr_t *event_mgr) {
+
+  if(stringDTD != NULL)
+  {
+    fprintf(xmlout,"<?xml version=\"1.0\" standalone=\"no\"?>\n");
+	/* stringDTD is known to start with "SYSTEM " or "PUBLIC " */
+	/* typical: SYSTEM mj2_to_metadata.dtd */
+	stringDTD[6] = '\0'; /* Break into two strings at space, so quotes can be inserted. */
+    fprintf(xmlout,"<!DOCTYPE MJ2_File %s \"%s\">\n", stringDTD, stringDTD+7); 
+	stringDTD[6] = ' '; /* restore for sake of debugger or memory allocator */
+  } else
+    fprintf(xmlout,"<?xml version=\"1.0\" standalone=\"yes\"?>\n");    
+
+  fprintf(xmlout, "<MJ2_File>\n");
+  xml_write_overall_header(file, xmlout, movie, sampleframe, event_mgr);
+  fprintf(xmlout, "</MJ2_File>");
+  return 0;
+}
+
+/* ------------- */
+
+int xml_write_overall_header(FILE *file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, opj_event_mgr_t *event_mgr)
+{
+  int i;
+  char buf[5];
+  buf[4] = '\0';
+
+  fprintf(xmlout,   "  <JP2 BoxType=\"jP[space][space]\" Signature=\"0x0d0a870a\" />\n");
+  // Called after structure initialized by mj2_read_ftyp
+  fprintf(xmlout,   "  <FileType BoxType=\"ftyp\">\n");
+  uint_to_chars(movie->brand, buf);
+  fprintf(xmlout,   "    <Brand>%s</Brand>\n", buf);    /* 4 character; BR              */
+  fprintf(xmlout,   "    <MinorVersion>%u</MinorVersion>\n", movie->minversion);    /* 4 char; MinV            */
+  fprintf(xmlout,   "    <CompatibilityList Count=\"%d\">\n",movie->num_cl);
+  for (i = movie->num_cl - 1; i > -1; i--) /* read routine stored in reverse order, so let's undo damage */
+  {
+    uint_to_chars(movie->cl[i], buf);
+    fprintf(xmlout, "      <CompatibleBrand>%s</CompatibleBrand>\n", buf);    /*4 characters, each CLi */
+  }
+  fprintf(xmlout,   "    </CompatibilityList>\n");
+  fprintf(xmlout,   "  </FileType>\n");
+  xml_write_moov(file, xmlout, movie, sampleframe, event_mgr);
+  // To come?              <mdat>  // This is the container for media data that can also be accessed through track structures,
+                                   // so is redundant, and simply not of interest as metadata
+  //                       <moof>  // Allows incremental build up of movie.  Probably not in Simple Profile
+  xml_write_free_and_skip(xmlout, movie); /* NO OP so far */ /* May be a place where user squirrels metadata */
+  xml_write_uuid(xmlout, movie); /* NO OP so far */ /* May be a place where user squirrels metadata */
+  return 0;
+}
+
+/* ------------- */
+
+int xml_write_moov(FILE *file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, opj_event_mgr_t *event_mgr)
+{
+  unsigned int tnum;
+  mj2_tk_t *track;
+
+  fprintf(xmlout,   "  <MovieBox BoxType=\"moov\">\n");
+  fprintf(xmlout,   "    <MovieHeader BoxType=\"mvhd\">\n");
+  fprintf(xmlout,   "      <CreationTime>\n");
+  if(raw)
+    fprintf(xmlout, "        <InSeconds>%u</InSeconds>\n", movie->creation_time);
+  if(notes)
+    fprintf(xmlout, "        <!-- Seconds since start of Jan. 1, 1904 UTC (Greenwich) -->\n");
+  /*  2082844800 = seconds between 1/1/04 and 1/1/70 */
+  /* There's still a time zone offset problem not solved... but spec is ambigous as to whether stored time
+     should be local or UTC */
+  if(derived) {
+    fprintf(xmlout, "        <AsLocalTime>"); 
+                             xml_time_out(xmlout, movie->creation_time - 2082844800);
+                                                     fprintf(xmlout,"</AsLocalTime>\n");
+  }
+  fprintf(xmlout,   "      </CreationTime>\n");
+  fprintf(xmlout,   "      <ModificationTime>\n");
+  if(raw)
+    fprintf(xmlout, "        <InSeconds>%u</InSeconds>\n", movie->modification_time);
+  if(derived) {
+    fprintf(xmlout, "        <AsLocalTime>"); 
+                             xml_time_out(xmlout, movie->modification_time - 2082844800);
+                                                     fprintf(xmlout,"</AsLocalTime>\n");
+  }
+  fprintf(xmlout,   "      </ModificationTime>\n");
+  fprintf(xmlout,   "      <Timescale>%d</Timescale>\n", movie->timescale);
+  if(notes)
+    fprintf(xmlout, "      <!-- Timescale defines time units in one second -->\n");
+  fprintf(xmlout,   "      <Rate>\n");        /* Rate to play presentation  (default = 0x00010000)          */
+  if(notes) {
+    fprintf(xmlout, "      <!-- Rate to play presentation is stored as fixed-point binary 16.16 value. Decimal value is approximation. -->\n");
+    fprintf(xmlout, "      <!-- Rate is expressed relative to normal (default) value of 0x00010000 (1.0) -->\n");
+  }
+  if(raw)
+    fprintf(xmlout, "        <AsHex>0x%08x</AsHex>\n", movie->rate);
+  if(derived)
+    fprintf(xmlout, "        <AsDecimal>%12.6f</AsDecimal>\n", (double)movie->rate/(double)0x00010000);
+  fprintf(xmlout,   "      </Rate>\n");
+  fprintf(xmlout,   "      <Duration>\n");
+  if(raw)
+    fprintf(xmlout, "        <InTimeUnits>%u</InTimeUnits>\n", movie->duration);
+  if(derived)
+    fprintf(xmlout, "        <InSeconds>%12.3f</InSeconds>\n", (double)movie->duration/(double)movie->timescale);    // Make this double later to get fractional seconds
+  fprintf(xmlout,   "      </Duration>\n");
+#ifdef CURRENTSTRUCT
+  movie->volume = movie->volume << 8;
+#endif
+  fprintf(xmlout,   "      <Volume>\n");
+  if(notes) {
+    fprintf(xmlout, "      <!-- Audio volume stored as fixed-point binary 8.8 value. Decimal value is approximation. -->\n");
+    fprintf(xmlout, "      <!-- Full, normal (default) value is 0x0100 (1.0) -->\n");
+  }
+  if(raw)
+    fprintf(xmlout, "        <AsHex>0x%04x</AsHex>\n", movie->volume);
+  if(derived)
+    fprintf(xmlout, "        <AsDecimal>%6.3f</AsDecimal>\n", (double)movie->volume/(double)0x0100);
+  fprintf(xmlout,   "      </Volume>\n");
+#ifdef CURRENTSTRUCT
+  if(notes)
+    fprintf(xmlout, "      <!-- Current m2j_to_metadata implementation always shows bits to right of decimal as zeroed. -->\n");
+  movie->volume = movie->volume >> 8;
+#endif
+  /* Transformation matrix for video                            */
+  fprintf(xmlout,   "      <TransformationMatrix>\n");
+  if(notes) {
+    fprintf(xmlout, "      <!-- 3 x 3 Video Transformation Matrix {a,b,u,c,d,v,x,y,w}.  Required: u=0, v=0, w=1 -->\n");
+    fprintf(xmlout, "      <!-- Maps decompressed point (p,q) to rendered point (ap + cq + x, bp + dq + y) -->\n");
+    fprintf(xmlout, "      <!-- Stored as Fixed Point Hex: all are binary 16.16, except u,v,w are 2.30 -->\n");
+    fprintf(xmlout, "      <!-- Unity = 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 -->\n");
+  }
+  fprintf(xmlout,   "        <TMa>0x%08x</TMa>\n", movie->trans_matrix[0]);    
+  fprintf(xmlout,   "        <TMb>0x%08x</TMb>\n", movie->trans_matrix[1]);    
+  fprintf(xmlout,   "        <TMu>0x%08x</TMu>\n", movie->trans_matrix[2]);    
+  fprintf(xmlout,   "        <TMc>0x%08x</TMc>\n", movie->trans_matrix[3]);    
+  fprintf(xmlout,   "        <TMd>0x%08x</TMd>\n", movie->trans_matrix[4]);    
+  fprintf(xmlout,   "        <TMv>0x%08x</TMv>\n", movie->trans_matrix[5]);    
+  fprintf(xmlout,   "        <TMx>0x%08x</TMx>\n", movie->trans_matrix[6]);    
+  fprintf(xmlout,   "        <TMy>0x%08x</TMy>\n", movie->trans_matrix[7]);    
+  fprintf(xmlout,   "        <TMw>0x%08x</TMw>\n", movie->trans_matrix[8]);
+  fprintf(xmlout,   "      </TransformationMatrix>\n");
+  fprintf(xmlout,   "    </MovieHeader>\n");
+  
+  fprintf(xmlout,   "    <Statistics>\n");
+  fprintf(xmlout,   "      <TracksFound>\n");
+  fprintf(xmlout,   "        <Video>%d</Video>\n", movie->num_vtk);
+  fprintf(xmlout,   "        <Audio>%d</Audio>\n", movie->num_stk);
+  fprintf(xmlout,   "        <Hint>%d</Hint>\n", movie->num_htk);
+  if(notes)
+    fprintf(xmlout, "        <!-- Hint tracks for streaming video are not part of MJ2, but are a defined extension. -->\n");
+  /* See Part 3 Amend 2 Section 4.2 for relation of MJ2 to Part 12 Sections 7 and 10 hints */
+  fprintf(xmlout,   "      </TracksFound>\n");
+  fprintf(xmlout,   "    </Statistics>\n");
+  /* Idea for the future:  It would be possible to add code to verify that the file values:
+    1) are legal and self-consistent
+	2) comply with particular JP2 and/or MJ2 profiles.
+	This could be reported here as additional XML elements */
+
+  // Find first video track 
+  tnum = 0;
+  while (movie->tk[tnum].track_type != 0)
+    tnum ++;
+
+  track = &(movie->tk[tnum]);
+  // For now, output info on first video track
+  xml_write_trak(file, xmlout, track, tnum, sampleframe, event_mgr);
+
+  // to come:                <MovieExtends mvek> // possibly not in Simple Profile
+  xml_write_moov_udta(xmlout, movie); /* NO OP so far */ /* <UserDataBox udta> contains <CopyrightBox cprt> */
+  fprintf(xmlout,   "  </MovieBox>\n");
+  return 0;
+}
+
+/* --------------- */
+
+void uint_to_chars(unsigned int value, char* buf)
+{
+	/* buf is at least char[5] */
+    int i;
+    for (i = 3; i >= 0; i--)
+    {
+        buf[i] = (value & 0x000000ff);
+        value = (value >> 8);
+    }
+	buf[4] = '\0'; /* Precautionary */
+}
+
+/* ------------- */
+
+/* WINDOWS SPECIFIC */
+
+void UnixTimeToFileTime(time_t t, LPFILETIME pft)
+{
+  /* Windows specific.  From MS Q167296 */
+  /* 'time_t' represents seconds since midnight January 1, 1970 UTC (coordinated universal time). */
+  /* 64-bit FILETIME structure represents the number of 100-nanosecond intervals since January 1, 1601 UTC (coordinate universal time). */
+  LONGLONG ll; /* LONGLONG is a 64-bit value. */
+  ll = Int32x32To64(t, 10000000) + 116444736000000000;
+  pft->dwLowDateTime = (DWORD)ll;
+  /* pft->dwLowDateTime = (DWORD)(0x00000000ffffffff & ll); */
+  pft->dwHighDateTime = (DWORD)(ll >> 32);
+} 
+// Once the UNIX time is converted to a FILETIME structure,
+// other Win32 time formats can be easily obtained by using Win32 functions such
+// as FileTimeToSystemTime() and FileTimeToDosDateTime().
+
+/* ------------- */
+
+void UnixTimeToSystemTime(time_t t, LPSYSTEMTIME pst)
+{
+  /* Windows specific */
+  FILETIME ft;
+  UnixTimeToFileTime(t, &ft);
+  FileTimeToLocalFileTime( &ft, &ft ); /* Adjust from UTC to local time zone */
+  FileTimeToSystemTime(&ft, pst);
+}
+
+/* ------------- */
+
+void xml_time_out(FILE* xmlout, time_t t)
+{
+  /* Windows specific */
+  SYSTEMTIME st;
+  char szLocalDate[255], szLocalTime[255];
+  UnixTimeToSystemTime( t, &st );
+  GetDateFormat( LOCALE_USER_DEFAULT, DATE_LONGDATE, &st, NULL, szLocalDate, 255 );
+  GetTimeFormat( LOCALE_USER_DEFAULT, 0, &st, NULL, szLocalTime, 255 );
+  fprintf(xmlout, "%s %s", szLocalDate, szLocalTime ); 
+}
+
+/* END WINDOWS SPECIFIC */
+
+/* ------------- */
+
+void xml_write_moov_udta(FILE* xmlout, opj_mj2_t * movie) {
+  /* Compare with xml_write_udta */
+#ifdef NOTYET
+  /* NO-OP so far.  Optional UserData 'udta' (zero or one in moov or each trak)
+     can contain multiple Copyright 'cprt' with different language codes */
+  /* There may be nested non-standard boxes within udta */
+  IMAGINE movie->udta, movie->copyright_count, movie->copyright_language[i] (array of 16bit ints), movie->copyright_notice[i] (array of buffers)
+  PROBABLY ALSO NEED movie->udta_len or special handler for non-standard boxes
+  char buf[5];
+  int i;
+
+  if(movie->udta != 1)
+	  return; /* Not present */
+
+  fprintf(xmlout,    "    <UserData BoxType=\"udta\">\n");
+  for(i = 0; i < movie->copyright_count; i++) {
+    fprintf(xmlout,  "      <Copyright BoxType=\"cprt\"> Instance=\"%d\">\n", i+1);
+    int16_to_3packedchars((short int)movie->copyright_languages[i], buf);
+    fprintf(xmlout,  "        <Language>%s</Language>\n", buf);    /* 3 chars */
+    fprintf(xmlout,  "        <Notice>%s</Notice>\n",movie->copyright_notices[i]);
+    fprintf(xmlout,  "      </Copyright>\n", i+1);
+  }
+  /* TO DO: Non-standard boxes */
+  fprintf(xmlout,    "    </UserData>\n");
+#endif
+}
+
+void xml_write_free_and_skip(FILE* xmlout, opj_mj2_t * movie) {
+#ifdef NOTYET
+  /* NO-OP so far.  There can be zero or more instances of free and/or skip
+     at the top level of the file.  This may be a place where the user squirrel's metadata.
+	 Let's assume unstructured, and do a dump */
+  IMAGINE movie->free_and_skip, movie->free_and_skip_count, movie->free_and_skip_content[i] (array of buffers),
+	  movie->free_and_skip_len[i] (array of ints), movie->is_skip[i] (array of BOOL)
+  int i;
+
+  if(movie->free_and_skip != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < movie->free_and_skip_count; i++) {
+    if(movie->is_skip[i])
+      fprintf(xmlout,    "  <Skip BoxType=\"skip\">\n");
+	else
+      fprintf(xmlout,    "  <Free BoxType=\"free\">\n");
+
+    xml_out_dump_hex_and_ascii(xmlout, movie->free_and_skip_contents[i], movie->free_and_skip_len[i]);
+
+    if(movie->is_skip[i])
+      fprintf(xmlout,    "  </Skip>\n");
+	else
+      fprintf(xmlout,    "  </Free>\n");
+  }
+#endif
+}
+
+void xml_write_uuid(FILE* xmlout, opj_mj2_t * movie) {
+/* Univeral Unique IDs of 16 bytes.  */
+#ifdef NOTYET
+  /* NO-OP so far.  There can be zero or more instances of private uuid boxes in a file.
+     This function supports the top level of the file, but uuid may be elsewhere [not yet supported].
+	 This may be a place where the user squirrel's metadata.  Let's assume unstructured, and do a dump */
+  IMAGINE movie->uuid, movie->uuid_count, movie->uuid_content[i] (array of buffers),
+	  movie->uuid_len[i] (array of ints), movie->uuid_type[i] (array of 17-byte (16+null termination) buffers)
+  int i;
+
+  if(movie->uuid != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < movie->uuid_count; i++) {
+    fprintf(xmlout,    "  <PrivateExtension BoxType=\"uuid\" UUID=\"%s\">\n", movie->uuid_type[i]);
+	// See Part III section 5.2.1, 6.1, 6.2
+    xml_out_dump_hex_and_ascii(xmlout, movie->uuid_contents[i], movie->uuid_len[i]);
+    fprintf(xmlout,    "  </PrivateExtension>\n");
+  }
+#endif
+}
+
+/* ------------- */
+
+void xml_write_trak(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum, unsigned int sampleframe, opj_event_mgr_t *event_mgr)
+{
+  fprintf(xmlout,    "    <Track BoxType=\"trak\" Instance=\"%d\">\n", tnum);
+  xml_write_tkhd(file, xmlout, track, tnum);
+  // TO DO: TrackReferenceContainer 'tref'  just used in hint track
+  // TO DO: EditListContainer 'edts', contains EditList 'elst' with media-time, segment-duration, media-rate
+  xml_write_mdia(file, xmlout, track, tnum);
+  xml_write_udta(file, xmlout, track, tnum); // NO-OP so far.  Optional UserData 'udta', can contain multiple Copyright 'cprt'
+
+  if(track->track_type==0) { /* Only do for visual track */
+	/* sampleframe is from user option -f.  1 = first frame */
+    /* sampleframe of 0 is a user requests: no jp2 header */
+	/* Treat out-of-bounds values in the same way */
+	if(sampleframe > 0 && sampleframe <= track->num_samples) 
+    {
+      mj2_sample_t *sample;
+      unsigned int snum;
+
+      snum = sampleframe-1;
+      // Someday maybe do a smart range scan... for (snum=0; snum < track->num_samples; snum++){
+      //  fprintf(stdout,"Frame %d: ",snum+1);
+      sample = &track->sample[snum];
+	  if(xml_out_frame(file, xmlout, sample, snum, event_mgr))
+	    return; /* Not great error handling here */
+    }
+  }
+  fprintf(xmlout,    "    </Track>\n");
+}
+
+/* ------------- */
+
+void xml_write_tkhd(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum)
+{
+  fprintf(xmlout,    "      <TrackHeader BoxType=\"tkhd\">\n");
+  if(notes) {
+    fprintf(xmlout,  "      <!-- Not shown here: CreationTime, ModificationTime, Duration. -->\n");
+    fprintf(xmlout,  "      <!-- These 3 fields are reported under MediaHeader below.   When reading these 3, -->\n");
+    fprintf(xmlout,  "      <!-- m2j_to_metadata currently doesn't distinguish between TrackHeader and MediaHeader source. -->\n");
+    fprintf(xmlout,  "      <!-- If both found, value read from MediaHeader is used. -->\n");
+  }
+  fprintf(xmlout,    "        <TrackID>%u</TrackID>\n", track->track_ID);
+  if(track->track_type==0) /* For visual track */
+  {
+    fprintf(xmlout,  "        <TrackLayer>%d</TrackLayer>\n", track->layer);
+    if(notes)
+      fprintf(xmlout,"        <!-- front-to-back ordering of video tracks. 0 = normal, -1 is closer, etc. -->\n");
+  }
+  if(track->track_type!=0) /* volume irrelevant for visual track */
+  {
+#ifdef CURRENTSTRUCT
+    track->volume = track->volume << 8;
+#endif
+    fprintf(xmlout,  "        <Volume>\n");
+	if(notes) {
+      fprintf(xmlout,"          <!-- Track audio volume stored as fixed-point binary 8.8 value. Decimal value is approximation. -->\n");
+      fprintf(xmlout,"          <!-- Full, normal (default) value is 0x0100 (1.0) -->\n");
+	}
+	if(raw)
+      fprintf(xmlout,"          <AsHex>0x%04x</AsHex>\n", track->volume);
+	if(derived)
+      fprintf(xmlout,"          <AsDecimal>%6.3f</AsDecimal>\n", (double)track->volume/(double)0x0100);
+    fprintf(xmlout,  "        </Volume>\n");
+#ifdef CURRENTSTRUCT
+  if(notes)
+    fprintf(xmlout,  "        <!-- Current m2j_to_metadata implementation always shows bits to right of decimal as zeroed. -->\n");
+	track->volume = track->volume >> 8;
+#endif
+  }
+  if(track->track_type==0)
+  {
+    /* Transformation matrix for video                            */
+    fprintf(xmlout,  "        <TransformationMatrix>\n");
+	if(notes) {
+      fprintf(xmlout,"          <!-- Comments about matrix in MovieHeader apply here as well. -->\n");
+      fprintf(xmlout,"          <!-- This matrix is applied before MovieHeader one. -->\n");
+	}
+    fprintf(xmlout,  "          <TMa>0x%08x</TMa>\n", track->trans_matrix[0]);    
+    fprintf(xmlout,  "          <TMb>0x%08x</TMb>\n", track->trans_matrix[1]);    
+    fprintf(xmlout,  "          <TMu>0x%08x</TMu>\n", track->trans_matrix[2]);    
+    fprintf(xmlout,  "          <TMc>0x%08x</TMc>\n", track->trans_matrix[3]);    
+    fprintf(xmlout,  "          <TMd>0x%08x</TMd>\n", track->trans_matrix[4]);    
+    fprintf(xmlout,  "          <TMv>0x%08x</TMv>\n", track->trans_matrix[5]);    
+    fprintf(xmlout,  "          <TMx>0x%08x</TMx>\n", track->trans_matrix[6]);    
+    fprintf(xmlout,  "          <TMy>0x%08x</TMy>\n", track->trans_matrix[7]);    
+    fprintf(xmlout,  "          <TMw>0x%08x</TMw>\n", track->trans_matrix[8]);
+    fprintf(xmlout,  "        </TransformationMatrix>\n");
+  }
+#ifdef CURRENTSTRUCT
+  track->w = track->w << 16;
+  track->h = track->h << 16;
+#endif
+  if(notes) {
+    fprintf(xmlout,  "        <!-- Width and Height in pixels are for the presentation; frames will be scaled to this. -->\n");
+    fprintf(xmlout,  "        <!-- Both stored as fixed-point binary 16.16 values. Decimal values are approximations. -->\n");
+  }
+  fprintf(xmlout,    "        <Width>\n");
+  if(raw)
+    fprintf(xmlout,  "          <AsHex>0x%08x</AsHex>\n", track->w);
+  if(derived)
+    fprintf(xmlout,  "          <AsDecimal>%12.6f</AsDecimal>\n", (double)track->w/(double)0x00010000);        /* Rate to play presentation  (default = 0x00010000)          */
+  fprintf(xmlout,    "        </Width>\n");
+  fprintf(xmlout,    "        <Height>\n");
+  if(raw)
+    fprintf(xmlout,  "          <AsHex>0x%08x</AsHex>\n", track->h);
+  if(derived)
+    fprintf(xmlout,  "          <AsDecimal>%12.6f</AsDecimal>\n", (double)track->h/(double)0x00010000);        /* Rate to play presentation  (default = 0x00010000)          */
+  fprintf(xmlout,    "        </Height>\n");
+#ifdef CURRENTSTRUCT
+  if(notes) {
+    fprintf(xmlout,  "        <!-- Current m2j_to_metadata implementation always shows bits to right of decimal as zeroed. -->\n");
+    fprintf(xmlout,  "        <!-- Also, width and height values shown here will actually be those read from track's <VisualSampleEntry> if given. -->\n");
+  }
+  track->w = track->w >> 16;
+  track->h = track->h >> 16;
+#endif
+  fprintf(xmlout,    "      </TrackHeader>\n");
+}
+
+/* ------------- */
+
+void xml_write_udta(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum) {
+  /* NO-OP so far.  Optional UserData 'udta' (zero or one in moov or each trak)
+     can contain multiple Copyright 'cprt' with different language codes */
+  /* There may be nested non-standard boxes within udta */
+#ifdef NOTYET
+  IMAGINE track->udta, track->copyright_count, track->copyright_language[i] (array of 16bit ints), track->copyright_notice[i] (array of buffers)
+  PROBABLY ALSO NEED track->udta_len or special handler for non-standard boxes
+  char buf[5];
+  int i;
+
+  if(track->udta != 1)
+	  return; /* Not present */
+
+  fprintf(xmlout,    "      <UserData BoxType=\"udta\">\n");
+  for(i = 0; i < track->copyright_count; i++) {
+    fprintf(xmlout,  "        <Copyright BoxType=\"cprt\"> Instance=\"%d\">\n", i+1);
+    int16_to_3packedchars((short int)track->copyright_languages[i], buf);
+    fprintf(xmlout,  "          <Language>%s</Language>\n", buf);    /* 3 chars */
+    fprintf(xmlout,  "          <Notice>%s</Notice>\n",track->copyright_notices[i]);
+    fprintf(xmlout,  "        </Copyright>\n", i+1);
+  }
+  /* TO DO: Non-standard boxes */
+  fprintf(xmlout,    "      </UserData>\n");
+#endif
+}
+
+/* ------------- */
+
+void xml_write_mdia(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum)
+{
+  char buf[5];
+  int i, k;
+  buf[4] = '\0';
+
+  fprintf(xmlout,    "      <Media BoxType=\"mdia\">\n");
+  fprintf(xmlout,    "        <MediaHeader BoxType=\"mdhd\">\n");
+  fprintf(xmlout,    "          <CreationTime>\n");
+  if(raw)
+    fprintf(xmlout,  "            <InSeconds>%u</InSeconds>\n", track->creation_time);
+  if(notes)
+    fprintf(xmlout,  "            <!-- Seconds since start of Jan. 1, 1904 UTC (Greenwich) -->\n");
+  /*  2082844800 = seconds between 1/1/04 and 1/1/70 */
+  /* There's still a time zone offset problem not solved... but spec is ambigous as to whether stored time
+     should be local or UTC */
+  if(derived) {
+    fprintf(xmlout,  "            <AsLocalTime>"); 
+                                xml_time_out(xmlout, track->creation_time - 2082844800);
+                                                     fprintf(xmlout,"</AsLocalTime>\n");
+  }
+  fprintf(xmlout,    "          </CreationTime>\n");
+  fprintf(xmlout,    "          <ModificationTime>\n");
+  if(raw)
+    fprintf(xmlout,  "            <InSeconds>%u</InSeconds>\n", track->modification_time);
+  if(derived) {
+    fprintf(xmlout,  "            <AsLocalTime>"); 
+                                xml_time_out(xmlout, track->modification_time - 2082844800);
+                                                     fprintf(xmlout,"</AsLocalTime>\n");
+  }
+  fprintf(xmlout,    "          </ModificationTime>\n");
+  fprintf(xmlout,    "          <Timescale>%d</Timescale>\n", track->timescale);
+  if(notes)
+    fprintf(xmlout,  "          <!-- Timescale defines time units in one second -->\n");
+  fprintf(xmlout,    "          <Duration>\n");
+  if(raw)
+    fprintf(xmlout,  "            <InTimeUnits>%u</InTimeUnits>\n", track->duration);
+  if(derived)
+    fprintf(xmlout,  "            <InSeconds>%12.3f</InSeconds>\n", (double)track->duration/(double)track->timescale);    // Make this double later to get fractional seconds
+  fprintf(xmlout,    "          </Duration>\n");
+  int16_to_3packedchars((short int)track->language, buf);
+  fprintf(xmlout,    "          <Language>%s</Language>\n", buf);    /* 3 chars */
+  fprintf(xmlout,    "        </MediaHeader>\n");
+  fprintf(xmlout,    "        <HandlerReference BoxType=\"hdlr\">\n");
+  switch(track->track_type)
+  {
+  case 0:
+    fprintf(xmlout,  "          <HandlerType Code=\"vide\">video media track</HandlerType>\n"); break;
+  case 1:
+    fprintf(xmlout,  "          <HandlerType Code=\"soun\">Sound</HandlerType>\n"); break;
+  case 2:
+    fprintf(xmlout,  "          <HandlerType Code=\"hint\">Hint</HandlerType>\n"); break;
+  }
+  if(notes) {
+    fprintf(xmlout,  "          <!-- String value shown is not actually read from file. -->\n");
+    fprintf(xmlout,  "          <!-- Shown value is one used for our encode. -->\n");
+  }
+  fprintf(xmlout,    "        </HandlerReference>\n");
+  fprintf(xmlout,    "        <MediaInfoContainer BoxType=\"minf\">\n");
+  switch(track->track_type)
+  {
+  case 0:
+    fprintf(xmlout,  "          <VideoMediaHeader BoxType=\"vmhd\">\n");
+    fprintf(xmlout,  "            <GraphicsMode>0x%02x</GraphicsMode>\n", track->graphicsmode);
+	if(notes) {
+      fprintf(xmlout,"            <!-- Enumerated values of graphics mode: -->\n");
+      fprintf(xmlout,"            <!--  0x00 = copy (over existing image); -->\n");
+      fprintf(xmlout,"            <!--  0x24 = transparent; 'blue-screen' this image using opcolor; -->\n");
+      fprintf(xmlout,"            <!--  0x100 = alpha; alpha-blend this image -->\n");
+/*    fprintf(xmlout,"            <!--  0x101 = whitealpha; alpha-blend this image, which has been blended with white; -->\n"); This was evidently dropped upon amendment */
+      fprintf(xmlout,"            <!--  0x102 = pre-multiplied black alpha; image has been already been alpha-blended with black. -->\n");
+      fprintf(xmlout,"            <!--  0x110 = component alpha; blend alpha channel(s) and color channels individually. -->\n");
+	}
+    fprintf(xmlout,  "            <Opcolor>\n");
+    fprintf(xmlout,  "              <Red>0x%02x</Red>\n", track->opcolor[0]);
+    fprintf(xmlout,  "              <Green>0x%02x</Green>\n",track->opcolor[1]);
+    fprintf(xmlout,  "              <Blue>0x%02x</Blue>\n",track->opcolor[2]);
+    fprintf(xmlout,  "            </Opcolor>\n");
+    fprintf(xmlout,  "          </VideoMediaHeader>\n");
+    break;
+  case 1:
+    fprintf(xmlout,  "          <SoundMediaHeader BoxType=\"smhd\">\n");
+#ifdef CURRENTSTRUCT
+	track->balance = track->balance << 8;
+#endif
+    fprintf(xmlout,  "            <Balance>\n");
+	if(notes) {
+      fprintf(xmlout,"              <!-- Track audio balance fixes mono track in stereo space. -->\n");
+      fprintf(xmlout,"              <!-- Stored as fixed-point binary 8.8 value. Decimal value is approximation. -->\n");
+      fprintf(xmlout,"              <!-- 0.0 = center, -1.0 = full left, 1.0 = full right -->\n");
+	}
+	if(raw)
+      fprintf(xmlout,"              <AsHex>0x%04x</AsHex>\n", track->balance);
+    if(derived)
+	  fprintf(xmlout,"              <AsDecimal>%6.3f</AsDecimal>\n", (double)track->balance/(double)0x0100);
+    fprintf(xmlout,  "            </Balance>\n");
+#ifdef CURRENTSTRUCT
+    if(notes)
+	  fprintf(xmlout,"            <!-- Current m2j_to_metadata implementation always shows bits to right of decimal as zeroed. -->\n");
+	track->balance = track->balance >> 8;
+#endif
+    fprintf(xmlout,  "          </SoundMediaHeader>\n");
+    break;
+  case 2:
+    fprintf(xmlout,  "          <HintMediaHeader BoxType=\"hmhd\">\n");
+    fprintf(xmlout,  "            <MaxPDU_Size>%d</MaxPDU_Size>\n", track->maxPDUsize);
+    if(notes)
+      fprintf(xmlout,"            <!-- Size in bytes of largest PDU in this hint stream. -->\n");
+    fprintf(xmlout,  "            <AvgPDU_Size>%d</AvgPDU_Size>\n", track->avgPDUsize);
+    if(notes)
+      fprintf(xmlout,"            <!-- Average size in bytes of a PDU over the entire presentation. -->\n");
+    fprintf(xmlout,  "            <MaxBitRate>%d</MaxBitRate>\n", track->maxbitrate);
+    if(notes)
+      fprintf(xmlout,"            <!-- Maximum rate in bits per second over any window of 1 second. -->\n");
+    fprintf(xmlout,  "            <AvgBitRate>%d</AvgBitRate>\n", track->avgbitrate);
+    if(notes)
+      fprintf(xmlout,"            <!-- Averate rate in bits per second over the entire presentation. -->\n");
+    fprintf(xmlout,  "            <SlidingAvgBit>%d</SlidingAvgBitRate>\n", track->slidingavgbitrate);
+    if(notes)
+      fprintf(xmlout,"            <!-- Maximum rate in bits per second over any window of one minute. -->\n");
+    fprintf(xmlout,  "          </HintMediaHeader>\n");
+    break;
+  }
+  fprintf(xmlout,    "          <DataInfo BoxType=\"dinf\">\n");
+  fprintf(xmlout,    "            <DataReference BoxType=\"dref\"  URL_Count=\"%d\" URN_Count=\"%d\">\n", track->num_url, track->num_urn); // table w. flags, URLs, URNs
+  // Data structure does not distinguish between single URL, single URN, or DREF table or URLs & URNs.
+  // We could infer those, but for now just present everything as a DREF table.
+  if(notes)
+    fprintf(xmlout,  "              <!-- No entries here mean that file is self-contained, as required by Simple Profile. -->\n");
+  for(k = 0; k < track->num_url; k++) {
+    fprintf(xmlout,  "            <DataEntryUrlBox BoxType=\"url[space]\">\n"); // table w. flags, URLs, URNs
+    if(notes)
+      fprintf(xmlout,"              <!-- Only the first 16 bytes of URL location are recorded in mj2_to_metadata data structure. -->\n");
+    for(i = 0; i < 4; i++) {
+      uint_to_chars(track->url[track->num_url].location[i], buf);
+    fprintf(xmlout,  "              <Location>%s</Location>\n");
+    }
+    fprintf(xmlout,  "            </DataEntryUrlBox>\n"); // table w. flags, URLs, URNs
+  }
+  for(k = 0; k < track->num_urn; k++) {
+    fprintf(xmlout,"            <DataEntryUrnBox BoxType=\"urn[space]\">\n"); // table w. flags, URLs, URNs
+    // Only the first 16 bytes are recorded in the data structure currently.
+    if(notes)
+      fprintf(xmlout,"              <!-- Only the first 16 bytes each of URN name and optional location are recorded in mj2_to_metadata data structure. -->\n");
+    fprintf(xmlout,  "              <Name>");
+    for(i = 0; i < 4; i++) {
+      uint_to_chars(track->urn[track->num_urn].name[i], buf);
+      fprintf(xmlout,"%s", buf);
+    }
+    fprintf(xmlout,  "</Name>\n");
+    fprintf(xmlout,  "              <Location>");
+    for(i = 0; i < 4; i++) {
+      uint_to_chars(track->urn[track->num_urn].location[i], buf);
+      fprintf(xmlout,"%s");
+    }
+    fprintf(xmlout,  "</Location>\n");
+    fprintf(xmlout,  "            </DataEntryUrnBox>\n");
+  }
+  fprintf(xmlout,    "            </DataReference>\n");
+  fprintf(xmlout,    "          </DataInfo>\n");
+
+  xml_write_stbl(file, xmlout, track, tnum); /* SampleTable */
+
+  fprintf(xmlout,    "        </MediaInfoContainer>\n");  
+  fprintf(xmlout,    "      </Media>\n");
+}
+
+/* ------------- */
+
+void xml_write_stbl(FILE* file, FILE* xmlout, mj2_tk_t *track, unsigned int tnum)
+{
+  char buf[5], buf33[33];
+  int i, len;
+  buf[4] = '\0';
+
+  fprintf(xmlout,      "          <SampleTable BoxType=\"stbl\">\n");
+  if(notes)
+    fprintf(xmlout,    "            <!-- What follows are specific instances of generic SampleDescription BoxType=\"stsd\" -->\n");
+  switch(track->track_type)
+  {
+  case 0:
+    // There could be multiple instances of this, but "entry_count" is just a local at read-time.
+    // And it's used wrong, too, as count of just visual type, when it's really all 3 types.
+    // This is referred to as "smj2" within mj2.c
+    fprintf(xmlout,    "            <VisualSampleEntry BoxType=\"mjp2\">\n");
+	if(notes) {
+      fprintf(xmlout,  "            <!-- If multiple instances of this box, only first is shown here. -->\n");
+	  fprintf(xmlout,  "            <!-- Width and Height are in pixels.  Unlike the Track Header, there is no fractional part. -->\n");
+	  fprintf(xmlout,  "            <!-- In mj2_to_metadata implementation, the values are not represented separately from Track Header's values. -->\n");
+	}
+	/* No shifting required.  If CURRENTSTRUCT gets changed, then may need to revisit treatment of these */
+    fprintf(xmlout,    "              <WidthAsInteger>%d</WidthAsInteger>\n", track->w);
+    fprintf(xmlout,    "              <HeightAsInteger>%d</HeightAsInteger>\n", track->h);
+// Horizresolution and vertresolution don't require shifting, already stored right in CURRENTSTRUCT
+    if(notes) {
+      fprintf(xmlout,  "              <!-- Resolutions are in pixels per inch, for the highest-resolution component (typically luminance). -->\n");
+      fprintf(xmlout,  "              <!-- Both stored as fixed-point binary 16.16 values. Decimal values are approximations. -->\n");
+      fprintf(xmlout,  "              <!-- Typical value for both resolutions is 0x00480000  (72.0) -->\n");
+	}
+    fprintf(xmlout,    "              <HorizontalRes>\n");
+	if(raw)
+      fprintf(xmlout,  "                <AsHex>0x%08x</AsHex>\n", track->horizresolution);
+	if(derived)
+      fprintf(xmlout,  "                <AsDecimal>%12.6f</AsDecimal>\n", (double)track->horizresolution/(double)0x00010000);        /* Rate to play presentation  (default = 0x00010000)          */
+    fprintf(xmlout,    "              </HorizontalRes>\n");
+    fprintf(xmlout,    "              <VerticalRes>\n");
+	if(raw)
+      fprintf(xmlout,  "                <AsHex>0x%08x</AsHex>\n", track->vertresolution);
+	if(derived)
+      fprintf(xmlout,  "                <AsDecimal>%12.6f</AsDecimal>\n", (double)track->vertresolution/(double)0x00010000);        /* Rate to play presentation  (default = 0x00010000)          */
+    fprintf(xmlout,    "              </VerticalRes>\n");
+
+    buf33[0] = '\0';
+    for(i = 0; i < 8; i++) {
+      uint_to_chars((unsigned int)track->compressorname[i], buf);
+      strcat(buf33, buf); /* This loads up (4 * 8) + 1 chars, but trailing ones are usually junk */
+    }
+    len = (int)buf33[0]; /* First byte has string length in bytes.  There may be garbage beyond it. */
+    buf33[len+1] = '\0'; /* Suppress it */
+    fprintf(xmlout,    "              <CompressorName>%s</CompressorName>\n", buf33+1); /* Start beyond first byte */
+	if(notes) {
+      fprintf(xmlout,  "              <!-- Compressor name for debugging.  Standard restricts max length to 31 bytes. -->\n");
+      fprintf(xmlout,  "              <!-- Usually blank or \"Motion JPEG2000\" -->\n");
+	}
+    fprintf(xmlout,    "              <Depth>0x%02x</Depth>\n",track->depth);
+	if(notes) {
+      fprintf(xmlout,  "              <!-- Depth is: -->\n");
+      fprintf(xmlout,  "              <!--   0x20: alpha channels present (color or grayscale) -->\n");
+      fprintf(xmlout,  "              <!--   0x28: grayscale without alpha -->\n");
+      fprintf(xmlout,  "              <!--   0x18: color without alpha -->\n");
+	}
+
+    xml_out_frame_jp2h(xmlout, &(track->jp2_struct));  /* JP2 Header */
+    
+  /* Following subboxes are optional */
+    fprintf(xmlout,    "              <FieldCoding BoxType=\"fiel\">\n");
+    fprintf(xmlout,    "                <FieldCount>%d</FieldCount>\n", (unsigned int)track->fieldcount); /* uchar as 1 byte uint */
+    if(notes)
+      fprintf(xmlout,  "                <!-- Must be either 1 or 2 -->\n");
+    fprintf(xmlout,    "                <FieldOrder>%d</FieldOrder>\n", (unsigned int)track->fieldorder); /* uchar as 1 byte uint */
+	if(notes) {
+      fprintf(xmlout,  "                <!-- When FieldCount=2, FieldOrder means: -->\n");
+      fprintf(xmlout,  "                <!--   0: Field coding unknown -->\n");
+      fprintf(xmlout,  "                <!--   1: Field with topmost line is stored first in sample; fields are in temporal order -->\n");
+      fprintf(xmlout,  "                <!--   6: Field with topmost line is stored second in sample; fields are in temporal order -->\n");
+      fprintf(xmlout,  "                <!-- Defaults: FieldCount=1, FieldOrder=0 if FieldCoding box not present -->\n");
+      fprintf(xmlout,  "                <!-- Current implementation doesn't retain whether box was actually present. -->\n");
+	}
+    fprintf(xmlout,    "              </FieldCoding>\n");
+
+    fprintf(xmlout,    "              <MJP2_Profile BoxType=\"jp2p\" Count=\"%d\">\n",track->num_br);
+    for (i = 0; i < track->num_br; i++) /* read routine stored in reverse order, so let's undo damage */
+    {
+      uint_to_chars(track->br[i], buf);
+      fprintf(xmlout,  "                <CompatibleBrand>%s</CompatibleBrand>\n", buf);    /*4 characters, each CLi */
+    }
+    fprintf(xmlout,    "              </MJP2_Profile>\n");
+
+    fprintf(xmlout,    "              <MJP2_Prefix BoxType=\"jp2x\" Count=\"%d\">\n",track->num_jp2x);
+    for (i = 0; i < track->num_jp2x; i++)
+    { // We'll probably need better formatting than this
+      fprintf(xmlout,  "                <Data>0x%02x</Data>\n", track->jp2xdata[i]);    /* Each entry is single byte */
+    }
+    fprintf(xmlout,    "              </MJP2_Prefix>\n");
+
+    fprintf(xmlout,    "              <MJP2_SubSampling BoxType=\"jsub\">\n"); /* These values are all 1 byte */
+    if(notes)
+	  fprintf(xmlout,  "              <!-- Typical subsample value is 2 for 4:2:0 -->\n");
+    fprintf(xmlout,    "                <HorizontalSub>%d</HorizontalSub>\n", track->hsub);
+    fprintf(xmlout,    "                <VerticalSub>%d</VerticalSub>\n", track->vsub);
+    fprintf(xmlout,    "                <HorizontalOffset>%d</HorizontalOffset>\n", track->hoff);
+    fprintf(xmlout,    "                <VerticalOffset>%d</VerticalOffset>\n", track->voff);
+	if(notes) {
+	  fprintf(xmlout,  "                <!-- Typical {horizontal, vertical} chroma offset values: -->\n");
+	  fprintf(xmlout,  "                <!-- 4:2:2 format (CCIR601, H.262, MPEG2, MPEG4, recom. Exif): {0, 0} -->\n");
+	  fprintf(xmlout,  "                <!-- 4:2:2 format (JFIF):                                      {1, 0} -->\n");
+	  fprintf(xmlout,  "                <!-- 4:2:0 format (H.262, MPEG2, MPEG4):                       {0, 1} -->\n");
+	  fprintf(xmlout,  "                <!-- 4:2:0 format (MPEG1, H.261, JFIF, recom. Exif):           {1, 1} -->\n");
+	}
+    fprintf(xmlout,    "              </MJP2_SubSampling>\n"); /* These values are all 1 byte */
+
+    fprintf(xmlout,    "              <MJP2_OriginalFormat BoxType=\"orfo\">\n"); /* Part III Appx. 2 */
+    fprintf(xmlout,    "                <OriginalFieldCount>%u</OriginalFieldCount>\n", (unsigned int)track->or_fieldcount); /* uchar as 1-byte uint */
+    if(notes)
+      fprintf(xmlout,  "                <!-- In original material before encoding.  Must be either 1 or 2 -->\n");
+    fprintf(xmlout,    "                <OriginalFieldOrder>%u</OriginalFieldOrder>\n", (unsigned int)track->or_fieldorder); /* uchar as 1-byte uint */
+	if(notes) {
+      fprintf(xmlout,  "                <!-- When FieldCount=2, FieldOrder means: -->\n");
+      fprintf(xmlout,  "                <!--   0: Field coding unknown -->\n");
+      fprintf(xmlout,  "                <!--   11: Topmost line came from the earlier field; -->\n");
+      fprintf(xmlout,  "                <!--   16:  Topmost line came form the later field. -->\n");
+      fprintf(xmlout,  "                <!-- Defaults: FieldCount=1, FieldOrder=0 if FieldCoding box not present -->\n");
+      fprintf(xmlout,  "                <!-- Current implementation doesn't retain whether box was actually present. -->\n");
+	}
+    fprintf(xmlout,    "              </MJP2_OriginalFormat>\n");
+    fprintf(xmlout,    "            </VisualSampleEntry>\n");
+    break;
+  case 1: case 2:
+    if(notes)
+      fprintf(xmlout,  "            <!-- mj2_to_metadata's data structure doesn't record this currently. -->\n"); break;
+  }
+  fprintf(xmlout,      "            <TimeToSample BoxType=\"stts\">\n");  
+  fprintf(xmlout,      "              <SampleStatistics>\n");  
+  fprintf(xmlout,      "                <TotalSamples>%d</TotalSamples>\n", track->num_samples);
+  if(notes)
+    fprintf(xmlout,    "                <!-- For video, gives the total frames in the track, by summing all entries in the Sample Table -->\n");
+  fprintf(xmlout,      "              </SampleStatistics>\n"); 
+  fprintf(xmlout,      "              <SampleEntries EntryCount=\"%d\">\n", track->num_tts);
+  for (i = 0; i < track->num_tts; i++) {
+    fprintf(xmlout,    "                <Table Entry=\"%u\" SampleCount=\"%d\" SampleDelta=\"%u\" />\n",
+                                      i+1, track->tts[i].sample_count, track->tts[i].sample_delta);
+  }
+  fprintf(xmlout,      "              </SampleEntries>\n");
+  fprintf(xmlout,      "            </TimeToSample>\n");
+
+  fprintf(xmlout,      "            <SampleToChunk BoxType=\"stsc\" Count=\"%d\">\n", track->num_samplestochunk);
+  for (i = 0; i < track->num_samplestochunk; i++) {
+    fprintf(xmlout,    "              <FirstChunk>%u</FirstChunk>\n",track->sampletochunk[i].first_chunk); /* 4 bytes */
+    fprintf(xmlout,    "              <SamplesPerChunk>%u</SamplesPerChunk>\n",track->sampletochunk[i].samples_per_chunk); /* 4 bytes */
+    fprintf(xmlout,    "              <SampleDescrIndex>%u</SampleDescrIndex>\n",track->sampletochunk[i].sample_descr_idx); /* 4 bytes */
+  }
+  fprintf(xmlout,      "            </SampleToChunk>\n");
+  // After reading this info in, track->num_chunks is calculated and a decompressed table established internally.
+
+  fprintf(xmlout,      "            <SampleSize BoxType=\"stsz\">\n");
+  if(track->same_sample_size) {
+    // all values in track->sample[i].sample_size are equal.  Grab the first one.
+    fprintf(xmlout,    "              <Sample_Size>%u</Sample_Size>\n", track->sample[0].sample_size);
+	if(notes) {
+      fprintf(xmlout,  "              <!-- Non-zero value means all samples have that size. -->\n");
+	  fprintf(xmlout,  "              <!-- So <Sample_Count> (aka Entry_Count in std.) has no meaning, is suppressed from this output, and no table follows. -->\n");
+	}
+  } else {
+    fprintf(xmlout,    "              <Sample_Size>0</Sample_Size>\n");
+    if(notes)
+	  if(sampletables)
+        fprintf(xmlout,"              <!-- Zero value means samples have different sizes, given in table next of length Sample_Count (aka Entry_Count in std). -->\n");
+	  else
+        fprintf(xmlout,"              <!-- Zero value means samples have different sizes, given in table (not shown) of length Sample_Count (aka Entry_Count in std). -->\n");
+	fprintf(xmlout,    "              <Sample_Count>%u</Sample_Count>\n", track->num_samples);
+	if(sampletables)
+     for (i = 0; i < (int)track->num_samples; i++) {
+      fprintf(xmlout,  "              <EntrySize Num=\"%u\">%u</EntrySize>\n", i+1, track->sample[i].sample_size);
+     }
+  }  
+  fprintf(xmlout,      "            </SampleSize>\n");
+
+  fprintf(xmlout,      "            <ChunkOffset BoxType=\"stco\">\n");
+  // Structure not yet - Variant ChunkLargeOffset 'co64'
+  fprintf(xmlout,      "              <EntryCount>%u</EntryCount>\n", track->num_chunks);
+  if(notes) {
+    fprintf(xmlout,    "              <!-- For this implementation, EntryCount shown is one calculated during file read of <SampleToChunk> data. -->\n");
+    fprintf(xmlout,    "              <!-- Implementation will report failure during file read of <ChunkOffset> data if read entry-count disagrees. -->\n");
+  }
+  if(sampletables)
+    for (i = 0; i < (int)track->num_chunks; i++)
+      fprintf(xmlout,  "              <Chunk_Offset Num=\"%d\">%u</Chunk_Offset>\n", i+1, track->chunk[i].offset);
+  fprintf(xmlout,      "            </ChunkOffset>\n");
+
+  fprintf(xmlout,      "          </SampleTable>\n");
+}
+
+/* ------------- */
+
+int xml_out_frame(FILE* file, FILE* xmlout, mj2_sample_t *sample, unsigned int snum, opj_event_mgr_t *event_mgr)
+{
+	opj_dparameters_t parameters;	/* decompression parameters */
+  opj_image_t *img;
+  opj_cp_t *cp;
+  int i;
+  int numcomps;
+  unsigned char* frame_codestream;
+	opj_dinfo_t* dinfo = NULL;	/* handle to a decompressor */
+	opj_cio_t *cio = NULL;	
+	opj_j2k_t *j2k;
+
+	/* JPEG 2000 compressed image data */
+
+	/* get a decoder handle */
+	dinfo = opj_create_decompress(CODEC_J2K);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, event_mgr, stderr);
+
+	/* setup the decoder decoding parameters using the current image and user parameters */
+	parameters.cp_limit_decoding = DECODE_ALL_BUT_PACKETS;
+	opj_setup_decoder(dinfo, &parameters);	
+
+  frame_codestream = (unsigned char*) malloc (sample->sample_size-8); /* Skipping JP2C marker */
+  if(frame_codestream == NULL)
+	  return 1;
+
+  fseek(file,sample->offset+8,SEEK_SET);
+  fread(frame_codestream,sample->sample_size-8,1, file);  /* Assuming that jp and ftyp markers size do */
+
+	/* open a byte stream */
+	cio = opj_cio_open((opj_common_ptr)dinfo, frame_codestream, sample->sample_size-8);
+
+  /* Decode J2K to image: */
+	img = opj_decode(dinfo, cio);
+  if (!img) {
+		fprintf(stderr, "ERROR -> j2k_to_image: failed to decode image!\n");
+		opj_destroy_decompress(dinfo);
+		opj_cio_close(cio);
+		return 1;
+	}
+
+	j2k = (opj_j2k_t*)dinfo->j2k_handle;
+	j2k_default_tcp = j2k->default_tcp;
+	cp = j2k->cp;
+
+  numcomps = img->numcomps;
+  /*  Alignments:        "      <       To help maintain xml pretty-printing */  
+  fprintf(xmlout,      "      <JP2_Frame Num=\"%d\">\n", snum+1);
+  fprintf(xmlout,      "        <MainHeader>\n");
+  /* There can be multiple codestreams; a particular image is entirely within a single codestream */
+  /* TO DO:  A frame can be represented by two I-guess-contigious codestreams if its interleaved. */
+  fprintf(xmlout,      "          <StartOfCodestream Marker=\"SOC\" />\n");
+  /* "cp" stands for "coding parameter"; "tcp" is tile coding parameters, "tccp" is tile-component coding parameters */
+  xml_out_frame_siz(xmlout, img, cp); /* reqd in main */
+  xml_out_frame_cod(xmlout, j2k_default_tcp); /* reqd in main */
+  xml_out_frame_coc(xmlout, j2k_default_tcp, numcomps); /* opt in main, at most 1 per component */
+  xml_out_frame_qcd(xmlout, j2k_default_tcp); /* reqd in main */
+  xml_out_frame_qcc(xmlout, j2k_default_tcp, numcomps);	/* opt in main, at most 1 per component */
+  xml_out_frame_rgn(xmlout, j2k_default_tcp, numcomps); /* opt, at most 1 per component */
+  xml_out_frame_poc(xmlout, j2k_default_tcp); /*  opt (but reqd in main or tile for any progression order changes) */
+  /* Next four get j2k_default_tcp passed globally: */
+#ifdef SUPPRESS_FOR_NOW
+  xml_out_frame_ppm(xmlout, cp); /* opt (but either PPM or PPT [distributed in tile headers] or codestream packet header reqd) */
+#endif
+  xml_out_frame_tlm(xmlout); /* NO-OP.  TLM NOT SAVED IN DATA STRUCTURE */ /* opt */
+  xml_out_frame_plm(xmlout); /* NO-OP.  PLM NOT SAVED IN DATA STRUCTURE */ /* opt in main; can be used in conjunction with PLT */
+  xml_out_frame_crg(xmlout); /* NO-OP.  CRG NOT SAVED IN DATA STRUCTURE */ /* opt in main; */
+  xml_out_frame_com(xmlout, j2k_default_tcp); /* NO-OP.  COM NOT SAVED IN DATA STRUCTURE */ /* opt in main; */
+
+  fprintf(xmlout,      "        </MainHeader>\n");
+
+  /*	TO DO: all the tile headers (sigh)  */
+  fprintf(xmlout,      "        <TilePartHeaders Count=\"%d\">\n", cp->tileno_size);		/* size of the vector tileno */
+  for(i = 0; i < cp->tileno_size; i++) { /* I think cp->tileno_size will be same number as (cp->tw * cp->th) or as global j2k_curtileno */
+    // Standard seems to use zero-based # for tile-part.
+    fprintf(xmlout,    "          <TilePartHeader Num=\"%d\" ID=\"%d\">\n", i, cp->tileno[i]);			/* ID number of the tiles present in the codestream */
+    fprintf(xmlout,    "            <StartOfTilePart Marker=\"SOT\" />\n");
+	/* All markers in tile-part headers (between SOT and SOD) are optional, unless structure requires. */
+    if(i == 0) {
+      xml_out_frame_cod(xmlout, &(cp->tcps[i])); /* No more than 1 per tile */
+      xml_out_frame_coc(xmlout, &(cp->tcps[i]), numcomps); /* No more than 1 per component */
+      xml_out_frame_qcd(xmlout, &(cp->tcps[i])); /* No more than 1 per tile */
+      xml_out_frame_qcc(xmlout, &(cp->tcps[i]), numcomps);	/* No more than 1 per component */
+      xml_out_frame_rgn(xmlout, &(cp->tcps[i]), numcomps); /* No more than 1 per component */
+    }
+    xml_out_frame_poc(xmlout, &(cp->tcps[i])); /* Reqd only if any progression order changes different from main POC */
+#ifdef SUPPRESS_FOR_NOW
+    xml_out_frame_ppt(xmlout, &(cp->tcps[i])); /* Either PPT [distributed in tile headers] or PPM or codestream packet header reqd. */
+#endif
+    xml_out_frame_plt(xmlout, &(cp->tcps[i])); /* NO-OP.  PLT NOT SAVED IN DATA STRUCTURE */ /* Can be used in conjunction with main's PLM */
+    xml_out_frame_com(xmlout, &(cp->tcps[i])); /* NO-OP.  COM NOT SAVED IN DATA STRUCTURE */
+    /* opj_tcp_t * cp->tcps; "tile coding parameters" */
+    /* Maybe not: fprintf(xmlout,  "        <>%d</>, cp->matrice[i];			*/ /* Fixed layer    */
+    fprintf(xmlout,    "            <StartOfData Marker=\"SOD\" />\n");
+    if(notes)
+      fprintf(xmlout,  "            <!-- Tile-part bitstream, not shown, follows tile-part header and SOD marker. -->\n");
+    fprintf(xmlout,    "          </TilePartHeader>\n");
+  }
+  fprintf(xmlout,      "        </TilePartHeaders>\n");		/* size of the vector tileno */
+
+#ifdef NOTYET
+  IMAGINE the cp object has data to support the following... but we could use an new different data structure instead
+  /* I'm unclear if the span of the original fread(frame_codestream...) included the following items if they're trailing. */
+  /* ALSO TO DO, BUT DATA STRUCTURE DOESN'T HANDLE YET: boxes (anywhere in file except before the Filetype box): */
+  xml_out_frame_jp2i(xmlout, &cp); /* IntellectualProperty 'jp2i' (no restrictions on location) */
+  xml_out_frame_xml(xmlout, &cp); /* XML 'xml\040' (0x786d6c20).  Can appear multiply */
+  xml_out_frame_uuid(xmlout, &cp); /* UUID 'uuid' (top level only) */
+  xml_out_frame_uinf(xmlout, &cp); /* UUIDInfo 'uinf', includes UUIDList 'ulst' and URL 'url\40' */
+#endif
+
+  fprintf(xmlout,      "      </JP2_Frame>\n");
+
+  /* Extra commentary: */
+  if(notes) {
+    fprintf(xmlout,    "      <!-- Given the number and size of components, mj2_to_frame would try to convert this -->\n");
+    if (((img->numcomps == 3) && (img->comps[0].dx == img->comps[1].dx / 2) 
+      && (img->comps[0].dx == img->comps[2].dx / 2 ) && (img->comps[0].dx == 1)) 
+      || (img->numcomps == 1)) {
+      fprintf(xmlout,  "      <!-- file to a YUV movie in the normal manner. -->\n");
+    }
+    else if ((img->numcomps == 3) && 
+      (img->comps[0].dx == 1) && (img->comps[1].dx == 1)&&
+	  (img->comps[2].dx == 1))  {// If YUV 4:4:4 input --> to bmp
+	  fprintf(xmlout,  "      <!-- YUV 4:4:4 file to a series of .bmp files. -->\n");
+    }
+    else {
+	  fprintf(xmlout,  "      <!-- file whose image component dimension are unknown, to a series of .j2k files. -->\n");
+    }
+  }
+
+	opj_destroy_decompress(dinfo);
+	opj_cio_close(cio);
+  free(frame_codestream);
+
+  return 0;
+}
+
+/* ------------- */
+
+void int16_to_3packedchars(short int value, char* buf)
+{
+    /* This is to retrieve the 3-letter ASCII language code */
+    /* Each char is packed into 5 bits, as difference from 0x60 */
+    int i;
+    for (i = 2; i >= 0; i--)
+    {
+        buf[i] = (value & 0x001f) + 0x60;
+        value = (value >>5);
+    }
+    buf[3] = '\0';
+}
+
+/* ------------- */
+
+void xml_out_frame_siz(FILE* xmlout, opj_image_t *img, opj_cp_t *cp)
+{
+  opj_image_comp_t *comp;
+  int i;
+
+  fprintf(xmlout,    "          <ImageAndFileSize Marker=\"SIZ\">\n");
+  // This is similar to j2k.c's j2k_dump_image.
+  // Not of interest: Lsiz, Rsiz
+  fprintf(xmlout,    "            <Xsiz>%d</Xsiz>\n", img->x1);
+  fprintf(xmlout,    "            <Ysiz>%d</Ysiz>\n", img->y1);
+  if(notes)
+    fprintf(xmlout,  "            <!-- Xsiz, Ysiz is the size of the reference grid. -->\n");
+  fprintf(xmlout,    "            <XOsiz>%d</XOsiz>\n", img->x0);
+  fprintf(xmlout,    "            <YOsiz>%d</YOsiz>\n", img->y0);
+  if(notes)
+    fprintf(xmlout,  "            <!-- XOsiz, YOsiz are offsets from grid origin to image origin. -->\n");
+  fprintf(xmlout,    "            <XTsiz>%d</XTsiz>\n", cp->tdx);
+  fprintf(xmlout,    "            <YTsiz>%d</YTsiz>\n", cp->tdy);
+  if(notes)
+    fprintf(xmlout,  "            <!-- XTsiz, YTsiz is the size of one tile with respect to the grid. -->\n");
+  fprintf(xmlout,    "            <XTOsiz>%d</XTOsiz>\n", cp->tx0);
+  fprintf(xmlout,    "            <YTOsiz>%d</YTOsiz>\n", cp->ty0);
+  if(notes)
+    fprintf(xmlout,  "            <!-- XTOsiz, YTOsiz are offsets from grid origin to first tile origin. -->\n");
+  fprintf(xmlout,    "            <Csiz>%d</Csiz>\n", img->numcomps);
+  if(notes) {
+    fprintf(xmlout,  "            <!-- Csiz is the number of components in the image. -->\n");
+    fprintf(xmlout,  "            <!-- For image components next: -->\n");
+    fprintf(xmlout,  "            <!--   XRsiz, YRsiz denote pixel-sample-spacing on the grid, per Part I Annex B. -->\n");
+    //fprintf(xmlout,"            <!--   XO, YO is offset of the component compared to the whole image. -->\n");
+    fprintf(xmlout,  "            <!--   Bits per pixel (bpp) is the pixel depth. -->\n");
+    fprintf(xmlout,  "            <!--   WidthOfData and HeightOfData are calculated values, e.g.: w = roundup((Xsiz - XOsiz)/ XRsiz) -->\n");
+  }
+
+  for (i = 0; i < img->numcomps; i++) {/* image-components */
+    comp = &(img->comps[i]);
+    fprintf(xmlout,  "            <Component Num=\"%d\">\n", i+1);
+    fprintf(xmlout,  "              <Ssiz>\n");
+	if(raw)
+      fprintf(xmlout,"                <AsHex>0x%02x</AsHex>\n", (comp->sgnd << 7) & (comp->prec - 1));
+	if(derived) {
+      fprintf(xmlout,"                <Signed>%d</Signed>\n", comp->sgnd);
+      fprintf(xmlout,"                <PrecisionInBits>%d</PrecisionInBits>\n", comp->prec);
+	}
+    fprintf(xmlout,  "              </Ssiz>\n");
+    fprintf(xmlout,  "              <XRsiz>%d</XRsiz>\n", comp->dx);
+    fprintf(xmlout,  "              <YRsiz>%d</YRsiz>\n", comp->dy);
+    fprintf(xmlout,  "              <WidthOfData>%d</WidthOfData>\n", comp->w);
+    fprintf(xmlout,  "              <HeightOfData>%d</HeightOfData>\n", comp->h);
+    /* Rest of these aren't calculated when SIZ is read:
+    fprintf(xmlout,  "              <XO>%d</XO>\n", comp->x0);
+    fprintf(xmlout,  "              <YO>%d</YO>\n", comp->y0);
+	if(notes)
+	  fprintf(xmlout,"              <!--  XO, YO is offset of the component compared to the whole image. -->\n");
+    fprintf(xmlout,  "              <BitsPerPixel>%d</BitsPerPixel>\n", comp->bpp);
+    fprintf(xmlout,  "              <NumberOfDecodedResolution>%d</NumberOfDecodedResolution>\n", comp->resno_decoded); */
+    // SUPPRESS: n/a to mj2_to_metadata.  fprintf(xmlout,"        <Factor>%d</Factor\n", comp->factor);
+    /* factor = number of division by 2 of the out image  compare to the original size of image */
+    // TO DO comp->data:  int *data;			/* image-component data      */
+
+    fprintf(xmlout,  "            </Component>\n");
+  }
+  fprintf(xmlout,    "          </ImageAndFileSize>\n");
+}
+
+/* ------------- */
+
+void xml_out_frame_cod(FILE* xmlout, opj_tcp_t *tcp)
+{
+/* Could be called with tcp = &j2k_default_tcp;
+/* Or, for tile-part header, with &j2k_cp->tcps[j2k_curtileno]
+/*  Alignment for main:"          < < < <   To help maintain xml pretty-printing */  
+/*  Alignment for tile:"            < < <   To help maintain xml pretty-printing */  
+  opj_tccp_t *tccp;
+  int i;
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+  tccp = &(tcp->tccps[0]);
+
+  fprintf(xmlout,      "%s<CodingStyleDefault Marker=\"COD\">\n",s); /* Required in main header */
+  /* Not retained or of interest: Lcod */
+  fprintf(xmlout,      "%s  <Scod>0x%02x</Scod>\n", s, tcp->csty); /* 1 byte */
+  if(notes) {
+    fprintf(xmlout,    "%s  <!-- For Scod, specific bits mean (where bit 0 is lowest or rightmost): -->\n",s);
+    fprintf(xmlout,    "%s  <!-- bit 0: Defines entropy coder precincts -->\n",s);
+    fprintf(xmlout,    "%s  <!--        0 = (PPx=15, PPy=15); 1 = precincts defined below. -->\n",s);
+    fprintf(xmlout,    "%s  <!-- bit 1: 1 = SOP marker may be used; 0 = not. -->\n",s);
+    fprintf(xmlout,    "%s  <!-- bit 2: 1 = EPH marker may be used; 0 = not. -->\n",s);
+  }
+  fprintf(xmlout,      "%s  <SGcod>\n",s);
+  fprintf(xmlout,      "%s    <ProgressionOrder>%d</ProgressionOrder>\n", s, tcp->prg); /* 1 byte, SGcod (A) */
+  if(notes) {
+    fprintf(xmlout,    "%s    <!-- Defined Progression Order Values are: -->\n",s);
+    fprintf(xmlout,    "%s    <!-- 0 = LRCP; 1 = RLCP; 2 = RPCL; 3 = PCRL; 4 = CPRL -->\n",s);
+    fprintf(xmlout,    "%s    <!-- where L = \"layer\", R = \"resolution level\", C = \"component\", P = \"position\". -->\n",s);
+  }
+  fprintf(xmlout,      "%s    <NumberOfLayers>%d</NumberOfLayers>\n", s, tcp->numlayers); /* 2 bytes, SGcod (B) */
+  fprintf(xmlout,      "%s    <MultipleComponentTransformation>%d</MultipleComponentTransformation>\n", s, tcp->mct); /* 1 byte, SGcod (C).  More or less boolean */
+  if(notes)
+    fprintf(xmlout,    "%s    <!-- For MCT, 0 = none, 1 = transform first 3 components for efficiency, per Part I Annex G -->\n",s);
+  fprintf(xmlout,      "%s  </SGcod>\n",s);
+  /* This code will compile only if declaration of j2k_default_tcp is changed from static (to implicit extern) in j2k.c */
+  fprintf(xmlout,      "%s  <SPcod>\n",s);
+  /* Internal data structure tccp defines separate defaults for each component, but they all get the same values */
+  /* So we only have to report the first component's values here. */
+  /* Compare j2k_read_cox(...) */
+  fprintf(xmlout,      "%s    <NumberOfDecompositionLevels>%d</NumberOfDecompositionLevels>\n", s, tccp->numresolutions - 1);	/* 1 byte, SPcox (D) */
+  fprintf(xmlout,      "%s    <CodeblockWidth>%d</CodeblockWidth>\n", s, tccp->cblkw - 2);	/* 1 byte, SPcox (E) */
+  fprintf(xmlout,      "%s    <CodeblockHeight>%d</CodeblockHeight>\n", s, tccp->cblkh - 2);	/* 1 byte, SPcox (F) */
+  if(notes) {
+    fprintf(xmlout,    "%s    <!-- CBW and CBH are non-negative, and summed cannot exceed 8 -->\n",s);
+    fprintf(xmlout,    "%s    <!-- Codeblock dimension is 2^(value + 2) -->\n", s);
+  }
+  fprintf(xmlout,      "%s    <CodeblockStyle>0x%02x</CodeblockStyle>\n", s, tccp->cblksty);	/* 1 byte, SPcox (G) */
+  if(notes) {
+    fprintf(xmlout,    "%s    <!-- For CodeblockStyle, bits mean (with value 1=feature on, 0=off): -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 0: Selective arithmetic coding bypass. -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 1: Reset context probabilities on coding pass boundaries. -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 2: Termination on each coding pass. -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 3: Vertically causal context. -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 4: Predictable termination. -->\n",s);
+    fprintf(xmlout,    "%s    <!-- bit 5: Segmentation symbols are used. -->\n",s);
+  }
+  fprintf(xmlout,      "%s    <Transformation>%d</Transformation>\n", s, tccp->qmfbid);	/* 1 byte, SPcox (H) */
+  if(notes)
+    fprintf(xmlout,    "%s    <!-- For Transformation, 0=\"9-7 irreversible filter\", 1=\"5-3 reversible filter\" -->\n",s);
+  if (tccp->csty & J2K_CP_CSTY_PRT) {
+    fprintf(xmlout,    "%s    <PrecinctSize>\n",s); /* 1 byte, SPcox (I_i) */
+    if(notes)
+      fprintf(xmlout,  "%s    <!-- These are size exponents PPx and PPy. May be zero only for first level (aka N(L)LL subband)-->\n",s);
+    for (i = 0; i < tccp->numresolutions; i++) {	
+      fprintf(xmlout,  "%s      <PrecinctHeightAndWidth  ResolutionLevel=\"%d\">\n", s, i);
+	  if(raw)
+        fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->prch[i] << 4) | tccp->prcw[i]);	/* packed into 1 byte, SPcox (G) */
+	  if(derived) {
+        fprintf(xmlout,"%s        <WidthAsDecimal>%d</WidthAsDecimal>\n", s, tccp->prcw[i]);
+        fprintf(xmlout,"%s        <HeightAsDecimal>%d</HeightAsDecimal>\n", s, tccp->prch[i]);
+	  }
+      fprintf(xmlout,  "%s      </PrecinctHeightAndWidth>\n", s, i);
+    }
+    fprintf(xmlout,    "%s    </PrecinctSize>\n",s); /* 1 byte, SPcox (I_i) */
+  }
+  fprintf(xmlout,      "%s  </SPcod>\n",s);
+  fprintf(xmlout,      "%s</CodingStyleDefault>\n",s);
+}
+
+/* ------------- */
+
+void xml_out_frame_coc(FILE* xmlout, opj_tcp_t *tcp, int numcomps) /* Optional in main & tile-part headers */
+{
+/* Uses global j2k_default_tcp */
+  opj_tccp_t *tccp, *firstcomp_tccp;
+  int i, compno;
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+
+  firstcomp_tccp = &(tcp->tccps[0]);
+    /* Internal data structure tccp defines separate defaults for each component, set from main */
+	/* default, then selectively overwritten. */
+    /* Compare j2k_read_cox(...) */
+  /* We don't really know which was the default, and which were not */
+  /* Let's pretend that [0] is the default and all others are not */
+  if(notes) {
+    fprintf(xmlout,    "%s<!-- mj2_to_metadata implementation always reports component[0] as using default COD, -->\n", s);
+    if(tcp == j2k_default_tcp)
+      fprintf(xmlout,  "%s<!-- and any other component, with main-header style values different from [0], as COC. -->\n", s);
+    else
+      fprintf(xmlout,  "%s<!-- and any other component, with tile-part-header style values different from [0], as COC. -->\n", s);
+  }
+  for (compno = 1; compno < numcomps; compno++) /* spec says components are zero-based */
+  {
+    tccp = &tcp->tccps[compno];
+    if(same_component_style(firstcomp_tccp, tccp))
+		continue;
+
+/*  Alignments:          "      < < < < <   To help maintain xml pretty-printing */  
+    fprintf(xmlout,      "%s<CodingStyleComponent Marker=\"COC\">\n", s); /* Optional in main header, at most 1 per component */
+    if(notes)
+      fprintf(xmlout,    "%s  <!-- See Ccoc below for zero-based component number. -->\n", s);
+    /* Overrides the main COD for the specific component */
+    /* Not retained or of interest: Lcod */
+    fprintf(xmlout,      "%s  <Scoc>0x%02x</Scoc>\n", s, tccp->csty); /* 1 byte */
+	if(notes) {
+	  fprintf(xmlout,    "%s  <!-- Scoc defines entropy coder precincts: -->\n", s);
+      fprintf(xmlout,    "%s  <!--   0 = maximum, namely (PPx=15, PPy=15); 1 = precincts defined below. -->\n", s);
+	}
+    fprintf(xmlout,      "%s  <Ccoc>%d</Ccoc>\n", s, compno); /* 1 or 2 bytes */
+    /* Unfortunately compo isn't retained in j2k_read_coc:  compno = cio_read(j2k_img->numcomps <= 256 ? 1 : 2);	/* Ccoc */
+    /*if(j2k_img_numcomps <=256)
+	  component is 1 byte
+    else
+      compno is 2 byte */
+
+    /* This code will compile only if declaration of j2k_default_tcp is changed from static (to implicit extern) in j2k.c */
+    fprintf(xmlout,      "%s  <SPcoc>\n", s);
+    fprintf(xmlout,      "%s    <NumberOfDecompositionLevels>%d</NumberOfDecompositionLevels>\n", s, tccp->numresolutions - 1);	/* 1 byte, SPcox (D) */
+    fprintf(xmlout,      "%s    <CodeblockWidth>%d</CodeblockWidth>\n", s, tccp->cblkw - 2);	/* 1 byte, SPcox (E) */
+    fprintf(xmlout,      "%s    <CodeblockHeight>%d</CodeblockHeight>\n", s, tccp->cblkh - 2);	/* 1 byte, SPcox (F) */
+	if(notes) {
+      fprintf(xmlout,    "%s    <!-- CBW and CBH are non-negative, and summed cannot exceed 8 -->\n", s);
+      fprintf(xmlout,    "%s    <!-- Codeblock dimension is 2^(value + 2) -->\n", s);
+	}
+    fprintf(xmlout,      "%s    <CodeblockStyle>0x%02x</CodeblockStyle>\n", s, tccp->cblksty);	/* 1 byte, SPcox (G) */
+	if(notes) {
+      fprintf(xmlout,    "%s    <!-- For CodeblockStyle, bits mean (with value 1=feature on, 0=off): -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 0: Selective arithmetic coding bypass. -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 1: Reset context probabilities on coding pass boundaries. -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 2: Termination on each coding pass. -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 3: Vertically causal context. -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 4: Predictable termination. -->\n", s);
+      fprintf(xmlout,    "%s    <!-- bit 5: Segmentation symbols are used. -->\n", s);
+	}
+    fprintf(xmlout,      "%s    <Transformation>%d</Transformation>\n", s, tccp->qmfbid);	/* 1 byte, SPcox (H) */
+    if(notes)
+      fprintf(xmlout,    "%s    <!-- For Transformation, 0=\"9-7 irreversible filter\", 1=\"5-3 reversible filter\" -->\n", s);
+    if (tccp->csty & J2K_CP_CSTY_PRT) {
+      fprintf(xmlout,    "%s    <PrecinctSize>\n", s); /* 1 byte, SPcox (I_i) */
+      if(notes)
+        fprintf(xmlout,  "%s      <!-- These are size exponents PPx and PPy. May be zero only for first level (aka N(L)LL subband)-->\n", s);
+      for (i = 0; i < tccp->numresolutions-1; i++) { /* subtract 1 to get # of decomposition levels */	
+        fprintf(xmlout,  "%s      <PrecinctHeightAndWidth  ResolutionLevel=\"%d\">\n", s, i);
+		if(raw)
+          fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->prch[i] << 4) | tccp->prcw[i]);	/* packed into 1 byte, SPcox (G) */
+		if(derived) {
+          fprintf(xmlout,"%s        <WidthAsDecimal>%d</WidthAsDecimal>\n", s, tccp->prcw[i]);
+          fprintf(xmlout,"%s        <HeightAsDecimal>%d</HeightAsDecimal>\n", s, tccp->prch[i]);
+		}
+        fprintf(xmlout,  "%s      </PrecinctHeightAndWidth>\n", s, i);
+      }
+      fprintf(xmlout,    "%s    </PrecinctSize>\n", s); /* 1 byte, SPcox (I_i) */
+    }
+    fprintf(xmlout,      "%s  </SPcoc>\n", s);
+    fprintf(xmlout,      "%s</CodingStyleComponent>\n", s);
+  }
+}
+
+/* ------------- */
+
+BOOL same_component_style(opj_tccp_t *tccp1, opj_tccp_t *tccp2)
+{
+  int i;
+
+  if(tccp1->numresolutions != tccp2->numresolutions)
+	  return FALSE;
+  if(tccp1->cblkw != tccp2->cblkw)
+	  return FALSE;
+  if(tccp1->cblkh != tccp2->cblkh)
+	  return FALSE;
+  if(tccp1->cblksty != tccp2->cblksty)
+	  return FALSE;
+  if(tccp1->csty != tccp2->csty)
+	  return FALSE;
+  
+  if (tccp1->csty & J2K_CP_CSTY_PRT) {
+      for (i = 0; i < tccp1->numresolutions; i++) {	
+         if(tccp1->prcw[i] != tccp2->prcw[i] || tccp1->prch[i] != tccp2->prch[i])
+			 return FALSE;
+      }
+  }
+  return TRUE;
+}
+
+/* ------------- */
+
+void xml_out_frame_qcd(FILE* xmlout, opj_tcp_t *tcp)
+{
+  /* This code will compile only if declaration of j2k_default_tcp is changed from static (to implicit extern) in j2k.c */
+  opj_tccp_t *tccp;
+  int bandno, numbands;
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+
+  /* Compare j2k_read_qcx */
+  fprintf(xmlout,      "%s<QuantizationDefault Marker=\"QCD\">\n", s); /* Required in main header, single occurrence */
+  tccp = &(tcp->tccps[0]);
+  /* Not retained or of interest: Lqcd */
+  fprintf(xmlout,      "%s  <Sqcd>\n", s);		/* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "%s  <!-- Default quantization style for all components. -->\n", s);
+  if(raw)
+    fprintf(xmlout,    "%s    <AsHex>0x%02x</AsHex>\n", s, (tccp->numgbits) << 5 | tccp->qntsty);
+  if(derived)
+    fprintf(xmlout,    "%s    <QuantizationStyle>%d</QuantizationStyle>\n", s, tccp->qntsty);
+  if(notes) {
+    fprintf(xmlout,    "%s    <!-- Quantization style (in Sqcd's low 5 bits) may be: -->\n", s);
+    fprintf(xmlout,    "%s    <!--   0 = No quantization. SPqcd size = 8 bits-->\n", s);
+    fprintf(xmlout,    "%s    <!--   1 = Scalar derived (values signaled for N(L)LL subband only). Use Eq. E.5. SPqcd size = 16. -->\n", s);
+    fprintf(xmlout,    "%s    <!--   2 = Scalar expounded (values signaled for each subband). SPqcd size = 16. -->\n", s);
+  }
+  if(derived)
+    fprintf(xmlout,    "%s    <NumberOfGuardBits>%d</NumberOfGuardBits>\n", s,	tccp->numgbits);
+  if(notes)
+    fprintf(xmlout,    "%s    <!-- 0-7 guard bits allowed (stored in Sqcd's high 3 bits) -->\n", s);
+  fprintf(xmlout,      "%s  </Sqcd>\n", s);
+	  
+  /* Problem: numbands in some cases is calculated from len, which is not retained or available here at this time */
+  /* So we'll just dump all internal values */
+  /* We could calculate it, but I'm having trouble believing the length equations in the standard */
+  
+  fprintf(xmlout,      "%s  <SPqcd>\n", s);
+  switch(tccp->qntsty) {
+  case J2K_CCP_QNTSTY_NOQNT: /* no quantization */
+    /* This is what standard says, but I don't believe it: len = 4 + (3*decomp); */
+    numbands = J2K_MAXBANDS; /* should be: numbands = len - 1; */
+	/* Better: IMAGINE numbands = tccp->stepsize_numbands; */
+    /* Instead look for first zero exponent, quit there.  Adequate? */
+    fprintf(xmlout,    "%s    <ReversibleStepSizeValue>\n", s);
+	if(notes) {
+      fprintf(xmlout,  "%s    <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+	  fprintf(xmlout,  "%s    <!-- until an exponent with zero value is reached. -->\n", s);
+	  fprintf(xmlout,  "%s    <!-- Exponent epsilon(b) of reversible dynamic range. -->\n", s);
+	  fprintf(xmlout,  "%s    <!-- Hex value is as stored, in high-order 5 bits. -->\n", s);
+	}
+    for (bandno = 0; bandno < numbands; bandno++) {
+      if(tccp->stepsizes[bandno].expn == 0)
+        break; /* Remove when we have real numbands */
+      fprintf(xmlout,  "%s      <DynamicRangeExponent Subband=\"%d\">\n", s, bandno);
+	  if(raw)
+        fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, tccp->stepsizes[bandno].expn << 3);
+	  if(derived)
+        fprintf(xmlout,"%s        <AsDecimal>%d</AsDecimal>\n", s, tccp->stepsizes[bandno].expn);
+      fprintf(xmlout,  "%s      </DynamicRangeExponent>\n", s);
+    }
+    fprintf(xmlout,    "%s    </ReversibleStepSizeValue>\n", s);
+    break;
+  case J2K_CCP_QNTSTY_SIQNT:  /* scalar quantization derived */
+    /* This is what standard says.  Should I believe it:: len = 5;
+    /* numbands = 1; */
+    fprintf(xmlout,    "%s    <QuantizationStepSizeValues>\n", s);
+    if(notes)
+      fprintf(xmlout,  "%s    <!-- For irreversible transformation only.  See Part I Annex E Equation E.3 -->\n", s);
+    fprintf(xmlout,    "%s      <QuantizationValues Subband=\"0\">\n", s);
+    if(notes)
+      fprintf(xmlout,  "%s      <!-- For N(L)LL subband: >\n", s);
+	if(raw)
+      fprintf(xmlout,  "%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->stepsizes[0].expn << 11) | tccp->stepsizes[0].mant);
+	if(derived) {
+      fprintf(xmlout,  "%s        <Exponent>%d</Exponent>\n", s, tccp->stepsizes[0].expn);
+      fprintf(xmlout,  "%s        <Mantissa>%d</Mantissa>\n", s, tccp->stepsizes[0].mant);
+	}
+    fprintf(xmlout,    "%s      </QuantizationValues>\n", s);
+	if(notes) {
+      fprintf(xmlout,  "%s      <!-- Exponents for subbands beyond 0 are not from header, but calculated per Eq. E.5 -->\n", s);
+      fprintf(xmlout,  "%s      <!-- The mantissa for all subbands is the same, given by the value above. -->\n", s);
+      fprintf(xmlout,  "%s      <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+	  fprintf(xmlout,  "%s      <!-- until a subband with exponent of zero value is reached. -->\n", s);
+	}
+
+    for (bandno = 1; bandno < J2K_MAXBANDS; bandno++) {
+      if(tccp->stepsizes[bandno].expn == 0)
+        break;
+
+      fprintf(xmlout,  "%s      <CalculatedExponent Subband=\"%d\">%d</CalculatedExponent>\n", s, bandno, tccp->stepsizes[bandno].expn);
+    }
+
+    fprintf(xmlout,    "%s    </QuantizationStepSizeValues>\n", s);
+    break;
+
+  default: /* J2K_CCP_QNTSTY_SEQNT */ /* scalar quantization expounded */
+    /* This is what standard says, but should I believe it: len = 5 + 6*decomp; */
+    numbands = J2K_MAXBANDS; /* should be: (len - 1) / 2;*/
+	/* Better: IMAGINE numbands = tccp->stepsize_numbands; */
+    fprintf(xmlout,    "%s    <QuantizationStepSizeValues>\n", s);
+	if(notes) {
+      fprintf(xmlout,  "%s    <!-- For irreversible transformation only.  See Part I Annex E Equation E.3 -->\n", s);
+      fprintf(xmlout,  "%s    <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+      fprintf(xmlout,  "%s    <!-- until a subband with mantissa and exponent of zero values is reached. -->\n", s);
+    }
+    for (bandno = 0; bandno < numbands; bandno++) {
+      if(tccp->stepsizes[bandno].expn == 0 && tccp->stepsizes[bandno].mant == 0)
+        break; /* Remove when we have real numbands */
+
+      fprintf(xmlout,  "%s      <QuantizationValues Subband=\"%d\">\n", s, bandno);
+	  if(raw)
+        fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->stepsizes[bandno].expn << 11) | tccp->stepsizes[bandno].mant);
+	  if(derived) {
+        fprintf(xmlout,"%s        <Exponent>%d</Exponent>\n", s, tccp->stepsizes[bandno].expn);
+        fprintf(xmlout,"%s        <Mantissa>%d</Mantissa>\n", s, tccp->stepsizes[bandno].mant);
+	  }
+      fprintf(xmlout,  "%s      </QuantizationValues>\n", s);
+    }
+    fprintf(xmlout,    "%s    </QuantizationStepSizeValues>\n", s);
+    break;
+  } /* switch */
+  fprintf(xmlout,      "%s  </SPqcd>\n", s);
+  fprintf(xmlout,      "%s</QuantizationDefault>\n", s);
+
+/*  Alignments:        "    < < < < <   To help maintain xml pretty-printing */  
+}
+
+/* ------------- */
+
+void xml_out_frame_qcc(FILE* xmlout, opj_tcp_t *tcp, int numcomps)
+{
+/* Uses global j2k_default_tcp */
+  /* This code will compile only if declaration of j2k_default_tcp is changed from static (to implicit extern) in j2k.c */
+  opj_tccp_t *tccp, *firstcomp_tccp;
+  int bandno, numbands;
+  int compno;
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+
+  firstcomp_tccp = &(tcp->tccps[0]);
+    /* Internal data structure tccp defines separate defaults for each component, set from main */
+	/* default, then selectively overwritten. */
+    /* Compare j2k_read_qcx(...) */
+  /* We don't really know which was the default, and which were not */
+  /* Let's pretend that [0] is the default and all others are not */
+  if(notes) {
+    fprintf(xmlout,      "%s<!-- mj2_to_metadata implementation always reports component[0] as using default QCD, -->\n", s);
+    if(tcp == j2k_default_tcp)
+      fprintf(xmlout,    "%s<!-- and any other component, with main-header quantization values different from [0], as QCC. -->\n", s);
+    else
+      fprintf(xmlout,    "%s<!-- and any other component, with tile-part-header quantization values different from [0], as QCC. -->\n", s);
+  }
+  for (compno = 1; compno < numcomps; compno++) /* spec says components are zero-based */
+  {
+    tccp = &(tcp->tccps[compno]);
+    if(same_component_quantization(firstcomp_tccp, tccp))
+		continue;
+
+    /* Compare j2k_read_qcx */
+    fprintf(xmlout,      "%s<QuantizationComponent Marker=\"QCC\" Component=\"%d\">\n", s, compno); /* Required in main header, single occurrence */
+    tccp = &j2k_default_tcp->tccps[0];
+    /* Not retained or perhaps of interest: Lqcd   It maybe can be calculated.  */
+    fprintf(xmlout,      "%s  <Sqcc>\n", s);		/* 1 byte */
+    if(notes)
+      fprintf(xmlout,    "%s  <!-- Quantization style for this component. -->\n", s);
+	if(raw)
+      fprintf(xmlout,    "%s    <AsHex>0x%02x</AsHex>\n", s, (tccp->numgbits) << 5 | tccp->qntsty);
+	if(derived)
+      fprintf(xmlout,    "%s    <QuantizationStyle>%d</QuantizationStyle>\n", s, tccp->qntsty);
+	if(notes) {
+      fprintf(xmlout,    "%s    <!-- Quantization style (in Sqcc's low 5 bits) may be: -->\n", s);
+      fprintf(xmlout,    "%s    <!--   0 = No quantization. SPqcc size = 8 bits-->\n", s);
+      fprintf(xmlout,    "%s    <!--   1 = Scalar derived (values signaled for N(L)LL subband only). Use Eq. E.5. SPqcc size = 16. -->\n", s);
+      fprintf(xmlout,    "%s    <!--   2 = Scalar expounded (values signaled for each subband). SPqcc size = 16. -->\n", s);
+	}
+	if(derived)
+      fprintf(xmlout,    "%s    <NumberOfGuardBits>%d</NumberOfGuardBits>\n", s,	tccp->numgbits);
+    if(notes)
+      fprintf(xmlout,    "%s    <!-- 0-7 guard bits allowed (stored in Sqcc's high 3 bits) -->\n", s);
+    fprintf(xmlout,      "%s  </Sqcc>\n", s);
+	  
+    /* Problem: numbands in some cases is calculated from len, which is not retained or available here at this time */
+    /* So we'll just dump all internal values */
+    fprintf(xmlout,      "%s  <SPqcc>\n", s);
+    switch(tccp->qntsty) {
+    case J2K_CCP_QNTSTY_NOQNT:
+      numbands = J2K_MAXBANDS; /* should be: numbands = len - 1; */
+	  /* Better: IMAGINE numbands = tccp->stepsize_numbands; */
+
+      /* Instead look for first zero exponent, quit there.  Adequate? */
+      fprintf(xmlout,    "%s    <ReversibleStepSizeValue>\n", s);
+	  if(notes) {
+        fprintf(xmlout,  "%s    <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+	    fprintf(xmlout,  "%s    <!-- until an exponent with zero value is reached. -->\n", s);
+	    fprintf(xmlout,  "%s    <!-- Exponent epsilon(b) of reversible dynamic range. -->\n", s);
+	    fprintf(xmlout,  "%s    <!-- Hex value is as stored, in high-order 5 bits. -->\n", s);
+	  }
+      for (bandno = 0; bandno < numbands; bandno++) {
+        if(tccp->stepsizes[bandno].expn == 0)
+          break; /* Remove this once we have real numbands */
+        fprintf(xmlout,  "%s      <Exponent Subband=\"%d\">\n", s, bandno);
+		if(raw)
+          fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, tccp->stepsizes[bandno].expn << 3);
+		if(derived)
+          fprintf(xmlout,"%s        <AsDecimal>%d</AsDecimal>\n", s, tccp->stepsizes[bandno].expn);
+        fprintf(xmlout,  "%s      </Exponent>\n", s);
+      }
+      fprintf(xmlout,    "%s    </ReversibleStepSizeValue>\n", s);
+      break;
+    case J2K_CCP_QNTSTY_SIQNT:
+      /* numbands = 1; */
+      fprintf(xmlout,    "%s    <QuantizationStepSizeValues>\n", s);
+      if(notes)
+        fprintf(xmlout,  "%s    <!-- For irreversible transformation only.  See Part I Annex E Equation E.3 -->\n", s);
+      fprintf(xmlout,    "%s      <QuantizationValuesForSubband0>\n", s);
+      if(notes)
+        fprintf(xmlout,  "%s      <!-- For N(L)LL subband: >\n", s);
+	  if(raw)
+        fprintf(xmlout,  "%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->stepsizes[0].expn << 11) | tccp->stepsizes[0].mant);
+	  if(derived) {
+        fprintf(xmlout,  "%s        <Exponent>%d</Exponent>\n", s, tccp->stepsizes[0].expn);
+        fprintf(xmlout,  "%s        <Mantissa>%d</Mantissa>\n", s, tccp->stepsizes[0].mant);
+	  }
+      fprintf(xmlout,    "%s      </QuantizationValuesForSubband0>\n", s);
+	  if(notes) {
+        fprintf(xmlout,  "%s      <!-- Exponents for subbands beyond 0 are not from header, but calculated per Eq. E.5 -->\n", s);
+        fprintf(xmlout,  "%s      <!-- The mantissa for all subbands is the same, given by the value above. -->\n", s);
+        fprintf(xmlout,  "%s      <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+	    fprintf(xmlout,  "%s      <!-- until a subband with exponent of zero value is reached. -->\n", s);
+        }
+
+      for (bandno = 1; bandno < J2K_MAXBANDS; bandno++) {
+        if(tccp->stepsizes[bandno].expn == 0)
+          break;
+
+        fprintf(xmlout,  "%s      <CalculatedExponent Subband=\"%d\">%d</CalculatedExponent>\n", s, bandno, tccp->stepsizes[bandno].expn);
+      }
+      fprintf(xmlout,    "%s    </QuantizationStepSizeValues>\n", s);
+      break;
+
+    default: /* J2K_CCP_QNTSTY_SEQNT */
+      numbands = J2K_MAXBANDS; /* should be: (len - 1) / 2;*/
+	  /* Better: IMAGINE numbands = tccp->stepsize_numbands; */
+      fprintf(xmlout,    "%s    <QuantizationStepSizeValues>\n", s);
+      if(notes) {
+        fprintf(xmlout,  "%s    <!-- For irreversible transformation only.  See Part I Annex E Equation E.3 -->\n", s);
+        fprintf(xmlout,  "%s    <!-- Current mj2_to_metadata implementation dumps entire internal table, -->\n", s);
+	    fprintf(xmlout,  "%s    <!-- until a subband with mantissa and exponent of zero values is reached. -->\n", s);
+	  }
+      for (bandno = 0; bandno < numbands; bandno++) {
+        if(tccp->stepsizes[bandno].expn == 0 && tccp->stepsizes[bandno].mant == 0)
+			break; /* Remove this once we have real numbands count */
+        fprintf(xmlout,  "%s      <QuantizationValues Subband=\"%d\">\n", s, bandno);
+		if(raw)
+          fprintf(xmlout,"%s        <AsHex>0x%02x</AsHex>\n", s, (tccp->stepsizes[bandno].expn << 11) | tccp->stepsizes[bandno].mant);
+		if(derived) {
+          fprintf(xmlout,"%s        <Exponent>%d</Exponent>\n", s, tccp->stepsizes[bandno].expn);
+          fprintf(xmlout,"%s        <Mantissa>%d</Mantissa>\n", s, tccp->stepsizes[bandno].mant);
+		}
+        fprintf(xmlout,  "%s      </QuantizationValues>\n", s);
+      }
+      fprintf(xmlout,    "%s    </QuantizationStepSizeValues>\n", s);
+      break;
+    } /* switch */
+    fprintf(xmlout,      "%s  </SPqcc>\n", s);
+    fprintf(xmlout,      "%s</QuantizationComponent>\n", s);
+  }
+/*  Alignments:          "    < < < < <   To help maintain xml pretty-printing */  
+}
+
+/* ------------- */
+
+BOOL same_component_quantization(opj_tccp_t *tccp1, opj_tccp_t *tccp2)
+{
+  int bandno, numbands;
+
+  if(tccp1->qntsty != tccp2->qntsty)
+	  return FALSE;
+  if(tccp1->numgbits != tccp2->numgbits)
+	  return FALSE;
+
+  switch(tccp1->qntsty) {
+    case J2K_CCP_QNTSTY_NOQNT:
+      numbands = J2K_MAXBANDS; /* should be: numbands = len - 1; */
+      /* Instead look for first zero exponent, quit there.  Adequate? */
+      for (bandno = 0; bandno < numbands; bandno++) {
+        if(tccp1->stepsizes[bandno].expn == 0)
+          break;
+        if(tccp1->stepsizes[bandno].expn != tccp2->stepsizes[bandno].expn)
+         return FALSE;
+      }
+      break;
+    case J2K_CCP_QNTSTY_SIQNT:
+      /* numbands = 1; */
+      if(tccp1->stepsizes[0].expn != tccp2->stepsizes[0].expn || tccp1->stepsizes[0].mant != tccp2->stepsizes[0].mant)
+        return FALSE;
+	  /* Don't need to check remainder, since they are calculated from [0] */
+      break;
+
+    default: /* J2K_CCP_QNTSTY_SEQNT */
+      numbands = J2K_MAXBANDS; /* should be: (len - 1) / 2;*/
+	  /* This comparison may cause us problems with trailing junk values. */
+      for (bandno = 0; bandno < numbands; bandno++) {
+        if(tccp1->stepsizes[bandno].expn != tccp2->stepsizes[bandno].expn || tccp1->stepsizes[bandno].mant != tccp2->stepsizes[bandno].mant);
+          return FALSE;
+      }
+      break;
+    } /* switch */
+  return TRUE;
+}
+
+/* ------------- */
+
+void xml_out_frame_rgn(FILE* xmlout, opj_tcp_t *tcp, int numcomps)
+{
+  int compno, SPrgn;
+  /* MJ2 files can have regions of interest if hybridized with JPX Part II */
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+
+  for(compno = 0; compno < numcomps; compno++) {
+    SPrgn = tcp->tccps[compno].roishift;	/* 1 byte; SPrgn */
+    if(SPrgn == 0)
+		continue; /* Yet another kludge */
+
+    fprintf(xmlout,    "%s<RegionOfInterest Marker=\"RGN\">\n", s); /* Optional in main header, at most 1 per component */
+    if(notes)
+      fprintf(xmlout,  "%s<!-- See Crgn below for zero-based component number. -->\n", s);
+    /* Not retained or of interest: Lrgd */
+    fprintf(xmlout,    "%s  <Srgn>0</Srgn>\n", s); /* 1 byte */
+    if(notes)
+	  fprintf(xmlout,  "%s  <!-- Srgn is ROI style.  Only style=0 defined: Implicit ROI (max. shift) -->\n", s);
+    fprintf(xmlout,    "%s  <Crgn>%d</Crgn>\n", s, compno); /* 1 or 2 bytes */
+    fprintf(xmlout,    "%s  <SPrgn>%d</SPrgn>\n", s, SPrgn); /* 1 byte */
+    if(notes)
+      fprintf(xmlout,  "%s  <!-- SPrgn is implicit ROI shift, i.e., binary shifting of ROI coefficients above background. -->\n", s);
+    fprintf(xmlout,    "</RegionOfInterest\n", s); /* Optional in main header, at most 1 per component */
+  }
+}
+
+/* ------------- */
+
+void xml_out_frame_poc(FILE* xmlout, opj_tcp_t *tcp) { /* Progression Order Change */
+  /* Compare j2k_read_poc() */
+  int i;
+  opj_poc_t *poc;
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+  
+  if(tcp->POC != 1)
+	  return; /* Not present */
+
+  fprintf(xmlout,    "%s<ProgressionOrderChange Marker=\"POC\">\n", s); /* Optional in main header, at most 1 per component */
+  /* j2k_read_poc seems to allow accumulation of default pocs from multiple POC segments, but does
+  the spec really allow that? */
+  /* 2 bytes, not retained; Lpoc */
+  /* I probably didn't get this dump precisely right. */
+  for (i = 0; i < tcp->numpocs; i++) {
+    poc = &tcp->pocs[i];
+    fprintf(xmlout,  "%s  <Progression Num=\"%d\">\n", s, i+1);
+    fprintf(xmlout,  "%S    <RSpoc>%d</RSpoc>\n", s, poc->resno0);	/* 1 byte, RSpoc_i */
+    if(notes)
+	  fprintf(xmlout,"%s    <!-- Resolution level index (inclusive) for progression start. Range: 0 to 33 -->\n", s);
+    fprintf(xmlout,  "%s    <CSpoc>%d</CSpoc>\n", s, poc->compno0);/* j2k_img->numcomps <= 256 ? 1 byte : 2 bytes; CSpoc_i */
+    if(notes)
+      fprintf(xmlout,"%s    <!-- Component index (inclusive) for progression start. -->\n", s);
+    fprintf(xmlout,  "%s    <LYEpoc>%d</LYEpoc>\n", s, poc->layno1); /* int_min(cio_read(2), tcp->numlayers);	/* 2 bytes; LYEpoc_i */
+    if(notes)
+      fprintf(xmlout,"%s    <!-- Layer index (exclusive) for progression end. -->\n", s);
+    fprintf(xmlout,  "%s    <REpoc>%d</REpoc>\n", s, poc->resno1); /*int_min(cio_read(1), tccp->numresolutions);	/* REpoc_i */
+    if(notes)
+      fprintf(xmlout,"%s    <!-- Resolution level index (exclusive) for progression end. Range: RSpoc to 33 -->\n", s);
+    fprintf(xmlout,  "%s    <CEpoc>%d</CEpoc>\n", s, poc->compno1); /* int_min(cio_read(j2k_img->numcomps <= 256 ? 1 : 2), j2k_img->numcomps);	/* CEpoc_i */
+    if(notes)
+	  fprintf(xmlout,"%s    <!-- Component index (exclusive) for progression end.  Minimum: CSpoc -->\n", s);
+    fprintf(xmlout,  "%s    <Ppoc>%d</Ppoc>\n", s, poc->prg); /* 1 byte Ppoc_i */
+	if(notes) {
+      fprintf(xmlout,"%s    <!-- Defined Progression Order Values are: -->\n", s);
+      fprintf(xmlout,"%s    <!-- 0 = LRCP; 1 = RLCP; 2 = RPCL; 3 = PCRL; 4 = CPRL -->\n", s);
+      fprintf(xmlout,"%s    <!-- where L = \"layer\", R = \"resolution level\", C = \"component\", P = \"position\". -->\n", s);
+	}
+    fprintf(xmlout,  "%s  </Progression>\n", s);
+  }
+  fprintf(xmlout,    "%s</ProgressionOrderChange\n", s);
+}
+
+/* ------------- */
+
+#ifdef SUPPRESS_FOR_NOW
+/* Suppress PPM and PPT since we're not showing data from the third option, namely within the codestream, and
+that's evidently what frames_to_mj2 uses.  And a hex dump isn't so useful anyway */
+
+void xml_out_frame_ppm(FILE *xmlout, opj_cp_t *cp) { /* For main header, not tile-part (which uses PPT instead). */
+/* Either the PPM or PPT is required if the packet headers are not distributed in the bit stream */
+/* Use of PPM and PPT are mutually exclusive. */
+/* Compare j2k_read_ppm() */
+  int j;
+  
+  if(cp->ppm != 1)
+	  return; /* Not present */
+/* Main header uses indent of 10 spaces */
+  fprintf(xmlout,    "          <PackedPacketHeadersMainHeader Marker=\"PPM\">\n"); /* Optional in main header, but if not, must be in PPT or codestream */
+  /* 2 bytes Lppm not saved */
+  if(notes) {
+    fprintf(xmlout,  "          <!-- If there are multiple PPM marker segments in the main header, -->\n");
+    fprintf(xmlout,  "          <!-- this mj2_to_metadata implementation will report them as a single consolidated PPM header. -->\n");
+    fprintf(xmlout,  "          <!-- The implementation can't currently segregate by tile-part. -->\n");
+    fprintf(xmlout,  "          <!-- TO DO? further map the packet headers to xml. -->\n");
+  }
+ 
+  /* 1 byte, not retained ; Zppm is sequence # of this PPM header */
+  /* 4 bytes, possibly overwritten multiple times in j2k_cp->ppm_previous: Nppm */
+  /* Use j symbol for index instead of i, to make comparable with j2k_read_ppm */
+  /* Not real clear whether to use ppm->store or ppm_len as upper bound */
+  fprintf(xmlout,    "            <PackedData>\n");
+  xml_out_dump_hex(xmlout, cp->ppm_data, cp->ppm_len);
+  /* Dump packet headers 1 byte at a time: lppm[i][j] */
+  fprintf(xmlout,    "            </PackedData>\n");
+  fprintf(xmlout,    "          </PackedPacketHeadersMainHeader>\n"); /* Optional in main header, but if not, must be in PPT or codestream */
+}
+
+/* ------------- */
+
+void xml_out_frame_ppt(FILE *xmlout, opj_tcp_t *tcp) { /* For tile-part header, not main (which uses PPM instead). */
+/* Either the PPM or PPT is required if the packet headers are not distributed in the bit stream */
+/* Use of PPM and PPT are mutually exclusive. */
+/* Compare j2k_read_ppt() */
+  int j;
+  
+  if(tcp->ppt != 1)
+	  return; /* Not present */
+
+  /* Tile-part indents are 12 spaces */
+  fprintf(xmlout,    "            <PackedPacketHeadersTilePartHeader Marker=\"PPT\">\n"); /* Optional in main header, but if not, must be in PPT or codestream */
+  /* 2 bytes Lppm not saved */
+  if(notes) {
+    fprintf(xmlout,  "            <!-- If there are multiple PPT marker segments in the tile-part header, -->\n");
+    fprintf(xmlout,  "            <!-- this mj2_to_metadata implementation will report them as a single consolidated PPT header. -->\n");
+    fprintf(xmlout,  "            <!-- The implementation can't currently segregate by tile-part. -->\n");
+    fprintf(xmlout,  "            <!-- TO DO? further map the packet headers to xml. -->\n");
+  }
+ 
+  /* 1 byte, not retained ; Zppt is sequence # of this PPT header */
+  /* 4 bytes, possibly overwritten multiple times in j2k_cp->ppt_previous: Nppt */
+  /* Use j symbol for index instead of i, to make comparable with j2k_read_ppt */
+  /* Not real clear whether to use ppt->store or ppt_len as upper bound */
+  fprintf(xmlout,    "              <PackedData>\n");
+  xml_out_dump_hex(xmlout, tcp->ppt_data, tcp->ppt_len);
+  /* Dump packet headers 1 byte at a time: lppt[i][j] */
+  fprintf(xmlout,    "              </PackedData>\n");
+  fprintf(xmlout,    "            </PackedPacketHeadersTileHeader>\n"); /* Optional in tile-part header, but if not, must be in PPM or codestream */
+}
+#endif SUPPRESS_FOR_NOW
+
+/* ------------- */
+
+void xml_out_frame_tlm(FILE* xmlout) { /* opt, main header only.  May be multiple. */
+/* Compare j2k_read_tlm()... which doesn't retain anything! */
+/* Plan:  Since this is only called from main header, not tilepart, use global j2k_default_tcp rather than parameter */
+/* Main header indents are 10 spaces */
+}
+
+/* ------------- */
+
+void xml_out_frame_plm(FILE* xmlout) { /* opt, main header only; can be used in conjunction with tile-part's PLT */
+/* NO-OP.  PLM NOT SAVED IN DATA STRUCTURE */
+	/* Compare j2k_read_plm()... which doesn't retain anything! */
+/* Plan:  Since this is only called from main header, not tilepart, use global j2k_default_tcp rather than parameter */
+/* Main header indents are 10 spaces */
+}
+
+/* ------------- */
+
+void xml_out_frame_plt(FILE* xmlout, opj_tcp_t *tcp) { /* opt, tile-part headers only; can be used in conjunction with main header's PLM */
+/* NO-OP.  PLT NOT SAVED IN DATA STRUCTURE */
+	/* Compare j2k_read_plt()... which doesn't retain anything! */
+/* Tile-part header indents are 12 spaces */
+}
+
+/* ------------- */
+
+void xml_out_frame_crg(FILE* xmlout) { /* NO-OP.  CRG NOT SAVED IN DATA STRUCTURE */ /* opt, main header only; */
+/* Compare j2k_read_crg()... which doesn't retain anything! */
+/* Plan:  Since this is only called from main header, not tilepart, use global j2k_default_tcp rather than parameter */
+#ifdef NOTYET
+  THIS PSEUDOCODE IMAGINES THESE EXIST: j2k_default_tcp->crg, j2k_default_tcp->crg_i, j2k_default_tcp->crg_xcrg*, j2k_default_tcp->crg_ycrg* 
+  (POSSIBLY DON'T NEED crg_i, CAN GET NUMBER OR COMPONENTS FROM ELSEWHERE)
+  if(j2k_default_tcp->crg != 1 || j2k_default_tcp->crg_i == 0)
+	  return; /* Not present */
+
+/* Main header indents are 10 spaces */
+  fprintf(xmlout,    "          <ComponentRegistration Marker=\"RG\" Count=\"%d\">\n", j2k_default_tcp->crg_i);
+  if(notes) {
+    fprintf(xmlout,  "          <!-- Fine tuning of registration of components with respect to each other, -->\n");
+    fprintf(xmlout,  "          <!-- not required but potentially helpful for decoder. -->\n");
+    fprintf(xmlout,  "          <!-- These supplementary fractional offsets are in units of 1/65536 of the horizontal -->\n");
+    fprintf(xmlout,  "          <!-- or vertical separation (e.g., XRsiz[i] or YRsiz[i] for component i). -->\n");
+  }
+  /* This isn't the most compact form of table, but is OK when number of components is small, as is likely. */
+  for (i = 0; i < j2k_default_tcp->crg_i; i++) {
+    fprintf(xmlout,  "            <Component Num=\"%d\">\n", i+1);
+    fprintf(xmlout,  "              <Xcrg>\n");
+	if(raw)
+      fprintf(xmlout,"                <AsNumerator>%d</AsNumerator>\n", j2k_default_tcp->crg_xcrg[i]);
+	if(derived) {
+	  /* Calculate n * 100%/65536; 4 digits after decimal point is sufficiently accurate */
+      fprintf(xmlout,"                <AsPercentage>%.4f</AsPercentage>\n", ((double)j2k_default_tcp->crg_xcrg[i])/655.36);
+	  /* We could do another calculation that include XRsiz[i]; maybe later. */
+	}
+    fprintf(xmlout,  "              </Xcrg>\n");
+    fprintf(xmlout,  "              <Ycrg>\n");
+	if(raw)
+      fprintf(xmlout,"                <AsNumerator>%d</AsNumerator>\n", j2k_default_tcp->crg_ycrg[i]);
+	if(derived) {
+      fprintf(xmlout,"                <AsPercentage>%f</AsPercentage>\n", ((double)j2k_default_tcp->crg_ycrg[i])/655.36);
+	}
+    fprintf(xmlout,  "              </Ycrg>\n");
+    fprintf(xmlout,  "            </Component>\n");
+  }
+
+  fprintf(xmlout,    "          </ComponentRegistration>\n");
+
+#endif
+}
+
+/* ------------- */
+
+/* Regrettably from a metadata point of view, j2k_read_com() skips over any comments in main header or tile-part-header */
+void xml_out_frame_com(FILE* xmlout, opj_tcp_t *tcp) { /* NO-OP.  COM NOT SAVED IN DATA STRUCTURE */ /* opt in main or tile-part headers; */
+/* Compare j2k_read_com()... which doesn't retain anything! */
+#ifdef NOTYET
+  char spaces[13] = "            "; /* 12 spaces if tilepart*/
+  char* s = spaces;
+  if(tcp == &j2k_default_tcp) {
+    s++;s++; /* shorten s to 10 spaces if main */
+  }
+  THIS PSEUDOCODE IMAGINES THESE EXIST: tcp->com, tcp->com_len, tcp->com_data array 
+  if(tcp->com != 1)
+	  return; /* Not present */
+
+  fprintf(xmlout,    "%s<Comment Marker=\"COM\">\n", s); /* Optional in main or tile-part header */
+  xml_out_dump_hex_and_ascii(tcp->com_data, tcp->com_len, s);
+  fprintf(xmlout,    "%s</Comment>\n", s);
+#endif
+}
+
+void xml_out_dump_hex(FILE* xmlout, char *data, int data_len, char* s) {
+  /* s is a string of spaces for indent */
+  int i;
+  
+  /* This is called when raw is true, or there is no appropriate derived form */
+  fprintf(xmlout,    "%s<AsHex>\n", s);
+  fprintf(xmlout,    "%s  ", s); /* Inadequate for pretty printing */
+  for (i = 0; i < data_len; i++) {	/* Dump packet headers */
+    fprintf(xmlout,  "%02x", data[i]);
+  }
+  fprintf(xmlout,    "%s</AsHex>\n", s);
+}
+
+/* Define this as an even number: */
+#define BYTES_PER_DUMP_LINE 40
+/* Current total width for Hex and ASCII is : 11 spaces lead + (3 * BPDL) + 2 spaces + BPDL */
+void xml_out_dump_hex_and_ascii(FILE* xmlout, char *data, int data_len, char* s) {
+  /* s is a string of spaces for indent */
+  int i,j;
+  
+  if(raw)
+    xml_out_dump_hex(xmlout, data, data_len, s);
+
+  if(derived) {
+    fprintf(xmlout,  "%s<AsHexAndASCII>\n", s);
+	for (i = 0; i < data_len; ) {
+      fprintf(xmlout,"%s ", s); /* Additional leading space added in loop */
+	  /* First column: hex */
+      for (j = 0; j < BYTES_PER_DUMP_LINE; j++)	/* Dump bytes */
+        fprintf(xmlout," %02x", data[i+j]);
+      /* Space between columns... */ fprintf(xmlout,  "  ");
+	  /* Second column: ASCII */
+	  for (j = 0; j < BYTES_PER_DUMP_LINE; j++, i++) {
+	    if(isprint((int)data[i]) && i < data_len)
+          fprintf(xmlout,"%c", data[i]);
+	    else
+	      fprintf(xmlout," ");
+      }
+      /* If we also wanted to output UCS-2 Unicode as a third column, then entire document
+      must use fwprintf.  Forget about it for now.  As it stands, if data is UCS-2 format but still
+      the ASCII set, then we'll be able to read every other byte as ASCII in column 2.  If
+      data is UTF-8 format but still ASCII, then we'll be able to read every byte as ASCII
+      in column 2. */
+    }
+    fprintf(xmlout,  "%s</AsHexAndASCII>\n", s);
+  }
+}
+
+
+/* ------------- */
+
+void xml_out_frame_jp2h(FILE* xmlout, opj_jp2_t *jp2_struct) {  /* JP2 Header */
+/* Compare jp2_read_jp2h(opj_jp2_t * jp2_struct) */
+  int i;
+
+  fprintf(xmlout,      "              <JP2Header BoxType=\"jp2h\">\n");
+
+/* Compare jp2_read_ihdr(jp2_struct)) */
+  fprintf(xmlout,      "                <ImageHeader BoxType=\"ihdr\">\n");
+  fprintf(xmlout,      "                  <HEIGHT>%d</HEIGHT>\n", jp2_struct->h); /* 4 bytes */
+  fprintf(xmlout,      "                  <WIDTH>%d</WIDTH>\n", jp2_struct->w); /* 4 bytes */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- HEIGHT here, if 2 fields per image, is of total deinterlaced height. -->\n");
+  fprintf(xmlout,      "                  <NC>%d</NC>\n", jp2_struct->numcomps); /* 2 bytes */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- NC is number of components -->\n"); /* 2 bytes */
+  fprintf(xmlout,      "                  <BPC>\n"); /* 1 byte */
+  if(jp2_struct->bpc == 255) {
+    fprintf(xmlout,    "                    <AsHex>0x%02x</AsHex>\n", jp2_struct->bpc); /* 1 byte */
+    if(notes)
+      fprintf(xmlout,  "                    <!-- BPC = 0xff means bits per pixel varies with component; see table below. -->\n");
+  } else { /* Not 0xff */
+    if(raw) {
+      fprintf(xmlout,  "                    <AsHex>0x%02x</AsHex>\n", jp2_struct->bpc); /* 1 byte */
+      if(notes)
+        fprintf(xmlout,"                    <!-- BPC = 0xff means bits per pixel varies with component; see table below. -->\n");
+	}
+    if(derived) {
+      fprintf(xmlout,  "                    <BitsPerPixel>%d</BitsPerPixel>\n", jp2_struct->bpc & 0x7f);
+      fprintf(xmlout,  "                    <Signed>%d</Signed>\n", jp2_struct->bpc >> 7);
+	}
+  }
+  fprintf(xmlout,      "                  </BPC>\n");
+  fprintf(xmlout,      "                  <C>%d</C>\n", jp2_struct->C); /* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- C is compression type.  Only \"7\" is allowed to date. -->\n"); /* 2 bytes */
+  fprintf(xmlout,      "                  <UnkC>%d</UnkC>\n", jp2_struct->UnkC); /* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- Colourspace Unknown. 1 = unknown, 0 = known (e.g., colourspace spec is accurate) -->\n"); /* 1 byte */
+  fprintf(xmlout,      "                  <IPR>%d</IPR>\n", jp2_struct->IPR); /* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- IPR is 1 if frame contains an Intellectual Property box; 0 otherwise. -->\n"); /* 2 bytes */
+  fprintf(xmlout,      "                </ImageHeader>\n");
+
+  if (jp2_struct->bpc == 255)
+  {
+    fprintf(xmlout,    "                <BitsPerComponent BoxType=\"bpcc\">\n");
+    if(notes)
+      fprintf(xmlout,  "                <!-- Pixel depth (range 1 to 38) is low 7 bits of hex value + 1 -->\n");
+	/* Bits per pixel varies with components */
+    /* Compare jp2_read_bpcc(jp2_struct) */
+	for (i = 0; i < (int)jp2_struct->numcomps; i++) {
+	  if(raw)
+        fprintf(xmlout,"                  <AsHex>0x%02x</AsHex>\n", jp2_struct->comps[i].bpcc); /* 1 byte */
+	  if(derived) {
+        fprintf(xmlout,"                  <BitsPerPixel>%d</BitsPerPixel>\n", (jp2_struct->comps[i].bpcc & 0x7f)+1);
+        fprintf(xmlout,"                  <Signed>%d</Signed>\n", jp2_struct->comps[i].bpcc >> 7);
+	  }
+	}
+    fprintf(xmlout,    "                </BitsPerComponent>\n");
+  }
+
+  /* Compare jp2_read_colr(jp2_struct) */
+  fprintf(xmlout,      "                <ColourSpecification BoxType=\"colr\">\n");
+  fprintf(xmlout,      "                  <METH>%d</METH>\n", jp2_struct->meth); /* 1 byte */
+  if(notes) {
+    fprintf(xmlout,    "                  <!-- Valid values of specification method so far: -->\n");
+    fprintf(xmlout,    "                  <!--   1 = Enumerated colourspace, in EnumCS field -->\n");
+    fprintf(xmlout,    "                  <!--   2 = Restricted ICC Profile, in PROFILE field -->\n");
+  }
+  fprintf(xmlout,      "                  <PREC>%d</PREC>\n", jp2_struct->precedence); /* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- 0 is only valid value of precedence so far. -->\n");
+  fprintf(xmlout,      "                  <APPROX>%d</APPROX>\n", jp2_struct->approx); /* 1 byte */
+  if(notes)
+    fprintf(xmlout,    "                  <!-- 0 is only valid value of colourspace approximation so far. -->\n");
+
+  if (jp2_struct->meth == 1) {
+    fprintf(xmlout,    "                  <EnumCS>%d</EnumCS>\n", jp2_struct->enumcs); /* 4 bytes */
+	if(notes) {
+	  fprintf(xmlout,  "                  <!-- Valid values of enumerated MJ2 colourspace so far: -->\n");
+	  fprintf(xmlout,  "                  <!--   16: sRGB as defined by IEC 61966-2-1. -->\n");
+	  fprintf(xmlout,  "                  <!--   17: greyscale (related to sRGB). -->\n");
+	  fprintf(xmlout,  "                  <!--   18: sRGB YCC (from JPEG 2000 Part II). -->\n");
+	  fprintf(xmlout,  "                  <!-- (Additional JPX values are defined in Part II). -->\n");
+	}
+  }
+  else
+    if(notes)
+      fprintf(xmlout,  "                  <!-- PROFILE is not handled by current OpenJPEG implementation. -->\n");
+    /* only 1 byte is read and nothing stored */
+  fprintf(xmlout,      "                </ColourSpecification>\n");
+
+  /* TO DO?  No OpenJPEG support.
+  Palette 'pclr'
+  ComponentMapping 'cmap'
+  ChannelDefinition 'cdef'
+  Resolution 'res'
+  */
+  fprintf(xmlout,      "              </JP2Header>\n");
+}
+/* ------------- */
+
+#ifdef NOTYET
+IMAGE these use cp structure, extended... but we could use a new data structure instead
+void xml_out_frame_jp2i(FILE* xmlout, opj_cp_t *cp) {
+  /* IntellectualProperty 'jp2i' (no restrictions on location) */
+  int i;
+  IMAGE cp->jp2i, cp->jp2i_count, cp->jp2i_data (array of chars), cp->cp2i_len (array of ints)
+  if(cp->jp2i != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < cp->jp2i_count; i++)
+  {
+    fprintf(xmlout,      "            <IntellectualProperty BoxType=\"jp2i\">\n");
+  /* I think this can be anything, including binary, so do a dump */
+    /* Is it better to indent or not indent this content?  Indent is better for reading, but
+    worse for cut/paste. */
+    xml_out_dump_hex_and_ascii(xmlout, cp->jp2i_data[i], cp->jp2i_len[i]);
+    fprintf(xmlout,      "            </IntellectualProperty>\n");
+  }
+}
+
+void xml_out_frame_xml(FILE* xmlout, opj_cp_t *cp) {
+  /* XML 'xml\040' (0x786d6c20).  Can appear multiply, before or after jp2c codestreams */
+  IMAGE cp->xml, cp->xml_count, cp->xml_data (array of chars)
+  MAYBE WE DON'T NEED cp->xml_len (array of ints) IF WE ASSUME xml_data IS NULL-TERMINATED.
+  ASSUME ASSUME EACH LINE IS ENDED BY \n.
+  int i;
+  if(cp->xml != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < cp->xml_count; i++)
+  {
+    fprintf(xmlout,      "            <TextFormXML BoxType=\"xml[space]" Instance=\"%d\">\n", i+1);
+    /* Is it better to indent or not indent this content?  Indent is better for reading, but
+    worse for cut/paste. Being lazy, didn't indent here. */
+    fprintf(xmlout,cp->xml_data[i]); /* May be multiple lines */ /* Could check if this is well-formed */
+    fprintf(xmlout,      "            </TextFormXML>\n");
+  }
+}
+
+void xml_out_frame_uuid(FILE* xmlout, opj_cp_t *cp) {
+	/* UUID 'uuid' (top level only) */
+	/* Part I 1.7.2 says: may appear multiply in JP2 file, anywhere except before File Type box */
+	/* Part III 5.2.1 says: Private extensions shall be achieved through the 'uuid' type. */
+	/* A UUID is a 16-byte value.  There is a conventional string representation for it:
+	   "0x12345678-9ABC-DEF0-1234-567890ABCDEF".  Let's assume that is what is stored in uuid_value */
+
+	/* Part III 6.1 Any other MJ2 box type could be alternatively written as a 'uuid' box, with value given
+	   as : 0xXXXXXXXX-0011-0010-8000-00AA00389B71, where the Xs are the boxtype in hex.  However,
+	   such a file is "not compliant; systems may choose to read [such] objects ... as equivalent to the box of
+	   the same type, or not."  Here, we choose not to. */
+  int i;
+  IMAGE cp->uuid, cp->uuid_count, cp->uuid_value (array of uuids... let's say fixed-length strings) cp->uuid_data (array of char buffers), cp->uuid_len (array of ints)
+  if(cp->juuid != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < cp->uuid_count; i++)
+  {
+    fprintf(xmlout,      "            <UniversalUniqueID BoxType=\"uuid\">
+	fprintf(xmlout,      "              <UUID>%s</UUDI>\n", cp->uuid_value[i]);
+	fprintf(xmlout,      "              <Data>\n");
+  /* I think this can be anything, including binary, so do a dump */
+    /* Is it better to indent or not indent this content?  Indent is better for reading, but
+    worse for cut/paste. */
+    xml_out_dump_hex_and_ascii(xmlout, cp->uuid_data[i], cp->uuid_len[i]);
+	fprintf(xmlout,      "              </Data>\n");
+    fprintf(xmlout,      "            </UniversalUniqueID>\n");
+  }
+}
+
+void xml_out_frame_uinf(FILE* xmlout, opj_cp_t *cp) {
+	/* UUIDInfo 'uinf', includes UUIDList 'ulst' and URL 'url\40' */
+	/* Part I 1.7.3 says: may appear multiply in JP2 file, anywhere at the top level except before File Type box */
+	/* So there may be multiple ulst's, and each can have multiple UUIDs listed (with a single URL) */
+	/* This is not quite as vendor-specific as UUIDs, or at least is meant to be generally readable */
+	/* Assume UUIDs stored in canonical string format */
+  int i, j;
+  IMAGE cp->uinf, cp->uinf_count, cp->uinf_ulst_nu (array of ints)
+    cp->uinf_uuid (2 dimensional array of uuids... let's say fixed-length strings),
+    cp->uinf_url (array of char buffers)
+
+  if(cp->uinf != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < cp->uuid_count; i++)
+  {
+    fprintf(xmlout,      "            <UUIDInfo BoxType=\"uinf\">\n");
+    fprintf(xmlout,      "              <UUIDList BoxType=\"ulst\" Count=\"%d\">\n",cp->cp->uinf_ulst_nu[i]);
+	for(j = 0; j < cp->uinf_ulst_nu[i];  j++)
+	  fprintf(xmlout,    "              <ID Instance=\"%s\">%s</ID>\n", cp->uuif_uuid[i][j], j+1);
+    fprintf(xmlout,      "              </UUIDList>\n");
+	fprintf(xmlout,      "              <DataEntryURL>\n");
+	/* Could add VERS and FLAG here */
+	fprintf(xmlout,      "                <LOC>\n");
+    fprintf(xmlout,      "                  %s",cp->uinf_url[i]); /* Probably single line, so indent works */ /* In theory, could check if this is well-formed, or good live link */
+	fprintf(xmlout,      "                </LOC>\n");
+	fprintf(xmlout,      "              </DataEntryURL>\n");
+    fprintf(xmlout,      "            </UUIDInfo>\n");
+  }
+}
+
+IMAGE these use cp structure, extended... but we could use a new data structure instead
+void xml_out_frame_unknown_type(FILE* xmlout, opj_cp_t *cp) {
+  /* Part III 5.2.1 says "Type fields not defined here are reserved.  Private extensions
+     shall be acieved through the 'uuid' type." [This implies an unknown
+     type would be an error, but then...] "Boxes not explicitly defined in this standard,
+	 or otherwise unrecognized by a reader, may be ignored."
+	 Also, it says  "the following types are not and will not be used, or used only in
+	 their existing sense, in future versions of this specification, to avoid conflict
+	 with existing content using earlier pre-standard versions of this format:
+	   clip, crgn, matt, kmat, pnot, ctab, load, imap;
+	   track reference types tmcd, chap, sync,scpt, ssrc"
+	 [But good luck figuring out the mapping.]
+	 Part III Amend. 2 4.1 is stronger: "All these specifications [of this family, e.g.,
+	 JP2 Part I, ISO Base format (Part 12) leading to MP4, Quicktime, and possibly including
+	 MJ2] require that readers ignore objects that are unrecognizable to them".
+	 */
+  int i;
+  IMAGE cp->unknown_type, cp->unknown_type_count, cp->unknown_type_boxtype (array of buf[5]s), cp->unknown_type_data (array of chars), cp->unknown_type_len (array of ints)
+  if(cp->unknown_type != 1)
+	  return; /* Not present */
+
+  for(i = 0; i < cp->unknown_type_count; i++)
+  {
+    fprintf(xmlout,      "            <UnknownType BoxType=\"%s\">\n", cp->unknown_type_boxtype[i]);
+    /* Can be anything, including binary, so do a dump */
+    /* Is it better to indent or not indent this content?  Indent is better for reading, but
+    worse for cut/paste. */
+    xml_out_dump_hex_and_ascii(xmlout, cp->unknown_type_data[i], cp->unknown_type_len[i]);
+    fprintf(xmlout,      "            </UnknownType>\n");
+  }
+}
+
+#endif
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/meta_out.h.svn-base ./mj2/.svn/text-base/meta_out.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/meta_out.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/meta_out.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,13 @@
+/* meta_out.h */
+/* Dump MJ2, JP2 metadata (partial so far) to xml file */
+/* Callable from mj2_to_metadata */
+/* Contributed to Open JPEG by Glenn Pearson, U.S. National Library of Medicine */
+
+#define BOOL int
+#define FALSE 0
+#define TRUE 1
+
+void xml_write_init(BOOL n, BOOL t, BOOL r, BOOL d);
+
+int xml_write_struct(FILE *file, FILE *xmlout, opj_mj2_t * movie, unsigned int sampleframe, char* stringDTD, opj_event_mgr_t *event_mgr);
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_convert.c.svn-base ./mj2/.svn/text-base/mj2_convert.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_convert.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_convert.c.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,331 @@
+/*
+* Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+* Copyright (c) 2002-2007, Professor Benoit Macq
+* Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include "opj_includes.h"
+#include "mj2.h"
+
+/*  -----------------------	      */
+/*				      */
+/*				      */
+/*  Count the number of frames	      */
+/*  in a YUV file		      */
+/*				      */
+/*  -----------------------	      */
+
+int yuv_num_frames(mj2_tk_t * tk, char *infile)
+{
+  int numimages, frame_size;
+  long end_of_f;
+	FILE *f;
+
+  f = fopen(infile,"rb");
+  if (!f) {  
+    fprintf(stderr, "failed to open %s for reading\n",infile);
+    return -1;
+  }
+	
+  frame_size = (int) (tk->w * tk->h * (1.0 + (double) 2 / (double) (tk->CbCr_subsampling_dx * tk->CbCr_subsampling_dy)));	/* Calculate frame size */
+	
+  fseek(f, 0, SEEK_END);
+  end_of_f = ftell(f);		/* Calculate file size */
+	
+  if (end_of_f < frame_size) {
+    fprintf(stderr,
+			"YUV does not contains any frame of %d x %d size\n", tk->w,
+			tk->h);
+    return -1;
+  }
+	
+  numimages = end_of_f / frame_size;	/* Calculate number of images */
+	fclose(f);
+
+  return numimages;
+}
+
+//  -----------------------
+//
+//
+//  YUV to IMAGE
+//
+//  -----------------------
+
+opj_image_t *mj2_image_create(mj2_tk_t * tk, opj_cparameters_t *parameters)
+{
+	opj_image_cmptparm_t cmptparm[3];
+	opj_image_t * img;
+	int i;
+	int numcomps = 3;
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+
+	/* initialize image components */
+	memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < numcomps; i++) {
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = 0;		
+		cmptparm[i].dx = i ? subsampling_dx * tk->CbCr_subsampling_dx : subsampling_dx;
+		cmptparm[i].dy = i ? subsampling_dy * tk->CbCr_subsampling_dy : subsampling_dy;
+		cmptparm[i].w = tk->w;
+		cmptparm[i].h = tk->h;
+	}
+	/* create the image */
+	img = opj_image_create(numcomps, cmptparm, CLRSPC_SRGB);
+	return img;
+}
+
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile)
+{
+  int i, compno;
+  int offset;
+  long end_of_f, position;
+	int numcomps = 3;
+	int subsampling_dx = parameters->subsampling_dx;
+	int subsampling_dy = parameters->subsampling_dy;
+	FILE *yuvfile;
+	
+  yuvfile = fopen(infile,"rb");
+  if (!yuvfile) {  
+    fprintf(stderr, "failed to open %s for readings\n",parameters->infile);
+    return 1;
+  }
+
+  offset = (int) ((double) (frame_num * tk->w * tk->h) * (1.0 +
+		1.0 * (double) 2 / (double) (tk->CbCr_subsampling_dx * tk->CbCr_subsampling_dy)));
+  fseek(yuvfile, 0, SEEK_END);
+  end_of_f = ftell(yuvfile);
+  fseek(yuvfile, sizeof(unsigned char) * offset, SEEK_SET);
+  position = ftell(yuvfile);
+  if (position >= end_of_f) {
+    fprintf(stderr, "Cannot reach frame number %d in yuv file !!\n",
+			frame_num);
+		fclose(yuvfile);
+    return 1;
+  }
+	
+  img->x0 = tk->Dim[0];
+  img->y0 = tk->Dim[1];
+  img->x1 = !tk->Dim[0] ? (tk->w - 1) * subsampling_dx + 1 : tk->Dim[0] +
+    (tk->w - 1) * subsampling_dx + 1;
+  img->y1 = !tk->Dim[1] ? (tk->h - 1) * subsampling_dy + 1 : tk->Dim[1] +
+    (tk->h - 1) * subsampling_dy + 1;
+	
+	for(compno = 0; compno < numcomps; compno++) {
+		for (i = 0; i < (tk->w * tk->h / (img->comps[compno].dx * img->comps[compno].dy))
+			&& !feof(yuvfile); i++) {
+			if (!fread(&img->comps[compno].data[i], 1, 1, yuvfile)) {
+				fprintf(stderr, "Error reading %s file !!\n", infile);				
+				return 1;
+			}
+		}
+	}
+	fclose(yuvfile);
+	
+  return 0;
+}
+
+
+
+//  -----------------------
+//
+//
+//  IMAGE to YUV
+//
+//  -----------------------
+
+
+bool imagetoyuv(opj_image_t * img, char *outfile)
+{
+  FILE *f;
+  int i;
+  
+  if (img->numcomps == 3) {
+    if (img->comps[0].dx != img->comps[1].dx / 2
+      || img->comps[1].dx != img->comps[2].dx) {
+      fprintf(stderr,
+				"Error with the input image components size: cannot create yuv file)\n");
+      return false;
+    }
+  } else if (!(img->numcomps == 1)) {
+    fprintf(stderr,
+      "Error with the number of image components(must be one or three)\n");
+    return false;
+  }
+  
+  f = fopen(outfile, "a+b");
+  if (!f) {
+    fprintf(stderr, "failed to open %s for writing\n", outfile);
+    return false;
+  }
+  
+  
+  for (i = 0; i < (img->comps[0].w * img->comps[0].h); i++) {
+    unsigned char y;
+    y = img->comps[0].data[i];
+    fwrite(&y, 1, 1, f);
+  }
+  
+  
+  if (img->numcomps == 3) {
+    for (i = 0; i < (img->comps[1].w * img->comps[1].h); i++) {
+      unsigned char cb;
+      cb = img->comps[1].data[i];
+      fwrite(&cb, 1, 1, f);
+    }
+    
+    
+    for (i = 0; i < (img->comps[2].w * img->comps[2].h); i++) {
+      unsigned char cr;
+      cr = img->comps[2].data[i];
+      fwrite(&cr, 1, 1, f);
+    }
+  } else if (img->numcomps == 1) {
+    for (i = 0; i < (img->comps[0].w * img->comps[0].h * 0.25); i++) {
+      unsigned char cb = 125;
+      fwrite(&cb, 1, 1, f);
+    }
+    
+    
+    for (i = 0; i < (img->comps[0].w * img->comps[0].h * 0.25); i++) {
+      unsigned char cr = 125;
+      fwrite(&cr, 1, 1, f);
+    }
+  }  
+  fclose(f);
+  return true;
+}
+
+//  -----------------------
+//
+//
+//  IMAGE to BMP
+//
+//  -----------------------
+
+int imagetobmp(opj_image_t * img, char *outfile) {
+  int w,wr,h,hr,i,pad;
+  FILE *f;
+  
+  if (img->numcomps == 3 && img->comps[0].dx == img->comps[1].dx
+    && img->comps[1].dx == img->comps[2].dx
+    && img->comps[0].dy == img->comps[1].dy
+    && img->comps[1].dy == img->comps[2].dy
+    && img->comps[0].prec == img->comps[1].prec
+    && img->comps[1].prec == img->comps[2].prec) {
+    /* -->> -->> -->> -->>
+    
+      24 bits color
+      
+    <<-- <<-- <<-- <<-- */
+    
+    f = fopen(outfile, "wb");
+    if (!f) {
+      fprintf(stderr, "failed to open %s for writing\n", outfile);
+      return 1;
+    }   
+    
+    w = img->comps[0].w;
+    wr = int_ceildivpow2(img->comps[0].w, img->comps[0].factor);
+    
+    h = img->comps[0].h;
+    hr = int_ceildivpow2(img->comps[0].h, img->comps[0].factor);
+    
+    fprintf(f, "BM");
+    
+    /* FILE HEADER */
+    /* ------------- */
+    fprintf(f, "%c%c%c%c",
+      (unsigned char) (hr * wr * 3 + 3 * hr * (wr % 2) +
+      54) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)
+      >> 8) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)
+      >> 16) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2) + 54)
+      >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff,
+      ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (54) & 0xff, ((54) >> 8) & 0xff,
+      ((54) >> 16) & 0xff, ((54) >> 24) & 0xff);
+    
+    /* INFO HEADER   */
+    /* ------------- */
+    fprintf(f, "%c%c%c%c", (40) & 0xff, ((40) >> 8) & 0xff,
+      ((40) >> 16) & 0xff, ((40) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (unsigned char) ((wr) & 0xff),
+      (unsigned char) ((wr) >> 8) & 0xff,
+      (unsigned char) ((wr) >> 16) & 0xff,
+      (unsigned char) ((wr) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (unsigned char) ((hr) & 0xff),
+      (unsigned char) ((hr) >> 8) & 0xff,
+      (unsigned char) ((hr) >> 16) & 0xff,
+      (unsigned char) ((hr) >> 24) & 0xff);
+    fprintf(f, "%c%c", (1) & 0xff, ((1) >> 8) & 0xff);
+    fprintf(f, "%c%c", (24) & 0xff, ((24) >> 8) & 0xff);
+    fprintf(f, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff,
+      ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c",
+      (unsigned char) (3 * hr * wr +
+      3 * hr * (wr % 2)) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >>
+      8) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >>
+      16) & 0xff,
+      (unsigned char) ((hr * wr * 3 + 3 * hr * (wr % 2)) >>
+      24) & 0xff);
+    fprintf(f, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,
+      ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (7834) & 0xff, ((7834) >> 8) & 0xff,
+      ((7834) >> 16) & 0xff, ((7834) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff,
+      ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+    fprintf(f, "%c%c%c%c", (0) & 0xff, ((0) >> 8) & 0xff,
+      ((0) >> 16) & 0xff, ((0) >> 24) & 0xff);
+    
+    for (i = 0; i < wr * hr; i++) {
+      unsigned char R, G, B;
+      /* a modifier */
+      // R = img->comps[0].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+      R = img->comps[0].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+      // G = img->comps[1].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+      G = img->comps[1].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+      // B = img->comps[2].data[w * h - ((i) / (w) + 1) * w + (i) % (w)];
+      B = img->comps[2].data[w * hr - ((i) / (wr) + 1) * w + (i) % (wr)];
+      fprintf(f, "%c%c%c", B, G, R);
+      
+      if ((i + 1) % wr == 0) {
+				for (pad = (3 * wr) % 4 ? 4 - (3 * wr) % 4 : 0; pad > 0; pad--)	/* ADD */
+					fprintf(f, "%c", 0);
+      }
+    }
+    fclose(f);
+    opj_free(img->comps[1].data);
+    opj_free(img->comps[2].data);
+  }
+  return 0;
+}
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_convert.h.svn-base ./mj2/.svn/text-base/mj2_convert.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_convert.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_convert.h.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,45 @@
+/*
+* Copyright (c) 2003-2004, François-Olivier Devaux
+* Copyright (c) 2002-2004,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*/
+
+
+#include "mj2.h"
+
+#ifndef __MJ2_CONVERT_H
+#define __MJ2_CONVERT_H
+
+int imagetoyuv(opj_image_t * img, char *outfile);
+
+int imagetobmp(opj_image_t * img, char *outfile);
+
+opj_image_t *mj2_image_create(mj2_tk_t * tk, opj_cparameters_t *parameters);
+
+char yuvtoimage(mj2_tk_t * tk, opj_image_t * img, int frame_num, opj_cparameters_t *parameters, char* infile);
+
+int yuv_num_frames(mj2_tk_t * tk, char *infile);
+
+
+#endif
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2.c.svn-base ./mj2/.svn/text-base/mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,2906 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include "opj_includes.h"
+#include "mj2.h"
+
+/** @defgroup JP2 JP2 - JPEG-2000 file format reader/writer */
+/*@{*/
+
+/** @name Local static functions */
+/*@{*/
+
+/**
+Read box headers
+@param cinfo Codec context info
+@param cio Input stream
+@param box
+@return Returns true if successful, returns false otherwise
+*/
+static bool jp2_read_boxhdr(opj_common_ptr cinfo, opj_cio_t *cio, opj_jp2_box_t *box);
+
+/*
+* 
+* Read box headers
+*
+*/
+
+int mj2_read_boxhdr(mj2_box_t * box, opj_cio_t *cio)
+{
+  box->init_pos = cio_tell(cio);
+  box->length = cio_read(cio, 4);
+  box->type = cio_read(cio, 4);
+  if (box->length == 1) {
+    if (cio_read(cio, 4) != 0) {
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Cannot handle box sizes higher than 2^32\n");
+      return 1;
+    };
+    box->length = cio_read(cio, 4);
+    if (box->length == 0) 
+      box->length = cio_numbytesleft(cio) + 12;
+  }
+  else if (box->length == 0) {
+    box->length = cio_numbytesleft(cio) + 8;
+  }
+  return 0;
+}
+
+/*
+* 
+* Initialisation of a Standard Movie, given a simple movie structure defined by the user 
+* The movie will have one sample per chunk
+* 
+* Arguments: opj_mj2_t * movie
+* Several variables of "movie" must be defined in order to enable a correct execution of 
+* this function:
+*   - The number of tracks of each type (movie->num_vtk, movie->num_stk, movie->num_htk)
+*   - The memory for each must be allocated (movie->tk)
+*   - For each track:
+*	  The track type (tk->track_type)
+*	  The number of sample (tk->num_samples)
+*	  The sample rate (tk->sample_rate)
+*
+*/
+
+int mj2_init_stdmovie(opj_mj2_t * movie)
+{
+  int i;
+  unsigned int j;
+  time_t ltime;
+	
+  movie->brand = MJ2_MJ2;
+  movie->minversion = 0;
+  movie->num_cl = 2;
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
+  movie->cl[0] = MJ2_MJ2;
+  movie->cl[1] = MJ2_MJ2S;
+  time(&ltime);			/* Time since 1/1/70 */
+  movie->creation_time = (unsigned int) ltime + 2082844800;	/* Seconds between 1/1/04 and 1/1/70 */
+  movie->timescale = 1000;
+	
+  movie->rate = 1 << 16;		/* Rate to play presentation  (default = 0x00010000)          */
+  movie->volume = 1 << 8;		/* Movie volume (default = 0x0100)                            */
+  movie->trans_matrix[0] = 0x00010000;	/* Transformation matrix for video                            */
+  movie->trans_matrix[1] = 0;	/* Unity is { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }  */
+  movie->trans_matrix[2] = 0;
+  movie->trans_matrix[3] = 0;
+  movie->trans_matrix[4] = 0x00010000;
+  movie->trans_matrix[5] = 0;
+  movie->trans_matrix[6] = 0;
+  movie->trans_matrix[7] = 0;
+  movie->trans_matrix[8] = 0x40000000;
+  movie->next_tk_id = 1;
+	
+  for (i = 0; i < movie->num_htk + movie->num_stk + movie->num_vtk; i++) {
+    mj2_tk_t *tk = &movie->tk[i];
+    movie->next_tk_id++;
+    tk->jp2_struct.comps = NULL;
+    tk->jp2_struct.cl = NULL;
+    
+    if (tk->track_type == 0) {
+      if (tk->num_samples == 0)
+				return 1;
+			
+      tk->Dim[0] = 0;
+      tk->Dim[1] = 0;
+			
+      tk->timescale = 1000;	/* Timescale = 1 ms                                          */
+			
+      tk->chunk[0].num_samples = 1;
+      tk->chunk[0].sample_descr_idx = 1;
+			
+      tk->same_sample_size = 0;
+			
+      tk->num_samplestochunk = 1;	/* One sample per chunk                                      */
+		tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
+      tk->sampletochunk[0].first_chunk = 1;
+      tk->sampletochunk[0].samples_per_chunk = 1;
+      tk->sampletochunk[0].sample_descr_idx = 1;
+      
+      if (tk->sample_rate == 0) {
+				opj_event_msg(tk->cinfo, EVT_ERROR,
+					"Error while initializing MJ2 movie: Sample rate of track %d must be different from zero\n",
+					tk->track_ID);
+				return 1;
+      }
+			
+      for (j = 0; j < tk->num_samples; j++) {
+				tk->sample[j].sample_delta = tk->timescale / tk->sample_rate;
+      }
+			
+      tk->num_tts = 1;
+		tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
+      tk->tts[0].sample_count = tk->num_samples;
+      tk->tts[0].sample_delta = tk->timescale / tk->sample_rate;
+			
+      tk->horizresolution = 0x00480000;	/* Horizontal resolution (typically 72)                       */
+      tk->vertresolution = 0x00480000;	/* Vertical resolution (typically 72)                         */
+      tk->compressorname[0] = 0x0f4d6f74;	/* Compressor Name[]: Motion JPEG2000                         */
+      tk->compressorname[1] = 0x696f6e20;
+      tk->compressorname[2] = 0x4a504547;
+      tk->compressorname[3] = 0x32303030;
+      tk->compressorname[4] = 0x00120000;
+      tk->compressorname[5] = 0;
+      tk->compressorname[6] = 0x00000042;
+      tk->compressorname[7] = 0x000000DC;
+      tk->num_url = 0;		/* Number of URL                                              */
+      tk->num_urn = 0;		/* Number of URN                                              */
+      tk->graphicsmode = 0;	/* Graphicsmode                                               */
+      tk->opcolor[0] = 0;	/* OpColor                                                    */
+      tk->opcolor[1] = 0;	/* OpColor                                                    */
+      tk->opcolor[2] = 0;	/* OpColor                                                    */
+      tk->creation_time = movie->creation_time;	/* Seconds between 1/1/04 and 1/1/70          */
+      tk->language = 0;		/* Language (undefined)					      */
+      tk->layer = 0;
+      tk->volume = 1 << 8;		/* Movie volume (default = 0x0100) */
+      tk->trans_matrix[0] = 0x00010000;	/* Transformation matrix for track */
+      tk->trans_matrix[1] = 0;	/* Unity is { 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 }  */
+      tk->trans_matrix[2] = 0;
+      tk->trans_matrix[3] = 0;
+      tk->trans_matrix[4] = 0x00010000;
+      tk->trans_matrix[5] = 0;
+      tk->trans_matrix[6] = 0;
+      tk->trans_matrix[7] = 0;
+      tk->trans_matrix[8] = 0x40000000;
+      tk->fieldcount = 1;
+      tk->fieldorder = 0;
+      tk->or_fieldcount = 1;
+      tk->or_fieldorder = 0;
+      tk->num_br = 2;
+		tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
+      tk->br[0] = MJ2_JP2;
+      tk->br[1] = MJ2_J2P0;
+      tk->num_jp2x = 0;
+      tk->hsub = 2;		/* 4:2:0                                                      */
+      tk->vsub = 2;		/* 4:2:0                                                      */
+      tk->hoff = 0;
+      tk->voff = 0;
+      tk->visual_w = tk->w << 16;
+      tk->visual_h = tk->h << 16;
+    }
+    else {
+      tk->num_br = 0;
+      tk->jp2xdata = NULL;
+    }
+  }
+  return 0;
+}
+
+/*
+* Time To Sample box Decompact
+*
+*/
+void mj2_tts_decompact(mj2_tk_t * tk)
+{
+  int i, j;
+  tk->num_samples = 0;
+  for (i = 0; i < tk->num_tts; i++) {
+    tk->num_samples += tk->tts[i].sample_count;
+  }
+
+  tk->sample = (mj2_sample_t*) opj_malloc(tk->num_samples * sizeof(mj2_sample_t));
+
+  for (i = 0; i < tk->num_tts; i++) {
+    for (j = 0; j < tk->tts[i].sample_count; j++) {
+      tk->sample[j].sample_delta = tk->tts[i].sample_delta;
+    }
+  }
+}
+
+/*
+* Sample To Chunk box Decompact
+*
+*/
+void mj2_stsc_decompact(mj2_tk_t * tk)
+{
+  int j, i;
+  unsigned int k;
+  int sampleno=0;
+  
+  if (tk->num_samplestochunk == 1) {
+    tk->num_chunks =
+      (unsigned int) ceil((double) tk->num_samples /
+      (double) tk->sampletochunk[0].samples_per_chunk);
+	 tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_chunks * sizeof(mj2_chunk_t));
+    for (k = 0; k < tk->num_chunks; k++) {
+      tk->chunk[k].num_samples = tk->sampletochunk[0].samples_per_chunk;
+    }
+    
+  } else {
+    tk->chunk = (mj2_chunk_t*) opj_malloc(tk->num_samples * sizeof(mj2_chunk_t));
+    tk->num_chunks = 0;
+    for (i = 0; i < tk->num_samplestochunk -1 ; i++) {
+      for (j = tk->sampletochunk[i].first_chunk - 1;
+      j < tk->sampletochunk[i + 1].first_chunk - 1; j++) {
+				tk->chunk[j].num_samples = tk->sampletochunk[i].samples_per_chunk;
+				tk->num_chunks++;
+				sampleno += tk->chunk[j].num_samples;
+      }
+    }
+    tk->num_chunks += (int)(tk->num_samples  - sampleno) / tk->sampletochunk[tk->num_samplestochunk - 1].samples_per_chunk;
+    for (k = tk->sampletochunk[tk->num_samplestochunk - 1].first_chunk - 1;
+    k < tk->num_chunks; k++) {
+      tk->chunk[k].num_samples =
+				tk->sampletochunk[tk->num_samplestochunk - 1].samples_per_chunk;
+    }
+    tk->chunk = opj_realloc(tk->chunk, tk->num_chunks * sizeof(mj2_chunk_t));
+  }
+  
+}
+
+
+/*
+* Chunk offset box Decompact
+*
+*/
+void mj2_stco_decompact(mj2_tk_t * tk)
+{
+  int j;
+  unsigned int i;
+  int k = 0;
+  int intra_chunk_offset;
+	
+  for (i = 0; i < tk->num_chunks; i++) {
+    intra_chunk_offset = 0;
+    for (j = 0; j < tk->chunk[i].num_samples; j++) {
+      tk->sample[k].offset = intra_chunk_offset + tk->chunk[i].offset;
+      intra_chunk_offset += tk->sample[k].sample_size;
+      k++;
+    }
+  }
+}
+
+/*
+* Write the JP box
+*
+* JP Signature box
+*
+*/
+void mj2_write_jp(opj_cio_t *cio)
+{
+  mj2_box_t box;
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+	
+  cio_write(cio, MJ2_JP, 4);		/* JP */
+  cio_write(cio, 0x0d0a870a, 4);	/* 0x0d0a870a required in a JP box */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the JP box
+*
+* JPEG 2000 signature
+*
+*/
+int mj2_read_jp(opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_JP != box.type) {	/* Check Marker */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected JP Marker\n");
+    return 1;
+  }
+  if (0x0d0a870a != cio_read(cio, 4)) {	/* read the 0x0d0a870a required in a JP box */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with JP Marker\n");
+    return 1;
+  }
+  if (cio_tell(cio) - box.init_pos != box.length) {	/* Check box length */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with JP Box size \n");
+    return 1;
+  }
+  return 0;
+	
+}
+
+/*
+* Write the FTYP box
+*
+* File type box
+*
+*/
+void mj2_write_ftyp(opj_mj2_t * movie, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+	
+  cio_write(cio, MJ2_FTYP, 4);	/* FTYP       */
+  cio_write(cio, movie->brand, 4);	/* BR         */
+  cio_write(cio, movie->minversion, 4);	/* MinV       */
+	
+  for (i = 0; i < movie->num_cl; i++)
+    cio_write(cio, movie->cl[i], 4);	/* CL         */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* Length     */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the FTYP box
+*
+* File type box
+*
+*/
+int mj2_read_ftyp(opj_mj2_t * movie, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);	/* Box Size */
+  if (MJ2_FTYP != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected FTYP Marker\n");
+    return 1;
+  }
+	
+  movie->brand = cio_read(cio, 4);	/* BR              */
+  movie->minversion = cio_read(cio, 4);	/* MinV            */
+  movie->num_cl = (box.length - 16) / 4;
+  movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+
+  for (i = movie->num_cl - 1; i > -1; i--)
+    movie->cl[i] = cio_read(cio, 4);	/* CLi */
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with FTYP Box\n");
+    return 1;
+  }
+  return 0;
+}
+
+
+/*
+* Write the STCO box
+*
+* Chunk Offset Box
+*
+*/
+void mj2_write_stco(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+  unsigned int i;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STCO, 4);	/* STCO       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->num_chunks, 4);	/* Entry Count */
+	
+  for (i = 0; i < tk->num_chunks; i++) {
+    cio_write(cio, tk->chunk[i].offset, 4);	/* Entry offset */
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STCO box
+*
+* Chunk Offset Box
+*
+*/
+int mj2_read_stco(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  unsigned int i;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);	/* Box Size */
+  if (MJ2_STCO != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STCO Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in STCO box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in STCO box. Expected flag 0\n");
+    return 1;
+  }
+	
+	
+  if (cio_read(cio, 4) != tk->num_chunks) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, 
+			"Error in STCO box: expecting same amount of entry-count as chunks \n");
+  } else {
+    for (i = 0; i < tk->num_chunks; i++) {
+      tk->chunk[i].offset = cio_read(cio, 4);	/* Entry offset */
+    }
+  }
+	
+  mj2_stco_decompact(tk);
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STCO Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the STSZ box
+*
+* Sample size box
+*
+*/
+void mj2_write_stsz(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+  unsigned int i;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STSZ, 4);	/* STSZ       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  if (tk->same_sample_size == 1) {	/* If they all have the same size */
+    cio_write(cio, tk->sample[0].sample_size, 4);	/* Size */
+		
+    cio_write(cio, 1, 4);		/* Entry count = 1 */
+  }
+	
+  else {
+    cio_write(cio, 0, 4);		/* Sample Size = 0 becase they all have different sizes */
+		
+    cio_write(cio, tk->num_samples, 4);	/* Sample Count */
+		
+    for (i = 0; i < tk->num_samples; i++) {
+      cio_write(cio, tk->sample[i].sample_size, 4);
+    }
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STSZ box
+*
+* Sample size box
+*
+*/
+int mj2_read_stsz(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int sample_size;
+  unsigned int i;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);	/* Box Size */
+  if (MJ2_STSZ != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STSZ Marker\n");
+    return 1;
+  }
+	
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in STSZ box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in STSZ box. Expected flag 0\n");
+    return 1;
+  }
+	
+  sample_size = cio_read(cio, 4);
+	
+  if (sample_size != 0) {	/* Samples do have the same size */
+    tk->same_sample_size = 1;
+    for (i = 0; i < tk->num_samples; i++) {
+      tk->sample[i].sample_size = sample_size;
+    }
+    cio_skip(cio,4);		/* Sample count = 1 */
+  } else {
+    tk->same_sample_size = 0;
+    if (tk->num_samples != cio_read(cio, 4)) {	/* Sample count */
+      opj_event_msg(cio->cinfo, EVT_ERROR,
+				"Error in STSZ box. Expected that sample-count is number of samples in track\n");
+      return 1;
+    }
+    for (i = 0; i < tk->num_samples; i++) {
+      tk->sample[i].sample_size = cio_read(cio, 4);	/* Sample Size */
+    }
+		
+    if (cio_tell(cio) - box.init_pos != box.length) {
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STSZ Box size\n");
+      return 1;
+    }
+  }
+  return 0;
+	
+}
+
+/*
+* Write the STSC box
+*
+* Sample to Chunk
+*
+*/
+void mj2_write_stsc(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STSC, 4);	/* STSC       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->num_samplestochunk, 4);	/* Entry Count */
+	
+  for (i = 0; i < tk->num_samplestochunk; i++) {
+    cio_write(cio, tk->sampletochunk[i].first_chunk, 4);	/* First Chunk */
+    cio_write(cio, tk->sampletochunk[i].samples_per_chunk, 4);	/* Samples per chunk */
+    cio_write(cio, tk->sampletochunk[i].sample_descr_idx, 4);	/* Samples description index */
+  }
+	
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STSC box
+*
+* Sample to Chunk
+*
+*/
+int mj2_read_stsc(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);	/* Box Size */
+  if (MJ2_STSC != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STSC Marker\n");
+    return 1;
+  }
+	
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in STSC box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in STSC box. Expected flag 0\n");
+    return 1;
+  }
+	
+  tk->num_samplestochunk = cio_read(cio, 4);
+
+  tk->sampletochunk = (mj2_sampletochunk_t*) opj_malloc(tk->num_samplestochunk * sizeof(mj2_sampletochunk_t));
+
+  for (i = 0; i < tk->num_samplestochunk; i++) {
+    tk->sampletochunk[i].first_chunk = cio_read(cio, 4);
+    tk->sampletochunk[i].samples_per_chunk = cio_read(cio, 4);
+    tk->sampletochunk[i].sample_descr_idx = cio_read(cio, 4);
+  }
+	
+  mj2_stsc_decompact(tk);	/* decompact sample to chunk box */
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STSC Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the STTS box
+*
+* Time to Sample Box
+*
+*/
+void mj2_write_stts(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STTS, 4);	/* STTS       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->num_tts, 4);	/* entry_count */
+  for (i = 0; i < tk->num_tts; i++) {
+    cio_write(cio, tk->tts[i].sample_count, 4);	/* Sample-count */
+    cio_write(cio, tk->tts[i].sample_delta, 4);	/* Sample-Delta */
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STTS box
+*
+* 
+*
+*/
+int mj2_read_stts(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_STTS != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STTS Marker\n");
+    return 1;
+  }
+	
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in STTS box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in STTS box. Expected flag 0\n");
+    return 1;
+  }
+	
+  tk->num_tts = cio_read(cio, 4);
+
+  tk->tts = (mj2_tts_t*) opj_malloc(tk->num_tts * sizeof(mj2_tts_t));
+
+  for (i = 0; i < tk->num_tts; i++) {
+    tk->tts[i].sample_count = cio_read(cio, 4);
+    tk->tts[i].sample_delta = cio_read(cio, 4);
+  }
+	
+  mj2_tts_decompact(tk);
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STTS Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the FIEL box
+*
+* Field coding Box
+*
+*/
+void mj2_write_fiel(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_FIEL, 4);	/* STTS       */
+	
+  cio_write(cio, tk->fieldcount, 1);	/* Field count */
+  cio_write(cio, tk->fieldorder, 1);	/* Field order */
+	
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the FIEL box
+*
+* Field coding Box
+*
+*/
+int mj2_read_fiel(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_FIEL != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected FIEL Marker\n");
+    return 1;
+  }
+	
+	
+  tk->fieldcount = cio_read(cio, 1);
+  tk->fieldorder = cio_read(cio, 1);
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with FIEL Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the ORFO box
+*
+* Original Format Box
+*
+*/
+void mj2_write_orfo(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_ORFO, 4);
+	
+  cio_write(cio, tk->or_fieldcount, 1);	/* Original Field count */
+  cio_write(cio, tk->or_fieldorder, 1);	/* Original Field order */
+	
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the ORFO box
+*
+* Original Format Box
+*
+*/
+int mj2_read_orfo(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_ORFO != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected ORFO Marker\n");
+    return 1;
+  }
+	
+	
+  tk->or_fieldcount = cio_read(cio, 1);
+  tk->or_fieldorder = cio_read(cio, 1);
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with ORFO Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the JP2P box
+*
+* MJP2 Profile Box
+*
+*/
+void mj2_write_jp2p(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_JP2P, 4);
+	
+  cio_write(cio, 0, 4);		/* Version 0, flags =0 */
+	
+  for (i = 0; i < tk->num_br; i++) {
+    cio_write(cio, tk->br[i], 4);
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the JP2P box
+*
+* MJP2 Profile Box
+*
+*/
+int mj2_read_jp2p(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_JP2P != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected JP2P Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in JP2P box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in JP2P box. Expected flag 0\n");
+    return 1;
+  }
+	
+	
+  tk->num_br = (box.length - 12) / 4;
+  tk->br = (unsigned int*) opj_malloc(tk->num_br * sizeof(unsigned int));
+
+  for (i = 0; i < tk->num_br; i++) {
+    tk->br[i] = cio_read(cio, 4);
+  }
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with JP2P Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the JP2X box
+*
+* MJP2 Prefix Box
+*
+*/
+void mj2_write_jp2x(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_JP2X, 4);
+	
+  for (i = 0; i < tk->num_jp2x; i++) {
+    cio_write(cio, tk->jp2xdata[i], 1);
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the JP2X box
+*
+* MJP2 Prefix Box
+*
+*/
+int mj2_read_jp2x(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  unsigned int i;
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_JP2X != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected JP2X Marker\n");
+    return 1;
+  }
+	
+	
+  tk->num_jp2x = (box.length - 8);
+  tk->jp2xdata = (unsigned char*) opj_malloc(tk->num_jp2x * sizeof(unsigned char));
+
+  for (i = 0; i < tk->num_jp2x; i++) {
+    tk->jp2xdata[i] = cio_read(cio, 1);
+  }
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with JP2X Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the JSUB box
+*
+* MJP2 Subsampling Box
+*
+*/
+void mj2_write_jsub(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_JSUB, 4);
+	
+  cio_write(cio, tk->hsub, 1);
+  cio_write(cio, tk->vsub, 1);
+  cio_write(cio, tk->hoff, 1);
+  cio_write(cio, tk->voff, 1);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the JSUB box
+*
+* MJP2 Subsampling Box
+*
+*/
+int mj2_read_jsub(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_JSUB != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected JSUB Marker\n");
+    return 1;
+  }
+	
+  tk->hsub = cio_read(cio, 1);
+  tk->vsub = cio_read(cio, 1);
+  tk->hoff = cio_read(cio, 1);;
+  tk->voff = cio_read(cio, 1);
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with JSUB Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the SMJ2 box
+*
+* Visual Sample Entry Description
+*
+*/
+void mj2_write_smj2(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MJ2, 4);	/* MJ2       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, 1, 4);
+	
+  cio_write(cio, 0, 2);		/* Pre-defined */
+	
+  cio_write(cio, 0, 2);		/* Reserved */
+	
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+	
+  cio_write(cio, tk->w, 2);		/* Width  */
+  cio_write(cio, tk->h, 2);		/* Height */
+	
+  cio_write(cio, tk->horizresolution, 4);	/* Horizontal resolution */
+  cio_write(cio, tk->vertresolution, 4);	/* Vertical resolution   */
+	
+  cio_write(cio, 0, 4);		/* Reserved */
+	
+  cio_write(cio, 1, 2);		/* Pre-defined = 1 */
+	
+  cio_write(cio, tk->compressorname[0], 4);	/* Compressor Name */
+  cio_write(cio, tk->compressorname[1], 4);
+  cio_write(cio, tk->compressorname[2], 4);
+  cio_write(cio, tk->compressorname[3], 4);
+  cio_write(cio, tk->compressorname[4], 4);
+  cio_write(cio, tk->compressorname[5], 4);
+  cio_write(cio, tk->compressorname[6], 4);
+  cio_write(cio, tk->compressorname[7], 4);
+	
+  cio_write(cio, tk->depth, 2);	/* Depth */
+	
+  cio_write(cio, 0xffff, 2);		/* Pre-defined = -1 */
+	
+  jp2_write_jp2h(&tk->jp2_struct, cio);
+	
+  mj2_write_fiel(tk, cio);
+	
+  if (tk->num_br != 0)
+    mj2_write_jp2p(tk, cio);
+  if (tk->num_jp2x != 0)
+    mj2_write_jp2x(tk, cio);
+	
+  mj2_write_jsub(tk, cio);
+  mj2_write_orfo(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the SMJ2 box
+*
+* Visual Sample Entry Description
+*
+*/
+int mj2_read_smj2(opj_image_t * img, mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+  mj2_box_t box2;
+  int i;
+	
+  mj2_read_boxhdr(&box, cio);
+	
+  if (MJ2_MJ2 != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error in SMJ2 box: Expected MJ2 Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in MJP2 box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in MJP2 box. Expected flag 0\n");
+    return 1;
+  }
+	
+  cio_skip(cio,4);
+	
+  cio_skip(cio,2);			/* Pre-defined */
+	
+  cio_skip(cio,2);			/* Reserved */
+	
+  cio_skip(cio,4);			/* Pre-defined */
+  cio_skip(cio,4);			/* Pre-defined */
+  cio_skip(cio,4);			/* Pre-defined */
+	
+  tk->w = cio_read(cio, 2);		/* Width  */
+  tk->h = cio_read(cio, 2);		/* Height */
+	
+  tk->horizresolution = cio_read(cio, 4);	/* Horizontal resolution */
+  tk->vertresolution = cio_read(cio, 4);	/* Vertical resolution   */
+	
+  cio_skip(cio,4);			/* Reserved */
+	
+  cio_skip(cio,2);			/* Pre-defined = 1 */
+	
+  tk->compressorname[0] = cio_read(cio, 4);	/* Compressor Name */
+  tk->compressorname[1] = cio_read(cio, 4);
+  tk->compressorname[2] = cio_read(cio, 4);
+  tk->compressorname[3] = cio_read(cio, 4);
+  tk->compressorname[4] = cio_read(cio, 4);
+  tk->compressorname[5] = cio_read(cio, 4);
+  tk->compressorname[6] = cio_read(cio, 4);
+  tk->compressorname[7] = cio_read(cio, 4);
+	
+  tk->depth = cio_read(cio, 2);	/* Depth */
+	
+  /* Init std value */
+  tk->num_jp2x = 0;
+  tk->fieldcount = 1;
+  tk->fieldorder = 0;
+  tk->or_fieldcount = 1;
+  tk->or_fieldorder = 0;
+	
+  cio_skip(cio,2);			/* Pre-defined = -1 */
+	
+  if (!jp2_read_jp2h(&tk->jp2_struct, cio)) {
+		opj_event_msg(tk->cinfo, EVT_ERROR, "Error reading JP2H Box\n");
+    return 1;
+  }
+
+  tk->jp2_struct.comps = (opj_jp2_comps_t*) opj_malloc(tk->jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
+  tk->jp2_struct.cl = (int*) opj_malloc(sizeof(int));
+
+  tk->num_br = 0;
+  tk->num_jp2x = 0;
+	
+  for (i = 0; cio_tell(cio) - box.init_pos < box.length; i++) {
+    mj2_read_boxhdr(&box2, cio);
+    cio_seek(cio, box2.init_pos);
+    switch (box2.type) {
+    case MJ2_FIEL:
+      if (mj2_read_fiel(tk, cio))
+				return 1;
+      break;
+			
+    case MJ2_JP2P:
+      if (mj2_read_jp2p(tk, cio))
+				return 1;
+      break;
+			
+    case MJ2_JP2X:
+      if (mj2_read_jp2x(tk, cio))
+				return 1;
+      break;
+			
+    case MJ2_JSUB:
+      if (mj2_read_jsub(tk, cio))
+				return 1;
+      break;
+			
+    case MJ2_ORFO:
+      if (mj2_read_orfo(tk, cio))
+				return 1;
+      break;
+			
+    default:
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MJP2 Box size\n");
+      return 1;
+      break;
+			
+    }
+  }
+  return 0;
+}
+
+
+/*
+* Write the STSD box
+*
+* Sample Description
+*
+*/
+void mj2_write_stsd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STSD, 4);	/* STSD       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, 1, 4);		/* entry_count = 1 (considering same JP2 headerboxes) */
+	
+  if (tk->track_type == 0) {
+    mj2_write_smj2(tk, cio);
+  } else if (tk->track_type == 1) {
+    // Not implemented
+  }
+  if (tk->track_type == 2) {
+    // Not implemented
+  }
+	
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STSD box
+*
+* Sample Description
+*
+*/
+int mj2_read_stsd(mj2_tk_t * tk, opj_image_t * img, opj_cio_t *cio)
+{
+  int i;
+  int entry_count, len_2skip;
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+	
+  if (MJ2_STSD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STSD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in STSD box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in STSD box. Expected flag 0\n");
+    return 1;
+  }
+	
+  entry_count = cio_read(cio, 4);
+	
+  if (tk->track_type == 0) {
+    for (i = 0; i < entry_count; i++) {
+      if (mj2_read_smj2(img, tk, cio))
+				return 1;
+    }
+  } else if (tk->track_type == 1) {
+    len_2skip = cio_read(cio, 4);	// Not implemented -> skipping box
+    cio_skip(cio,len_2skip - 4);
+  } else if (tk->track_type == 2) {
+    len_2skip = cio_read(cio, 4);	// Not implemented -> skipping box
+    cio_skip(cio,len_2skip - 4);
+  }
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STSD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the STBL box
+*
+* Sample table box box
+*
+*/
+void mj2_write_stbl(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_STBL, 4);	/* STBL       */
+	
+  mj2_write_stsd(tk, cio);
+  mj2_write_stts(tk, cio);
+  mj2_write_stsc(tk, cio);
+  mj2_write_stsz(tk, cio);
+  mj2_write_stco(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the STBL box
+*
+* Sample table box box
+*
+*/
+int mj2_read_stbl(mj2_tk_t * tk, opj_image_t * img, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_STBL != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected STBL Marker\n");
+    return 1;
+  }
+	
+  if (mj2_read_stsd(tk, img, cio))
+    return 1;
+  if (mj2_read_stts(tk, cio))
+    return 1;
+  if (mj2_read_stsc(tk, cio))
+    return 1;
+  if (mj2_read_stsz(tk, cio))
+    return 1;
+  if (mj2_read_stco(tk, cio))
+    return 1;
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with STBL Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the URL box
+*
+* URL box
+*
+*/
+void mj2_write_url(mj2_tk_t * tk, int url_num, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_URL, 4);	/* URL       */
+	
+  if (url_num == 0)
+    cio_write(cio, 1, 4);		/* Version = 0, flags = 1 because stored in same file */
+  else {
+    cio_write(cio, 0, 4);		/* Version = 0, flags =  0 */
+    cio_write(cio, tk->url[url_num - 1].location[0], 4);
+    cio_write(cio, tk->url[url_num - 1].location[1], 4);
+    cio_write(cio, tk->url[url_num - 1].location[2], 4);
+    cio_write(cio, tk->url[url_num - 1].location[3], 4);
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the URL box
+*
+* URL box
+*
+*/
+int mj2_read_url(mj2_tk_t * tk, int urn_num, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_URL != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected URL Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in URL box\n");
+    return 1;
+  }
+	
+  if (1 != cio_read(cio, 3)) {	/* If flags = 1 --> media data in file */
+    tk->url[urn_num].location[0] = cio_read(cio, 4);
+    tk->url[urn_num].location[1] = cio_read(cio, 4);
+    tk->url[urn_num].location[2] = cio_read(cio, 4);
+    tk->url[urn_num].location[3] = cio_read(cio, 4);
+  } else {
+    tk->num_url--;
+  }
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with URL Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the URN box
+*
+* URN box
+*
+*/
+void mj2_write_urn(mj2_tk_t * tk, int urn_num, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_URN, 4);	/* URN       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags =  0 */
+	
+  cio_write(cio, tk->urn[urn_num].name[0], 4);
+  cio_write(cio, tk->urn[urn_num].name[1], 4);
+  cio_write(cio, tk->urn[urn_num].name[2], 4);
+  cio_write(cio, tk->urn[urn_num].name[3], 4);
+  cio_write(cio, tk->urn[urn_num].location[0], 4);
+  cio_write(cio, tk->urn[urn_num].location[1], 4);
+  cio_write(cio, tk->urn[urn_num].location[2], 4);
+  cio_write(cio, tk->urn[urn_num].location[3], 4);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the URN box
+*
+* URN box
+*
+*/
+int mj2_read_urn(mj2_tk_t * tk, int urn_num, opj_cio_t *cio)
+{
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_URN != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected URN Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in URN box\n");
+    return 1;
+  }
+	
+  if (1 != cio_read(cio, 3)) {	/* If flags = 1 --> media data in file */
+    tk->urn[urn_num].name[0] = cio_read(cio, 4);
+    tk->urn[urn_num].name[1] = cio_read(cio, 4);
+    tk->urn[urn_num].name[2] = cio_read(cio, 4);
+    tk->urn[urn_num].name[3] = cio_read(cio, 4);
+    tk->urn[urn_num].location[0] = cio_read(cio, 4);
+    tk->urn[urn_num].location[1] = cio_read(cio, 4);
+    tk->urn[urn_num].location[2] = cio_read(cio, 4);
+    tk->urn[urn_num].location[3] = cio_read(cio, 4);
+  }
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with URN Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+
+/*
+* Write the DREF box
+*
+* Data reference box
+*
+*/
+void mj2_write_dref(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_DREF, 4);	/* DREF       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  if (tk->num_url + tk->num_urn == 0) {	/* Media data in same file */
+    cio_write(cio, 1, 4);		/* entry_count = 1 */
+    mj2_write_url(tk, 0, cio);
+  } else {
+    cio_write(cio, tk->num_url + tk->num_urn, 4);	/* entry_count */
+		
+    for (i = 0; i < tk->num_url; i++)
+      mj2_write_url(tk, i + 1, cio);
+		
+    for (i = 0; i < tk->num_urn; i++)
+      mj2_write_urn(tk, i, cio);
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the DREF box
+*
+* Data reference box
+*
+*/
+int mj2_read_dref(mj2_tk_t * tk, opj_cio_t *cio)
+{
+	
+  int i;
+  int entry_count, marker;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_DREF != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected DREF Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in DREF box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in DREF box. Expected flag 0\n");
+    return 1;
+  }
+	
+  entry_count = cio_read(cio, 4);
+  tk->num_url = 0;
+  tk->num_urn = 0;
+	
+  for (i = 0; i < entry_count; i++) {
+    cio_skip(cio,4);
+    marker = cio_read(cio, 4);
+    if (marker == MJ2_URL) {
+      cio_skip(cio,-8);
+      tk->num_url++;
+      if (mj2_read_url(tk, tk->num_url, cio))
+				return 1;
+    } else if (marker == MJ2_URN) {
+      cio_skip(cio,-8);
+      tk->num_urn++;
+      if (mj2_read_urn(tk, tk->num_urn, cio))
+				return 1;
+    } else {
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Error with in DREF box. Expected URN or URL box\n");
+      return 1;
+    }
+		
+  }
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with DREF Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the DINF box
+*
+* Data information box
+*
+*/
+void mj2_write_dinf(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_DINF, 4);	/* DINF       */
+	
+  mj2_write_dref(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the DINF box
+*
+* Data information box
+*
+*/
+int mj2_read_dinf(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_DINF != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected DINF Marker\n");
+    return 1;
+  }
+	
+  if (mj2_read_dref(tk, cio))
+    return 1;
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with DINF Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the VMHD box
+*
+* Video Media information box
+*
+*/
+void mj2_write_vmhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_VMHD, 4);	/* VMHD       */
+	
+  cio_write(cio, 1, 4);		/* Version = 0, flags = 1 */
+	
+  cio_write(cio, tk->graphicsmode, 2);
+  cio_write(cio, tk->opcolor[0], 2);
+  cio_write(cio, tk->opcolor[1], 2);
+  cio_write(cio, tk->opcolor[2], 2);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the VMHD box
+*
+* Video Media information box
+*
+*/
+int mj2_read_vmhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_VMHD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected VMHD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in VMHD box\n");
+    return 1;
+  }
+	
+  if (1 != cio_read(cio, 3)) {	/* Flags = 1  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in VMHD box. Expected flag 1\n");
+    return 1;
+  }
+	
+  tk->track_type = 0;
+  tk->graphicsmode = cio_read(cio, 2);
+  tk->opcolor[0] = cio_read(cio, 2);
+  tk->opcolor[1] = cio_read(cio, 2);
+  tk->opcolor[2] = cio_read(cio, 2);
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with VMHD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the SMHD box
+*
+* Sound Media information box
+*
+*/
+void mj2_write_smhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_SMHD, 4);	/* SMHD       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->balance, 2);
+	
+  cio_write(cio, 0, 2);		/* Reserved */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the SMHD box
+*
+* Sound Media information box
+*
+*/
+int mj2_read_smhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_SMHD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected SMHD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in SMHD box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in SMHD box. Expected flag 0\n");
+    return 1;
+  }
+	
+  tk->track_type = 1;
+  tk->balance = cio_read(cio, 2);
+	
+  /* Init variables to zero to avoid problems when freeeing memory
+  The values will possibly be overidded when decoding the track structure */
+  tk->num_br = 0;
+  tk->num_url = 0;
+  tk->num_urn = 0;
+  tk->num_chunks = 0;
+  tk->num_tts = 0;
+  tk->num_samplestochunk = 0;
+  tk->num_samples = 0;
+	
+  cio_skip(cio,2);			/* Reserved */
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with SMHD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the HMHD box
+*
+* Hint Media information box
+*
+*/
+void mj2_write_hmhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_HMHD, 4);	/* HMHD       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->maxPDUsize, 2);
+  cio_write(cio, tk->avgPDUsize, 2);
+  cio_write(cio, tk->maxbitrate, 4);
+  cio_write(cio, tk->avgbitrate, 4);
+  cio_write(cio, tk->slidingavgbitrate, 4);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the HMHD box
+*
+* Hint Media information box
+*
+*/
+int mj2_read_hmhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_HMHD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected HMHD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in HMHD box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in HMHD box. Expected flag 0\n");
+    return 1;
+  }
+	
+  tk->track_type = 2;
+  tk->maxPDUsize = cio_read(cio, 2);
+  tk->avgPDUsize = cio_read(cio, 2);
+  tk->maxbitrate = cio_read(cio, 4);
+  tk->avgbitrate = cio_read(cio, 4);
+  tk->slidingavgbitrate = cio_read(cio, 4);
+	
+  /* Init variables to zero to avoid problems when freeeing memory
+  The values will possibly be overidded when decoding the track structure */
+  tk->num_br = 0;
+  tk->num_url = 0;
+  tk->num_urn = 0;
+  tk->num_chunks = 0;
+  tk->num_tts = 0;
+  tk->num_samplestochunk = 0;
+  tk->num_samples = 0;
+	
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with HMHD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the MINF box
+*
+* Media information box
+*
+*/
+void mj2_write_minf(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MINF, 4);	/* MINF       */
+	
+  if (tk->track_type == 0) {
+    mj2_write_vmhd(tk, cio);
+  } else if (tk->track_type == 1) {
+    mj2_write_smhd(tk, cio);
+  } else if (tk->track_type == 2) {
+    mj2_write_hmhd(tk, cio);
+  }
+	
+  mj2_write_dinf(tk, cio);
+  mj2_write_stbl(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the MINF box
+*
+* Media information box
+*
+*/
+int mj2_read_minf(mj2_tk_t * tk, opj_image_t * img, opj_cio_t *cio)
+{
+	
+  unsigned int box_type;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_MINF != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected MINF Marker\n");
+    return 1;
+  }
+	
+  cio_skip(cio,4);
+  box_type = cio_read(cio, 4);
+  cio_skip(cio,-8);
+	
+  if (box_type == MJ2_VMHD) {
+    if (mj2_read_vmhd(tk, cio))
+      return 1;
+  } else if (box_type == MJ2_SMHD) {
+    if (mj2_read_smhd(tk, cio))
+      return 1;
+  } else if (box_type == MJ2_HMHD) {
+    if (mj2_read_hmhd(tk, cio))
+      return 1;
+  } else {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error in MINF box expected vmhd, smhd or hmhd\n");
+    return 1;
+  }
+	
+  if (mj2_read_dinf(tk, cio))
+    return 1;
+	
+  if (mj2_read_stbl(tk, img, cio))
+    return 1;
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MINF Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the HDLR box
+*
+* Handler reference box
+*
+*/
+void mj2_write_hdlr(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_HDLR, 4);	/* HDLR       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, 0, 4);		/* Predefine */
+	
+  tk->name = 0;			/* The track name is immediately determined by the track type */
+	
+  if (tk->track_type == 0) {
+    tk->handler_type = 0x76696465;	/* Handler type: vide */
+    cio_write(cio, tk->handler_type, 4);
+		
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);		/* Reserved */
+		
+    cio_write(cio, 0x76696465, 4);
+    cio_write(cio, 0x6F206d65, 4);
+    cio_write(cio, 0x64696120, 4);
+    cio_write(cio, 0x74726163, 4);
+    cio_write(cio, 0x6b00, 2);	/* String: video media track */
+  } else if (tk->track_type == 1) {
+    tk->handler_type = 0x736F756E;	/* Handler type: soun */
+    cio_write(cio, tk->handler_type, 4);
+		
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);		/* Reserved */
+		
+    cio_write(cio, 0x536F756E, 4);
+    cio_write(cio, 0x6400, 2);	/* String: Sound */
+  } else if (tk->track_type == 2) {
+    tk->handler_type = 0x68696E74;	/* Handler type: hint */
+    cio_write(cio, tk->handler_type, 4);
+		
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);
+    cio_write(cio, 0, 4);		/* Reserved */
+		
+    cio_write(cio, 0x48696E74, 4);
+    cio_write(cio, 0, 2);		/* String: Hint */
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the HDLR box
+*
+* Handler reference box
+*
+*/
+int mj2_read_hdlr(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_HDLR != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected HDLR Marker\n");
+    return 1;
+  }
+	
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in HDLR box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0  */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in HDLR box. Expected flag 0\n");
+    return 1;
+  }
+	
+  cio_skip(cio,4);			/* Reserved */
+	
+  tk->handler_type = cio_read(cio, 4);
+  cio_skip(cio,12);			/* Reserved */
+	
+  tk->name_size = box.length - 32;
+
+  tk->name = (char*) opj_malloc(tk->name_size * sizeof(char));
+  for (i = 0; i < tk->name_size; i++) {
+    tk->name[i] = cio_read(cio, 1);	/* Name */
+  }
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with HDLR Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the MDHD box
+*
+* Media Header Box
+*
+*/
+void mj2_write_mdhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+  unsigned int i;
+  time_t ltime;
+  unsigned int modification_time;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MDHD, 4);	/* MDHD       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  cio_write(cio, tk->creation_time, 4);	/* Creation Time */
+	
+  time(&ltime);			/* Time since 1/1/70 */
+  modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+	
+  cio_write(cio, modification_time, 4);	/* Modification Time */
+	
+  cio_write(cio, tk->timescale, 4);	/* Timescale */
+	
+  tk->duration = 0;
+	
+  for (i = 0; i < tk->num_samples; i++)
+    tk->duration += tk->sample[i].sample_delta;
+	
+  cio_write(cio, tk->duration, 4);	/* Duration */
+	
+  cio_write(cio, tk->language, 2);	/* Language */
+	
+  cio_write(cio, 0, 2);		/* Predefined */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the MDHD box
+*
+* Media Header Box
+*
+*/
+int mj2_read_mdhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (!(MJ2_MHDR == box.type || MJ2_MDHD == box.type)) {	// Kakadu writes MHDR instead of MDHD
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected MDHD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in MDHD box\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 3)) {	/* Flags = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with flag in MDHD box. Expected flag 0\n");
+    return 1;
+  }
+	
+	
+  tk->creation_time = cio_read(cio, 4);	/* Creation Time */
+	
+  tk->modification_time = cio_read(cio, 4);	/* Modification Time */
+	
+  tk->timescale = cio_read(cio, 4);	/* Timescale */
+	
+  tk->duration = cio_read(cio, 4);	/* Duration */
+	
+  tk->language = cio_read(cio, 2);	/* Language */
+	
+  cio_skip(cio,2);			/* Predefined */
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MDHD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the MDIA box
+*
+* Media box
+*
+*/
+void mj2_write_mdia(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MDIA, 4);	/* MDIA       */
+	
+  mj2_write_mdhd(tk, cio);
+  mj2_write_hdlr(tk, cio);
+  mj2_write_minf(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the MDIA box
+*
+* Media box
+*
+*/
+int mj2_read_mdia(mj2_tk_t * tk, opj_image_t * img, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_MDIA != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected MDIA Marker\n");
+    return 1;
+  }
+	
+  if (mj2_read_mdhd(tk, cio))
+    return 1;
+  if (mj2_read_hdlr(tk, cio))
+    return 1;
+  if (mj2_read_minf(tk, img, cio))
+    return 1;
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MDIA Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the TKHD box
+*
+* Track Header box
+*
+*/
+void mj2_write_tkhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+  unsigned int i;
+  time_t ltime;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+	
+  cio_write(cio, MJ2_TKHD, 4);	/* TKHD       */
+	
+  cio_write(cio, 3, 4);		/* Version=0, flags=3 */
+	
+  time(&ltime);			/* Time since 1/1/70 */
+  tk->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+	
+  cio_write(cio, tk->creation_time, 4);	/* Creation Time */
+	
+  cio_write(cio, tk->modification_time, 4);	/* Modification Time */
+	
+  cio_write(cio, tk->track_ID, 4);	/* Track ID */
+	
+  cio_write(cio, 0, 4);		/* Reserved */
+	
+  tk->duration = 0;
+	
+  for (i = 0; i < tk->num_samples; i++)
+    tk->duration += tk->sample[i].sample_delta;
+	
+  cio_write(cio, tk->duration, 4);	/* Duration */
+	
+  cio_write(cio, 0, 4);		/* Reserved */
+  cio_write(cio, 0, 4);		/* Reserved */
+	
+  cio_write(cio, tk->layer, 2);	/* Layer    */
+	
+  cio_write(cio, 0, 2);		/* Predefined */
+	
+  cio_write(cio, tk->volume, 2);	/* Volume       */
+	
+  cio_write(cio, 0, 2);		/* Reserved */
+	
+  cio_write(cio, tk->trans_matrix[0], 4);	/* Transformation matrix for track */
+  cio_write(cio, tk->trans_matrix[1], 4);
+  cio_write(cio, tk->trans_matrix[2], 4);
+  cio_write(cio, tk->trans_matrix[3], 4);
+  cio_write(cio, tk->trans_matrix[4], 4);
+  cio_write(cio, tk->trans_matrix[5], 4);
+  cio_write(cio, tk->trans_matrix[6], 4);
+  cio_write(cio, tk->trans_matrix[7], 4);
+  cio_write(cio, tk->trans_matrix[8], 4);
+	
+  cio_write(cio, tk->visual_w, 4);	/* Video Visual Width  */
+	
+  cio_write(cio, tk->visual_h, 4);	/* Video Visual Height */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the TKHD box
+*
+* Track Header box
+*
+*/
+int mj2_read_tkhd(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  int flag;
+	
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+	
+  if (MJ2_TKHD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected TKHD Marker\n");
+    return 1;
+  }
+	
+  if (0 != cio_read(cio, 1)) {	/* Version = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in TKHD box\n");
+    return 1;
+  }
+	
+  flag = cio_read(cio, 3);
+	
+  if (!(flag == 1 || flag == 2 || flag == 3 || flag == 4)) {	/* Flags = 1,2,3 or 4 */
+    opj_event_msg(cio->cinfo, EVT_ERROR,
+			"Error with flag in TKHD box: Expected flag 1,2,3 or 4\n");
+    return 1;
+  }
+	
+  tk->creation_time = cio_read(cio, 4);	/* Creation Time */
+	
+  tk->modification_time = cio_read(cio, 4);	/* Modification Time */
+	
+  tk->track_ID = cio_read(cio, 4);	/* Track ID */
+	
+  cio_skip(cio,4);			/* Reserved */
+	
+  tk->duration = cio_read(cio, 4);	/* Duration */
+	
+  cio_skip(cio,8);			/* Reserved */
+	
+  tk->layer = cio_read(cio, 2);	/* Layer    */
+	
+  cio_read(cio, 2);			/* Predefined */
+	
+  tk->volume = cio_read(cio, 2);	/* Volume       */
+	
+  cio_skip(cio,2);			/* Reserved */
+	
+  tk->trans_matrix[0] = cio_read(cio, 4);	/* Transformation matrix for track */
+  tk->trans_matrix[1] = cio_read(cio, 4);
+  tk->trans_matrix[2] = cio_read(cio, 4);
+  tk->trans_matrix[3] = cio_read(cio, 4);
+  tk->trans_matrix[4] = cio_read(cio, 4);
+  tk->trans_matrix[5] = cio_read(cio, 4);
+  tk->trans_matrix[6] = cio_read(cio, 4);
+  tk->trans_matrix[7] = cio_read(cio, 4);
+  tk->trans_matrix[8] = cio_read(cio, 4);
+	
+  tk->visual_w = cio_read(cio, 4);	/* Video Visual Width  */
+	
+  tk->visual_h = cio_read(cio, 4);	/* Video Visual Height */
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with TKHD Box size\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the TRAK box
+*
+* Track box
+*
+*/
+void mj2_write_trak(mj2_tk_t * tk, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+	
+  cio_write(cio, MJ2_TRAK, 4);	/* TRAK       */
+	
+  mj2_write_tkhd(tk, cio);
+  mj2_write_mdia(tk, cio);
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the TRAK box
+*
+* Track box
+*
+*/
+int mj2_read_trak(mj2_tk_t * tk, opj_image_t * img, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_TRAK != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected TRAK Marker\n");
+    return 1;
+  }
+  if (mj2_read_tkhd(tk, cio))
+    return 1;
+  if (mj2_read_mdia(tk, img, cio))
+    return 1;
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with TRAK Box\n");
+    return 1;
+  }
+  return 0;
+}
+
+/*
+* Write the MVHD box
+*
+* Movie header Box
+*
+*/
+void mj2_write_mvhd(opj_mj2_t * movie, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+  unsigned j;
+  time_t ltime;
+  int max_tk_num = 0;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MVHD, 4);	/* MVHD       */
+	
+  cio_write(cio, 0, 4);		/* Version = 0, flags = 0 */
+	
+  time(&ltime);			/* Time since 1/1/70 */
+  movie->modification_time = (unsigned int)ltime + 2082844800;	/* Seoonds between 1/1/04 and 1/1/70 */
+	
+  cio_write(cio, movie->creation_time, 4);	/* Creation Time */
+	
+  cio_write(cio, movie->modification_time, 4);	/* Modification Time */
+	
+  cio_write(cio, movie->timescale, 4);	/* Timescale */
+	
+  movie->duration = 0;
+	
+  for (i = 0; i < (movie->num_stk + movie->num_htk + movie->num_vtk); i++) {
+    mj2_tk_t *tk = &movie->tk[i];
+		
+    for (j = 0; j < tk->num_samples; j++) {
+      movie->duration += tk->sample[j].sample_delta;
+    }
+  }
+	
+  cio_write(cio, movie->duration, 4);
+	
+  cio_write(cio, movie->rate, 4);	/* Rate to play presentation    */
+	
+  cio_write(cio, movie->volume, 2);	/* Volume       */
+	
+  cio_write(cio, 0, 2);		/* Reserved */
+  cio_write(cio, 0, 4);		/* Reserved */
+  cio_write(cio, 0, 4);		/* Reserved */
+	
+  cio_write(cio, movie->trans_matrix[0], 4);	/* Transformation matrix for video */
+  cio_write(cio, movie->trans_matrix[1], 4);
+  cio_write(cio, movie->trans_matrix[2], 4);
+  cio_write(cio, movie->trans_matrix[3], 4);
+  cio_write(cio, movie->trans_matrix[4], 4);
+  cio_write(cio, movie->trans_matrix[5], 4);
+  cio_write(cio, movie->trans_matrix[6], 4);
+  cio_write(cio, movie->trans_matrix[7], 4);
+  cio_write(cio, movie->trans_matrix[8], 4);
+	
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+  cio_write(cio, 0, 4);		/* Pre-defined */
+	
+	
+  for (i = 0; i < movie->num_htk + movie->num_stk + movie->num_vtk; i++) {
+    if (max_tk_num < movie->tk[i].track_ID)
+      max_tk_num = movie->tk[i].track_ID;
+  }
+	
+  movie->next_tk_id = max_tk_num + 1;
+	
+  cio_write(cio, movie->next_tk_id, 4);	/* ID of Next track to be added */
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);
+}
+
+/*
+* Read the MVHD box
+*
+* Movie header Box
+*
+*/
+int mj2_read_mvhd(opj_mj2_t * movie, opj_cio_t *cio)
+{
+  mj2_box_t box;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_MVHD != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected MVHD Marker\n");
+    return 1;
+  }
+	
+	
+  if (0 != cio_read(cio, 4)) {	/* Version = 0, flags = 0 */
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Only Version 0 handled in MVHD box\n");
+  }
+	
+  movie->creation_time = cio_read(cio, 4);	/* Creation Time */
+	
+  movie->modification_time = cio_read(cio, 4);	/* Modification Time */
+	
+  movie->timescale = cio_read(cio, 4);	/* Timescale */
+	
+  movie->duration = cio_read(cio, 4);	/* Duration */
+	
+  movie->rate = cio_read(cio, 4);		/* Rate to play presentation    */
+	
+  movie->volume = cio_read(cio, 2);		/* Volume       */
+	
+  cio_skip(cio,10);				/* Reserved */
+	
+  movie->trans_matrix[0] = cio_read(cio, 4);	/* Transformation matrix for video */
+  movie->trans_matrix[1] = cio_read(cio, 4);
+  movie->trans_matrix[2] = cio_read(cio, 4);
+  movie->trans_matrix[3] = cio_read(cio, 4);
+  movie->trans_matrix[4] = cio_read(cio, 4);
+  movie->trans_matrix[5] = cio_read(cio, 4);
+  movie->trans_matrix[6] = cio_read(cio, 4);
+  movie->trans_matrix[7] = cio_read(cio, 4);
+  movie->trans_matrix[8] = cio_read(cio, 4);
+	
+  cio_skip(cio,24);			/* Pre-defined */
+	
+  movie->next_tk_id = cio_read(cio, 4);	/* ID of Next track to be added */
+	
+  if (cio_tell(cio) - box.init_pos != box.length) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MVHD Box Size\n");
+    return 1;
+  }
+  return 0;
+}
+
+
+/*
+* Write the MOOV box
+*
+* Movie Box
+*
+*/
+void mj2_write_moov(opj_mj2_t * movie, opj_cio_t *cio)
+{
+  int i;
+  mj2_box_t box;
+	
+  box.init_pos = cio_tell(cio);
+  cio_skip(cio,4);
+  cio_write(cio, MJ2_MOOV, 4);	/* MOOV       */
+	
+  mj2_write_mvhd(movie, cio);
+	
+  for (i = 0; i < (movie->num_stk + movie->num_htk + movie->num_vtk); i++) {
+    mj2_write_trak(&movie->tk[i], cio);
+  }
+	
+  box.length = cio_tell(cio) - box.init_pos;
+  cio_seek(cio, box.init_pos);
+  cio_write(cio, box.length, 4);	/* L          */
+  cio_seek(cio, box.init_pos + box.length);	
+}
+
+/*
+* Read the MOOV box
+*
+* Movie Box
+*
+*/
+int mj2_read_moov(opj_mj2_t * movie, opj_image_t * img, opj_cio_t *cio)
+{
+  unsigned int i;
+  mj2_box_t box;
+  mj2_box_t box2;
+	
+  mj2_read_boxhdr(&box, cio);
+  if (MJ2_MOOV != box.type) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "Error: Expected MOOV Marker\n");
+    return 1;
+  }
+	
+  if (mj2_read_mvhd(movie, cio))
+    return 1;
+
+  movie->tk = (mj2_tk_t*) opj_malloc((movie->next_tk_id - 1) * sizeof(mj2_tk_t));
+
+  for (i = 0; cio_tell(cio) - box.init_pos < box.length; i++) {
+		mj2_tk_t *tk = &movie->tk[i];
+		tk->cinfo = movie->cinfo;
+    mj2_read_boxhdr(&box2, cio);
+    if (box2.type == MJ2_TRAK) {
+      cio_seek(cio, box2.init_pos);
+      if (mj2_read_trak(tk, img, cio))
+				return 1;
+			
+      if (tk->track_type == 0) {
+				movie->num_vtk++;
+      } else if (tk->track_type == 1) {
+				movie->num_stk++;
+      } else if (tk->track_type == 2) {
+				movie->num_htk++;
+      }
+    } else if (box2.type == MJ2_MVEX) {
+      cio_seek(cio, box2.init_pos);
+      cio_skip(cio,box2.length);
+      i--;
+    } else {
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Error with MOOV Box: Expected TRAK or MVEX box\n");
+      return 1;
+    }
+  }
+  return 0;
+}
+
+int mj2_read_struct(FILE *file, opj_mj2_t *movie) {
+  mj2_box_t box;
+  opj_image_t img;
+  char * src;
+  int fsresult;
+  int foffset;
+	opj_cio_t *cio;
+	
+	/* open a byte stream for reading */	
+	src = (char*) opj_malloc(300 * sizeof(char));	
+
+	/* Assuming that jp and ftyp markers size do
+     not exceed 300 bytes */
+  fread(src,300,1, file);  
+  
+  cio = opj_cio_open((opj_common_ptr)movie->cinfo, src, 300);
+  
+  if (mj2_read_jp(cio))
+    return 1;
+  if (mj2_read_ftyp(movie, cio))
+    return 1;
+	
+  fsresult = fseek(file,cio_tell(cio),SEEK_SET);
+  if( fsresult ) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read data after FTYP box\n" );
+    return 1;
+  }
+	
+  foffset = cio_tell(cio);
+  
+  box.type = 0;
+  
+  fread(src,30,1,file);
+  cio = opj_cio_open((opj_common_ptr)movie->cinfo, src, 300);
+  mj2_read_boxhdr(&box, cio);
+  
+  while(box.type != MJ2_MOOV) {
+    
+    switch(box.type)
+    {
+    case MJ2_MDAT:
+      fsresult = fseek(file,foffset+box.length,SEEK_SET);
+      if( fsresult ) {
+				opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MDAT box\n" );
+				return 1;
+      }
+      foffset += box.length;
+      break;
+      
+    case MJ2_MOOF:
+      fsresult = fseek(file,foffset+box.length,SEEK_SET);
+      if( fsresult ) {
+				opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MOOF box\n" );
+				return 1;
+      }
+      foffset += box.length;
+      break;      
+    case MJ2_FREE:
+      fsresult = fseek(file,foffset+box.length,SEEK_SET);
+      if( fsresult ) {
+				opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read FREE box\n" );
+				return 1;
+      }
+      foffset += box.length;
+      break;      
+    case MJ2_SKIP:
+      fsresult = fseek(file,foffset+box.length,SEEK_SET);
+      if( fsresult ) {
+				opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read SKIP box\n" );
+				return 1;
+      }
+      foffset += box.length;
+      break;      
+    default:
+      opj_event_msg(cio->cinfo, EVT_ERROR, "Unknown box in MJ2 stream\n");
+      fsresult = fseek(file,foffset+box.length,SEEK_SET);
+      if( fsresult ) {
+				opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read end of unknown box\n"); 
+				return 1;
+      }      
+      foffset += box.length;
+      break;
+    }
+    fsresult = fread(src,8,1,file);
+    if (fsresult != 1) {
+      opj_event_msg(cio->cinfo, EVT_ERROR, "MOOV box not found in file\n"); 
+      return 1;
+    }
+		cio = opj_cio_open((opj_common_ptr)movie->cinfo, src, 8);    		
+    mj2_read_boxhdr(&box, cio);
+  }	
+
+  fseek(file,foffset,SEEK_SET);
+  src = opj_realloc(src,box.length);
+  fsresult = fread(src,box.length,1,file);
+  if (fsresult != 1) {
+    opj_event_msg(cio->cinfo, EVT_ERROR, "End of file reached while trying to read MOOV box\n"); 
+    return 1;
+  }
+	
+	cio = opj_cio_open((opj_common_ptr)movie->cinfo, src, box.length);
+  
+  if (mj2_read_moov(movie, &img, cio))
+    return 1;
+
+  opj_free(src);
+  return 0;
+}
+
+/* ----------------------------------------------------------------------- */
+/* MJ2 decoder interface															                     */
+/* ----------------------------------------------------------------------- */
+
+opj_dinfo_t* mj2_create_decompress() {
+	opj_mj2_t* mj2;
+	opj_dinfo_t *dinfo = (opj_dinfo_t*) opj_calloc(1, sizeof(opj_dinfo_t));
+	if(!dinfo) return NULL;
+
+	dinfo->is_decompressor = true;	
+
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
+	dinfo->mj2_handle = mj2;
+	if(mj2) {
+		mj2->cinfo = (opj_common_ptr)dinfo;
+	}
+	mj2->j2k = j2k_create_decompress((opj_common_ptr)dinfo);
+	dinfo->j2k_handle = mj2->j2k;
+
+	return dinfo;
+}
+
+void mj2_setup_decoder(opj_mj2_t *movie, mj2_dparameters_t *mj2_parameters) {
+	movie->num_vtk=0;
+  movie->num_stk=0;
+  movie->num_htk=0;	
+
+	/* setup the J2K decoder parameters */
+	j2k_setup_decoder(movie->cinfo->j2k_handle, &mj2_parameters->j2k_parameters);
+
+}
+
+void mj2_destroy_decompress(opj_mj2_t *movie) {
+	if(movie) {
+		int i;
+		mj2_tk_t *tk=NULL;
+
+		if (movie->cinfo->j2k_handle) 
+			j2k_destroy_compress(movie->j2k);
+		
+		if (movie->num_cl != 0)
+			opj_free(movie->cl);
+		
+		for (i = 0; i < movie->num_vtk + movie->num_stk + movie->num_htk; i++) {
+			tk = &movie->tk[i];
+			if (tk->name_size != 0)
+				opj_free(tk->name);
+			if (tk->track_type == 0)  {// Video track
+				if (tk->jp2_struct.comps != 0)
+					opj_free(tk->jp2_struct.comps);
+				if (tk->jp2_struct.cl != 0)
+					opj_free(tk->jp2_struct.cl);
+				if (tk->num_jp2x != 0)
+					opj_free(tk->jp2xdata);
+				
+			}
+			if (tk->num_url != 0)
+				opj_free(tk->url);
+			if (tk->num_urn != 0)
+				opj_free(tk->urn);
+			if (tk->num_br != 0)
+				opj_free(tk->br);
+			if (tk->num_tts != 0)
+				opj_free(tk->tts);
+			if (tk->num_chunks != 0)
+				opj_free(tk->chunk);
+			if (tk->num_samplestochunk != 0)
+				opj_free(tk->sampletochunk);
+			if (tk->num_samples != 0)
+				opj_free(tk->sample);
+		}
+		
+		opj_free(movie->tk);
+	}	
+	opj_free(movie);
+}
+
+/* ----------------------------------------------------------------------- */
+/* MJ2 encoder interface															                     */
+/* ----------------------------------------------------------------------- */
+
+
+opj_cinfo_t* mj2_create_compress() {
+	opj_mj2_t* mj2;
+	opj_cinfo_t *cinfo = (opj_cinfo_t*) opj_calloc(1, sizeof(opj_cinfo_t));
+	if(!cinfo) return NULL;
+
+	mj2 = (opj_mj2_t*) opj_calloc(1, sizeof(opj_mj2_t));
+	cinfo->mj2_handle = mj2;
+	if(mj2) {
+		mj2->cinfo = (opj_common_ptr)cinfo;
+	}
+
+	mj2->j2k = j2k_create_compress(mj2->cinfo);
+	cinfo->j2k_handle = mj2->j2k;
+
+	return cinfo;
+}
+
+void mj2_setup_encoder(opj_mj2_t *movie, mj2_cparameters_t *parameters) {
+	if(movie && parameters) {
+		opj_jp2_t *jp2_struct;
+			
+		movie->num_htk = 0;	  // No hint tracks
+		movie->num_stk = 0;	  // No sound tracks
+		movie->num_vtk = 1;	  // One video track  
+
+		movie->brand = MJ2_MJ2;  // One brand: MJ2
+		movie->num_cl = 2;	  // Two compatible brands: MJ2 and MJ2S
+		movie->cl = (unsigned int*) opj_malloc(movie->num_cl * sizeof(unsigned int));
+		movie->cl[0] = MJ2_MJ2;
+		movie->cl[1] = MJ2_MJ2S;
+		movie->minversion = 0;	  // Minimum version: 0		
+
+		movie->tk = (mj2_tk_t*) opj_malloc(sizeof(mj2_tk_t)); //Memory allocation for the video track
+		movie->tk[0].track_ID = 1;	  // Track ID = 1 
+		movie->tk[0].track_type = 0;	  // Video track
+		movie->tk[0].Dim[0] = parameters->Dim[0];
+		movie->tk[0].Dim[1] = parameters->Dim[1];
+		movie->tk[0].w = parameters->w;
+		movie->tk[0].h = parameters->h;
+		movie->tk[0].CbCr_subsampling_dx = parameters->CbCr_subsampling_dx;
+		movie->tk[0].CbCr_subsampling_dy = parameters->CbCr_subsampling_dy;
+		movie->tk[0].sample_rate = parameters->frame_rate;
+		movie->tk[0].name_size = 0;
+		movie->tk[0].chunk = (mj2_chunk_t*) opj_malloc(sizeof(mj2_chunk_t));  
+		movie->tk[0].sample = (mj2_sample_t*) opj_malloc(sizeof(mj2_sample_t));
+
+		jp2_struct = &movie->tk[0].jp2_struct;
+		jp2_struct->numcomps = 3;	// NC  		
+		jp2_struct->comps = (opj_jp2_comps_t*) opj_malloc(jp2_struct->numcomps * sizeof(opj_jp2_comps_t));
+		jp2_struct->precedence = 0;   /* PRECEDENCE*/
+		jp2_struct->approx = 0;   /* APPROX*/		
+		jp2_struct->brand = JP2_JP2;	/* BR         */
+		jp2_struct->minversion = 0;	/* MinV       */
+		jp2_struct->numcl = 1;
+		jp2_struct->cl = (unsigned int*) opj_malloc(jp2_struct->numcl * sizeof(int));
+		jp2_struct->cl[0] = JP2_JP2;	/* CL0 : JP2  */		
+		jp2_struct->C = 7;      /* C : Always 7*/
+		jp2_struct->UnkC = 0;      /* UnkC, colorspace specified in colr box*/
+		jp2_struct->IPR = 0;      /* IPR, no intellectual property*/						
+		jp2_struct->w = parameters->w;
+		jp2_struct->h = parameters->h;
+		jp2_struct->bpc = 7;  
+		jp2_struct->meth = 1;
+		jp2_struct->enumcs = 18;  // YUV
+  }
+}
+
+void mj2_destroy_compress(opj_mj2_t *movie) {
+	if(movie) {
+		int i;
+		mj2_tk_t *tk=NULL;
+
+		if (movie->cinfo->j2k_handle) {
+			j2k_destroy_compress(movie->j2k);
+		}
+		
+		if (movie->num_cl != 0)
+			opj_free(movie->cl);
+		
+		for (i = 0; i < movie->num_vtk + movie->num_stk + movie->num_htk; i++) {
+			tk = &movie->tk[i];
+			if (tk->name_size != 0)
+				opj_free(tk->name);
+			if (tk->track_type == 0)  {// Video track
+				if (tk->jp2_struct.comps != 0)
+					opj_free(tk->jp2_struct.comps);
+				if (tk->jp2_struct.cl != 0)
+					opj_free(tk->jp2_struct.cl);
+				if (tk->num_jp2x != 0)
+					opj_free(tk->jp2xdata);
+				
+			}
+			if (tk->num_url != 0)
+				opj_free(tk->url);
+			if (tk->num_urn != 0)
+				opj_free(tk->urn);
+			if (tk->num_br != 0)
+				opj_free(tk->br);
+			if (tk->num_tts != 0)
+				opj_free(tk->tts);
+			if (tk->num_chunks != 0)
+				opj_free(tk->chunk);
+			if (tk->num_samplestochunk != 0)
+				opj_free(tk->sampletochunk);
+			if (tk->num_samples != 0)
+				opj_free(tk->sample);
+		}
+		
+		opj_free(movie->tk);
+	}	
+	opj_free(movie);
+}
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.dsp.svn-base ./mj2/.svn/text-base/MJ2_Extractor.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Extractor.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,196 @@
+# Microsoft Developer Studio Project File - Name="MJ2_Extractor" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=MJ2_Extractor - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "MJ2_Extractor.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "MJ2_Extractor.mak" CFG="MJ2_Extractor - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "MJ2_Extractor - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "MJ2_Extractor - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "MJ2_Extractor - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /YX /FD /c
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmt"
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "MJ2_Extractor - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "MJ2_Extractor___Win32_Debug"
+# PROP BASE Intermediate_Dir "MJ2_Extractor___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "MJ2_Extractor___Win32_Debug"
+# PROP Intermediate_Dir "MJ2_Extractor___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MT /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmt" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "MJ2_Extractor - Win32 Release"
+# Name "MJ2_Extractor - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\extract_j2k_from_mj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\mj2.h
+# End Source File
+# End Group
+# Begin Group "OpenJPEG Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.dsw.svn-base ./mj2/.svn/text-base/MJ2_Extractor.dsw.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Extractor.dsw.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"="..\LibOpenJPEG.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "MJ2_Extractor"=".\MJ2_Extractor.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.sln.svn-base ./mj2/.svn/text-base/MJ2_Extractor.sln.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Extractor.sln.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Extractor", "MJ2_Extractor.vcproj", "{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Debug|Win32.Build.0 = Debug|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.ActiveCfg = Release|Win32
+		{BCBEB12A-B691-4B14-9DC5-193BCD01183D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.vcproj.svn-base ./mj2/.svn/text-base/MJ2_Extractor.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Extractor.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Extractor.vcproj.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,354 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Extractor"
+	ProjectGUID="{BCBEB12A-B691-4B14-9DC5-193BCD01183D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib ../libs/libtiff/libtiff.lib"
+				OutputFile=".\Release/MJ2_Extractor.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libc"
+				ProgramDatabaseFile=".\Release/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Extractor___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Extractor___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pch"
+				AssemblerListingLocation=".\MJ2_Extractor___Win32_Debug/"
+				ObjectFile=".\MJ2_Extractor___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Extractor___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmt"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Extractor___Win32_Debug/MJ2_Extractor.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="extract_j2k_from_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2.h.svn-base ./mj2/.svn/text-base/mj2.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,391 @@
+/*
+* Copyright (c) 2003-2004, François-Olivier Devaux
+* Copyright (c) 2003-2004,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+* All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#ifndef __MJ2_H
+#define __MJ2_H
+/**
+@file mj2.h
+@brief The Motion JPEG 2000 file format Reader/Writer (MJ22)
+
+*/
+
+/** @defgroup MJ2 MJ2 - Motion JPEG 2000 file format reader/writer */
+/*@{*/
+
+#define MJ2_JP    0x6a502020
+#define MJ2_FTYP  0x66747970
+#define MJ2_MJ2   0x6d6a7032
+#define MJ2_MJ2S  0x6d6a3273
+#define MJ2_MDAT  0x6d646174
+#define MJ2_MOOV  0x6d6f6f76
+#define MJ2_MVHD  0x6d766864
+#define MJ2_TRAK  0x7472616b
+#define MJ2_TKHD  0x746b6864
+#define MJ2_MDIA  0x6d646961
+#define MJ2_MDHD  0x6d646864
+#define MJ2_MHDR  0x6d686472
+#define MJ2_HDLR  0x68646C72
+#define MJ2_MINF  0x6d696e66
+#define MJ2_VMHD  0x766d6864
+#define MJ2_SMHD  0x736d6864
+#define MJ2_HMHD  0x686d6864
+#define MJ2_DINF  0x64696e66
+#define MJ2_DREF  0x64726566
+#define MJ2_URL   0x75726c20
+#define MJ2_URN   0x75726e20
+#define MJ2_STBL  0x7374626c
+#define MJ2_STSD  0x73747364
+#define MJ2_STTS  0x73747473
+#define MJ2_STSC  0x73747363
+#define MJ2_STSZ  0x7374737a
+#define MJ2_STCO  0x7374636f
+#define MJ2_MOOF  0x6d6f6f66
+#define MJ2_FREE  0x66726565
+#define MJ2_SKIP  0x736b6970
+#define MJ2_JP2C  0x6a703263
+#define MJ2_FIEL  0x6669656c
+#define MJ2_JP2P  0x6a703270
+#define MJ2_JP2X  0x6a703278
+#define MJ2_JSUB  0x6a737562
+#define MJ2_ORFO  0x6f72666f
+#define MJ2_MVEX  0x6d766578
+#define MJ2_JP2   0x6a703220
+#define MJ2_J2P0  0x4a325030
+
+/**
+Decompressed format used in parameters
+YUV = 0
+*/
+#define YUV_DFMT 1 
+
+/**
+Compressed format used in parameters
+MJ2 = 0
+*/
+#define MJ2_CFMT 2
+
+
+/* ----------------------------------------------------------------------- */
+
+/**
+Time To Sample
+*/
+typedef struct mj2_tts {
+  int sample_count;
+  int sample_delta;
+} mj2_tts_t;
+
+/**
+Chunk
+*/
+typedef struct mj2_chunk {		
+  int num_samples;
+  int sample_descr_idx;
+  int offset;
+} mj2_chunk_t;
+
+/**
+Sample to chunk
+*/
+typedef struct mj2_sampletochunk {		
+  int first_chunk;
+  int samples_per_chunk;
+  int sample_descr_idx;
+} mj2_sampletochunk_t;
+
+/**
+Sample
+*/
+typedef struct mj2_sample {		
+  unsigned int sample_size;
+  unsigned int offset;
+  unsigned int sample_delta;
+} mj2_sample_t;
+
+/**
+URL
+*/
+typedef struct mj2_url {
+  int location[4];
+} mj2_url_t;
+
+/**
+URN
+*/
+typedef struct mj2_urn {		
+  int name[2];
+  int location[4];
+} mj2_urn_t;
+
+/**
+Video Track Parameters
+*/
+typedef struct mj2_tk {
+	/** codec context */
+	opj_common_ptr cinfo;
+  int track_ID;
+  int track_type;
+  unsigned int creation_time;
+  unsigned int modification_time;
+  int duration;
+  int timescale;
+  int layer;
+  int volume;
+  int language;
+  int balance;
+  int maxPDUsize;
+  int avgPDUsize;
+  int maxbitrate;
+  int avgbitrate;
+  int slidingavgbitrate;
+  int graphicsmode;
+  int opcolor[3];
+  int num_url;
+  mj2_url_t *url;
+  int num_urn;
+  mj2_urn_t *urn;
+  int Dim[2];
+  int w;
+  int h;
+  int visual_w;
+  int visual_h;
+  int CbCr_subsampling_dx;
+  int CbCr_subsampling_dy;
+  int sample_rate;
+  int sample_description;
+  int horizresolution;
+  int vertresolution;
+  int compressorname[8];
+  int depth;
+  unsigned char fieldcount;
+  unsigned char fieldorder;
+  unsigned char or_fieldcount;
+  unsigned char or_fieldorder;
+  int num_br;
+  unsigned int *br;
+  unsigned char num_jp2x;
+  unsigned char *jp2xdata;
+  unsigned char hsub;
+  unsigned char vsub;
+  unsigned char hoff;
+  unsigned char voff;
+  int trans_matrix[9];
+	/** Number of samples */
+  unsigned int num_samples;	
+  int transorm;
+  int handler_type;
+  int name_size;
+  unsigned char same_sample_size;
+  int num_tts;
+	/** Time to sample    */
+  mj2_tts_t *tts;		
+  unsigned int num_chunks;
+  mj2_chunk_t *chunk;
+  int num_samplestochunk;
+  mj2_sampletochunk_t *sampletochunk;
+  char *name;
+  opj_jp2_t jp2_struct;
+	/** Sample parameters */
+  mj2_sample_t *sample;		
+} mj2_tk_t;			
+
+/**
+MJ2 box
+*/
+typedef struct mj2_box {
+  int length;
+  int type;
+  int init_pos;
+} mj2_box_t;
+
+/**
+MJ2 Movie
+*/
+typedef struct opj_mj2 {		
+	/** codec context */
+	opj_common_ptr cinfo;
+	/** handle to the J2K codec  */
+	opj_j2k_t *j2k;
+  unsigned int brand;
+  unsigned int minversion;
+  int num_cl;
+  unsigned int *cl;
+  unsigned int creation_time;
+  unsigned int modification_time;
+  int timescale;
+  unsigned int duration;
+  int rate;
+  int num_vtk;
+  int num_stk;
+  int num_htk;
+  int volume;
+  int trans_matrix[9];
+  int next_tk_id;
+	/** Track Parameters  */
+  mj2_tk_t *tk;			
+} opj_mj2_t;
+
+/**
+Decompression parameters
+*/
+typedef struct mj2_dparameters {
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+	/** input file name */
+	char infile[OPJ_PATH_LEN];
+	/** output file name */
+	char outfile[OPJ_PATH_LEN];	
+	/** J2K decompression parameters */
+	opj_dparameters_t j2k_parameters;	
+} mj2_dparameters_t;
+
+/**
+Compression parameters
+*/
+typedef struct mj2_cparameters {
+	/**@name command line encoder parameters (not used inside the library) */
+	/*@{*/
+	/** J2K compression parameters */
+	opj_cparameters_t j2k_parameters;	
+	/** input file name */
+	char infile[OPJ_PATH_LEN];
+	/** output file name */
+	char outfile[OPJ_PATH_LEN];	
+	/** input file format 0:MJ2 */
+	int decod_format;
+	/** output file format 0:YUV */
+	int cod_format;
+	/** Portion of the image coded */
+	int Dim[2];
+	/** YUV Frame width */
+	int w;
+	/** YUV Frame height */
+	int h;
+	/*   Sample rate of YUV 4:4:4, 4:2:2 or 4:2:0 */
+	int CbCr_subsampling_dx;	
+	/*   Sample rate of YUV 4:4:4, 4:2:2 or 4:2:0 */
+  int CbCr_subsampling_dy;	
+	/*   Video Frame Rate  */
+  int frame_rate;		
+	/*   In YUV files, numcomps always considered as 3 */
+  int numcomps;			
+	/*   In YUV files, precision always considered as 8 */
+  int prec;		
+} mj2_cparameters_t;
+
+
+/** @name Exported functions */
+/*@{*/
+/* ----------------------------------------------------------------------- */
+/**
+Write the JP box 
+*/
+void mj2_write_jp(opj_cio_t *cio);
+/**
+Write the FTYP box
+@param movie MJ2 movie
+@param cio Output buffer stream
+*/
+void mj2_write_ftyp(opj_mj2_t *movie, opj_cio_t *cio);
+/**
+Creates an MJ2 decompression structure
+@return Returns a handle to a MJ2 decompressor if successful, returns NULL otherwise
+*/
+opj_dinfo_t* mj2_create_decompress();
+/**
+Destroy a MJ2 decompressor handle
+@param movie MJ2 decompressor handle to destroy
+*/
+void mj2_destroy_decompress(opj_mj2_t *movie);
+/**
+Setup the decoder decoding parameters using user parameters.
+Decoding parameters are returned in mj2->j2k->cp. 
+@param movie MJ2 decompressor handle
+@param parameters decompression parameters
+*/
+void mj2_setup_decoder(opj_mj2_t *movie, mj2_dparameters_t *mj2_parameters);
+/**
+Decode an image from a JPEG-2000 file stream
+@param movie MJ2 decompressor handle
+@param cio Input buffer stream
+@return Returns a decoded image if successful, returns NULL otherwise
+*/
+opj_image_t* mj2_decode(opj_mj2_t *movie, opj_cio_t *cio);
+/**
+Creates a MJ2 compression structure
+@return Returns a handle to a MJ2 compressor if successful, returns NULL otherwise
+*/
+opj_cinfo_t* mj2_create_compress();
+/**
+Destroy a MJ2 compressor handle
+@param movie MJ2 compressor handle to destroy
+*/
+void mj2_destroy_compress(opj_mj2_t *movie);
+/**
+Setup the encoder parameters using the current image and using user parameters. 
+Coding parameters are returned in mj2->j2k->cp. 
+@param movie MJ2 compressor handle
+@param parameters compression parameters
+*/
+void mj2_setup_encoder(opj_mj2_t *movie, mj2_cparameters_t *parameters);
+/**
+Encode an image into a JPEG-2000 file stream
+@param movie MJ2 compressor handle
+@param cio Output buffer stream
+@param image Image to encode
+@param index Name of the index file if required, NULL otherwise
+@return Returns true if successful, returns false otherwise
+*/
+bool mj2_encode(opj_mj2_t *movie, opj_cio_t *cio, opj_image_t *image, char *index);
+
+/**
+Init a Standard MJ2 movie
+@param movie MJ2 Movie
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int mj2_init_stdmovie(opj_mj2_t *movie);
+/**
+Read the structure of an MJ2 file
+@param File MJ2 input File
+@param movie J2 movie structure 
+@return Returns 0 if successful, returns 1 otherwise
+*/
+int mj2_read_struct(FILE *file, opj_mj2_t *mj2);
+/**
+Write the the MOOV box to an output buffer stream
+@param movie MJ2 movie structure 
+@param cio Output buffer stream
+*/
+void mj2_write_moov(opj_mj2_t *movie, opj_cio_t *cio);
+
+
+/* ----------------------------------------------------------------------- */
+/*@}*/
+
+/*@}*/
+
+#endif /* __MJ2_H */
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.c.svn-base ./mj2/.svn/text-base/mj2_to_frames.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_frames.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,225 @@
+/*
+* Copyright (c) 2003-2004, François-Olivier Devaux
+* Copyright (c) 2002-2004,  Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium
+* All rights reserved.
+*
+* Redistribution and use in source and binary forms, with or without
+* modification, are permitted provided that the following conditions
+* are met:
+* 1. Redistributions of source code must retain the above copyright
+*    notice, this list of conditions and the following disclaimer.
+* 2. Redistributions in binary form must reproduce the above copyright
+*    notice, this list of conditions and the following disclaimer in the
+*    documentation and/or other materials provided with the distribution.
+*
+* THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+* AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+* ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+* LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+* CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+* SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+* INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+* CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+* ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+* POSSIBILITY OF SUCH DAMAGE.
+*/
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k_lib.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "mj2.h"
+#include "mj2_convert.h"
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+int main(int argc, char *argv[]) {
+	mj2_dparameters_t mj2_parameters;			/* decompression parameters */
+	opj_dinfo_t* dinfo; 
+	opj_event_mgr_t event_mgr;		/* event manager */	
+	opj_cio_t *cio = NULL;
+  unsigned int tnum, snum;
+  opj_mj2_t *movie;
+  mj2_tk_t *track;
+  mj2_sample_t *sample;
+  unsigned char* frame_codestream;
+  FILE *file, *outfile;
+  char outfilename[50];
+  opj_image_t *img = NULL;
+	unsigned int max_codstrm_size = 0;
+	double total_time = 0;
+	unsigned int numframes = 0;
+			
+  if (argc != 3) {
+    printf("Bad syntax: Usage: mj2_to_frames inputfile.mj2 outputfile.yuv\n"); 
+    printf("Example: MJ2_decoder foreman.mj2 foreman.yuv\n");
+    return 1;
+  }
+  
+  file = fopen(argv[1], "rb");
+  
+  if (!file) {
+    fprintf(stderr, "failed to open %s for reading\n", argv[1]);
+    return 1;
+  }
+	
+  // Checking output file
+  outfile = fopen(argv[2], "w");
+  if (!file) {
+    fprintf(stderr, "failed to open %s for writing\n", argv[2]);
+    return 1;
+  }
+  fclose(outfile);
+	
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = NULL;
+	
+	/* get a MJ2 decompressor handle */
+	dinfo = mj2_create_decompress();
+	movie = dinfo->mj2_handle;
+	
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);		
+
+	/* set J2K decoding parameters to default values */
+	opj_set_default_decoder_parameters(&mj2_parameters.j2k_parameters);
+	
+	/* setup the decoder decoding parameters using user parameters */
+	mj2_setup_decoder(dinfo->mj2_handle, &mj2_parameters);
+			
+  if (mj2_read_struct(file, movie)) // Creating the movie structure
+    return 1;	
+	
+  // Decode first video track 
+	for (tnum=0; tnum < (unsigned int)(movie->num_htk + movie->num_stk + movie->num_vtk); tnum++) {
+		if (movie->tk[tnum].track_type == 0) 
+			break;
+	}
+	
+	if (movie->tk[tnum].track_type != 0) {
+		printf("Error. Movie does not contain any video track\n");
+		return 1;
+	}
+	
+  track = &movie->tk[tnum];
+	
+  // Output info on first video tracl
+  fprintf(stdout,"The first video track contains %d frames.\nWidth: %d, Height: %d \n\n",
+    track->num_samples, track->w, track->h);
+	
+	max_codstrm_size = track->sample[0].sample_size-8;
+	frame_codestream = (unsigned char*) malloc(max_codstrm_size * sizeof(unsigned char)); 
+
+	numframes = track->num_samples;
+	
+  for (snum=0; snum < numframes; snum++)
+  {
+		double init_time = opj_clock();
+		double elapsed_time;
+
+    sample = &track->sample[snum];
+		if (sample->sample_size-8 > max_codstrm_size) {
+			max_codstrm_size =  sample->sample_size-8;
+			if ((frame_codestream = realloc(frame_codestream, max_codstrm_size)) == NULL) {
+				printf("Error reallocation memory\n");
+				return 1;
+			}; 		
+		}
+    fseek(file,sample->offset+8,SEEK_SET);
+    fread(frame_codestream, sample->sample_size-8, 1, file);  // Assuming that jp and ftyp markers size do
+		
+		/* open a byte stream */
+		cio = opj_cio_open((opj_common_ptr)dinfo, frame_codestream, sample->sample_size-8);
+		
+		img = opj_decode(dinfo, cio); // Decode J2K to image
+				
+    if (((img->numcomps == 3) && (img->comps[0].dx == img->comps[1].dx / 2) 
+      && (img->comps[0].dx == img->comps[2].dx / 2 ) && (img->comps[0].dx == 1)) 
+      || (img->numcomps == 1)) {
+      
+      if (!imagetoyuv(img, argv[2]))	// Convert image to YUV
+				return 1;
+    }
+    else if ((img->numcomps == 3) && 
+      (img->comps[0].dx == 1) && (img->comps[1].dx == 1)&&
+      (img->comps[2].dx == 1))// If YUV 4:4:4 input --> to bmp
+    {
+      fprintf(stdout,"The frames will be output in a bmp format (output_1.bmp, ...)\n");
+      sprintf(outfilename,"output_%d.bmp",snum);
+      if (imagetobmp(img, outfilename))	// Convert image to YUV
+				return 1;
+      
+    }
+    else {
+      fprintf(stdout,"Image component dimensions are unknown. Unable to output image\n");
+      fprintf(stdout,"The frames will be output in a j2k file (output_1.j2k, ...)\n");
+			
+      sprintf(outfilename,"output_%d.j2k",snum);
+      outfile = fopen(outfilename, "wb");
+      if (!outfile) {
+				fprintf(stderr, "failed to open %s for writing\n",outfilename);
+				return 1;
+      }
+      fwrite(frame_codestream,sample->sample_size-8,1,outfile);
+      fclose(outfile);
+    }
+		/* close the byte stream */
+		opj_cio_close(cio);	
+		/* free image data structure */
+		opj_image_destroy(img);
+		elapsed_time = opj_clock()-init_time;
+		fprintf(stderr, "Frame number %d/%d decoded in %.2f mseconds\n", snum + 1, numframes, elapsed_time*1000);
+		total_time += elapsed_time;
+
+  }
+	
+	free(frame_codestream);	
+  fclose(file);	
+
+	/* free remaining structures */
+	if(dinfo) {
+		mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
+	}
+	free(dinfo);
+	
+	fprintf(stdout, "%d frame(s) correctly decompressed\n", snum);
+	fprintf(stdout,"Total decoding time: %.2f seconds (%.1f fps)\n", total_time, (float)numframes/total_time);
+		
+  return 0;
+}
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.dsp.svn-base ./mj2/.svn/text-base/mj2_to_frames.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_frames.dsp.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,159 @@
+# Microsoft Developer Studio Project File - Name="mj2_to_frames" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=mj2_to_frames - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "mj2_to_frames.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "mj2_to_frames.mak" CFG="mj2_to_frames - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "mj2_to_frames - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "mj2_to_frames - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "mj2_to_frames - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /c
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "mj2_to_frames - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "mj2_to_frames___Win32_Debug0"
+# PROP BASE Intermediate_Dir "mj2_to_frames___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "mj2_to_frames___Win32_Debug0"
+# PROP Intermediate_Dir "mj2_to_frames___Win32_Debug0"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MT /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /GZ /c
+# SUBTRACT CPP /X
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd" /pdbtype:sept
+
+!ENDIF 
+
+# Begin Target
+
+# Name "mj2_to_frames - Win32 Release"
+# Name "mj2_to_frames - Win32 Debug"
+# Begin Group "MJ2"
+
+# PROP Default_Filter ""
+# Begin Group "MJ2 Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.h
+# End Source File
+# End Group
+# Begin Group "MJ2 Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\compat\getopt.c
+
+!IF  "$(CFG)" == "mj2_to_frames - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "mj2_to_frames - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.c
+
+!IF  "$(CFG)" == "mj2_to_frames - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "mj2_to_frames - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.c
+
+!IF  "$(CFG)" == "mj2_to_frames - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "mj2_to_frames - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_to_frames.c
+
+!IF  "$(CFG)" == "mj2_to_frames - Win32 Release"
+
+!ELSEIF  "$(CFG)" == "mj2_to_frames - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# End Group
+# End Group
+# Begin Group "OpenJPEG Headers"
+
+# PROP Default_Filter ""
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.dsw.svn-base ./mj2/.svn/text-base/mj2_to_frames.dsw.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_frames.dsw.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"="..\LibOpenJPEG.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "mj2_to_frames"=".\mj2_to_frames.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.sln.svn-base ./mj2/.svn/text-base/mj2_to_frames.sln.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_frames.sln.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_frames", "mj2_to_frames.vcproj", "{64325EAD-A083-4C8E-B852-71006428881D}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.ActiveCfg = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Debug|Win32.Build.0 = Debug|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.ActiveCfg = Release|Win32
+		{64325EAD-A083-4C8E-B852-71006428881D}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.vcproj.svn-base ./mj2/.svn/text-base/mj2_to_frames.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_frames.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_frames.vcproj.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,324 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="mj2_to_frames"
+	ProjectGUID="{64325EAD-A083-4C8E-B852-71006428881D}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_frames___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_frames___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pch"
+				AssemblerListingLocation=".\mj2_to_frames___Win32_Debug0/"
+				ObjectFile=".\mj2_to_frames___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_frames___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				AdditionalDependencies="odbc32.lib odbccp32.lib libcmtd.lib"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_frames___Win32_Debug0/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_frames.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_frames.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_frames.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/mj2_to_frames.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_frames.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_frames.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Headers"
+			>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.c.svn-base ./mj2/.svn/text-base/mj2_to_metadata.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.c.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,312 @@
+/* mj2_to_metadata.c */
+/* Dump MJ2, JP2 metadata (partial so far) to xml file */
+/* Contributed to Open JPEG by Glenn Pearson, contract software developer, U.S. National Library of Medicine.
+
+The base code in this file was developed by the author as part of a video archiving
+project for the U.S. National Library of Medicine, Bethesda, MD. 
+It is the policy of NLM (and U.S. government) to not assert copyright.
+
+A non-exclusive copy of this code has been contributed to the Open JPEG project.
+Except for copyright, inclusion of the code within Open JPEG for distribution and use
+can be bound by the Open JPEG open-source license and disclaimer, expressed elsewhere.
+*/
+
+#include "opj_includes.h"
+#include "mj2.h"
+
+#include "mj2_to_metadata.h"
+#include <string.h>
+#include "compat/getopt.h"
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+
+/* ------------- */
+
+void help_display()
+{
+  /*             "1234567890123456789012345678901234567890123456789012345678901234567890123456789" */
+  fprintf(stdout,"                Help for the 'mj2_to_metadata' Program\n");
+  fprintf(stdout,"                ======================================\n");
+  fprintf(stdout,"The -h option displays this information on screen.\n\n");
+  
+  fprintf(stdout,"mj2_to_metadata generates an XML file from a Motion JPEG 2000 file.\n");
+  fprintf(stdout,"The generated XML shows the structural, but not (yet) curatorial,\n");
+  fprintf(stdout,"metadata from the movie header and from the JPEG 2000 image and tile\n");
+  fprintf(stdout,"headers of a sample frame.  Excluded: low-level packed-bits image data.\n\n");
+
+  fprintf(stdout,"By Default\n");
+  fprintf(stdout,"----------\n");
+  fprintf(stdout,"The metadata includes the jp2 image and tile headers of the first frame.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Metadata values are shown in 'raw' form (e.g., hexidecimal) as stored in the\n");
+  fprintf(stdout,"file, and, if apt, in a 'derived' form that is more quickly grasped.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Notes explaining the XML are embedded as terse comments.  These include\n");
+  fprintf(stdout,"   meaning of non-obvious tag abbreviations;\n");
+  fprintf(stdout,"   range and precision of valid values;\n");
+  fprintf(stdout,"   interpretations of values, such as enumerations; and\n");
+  fprintf(stdout,"   current implementation limitations.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"The sample-size and chunk-offset tables, each with 1 row per frame, are not reported.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"The file is self-contained and no verification (e.g., against a DTD) is requested.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Required Parameters (except with -h)\n");
+  fprintf(stdout,"------------------------------------\n");
+  fprintf(stdout,"[Caution: file strings that contain spaces should be wrapped with quotes.]\n");
+  fprintf(stdout,"-i input.mj2  : where 'input' is any source file name or path.\n");
+  fprintf(stdout,"                MJ2 files created with 'frames_to_mj2' are supported so far.\n");
+  fprintf(stdout,"                These are silent, single-track, 'MJ2 Simple Profile' videos.\n");
+  fprintf(stdout,"-o output.xml : where 'output' is any destination file name or path.\n");
+  fprintf(stdout,"\n");
+  fprintf(stdout,"Optional Parameters\n");
+  fprintf(stdout,"-------------------\n");
+  fprintf(stdout,"-h            : Display this help information.\n");
+  fprintf(stdout,"-n            : Suppress all mj2_to_metadata notes.\n");
+  fprintf(stdout,"-t            : Include sample-size and chunk-offset tables.\n");
+  fprintf(stdout,"-f n          : where n > 0.  Include jp2 header info for frame n [default=1].\n");
+  fprintf(stdout,"-f 0          : No jp2 header info.\n");
+  fprintf(stdout,"-r            : Suppress all 'raw' data for which a 'derived' form exists.\n");
+  fprintf(stdout,"-d            : Suppress all 'derived' data.\n");
+  fprintf(stdout,"                (If both -r and -d given, -r will be ignored.)\n");
+  fprintf(stdout,"-v string     : Verify against the DTD file located by the string.\n");
+  fprintf(stdout,"                Prepend quoted 'string' with either SYSTEM or PUBLIC keyword.\n");
+  fprintf(stdout,"                Thus, for the distributed DTD placed in the same directory as\n");
+  fprintf(stdout,"                the output file: -v \"SYSTEM mj2_to_metadata.dtd\"\n");
+  fprintf(stdout,"                \"PUBLIC\" is used with an access protocol (e.g., http:) + URL.\n");
+  /* More to come */
+  fprintf(stdout,"\n");
+  /*             "1234567890123456789012345678901234567890123456789012345678901234567890123456789" */
+}
+
+/* ------------- */
+
+int main(int argc, char *argv[]) {
+
+	opj_dinfo_t* dinfo; 
+	opj_event_mgr_t event_mgr;		/* event manager */
+
+  FILE *file, *xmlout;
+/*  char xmloutname[50]; */
+  opj_mj2_t *movie;
+
+  char* infile = 0;
+  char* outfile = 0;
+  char* s, S1, S2, S3;
+  int len;
+  unsigned int sampleframe = 1; /* First frame */
+  char* stringDTD = NULL;
+  BOOL notes = TRUE;
+  BOOL sampletables = FALSE;
+  BOOL raw = TRUE;
+  BOOL derived = TRUE;
+	mj2_dparameters_t parameters;
+
+  while (TRUE) {
+	/* ':' after letter means it takes an argument */
+    int c = getopt(argc, argv, "i:o:f:v:hntrd");
+	/* FUTURE:  Reserve 'p' for pruning file (which will probably make -t redundant) */
+    if (c == -1)
+      break;
+    switch (c) {
+    case 'i':			/* IN file */
+      infile = optarg;
+      s = optarg;
+      while (*s) { s++; } /* Run to filename end */
+      s--;
+      S3 = *s;
+      s--;
+      S2 = *s;
+      s--;
+      S1 = *s;
+      
+      if ((S1 == 'm' && S2 == 'j' && S3 == '2')
+      || (S1 == 'M' && S2 == 'J' && S3 == '2')) {
+       break;
+      }
+      fprintf(stderr, "Input file name must have .mj2 extension, not .%c%c%c.\n", S1, S2, S3);
+      return 1;
+
+      /* ----------------------------------------------------- */
+    case 'o':			/* OUT file */
+      outfile = optarg;
+      while (*outfile) { outfile++; } /* Run to filename end */
+      outfile--;
+      S3 = *outfile;
+      outfile--;
+      S2 = *outfile;
+      outfile--;
+      S1 = *outfile;
+      
+      outfile = optarg;
+      
+      if ((S1 == 'x' && S2 == 'm' && S3 == 'l')
+	  || (S1 == 'X' && S2 == 'M' && S3 == 'L'))
+        break;
+    
+      fprintf(stderr,
+	  "Output file name must have .xml extension, not .%c%c%c\n", S1, S2, S3);
+	  return 1;
+
+      /* ----------------------------------------------------- */
+    case 'f':			/* Choose sample frame.  0 = none */
+      sscanf(optarg, "%u", &sampleframe);
+      break;
+
+      /* ----------------------------------------------------- */
+    case 'v':			/* Verification by DTD. */
+      stringDTD = optarg;
+	  /* We will not insist upon last 3 chars being "dtd", since non-file
+	  access protocol may be used. */
+	  if(strchr(stringDTD,'"') != NULL) {
+        fprintf(stderr, "-D's string must not contain any embedded double-quote characters.\n");
+	    return 1;
+	  }
+
+      if (strncmp(stringDTD,"PUBLIC ",7) == 0 || strncmp(stringDTD,"SYSTEM ",7) == 0)
+        break;
+    
+      fprintf(stderr, "-D's string must start with \"PUBLIC \" or \"SYSTEM \"\n");
+	  return 1;
+
+    /* ----------------------------------------------------- */
+    case 'n':			/* Suppress comments */
+      notes = FALSE;
+      break;
+
+    /* ----------------------------------------------------- */
+    case 't':			/* Show sample size and chunk offset tables */
+      sampletables = TRUE;
+      break;
+
+    /* ----------------------------------------------------- */
+    case 'h':			/* Display an help description */
+      help_display();
+      return 0;
+
+    /* ----------------------------------------------------- */
+    case 'r':			/* Suppress raw data */
+      raw = FALSE;
+      break;
+
+    /* ----------------------------------------------------- */
+    case 'd':			/* Suppress derived data */
+      derived = FALSE;
+      break;
+
+   /* ----------------------------------------------------- */
+    default:
+      return 1;
+    } /* switch */
+  } /* while */
+
+  if(!raw && !derived)
+	  raw = TRUE; /* At least one of 'raw' and 'derived' must be true */
+
+    /* Error messages */
+  /* -------------- */
+  if (!infile || !outfile) {
+    fprintf(stderr,"Correct usage: mj2_to_metadata -i mj2-file -o xml-file (plus options)\n");
+    return 1;
+  }
+
+/* was:
+  if (argc != 3) {
+    printf("Bad syntax: Usage: MJ2_to_metadata inputfile.mj2 outputfile.xml\n"); 
+    printf("Example: MJ2_to_metadata foreman.mj2 foreman.xml\n");
+    return 1;
+  }
+*/
+  len = strlen(infile);
+  if(infile[0] == ' ')
+  {
+    infile++; /* There may be a leading blank if user put space after -i */
+  }
+  
+  file = fopen(infile, "rb"); /* was: argv[1] */
+  
+  if (!file) {
+    fprintf(stderr, "Failed to open %s for reading.\n", infile); /* was: argv[1] */
+    return 1;
+  }
+
+  len = strlen(outfile);
+  if(outfile[0] == ' ')
+  {
+    outfile++; /* There may be a leading blank if user put space after -o */
+  }
+
+  // Checking output file
+  xmlout = fopen(outfile, "w"); /* was: argv[2] */
+  if (!xmlout) {
+    fprintf(stderr, "Failed to open %s for writing.\n", outfile); /* was: argv[2] */
+    return 1;
+  }
+  // Leave it open
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* get a MJ2 decompressor handle */
+	dinfo = mj2_create_decompress();
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);		
+
+	/* setup the decoder decoding parameters using user parameters */
+	movie = (opj_mj2_t*) dinfo->mj2_handle;
+	mj2_setup_decoder(dinfo->mj2_handle, &parameters);
+
+  if (mj2_read_struct(file, movie)) // Creating the movie structure
+  {
+    fclose(xmlout);
+    return 1;
+  }
+
+  xml_write_init(notes, sampletables, raw, derived);
+  xml_write_struct(file, xmlout, movie, sampleframe, stringDTD, &event_mgr);
+  fclose(xmlout);
+
+	fprintf(stderr,"Metadata correctly extracted to XML file \n");;	
+
+	/* free remaining structures */
+	if(dinfo) {
+		mj2_destroy_decompress((opj_mj2_t*)dinfo->mj2_handle);
+	}
+
+  return 0;
+}
+
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dsp.svn-base ./mj2/.svn/text-base/mj2_to_metadata.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,140 @@
+# Microsoft Developer Studio Project File - Name="mj2_to_metadata" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=mj2_to_metadata - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "mj2_to_metadata.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "mj2_to_metadata.mak" CFG="mj2_to_metadata - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "mj2_to_metadata - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "mj2_to_metadata - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "mj2_to_metadata - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /YX /FD /c
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386 /nodefaultlib:"libcmtd"
+# SUBTRACT LINK32 /pdb:none
+
+!ELSEIF  "$(CFG)" == "mj2_to_metadata - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "mj2_to_metadata___Win32_Debug0"
+# PROP BASE Intermediate_Dir "mj2_to_metadata___Win32_Debug0"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "mj2_to_metadata___Win32_Debug0"
+# PROP Intermediate_Dir "mj2_to_metadata___Win32_Debug0"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmtd" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "mj2_to_metadata - Win32 Release"
+# Name "mj2_to_metadata - Win32 Debug"
+# Begin Group "MJ2"
+
+# PROP Default_Filter ""
+# Begin Group "MJ2 Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\compat\getopt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\meta_out.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_to_metadata.h
+# End Source File
+# End Group
+# Begin Group "MJ2 Source Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=.\compat\getopt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\meta_out.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_convert.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\mj2_to_metadata.c
+# End Source File
+# End Group
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dsw.svn-base ./mj2/.svn/text-base/mj2_to_metadata.dsw.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.dsw.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"="..\LibOpenJPEG.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "mj2_to_metadata"=".\mj2_to_metadata.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dtd.svn-base ./mj2/.svn/text-base/mj2_to_metadata.dtd.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.dtd.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.dtd.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,425 @@
+<!--
+Preliminary DTD for Open JPEG "mj2_to_metadata" function.
+Last revised: April 20, 2005
+Author:  Glenn Pearson, at U.S. National Library of Medicine.
+See mj2_to_metadata.c regarding copyright, license, disclaimer status.
+
+While the vocabulary of this DTD is based on the relevant portions of the
+ISO/IEC JPEG 200 standard, the detailed representation is the author's own.
+It is neither an ISO/IEC nor NLM official or consensus representation.
+Furthermore, it deviates from a pure representation of the ISO/IEC standard
+in these aspects:
+
+  - it is incomplete in a number of ways (which to some extent may be
+    addressed over time);
+  - it has extensions for "derived" data and "statistics";
+  - it is more flexible.  That is, some elements are marked as optional
+    not because they are optional in an MJ2 file, but because reporting
+    of them is optional based on current or projected mj2_to_metadata
+    command-line flags.
+-->
+<!ELEMENT MJ2_File (JP2?, FileType?, MovieBox?)>
+<!ELEMENT JP2 EMPTY>
+<!ATTLIST JP2 BoxType CDATA #FIXED "jP[space][space]">
+<!ATTLIST JP2 Signature CDATA #FIXED "0x0d0a870a">
+<!ELEMENT FileType (Brand, MinorVersion, CompatibilityList)>
+<!ATTLIST FileType BoxType CDATA #FIXED "ftyp">
+<!ELEMENT Brand (#PCDATA)> <!-- 4 characters max -->
+<!ELEMENT MinorVersion (#PCDATA)> <!-- 4 chararcters max -->
+<!ELEMENT CompatibilityList (CompatibleBrand)*>
+<!ATTLIST CompatibilityList Count CDATA #REQUIRED>  <!-- Count >= 0 -->
+<!ELEMENT CompatibleBrand (#PCDATA)> <!-- 4 characters max -->
+<!ELEMENT MovieBox (MovieHeader, Statistics?, Track*)>
+<!ATTLIST MovieBox BoxType CDATA #FIXED "moov">
+<!ELEMENT MovieHeader (CreationTime, ModificationTime, Timescale, Rate, Duration, Volume, TransformationMatrix)>
+<!ATTLIST MovieHeader BoxType CDATA #FIXED "mvhd">
+<!ELEMENT CreationTime (InSeconds?,AsLocalTime?)>
+<!ELEMENT InSeconds (#PCDATA)>
+<!ELEMENT AsLocalTime (#PCDATA)>
+<!ELEMENT ModificationTime (InSeconds?,AsLocalTime?)>
+<!ELEMENT Timescale (#PCDATA)> <!-- Timescale defines time units in one second -->
+<!ELEMENT Rate (AsHex | (AsHex, AsDecimal) | AsDecimal)>  <!-- Decimal is Approximation; Optional on input. -->
+<!ELEMENT AsHex (#PCDATA)>
+<!ELEMENT AsDecimal (#PCDATA)> 
+<!ELEMENT Duration (InTimeUnits | (InTimeUnits, InSeconds) | InSeconds)>  <!-- InSeconds Optional on input. -->
+<!ELEMENT InTimeUnits (#PCDATA)>
+<!ELEMENT Volume (AsHex | (AsHex, AsDecimal) | AsDecimal)>   <!-- hex default = 0x0100 -->
+<!-- Fixed 8.8 value of audio volume.  Full, normal value is 1.0 (0x0100) -->
+<!ELEMENT TransformationMatrix (TMa,TMb,TMu,TMc,TMd,TMv,TMx,TMy,TMw)> <!-- for video -->
+<!-- 3 x 3 Video Transformation Matrix {a,b,u,c,d,v,x,y,w}.  Required: u=0, v=0, w=1 -->
+<!-- Maps decompressed point (p,q) to rendered point (ap + cq + x, bp + dq + y) -->
+<!-- Stored as Fixed Point Hex: all are 16.16, except u,v,w are 2.30 -->
+<!-- Unity = 0x00010000,0,0,0,0x00010000,0,0,0,0x40000000 -->
+<!ELEMENT TMa (#PCDATA)>    
+<!ELEMENT TMb (#PCDATA)>  
+<!ELEMENT TMu (#PCDATA)> <!--Always "0x00000000" -->
+<!ELEMENT TMc (#PCDATA)>
+<!ELEMENT TMd (#PCDATA)>
+<!ELEMENT TMv (#PCDATA)> <!--Always "0x00000000" -->
+<!ELEMENT TMx (#PCDATA)>
+<!ELEMENT TMy (#PCDATA)>
+<!ELEMENT TMw (#PCDATA)> <!--Always "0x40000000" -->
+
+<!ELEMENT Statistics (TracksFound)>
+<!ELEMENT TracksFound (Video,Audio,Hint)>
+<!ELEMENT Video (#PCDATA)>
+<!ELEMENT Audio (#PCDATA)>
+<!ELEMENT Hint (#PCDATA)>
+ 
+
+<!-- For now, output info on at most one video track -->
+
+
+<!ELEMENT Track (TrackHeader, TrackReferenceContainer?, EditListContainer?, Media, JP2_Frame?)>  <!-- JP2_Frame is mj2_to_metadata extension -->
+<!ATTLIST Track BoxType CDATA #FIXED "trak">
+<!ATTLIST Track Instance CDATA #REQUIRED>
+<!ELEMENT TrackHeader (TrackID, TrackLayer?, Volume?, TransformationMatrix?, Width?, Height?)>
+<!ATTLIST TrackHeader BoxType CDATA #FIXED "tkhd">
+<!-- Not shown here: CreationTime, ModificationTime, Duration. -->
+<!-- These 3 fields are reported under MediaHeader below.   When reading these 3, -->
+<!-- m2j_to_metadata currently doesn't distinguish between TrackHeader and MediaHeader source. -->
+<!-- If both found, value read from MediaHeader is used. -->
+<!ELEMENT TrackID (#PCDATA)>
+<!ELEMENT TrackLayer (#PCDATA)>  <!-- front-to-back ordering of video tracks. 0 = normal, -1 is closer, etc. -->
+<!-- "Volume" element described above; here it is for particular audio track.  Full, normal (default = 0x0100) -->
+<!-- "TransformationMatrix" element described above; matrix here is applied before MovieHeader one. -->
+<!ELEMENT Width (AsHex | (AsHex, AsDecimal) | AsDecimal)>
+<!ELEMENT Height (AsHex | (AsHex, AsDecimal) | AsDecimal)>
+<!-- AsHex, AsDecimal already defined above -->
+ <!-- Width and Height are for the presentation; frames will be scaled to this -->
+<!-- /TrackHeader -->
+<!ELEMENT TrackReferenceContainer ANY>  <!-- TO DO: TrackReferenceContainer 'tref'  just used in hint track -->
+<!ELEMENT EditListContainer ANY>  <!-- TO DO: EditListContainer 'edts', contains EditList 'elst' with media-time, segment-duration, media-rate -->
+<!ELEMENT Media (MediaHeader, HandlerReference,MediaInfoContainer)>
+<!ATTLIST Media BoxType CDATA #FIXED "mdia">
+<!ELEMENT MediaHeader (CreationTime,ModificationTime,Timescale,Duration,Language)>
+<!ATTLIST MediaHeader BoxType CDATA #FIXED "mdhd">
+<!-- Elements already defined above: CreationTime, ModificationTime, Timescale, Duration -->
+<!ELEMENT Language (#PCDATA)> <!-- 3 chars max.  There's an enumeration available -->
+<!ELEMENT HandlerReference (HandlerType)>
+<!ATTLIST HandlerReference BoxType CDATA #FIXED "hdlr">
+<!ELEMENT HandlerType (#PCDATA)>
+<!ATTLIST HandlerType Code ( vide | soun | hint ) "vide">
+
+<!-- make the media headers multiple? -->
+<!ELEMENT MediaInfoContainer ((VideoMediaHeader | SoundMediaHeader | HintMediaHeader), DataInfo, SampleTable)>
+<!ATTLIST MediaInfoContainer BoxType CDATA #FIXED "minf">
+<!ELEMENT VideoMediaHeader (GraphicsMode, Opcolor)>
+<!ATTLIST VideoMediaHeader BoxType CDATA #FIXED "vmhd">
+<!ELEMENT GraphicsMode (#PCDATA)>
+          <!-- Enumerated values of graphics mode: -->
+          <!--  0x00 = copy (over existing image); -->
+          <!--  0x24 = transparent; 'blue-screen' this image using opcolor; -->
+          <!--  0x100 = alpha; alpha-blend this image -->
+          <!--  0x101 = whitealpha; alpha-blend this image, which has been blended with white; -->
+          <!--  0x102 = blackalpha; alpha-blend this image, which has been blended with black. -->
+<!ELEMENT Opcolor (Red,Green,Blue)>
+<!ELEMENT Red (#PCDATA)>
+<!ELEMENT Green (#PCDATA)>
+<!ELEMENT Blue (#PCDATA)>
+<!ELEMENT SoundMediaHeader (Balance)>
+<!ATTLIST SoundMediaHeader BoxType CDATA #FIXED "smhd">
+<!ELEMENT Balance (#PCDATA)>
+          <!-- Fixed Point 8.8, fixes mono track in stereo space. -->
+          <!-- 0.0 = center, -1.0 = full left, 1.0 = full right -->
+<!ELEMENT HintMediaHeader (MaxPDU_Size, AvgPDU_Size, MaxBitRate, AvgBitRate, SlidingAvgBitRate)>
+<!ATTLIST HintMediaHeader BoxType CDATA #FIXED "hmhd">
+<!ELEMENT MaxPDU_Size (#PCDATA)>
+          <!-- Size in bytes of largest PDU in this hint stream. -->
+<!ELEMENT AvgPDU_Size (#PCDATA)>
+           <!-- Average size in bytes of a PDU over the entire presentation. -->
+<!ELEMENT MaxBitRate (#PCDATA)>
+          <!-- Maximum rate in bits per second over any window of 1 second. -->
+<!ELEMENT AvgBitRate (#PCDATA)>
+          <!-- Averate rate in bits per second over the entire presentation. -->
+<!ELEMENT SlidingAvgBit (#PCDATA)>
+          <!-- Maximum rate in bits per second over any window of one minute. -->
+ 
+<!ELEMENT DataInfo (DataReference)>
+<!ATTLIST DataInfo BoxType CDATA #FIXED "dinf">
+<!ELEMENT DataReference (DataEntryUrlBox | DataEntryUrnBox )*>
+<!ATTLIST DataReference BoxType CDATA #FIXED "dref">
+<!ATTLIST DataReference URL_Count CDATA #REQUIRED>
+<!ATTLIST DataReference URN_Count CDATA #REQUIRED> <!-- table w. flags, URLs, URNs -->
+<!--  // Data structure does not distinguish between single URL, single URN, or DREF table or URLs & URNs.
+  // We could infer those, but for now just present everything as a DREF table.
+-->
+              <!-- No entries here mean that file is self-contained, as required by Simple Profile. -->
+
+<!ELEMENT DataEntryUrlBox (Location)>
+<!ATTLIST DataEntryUrlBox BoxType CDATA #FIXED "url[space]"> <!-- table w. flags, URLs, URNs -->
+            <!-- Only the first 16 bytes of URL location are recorded in mj2_to_metadata data structure. -->
+<!ELEMENT DataEntryUrnBox (Name, Location?)>
+<!ATTLIST DataEntryUrnBox BoxType CDATA #FIXED "urn[space]\">
+            <!-- Only the first 16 bytes each of URN name and optional location are recorded in mj2_to_metadata data structure. -->
+
+<!ELEMENT SampleTable (VisualSampleEntry,TimeToSample,SampleToChunk,SampleSize,ChunkOffset)>  <!-- structure doesn't do non-visual sample entry yet -->
+<!ATTLIST SampleTable BoxType CDATA #FIXED "stbl">  <!-- to add: entry count -->
+            <!-- Next are instances of generic SampleDescription BoxType=\"stsd\" -->
+ 
+    <!-- There could be multiple instances of this, but "entry_count" is just a local at read-time.
+       And it's used wrong, too, as count of just visual type, when it's really all 3 types.
+       This is referred to as "smj2" within mj2.c -->
+<!ELEMENT VisualSampleEntry (WidthAsInteger, HeightAsInteger, HorizontalRes, VerticalRes, CompressorName, Depth, JP2Header?, FieldCoding?, MJP2_Profile?, MJP2_Prefix?, MJP2_SubSampling?, MJP2_OriginalFormat?)>
+<!ATTLIST VisualSampleEntry BoxType CDATA #FIXED "mjp2">
+          <!-- If multiple instances of this, only first is shown here. -->
+<!ELEMENT WidthAsInteger (#PCDATA)>
+<!ELEMENT HeightAsInteger (#PCDATA)>
+<!ELEMENT HorizontalRes (AsHex | (AsHex, AsDecimal) | AsDecimal)>
+<!ELEMENT VerticalRes (AsHex | (AsHex, AsDecimal) | AsDecimal)>
+<!-- Typical value for both resolution is 72 (0x00480000) -->
+<!ELEMENT CompressorName (#PCDATA)>
+          <!-- Compressor name for debugging.  Standard restricts max length to 31 bytes. -->
+          <!-- Usually blank or \"Motion JPEG2000\" -->
+<!ELEMENT Depth (#PCDATA)>
+          <!-- Depth is: -->
+          <!--   0x20: alpha channels present (color or grayscale) -->
+          <!--   0x28: grayscale without alpha -->
+          <!--   0x18: color without alpha -->
+
+<!-- TODO somewhere: tk->jp2_struct.numcomps -->
+<!ELEMENT JP2Header (ImageHeader, ColourSpecification)>
+<!ATTLIST JP2Header BoxType CDATA #FIXED "jp2h">
+<!ELEMENT ImageHeader (HEIGHT, WIDTH, NC, BPC, C, UnkC, IPR)>
+<!ATTLIST ImageHeader BoxType CDATA #FIXED "ihdr">
+<!ELEMENT HEIGHT (#PCDATA)>  <!-- If 2 fields/frame, total deinterlaced height -->
+<!ELEMENT WIDTH (#PCDATA)>
+<!ELEMENT NC (#PCDATA)>  <!-- number of components -->
+<!ELEMENT BPC (AsHex | (AsHex,BitsPerPixel,Signed) | (BitsPerPixel,Signed))>
+<!ELEMENT BitsPerPixel (#PCDATA)>
+<!ELEMENT Signed (#PCDATA)>
+<!ELEMENT C (#PCDATA)>  <!-- Compression type.  Only "7" defined -->
+<!ELEMENT UnkC (#PCDATA)>  <!-- Colourspace Unknown. 1 = unknown, 0 = known -->
+<!ELEMENT IPR (#PCDATA)>  <!-- 1 = frame has Intellectual Prop. box; otherwise 0 -->
+<!ELEMENT ColourSpecification (METH, PREC, APPROX, EnumCS)>
+<!ATTLIST ColourSpecification BoxType CDATA #FIXED "colr">
+<!ELEMENT METH (#PCDATA)>  <!-- 1 = EnumCS field; 2 = PROFILE field (not yet generated) -->
+<!ELEMENT PREC (#PCDATA)> <!-- precedence must be 0 so far -->
+<!ELEMENT APPROX (#PCDATA)>  <!-- colourspace approximation must be 0 so far -->
+<!ELEMENT EnumCS (#PCDATA)> <!-- Valid enumerated MJ2 colourspaces: 16 (sRGB), 17 (grey sRGB), 18 (YCC) -->
+
+<!-- Following subboxes are optional -->
+<!ELEMENT FieldCoding (FieldCount, FieldOrder)>
+<!ATTLIST FieldCoding BoxType CDATA #FIXED "fiel">
+<!ELEMENT FieldCount (#PCDATA)>
+            <!-- Must be either 1 or 2 -->
+<!ELEMENT FieldOrder (#PCDATA)>
+            <!-- When FieldCount=2, FieldOrder means: -->
+            <!--   0: Field coding unknown -->
+            <!--   1: Field with topmost line is stored first in sample; fields are in temporal order -->
+            <!--   6: Field with topmost line is stored second in sample; fields are in temporal order -->
+            <!-- Defaults: FieldCount=1, FieldOrder=0 if FieldCoding box not present -->
+            <!-- Current implementation doesn't retain whether box was actually present. -->
+
+<!ELEMENT MJP2_Profile (CompatibleBrand*)>
+<!ATTLIST MJP2_Profile BoxType CDATA #FIXED "jp2p">
+<!ATTLIST MJP2_Profile Count CDATA #REQUIRED>
+
+<!ELEMENT MJP2_Prefix (Data*)>
+<!ATTLIST MJP2_Prefix BoxType CDATA #FIXED "jp2x">
+<!ATTLIST MJP2_Prefix Count CDATA #REQUIRED>
+<!-- We'll probably need better formatting than this  -->
+<!ELEMENT Data (#PCDATA)>    <!-- Multiple. Each entry is single byte -->
+
+<!ELEMENT MJP2_SubSampling (HorizontalSub, VerticalSub, HorizontalOffset, VerticalOffset)>
+<!ATTLIST MJP2_SubSampling BoxType CDATA #FIXED "jsub">
+<!-- These values are all 1 byte -->
+            <!-- Typical subsample value is 2 for 4:2:0 -->
+<!ELEMENT HorizontalSub (#PCDATA)>
+<!ELEMENT VerticalSub (#PCDATA)>
+<!ELEMENT HorizontalOffset (#PCDATA)>
+<!ELEMENT VerticalOffset (#PCDATA)>
+
+<!ELEMENT MJP2_OriginalFormat (OriginalFieldCount, OriginalFieldOrder)>
+<!ATTLIST MJP2_OriginalFormat BoxType CDATA #FIXED "orfo"> <!-- Part III Appx. 2 -->
+<!ELEMENT OriginalFieldCount (#PCDATA)>
+            <!-- In original material before encoding.  Must be either 1 or 2 -->
+<!ELEMENT OriginalFieldOrder (#PCDATA)>
+            <!-- When FieldCount=2, FieldOrder means: -->
+            <!--   0: Field coding unknown -->
+            <!--   11: Topmost line came from the earlier field; -->
+            <!--   16:  Topmost line came form the later field. -->
+            <!-- Defaults: FieldCount=1, FieldOrder=0 if FieldCoding box not present -->
+            <!-- Current implementation doesn't retain whether box was actually present. -->
+
+
+            <!-- mj2_to_metadata's data structure doesn't record Audio and Hint sample data currently. -->
+
+<!-- Within SampleTable: -->
+<!ELEMENT TimeToSample (SampleStatistics, SampleEntries)>
+<!ATTLIST TimeToSample BoxType CDATA #FIXED "stts">  
+<!ELEMENT SampleStatistics (TotalSamples)>  <!-- Not part of standard -->  
+<!ELEMENT TotalSamples (#PCDATA)>
+                <!-- For video, gives the total frames in the track, by summing all entries in the Sample Table -->
+
+<!ELEMENT SampleEntries (Table*)>
+<!ATTLIST SampleEntries EntryCount CDATA #REQUIRED>
+<!ELEMENT Table EMPTY> <!-- Multiple.  Attributes have values -->
+<!ATTLIST Table Entry CDATA #REQUIRED>
+<!ATTLIST Table SampleCount CDATA #REQUIRED>
+<!ATTLIST Table SampleDelta CDATA #REQUIRED>
+
+<!-- Within SampleTable: -->
+<!ELEMENT SampleToChunk (FirstChunk,SamplesPerChunk,SampleDescrIndex)>
+<!ATTLIST SampleToChunk BoxType CDATA #FIXED "stsc">
+<!ATTLIST SampleToChunk Count CDATA #REQUIRED>
+<!ELEMENT FirstChunk (#PCDATA)>
+<!ELEMENT SamplesPerChunk (#PCDATA)>
+<!ELEMENT SampleDescrIndex (#PCDATA)>
+<!ELEMENT SampleSize (Sample_Size,Sample_Count,EntrySize*)>
+<!ATTLIST SampleSize BoxType CDATA #FIXED "stsz">
+<!ELEMENT Sample_Size (#PCDATA)>
+<!ELEMENT Sample_Count (#PCDATA)>
+<!ELEMENT EntrySize (#PCDATA)>  <!-- appears multiply, but only with mj2_to_metadata option -t -->
+<!ATTLIST EntrySize Num CDATA #REQUIRED>
+<!ELEMENT ChunkOffset (EntryCount, Chunk_Offset*)>
+<!ATTLIST ChunkOffset BoxType CDATA #FIXED "stco">
+<!ELEMENT EntryCount (#PCDATA)>
+<!ELEMENT Chunk_Offset (#PCDATA)>  <!-- appears multiply, but only with mj2_to_metadata option -t -->
+<!ATTLIST Chunk_Offset Num CDATA #REQUIRED>
+<!-- </SampleTable> </MediaInfoContainer> </Media> -->
+
+<!-- TO DO: optional UserData 'udat', can contain multiple Copyright 'cprt' -->
+
+
+<!-- Optional, and only for Visual Track: given individual frame -->
+<!ELEMENT JP2_Frame (MainHeader, TilePartHeaders)>
+<!ATTLIST JP2_Frame Num CDATA #REQUIRED>
+<!ELEMENT MainHeader (StartOfCodestream,ImageAndFileSize,CodingStyleDefault,QuantizationDefault,QuantizationComponent*,RegionOfInterest?,ProgressionOrderChange*)>
+<!ELEMENT StartOfCodestream EMPTY>
+<!ATTLIST StartOfCodestream Marker CDATA #FIXED "SOC">
+<!ELEMENT ImageAndFileSize (Xsiz,Ysiz,XOsiz,YOsiz,XTsiz,YTsiz,XTOsiz,YTOsiz,Csiz,Component+)>
+<!ATTLIST ImageAndFileSize Marker CDATA #FIXED "SIZ">
+<!ELEMENT Xsiz (#PCDATA)>
+<!ELEMENT Ysiz (#PCDATA)>  <!-- Xsiz, Ysiz is the size of the reference grid. -->
+<!ELEMENT XOsiz (#PCDATA)>
+<!ELEMENT YOsiz (#PCDATA)>  <!-- XOsiz, YOsiz are offsets from grid origin to image origin. -->
+<!ELEMENT XTsiz (#PCDATA)>
+<!ELEMENT YTsiz (#PCDATA)>  <!-- XTsiz, YTsiz is the size of one tile with respect to the grid. -->
+<!ELEMENT XTOsiz (#PCDATA)>
+<!ELEMENT YTOsiz (#PCDATA)> <!-- XTOsiz, YTOsiz are offsets from grid origin to first tile origin. -->
+<!ELEMENT Csiz (#PCDATA)>  <!-- Csiz is the number of components in the image. -->
+<!-- For image components next -->
+<!ELEMENT Component (Ssiz,XRsiz,YRsiz,WidthOfData,HeightOfData)>
+<!ATTLIST Component Num CDATA #REQUIRED>
+<!ELEMENT Ssiz (AsHex | (AsHex,Signed,PrecisionInBits) | (Signed,PrecisionInBits))>
+<!-- Signed already defined -->
+<!ELEMENT PrecisionInBits (#PCDATA)>  <!--   Bits per pixel (bpp) or pixel depth. -->
+<!ELEMENT XRsiz (#PCDATA)>
+<!ELEMENT YRsiz (#PCDATA)> <!-- XRsiz, YRsiz denote pixel-sample-spacing on the grid, per Part I Annex B. -->
+<!ELEMENT WidthOfData (#PCDATA)>
+<!ELEMENT HeightOfData (#PCDATA)>  <!-- WidthOfData and HeightOfData are calculated values, e.g.: w = roundup((Xsiz - XOsiz)/ XRsiz) -->
+<!-- -->
+<!ELEMENT CodingStyleDefault (Scod,SGcod,SPcod)>
+<!ATTLIST CodingStyleDefault Marker CDATA #FIXED "COD">
+<!ELEMENT Scod (#PCDATA)>
+          <!-- For Scod, specific bits mean (where bit 0 is lowest or rightmost): -->
+          <!-- bit 0: Defines entropy coder precincts -->
+          <!--        0 = (PPx=15, PPy=15); 1 = precincts defined below. -->
+          <!-- bit 1: 1 = SOP marker may be used; 0 = not. -->
+          <!-- bit 2: 1 = EPH marker may be used; 0 = not. -->
+<!ELEMENT SGcod (ProgressionOrder,NumberOfLayers,MultipleComponentTransformation)>
+<!ELEMENT ProgressionOrder (#PCDATA)>
+            <!-- Defined Progression Order Values are: -->
+            <!-- 0 = LRCP; 1 = RLCP; 2 = RPCL; 3 = PCRL; 4 = CPRL -->
+            <!-- where L = "layer", R = "resolution level", C = "component", P = "position". -->
+<!ELEMENT NumberOfLayers (#PCDATA)>
+<!ELEMENT MultipleComponentTransformation (#PCDATA)>
+            <!-- For MCT, 0 = none, 1 = transform first 3 components for efficiency, per Part I Annex G -->
+<!ELEMENT SPcod (NumberOfDecompositionLevels,CodeblockWidth,CodeblockHeight,CodeblockStyle,Transformation)>
+<!ELEMENT NumberOfDecompositionLevels (#PCDATA)>
+<!ELEMENT CodeblockWidth (#PCDATA)>   <!-- CBW and CBH are non-negative, and summed cannot exceed 8 -->
+<!ELEMENT CodeblockHeight (#PCDATA)>  <!-- Codeblock dimension is 2^(value + 2) -->
+<!ELEMENT CodeblockStyle (#PCDATA)>
+            <!-- For CodeblockStyle, bits mean (with value 1=feature on, 0=off): -->
+            <!-- bit 0: Selective arithmetic coding bypass. -->
+            <!-- bit 1: Reset context probabilities on coding pass boundaries. -->
+            <!-- bit 2: Termination on each coding pass. -->
+            <!-- bit 3: Vertically causal context. -->
+            <!-- bit 4: Predictable termination. -->
+            <!-- bit 5: Segmentation symbols are used. -->
+<!ELEMENT Transformation (#PCDATA)> <!-- For Transformation, 0="9-7 irreversible filter", 1="5-3 reversible filter" -->
+        <!-- mj2_to_metadata implementation always reports component[0] as using default COD, -->
+        <!-- and any other component, with main-header style values different from [0], as COC. -->
+<!ELEMENT QuantizationDefault (Sqcd,SPqcd)>
+<!ATTLIST QuantizationDefault Marker CDATA #FIXED "QCD">
+<!ELEMENT Sqcd (AsHex | (AsHex,QuantizationStyle,NumberOfGuardBits) | (QuantizationStyle,NumberOfGuardBits))>
+<!ELEMENT QuantizationStyle (#PCDATA)>  <!-- Default quantization style for all components. -->
+            <!-- Quantization style (in Sqcd's low 5 bits) may be: -->
+            <!--   0 = No quantization. SPqcd size = 8 bits-->
+            <!--   1 = Scalar derived (values signaled for N(L)LL subband only). Use Eq. E.5. SPqcd size = 16. -->
+            <!--   2 = Scalar expounded (values signaled for each subband). SPqcd size = 16. -->
+<!ELEMENT NumberOfGuardBits (#PCDATA)>  <!-- 0-7 guard bits allowed (stored in Sqcd's high 3 bits) -->
+<!ELEMENT SPqcd (ReversibleStepSizeValue | QuantizationStepSizeValues )>  <!-- TO DO: Irreversible choices -->
+<!ELEMENT ReversibleStepSizeValue (DynamicRangeExponent+)>
+            <!-- Current mj2_to_metadata implementation dumps entire internal table, -->
+            <!-- until an exponent with zero value is reached. -->
+            <!-- Exponent epsilon(b) of reversible dynamic range. -->
+            <!-- Hex value is as stored, in high-order 5 bits. -->
+<!ELEMENT DynamicRangeExponent (AsHex | (AsHex, AsDecimal) | AsDecimal)>
+<!ATTLIST DynamicRangeExponent Subband CDATA #REQUIRED>
+<!ELEMENT QuantizationStepSizeValues (QuantizationValues+, CalculatedExponent*)>  <!-- Calculated exponents iff only subband 0 reported -->
+<!ELEMENT QuantizationValues (AsHex | (AsHex,Exponent,Mantissa) | (Exponent,Mantissa))>
+<!ATTLIST QuantizationValues Subband CDATA #REQUIRED>
+<!ELEMENT Exponent (#PCDATA)>
+<!ELEMENT Mantissa (#PCDATA)>
+<!ELEMENT CalculatedExponent (#PCDATA)>
+<!ATTLIST CalculatedExponent Subband CDATA #REQUIRED>
+<!-- /QuantizationDefault -->
+        <!-- mj2_to_metadata implementation always reports component[0] as using default QCD, -->
+        <!-- and any other component, with main-header quantization values different from [0], as QCC. -->
+<!ELEMENT QuantizationComponent (Sqcc,SPqcc)>
+<!ATTLIST QuantizationComponent Marker CDATA #FIXED "QCC">
+<!ATTLIST QuantizationComponent Component CDATA #REQUIRED>
+<!ELEMENT Sqcc (AsHex | (AsHex,QuantizationStyle,NumberOfGuardBits) | (QuantizationStyle,NumberOfGuardBits))>
+<!ELEMENT SPqcc (ReversibleStepSizeValue | QuantizationStepSizeValues )>  <!-- TO DO: Irreversible choices -->
+<!-- /QuantizationComponent -->
+<!-- Don't know if MJ2 files can have regions of interest.  Assume yes -->
+<!ELEMENT RegionOfInterest (Srgn,Crgn,Sprgn)> <!-- Optional in main header, at most 1 per component -->
+<!ATTLIST RegionOfInterest Marker CDATA #FIXED "RGN">
+<!ELEMENT Srgn (#PCDATA)>  <!-- ROI style.  Only style=0 defined: Implicit ROI (max. shift) -->
+<!ELEMENT Crgn (#PCDATA)>  <!-- Zero-based component number. -->
+<!ELEMENT SPrgn (#PCDATA)> <!-- Implicit ROI shift, i.e., binary shifting of ROI coefficients above background. -->
+<!-- </RegionOfInterest> -->
+<!ELEMENT ProgressionOrderChange (Progression+)> <!-- Optional in main header, at most 1 per component (but impl allows more?) -->
+<!ATTLIST ProgressionOrderChange Marker CDATA #REQUIRED>
+<!ELEMENT Progression (RSpoc,CSpoc,LYEpoc,REpoc,CEpoc,Ppoc)>
+<!ATTLIST Progression Num CDATA #REQUIRED>
+<!ELEMENT RSpoc (#PCDATA)> <!-- Resolution level index (inclusive) for progression start. Range: 0 to 33 -->
+<!ELEMENT CSpoc (#PCDATA)> <!-- Component index (inclusive) for progression start. -->
+<!ELEMENT LYEpoc (#PCDATA)> <!-- Layer index (exclusive) for progression end. -->
+<!ELEMENT REpoc (#PCDATA)> <!-- Resolution level index (exclusive) for progression end. Range: RSpoc to 33 -->
+<!ELEMENT CEpoc (#PCDATA)> <!-- Component index (exclusive) for progression end.  Minimum: CSpoc -->
+<!ELEMENT Ppoc (#PCDATA)> <!-- Defined Progression Order Values are: -->
+                          <!-- 0 = LRCP; 1 = RLCP; 2 = RPCL; 3 = PCRL; 4 = CPRL -->
+                          <!-- where L = "layer", R = "resolution level", C = "component", P = "position". -->
+<!-- </Progression>, </ProgressionOrderChange -->
+<!-- /MainHeader -->
+<!ELEMENT TilePartHeaders (TilePartHeader+)>
+<!ATTLIST TilePartHeaders Count CDATA #REQUIRED>
+<!ELEMENT TilePartHeader (StartOfTilePart,CodingStyleDefault,QuantizationDefault,QuantizationComponent*,RegionOfInterest?,ProgressionOrderChange*,StartOfData)>
+<!ATTLIST TilePartHeader Num CDATA #REQUIRED>
+<!ATTLIST TilePartHeader ID CDATA #REQUIRED>
+<!ELEMENT StartOfTilePart EMPTY>
+<!ATTLIST StartOfTilePart Marker CDATA #FIXED "SOT">
+<!-- CodingStyleDefault, QuantizationDefault, QuantizationComponent already defined -->
+        <!-- mj2_to_metadata implementation always reports component[0] as using default QCD, -->
+        <!-- and any other component, with tile-part-header quantization values different from [0], as QCC. -->
+<!ELEMENT StartOfData EMPTY> <!-- always empty for now -->
+<!ATTLIST StartOfData Marker CDATA #FIXED "SOD">
+          <!-- Tile-part bitstream, not shown, follows tile-part header and SOD marker. -->
+<!-- /TilePartHeader, /TilePartHeaders, /JP2_Frame -->
+<!-- </Track> -->
+
+<!-- to come:
+  <MovieExtends mvek> // possibly not in Simple Profile
+  <UserDataBox udat> contains <CopyrightBox cprt>
+  -->
+<!-- /MovieBox -->
+<!-- To come:
+  <mdat>
+  <moof>  // probably not in Simple Profile
+  <free>
+  <skip>
+  -->
+<!-- </MJ2_File> -->
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.h.svn-base ./mj2/.svn/text-base/mj2_to_metadata.h.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.h.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,9 @@
+/* mj2_to_metadata.h */
+/* Dump MJ2, JP2 metadata (partial so far) to xml file */
+/* Contributed to Open JPEG by Glenn Pearson, U.S. National Library of Medicine */
+
+#define BOOL int
+#define FALSE 0
+#define TRUE 1
+
+#include "meta_out.h"
Binary files /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata_Notes.doc.svn-base and ./mj2/.svn/text-base/mj2_to_metadata_Notes.doc.svn-base differ
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.sln.svn-base ./mj2/.svn/text-base/mj2_to_metadata.sln.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.sln.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "mj2_to_metadata", "mj2_to_metadata.vcproj", "{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	ProjectSection(ProjectDependencies) = postProject
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD} = {0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.ActiveCfg = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Debug|Win32.Build.0 = Debug|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.ActiveCfg = Release|Win32
+		{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}.Release|Win32.Build.0 = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.ActiveCfg = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Debug|Win32.Build.0 = Debug|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.ActiveCfg = Release|Win32
+		{0B1B7713-35B6-40A7-9BFF-A7D0EB06A8BD}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.vcproj.svn-base ./mj2/.svn/text-base/mj2_to_metadata.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/mj2_to_metadata.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/mj2_to_metadata.vcproj.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,349 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="mj2_to_metadata"
+	ProjectGUID="{69BE42AB-E7CE-4DA1-BBD2-39FEA2C91E0B}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\mj2_to_metadata___Win32_Debug0"
+			IntermediateDirectory=".\mj2_to_metadata___Win32_Debug0"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\mj2_to_metadata___Win32_Debug0/"
+				ObjectFile=".\mj2_to_metadata___Win32_Debug0/"
+				ProgramDataBaseFileName=".\mj2_to_metadata___Win32_Debug0/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="LIBCMT"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\mj2_to_metadata___Win32_Debug0/mj2_to_metadata.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/mj2_to_metadata.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/mj2_to_metadata.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/mj2_to_metadata.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				ProgramDatabaseFile=".\Release/mj2_to_metadata.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/mj2_to_metadata.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="MJ2"
+			>
+			<Filter
+				Name="MJ2 Header Files"
+				>
+				<File
+					RelativePath="compat\getopt.h"
+					>
+				</File>
+				<File
+					RelativePath="meta_out.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_convert.h"
+					>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.h"
+					>
+				</File>
+			</Filter>
+			<Filter
+				Name="MJ2 Source Files"
+				>
+				<File
+					RelativePath="compat\getopt.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="meta_out.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_convert.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+				<File
+					RelativePath="mj2_to_metadata.c"
+					>
+					<FileConfiguration
+						Name="Debug|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+					<FileConfiguration
+						Name="Release|Win32"
+						>
+						<Tool
+							Name="VCCLCompilerTool"
+							AdditionalIncludeDirectories=""
+							PreprocessorDefinitions=""
+						/>
+					</FileConfiguration>
+				</File>
+			</Filter>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.dsp.svn-base ./mj2/.svn/text-base/MJ2_Wrapper.dsp.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Wrapper.dsp.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,195 @@
+# Microsoft Developer Studio Project File - Name="MJ2_Wrapper" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=MJ2_Wrapper - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "MJ2_Wrapper.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "MJ2_Wrapper.mak" CFG="MJ2_Wrapper - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "MJ2_Wrapper - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "MJ2_Wrapper - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "MJ2_Wrapper - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /I "../libopenjpeg" /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /c
+# ADD BASE RSC /l 0x809 /d "NDEBUG"
+# ADD RSC /l 0x809 /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+
+!ELSEIF  "$(CFG)" == "MJ2_Wrapper - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "MJ2_Wrapper___Win32_Debug"
+# PROP BASE Intermediate_Dir "MJ2_Wrapper___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "MJ2_Wrapper___Win32_Debug"
+# PROP Intermediate_Dir "MJ2_Wrapper___Win32_Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MT /W3 /Gm /GX /ZI /Od /I "../libopenjpeg" /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /D "OPJ_STATIC" /FR /YX /FD /GZ /c
+# ADD BASE RSC /l 0x809 /d "_DEBUG"
+# ADD RSC /l 0x809 /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /nodefaultlib:"libcmt" /pdbtype:sept
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "MJ2_Wrapper - Win32 Release"
+# Name "MJ2_Wrapper - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\mj2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\wrap_j2k_in_mj2.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\mj2.h
+# End Source File
+# End Group
+# Begin Group "OpenJPEG Header Files"
+
+# PROP Default_Filter ""
+# Begin Source File
+
+SOURCE=..\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=..\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.dsw.svn-base ./mj2/.svn/text-base/MJ2_Wrapper.dsw.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Wrapper.dsw.svn-base	2007-09-28 11:33:41.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG"="..\LibOpenJPEG.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "MJ2_Wrapper"=".\MJ2_Wrapper.dsp" - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.sln.svn-base ./mj2/.svn/text-base/MJ2_Wrapper.sln.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Wrapper.sln.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,29 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "MJ2_Wrapper", "MJ2_Wrapper.vcproj", "{87C98B26-E658-4992-8810-201C3CE67011}"
+	ProjectSection(ProjectDependencies) = postProject
+		{4F27AA53-4181-4A1A-8238-3931B0A41048} = {4F27AA53-4181-4A1A-8238-3931B0A41048}
+	EndProjectSection
+EndProject
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "..\LibOpenJPEG.vcproj", "{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.ActiveCfg = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Debug|Win32.Build.0 = Debug|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.ActiveCfg = Release|Win32
+		{87C98B26-E658-4992-8810-201C3CE67011}.Release|Win32.Build.0 = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.ActiveCfg = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Debug|Win32.Build.0 = Debug|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.ActiveCfg = Release|Win32
+		{4F27AA53-4181-4A1A-8238-3931B0A41048}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.vcproj.svn-base ./mj2/.svn/text-base/MJ2_Wrapper.vcproj.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/MJ2_Wrapper.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/MJ2_Wrapper.vcproj.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,353 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="MJ2_Wrapper"
+	ProjectGUID="{87C98B26-E658-4992-8810-201C3CE67011}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\Release/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;NDEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\Release/MJ2_Wrapper.exe"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\MJ2_Wrapper___Win32_Debug"
+			IntermediateDirectory=".\MJ2_Wrapper___Win32_Debug"
+			ConfigurationType="1"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				TypeLibraryName=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				AdditionalIncludeDirectories="../libopenjpeg"
+				PreprocessorDefinitions="WIN32;_DEBUG;_CONSOLE;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="0"
+				PrecompiledHeaderFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pch"
+				AssemblerListingLocation=".\MJ2_Wrapper___Win32_Debug/"
+				ObjectFile=".\MJ2_Wrapper___Win32_Debug/"
+				ProgramDataBaseFileName=".\MJ2_Wrapper___Win32_Debug/"
+				BrowseInformation="1"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="2057"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.exe"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				IgnoreDefaultLibraryNames="libcmtd"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.pdb"
+				SubSystem="1"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\MJ2_Wrapper___Win32_Debug/MJ2_Wrapper.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="wrap_j2k_in_mj2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						AdditionalIncludeDirectories=""
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="mj2.h"
+				>
+			</File>
+		</Filter>
+		<Filter
+			Name="OpenJPEG Header Files"
+			>
+			<File
+				RelativePath="..\libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="..\libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/readme.txt.svn-base ./mj2/.svn/text-base/readme.txt.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/readme.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/readme.txt.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,3 @@
+Attention : the motion jpeg 2000 files currently only work with OpenJPEG v0.97 that you can find here : 
+
+http://www.openjpeg.org/openjpeg_v097.tar.gz
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/mj2/.svn/text-base/wrap_j2k_in_mj2.c.svn-base ./mj2/.svn/text-base/wrap_j2k_in_mj2.c.svn-base
--- /home/robin/sldeb/trunk/mj2/.svn/text-base/wrap_j2k_in_mj2.c.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./mj2/.svn/text-base/wrap_j2k_in_mj2.c.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,348 @@
+/*
+ * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+ * Copyright (c) 2002-2007, Professor Benoit Macq
+ * Copyright (c) 2003-2007, Francois-Olivier Devaux 
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
+#include "mj2.h"
+
+static int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+
+/**
+Size of memory first allocated for MOOV box
+*/
+#define TEMP_BUF 10000 
+
+
+/* -------------------------------------------------------------------------- */
+
+/**
+sample error callback expecting a FILE* client object
+*/
+void error_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[ERROR] %s", msg);
+}
+/**
+sample warning callback expecting a FILE* client object
+*/
+void warning_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[WARNING] %s", msg);
+}
+/**
+sample debug callback expecting a FILE* client object
+*/
+void info_callback(const char *msg, void *client_data) {
+	FILE *stream = (FILE*)client_data;
+	fprintf(stream, "[INFO] %s", msg);
+}
+
+/* -------------------------------------------------------------------------- */
+
+
+
+static void read_siz_marker(FILE *file, opj_image_t *image)
+{
+  int len,i;
+  char buf, buf2[2];
+  char *siz_buffer;
+	opj_cio_t *cio;
+  
+  fseek(file, 0, SEEK_SET);
+  do {
+    fread(&buf,1,1, file);
+    if (buf==(char)0xff)
+      fread(&buf,1,1, file);
+  }
+  while (!(buf==(char)0x51));
+  
+  fread(buf2,2,1,file);		/* Lsiz                */
+  len = ((buf2[0])<<8) + buf2[1];
+  
+  siz_buffer = (char*) malloc(len * sizeof(char));
+  fread(siz_buffer,len, 1, file);
+	cio = opj_cio_open(NULL, siz_buffer, len);
+  
+  cio_read(cio, 2);			/* Rsiz (capabilities) */
+  image->x1 = cio_read(cio, 4);	/* Xsiz                */
+  image->y1 = cio_read(cio, 4);	/* Ysiz                */
+  image->x0 = cio_read(cio, 4);	/* X0siz               */
+  image->y0 = cio_read(cio, 4);	/* Y0siz               */
+  cio_skip(cio, 16);			/* XTsiz, YTsiz, XT0siz, YT0siz        */
+  
+  image->numcomps = cio_read(cio,2);	/* Csiz                */
+  image->comps =
+    (opj_image_comp_t *) malloc(image->numcomps * sizeof(opj_image_comp_t));
+	
+  for (i = 0; i < image->numcomps; i++) {
+    int tmp;
+    tmp = cio_read(cio,1);		/* Ssiz_i          */
+    image->comps[i].prec = (tmp & 0x7f) + 1;
+    image->comps[i].sgnd = tmp >> 7;
+    image->comps[i].dx = cio_read(cio,1);	/* XRsiz_i         */
+    image->comps[i].dy = cio_read(cio,1);	/* YRsiz_i         */
+    image->comps[i].resno_decoded = 0;	/* number of resolution decoded */
+    image->comps[i].factor = 0;	/* reducing factor by component */
+  }
+  fseek(file, 0, SEEK_SET);
+	opj_cio_close(cio);
+}
+
+static void setparams(opj_mj2_t *movie, opj_image_t *image) {
+  int i, depth_0, depth, sign;
+  
+  movie->tk[0].sample_rate = 25;
+  movie->tk[0].w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
+  movie->tk[0].h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
+  mj2_init_stdmovie(movie);
+  
+  movie->tk[0].depth = image->comps[0].prec;
+	
+  if (image->numcomps==3) {
+    if ((image->comps[0].dx == 1) && (image->comps[1].dx == 1) && (image->comps[1].dx == 1)) 
+      movie->tk[0].CbCr_subsampling_dx = 1;
+    else if ((image->comps[0].dx == 1) && (image->comps[1].dx == 2) && (image->comps[1].dx == 2))
+      movie->tk[0].CbCr_subsampling_dx = 2;
+    else
+      fprintf(stderr,"Image component sizes are incoherent\n");
+    
+    if ((image->comps[0].dy == 1) && (image->comps[1].dy == 1) && (image->comps[1].dy == 1)) 
+      movie->tk[0].CbCr_subsampling_dy = 1;
+    else if ((image->comps[0].dy == 1) && (image->comps[1].dy == 2) && (image->comps[1].dy == 2))
+      movie->tk[0].CbCr_subsampling_dy = 2;
+    else
+      fprintf(stderr,"Image component sizes are incoherent\n");
+  }
+  
+  movie->tk[0].sample_rate = 25;
+  
+  movie->tk[0].jp2_struct.numcomps = image->numcomps;	// NC  
+	
+	/* Init Standard jp2 structure */
+	
+	movie->tk[0].jp2_struct.comps =
+    (opj_jp2_comps_t *) malloc(movie->tk[0].jp2_struct.numcomps * sizeof(opj_jp2_comps_t));
+  movie->tk[0].jp2_struct.precedence = 0;   /* PRECEDENCE*/
+  movie->tk[0].jp2_struct.approx = 0;   /* APPROX*/
+  movie->tk[0].jp2_struct.brand = JP2_JP2;	/* BR         */
+  movie->tk[0].jp2_struct.minversion = 0;	/* MinV       */
+  movie->tk[0].jp2_struct.numcl = 1;
+  movie->tk[0].jp2_struct.cl = (unsigned int *) malloc(movie->tk[0].jp2_struct.numcl * sizeof(int));
+  movie->tk[0].jp2_struct.cl[0] = JP2_JP2;	/* CL0 : JP2  */
+  movie->tk[0].jp2_struct.C = 7;      /* C : Always 7*/
+  movie->tk[0].jp2_struct.UnkC = 0;      /* UnkC, colorspace specified in colr box*/
+  movie->tk[0].jp2_struct.IPR = 0;      /* IPR, no intellectual property*/
+  movie->tk[0].jp2_struct.w = int_ceildiv(image->x1 - image->x0, image->comps[0].dx);
+  movie->tk[0].jp2_struct.h = int_ceildiv(image->y1 - image->y0, image->comps[0].dy);
+  
+  depth_0 = image->comps[0].prec - 1;
+  sign = image->comps[0].sgnd;
+  movie->tk[0].jp2_struct.bpc = depth_0 + (sign << 7);
+  
+  for (i = 1; i < image->numcomps; i++) {
+    depth = image->comps[i].prec - 1;
+    sign = image->comps[i].sgnd;
+    if (depth_0 != depth)
+      movie->tk[0].jp2_struct.bpc = 255;
+  }
+  
+  for (i = 0; i < image->numcomps; i++)
+    movie->tk[0].jp2_struct.comps[i].bpcc =
+    image->comps[i].prec - 1 + (image->comps[i].sgnd << 7);
+  
+  if ((image->numcomps == 1 || image->numcomps == 3)
+    && (movie->tk[0].jp2_struct.bpc != 255))
+    movie->tk[0].jp2_struct.meth = 1;
+  else
+    movie->tk[0].jp2_struct.meth = 2;
+	
+  if (image->numcomps == 1)
+    movie->tk[0].jp2_struct.enumcs = 17;  // Grayscale
+  
+  else   if ((image->comps[0].dx == 1) && (image->comps[1].dx == 1) && (image->comps[1].dx == 1) &&
+    (image->comps[0].dy == 1) && (image->comps[1].dy == 1) && (image->comps[1].dy == 1)) 
+    movie->tk[0].jp2_struct.enumcs = 16;    // RGB
+  
+  else   if ((image->comps[0].dx == 1) && (image->comps[1].dx == 2) && (image->comps[1].dx == 2) &&
+    (image->comps[0].dy == 1) && (image->comps[1].dy == 2) && (image->comps[1].dy == 2)) 
+    movie->tk[0].jp2_struct.enumcs = 18;  // YUV
+  
+  else
+    movie->tk[0].jp2_struct.enumcs = 0;	// Unkown profile */
+}
+
+int main(int argc, char *argv[]) {
+	opj_cinfo_t* cinfo; 
+	opj_event_mgr_t event_mgr;		/* event manager */  
+  unsigned int snum;
+  opj_mj2_t *movie;
+  mj2_sample_t *sample;
+  unsigned char* frame_codestream;
+  FILE *mj2file, *j2kfile;
+  char j2kfilename[50];
+  char *buf;
+  int offset, mdat_initpos;
+  opj_image_t img;
+ 	opj_cio_t *cio;
+	mj2_cparameters_t parameters;
+	
+  if (argc != 3) {
+    printf("Bad syntax: Usage: MJ2_Wrapper source_location mj2_filename\n");
+    printf("Example: MJ2_Wrapper input/input output.mj2\n");
+    return 1;
+  }
+  
+  mj2file = fopen(argv[2], "wb");
+  
+  if (!mj2file) {
+    fprintf(stderr, "failed to open %s for writing\n", argv[2]);
+    return 1;
+  }
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = error_callback;
+	event_mgr.warning_handler = warning_callback;
+	event_mgr.info_handler = info_callback;
+
+	/* get a MJ2 decompressor handle */
+	cinfo = mj2_create_compress();
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);	
+	
+	/* setup the decoder encoding parameters using user parameters */
+	movie = (opj_mj2_t*) cinfo->mj2_handle;
+	mj2_setup_encoder(cinfo->mj2_handle, &parameters);
+
+  
+	/* Writing JP, FTYP and MDAT boxes 
+	Assuming that the JP and FTYP boxes won't be longer than 300 bytes */
+	
+  buf = (char*) malloc (300 * sizeof(char)); 
+  cio = opj_cio_open(movie->cinfo, buf, 300);
+  mj2_write_jp(cio);
+  mj2_write_ftyp(movie, cio);
+  mdat_initpos = cio_tell(cio);
+  cio_skip(cio, 4);
+  cio_write(cio,MJ2_MDAT, 4);	
+  fwrite(buf,cio_tell(cio),1,mj2file);
+  free(buf);
+	
+  // Insert each j2k codestream in a JP2C box  
+  snum=0;
+  offset = 0;  
+  while(1)
+  {
+    sample = &movie->tk[0].sample[snum];
+    sprintf(j2kfilename,"%s_%05d.j2k",argv[1],snum);
+    j2kfile = fopen(j2kfilename, "rb");
+    if (!j2kfile) {
+      if (snum==0) {  // Could not open a single codestream
+				fprintf(stderr, "failed to open %s for reading\n",j2kfilename);
+				return 1;
+      }
+      else {	      // Tried to open a inexistant codestream
+				fprintf(stdout,"%d frames are being added to the MJ2 file\n",snum);
+				break;
+      }
+    }
+
+    // Calculating offset for samples and chunks
+    offset += cio_tell(cio);     
+    sample->offset = offset;
+    movie->tk[0].chunk[snum].offset = offset;  // There will be one sample per chunk
+    
+    // Calculating sample size
+    fseek(j2kfile,0,SEEK_END);	
+    sample->sample_size = ftell(j2kfile) + 8; // Sample size is codestream + JP2C box header
+    fseek(j2kfile,0,SEEK_SET);
+    
+    // Reading siz marker of j2k image for the first codestream
+    if (snum==0)	      
+      read_siz_marker(j2kfile, &img);
+    
+    // Writing JP2C box header			    
+    frame_codestream = (unsigned char*) malloc (sample->sample_size+8); 
+		cio = opj_cio_open(movie->cinfo, frame_codestream, sample->sample_size);    
+    cio_write(cio,sample->sample_size, 4);  // Sample size
+    cio_write(cio,JP2_JP2C, 4);	// JP2C
+    
+    // Writing codestream from J2K file to MJ2 file
+    fread(frame_codestream+8,sample->sample_size-8,1,j2kfile);
+    fwrite(frame_codestream,sample->sample_size,1,mj2file);
+    cio_skip(cio, sample->sample_size-8);
+    
+    // Ending loop
+    fclose(j2kfile);
+    snum++;
+    movie->tk[0].sample = realloc(movie->tk[0].sample, (snum+1) * sizeof(mj2_sample_t));
+    movie->tk[0].chunk = realloc(movie->tk[0].chunk, (snum+1) * sizeof(mj2_chunk_t));
+    free(frame_codestream);
+  }
+  
+  // Writing the MDAT box length in header
+  offset += cio_tell(cio);
+  buf = (char*) malloc (4 * sizeof(char));
+	cio = opj_cio_open(movie->cinfo, buf, 4);
+  cio_write(cio,offset-mdat_initpos,4); 
+  fseek(mj2file,(long)mdat_initpos,SEEK_SET);
+  fwrite(buf,4,1,mj2file);
+  fseek(mj2file,0,SEEK_END);
+  free(buf);
+	
+  // Setting movie parameters
+  movie->tk[0].num_samples=snum;
+  movie->tk[0].num_chunks=snum;
+  setparams(movie, &img);
+	
+  // Writing MOOV box 
+	buf = (char*) malloc ((TEMP_BUF+snum*20) * sizeof(char));
+	cio = opj_cio_open(movie->cinfo, buf, (TEMP_BUF+snum*20));
+	mj2_write_moov(movie, cio);
+  fwrite(buf,cio_tell(cio),1,mj2file);
+	
+  // Ending program
+  fclose(mj2file);
+  free(img.comps);
+  opj_cio_close(cio);
+  mj2_destroy_compress(movie);
+	
+  return 0;
+}
diff -urN /home/robin/sldeb/trunk/mj2/wrap_j2k_in_mj2.c ./mj2/wrap_j2k_in_mj2.c
--- /home/robin/sldeb/trunk/mj2/wrap_j2k_in_mj2.c	2007-05-10 15:21:09.000000000 +0100
+++ ./mj2/wrap_j2k_in_mj2.c	2007-11-27 22:39:50.000000000 +0000
@@ -26,9 +26,20 @@
  * POSSIBILITY OF SUCH DAMAGE.
  */
 
-#include "opj_includes.h"
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "openjpeg.h"
+#include "j2k.h"
+#include "jp2.h"
+#include "cio.h"
 #include "mj2.h"
 
+static int int_ceildiv(int a, int b) {
+	return (a + b - 1) / b;
+}
+
 /**
 Size of memory first allocated for MOOV box
 */
diff -urN /home/robin/sldeb/trunk/OpenJPEG.rc ./OpenJPEG.rc
--- /home/robin/sldeb/trunk/OpenJPEG.rc	2006-12-04 15:52:19.000000000 +0000
+++ ./OpenJPEG.rc	2007-09-28 11:33:52.000000000 +0100
@@ -49,7 +49,7 @@
             VALUE "FileDescription", "OpenJPEG\0"
             VALUE "FileVersion", "1, 1, 0, 0\0"
             VALUE "InternalName", "OpenJPEG\0"
-            VALUE "LegalCopyright", "Copyright © 2002-2006, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium\0"
+            VALUE "LegalCopyright", "Copyright © 2002-2007, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium\0"
             VALUE "LegalTrademarks", "See http://www.openjpeg.org for details\0"
             VALUE "OriginalFilename", "OpenJPEG.dll\0"
             VALUE "PrivateBuild", "\0"
diff -urN /home/robin/sldeb/trunk/OPJViewer/about/.svn/all-wcprops ./OPJViewer/about/.svn/all-wcprops
--- /home/robin/sldeb/trunk/OPJViewer/about/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/about/.svn/all-wcprops	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,17 @@
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/364/trunk/OPJViewer/about
+END
+about.htm
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/364/trunk/OPJViewer/about/about.htm
+END
+opj_logo.png
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/356/trunk/OPJViewer/about/opj_logo.png
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/about/.svn/entries ./OPJViewer/about/.svn/entries
--- /home/robin/sldeb/trunk/OPJViewer/about/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/about/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,53 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/OPJViewer/about
+http://www.openjpeg.org/svn
+
+
+
+2007-03-27T12:48:17.101066Z
+364
+unipg
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+about.htm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+c4f2de4efe8c9df30f734911c95ca532
+2007-03-27T12:48:17.101066Z
+364
+unipg
+
+opj_logo.png
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+7019df653f131c69eed3f78449cddd4b
+2007-03-01T00:01:37.891000Z
+356
+unipg
+has-props
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/about/.svn/format ./OPJViewer/about/.svn/format
--- /home/robin/sldeb/trunk/OPJViewer/about/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/about/.svn/format	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/OPJViewer/about/.svn/prop-base/opj_logo.png.svn-base ./OPJViewer/about/.svn/prop-base/opj_logo.png.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/about/.svn/prop-base/opj_logo.png.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/about/.svn/prop-base/opj_logo.png.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/about/.svn/text-base/about.htm.svn-base ./OPJViewer/about/.svn/text-base/about.htm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/about/.svn/text-base/about.htm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/about/.svn/text-base/about.htm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,36 @@
+<html>
+<body bgcolor="#FFFFFF">
+<table cellspacing=7 cellpadding=1 border=0 width="100%">
+<tr>
+<td rowspan=3 valign=top align=center width=70>
+<img src="opj_logo.png"><br><br>
+</td>
+<td align=center>
+<font size=+2 color="#000000"><b>OPJViewer v0.2 alpha</b></font><br>
+<font size=+0 color="#000000"><b>A JPEG 2000 image viewer</b></font>
+</td>
+</tr>
+<tr height=3 valign=center>
+<td valign=center  bgcolor=#cc3300></td>
+</tr>
+<tr>
+<td align=justify>
+<center><font size=+0 color="#000000"><a href="http://www.openjpeg.org/">OpenJPEG</a></font></center>
+<font size=-1 color="#000000">The OpenJPEG library is an open-source JPEG 2000 codec written in C language.
+In addition to the basic codec, various other features are under development,
+among them the JP2 and MJ2 (Motion JPEG 2000) file formats, an indexing tool
+useful for the JPIP protocol, JPWL-tools for error-resilience, ...</font>
+</td>
+</tr>
+<tr>
+<td colspan=2 bgcolor="#CC3300" height=3 valign=center></td>
+</tr>
+<tr>
+<td colspan=2>
+<font size=-2 color="#444444">OpenJPEG is &copy; 2002-2007 <a href="http://www.tele.ucl.ac.be/">TELE</a> - <a href="http://www.uclouvain.be/">Université Catholique de Louvain</a></font><br>
+<font size=-2 color="#444444">OPJViewer is also &copy; 2005-2007 <a href="http://dsplab.diei.unipg.it/">DSPLab</a> - <a href="http://www.unipg.it/">Università degli studi di Perugia</a></font>
+</td>
+</tr>
+</table>
+</body>
+</html>
Binary files /home/robin/sldeb/trunk/OPJViewer/about/.svn/text-base/opj_logo.png.svn-base and ./OPJViewer/about/.svn/text-base/opj_logo.png.svn-base differ
diff -urN /home/robin/sldeb/trunk/OPJViewer/buildupdate.bat ./OPJViewer/buildupdate.bat
--- /home/robin/sldeb/trunk/OPJViewer/buildupdate.bat	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/buildupdate.bat	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,15 @@
+::== buildupdate.bat
+@echo off
+setLocal EnableDelayedExpansion
+
+for /f "tokens=2,* delims=^(^) " %%a in ('find /v "" ^< .\source\build.h') do (
+rem echo %%a
+set /A M = %%a + 1
+echo Build %%a done^!
+echo wxT^("!M!"^) > buildtemp283746825t347
+)
+
+if exist buildtemp283746825t347 move /Y buildtemp283746825t347 .\source\build.h
+if exist buildtemp283746825t347 del /F /Q buildtemp283746825t347
+
+::==
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/OPJViewer/Makefile ./OPJViewer/Makefile
--- /home/robin/sldeb/trunk/OPJViewer/Makefile	2007-03-30 10:27:08.000000000 +0100
+++ ./OPJViewer/Makefile	2007-11-27 22:39:50.000000000 +0000
@@ -1,41 +1,41 @@
-# Makefile for the main JPWL OpenJPEG codecs: JPWL_ j2k_to_image and JPWL_image_to_j2k
-
-# General configuration variables:
-CC = $(shell wx-config-2.8 --cxx)
-AR = ar
-
-CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
-
-OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp
-
-MODULES = $(OPJV_SRCS:.cpp=.o)
-
-all: opjviewer lib
-
-.cpp.o:
-	$(CC) $(CFLAGS) -c $< -o $@
-
-lib:
-	cd ../jpwl; make
-
-opjviewer: $(OPJV_SRCS) lib
-	$(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)  
-
-
-clean:
-	rm -f OPJViewer *.o *.a
-	cd ../libopenjpeg; rm -f *.o
-
-
-
-
-#.cpp.o :
-#	$(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
-
-#all:    $(PROGRAM)
-
-#$(PROGRAM):     $(OBJECTS)
-#	$(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
-
-#clean:
-#	rm -f *.o $(PROGRAM)
+# Makefile for OPJViewer
+
+# General configuration variables:
+CC = $(shell wx-config-2.8 --cxx)
+AR = ar
+
+CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
+
+OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp
+
+MODULES = $(OPJV_SRCS:.cpp=.o)
+
+all: opjviewer lib
+
+.cpp.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+lib:
+	cd ../jpwl; make
+
+opjviewer: $(OPJV_SRCS) lib
+        $(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)
+
+
+clean:
+	rm -f OPJViewer *.o *.a
+	cd ../libopenjpeg; rm -f *.o
+
+
+
+
+#.cpp.o :
+#       $(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
+
+#all:    $(PROGRAM)
+
+#$(PROGRAM):     $(OBJECTS)
+#       $(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
+
+#clean:
+#       rm -f *.o $(PROGRAM)
diff -urN /home/robin/sldeb/trunk/OPJViewer/OPJViewer.dsp ./OPJViewer/OPJViewer.dsp
--- /home/robin/sldeb/trunk/OPJViewer/OPJViewer.dsp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/OPJViewer.dsp	2007-11-27 22:39:50.000000000 +0000
@@ -42,16 +42,21 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
-# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "c:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /FR /FD /c
+# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /D "OPJ_INICONFIG" /FR /FD /c
 # ADD BASE RSC /l 0x410 /d "NDEBUG"
-# ADD RSC /l 0x409 /i "c:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
+# ADD RSC /l 0x409 /i "d:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
 BSC32=bscmake.exe
 # ADD BASE BSC32 /nologo
 # ADD BSC32 /nologo
 LINK32=link.exe
 # ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
-# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"c:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
 # SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Desc=Update build number
+PostBuild_Cmds=buildupdate.bat
+# End Special Build Tool
 
 !ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
 
@@ -67,7 +72,7 @@
 # PROP Ignore_Export_Lib 0
 # PROP Target_Dir ""
 # ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
-# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "d:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "d:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
 # ADD BASE RSC /l 0x410 /d "_DEBUG"
 # ADD RSC /l 0x410 /i "d:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
 BSC32=bscmake.exe
@@ -106,6 +111,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\OPJDialogs.cpp
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\OPJViewer.cpp
 # End Source File
 # Begin Source File
@@ -126,6 +135,19 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\build.h
+
+!IF  "$(CFG)" == "OPJViewer - Win32 Release"
+
+# PROP Exclude_From_Build 1
+
+!ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\imagj2k.h
 # End Source File
 # Begin Source File
@@ -146,6 +168,50 @@
 # PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
 # Begin Source File
 
+SOURCE=.\source\wx\msw\blank.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\bullseye.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cdrom.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\computer.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cross.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\drive.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\file1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\floppy.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder2.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\hand.cur
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\icon1.xpm
 # End Source File
 # Begin Source File
@@ -166,6 +232,10 @@
 # End Source File
 # Begin Source File
 
+SOURCE=.\source\wx\msw\magnif1.cur
+# End Source File
+# Begin Source File
+
 SOURCE=.\source\opj_logo.xpm
 # End Source File
 # Begin Source File
@@ -188,6 +258,38 @@
 
 SOURCE=.\source\OPJViewer16.xpm
 # End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pbrush.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pencil.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntleft.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntright.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\removble.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\rightarr.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\roller.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\std.ico
+# End Source File
 # End Group
 # End Target
 # End Project
diff -urN /home/robin/sldeb/trunk/OPJViewer/OPJViewer.iss ./OPJViewer/OPJViewer.iss
--- /home/robin/sldeb/trunk/OPJViewer/OPJViewer.iss	2007-04-27 18:20:26.000000000 +0100
+++ ./OPJViewer/OPJViewer.iss	2007-09-28 11:33:50.000000000 +0100
@@ -42,3 +42,7 @@
 
 [Run]
 Filename: {app}\OPJViewer.exe; Description: {cm:LaunchProgram,OPJViewer}; Flags: nowait postinstall skipifsilent; WorkingDir: {app}
+
+[Registry]
+Root: HKCU; Subkey: Software\OpenJPEG; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
+Root: HKCU; Subkey: Software\OpenJPEG\OPJViewer; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
diff -urN /home/robin/sldeb/trunk/OPJViewer/Readme.txt ./OPJViewer/Readme.txt
--- /home/robin/sldeb/trunk/OPJViewer/Readme.txt	2007-04-22 23:41:01.000000000 +0100
+++ ./OPJViewer/Readme.txt	2007-09-28 11:33:50.000000000 +0100
@@ -1,13 +1,8 @@
-===============================================================================
-
+===============================================================================
 	JPEG2000 Visualization Software - OPJViewer
 
-		Version 0.1 alpha
-
-===============================================================================
-
-
-
+		Version 0.3 alpha
+===============================================================================
 
 
 1. Scope
@@ -15,7 +10,7 @@
 
 This document describes the installation and use of the OPJViewer in the framework of OpenJPEG library.
 
-This implementation has been developed using the OpenJPEG library as decoding engine and wxWidgets 2.8.0 as GUI engine.
+This implementation has been developed using the OpenJPEG library as decoding engine and wxWidgets 2.8 as GUI engine.
 
 If you find some bugs or if you have problems using the viewer, please send an e-mail to jpwl@diei.unipg.it
 
@@ -27,7 +22,7 @@
 a) compile from source code
 b) download a precompiled binary.
 
-In order to use option a), it is mandatory to have compiled and built the LibOpenJPEG_JPWL library and the wxWidgets 2.8.0 framework (you have to download it from http://www.wxwidgets.org/ and compile the wx* libraries).
+In order to use option a), it is mandatory to have compiled and built the LibOpenJPEG_JPWL library and the wxWidgets 2.8 framework (you have to download it from http://www.wxwidgets.org/ and compile the wx* libraries).
 
 2.1. Compiling the source code in Windows
 -------------------------------------------
@@ -52,8 +47,7 @@
 3. General information on the viewer
 ====================================
 
-This viewer is conceived to open and display information and image content of J2K, JP2,
-and MJ2 files.
+This viewer is conceived to open and display information and image content of J2K, JP2, and MJ2 files.
 The viewer application interface is divided into three main panels:
 - a browsing pane;
 - a viewing pane;
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/about_htm.h ./OPJViewer/source/about_htm.h
--- /home/robin/sldeb/trunk/OPJViewer/source/about_htm.h	2007-03-29 09:27:03.000000000 +0100
+++ ./OPJViewer/source/about_htm.h	2007-11-27 22:39:50.000000000 +0000
@@ -1,29 +1,31 @@
 wxString htmlaboutpage = wxT(
 "<html>"
 "<body bgcolor=#FFFFFF>"
-"<table cellspacing=7 cellpadding=1 border=0 width=100%>"
+"<table cellspacing=7 cellpadding=1 border=0 width=100%>"   
 "<tr>"
 "<td rowspan=3 valign=top align=center width=70>"
-"<img src=\"memory:opj_logo.xpm\"><br><br>"
+"<img src=\"memory:opj_logo.xpm\"><br><br>" 
 "</td>"
 "<td align=center>"
-"<font size=+0 color=#000000><b>"
-OPJ_APPLICATION " " OPJ_APPLICATION_VERSION
+"<font size=+0 color=#000000><b>" 
+OPJ_APPLICATION " " OPJ_APPLICATION_VERSION 
 "</b></font><br>"
-"<font size=-1 color=#000000><b>A JPEG 2000 image viewer</b></font><br>"
-"<font size=-2 color=#000000><b>" OPJ_APPLICATION_PLATFORM " version</b></font>"
+"<font size=-1 color=#000000><b>A JPEG 2000 image viewer</b></font><br>"  
+"<font size=-2 color=#000000><b>" OPJ_APPLICATION_PLATFORM " version</b></font>"  
 "</td>"
 "</tr>"
-"<tr height=3 valign=center>"
-"<td valign=center  bgcolor=#cc3300></td>"
+"<tr height=3 valign=center>"  
+"<td valign=center  bgcolor=#cc3300></td>"   
 "</tr>"
 "<tr>"
 "<td align=justify>"
 "<center><font size=+0 color=#000000><a href=\"http://www.openjpeg.org/\">OpenJPEG</a></font></center>"
 "<font size=-1 color=#000000>The OpenJPEG library is an open-source JPEG 2000 codec written in C language. "
 "In addition to the basic codec, various other features are under development.</font><br>"
-"<font size=-2 color=red>* Build: " wxVERSION_STRING ", " __DATE__ ", " __TIME__ "</font><br>"
-)
+"<font size=-2 color=red>* Build: ")
+#include "build.h"
+wxT(", " __DATE__ ", " __TIME__ "</font><br>")
+wxT("<font size=-2 color=red>* " wxVERSION_STRING "</font><br>")
 #ifdef USE_JPWL
 wxT("<font size=-2 color=green>- Compiled with JPWL support</font><br>")
 #endif // USE_JPWL
@@ -33,7 +35,7 @@
 wxT("</td>"
 "</tr>"
 "<tr>"
-"<td colspan=2 bgcolor=#CC3300 height=3 valign=center></td>"
+"<td colspan=2 bgcolor=#CC3300 height=3 valign=center></td>" 
 "</tr>"
 "<tr>"
 "<td colspan=2>"
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/build.h ./OPJViewer/source/build.h
--- /home/robin/sldeb/trunk/OPJViewer/source/build.h	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/build.h	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1 @@
+wxT("292") 
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/imagj2k.cpp ./OPJViewer/source/imagj2k.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/imagj2k.cpp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/imagj2k.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -131,6 +131,7 @@
 	unsigned char *src = NULL;
     unsigned char *ptr;
 	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -188,7 +189,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 #ifndef __WXGTK__ 
 		wxMutexGuiEnter();
@@ -230,18 +231,475 @@
 
 }
 
+#define CINEMA_24_CS 1302083	/* Codestream length for 24fps */
+#define CINEMA_48_CS 651041		/* Codestream length for 48fps */
+#define COMP_24_CS 1041666		/* Maximum size per color component for 2K & 4K @ 24fps */
+#define COMP_48_CS 520833		/* Maximum size per color component for 2K @ 48fps */
+
 // save the j2k codestream
-bool wxJ2KHandler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )
+bool wxJ2KHandler::SaveFile( wxImage *wimage, wxOutputStream& stream, bool verbose )
 {
+	opj_cparameters_t parameters;	/* compression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *oimage = NULL;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;
+	int codestream_length;
+	bool bSuccess;
+	int i;
+	char indexfilename[OPJ_PATH_LEN] = "";	/* index file name */
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = j2k_error_callback;
+	event_mgr.warning_handler = j2k_warning_callback;
+	event_mgr.info_handler = j2k_info_callback;
+
+	/* set encoding parameters to default values */
+	opj_set_default_encoder_parameters(&parameters);
+
+	/* load parameters */
+	parameters.cp_cinema = OFF;
+
+	/* subsampling */
+	if (sscanf(m_subsampling.ToAscii(), "%d,%d", &(parameters.subsampling_dx), &(parameters.subsampling_dy)) != 2) {
+		wxLogError(wxT("Wrong sub-sampling encoder setting: dx,dy"));
+		return false;
+	}
+
+	/* compression rates */
+	if ((m_rates != wxT("")) && (!m_enablequality)) {
+		const char *s1 = m_rates.ToAscii();
+		wxLogMessage(wxT("rates %s"), s1);
+		while (sscanf(s1, "%f", &(parameters.tcp_rates[parameters.tcp_numlayers])) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s1 && *s1 != ',') {
+				s1++;
+			}
+			if (!*s1)
+				break;
+			s1++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* image quality, dB */
+	if ((m_quality != wxT("")) && (m_enablequality)) {
+		const char *s2 = m_quality.ToAscii();
+		wxLogMessage(wxT("qualities %s"), s2);
+		while (sscanf(s2, "%f", &parameters.tcp_distoratio[parameters.tcp_numlayers]) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s2 && *s2 != ',') {
+				s2++;
+			}
+			if (!*s2)
+				break;
+			s2++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_fixed_quality = 1;
+	}
+
+	/* image origin */
+	if (sscanf(m_origin.ToAscii(), "%d,%d", &parameters.image_offset_x0, &parameters.image_offset_y0) != 2) {
+		wxLogError(wxT("bad coordinate of the image origin: x0,y0"));
+		return false;
+	}
+				
+	/* Create comment for codestream */
+	if(m_enablecomm) {
+		parameters.cp_comment = (char *) malloc(strlen(m_comment.ToAscii()) + 1);
+		if(parameters.cp_comment) {
+			strcpy(parameters.cp_comment, m_comment.ToAscii());
+		}
+	} else {
+		parameters.cp_comment = NULL;
+	}
+
+	/* indexing file */
+	if (m_enableidx) {
+		strncpy(indexfilename, m_index.ToAscii(), OPJ_PATH_LEN);
+		wxLogMessage(wxT("index file is %s"), indexfilename);
+	}
+
+	/* if no rate entered, lossless by default */
+	if (parameters.tcp_numlayers == 0) {
+		parameters.tcp_rates[0] = 0;	/* MOD antonin : losslessbug */
+		parameters.tcp_numlayers++;
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* irreversible transform */
+	parameters.irreversible = (m_irreversible == true) ? 1 : 0;
+
+	/* resolutions */
+	parameters.numresolution = m_resolutions;
+
+	/* codeblocks size */
+	if (m_cbsize != wxT("")) {
+		int cblockw_init = 0, cblockh_init = 0;
+		sscanf(m_cbsize.ToAscii(), "%d,%d", &cblockw_init, &cblockh_init);
+		if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024 || cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+			wxLogError(wxT("!! Size of code_block error !! Restrictions:\n  width*height<=4096\n  4<=width,height<= 1024"));
+			return false;
+		}
+		parameters.cblockw_init = cblockw_init;
+		parameters.cblockh_init = cblockh_init;
+	}
+
+	/* precincts size */
+	if (m_prsize != wxT("")) {
+		char sep;
+		int res_spec = 0;
+		char *s = (char *) m_prsize.c_str();
+		do {
+			sep = 0;
+			sscanf(s, "[%d,%d]%c", &parameters.prcw_init[res_spec], &parameters.prch_init[res_spec], &sep);
+			parameters.csty |= 0x01;
+			res_spec++;
+			s = strpbrk(s, "]") + 2;
+		} while (sep == ',');
+		parameters.res_spec = res_spec;
+	}
+
+	/* tiles */
+	if (m_tsize != wxT("")) {
+		sscanf(m_tsize.ToAscii(), "%d,%d", &parameters.cp_tdx, &parameters.cp_tdy);
+		parameters.tile_size_on = true;
+	}
+
+	/* tile origin */
+	if (sscanf(m_torigin.ToAscii(), "%d,%d", &parameters.cp_tx0, &parameters.cp_ty0) != 2) {
+		wxLogError(wxT("tile offset setting error: X0,Y0"));
+		return false;
+	}
+
+	/* use SOP */
+	if (m_enablesop)
+		parameters.csty |= 0x02;
+
+	/* use EPH */
+	if (m_enableeph)
+		parameters.csty |= 0x04;
+
+	/* multiple component transform */
+	if (m_multicomp)
+		parameters.tcp_mct = 1;
+	else
+		parameters.tcp_mct = 0;
+
+	/* mode switch */
+	parameters.mode = (m_enablebypass ? 1 : 0) + (m_enablereset ? 2 : 0)
+		+ (m_enablerestart ? 4 : 0) + (m_enablevsc ? 8 : 0)
+		+ (m_enableerterm ? 16 : 0) + (m_enablesegmark ? 32 : 0);
+
+	/* progression order */
+	switch (m_progression) {
+
+		/* LRCP */
+	case 0:
+		parameters.prog_order = LRCP;
+		break;
+
+		/* RLCP */
+	case 1:
+		parameters.prog_order = RLCP;
+		break;
+
+		/* RPCL */
+	case 2:
+		parameters.prog_order = RPCL;
+		break;
+
+		/* PCRL */
+	case 3:
+		parameters.prog_order = PCRL;
+		break;
+
+		/* CPRL */
+	case 4:
+		parameters.prog_order = CPRL;
+		break;
+
+		/* DCI2K24 */
+	case 5:
+		parameters.cp_cinema = CINEMA2K_24;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI2K48 */
+	case 6:
+		parameters.cp_cinema = CINEMA2K_48;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI4K */
+	case 7:
+		parameters.cp_cinema = CINEMA4K_24;
+		parameters.cp_rsiz = CINEMA4K;
+		break;
+
+	default:
+		break;
+	}
+
+	/* check cinema */
+	if (parameters.cp_cinema) {
+
+		/* set up */
+		parameters.tile_size_on = false;
+		parameters.cp_tdx=1;
+		parameters.cp_tdy=1;
+		
+		/*Tile part*/
+		parameters.tp_flag = 'C';
+		parameters.tp_on = 1;
+
+		/*Tile and Image shall be at (0,0)*/
+		parameters.cp_tx0 = 0;
+		parameters.cp_ty0 = 0;
+		parameters.image_offset_x0 = 0;
+		parameters.image_offset_y0 = 0;
+
+		/*Codeblock size= 32*32*/
+		parameters.cblockw_init = 32;	
+		parameters.cblockh_init = 32;
+		parameters.csty |= 0x01;
+
+		/*The progression order shall be CPRL*/
+		parameters.prog_order = CPRL;
+
+		/* No ROI */
+		parameters.roi_compno = -1;
+
+		parameters.subsampling_dx = 1;
+		parameters.subsampling_dy = 1;
+
+		/* 9-7 transform */
+		parameters.irreversible = 1;
+
+	}				
+
+	/* convert wx image into opj image */
+	cmptparm = (opj_image_cmptparm_t*) malloc(3 * sizeof(opj_image_cmptparm_t));
+
+	/* initialize opj image components */	
+	memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < 3; i++) {		
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = false;
+		cmptparm[i].dx = parameters.subsampling_dx;
+		cmptparm[i].dy = parameters.subsampling_dy;
+		cmptparm[i].w = wimage->GetWidth();
+		cmptparm[i].h = wimage->GetHeight();
+	}
+
+	/* create the image */
+	oimage = opj_image_create(3, &cmptparm[0], CLRSPC_SRGB);
+	if(!oimage) {
+		if (cmptparm)
+			free(cmptparm);
+		return false;
+	}
+
+	/* set image offset and reference grid */
+	oimage->x0 = parameters.image_offset_x0;
+	oimage->y0 = parameters.image_offset_y0;
+	oimage->x1 = parameters.image_offset_x0 + (wimage->GetWidth() - 1) * 1 + 1;
+	oimage->y1 = parameters.image_offset_y0 + (wimage->GetHeight() - 1) * 1 + 1;
+
+	/* load image data */
+	unsigned char *value = wimage->GetData(); 
+	int area = wimage->GetWidth() * wimage->GetHeight();
+	for (i = 0; i < area; i++) {
+			oimage->comps[0].data[i] = *(value++);
+			oimage->comps[1].data[i] = *(value++);
+			oimage->comps[2].data[i] = *(value++);
+	}
+
+	/* check cinema again */
+	if (parameters.cp_cinema) {
+		int i;
+		float temp_rate;
+		opj_poc_t *POC = NULL;
+
+		switch (parameters.cp_cinema) {
+
+		case CINEMA2K_24:
+		case CINEMA2K_48:
+			if (parameters.numresolution > 6) {
+				parameters.numresolution = 6;
+			}
+			if (!((oimage->comps[0].w == 2048) | (oimage->comps[0].h == 1080))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 2K compliant. JPEG Digital Cinema Profile-3 "
+					"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+		break;
+		
+		case CINEMA4K_24:
+			if (parameters.numresolution < 1) {
+					parameters.numresolution = 1;
+			} else if (parameters.numresolution > 7) {
+					parameters.numresolution = 7;
+			}
+			if (!((oimage->comps[0].w == 4096) | (oimage->comps[0].h == 2160))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 4K compliant. JPEG Digital Cinema Profile-4" 
+					"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+			parameters.POC[0].tile  = 1; 
+			parameters.POC[0].resno0  = 0; 
+			parameters.POC[0].compno0 = 0;
+			parameters.POC[0].layno1  = 1;
+			parameters.POC[0].resno1  = parameters.numresolution - 1;
+			parameters.POC[0].compno1 = 3;
+			parameters.POC[0].prg1 = CPRL;
+			parameters.POC[1].tile  = 1;
+			parameters.POC[1].resno0  = parameters.numresolution - 1; 
+			parameters.POC[1].compno0 = 0;
+			parameters.POC[1].layno1  = 1;
+			parameters.POC[1].resno1  = parameters.numresolution;
+			parameters.POC[1].compno1 = 3;
+			parameters.POC[1].prg1 = CPRL;
+			parameters.numpocs = 2;
+			break;
+		}
+
+		switch (parameters.cp_cinema) {
+		case CINEMA2K_24:
+		case CINEMA4K_24:
+			for (i = 0 ; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_24_CS ) {
+						parameters.tcp_rates[i]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					} else {
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_24_CS;
+			break;
+			
+		case CINEMA2K_48:
+			for (i = 0; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0 ;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate =((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_48_CS ){
+						parameters.tcp_rates[0]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					}else{
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_48_CS;
+			break;
+		}
+
+		parameters.cp_disto_alloc = 1;
+	}
+	
+	/* get a J2K compressor handle */
+	opj_cinfo_t* cinfo = opj_create_compress(CODEC_J2K);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+
+	/* setup the encoder parameters using the current image and user parameters */
+	opj_setup_encoder(cinfo, &parameters, oimage);
+
+	/* open a byte stream for writing */
+	/* allocate memory for all tiles */
+	cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+	/* encode the image */
+	bSuccess = opj_encode_with_info(cinfo, cio, oimage, &cstr_info);
+	if (!bSuccess) {
+
+		opj_cio_close(cio);
+		opj_destroy_compress(cinfo);
+		opj_image_destroy(oimage);
+		if (cmptparm)
+			free(cmptparm);
+		if(parameters.cp_comment)
+			free(parameters.cp_comment);
+		if(parameters.cp_matrice)
+			free(parameters.cp_matrice);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+
+		wxLogError(wxT("failed to encode image"));
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+		return false;
+	}
+	codestream_length = cio_tell(cio);
+	wxLogMessage(wxT("Codestream: %d bytes"), codestream_length);
+
+	/* write the buffer to stream */
+	stream.Write(cio->buffer, codestream_length);
+
+	/* close and free the byte stream */
+	opj_cio_close(cio);
+
+	/* Write the index to disk */
+	if (*indexfilename) {
+		bSuccess = write_index_file(&cstr_info, indexfilename);
+		if (!bSuccess) {
+			wxLogError(wxT("Failed to output index file"));
+		}
+	}
+
+	/* free remaining compression structures */
+	opj_destroy_compress(cinfo);
+
+	/* free image data */
+	opj_image_destroy(oimage);
+
+	if (cmptparm)
+		free(cmptparm);
+	if(parameters.cp_comment)
+		free(parameters.cp_comment);
+	if(parameters.cp_matrice)
+		free(parameters.cp_matrice);
+
 #ifndef __WXGTK__ 
     wxMutexGuiEnter();
 #endif /* __WXGTK__ */
-    wxLogError(wxT("J2K: Couldn't save image -> not implemented."));
+
+    wxLogMessage(wxT("J2K: Image encoded!"));
+
 #ifndef __WXGTK__ 
     wxMutexGuiLeave();
 #endif /* __WXGTK__ */
 
-    return false;
+    return true;
 }
 
 #ifdef __VISUALC__
@@ -259,6 +717,268 @@
     return hdr[0] == 0xFF && hdr[1] == 0x4F;
 }
 
+// write the index file
+bool wxJ2KHandler::write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+	FILE *stream = NULL;
+	double total_disto = 0;
+	int tilepartno;
+
+#ifdef USE_JPWL
+	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+		return true;
+#endif // USE_JPWL
+
+	if (!cstr_info)		
+		return 1;
+
+	stream = fopen(index, "w");
+	if (!stream) {
+		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+		return false;
+	}
+	
+	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+	fprintf(stream, "%d\n", cstr_info->prog);
+	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+	fprintf(stream, "%d\n", cstr_info->numcomps);
+	fprintf(stream, "%d\n", cstr_info->numlayers);
+	fprintf(stream, "%d\n", cstr_info->numdecompos);
+
+	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+		fprintf(stream, "[%d,%d] ", 
+			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+	}
+
+	fprintf(stream, "\n");
+	fprintf(stream, "%d\n", cstr_info->main_head_start);
+	fprintf(stream, "%d\n", cstr_info->main_head_end);
+	fprintf(stream, "%d\n", cstr_info->codestream_size);
+	
+	fprintf(stream, "\nINFO ON TILES\n");
+	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts         disto     nbpix   disto/nbpix\n");
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		fprintf(stream, "%4d %9d %9d %9d %9d %9e %9d %9e\n",
+			cstr_info->tile[tileno].tileno,
+			cstr_info->tile[tileno].start_pos,
+			cstr_info->tile[tileno].end_header,
+			cstr_info->tile[tileno].end_pos,
+			cstr_info->tile[tileno].num_tps,
+			cstr_info->tile[tileno].distotile, cstr_info->tile[tileno].numpix,
+			cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+	}
+		
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		int start_pos, end_ph_pos, end_pos;
+		double disto = 0;
+		int max_numdecompos = 0;
+		pack_nb = 0;
+
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			if (max_numdecompos < cstr_info->numdecompos[compno])
+				max_numdecompos = cstr_info->numdecompos[compno];
+		}	
+
+		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
+		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
+				tilepartno, tileno,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
+				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+				);
+		if (cstr_info->prog == LRCP) {	/* LRCP */
+			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
+
+			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max;
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d %8e\n",
+								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* LRCP */
+		else if (cstr_info->prog == RLCP) {	/* RLCP */
+
+			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos disto\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max; 
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d %8e\n",
+								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* RLCP */
+		else if (cstr_info->prog == RPCL) {	/* RPCL */
+
+			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					if (resno > cstr_info->numdecompos[compno])
+							break;
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* compno */
+			} /* resno */
+		} /* RPCL */
+		else if (cstr_info->prog == PCRL) {	/* PCRL */
+			/* I suppose components have same XRsiz, YRsiz */
+			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+			int x1 = x0 + cstr_info->tile_x;
+			int y1 = y0 + cstr_info->tile_y;
+
+			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* resno */
+			} /* compno */
+		} /* PCRL */
+		else {	/* CPRL */
+
+			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+				
+				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							}
+						} /* y = y0..y1 */
+					} /* precno */
+				} /* resno */
+			} /* compno */
+		} /* CPRL */   
+	} /* tileno */
+	
+	fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */
+	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+	fprintf(stream, "\nMARKER LIST\n");
+	fprintf(stream, "%d\n", cstr_info->marknum);
+	fprintf(stream, "type\tstart_pos    length\n");
+	for (x = 0; x < cstr_info->marknum; x++)
+		fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
+	fclose(stream);
+
+	fprintf(stderr,"Generated index file %s\n", index);
+
+	return true;
+}
+
 #endif   // wxUSE_STREAMS
 
 #endif   // wxUSE_LIBOPENJPEG
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/imagj2k.h ./OPJViewer/source/imagj2k.h
--- /home/robin/sldeb/trunk/OPJViewer/source/imagj2k.h	2007-03-01 00:01:37.000000000 +0000
+++ ./OPJViewer/source/imagj2k.h	2007-11-27 22:39:50.000000000 +0000
@@ -67,6 +67,7 @@
         m_type = wxBITMAP_TYPE_J2K;
         m_mime = wxT("image/j2k");
 
+		/* decoding */
 		m_reducefactor = 0;
 		m_qualitylayers = 0;
 		m_components = 0;
@@ -75,15 +76,95 @@
 		m_expcomps = JPWL_EXPECTED_COMPONENTS;
 		m_maxtiles = JPWL_MAXIMUM_TILES;
 #endif // USE_JPWL
+
+		/* encoding */
+		m_subsampling = wxT("1,1");
+		m_origin = wxT("0,0");
+		m_rates = wxT("20,10,5");
+		m_quality = wxT("30,35,40");
+		m_enablequality = false;
+		m_multicomp = false;
+		m_irreversible = false;
+		m_resolutions = 6;
+		m_progression = 0;
+		m_cbsize = wxT("32,32");
+		m_prsize = wxT("[128,128],[128,128]");
+		m_tsize = wxT("");
+		m_torigin = wxT("0,0");
+		/*m_progression
+		m_resilience*/
+		m_enablesop = false;
+		m_enableeph = false;
+		m_enablereset = false;
+		m_enablesegmark = false;
+		m_enablevsc = false;
+		m_enablerestart = false;
+		m_enableerterm = false;
+		m_enablebypass = false;
+		/*m_roicompo
+		m_roiup
+		m_indexfname*/
+		m_enableidx = false;
+		m_index = wxT("index.txt");
+		m_enablecomm = true;
+
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+
     }
 
-		// decoding engine parameters
-		int m_reducefactor, m_qualitylayers, m_components;
+	// decoding engine parameters
+	int m_reducefactor, m_qualitylayers, m_components;
 #ifdef USE_JPWL
-		bool m_enablejpwl;
-		int m_expcomps, m_maxtiles;
+	bool m_enablejpwl;
+	int m_expcomps, m_maxtiles;
 #endif // USE_JPWL
 
+	// encoding engine parameters
+	wxString m_subsampling;
+	wxString m_origin;
+	wxString m_rates;
+	wxString m_quality;
+	bool m_enablequality;
+	bool m_multicomp;
+	bool m_irreversible;
+	int m_resolutions;
+	int m_progression;
+	wxString m_cbsize;
+	wxString m_prsize;
+	wxString m_tsize;
+	wxString m_torigin;
+	/*m_progression
+	m_resilience*/
+	bool m_enablesop;
+	bool m_enableeph;
+	bool m_enablebypass;
+	bool m_enableerterm;
+	bool m_enablerestart;
+	bool m_enablereset;
+	bool m_enablesegmark;
+	bool m_enablevsc;
+	/*m_roicompo
+	m_roiup
+	m_indexfname*/
+	bool m_enableidx;
+	wxString m_index;
+	bool m_enablecomm;
+	wxString m_comment;
+
+	bool write_index_file(opj_codestream_info_t *cstr_info, char *index);
+
 #if wxUSE_STREAMS
     virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
     virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/imagjp2.cpp ./OPJViewer/source/imagjp2.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/imagjp2.cpp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/imagjp2.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -135,6 +135,7 @@
 	unsigned char *src = NULL;
     unsigned char *ptr;
 	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -193,7 +194,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 #ifndef __WXGTK__ 
 		wxMutexGuiEnter();
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/imagjpeg2000.cpp ./OPJViewer/source/imagjpeg2000.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/imagjpeg2000.cpp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/imagjpeg2000.cpp	2007-09-28 11:33:50.000000000 +0100
@@ -183,4 +183,4 @@
 	}
 
 
-}
\ No newline at end of file
+}
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/imagmj2.cpp ./OPJViewer/source/imagmj2.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/imagmj2.cpp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/imagmj2.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -130,10 +130,18 @@
 /* From little endian to big endian, 2 and 4 bytes */
 #define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
 #define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
 #define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
                         ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
 						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
 						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
 
 /* From codestream to int values */
 #define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
@@ -610,6 +618,7 @@
     unsigned char *ptr;
 	int file_length, jp2c_point, jp2h_point;
 	unsigned long int jp2hboxlen, jp2cboxlen;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
 
 	// destroy the image
     image->Destroy();
@@ -691,7 +700,7 @@
 	cio = opj_cio_open((opj_common_ptr)dinfo, src, my_jPheadSIZE + jp2hboxlen + jp2cboxlen);
 
 	/* decode the stream and fill the image structure */
-	opjimage = opj_decode(dinfo, cio);
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
 	if (!opjimage) {
 		wxMutexGuiEnter();
 		wxLogError(wxT("MJ2: failed to decode image!"));
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/OPJDialogs.cpp ./OPJViewer/source/OPJDialogs.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/OPJDialogs.cpp	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/OPJDialogs.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1082 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita'  degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "OPJViewer.h"
+
+// ----------------------------------------------------------------------------
+// OPJDecoderDialog
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
+
+BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
+#ifdef USE_JPWL
+	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
+	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
+#endif // USE_JPWL
+END_EVENT_TABLE()
+
+OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
+{
+	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+
+	Create(win, wxID_ANY, wxT("Decoder settings"),
+		wxDefaultPosition, wxDefaultSize,
+		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+		);
+
+	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+
+	m_settingsNotebook = GetBookCtrl();
+
+	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		jpeg2000Settings->Enable(false);
+	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		mjpeg2000Settings->Enable(false);
+#ifdef USE_JPWL
+	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		jpwlSettings->Enable(false);
+#endif // USE_JPWL
+
+	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
+	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
+	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
+#ifdef USE_JPWL
+	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+#endif // USE_JPWL
+
+	LayoutDialog();
+}
+
+OPJDecoderDialog::~OPJDecoderDialog()
+{
+}
+
+wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+		// add decoding enabling check box
+		subtopSizer->Add(
+			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
+
+		// add parsing enabling check box
+		subtopSizer->Add(
+			m_enableparseCheck = new wxCheckBox(panel, OPJDECO_ENABLEPARSE, wxT("Enable parsing"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enableparseCheck->SetValue(wxGetApp().m_enableparse);
+
+			// resize settings, column
+			wxString choices[] = {wxT("Don't resize"), wxT("Low quality"), wxT("High quality")};
+			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
+				wxT("Resize method"),
+				wxDefaultPosition, wxDefaultSize,
+				WXSIZEOF(choices),
+				choices,
+				1,
+				wxRA_SPECIFY_ROWS);
+			m_resizeBox->SetSelection(wxGetApp().m_resizemethod + 1);
+
+		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+			// frame settings, column
+			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
+			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
+
+				// selected frame number, row
+				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				framenumSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				framenumSizer->Add(
+					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
+								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_framenum),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+			// resolutions settings, column
+			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
+			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
+
+				// reduce factor sizer, row
+				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				reduceSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				reduceSizer->Add(
+					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
+					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 10000, wxGetApp().m_reducefactor),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
+
+			// quality layer settings, column
+			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
+			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+
+				// quality layers sizer, row
+				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				qualitySizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				qualitySizer->Add(
+					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
+								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 100000, wxGetApp().m_qualitylayers),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
+
+			// component settings, column
+			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+
+				// quality layers sizer, row
+				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				numcompsSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				numcompsSizer->Add(
+					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
+								wxString::Format(wxT("%d"), wxGetApp().m_components),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 100000, wxGetApp().m_components),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_numcompsCtrl->Enable(true);
+
+			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+#ifdef USE_JPWL
+wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+		// add JPWL enabling check box
+		subtopSizer->Add(
+			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
+
+			// component settings, column
+			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+
+				// expected components sizer, row
+				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				expcompsSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				expcompsSizer->Add(
+					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
+								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_expcomps),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
+
+			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+
+			// tiles settings, column
+			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+
+				// maximum tiles sizer, row
+				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				maxtileSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				maxtileSizer->Add(
+					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
+								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_maxtiles),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
+
+			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
+{
+	size_t pp;
+
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Decoding enabled"));
+		m_resizeBox->Enable(true);
+		// enable all tabs except ourselves
+		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+				m_settingsNotebook->GetPage(pp)->Enable(true);
+		}
+	} else {
+		wxLogMessage(wxT("Decoding disabled"));
+		m_resizeBox->Enable(false);
+		// disable all tabs except ourselves
+		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+				m_settingsNotebook->GetPage(pp)->Enable(false);
+		}
+	}
+
+}
+
+void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("JPWL enabled"));
+		m_expcompsCtrl->Enable(true);
+		m_maxtilesCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("JPWL disabled"));
+		m_expcompsCtrl->Enable(false);
+		m_maxtilesCtrl->Enable(false);
+	}
+
+}
+
+#endif // USE_JPWL
+
+bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
+{
+    /*size_t nFiles = filenames.GetCount();
+    wxString str;
+    str.Printf( _T("%d files dropped\n"), (int)nFiles);
+    for ( size_t n = 0; n < nFiles; n++ ) {
+        str << filenames[n] << wxT("\n");
+    }
+    wxLogMessage(str);*/
+	m_pOwner->OpenFiles(filenames, filenames);
+
+    return true;
+}
+
+
+
+
+
+// ----------------------------------------------------------------------------
+// OPJEncoderDialog
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
+
+BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
+#ifdef USE_JPWL
+	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
+	EVT_CHECKBOX(OPJENCO_ENABLECOMM, OPJEncoderDialog::OnEnableComm)
+	EVT_CHECKBOX(OPJENCO_ENABLEINDEX, OPJEncoderDialog::OnEnableIdx)
+	EVT_RADIOBUTTON(OPJENCO_RATERADIO, OPJEncoderDialog::OnRadioQualityRate)
+	EVT_RADIOBUTTON(OPJENCO_QUALITYRADIO, OPJEncoderDialog::OnRadioQualityRate)
+#endif // USE_JPWL
+END_EVENT_TABLE()
+
+OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
+{
+	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+
+	Create(win, wxID_ANY, wxT("Encoder settings"),
+		wxDefaultPosition, wxDefaultSize,
+		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+		);
+
+	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+
+	m_settingsNotebook = GetBookCtrl();
+
+	wxPanel* jpeg2000_1Settings = CreatePart1_1SettingsPage(m_settingsNotebook);
+	wxPanel* jpeg2000_2Settings = CreatePart1_2SettingsPage(m_settingsNotebook);
+	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+#ifdef USE_JPWL
+	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+#endif // USE_JPWL
+
+	m_settingsNotebook->AddPage(jpeg2000_1Settings, wxT("JPEG 2000 - 1"), false);
+	m_settingsNotebook->AddPage(jpeg2000_2Settings, wxT("JPEG 2000 - 2"), false);
+	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
+#ifdef USE_JPWL
+	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+#endif // USE_JPWL
+
+	LayoutDialog();
+}
+
+OPJEncoderDialog::~OPJEncoderDialog()
+{
+}
+
+wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+#ifdef USE_JPWL
+wxPanel* OPJEncoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+#endif // USE_JPWL
+
+wxPanel* OPJEncoderDialog::CreatePart1_1SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+
+			// image settings, column
+			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
+			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
+
+				// subsampling factor sizer, row
+				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				subsSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				subsSizer->Add(
+					m_subsamplingCtrl = new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
+								wxGetApp().m_subsampling,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
+
+				// origin sizer, row
+				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				imorigSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				imorigSizer->Add(
+					m_originCtrl = new wxTextCtrl(panel, OPJENCO_IMORIG,
+								wxGetApp().m_origin,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
+
+			// layer settings, column
+			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers/compression"));
+			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+
+				// rate factor sizer, row
+				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				/*rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
+
+				// add the radio button
+				rateSizer->Add(
+					m_rateRadio = new wxRadioButton(panel, OPJENCO_RATERADIO, wxT("&Rate values"),
+								wxDefaultPosition, wxDefaultSize,
+								wxRB_GROUP),
+								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
+								);
+				m_rateRadio->SetValue(!(wxGetApp().m_enablequality));
+
+				// add some horizontal space
+				rateSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				rateSizer->Add(
+					m_rateCtrl = new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
+								wxGetApp().m_rates,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				if (wxGetApp().m_enablequality == true)
+					m_rateCtrl->Enable(false);
+
+			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
+
+				// quality factor sizer, row
+				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				/*qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
+
+				// add the radio button
+				qualitySizer->Add(
+					m_qualityRadio = new wxRadioButton(panel, OPJENCO_QUALITYRADIO, wxT("&Quality values"),
+								wxDefaultPosition, wxDefaultSize),
+								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
+								);
+				m_qualityRadio->SetValue(wxGetApp().m_enablequality);
+
+				// add some horizontal space
+				qualitySizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				qualitySizer->Add(
+					m_qualityCtrl = new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
+								wxGetApp().m_quality,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				if (wxGetApp().m_enablequality == false)
+					m_qualityCtrl->Enable(false);
+
+			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
+
+			// wavelet settings, column
+			wxStaticBox* transformBox = new wxStaticBox(panel, wxID_ANY, wxT("Transforms"));
+			wxBoxSizer* transformSizer = new wxStaticBoxSizer(transformBox, wxVERTICAL);
+
+			// multiple component check box
+			transformSizer->Add(
+				m_mctCheck = new wxCheckBox(panel, OPJENCO_ENABLEMCT, wxT("Multiple component"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_mctCheck->SetValue(wxGetApp().m_multicomp);
+
+			// irreversible wavelet check box
+			transformSizer->Add(
+				m_irrevCheck = new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible wavelet"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_irrevCheck->SetValue(wxGetApp().m_irreversible);
+
+				// resolution number sizer, row
+				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				resnumSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				resnumSizer->Add(
+					m_resolutionsCtrl = new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
+								wxString::Format(wxT("%d"), wxGetApp().m_resolutions),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 256, 6),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			transformSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(transformSizer, 0, wxGROW | wxALL, 3);
+
+			// codestream settings, column
+			wxStaticBox* codestreamBox = new wxStaticBox(panel, wxID_ANY, wxT("Codestream"));
+			wxBoxSizer* codestreamSizer = new wxStaticBoxSizer(codestreamBox, wxVERTICAL);
+
+				// codeblock sizer, row
+				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				codeblockSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				codeblockSizer->Add(
+					m_cbsizeCtrl = new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
+								wxGetApp().m_cbsize,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			codestreamSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
+
+				// precinct sizer, row
+				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				precinctSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				precinctSizer->Add(
+					m_prsizeCtrl = new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
+								wxGetApp().m_prsize,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			codestreamSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(codestreamSizer, 0, wxGROW | wxALL, 3);
+
+			// tile settings, column
+			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+
+				// tile size sizer, row
+				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				tilesizeSizer->Add(
+					m_tsizeCtrl = new wxTextCtrl(panel, OPJENCO_TILESIZE,
+								wxGetApp().m_tsize,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
+
+				// tile origin sizer, row
+				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				tilorigSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				tilorigSizer->Add(
+					m_toriginCtrl = new wxTextCtrl(panel, OPJENCO_TILORIG,
+								wxGetApp().m_torigin,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
+
+			// progression and profile settings, column
+			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL"),
+				wxT("DCI2K24"), wxT("DCI2K48"), wxT("DCI4K")};
+			progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
+				wxT("Progression order/profile"),
+				wxDefaultPosition, wxDefaultSize,
+				WXSIZEOF(choices),
+				choices,
+				3,
+				wxRA_SPECIFY_COLS);
+			progressionBox->SetSelection(wxGetApp().m_progression);
+
+		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJEncoderDialog::CreatePart1_2SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+			
+			// resilience settings, column
+			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Error resilience"));
+			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
+
+				// resil2 sizer, row
+				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// SOP check box
+				resil2Sizer->Add(
+					m_sopCheck = new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
+						wxDefaultPosition, wxDefaultSize),
+						0, wxGROW | wxALL, 3);
+				m_sopCheck->SetValue(wxGetApp().m_enablesop);
+
+				// EPH check box
+				resil2Sizer->Add(
+					m_ephCheck = new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
+						wxDefaultPosition, wxDefaultSize),
+						0, wxGROW | wxALL, 3);
+				m_ephCheck->SetValue(wxGetApp().m_enableeph);
+
+			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
+
+			// separation
+			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
+
+				// resil3 sizer, row
+				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
+
+				// BYPASS check box
+				resil3Sizer->Add(
+					m_enablebypassCheck = new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablebypassCheck->SetValue(wxGetApp().m_enablebypass);
+
+				// RESET check box
+				resil3Sizer->Add(
+					m_enableresetCheck = new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enableresetCheck->SetValue(wxGetApp().m_enablereset);
+
+				// RESTART check box
+				resil3Sizer->Add(
+					m_enablerestartCheck = new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablerestartCheck->SetValue(wxGetApp().m_enablerestart);
+
+				// VSC check box
+				resil3Sizer->Add(
+					m_enablevscCheck = new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablevscCheck->SetValue(wxGetApp().m_enablevsc);
+
+				// ERTERM check box
+				resil3Sizer->Add(
+					m_enableertermCheck = new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enableertermCheck->SetValue(wxGetApp().m_enableerterm);
+
+				// SEGMARK check box
+				resil3Sizer->Add(
+					m_enablesegmarkCheck = new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablesegmarkCheck->SetValue(wxGetApp().m_enablesegmark);
+
+			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
+
+			// ROI settings, column
+			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("Region Of Interest"));
+			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
+
+				// component number sizer, row
+				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				roicompSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				roicompSizer->Add(
+					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
+								wxT("0"),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 256, 0),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
+
+				// upshift sizer, row
+				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				roishiftSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				roishiftSizer->Add(
+					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
+								wxT("0"),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 37, 0),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
+
+			// Index file settings, column
+			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
+			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
+
+			// indexing check box
+			indexSizer->Add(
+				m_enableidxCheck = new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enableidxCheck->SetValue(wxGetApp().m_enableidx);
+
+				// index file sizer, row
+				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				indexnameSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				indexnameSizer->Add(
+					m_indexCtrl = new wxTextCtrl(panel, OPJENCO_INDEXNAME,
+								wxGetApp().m_index,
+								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				m_indexCtrl->Enable(wxGetApp().m_enableidx);
+
+			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
+
+			// Comment settings, column
+			wxStaticBox* commentBox = new wxStaticBox(panel, wxID_ANY, wxT("Comment"));
+			wxBoxSizer* commentSizer = new wxStaticBoxSizer(commentBox, wxVERTICAL);
+
+			// commenting check box
+			commentSizer->Add(
+				m_enablecommCheck = new wxCheckBox(panel, OPJENCO_ENABLECOMM, wxT("Enabled (empty to reset)"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enablecommCheck->SetValue(wxGetApp().m_enablecomm);
+
+			// add some horizontal space
+			commentSizer->Add(3, 3, 1, wxALL, 0);
+
+			// add the value control
+			commentSizer->Add(
+				m_commentCtrl = new wxTextCtrl(panel, OPJENCO_COMMENTTEXT,
+							wxGetApp().m_comment,
+							wxDefaultPosition, wxSize(wxDefaultCoord, 60),
+							wxTE_LEFT | wxTE_MULTILINE),
+				0, wxGROW | wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+			m_commentCtrl->Enable(wxGetApp().m_enablecomm);
+
+		subtopSizer->Add(commentSizer, 0, wxGROW | wxALL, 3);
+
+			// POC settings, column
+			wxStaticBox* pocBox = new wxStaticBox(panel, wxID_ANY, wxT("POC"));
+			wxBoxSizer* pocSizer = new wxStaticBoxSizer(pocBox, wxVERTICAL);
+
+			// POC check box
+			pocSizer->Add(
+				m_enablepocCheck = new wxCheckBox(panel, OPJENCO_ENABLEPOC, wxT("Enabled"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enablepocCheck->SetValue(/*wxGetApp().m_enableidx*/true);
+
+				// POC sizer, row
+				wxBoxSizer* pocspecSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				pocspecSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Changes:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				pocspecSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				pocspecSizer->Add(
+					m_pocCtrl = new wxTextCtrl(panel, OPJENCO_POCSPEC,
+								/*wxGetApp().m_index*/wxT("RRRR"),
+								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				m_pocCtrl->Enable(/*wxGetApp().m_enableidx*/true);
+
+			pocSizer->Add(pocspecSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(pocSizer, 0, wxGROW | wxALL, 3);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+void OPJEncoderDialog::OnEnableComm(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Comment enabled"));
+		m_commentCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Comment disabled"));
+		m_commentCtrl->Enable(false);
+	}
+
+}
+
+void OPJEncoderDialog::OnEnableIdx(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Index enabled"));
+		m_indexCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Index disabled"));
+		m_indexCtrl->Enable(false);
+	}
+
+}
+
+void OPJEncoderDialog::OnRadioQualityRate(wxCommandEvent& event)
+{
+	if (event.GetId() == OPJENCO_QUALITYRADIO) {
+		wxLogMessage(wxT("Quality selected"));
+		m_rateCtrl->Enable(false);
+		m_qualityCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Rate selected"));
+		m_rateCtrl->Enable(true);
+		m_qualityCtrl->Enable(false);
+	}
+}
+
+#ifdef USE_JPWL
+void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
+{
+	/*if (event.IsChecked()) {
+		wxLogMessage(wxT("JPWL enabled"));
+		m_expcompsCtrl->Enable(true);
+		m_maxtilesCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("JPWL disabled"));
+		m_expcompsCtrl->Enable(false);
+		m_maxtilesCtrl->Enable(false);
+	}*/
+
+}
+#endif // USE_JPWL
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/OPJViewer.cpp ./OPJViewer/source/OPJViewer.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/OPJViewer.cpp	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/OPJViewer.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -1,5 +1,5 @@
 /*
- * Copyright (c) 2007, Digital Signal Processing Laboratory, UniversitÃ  degli studi di Perugia (UPG), Italy
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita' degli studi di Perugia (UPG), Italy
  * All rights reserved.
  *
  * Redistribution and use in source and binary forms, with or without
@@ -207,8 +207,66 @@
 	// memory file system
     wxFileSystem::AddHandler(new wxMemoryFSHandler);
 
+#ifdef OPJ_INICONFIG
+	//load decoding engine parameters
+	OPJconfig = new wxConfig(OPJ_APPLICATION, OPJ_APPLICATION_VENDOR);
+
+	OPJconfig->Read(wxT("enabledeco"), &m_enabledeco, (bool) true);
+	OPJconfig->Read(wxT("enableparse"), &m_enableparse, (bool) true);
+	OPJconfig->Read(wxT("resizemethod"), &m_resizemethod, (long) 0);
+	OPJconfig->Read(wxT("xxxreducefactor"), &m_reducefactor, (long) 0);
+	OPJconfig->Read(wxT("xxxqualitylayers"), &m_qualitylayers, (long) 0);
+	OPJconfig->Read(wxT("xxxcomponents"), &m_components, (long) 0);
+	OPJconfig->Read(wxT("xxxframenum"), &m_framenum, (long) 0);
+#ifdef USE_JPWL
+	OPJconfig->Read(wxT("enablejpwl"), &m_enablejpwl, (bool) true);
+	OPJconfig->Read(wxT("expcomps"), &m_expcomps, (long) JPWL_EXPECTED_COMPONENTS);
+	OPJconfig->Read(wxT("maxtiles"), &m_maxtiles, (long) JPWL_MAXIMUM_TILES);
+#endif // USE_JPWL
+
+	OPJconfig->Write(wxT("teststring"), wxT("This is a test value"));
+	OPJconfig->Write(wxT("testbool"), (bool) true);
+	OPJconfig->Write(wxT("testlong"), (long) 245);
+
+	OPJconfig->Read(wxT("showtoolbar"), &m_showtoolbar, (bool) true);
+	OPJconfig->Read(wxT("showbrowser"), &m_showbrowser, (bool) true);
+	OPJconfig->Read(wxT("showpeeker"), &m_showpeeker, (bool) true);
+	OPJconfig->Read(wxT("browserwidth"), &m_browserwidth, (long) OPJ_BROWSER_WIDTH);
+	OPJconfig->Read(wxT("peekerheight"), &m_peekerheight, (long) OPJ_PEEKER_HEIGHT);
+	OPJconfig->Read(wxT("framewidth"), &m_framewidth, (long) OPJ_FRAME_WIDTH);
+	OPJconfig->Read(wxT("frameheight"), &m_frameheight, (long) OPJ_FRAME_HEIGHT);
+
+	// load encoding engine parameters
+	OPJconfig->Read(wxT("subsampling"), &m_subsampling, (wxString) wxT("1,1"));
+	OPJconfig->Read(wxT("origin"), &m_origin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("rates"), &m_rates, (wxString) wxT("20,10,5"));
+	OPJconfig->Read(wxT("quality"), &m_quality, (wxString) wxT("30,35,40"));
+	OPJconfig->Read(wxT("enablequality"), &m_enablequality, (bool) false);
+	OPJconfig->Read(wxT("multicomp"), &m_multicomp, (bool) false);	
+	OPJconfig->Read(wxT("irreversible"), &m_irreversible, (bool) false);	
+	OPJconfig->Read(wxT("resolutions"), &m_resolutions, (int) 6);	
+	OPJconfig->Read(wxT("progression"), &m_progression, (int) 0);	
+	OPJconfig->Read(wxT("cbsize"), &m_cbsize, (wxString) wxT("32,32"));
+	OPJconfig->Read(wxT("prsize"), &m_prsize, (wxString) wxT("[128,128],[128,128]"));
+	OPJconfig->Read(wxT("tsize"), &m_tsize, (wxString) wxT(""));
+	OPJconfig->Read(wxT("torigin"), &m_torigin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("enablesop"), &m_enablesop, (bool) false);	
+	OPJconfig->Read(wxT("enableeph"), &m_enableeph, (bool) false);	
+	OPJconfig->Read(wxT("enablebypass"), &m_enablebypass, (bool) false);	
+	OPJconfig->Read(wxT("enablereset"), &m_enablereset, (bool) false);	
+	OPJconfig->Read(wxT("enablerestart"), &m_enablerestart, (bool) false);	
+	OPJconfig->Read(wxT("enablevsc"), &m_enablevsc, (bool) false);	
+	OPJconfig->Read(wxT("enableerterm"), &m_enableerterm, (bool) false);	
+	OPJconfig->Read(wxT("enablesegmark"), &m_enablesegmark, (bool) false);	
+	OPJconfig->Read(wxT("enablecomm"), &m_enablecomm, (bool) true);	
+	OPJconfig->Read(wxT("comment"), &m_comment, (wxString) wxT(""));
+	OPJconfig->Read(wxT("enableidx"), &m_enableidx, (bool) false);	
+	OPJconfig->Read(wxT("index"), &m_index, (wxString) wxT("index.txt"));
+
+#else
 	// set decoding engine parameters
 	m_enabledeco = true;
+	m_enableparse = true;
 	m_resizemethod = 0;
 	m_reducefactor = 0;
 	m_qualitylayers = 0;
@@ -219,10 +277,62 @@
 	m_expcomps = JPWL_EXPECTED_COMPONENTS;
 	m_maxtiles = JPWL_MAXIMUM_TILES;
 #endif // USE_JPWL
+	m_showtoolbar = true;
+	m_showbrowser = true;
+	m_showpeeker = true;
+	m_browserwidth = OPJ_BROWSER_WIDTH;
+	m_peekerheight = OPJ_PEEKER_HEIGHT;
+	m_framewidth = OPJ_FRAME_WIDTH;
+	m_frameheight = OPJ_FRAME_HEIGHT;
+
+	// set encoding engine parameters
+	m_subsampling = wxT("1,1");
+	m_origin = wxT("0,0");
+	m_rates = wxT("20,10,5");
+	m_quality = wxT("30,35,40");
+	m_enablequality = false;
+	m_multicomp = false;
+	m_irreversible = false;
+	m_resolutions = 6;
+	m_progression = 0;
+	m_cbsize= wxT("32,32");
+	m_prsize= wxT("[128,128],[128,128]");
+	m_tsize = wxT("");
+	m_torigin = wxT("0,0");
+	m_enablesop = false;
+	m_enableeph = false;
+	m_enablebypass = false;
+	m_enablereset = false;
+	m_enablerestart = false;
+	m_enablevsc = false;
+	m_enableerterm = false;
+	m_enablesegmark = false;
+	m_enableidx = false;
+	m_index = wxT("index.txt");
+	m_enablecomm = true;
+	m_comment = wxT("");
+
+#endif // OPJ_INICONFIG
+
+	if (m_comment == wxT("")) {
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+	}
 
 	// Create the main frame window
   OPJFrame *frame = new OPJFrame(NULL, wxID_ANY, OPJ_APPLICATION_TITLEBAR,
-					  wxDefaultPosition, wxSize(800, 600),
+					  wxDefaultPosition, wxSize(wxGetApp().m_framewidth, wxGetApp().m_frameheight),
                       wxDEFAULT_FRAME_STYLE | wxNO_FULL_REPAINT_ON_RESIZE |
                       wxHSCROLL | wxVSCROLL);
 
@@ -250,6 +360,60 @@
   return true;
 }
 
+int OPJViewerApp::OnExit()
+{
+#ifdef OPJ_INICONFIG
+	OPJconfig->Write(wxT("enabledeco"), m_enabledeco);
+	OPJconfig->Write(wxT("enableparse"), m_enableparse);
+	OPJconfig->Write(wxT("resizemethod"), m_resizemethod);
+	OPJconfig->Write(wxT("reducefactor"), m_reducefactor);
+	OPJconfig->Write(wxT("qualitylayers"), m_qualitylayers);
+	OPJconfig->Write(wxT("components"), m_components);
+	OPJconfig->Write(wxT("framenum"), m_framenum);
+#ifdef USE_JPWL
+	OPJconfig->Write(wxT("enablejpwl"), m_enablejpwl);
+	OPJconfig->Write(wxT("expcomps"), m_expcomps);
+	OPJconfig->Write(wxT("maxtiles"), m_maxtiles);
+#endif // USE_JPWL
+	OPJconfig->Write(wxT("showtoolbar"), m_showtoolbar);
+	OPJconfig->Write(wxT("showbrowser"), m_showbrowser);
+	OPJconfig->Write(wxT("showpeeker"), m_showpeeker);
+	OPJconfig->Write(wxT("browserwidth"), m_browserwidth);
+	OPJconfig->Write(wxT("peekerheight"), m_peekerheight);
+	OPJconfig->Write(wxT("framewidth"), m_framewidth);
+	OPJconfig->Write(wxT("frameheight"), m_frameheight);
+
+	OPJconfig->Write(wxT("subsampling"), m_subsampling);
+	OPJconfig->Write(wxT("origin"), m_origin);
+	OPJconfig->Write(wxT("rates"), m_rates);
+	OPJconfig->Write(wxT("quality"), m_quality);
+	OPJconfig->Write(wxT("enablequality"), m_enablequality);
+	OPJconfig->Write(wxT("multicomp"), m_multicomp);
+	OPJconfig->Write(wxT("irreversible"), m_irreversible);
+	OPJconfig->Write(wxT("resolutions"), m_resolutions);
+	OPJconfig->Write(wxT("progression"), m_progression);
+	OPJconfig->Write(wxT("cbsize"), m_cbsize);
+	OPJconfig->Write(wxT("prsize"), m_prsize);
+	OPJconfig->Write(wxT("tiles"), m_tsize);
+	OPJconfig->Write(wxT("torigin"), m_torigin);
+	OPJconfig->Write(wxT("enablesop"), m_enablesop);
+	OPJconfig->Write(wxT("enableeph"), m_enableeph);
+	OPJconfig->Write(wxT("enablebypass"), m_enablebypass);
+	OPJconfig->Write(wxT("enablereset"), m_enablereset);
+	OPJconfig->Write(wxT("enablerestart"), m_enablerestart);
+	OPJconfig->Write(wxT("enablevsc"), m_enablevsc);
+	OPJconfig->Write(wxT("enableerterm"), m_enableerterm);
+	OPJconfig->Write(wxT("enablesegmark"), m_enablesegmark);
+	OPJconfig->Write(wxT("enableidx"), m_enableidx);
+	OPJconfig->Write(wxT("index"), m_index);
+	OPJconfig->Write(wxT("enablecomm"), m_enablecomm);
+	OPJconfig->Write(wxT("comment"), m_comment);
+
+#endif // OPJ_INICONFIG
+
+	return 1;
+}
+
 void OPJViewerApp::ShowCmdLine(const wxCmdLineParser& parser)
 {
     wxString s = wxT("Command line parsed successfully:\nInput files: ");
@@ -267,14 +431,29 @@
 BEGIN_EVENT_TABLE(OPJFrame, wxMDIParentFrame)
     EVT_MENU(OPJFRAME_HELPABOUT, OPJFrame::OnAbout)
     EVT_MENU(OPJFRAME_FILEOPEN, OPJFrame::OnFileOpen)
+    EVT_MENU(OPJFRAME_FILESAVEAS, OPJFrame::OnFileSaveAs)
+    EVT_MENU(OPJFRAME_MEMORYOPEN, OPJFrame::OnMemoryOpen)
     EVT_SIZE(OPJFrame::OnSize)
     EVT_MENU(OPJFRAME_FILEEXIT, OPJFrame::OnQuit)
     EVT_MENU(OPJFRAME_FILECLOSE, OPJFrame::OnClose)
     EVT_MENU(OPJFRAME_VIEWZOOM, OPJFrame::OnZoom)
     EVT_MENU(OPJFRAME_VIEWFIT, OPJFrame::OnFit)
     EVT_MENU(OPJFRAME_VIEWRELOAD, OPJFrame::OnReload)
+    EVT_MENU(OPJFRAME_VIEWPREVFRAME, OPJFrame::OnPrevFrame)
+    EVT_MENU(OPJFRAME_VIEWHOMEFRAME, OPJFrame::OnHomeFrame)
+    EVT_MENU(OPJFRAME_VIEWNEXTFRAME, OPJFrame::OnNextFrame)
+    EVT_MENU(OPJFRAME_VIEWLESSLAYERS, OPJFrame::OnLessLayers)
+    EVT_MENU(OPJFRAME_VIEWALLLAYERS, OPJFrame::OnAllLayers)
+    EVT_MENU(OPJFRAME_VIEWMORELAYERS, OPJFrame::OnMoreLayers)
+    EVT_MENU(OPJFRAME_VIEWLESSRES, OPJFrame::OnLessRes)
+    EVT_MENU(OPJFRAME_VIEWFULLRES, OPJFrame::OnFullRes)
+    EVT_MENU(OPJFRAME_VIEWMORERES, OPJFrame::OnMoreRes)
+    EVT_MENU(OPJFRAME_VIEWPREVCOMP, OPJFrame::OnPrevComp)
+    EVT_MENU(OPJFRAME_VIEWALLCOMPS, OPJFrame::OnAllComps)
+    EVT_MENU(OPJFRAME_VIEWNEXTCOMP, OPJFrame::OnNextComp)
     EVT_MENU(OPJFRAME_FILETOGGLEB, OPJFrame::OnToggleBrowser)
     EVT_MENU(OPJFRAME_FILETOGGLEP, OPJFrame::OnTogglePeeker)
+    EVT_MENU(OPJFRAME_FILETOGGLET, OPJFrame::OnToggleToolbar)
     EVT_MENU(OPJFRAME_SETSENCO, OPJFrame::OnSetsEnco)
     EVT_MENU(OPJFRAME_SETSDECO, OPJFrame::OnSetsDeco)
     EVT_SASH_DRAGGED_RANGE(OPJFRAME_BROWSEWIN, OPJFRAME_LOGWIN, OPJFrame::OnSashDrag)
@@ -292,14 +471,30 @@
 	file_menu->Append(OPJFRAME_FILEOPEN, wxT("&Open\tCtrl+O"));
 	file_menu->SetHelpString(OPJFRAME_FILEOPEN, wxT("Open one or more files"));
 
+	file_menu->Append(OPJFRAME_MEMORYOPEN, wxT("&Memory\tCtrl+M"));
+	file_menu->SetHelpString(OPJFRAME_MEMORYOPEN, wxT("Open a memory buffer"));
+
+	file_menu->Append(OPJFRAME_FILECLOSE, wxT("&Close\tCtrl+C"));
+	file_menu->SetHelpString(OPJFRAME_FILECLOSE, wxT("Close current image"));
+
+	file_menu->AppendSeparator();
+
+	file_menu->Append(OPJFRAME_FILESAVEAS, wxT("&Save as\tCtrl+S"));
+	file_menu->SetHelpString(OPJFRAME_FILESAVEAS, wxT("Save the current image"));
+	//file_menu->Enable(OPJFRAME_FILESAVEAS, false);
+
+	file_menu->AppendSeparator();
+
 	file_menu->Append(OPJFRAME_FILETOGGLEB, wxT("Toggle &browser\tCtrl+B"));
 	file_menu->SetHelpString(OPJFRAME_FILETOGGLEB, wxT("Toggle the left browsing pane"));
 
 	file_menu->Append(OPJFRAME_FILETOGGLEP, wxT("Toggle &peeker\tCtrl+P"));
 	file_menu->SetHelpString(OPJFRAME_FILETOGGLEP, wxT("Toggle the bottom peeking pane"));
 
-	file_menu->Append(OPJFRAME_FILECLOSE, wxT("&Close\tCtrl+C"));
-	file_menu->SetHelpString(OPJFRAME_FILECLOSE, wxT("Close current image"));
+	file_menu->Append(OPJFRAME_FILETOGGLET, wxT("Toggle &toolbar\tCtrl+T"));
+	file_menu->SetHelpString(OPJFRAME_FILETOGGLET, wxT("Toggle the toolbar"));
+
+	file_menu->AppendSeparator();
 
 	file_menu->Append(OPJFRAME_FILEEXIT, wxT("&Exit\tCtrl+Q"));
 	file_menu->SetHelpString(OPJFRAME_FILEEXIT, wxT("Quit this program"));
@@ -316,6 +511,51 @@
 	view_menu->Append(OPJFRAME_VIEWRELOAD, wxT("&Reload image\tCtrl+R"));
 	view_menu->SetHelpString(OPJFRAME_VIEWRELOAD, wxT("Reload the current image"));
 
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVFRAME, wxT("&Prev frame\tLeft"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVFRAME, wxT("View previous frame"));
+
+	view_menu->Append(OPJFRAME_VIEWHOMEFRAME, wxT("&Start frame\tHome"));
+	view_menu->SetHelpString(OPJFRAME_VIEWHOMEFRAME, wxT("View starting frame"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTFRAME, wxT("&Next frame\tRight"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTFRAME, wxT("View next frame"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSLAYERS, wxT("&Less layers\t-"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSLAYERS, wxT("Remove a layer"));
+
+	view_menu->Append(OPJFRAME_VIEWALLLAYERS, wxT("&All layers\t0"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLLAYERS, wxT("Show all layers"));
+
+	view_menu->Append(OPJFRAME_VIEWMORELAYERS, wxT("&More layers\t+"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORELAYERS, wxT("Add a layer"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSRES, wxT("&Less resolution\t<"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSRES, wxT("Reduce the resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWFULLRES, wxT("&Full resolution\tf"));
+	view_menu->SetHelpString(OPJFRAME_VIEWFULLRES, wxT("Full resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWMORERES, wxT("&More resolution\t>"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORERES, wxT("Increase the resolution"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVCOMP, wxT("&Prev component\tDown"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVCOMP, wxT("View previous component"));
+
+	view_menu->Append(OPJFRAME_VIEWALLCOMPS, wxT("&All components\ta"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLCOMPS, wxT("View all components"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTCOMP, wxT("&Next component\tUp"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTCOMP, wxT("View next component"));
+
+
 	// settings menu and its items
 	wxMenu *sets_menu = new wxMenu;
 
@@ -344,17 +584,97 @@
 	// the status bar
 	CreateStatusBar();
 
+	// the toolbar
+	tool_bar = new wxToolBar(this, OPJFRAME_TOOLBAR,
+								wxDefaultPosition, wxDefaultSize,
+								wxTB_HORIZONTAL | wxNO_BORDER);
+	wxBitmap bmpOpen = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpSaveAs = wxArtProvider::GetBitmap(wxART_FILE_SAVE_AS, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpZoom = wxArtProvider::GetBitmap(wxART_FIND, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpFit = wxArtProvider::GetBitmap(wxART_FIND_AND_REPLACE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpReload = wxArtProvider::GetBitmap(wxART_EXECUTABLE_FILE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpDecosettings = wxArtProvider::GetBitmap(wxART_REPORT_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpEncosettings = wxArtProvider::GetBitmap(wxART_LIST_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpPrevframe = wxArtProvider::GetBitmap(wxART_GO_BACK, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpHomeframe = wxArtProvider::GetBitmap(wxART_GO_HOME, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextframe = wxArtProvider::GetBitmap(wxART_GO_FORWARD, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpLesslayers = bmpPrevframe;
+	wxBitmap bmpAlllayers = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMorelayers = bmpNextframe;
+	wxBitmap bmpLessres = bmpPrevframe;
+	wxBitmap bmpFullres = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMoreres = bmpNextframe;
+	wxBitmap bmpPrevcomp = bmpPrevframe;
+	wxBitmap bmpAllcomps = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextcomp = bmpNextframe;
+
+	tool_bar->AddTool(OPJFRAME_FILEOPEN, bmpOpen, wxT("Open"));
+	tool_bar->AddTool(OPJFRAME_FILESAVEAS, bmpSaveAs, wxT("Save as "));
+	//tool_bar->EnableTool(OPJFRAME_FILESAVEAS, false);
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWZOOM, bmpZoom, wxT("Zoom"));
+	tool_bar->AddTool(OPJFRAME_VIEWFIT, bmpFit, wxT("Zoom to fit"));
+	tool_bar->AddTool(OPJFRAME_VIEWRELOAD, bmpReload, wxT("Reload"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_SETSDECO, bmpDecosettings, wxT("Decoder settings"));
+	tool_bar->AddTool(OPJFRAME_SETSENCO, bmpEncosettings, wxT("Encoder settings"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVFRAME, bmpPrevframe, wxT("Previous frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWHOMEFRAME, bmpHomeframe, wxT("Starting frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTFRAME, bmpNextframe, wxT("Next frame"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSLAYERS, bmpLesslayers, wxT("Remove a layer"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLLAYERS, bmpAlllayers, wxT("Show all layers"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORELAYERS, bmpMorelayers, wxT("Add a layer"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSRES, bmpLessres, wxT("Reduce the resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWFULLRES, bmpFullres, wxT("Full resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORERES, bmpMoreres, wxT("Increase the resolution"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVCOMP, bmpPrevcomp, wxT("Previous component"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLCOMPS, bmpAllcomps, wxT("All components"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTCOMP, bmpNextcomp, wxT("Next component"));
+	tool_bar->Realize();
+	
+	// associate the toolbar with the frame
+	SetToolBar(tool_bar);
+
+	// show the toolbar?
+	if (!wxGetApp().m_showtoolbar)
+		tool_bar->Show(false);
+	else
+		tool_bar->Show(true);
+
 	// the logging window
 	loggingWindow = new wxSashLayoutWindow(this, OPJFRAME_LOGWIN,
-											wxDefaultPosition, wxSize(400, 130),
+											wxDefaultPosition, wxSize(400, wxGetApp().m_peekerheight),
 											wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
 											);
-	loggingWindow->SetDefaultSize(wxSize(1000, 130));
+	loggingWindow->SetDefaultSize(wxSize(1000, wxGetApp().m_peekerheight));
 	loggingWindow->SetOrientation(wxLAYOUT_HORIZONTAL);
 	loggingWindow->SetAlignment(wxLAYOUT_BOTTOM);
 	//loggingWindow->SetBackgroundColour(wxColour(0, 0, 255));
 	loggingWindow->SetSashVisible(wxSASH_TOP, true);
 
+	// show the logging?
+	if (!wxGetApp().m_showpeeker)
+		loggingWindow->Show(false);
+	else
+		loggingWindow->Show(true);
+
 	// create the bottom notebook
 	m_bookCtrlbottom = new wxNotebook(loggingWindow, BOTTOM_NOTEBOOK_ID,
 								wxDefaultPosition, wxDefaultSize,
@@ -385,10 +705,10 @@
 
 	// the browser window
 	markerTreeWindow = new wxSashLayoutWindow(this, OPJFRAME_BROWSEWIN,
-											  wxDefaultPosition, wxSize(300, 30),
+											  wxDefaultPosition, wxSize(wxGetApp().m_browserwidth, 30),
 											  wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
 											  );
-	markerTreeWindow->SetDefaultSize(wxSize(300, 1000));
+	markerTreeWindow->SetDefaultSize(wxSize(wxGetApp().m_browserwidth, 1000));
 	markerTreeWindow->SetOrientation(wxLAYOUT_VERTICAL);
 	markerTreeWindow->SetAlignment(wxLAYOUT_LEFT);
 	//markerTreeWindow->SetBackgroundColour(wxColour(0, 255, 0));
@@ -400,6 +720,12 @@
 								wxDefaultPosition, wxDefaultSize,
 								wxBK_TOP);
 
+	// show the browser?
+	if (!wxGetApp().m_showbrowser)
+		markerTreeWindow->Show(false);
+	else
+		markerTreeWindow->Show(true);
+
 #ifdef __WXMOTIF__
 	// For some reason, we get a memcpy crash in wxLogStream::DoLogStream
 	// on gcc/wxMotif, if we use wxLogTextCtl. Maybe it's just gcc?
@@ -418,6 +744,9 @@
 // this is the frame destructor
 OPJFrame::~OPJFrame(void)
 {
+	// save size settings
+	GetSize(&(wxGetApp().m_framewidth), &(wxGetApp().m_frameheight));
+
 	// delete all possible things
 	delete m_bookCtrl;
 	m_bookCtrl = NULL;
@@ -461,6 +790,32 @@
 
     if (dialog.ShowModal() == wxID_OK) {
 
+		// load settings
+		wxGetApp().m_subsampling = dialog.m_subsamplingCtrl->GetValue();
+		wxGetApp().m_origin = dialog.m_originCtrl->GetValue();
+		wxGetApp().m_rates = dialog.m_rateCtrl->GetValue();
+		wxGetApp().m_quality = dialog.m_qualityCtrl->GetValue();
+		wxGetApp().m_enablequality = dialog.m_qualityRadio->GetValue();
+		wxGetApp().m_multicomp = dialog.m_mctCheck->GetValue();
+		wxGetApp().m_irreversible = dialog.m_irrevCheck->GetValue();
+		wxGetApp().m_resolutions = dialog.m_resolutionsCtrl->GetValue();
+		wxGetApp().m_cbsize = dialog.m_cbsizeCtrl->GetValue();
+		wxGetApp().m_prsize = dialog.m_prsizeCtrl->GetValue();
+		wxGetApp().m_tsize = dialog.m_tsizeCtrl->GetValue();
+		wxGetApp().m_torigin = dialog.m_toriginCtrl->GetValue();
+		wxGetApp().m_progression = dialog.progressionBox->GetSelection();
+		wxGetApp().m_enablesop = dialog.m_sopCheck->GetValue();
+		wxGetApp().m_enableeph = dialog.m_ephCheck->GetValue();
+		wxGetApp().m_enablebypass = dialog.m_enablebypassCheck->GetValue();
+		wxGetApp().m_enablereset = dialog.m_enableresetCheck->GetValue();
+		wxGetApp().m_enablerestart = dialog.m_enablerestartCheck->GetValue();
+		wxGetApp().m_enablevsc = dialog.m_enablevscCheck->GetValue();
+		wxGetApp().m_enableerterm = dialog.m_enableertermCheck->GetValue();
+		wxGetApp().m_enablesegmark = dialog.m_enablesegmarkCheck->GetValue();
+		wxGetApp().m_enableidx = dialog.m_enableidxCheck->GetValue();
+		wxGetApp().m_index = dialog.m_indexCtrl->GetValue();
+		wxGetApp().m_enablecomm = dialog.m_enablecommCheck->GetValue();
+		wxGetApp().m_comment = dialog.m_commentCtrl->GetValue();
 	};
 }
 
@@ -472,7 +827,8 @@
 
 		// load settings
 		wxGetApp().m_enabledeco = dialog.m_enabledecoCheck->GetValue();
-		wxGetApp().m_resizemethod = dialog.m_resizeBox->GetSelection();
+		wxGetApp().m_enableparse = dialog.m_enableparseCheck->GetValue();
+		wxGetApp().m_resizemethod = dialog.m_resizeBox->GetSelection() - 1;
 		wxGetApp().m_reducefactor = dialog.m_reduceCtrl->GetValue();
 		wxGetApp().m_qualitylayers = dialog.m_layerCtrl->GetValue();
 		wxGetApp().m_components = dialog.m_numcompsCtrl->GetValue();
@@ -548,16 +904,23 @@
 void OPJFrame::Rescale(int zooml, OPJChildFrame *currframe)
 {
 	wxImage new_image = currframe->m_canvas->m_image100.ConvertToImage();
+
+	// resizing enabled?
+	if (wxGetApp().m_resizemethod == -1) {
+		zooml = 100;
+	}
+
 	if (zooml != 100)
 		new_image.Rescale((int) ((double) zooml * (double) new_image.GetWidth() / 100.0),
 			(int) ((double) zooml * (double) new_image.GetHeight() / 100.0),
 			wxGetApp().m_resizemethod ? wxIMAGE_QUALITY_HIGH : wxIMAGE_QUALITY_NORMAL);
-    currframe->m_canvas->m_image = wxBitmap(new_image);
+	currframe->m_canvas->m_image = wxBitmap(new_image);
 	currframe->m_canvas->SetScrollbars(20,
 										20,
 										(int)(0.5 + (double) new_image.GetWidth() / 20.0),
 										(int)(0.5 + (double) new_image.GetHeight() / 20.0)
 										);
+
 	currframe->m_canvas->Refresh();
 
 	// update zoom
@@ -569,19 +932,120 @@
 {
 	OPJChildFrame *currframe = (OPJChildFrame *) GetActiveChild();
 
-    OPJDecoThread *dthread = currframe->m_canvas->CreateDecoThread();
+	if (currframe) {
+		OPJDecoThread *dthread = currframe->m_canvas->CreateDecoThread();
 
-    if (dthread->Run() != wxTHREAD_NO_ERROR)
-        wxLogMessage(wxT("Can't start deco thread!"));
-    else
-		wxLogMessage(wxT("New deco thread started."));
+		if (dthread->Run() != wxTHREAD_NO_ERROR)
+			wxLogMessage(wxT("Can't start deco thread!"));
+		else
+			wxLogMessage(wxT("New deco thread started."));
 
-	currframe->m_canvas->Refresh();
+		currframe->m_canvas->Refresh();
 
-	// update zoom
-	//currframe->m_canvas->m_zooml = zooml;
+		// update zoom
+		//currframe->m_canvas->m_zooml = zooml;
+	}
+}
+
+void OPJFrame::OnPrevFrame(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_framenum < 0)
+		wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnHomeFrame(wxCommandEvent& event)
+{
+	wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnNextFrame(wxCommandEvent& event)
+{
+	++wxGetApp().m_framenum;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnLessLayers(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_qualitylayers < 1)
+		wxGetApp().m_qualitylayers = 1;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnAllLayers(wxCommandEvent& event)
+{
+	wxGetApp().m_qualitylayers = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnMoreLayers(wxCommandEvent& event)
+{
+	++wxGetApp().m_qualitylayers;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnLessRes(wxCommandEvent& event)
+{
+	++wxGetApp().m_reducefactor;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnFullRes(wxCommandEvent& event)
+{
+	wxGetApp().m_reducefactor = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnMoreRes(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_reducefactor < 0)
+		wxGetApp().m_reducefactor = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnPrevComp(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_components < 1)
+		wxGetApp().m_components = 1;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnAllComps(wxCommandEvent& event)
+{
+	wxGetApp().m_components = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
 }
 
+void OPJFrame::OnNextComp(wxCommandEvent& event)
+{
+	++wxGetApp().m_components;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
 
 // about window for the frame
 void OPJFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
@@ -649,6 +1113,11 @@
 
     wxLayoutAlgorithm layout;
     layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showbrowser = markerTreeWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
 }
 
 void OPJFrame::OnTogglePeeker(wxCommandEvent& WXUNUSED(event))
@@ -660,10 +1129,33 @@
 
     wxLayoutAlgorithm layout;
     layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showpeeker = loggingWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+}
+
+void OPJFrame::OnToggleToolbar(wxCommandEvent& WXUNUSED(event))
+{
+    if (tool_bar->IsShown())
+        tool_bar->Show(false);
+    else
+        tool_bar->Show(true);
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showtoolbar = tool_bar->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
 }
 
 void OPJFrame::OnSashDrag(wxSashEvent& event)
 {
+	int wid, hei;
+
     if (event.GetDragStatus() == wxSASH_STATUS_OUT_OF_RANGE)
         return;
 
@@ -685,6 +1177,49 @@
 
     // Leaves bits of itself behind sometimes
     GetClientWindow()->Refresh();
+
+	// update dimensions
+	markerTreeWindow->GetSize(&wid, &hei);
+	wxGetApp().m_browserwidth = wid;
+
+	loggingWindow->GetSize(&wid, &hei);
+	wxGetApp().m_peekerheight = hei;
+
+}
+
+// physically save the file
+void OPJFrame::SaveFile(wxArrayString paths, wxArrayString filenames)
+{
+	size_t count = paths.GetCount();
+	wxString msg, s;
+
+	if (wxFile::Exists(paths[0].c_str())) {
+
+		s.Printf(wxT("File %s already exists. Do you want to overwrite it?\n"), filenames[0].c_str());
+		wxMessageDialog dialog3(this, s, _T("File exists"), wxYES_NO);
+		if (dialog3.ShowModal() == wxID_NO)
+			return;
+	}
+
+	/*s.Printf(_T("File %d: %s (%s)\n"), (int)0, paths[0].c_str(), filenames[0].c_str());
+	msg += s;
+
+	wxMessageDialog dialog2(this, msg, _T("Selected files"));
+	dialog2.ShowModal();*/
+
+	if (!GetActiveChild())
+		return;
+
+	((OPJChildFrame *) GetActiveChild())->m_canvas->m_savename = paths[0];
+
+	OPJEncoThread *ethread = ((OPJChildFrame *) GetActiveChild())->m_canvas->CreateEncoThread();
+
+    if (ethread->Run() != wxTHREAD_NO_ERROR)
+        wxLogMessage(wxT("Can't start enco thread!"));
+    else
+		wxLogMessage(wxT("New enco thread started."));
+
+
 }
 
 // physically open the files
@@ -767,6 +1302,48 @@
 
 }
 
+void OPJFrame::OnFileSaveAs(wxCommandEvent& WXUNUSED(event))
+{
+    wxString wildcards =
+#ifdef wxUSE_LIBOPENJPEG
+#ifdef __WXMOTIF__
+	wxT("JPEG 2000 codestream (*.j2k)|*.*j*2*");
+#else
+	wxT("JPEG 2000 codestream (*.j2k)|*.j2k")
+	wxT("|JPEG 2000 file format (*.jp2)|*.jp2");
+#endif
+#endif
+
+    wxFileDialog dialog(this, _T("Save image file"),
+                        wxEmptyString, wxEmptyString, wildcards,
+                        wxFD_SAVE);
+
+    if (dialog.ShowModal() == wxID_OK) {
+        wxArrayString paths, filenames;
+
+        dialog.GetPaths(paths);
+        dialog.GetFilenames(filenames);
+
+		SaveFile(paths, filenames);
+    }
+
+
+}
+
+void OPJFrame::OnMemoryOpen(wxCommandEvent& WXUNUSED(event))
+{
+	wxTextEntryDialog dialog(this, wxT("Memory HEX address range: start_address-stop_address"),
+							wxT("Decode a memory buffer"),
+							wxT("0x-0x"),
+							wxOK | wxCANCEL | wxCENTRE,
+							wxDefaultPosition);
+
+	if (dialog.ShowModal() == wxID_OK) {
+
+	}
+
+}
+
 BEGIN_EVENT_TABLE(OPJCanvas, wxScrolledWindow)
     EVT_MOUSE_EVENTS(OPJCanvas::OnEvent)
 END_EVENT_TABLE()
@@ -809,6 +1386,19 @@
     return dthread;
 }
 
+OPJEncoThread *OPJCanvas::CreateEncoThread(void)
+{
+    OPJEncoThread *ethread = new OPJEncoThread(this);
+
+    if (ethread->Create() != wxTHREAD_NO_ERROR)
+		wxLogError(wxT("Can't create enco thread!"));
+
+    wxCriticalSectionLocker enter(wxGetApp().m_enco_critsect);
+    wxGetApp().m_enco_threads.Add(ethread);
+
+    return ethread;
+}
+
 #define activeoverlay 0
 // Define the repainting behaviour
 void OPJCanvas::OnDraw(wxDC& dc)
@@ -828,7 +1418,11 @@
 	} else {
 		dc.SetFont(*wxSWISS_FONT);
 		dc.SetPen(*wxBLACK_PEN);
+#ifdef __WXGTK__
+		dc.DrawText(_T("Decoding image, please wait... (press \"Zoom to Fit\" to show the image)"), 40, 50);
+#else
 		dc.DrawText(_T("Decoding image, please wait..."), 40, 50);
+#endif
 	}
 }
 
@@ -1125,32 +1719,39 @@
 	// open the file
 	wxFile m_file(fname.GetFullPath().c_str(), wxFile::read);
 
-	// what is the extension?
-	if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
+	// parsing enabled?
+	if (wxGetApp().m_enableparse) {
+
+		// what is the extension?
+		if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
 
-		// parse the file
-		ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
+			// parse the file
+			ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
 
-	} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
+		} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
+
+			// parse the file
+			if (this->m_parentid) {
+				//WriteText(wxT("Only a subsection of jp2"));
+				OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
+				ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
+				m_tree->Expand(rootid);
+
+			} else {
+				// as usual
+				ParseJP2File(&m_file, 0, m_file.Length(), rootid);
+			}
 
-		// parse the file
-		if (this->m_parentid) {
-			//WriteText(wxT("Only a subsection of jp2"));
-			OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
-			ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
-			m_tree->Expand(rootid);
-
-		} else
-			// as usual
-			ParseJP2File(&m_file, 0, m_file.Length(), rootid);
+		} else {
 
-	} else {
+			// unknown extension
+			WriteText(wxT("Unknown file format!"));
 
-		// unknown extension
-		WriteText(wxT("Unknown file format!"));
+		}
 
 	}
 
+
 	// this is the root node
 	if (this->m_parentid)
 		m_tree->SetItemText(rootid, wxT("Codestream"));
@@ -1369,14 +1970,13 @@
 
 void OPJMarkerTree::OnSelChanged(wxTreeEvent& event)
 {
-#define BUNCH_LINESIZE	16
-#define BUNCH_NUMLINES	7
+	int bunch_linesize = 16;
+	int bunch_numlines = 7;
 
 	wxTreeItemId item = event.GetItem();
 	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
 	wxString text;
 	int l, c, pos = 0, pre_pos;
-	unsigned char buffer[BUNCH_LINESIZE * BUNCH_NUMLINES];
 
 	m_peektextCtrl->Clear();
 
@@ -1391,19 +1991,25 @@
 	fp->Seek(data->m_start, wxFromStart);
 
 	// read a bunch
-	int max_read = wxMin(wxFileOffset(WXSIZEOF(buffer)), data->m_length - data->m_start + 1);
+	int max_read = wxMin(wxFileOffset(bunch_linesize * bunch_numlines), data->m_length - data->m_start + 1);
+	if (data->m_desc == wxT("MARK (65380)")) {
+		/*wxLogMessage(data->m_desc);*/
+		max_read = data->m_length - data->m_start + 1;
+		bunch_numlines = (int) ceil((float) max_read / (float) bunch_linesize);
+	}
+	unsigned char *buffer = new unsigned char[bunch_linesize * bunch_numlines];
 	fp->Read(buffer, max_read);
 
 	// write the file data between start and stop
 	pos = 0;
-	for (l = 0; l < BUNCH_NUMLINES; l++) {
+	for (l = 0; l < bunch_numlines; l++) {
 
 		text << wxString::Format(wxT("%010d:"), data->m_start + pos);
 
 		pre_pos = pos;
 
 		// add hex browsing text
-		for (c = 0; c < BUNCH_LINESIZE; c++) {
+		for (c = 0; c < bunch_linesize; c++) {
 
 			if (!(c % 8))
 				text << wxT(" ");
@@ -1418,7 +2024,7 @@
 		text << wxT("    ");
 
 		// add char browsing text
-		for (c = 0; c < BUNCH_LINESIZE; c++) {
+		for (c = 0; c < bunch_linesize; c++) {
 
 			if (pre_pos < max_read) {
 				if ((buffer[pre_pos] == '\n') ||
@@ -1427,7 +2033,7 @@
 					(buffer[pre_pos] == 0x0D) ||
 					(buffer[pre_pos] == 0x0B))
 					buffer[pre_pos] = ' ';
-				text << wxString::Format(wxT("%c."), wxChar(buffer[pre_pos]));
+				text << wxString::FromAscii((char) buffer[pre_pos]) << wxT(".");
 			} else
 				text << wxT("  ");
 			pre_pos++;
@@ -1441,6 +2047,8 @@
 	fp->Close();
 
 	m_peektextCtrl->WriteText(text);
+
+	delete buffer;
 }
 
 /*void LogKeyEvent(const wxChar *name, const wxKeyEvent& event)
@@ -1822,6 +2430,104 @@
 }
 
 /////////////////////////////////////////////////////////////////////
+// Encoding thread class
+/////////////////////////////////////////////////////////////////////
+
+OPJEncoThread::OPJEncoThread(OPJCanvas *canvas)
+        : wxThread()
+{
+    m_count = 0;
+    m_canvas = canvas;
+}
+
+void OPJEncoThread::WriteText(const wxString& text)
+{
+    wxString msg;
+
+    // before doing any GUI calls we must ensure that this thread is the only
+    // one doing it!
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif // __WXGTK__
+
+    msg << text;
+    m_canvas->WriteText(msg);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif // __WXGTK__
+}
+
+void OPJEncoThread::OnExit()
+{
+    wxCriticalSectionLocker locker(wxGetApp().m_enco_critsect);
+
+    wxArrayThread& ethreads = wxGetApp().m_enco_threads;
+    ethreads.Remove(this);
+
+    if (ethreads.IsEmpty() )
+    {
+        // signal the main thread that there are no more threads left if it is
+        // waiting for us
+        if (wxGetApp().m_enco_waitingUntilAllDone) {
+            wxGetApp().m_enco_waitingUntilAllDone = false;
+            wxGetApp().m_enco_semAllDone.Post();
+        }
+    }
+}
+
+void *OPJEncoThread::Entry()
+{
+    wxString text;
+
+	srand(GetId());
+	//int m_countnum = rand() % 9;
+    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
+    //            GetId(), GetPriority(), m_countnum);
+    text.Printf(wxT("Enco thread %d started"), m_canvas->m_childframe->m_winnumber);
+    WriteText(text);
+
+	// set handler properties
+	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
+	j2kkkhandler->m_subsampling = wxGetApp().m_subsampling;
+	j2kkkhandler->m_origin = wxGetApp().m_origin;
+	j2kkkhandler->m_rates = wxGetApp().m_rates;
+	j2kkkhandler->m_quality = wxGetApp().m_quality;
+	j2kkkhandler->m_enablequality = wxGetApp().m_enablequality;
+	j2kkkhandler->m_multicomp = wxGetApp().m_multicomp;
+	j2kkkhandler->m_irreversible = wxGetApp().m_irreversible;
+	j2kkkhandler->m_resolutions = wxGetApp().m_resolutions;
+	j2kkkhandler->m_progression = wxGetApp().m_progression;
+	j2kkkhandler->m_cbsize = wxGetApp().m_cbsize;
+	j2kkkhandler->m_prsize = wxGetApp().m_prsize;
+	j2kkkhandler->m_tsize = wxGetApp().m_tsize;
+	j2kkkhandler->m_torigin = wxGetApp().m_torigin;
+	j2kkkhandler->m_enablesop = wxGetApp().m_enablesop;
+	j2kkkhandler->m_enableeph = wxGetApp().m_enableeph;
+	j2kkkhandler->m_enablebypass = wxGetApp().m_enablebypass;
+	j2kkkhandler->m_enablerestart = wxGetApp().m_enablerestart;
+	j2kkkhandler->m_enablereset = wxGetApp().m_enablereset;
+	j2kkkhandler->m_enablesegmark = wxGetApp().m_enablesegmark;
+	j2kkkhandler->m_enableerterm = wxGetApp().m_enableerterm;
+	j2kkkhandler->m_enablevsc = wxGetApp().m_enablevsc;
+	j2kkkhandler->m_enableidx = wxGetApp().m_enableidx;
+	j2kkkhandler->m_index = m_canvas->m_savename.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR) + wxGetApp().m_index;
+	j2kkkhandler->m_enablecomm = wxGetApp().m_enablecomm;
+	j2kkkhandler->m_comment = wxGetApp().m_comment;
+
+	// save the file
+	if (!m_canvas->m_image100.SaveFile(m_canvas->m_savename.GetFullPath(), (wxBitmapType) wxBITMAP_TYPE_J2K)) {
+		WriteText(wxT("Can't save image"));
+		return NULL;
+	}
+
+    text.Printf(wxT("Enco thread %d finished"), m_canvas->m_childframe->m_winnumber);
+    WriteText(text);
+    return NULL;
+}
+
+/////////////////////////////////////////////////////////////////////
 // Decoding thread class
 /////////////////////////////////////////////////////////////////////
 
@@ -2062,908 +2768,3 @@
 
 
 
-// ----------------------------------------------------------------------------
-// OPJDecoderDialog
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
-
-BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
-#ifdef USE_JPWL
-	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
-	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
-#endif // USE_JPWL
-END_EVENT_TABLE()
-
-OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
-{
-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
-
-	Create(win, wxID_ANY, wxT("Decoder settings"),
-		wxDefaultPosition, wxDefaultSize,
-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
-		);
-
-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
-
-	m_settingsNotebook = GetBookCtrl();
-
-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
-	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpeg2000Settings->Enable(false);
-	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		mjpeg2000Settings->Enable(false);
-#ifdef USE_JPWL
-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpwlSettings->Enable(false);
-#endif // USE_JPWL
-
-	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
-	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
-	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
-#ifdef USE_JPWL
-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
-#endif // USE_JPWL
-
-	LayoutDialog();
-}
-
-OPJDecoderDialog::~OPJDecoderDialog()
-{
-}
-
-wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-		// add decoding enabling check box
-		subtopSizer->Add(
-			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
-			0, wxGROW | wxALL, 5);
-		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
-
-			// resize settings, column
-			wxString choices[] = {wxT("Low quality"), wxT("High quality")};
-			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
-				wxT("Resize method"),
-				wxDefaultPosition, wxDefaultSize,
-				WXSIZEOF(choices),
-				choices,
-				1,
-				wxRA_SPECIFY_ROWS);
-			m_resizeBox->SetSelection(wxGetApp().m_resizemethod);
-
-		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-			// frame settings, column
-			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
-			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
-
-				// selected frame number, row
-				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				framenumSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				framenumSizer->Add(
-					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
-								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_framenum),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-			// resolutions settings, column
-			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
-			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
-
-				// reduce factor sizer, row
-				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				reduceSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				reduceSizer->Add(
-					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
-					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 10000, wxGetApp().m_reducefactor),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
-
-			// quality layer settings, column
-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				qualitySizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				qualitySizer->Add(
-					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
-								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_qualitylayers),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-
-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
-
-			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				numcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				numcompsSizer->Add(
-					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_components),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_components),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_numcompsCtrl->Enable(true);
-
-			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-#ifdef USE_JPWL
-wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-		// add JPWL enabling check box
-		subtopSizer->Add(
-			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
-			0, wxGROW | wxALL, 5);
-		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
-
-			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// expected components sizer, row
-				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				expcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				expcompsSizer->Add(
-					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_expcomps),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
-
-			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-
-			// tiles settings, column
-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
-
-				// maximum tiles sizer, row
-				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				maxtileSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				maxtileSizer->Add(
-					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
-								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								1, 100000, wxGetApp().m_maxtiles),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
-
-			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
-{
-	size_t pp;
-
-	if (event.IsChecked()) {
-		wxLogMessage(wxT("Decoding enabled"));
-		m_resizeBox->Enable(true);
-		// enable all tabs except ourselves
-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
-				m_settingsNotebook->GetPage(pp)->Enable(true);
-		}
-	} else {
-		wxLogMessage(wxT("Decoding disabled"));
-		m_resizeBox->Enable(false);
-		// disable all tabs except ourselves
-		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
-			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
-				m_settingsNotebook->GetPage(pp)->Enable(false);
-		}
-	}
-
-}
-
-void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
-{
-	if (event.IsChecked()) {
-		wxLogMessage(wxT("JPWL enabled"));
-		m_expcompsCtrl->Enable(true);
-		m_maxtilesCtrl->Enable(true);
-	} else {
-		wxLogMessage(wxT("JPWL disabled"));
-		m_expcompsCtrl->Enable(false);
-		m_maxtilesCtrl->Enable(false);
-	}
-
-}
-
-#endif // USE_JPWL
-
-bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
-{
-    /*size_t nFiles = filenames.GetCount();
-    wxString str;
-    str.Printf( _T("%d files dropped\n"), (int)nFiles);
-    for ( size_t n = 0; n < nFiles; n++ ) {
-        str << filenames[n] << wxT("\n");
-    }
-    wxLogMessage(str);*/
-	m_pOwner->OpenFiles(filenames, filenames);
-
-    return true;
-}
-
-
-
-
-
-// ----------------------------------------------------------------------------
-// OPJEncoderDialog
-// ----------------------------------------------------------------------------
-
-IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
-
-BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
-#ifdef USE_JPWL
-	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
-#endif // USE_JPWL
-END_EVENT_TABLE()
-
-OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
-{
-	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
-
-	Create(win, wxID_ANY, wxT("Encoder settings"),
-		wxDefaultPosition, wxDefaultSize,
-		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
-		);
-
-	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
-
-	m_settingsNotebook = GetBookCtrl();
-
-	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
-	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
-/*	if (!wxGetApp().m_enabledeco)
-		jpeg2000Settings->Enable(false);
-	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		mjpeg2000Settings->Enable(false);
-#ifdef USE_JPWL
-	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
-	if (!wxGetApp().m_enabledeco)
-		jpwlSettings->Enable(false);
-#endif // USE_JPWL
-*/
-
-	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
-	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
-/*	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
-#ifdef USE_JPWL
-	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
-#endif // USE_JPWL
-*/
-	LayoutDialog();
-}
-
-OPJEncoderDialog::~OPJEncoderDialog()
-{
-}
-
-wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-		// sub top sizer
-		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
-
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-wxPanel* OPJEncoderDialog::CreatePart1SettingsPage(wxWindow* parent)
-{
-    wxPanel* panel = new wxPanel(parent, wxID_ANY);
-
-	// top sizer
-    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
-
-	// add some space
-	//topSizer->AddSpacer(5);
-
-		// sub top sizer
-		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
-
-			// image settings, column
-			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
-			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
-
-				// subsampling factor sizer, row
-				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				subsSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				subsSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
-								wxT("1,1"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
-
-				// origin sizer, row
-				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				imorigSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				imorigSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_IMORIG,
-								wxT("0,0"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
-
-			// layer settings, column
-			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
-			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
-
-				// rate factor sizer, row
-				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				rateSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				rateSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
-								wxT("20,10,5"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
-
-				// quality factor sizer, row
-				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				qualitySizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				qualitySizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
-								wxT("30,35,40"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
-
-			// wavelet settings, column
-			wxStaticBox* waveletBox = new wxStaticBox(panel, wxID_ANY, wxT("Transform"));
-			wxBoxSizer* waveletSizer = new wxStaticBoxSizer(waveletBox, wxVERTICAL);
-
-			// irreversible check box
-			waveletSizer->Add(
-				/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible"),
-				wxDefaultPosition, wxDefaultSize),
-				0, wxGROW | wxALL, 3);
-			/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// resolution number sizer, row
-				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				resnumSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				resnumSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
-								wxT("6"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 256, 6),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
-
-				// codeblock sizer, row
-				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				codeblockSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				codeblockSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
-								wxT("32,32"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
-
-				// precinct sizer, row
-				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				precinctSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				precinctSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
-								wxT("[128,128],[128,128]"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			waveletSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(waveletSizer, 0, wxGROW | wxALL, 3);
-
-			// tile settings, column
-			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
-			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
-
-				// tile size sizer, row
-				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				tilesizeSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_TILESIZE,
-								wxT(""),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
-
-				// tile origin sizer, row
-				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				tilorigSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				tilorigSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_TILORIG,
-								wxT("0,0"),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
-
-			// progression settings, column
-			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL")};
-			wxRadioBox *progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
-				wxT("Progression"),
-				wxDefaultPosition, wxDefaultSize,
-				WXSIZEOF(choices),
-				choices,
-				4,
-				wxRA_SPECIFY_COLS);
-			progressionBox->SetSelection(0);
-
-		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
-
-			// resilience settings, column
-			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Resilience"));
-			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
-
-				// resil2 sizer, row
-				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// SOP check box
-				resil2Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// EPH check box
-				resil2Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
-
-			// separation
-			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
-
-				// resil3 sizer, row
-				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
-
-				// BYPASS check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// RESET check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// RESTART check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// VSC check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// ERTERM check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// SEGMARK check box
-				resil3Sizer->Add(
-					/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
-					wxDefaultPosition, wxDefaultSize),
-					0, wxGROW | wxALL, 3);
-				/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
-
-			// ROI settings, column
-			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("ROI"));
-			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
-
-				// component number sizer, row
-				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				roicompSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				roicompSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
-								wxT("0"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 256, 0),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
-
-				// upshift sizer, row
-				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				roishiftSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				roishiftSizer->Add(
-					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
-								wxT("0"),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 37, 0),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
-
-			// ROI settings, column
-			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
-			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
-
-			// indexing check box
-			indexSizer->Add(
-				/*m_enabledecoCheck =*/ new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
-				wxDefaultPosition, wxDefaultSize),
-				0, wxGROW | wxALL, 3);
-			/*m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);*/
-
-				// index file sizer, row
-				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
-
-				// add some horizontal space
-				indexnameSizer->Add(3, 3, 1, wxALL, 0);
-
-				// add the value control
-				indexnameSizer->Add(
-					/*m_rateCtrl = */new wxTextCtrl(panel, OPJENCO_INDEXNAME,
-								wxT(""),
-								wxDefaultPosition, wxSize(120, wxDefaultCoord),
-								wxTE_LEFT),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
-
-			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
-
-		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
-
-/*			// component settings, column
-			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
-			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
-
-				// quality layers sizer, row
-				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
-
-				// add some text
-				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
-								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
-
-				// add some horizontal space
-				numcompsSizer->Add(5, 5, 1, wxALL, 0);
-
-				// add the value control
-				numcompsSizer->Add(
-					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
-								wxString::Format(wxT("%d"), wxGetApp().m_components),
-								wxDefaultPosition, wxSize(80, wxDefaultCoord),
-								wxSP_ARROW_KEYS,
-								0, 100000, wxGetApp().m_components),
-					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
-				m_numcompsCtrl->Enable(true);
-
-			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
-
-		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
-*/
-	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
-
-	// assign top and fit it
-    panel->SetSizer(topSizer);
-    topSizer->Fit(panel);
-
-    return panel;
-}
-
-#ifdef USE_JPWL
-void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
-{
-	/*if (event.IsChecked()) {
-		wxLogMessage(wxT("JPWL enabled"));
-		m_expcompsCtrl->Enable(true);
-		m_maxtilesCtrl->Enable(true);
-	} else {
-		wxLogMessage(wxT("JPWL disabled"));
-		m_expcompsCtrl->Enable(false);
-		m_maxtilesCtrl->Enable(false);
-	}*/
-
-}
-#endif // USE_JPWL
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/OPJViewer.h ./OPJViewer/source/OPJViewer.h
--- /home/robin/sldeb/trunk/OPJViewer/source/OPJViewer.h	2007-06-03 18:34:46.000000000 +0100
+++ ./OPJViewer/source/OPJViewer.h	2007-11-27 22:39:50.000000000 +0000
@@ -98,6 +98,9 @@
 
 #include <wx/imaglist.h>
 
+#include "wx/toolbar.h"
+#include "wx/artprov.h"
+
 #include "libopenjpeg/openjpeg.h"
 
 #include "imagj2k.h"
@@ -128,6 +131,7 @@
 #define OPJ_APPLICATION_VERSION		wxT("0.3 alpha")
 #define OPJ_APPLICATION_TITLEBAR	OPJ_APPLICATION_NAME wxT(" ") OPJ_APPLICATION_VERSION
 #define OPJ_APPLICATION_COPYRIGHT	wxT("(C) 2007, Giuseppe Baruffa")
+#define OPJ_APPLICATION_VENDOR      wxT("OpenJPEG")
 
 #ifdef __WXMSW__
 #define OPJ_APPLICATION_PLATFORM    wxT("Windows")
@@ -137,10 +141,17 @@
 #define OPJ_APPLICATION_PLATFORM    wxT("Linux")
 #endif
 
+#define OPJ_FRAME_WIDTH   800
+#define OPJ_FRAME_HEIGHT  600
+
+#define OPJ_BROWSER_WIDTH 300
+#define OPJ_PEEKER_HEIGHT 130
+
 #define OPJ_CANVAS_BORDER 10
 #define OPJ_CANVAS_COLOUR *wxWHITE
 
 class OPJDecoThread;
+class OPJEncoThread;
 class OPJParseThread;
 WX_DEFINE_ARRAY_PTR(wxThread *, wxArrayThread);
 class OPJChildFrame;
@@ -158,23 +169,24 @@
 
 		// other methods
 		bool OnInit(void);
+		int OnExit(void);
 		void SetShowImages(bool show) { m_showImages = show; }
 		bool ShowImages() const { return m_showImages; }
 		void ShowCmdLine(const wxCmdLineParser& parser);
 
 		// all the threads currently alive - as soon as the thread terminates, it's
 		// removed from the array
-		wxArrayThread m_deco_threads, m_parse_threads;
+		wxArrayThread m_deco_threads, m_parse_threads, m_enco_threads;
 
 		// crit section protects access to all of the arrays below
-		wxCriticalSection m_deco_critsect, m_parse_critsect;
+		wxCriticalSection m_deco_critsect, m_parse_critsect, m_enco_critsect;
 
 		// semaphore used to wait for the threads to exit, see OPJFrame::OnQuit()
-		wxSemaphore m_deco_semAllDone, m_parse_semAllDone;
+		wxSemaphore m_deco_semAllDone, m_parse_semAllDone, m_enco_semAllDone;
 
 		// the last exiting thread should post to m_semAllDone if this is true
 		// (protected by the same m_critsect)
-		bool m_deco_waitingUntilAllDone, m_parse_waitingUntilAllDone;
+		bool m_deco_waitingUntilAllDone, m_parse_waitingUntilAllDone, m_enco_waitingUntilAllDone;
 
 		// the list of all filenames written in the command line
 		wxArrayString m_filelist;
@@ -183,13 +195,30 @@
 		int m_resizemethod;
 
 		// decoding engine parameters
-		bool m_enabledeco;
+		bool m_enabledeco, m_enableparse;
 		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
 #ifdef USE_JPWL
 		bool m_enablejpwl;
 		int m_expcomps, m_maxtiles;
+		int m_framewidth, m_frameheight;
 #endif // USE_JPWL
 
+		// encoding engine parameters
+		wxString m_subsampling, m_origin, m_rates, m_comment, m_index, m_quality;
+		wxString m_cbsize, m_prsize, m_tsize, m_torigin;
+		bool m_enablecomm, m_enableidx, m_multicomp, m_irreversible, m_enablesop, m_enableeph;
+		bool m_enablebypass, m_enablereset, m_enablerestart, m_enablevsc, m_enableerterm;
+		bool m_enablesegmark;
+		bool m_enablequality;
+		int m_resolutions, m_progression;
+
+		// some layout settings
+		bool m_showtoolbar, m_showbrowser, m_showpeeker;
+		int m_browserwidth, m_peekerheight;
+
+		// application configuration
+		wxConfig *OPJconfig; 
+
 	// private methods and variables
 	private:
 		bool m_showImages, m_showButtons;
@@ -221,10 +250,11 @@
 #endif //__WXGTK__
 		}
 		OPJDecoThread *CreateDecoThread(void);
+		OPJEncoThread *CreateEncoThread(void);
 		OPJChildFrame *m_childframe;
 
 		wxBitmap  m_image, m_image100;
-		wxFileName m_fname;
+		wxFileName m_fname, m_savename;
 		long m_zooml;
 
 	DECLARE_EVENT_TABLE()
@@ -245,10 +275,10 @@
 		const wxChar *GetDesc1() const { return m_desc.c_str(); }
 		const wxChar *GetDesc2() const { return m_filestring.c_str(); }
 		wxFileOffset m_start, m_length;
+		wxString m_desc;
 
 	// private methods and variables
 	private:
-		wxString m_desc;
 		wxString m_filestring;
 };
 
@@ -364,17 +394,33 @@
 	void OnSize(wxSizeEvent& WXUNUSED(event));
     void OnAbout(wxCommandEvent& WXUNUSED(event));
     void OnFileOpen(wxCommandEvent& WXUNUSED(event));
+    void OnFileSaveAs(wxCommandEvent& WXUNUSED(event));
+    void OnMemoryOpen(wxCommandEvent& WXUNUSED(event));
     void OnQuit(wxCommandEvent& WXUNUSED(event));
     void OnClose(wxCommandEvent& WXUNUSED(event));
     void OnZoom(wxCommandEvent& WXUNUSED(event));
 	void OnFit(wxCommandEvent& WXUNUSED(event));
 	void OnToggleBrowser(wxCommandEvent& WXUNUSED(event));
 	void OnTogglePeeker(wxCommandEvent& WXUNUSED(event));
+	void OnToggleToolbar(wxCommandEvent& WXUNUSED(event));
 	void OnReload(wxCommandEvent& event);
+	void OnPrevFrame(wxCommandEvent& event);
+	void OnHomeFrame(wxCommandEvent& event);
+	void OnNextFrame(wxCommandEvent& event);
+	void OnLessLayers(wxCommandEvent& event);
+	void OnAllLayers(wxCommandEvent& event);
+	void OnMoreLayers(wxCommandEvent& event);
+	void OnLessRes(wxCommandEvent& event);
+	void OnFullRes(wxCommandEvent& event);
+	void OnMoreRes(wxCommandEvent& event);
+	void OnPrevComp(wxCommandEvent& event);
+	void OnAllComps(wxCommandEvent& event);
+	void OnNextComp(wxCommandEvent& event);
 	void OnSetsEnco(wxCommandEvent& event);
 	void OnSetsDeco(wxCommandEvent& event);
 	void OnSashDrag(wxSashEvent& event);
 	void OpenFiles(wxArrayString paths, wxArrayString filenames);
+	void SaveFile(wxArrayString paths, wxArrayString filenames);
 	void OnNotebook(wxNotebookEvent& event);
 	void Rescale(int scale, OPJChildFrame *child);
 
@@ -382,6 +428,7 @@
 	OPJChildFrameHash m_childhash;
     wxSashLayoutWindow* markerTreeWindow;
     wxSashLayoutWindow* loggingWindow;
+	wxToolBar* tool_bar;
     void Resize(int number);
 	wxNotebook *m_bookCtrl;
 	wxNotebook *m_bookCtrlbottom;
@@ -429,17 +476,33 @@
 	OPJFRAME_FILEEXIT = wxID_EXIT,
 	OPJFRAME_HELPABOUT = wxID_ABOUT,
 	OPJFRAME_FILEOPEN,
+	OPJFRAME_MEMORYOPEN,
+	OPJFRAME_FILESAVEAS,
 	OPJFRAME_FILETOGGLEB,
 	OPJFRAME_FILETOGGLEP,
+	OPJFRAME_FILETOGGLET,
 	OPJFRAME_VIEWZOOM,
 	OPJFRAME_VIEWFIT,
 	OPJFRAME_VIEWRELOAD,
+	OPJFRAME_VIEWPREVFRAME,
+	OPJFRAME_VIEWHOMEFRAME,
+	OPJFRAME_VIEWNEXTFRAME,
+	OPJFRAME_VIEWLESSLAYERS,
+	OPJFRAME_VIEWALLLAYERS,
+	OPJFRAME_VIEWMORELAYERS,
+	OPJFRAME_VIEWLESSRES,
+	OPJFRAME_VIEWFULLRES,
+	OPJFRAME_VIEWMORERES,
+	OPJFRAME_VIEWPREVCOMP,
+	OPJFRAME_VIEWALLCOMPS,
+	OPJFRAME_VIEWNEXTCOMP,
 	OPJFRAME_FILECLOSE,
 	OPJFRAME_SETSENCO,
 	OPJFRAME_SETSDECO,
 
 	OPJFRAME_BROWSEWIN = 10000,
-	OPJFRAME_LOGWIN
+	OPJFRAME_LOGWIN,
+	OPJFRAME_TOOLBAR
 };
 
 
@@ -494,6 +557,26 @@
 	LEFT_NOTEBOOK_ID
 };
 
+class OPJEncoThread : public wxThread
+{
+public:
+    OPJEncoThread(OPJCanvas *canvas);
+
+    // thread execution starts here
+    virtual void *Entry();
+
+    // called when the thread exits - whether it terminates normally or is
+    // stopped with Delete() (but not when it is Kill()ed!)
+    virtual void OnExit();
+
+    // write something to the text control
+    void WriteText(const wxString& text);
+
+public:
+    unsigned m_count;
+    OPJCanvas *m_canvas;
+};
+
 class OPJDecoThread : public wxThread
 {
 public:
@@ -569,21 +652,37 @@
 	wxBookCtrlBase* m_settingsNotebook;
 
     wxPanel* CreateMainSettingsPage(wxWindow* parent);
-    wxPanel* CreatePart1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_2SettingsPage(wxWindow* parent);
 /*    wxPanel* CreatePart3SettingsPage(wxWindow* parent);*/
 #ifdef USE_JPWL
 	void OnEnableJPWL(wxCommandEvent& event);
-/*    wxPanel* CreatePart11SettingsPage(wxWindow* parent);
-	wxCheckBox *m_enablejpwlCheck;*/
+	void OnEnableComm(wxCommandEvent& event);
+	void OnEnableIdx(wxCommandEvent& event);
+	void OnRadioQualityRate(wxCommandEvent& event);
+	wxPanel* CreatePart11SettingsPage(wxWindow* parent);
+	/*wxCheckBox *m_enablejpwlCheck;*/
 #endif // USE_JPWL
 
+	wxTextCtrl *m_subsamplingCtrl, *m_originCtrl, *m_rateCtrl, *m_commentCtrl;
+	wxRadioButton *m_rateRadio, *m_qualityRadio;
+	wxTextCtrl *m_indexCtrl, *m_qualityCtrl, *m_cbsizeCtrl, *m_prsizeCtrl, *m_pocCtrl;
+	wxTextCtrl *m_tsizeCtrl, *m_toriginCtrl;
+	wxRadioBox *progressionBox;
+	wxCheckBox *m_enablecommCheck, *m_enableidxCheck, *m_mctCheck, *m_irrevCheck;
+	wxCheckBox *m_sopCheck, *m_ephCheck, *m_enablebypassCheck, *m_enableresetCheck,
+		*m_enablerestartCheck, *m_enablevscCheck, *m_enableertermCheck, *m_enablesegmarkCheck;
+	wxCheckBox *m_enablepocCheck;
+	wxSpinCtrl *m_resolutionsCtrl;
 
 protected:
 
     enum {
 		OPJENCO_ENABLEJPWL = 100,
 		OPJENCO_RATEFACTOR,
+		OPJENCO_RATERADIO,
 		OPJENCO_QUALITYFACTOR,
+		OPJENCO_QUALITYRADIO,
 		OPJENCO_RESNUMBER,
 		OPJENCO_CODEBLOCKSIZE,
 		OPJENCO_PRECINCTSIZE,
@@ -598,13 +697,18 @@
 		OPJENCO_ENABLEVSC,
 		OPJENCO_ENABLEERTERM,
 		OPJENCO_ENABLESEGMARK,
+		OPJENCO_ENABLEPOC,
 		OPJENCO_ROICOMP,
 		OPJENCO_ROISHIFT,
 		OPJENCO_IMORIG,
 		OPJENCO_TILORIG,
+		OPJENCO_ENABLEMCT,
 		OPJENCO_ENABLEIRREV,
 		OPJENCO_ENABLEINDEX,
-		OPJENCO_INDEXNAME
+		OPJENCO_INDEXNAME,
+		OPJENCO_POCSPEC,
+		OPJENCO_ENABLECOMM,
+		OPJENCO_COMMENTTEXT
     };
 
 DECLARE_EVENT_TABLE()
@@ -619,7 +723,7 @@
     ~OPJDecoderDialog();
 
 	wxBookCtrlBase* m_settingsNotebook;
-	wxCheckBox *m_enabledecoCheck;
+	wxCheckBox *m_enabledecoCheck, *m_enableparseCheck;
 	wxSpinCtrl *m_reduceCtrl, *m_layerCtrl, *m_numcompsCtrl;
 	wxRadioBox* m_resizeBox;
 
@@ -644,6 +748,7 @@
 		OPJDECO_QUALITYLAYERS,
 		OPJDECO_NUMCOMPS,
 		OPJDECO_ENABLEDECO,
+		OPJDECO_ENABLEPARSE,
 		OPJDECO_ENABLEJPWL,
 		OPJDECO_EXPCOMPS,
 		OPJDECO_MAXTILES,
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/all-wcprops ./OPJViewer/source/.svn/all-wcprops
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/all-wcprops	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,173 @@
+K 25
+svn:wc:ra_dav:version-url
+V 40
+/svn/!svn/ver/469/trunk/OPJViewer/source
+END
+icon4.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/343/trunk/OPJViewer/source/icon4.xpm
+END
+imagjp2.h
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/356/trunk/OPJViewer/source/imagjp2.h
+END
+icon5.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/343/trunk/OPJViewer/source/icon5.xpm
+END
+OPJViewer.ico
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/343/trunk/OPJViewer/source/OPJViewer.ico
+END
+OPJViewer16.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/343/trunk/OPJViewer/source/OPJViewer16.xpm
+END
+build.h
+K 25
+svn:wc:ra_dav:version-url
+V 48
+/svn/!svn/ver/469/trunk/OPJViewer/source/build.h
+END
+OPJViewer.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 54
+/svn/!svn/ver/469/trunk/OPJViewer/source/OPJViewer.cpp
+END
+readmeafter.txt
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/375/trunk/OPJViewer/source/readmeafter.txt
+END
+readmebefore.txt
+K 25
+svn:wc:ra_dav:version-url
+V 57
+/svn/!svn/ver/356/trunk/OPJViewer/source/readmebefore.txt
+END
+OPJViewer.h
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/469/trunk/OPJViewer/source/OPJViewer.h
+END
+license.txt
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/375/trunk/OPJViewer/source/license.txt
+END
+wxj2kparser.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/468/trunk/OPJViewer/source/wxj2kparser.cpp
+END
+imagj2k.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/469/trunk/OPJViewer/source/imagj2k.cpp
+END
+OPJChild.ico
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/356/trunk/OPJViewer/source/OPJChild.ico
+END
+imagjpeg2000.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 57
+/svn/!svn/ver/397/trunk/OPJViewer/source/imagjpeg2000.cpp
+END
+OPJChild16.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/356/trunk/OPJViewer/source/OPJChild16.xpm
+END
+imagmj2.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/468/trunk/OPJViewer/source/imagmj2.cpp
+END
+about_htm.h
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/468/trunk/OPJViewer/source/about_htm.h
+END
+wxjp2parser.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 56
+/svn/!svn/ver/410/trunk/OPJViewer/source/wxjp2parser.cpp
+END
+imagj2k.h
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/469/trunk/OPJViewer/source/imagj2k.h
+END
+imagjp2.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 52
+/svn/!svn/ver/468/trunk/OPJViewer/source/imagjp2.cpp
+END
+opj_logo.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/364/trunk/OPJViewer/source/opj_logo.xpm
+END
+icon1.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/343/trunk/OPJViewer/source/icon1.xpm
+END
+imagmj2.h
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/364/trunk/OPJViewer/source/imagmj2.h
+END
+OPJDialogs.cpp
+K 25
+svn:wc:ra_dav:version-url
+V 55
+/svn/!svn/ver/469/trunk/OPJViewer/source/OPJDialogs.cpp
+END
+icon2.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/343/trunk/OPJViewer/source/icon2.xpm
+END
+OPJViewer.rc
+K 25
+svn:wc:ra_dav:version-url
+V 53
+/svn/!svn/ver/356/trunk/OPJViewer/source/OPJViewer.rc
+END
+icon3.xpm
+K 25
+svn:wc:ra_dav:version-url
+V 50
+/svn/!svn/ver/343/trunk/OPJViewer/source/icon3.xpm
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/entries ./OPJViewer/source/.svn/entries
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,366 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/OPJViewer/source
+http://www.openjpeg.org/svn
+
+
+
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+icon4.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+35ef61f312eca3a0fefbb0739502c1cd
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+imagjp2.h
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+25013eaea67b93f3a1017c6c5dfd856e
+2007-03-01T00:01:37.891000Z
+356
+unipg
+
+icon5.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+71518c8359b5e7319b9454158e243718
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+OPJViewer.ico
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+afdf003774bc96b6720a623389f8df31
+2007-02-22T17:05:58.742476Z
+343
+devaux
+has-props
+
+OPJViewer16.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+49abe41a5b96c08e03671a0f5cffaa00
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+build.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+4374667588326769e254dc386ad91d40
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+OPJViewer.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+5a19e4c9178b19ea70d47b31ae692fe6
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+readmeafter.txt
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+6522142049984871791a0134be566e9f
+2007-04-22T22:41:01.331384Z
+375
+unipg
+
+readmebefore.txt
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+5f90593dc8aa2659c7750d95822f6de9
+2007-03-01T00:01:37.891000Z
+356
+unipg
+
+OPJViewer.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+243415414fc3af7435d5251daccc7410
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+license.txt
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+26d1d2337820243263d64344fe4656bf
+2007-04-22T22:41:01.331384Z
+375
+unipg
+
+wxj2kparser.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+622d73601e8e71e413015d92846727bd
+2007-10-23T14:33:40.771959Z
+468
+unipg
+
+imagj2k.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+98d05c04fe87417ad9627fd399a2478c
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+OPJChild.ico
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+6f8e7cb8bdfdf2665caeb024b31d2cae
+2007-03-01T00:01:37.891000Z
+356
+unipg
+has-props
+
+OPJChild16.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+98929ac09c8e78dfce180d1fa8f37727
+2007-03-01T00:01:37.891000Z
+356
+unipg
+
+imagjpeg2000.cpp
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+566074b7ad74872ced3ca68b89940672
+2007-06-16T17:28:47.212959Z
+397
+unipg
+
+imagmj2.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+e071450d7b98c43265f547c19bd51e09
+2007-10-23T14:33:40.771959Z
+468
+unipg
+
+about_htm.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+d55eadce8f39c934ac82d44c50b1ab6a
+2007-10-23T14:33:40.771959Z
+468
+unipg
+
+wxjp2parser.cpp
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+61b5aefa5d7dd43a64d1b1d3eb00cfa4
+2007-08-02T12:45:28.829464Z
+410
+unipg
+
+imagj2k.h
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+9b47bee5abbd83a8b94fe5e20e85c3af
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+imagjp2.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+abc0111df4d47de93cf3e6f1081fa92b
+2007-10-23T14:33:40.771959Z
+468
+unipg
+
+opj_logo.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+b4f976245b8a3ac59dd23853d4b3a8c9
+2007-03-27T12:48:17.101066Z
+364
+unipg
+
+icon1.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+87b31ddebe11cfd44210f9479098a15f
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+imagmj2.h
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+0af4a8e0cf68cc703b86a1f218f9b62e
+2007-03-27T12:48:17.101066Z
+364
+unipg
+
+OPJDialogs.cpp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+eade1d29e6432cf9581e70e031def823
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+icon2.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+0fa2e59f2187296e7347a93e80a1e9b0
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+OPJViewer.rc
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+4ef98581910fc7ba3747cb425fc844d3
+2007-03-01T00:01:37.891000Z
+356
+unipg
+
+icon3.xpm
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+04344169b104fb5a203e00bd716b8a04
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/format ./OPJViewer/source/.svn/format
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/format	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/prop-base/OPJChild.ico.svn-base ./OPJViewer/source/.svn/prop-base/OPJChild.ico.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/prop-base/OPJChild.ico.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/prop-base/OPJChild.ico.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/prop-base/OPJViewer.ico.svn-base ./OPJViewer/source/.svn/prop-base/OPJViewer.ico.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/prop-base/OPJViewer.ico.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/prop-base/OPJViewer.ico.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,5 @@
+K 13
+svn:mime-type
+V 24
+application/octet-stream
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/about_htm.h.svn-base ./OPJViewer/source/.svn/text-base/about_htm.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/about_htm.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/about_htm.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,49 @@
+wxString htmlaboutpage = wxT(
+"<html>"
+"<body bgcolor=#FFFFFF>"
+"<table cellspacing=7 cellpadding=1 border=0 width=100%>"   
+"<tr>"
+"<td rowspan=3 valign=top align=center width=70>"
+"<img src=\"memory:opj_logo.xpm\"><br><br>" 
+"</td>"
+"<td align=center>"
+"<font size=+0 color=#000000><b>" 
+OPJ_APPLICATION " " OPJ_APPLICATION_VERSION 
+"</b></font><br>"
+"<font size=-1 color=#000000><b>A JPEG 2000 image viewer</b></font><br>"  
+"<font size=-2 color=#000000><b>" OPJ_APPLICATION_PLATFORM " version</b></font>"  
+"</td>"
+"</tr>"
+"<tr height=3 valign=center>"  
+"<td valign=center  bgcolor=#cc3300></td>"   
+"</tr>"
+"<tr>"
+"<td align=justify>"
+"<center><font size=+0 color=#000000><a href=\"http://www.openjpeg.org/\">OpenJPEG</a></font></center>"
+"<font size=-1 color=#000000>The OpenJPEG library is an open-source JPEG 2000 codec written in C language. "
+"In addition to the basic codec, various other features are under development.</font><br>"
+"<font size=-2 color=red>* Build: ")
+#include "build.h"
+wxT(", " __DATE__ ", " __TIME__ "</font><br>")
+wxT("<font size=-2 color=red>* " wxVERSION_STRING "</font><br>")
+#ifdef USE_JPWL
+wxT("<font size=-2 color=green>- Compiled with JPWL support</font><br>")
+#endif // USE_JPWL
+#ifdef USE_JPSEC
+wxT("<font size=-2 color=green>- Compiled with JPSEC support</font>")
+#endif // USE_JPSEC
+wxT("</td>"
+"</tr>"
+"<tr>"
+"<td colspan=2 bgcolor=#CC3300 height=3 valign=center></td>" 
+"</tr>"
+"<tr>"
+"<td colspan=2>"
+"<font size=-2 color=#444444>OpenJPEG is &copy; 2002-2007 <a href=\"http://www.tele.ucl.ac.be/\">TELE</a> - <a href=\"http://www.uclouvain.be/\">Universite' Catholique de Louvain</a></font><br>"
+"<font size=-2 color=#444444>OPJViewer is also &copy; 2007 <a href=\"http://dsplab.diei.unipg.it/\">DSPLab</a> - <a href=\"http://www.unipg.it/\">Universita' degli studi di Perugia</a></font>"
+"</td>"
+"</tr>"
+"</table>"
+"</body>"
+"</html>"
+);
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/build.h.svn-base ./OPJViewer/source/.svn/text-base/build.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/build.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/build.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1 @@
+wxT("292") 
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon1.xpm.svn-base ./OPJViewer/source/.svn/text-base/icon1.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon1.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/icon1.xpm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,79 @@
+/* XPM */
+static char *icon1_xpm[] = {
+/* columns rows colors chars-per-pixel */
+"32 32 41 1",
+"> c #97C4E7",
+"# c #4381AA",
+"d c #FFFFFF",
+"< c #71B2DE",
+"+ c #538BB1",
+"& c #D1E5F5",
+"q c #63B3DE",
+"6 c #F1F4F7",
+"* c #CAE1F3",
+"y c #7AC4E5",
+"= c #C3DDF1",
+"X c #74A1BD",
+"- c #BCD9EF",
+"5 c #619BC4",
+"3 c #E6EAF1",
+"2 c #4B8EBF",
+"o c #6B97B6",
+". c #4B82A8",
+"  c None",
+"w c #54A6D8",
+"1 c #71A8D1",
+", c #85BBE2",
+"t c #EFF6FC",
+"7 c #DEEDF8",
+"@ c #4388B4",
+"a c #F7FBFD",
+"$ c #D7E0E9",
+"r c #FAFCFE",
+"4 c #DAEAF7",
+"e c #E9F3FA",
+"0 c #76BAE2",
+"% c #7FA6C0",
+"s c #FDFDFE",
+"O c #5896BE",
+"p c #B6D5EE",
+"8 c #87ABC3",
+": c #A5CCEA",
+"9 c #E5F0F9",
+"; c #AFD1EC",
+"i c #F4F9FD",
+"u c #8FB0C3",
+/* pixels */
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"        .XXXooOO++@#$           ",
+"        %&*=-;:>>,<123          ",
+"        %4&*=-;:>>,1>56         ",
+"        %74&*=-;:>>1*>56        ",
+"        89700qqqqwq1e*>X        ",
+"        8e974&*=-;:1re*>8       ",
+"        8te974&*=-;11111#       ",
+"        8tty000qqqqqww>,+       ",
+"        uitte974&*=-p:>>+       ",
+"        uaitte974&*=-p:>O       ",
+"        uaayyyy000qqqqp:O       ",
+"        uraaitte974&*=-po       ",
+"        urraaitte974&*=-o       ",
+"        usryyyyyyy000q*=X       ",
+"        ussrraaitte974&*X       ",
+"        udssrraaitte974&X       ",
+"        uddyyyyyyyyyy074%       ",
+"        udddssrraaitte97%       ",
+"        uddddssrraaitte9%       ",
+"        udddddssrraaitte8       ",
+"        uddddddssrraaitt8       ",
+"        uuuuuuuuuuuuuu88u       ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                "
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon2.xpm.svn-base ./OPJViewer/source/.svn/text-base/icon2.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon2.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/icon2.xpm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,53 @@
+/* XPM */
+static char *icon2_xpm[] = {
+/* columns rows colors chars-per-pixel */
+"32 32 15 1",
+". c Black",
+"O c #97C4E7",
+"$ c #63B3DE",
+"@ c #CAE1F3",
+"; c #7AC4E5",
+"* c #74A1BD",
+"+ c #619BC4",
+"o c #4B8EBF",
+"  c None",
+"% c #54A6D8",
+"= c #FAFCFE",
+"& c #E9F3FA",
+"# c #76BAE2",
+"X c #C00000",
+"- c #87ABC3",
+/* pixels */
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"        .............           ",
+"        .XXXXXXXXXX.o.          ",
+"        .XXXXXXXXXX.O+.         ",
+"        .XXXXXXXXXX.@O+.        ",
+"        .XX##$$$$%$.&@O*        ",
+"        .XXXXXXXXXX.=&@O-       ",
+"        .XXXXXXXXXX......       ",
+"        .XX;###$$$$$%%XX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XX;;;;###$$$$XX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XX;;;;;;;###$XX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XX;;;;;;;;;;#XX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .XXXXXXXXXXXXXXX.       ",
+"        .................       ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                "
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon3.xpm.svn-base ./OPJViewer/source/.svn/text-base/icon3.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon3.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/icon3.xpm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,79 @@
+/* XPM */
+static char *icon3_xpm[] = {
+/* columns rows colors chars-per-pixel */
+"32 32 41 1",
+"6 c #EDF2FB",
+"- c #AAC1E8",
+": c #B9CDED",
+"X c #295193",
+", c #C6D6F0",
+"a c #4A7CCE",
+"u c #779DDB",
+"y c #7FA2DD",
+"$ c #3263B4",
+"5 c #EAF0FA",
+". c #2D59A3",
+"o c #6E96D8",
+"* c #356AC1",
+"r c #F7F9FD",
+"> c #BED0EE",
+"3 c #E1E9F7",
+"7 c #F0F5FC",
+"< c #CBD9F1",
+"2 c #DAE5F6",
+"# c #3161B1",
+"  c None",
+"0 c #FDFEFF",
+"= c #9FB9E5",
+"e c #AEC5EA",
+"t c #89A9DF",
+"q c #98B5E4",
+"p c #5584D1",
+"d c #3A70CA",
+"@ c #305FAC",
+"i c #5D89D3",
+"1 c #D2DFF4",
+"% c #3366B9",
+"9 c #FAFCFE",
+"8 c #F5F8FD",
+"s c #4075CC",
+"O c #638ED5",
+"w c #90AFE2",
+"& c #3467BC",
+"+ c #2F5DA9",
+"; c #B3C8EB",
+"4 c #E5EDF9",
+/* pixels */
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"      ......X                   ",
+"      .oooooO+                  ",
+"      .ooooooo.                 ",
+"      .+@@@##$%%&&&&&****.      ",
+"      .=-;:>,<12345678900.      ",
+"      .q=-;:>,<1234567890.      ",
+"      .wq=-e:>,<12345678r.      ",
+"      .twq=-e:>,<12345678.      ",
+"      .ytwq=-e:>,<1234567.      ",
+"      .uytwq=-e:>,<123456.      ",
+"      .ouytwq=-e:>,<12345.      ",
+"      .Oouytwq=-e;>,<1234.      ",
+"      .iOouytwq=-e;>,<123.      ",
+"      .piOouytwq=-e;>,<12.      ",
+"      .apiOouytwq=-e;>,<1.      ",
+"      .sapiOouytwq=-e;>,<.      ",
+"      .dsapiOouytwq=-e;>,.      ",
+"      ...................#      ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                "
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon4.xpm.svn-base ./OPJViewer/source/.svn/text-base/icon4.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon4.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/icon4.xpm.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,43 @@
+/* XPM */
+static char *icon4_xpm[] = {
+/* columns rows colors chars-per-pixel */
+"32 32 5 1",
+". c Black",
+"o c #8399B4",
+"X c #8DA0B9",
+"  c None",
+"O c #800000",
+/* pixels */
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"      .......                   ",
+"      .XXXXXo.                  ",
+"      .XXXXXXX.                 ",
+"      ....................      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      .OOOOOOOOOOOOOOOOOO.      ",
+"      ....................      ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                "
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon5.xpm.svn-base ./OPJViewer/source/.svn/text-base/icon5.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/icon5.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/icon5.xpm.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,79 @@
+/* XPM */
+static char *icon5_xpm[] = {
+/* columns rows colors chars-per-pixel */
+"32 32 41 1",
+"0 c #AAC1E8",
+"q c #B9CDED",
+"X c #295193",
+"e c #C6D6F0",
+"a c #4A7CCE",
+"& c #779DDB",
+"* c #7FA2DD",
+"2 c #EAF0FA",
+"@ c #2D59A3",
+"o c #6E96D8",
+"y c #356AC1",
+"d c #214279",
+"w c #BED0EE",
+"= c #85A7DF",
+"< c #E1E9F7",
+"3 c #F0F5FC",
+"s c #CBD9F1",
+", c #DAE5F6",
+"7 c #3161B1",
+"  c None",
+". c #274D8B",
+"6 c #FDFEFF",
+"i c #E7EEF9",
+"9 c #9FB9E5",
+"- c #89A9DF",
+"8 c #98B5E4",
+"$ c #5584D1",
+"+ c #3569BF",
+"% c #305FAC",
+"O c #5D89D3",
+"> c #D2DFF4",
+"p c #3366B9",
+"5 c #FAFCFE",
+"4 c #F5F8FD",
+"t c #4075CC",
+"u c #638ED5",
+"r c #CEDCF2",
+"; c #90AFE2",
+"# c #2F5DA9",
+": c #B3C8EB",
+"1 c #E5EDF9",
+/* pixels */
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"     ......X                    ",
+"     XoooooO.                   ",
+"     Xoooooo+.                  ",
+"     Xooooooo@XXXXXXXXXX#       ",
+"     Xoooooooooooooooooo#       ",
+"     Xoooooooooooooooooo#       ",
+"     Xoo$###################    ",
+"     Xoo%O&*=-;:>,<123445667    ",
+"     XooX890:qwer>,<123445q#    ",
+"     Xoty;890:qwer>,<12344#     ",
+"     Xo%u-;890:qwer>,<i234#     ",
+"     XoX&*-;890:qwer>,<i2r#     ",
+"     Xtpo&*-;890:qwer>,<i#      ",
+"     X%auo&*-;890:qwer>,<#      ",
+"     XX$Ouo&*-;890:qwer>s#      ",
+"     d%a$Ouo&*-;890:qwer#       ",
+"     d+ta$Ouo&*-;890:qwe#       ",
+"     d..................#       ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                ",
+"                                "
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagj2k.cpp.svn-base ./OPJViewer/source/.svn/text-base/imagj2k.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagj2k.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagj2k.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,984 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagj2k.cpp
+// Purpose:     wxImage JPEG 2000 codestream handler
+// Author:      Giuseppe Baruffa - based on imagjpeg.cpp, Vaclav Slavik
+// RCS-ID:      $Id: imagj2k.cpp,v 0.00 2007/02/08 23:59:00 MW Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_IMAGE && wxUSE_LIBOPENJPEG
+
+#include "imagj2k.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+    #include "wx/app.h"
+    #include "wx/intl.h"
+    #include "wx/bitmap.h"
+    #include "wx/module.h"
+#endif
+
+#include "wx/filefn.h"
+#include "wx/wfstream.h"
+
+// ----------------------------------------------------------------------------
+// types
+// ----------------------------------------------------------------------------
+
+
+//-----------------------------------------------------------------------------
+// wxJ2KHandler
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxJ2KHandler,wxImageHandler)
+
+#if wxUSE_STREAMS
+
+//------------- JPEG 2000 Data Source Manager
+
+#define J2K_CFMT 0
+#define JP2_CFMT 1
+#define JPT_CFMT 2
+#define MJ2_CFMT 3
+#define PXM_DFMT 0
+#define PGX_DFMT 1
+#define BMP_DFMT 2
+#define YUV_DFMT 3
+
+#define MAX_MESSAGE_LEN 200
+
+/* sample error callback expecting a FILE* client object */
+void j2k_error_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[ERROR] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample warning callback expecting a FILE* client object */
+void j2k_warning_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[WARNING] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample debug callback expecting no client object */
+void j2k_info_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[INFO] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+// load the j2k codestream
+bool wxJ2KHandler::LoadFile(wxImage *image, wxInputStream& stream, bool verbose, int index)
+{
+	opj_dparameters_t parameters;	/* decompression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *opjimage = NULL;
+	unsigned char *src = NULL;
+    unsigned char *ptr;
+	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+
+	// destroy the image
+    image->Destroy();
+
+	/* handle to a decompressor */
+	opj_dinfo_t* dinfo = NULL;	
+	opj_cio_t *cio = NULL;
+
+
+	/* configure the event callbacks (not required) */
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = j2k_error_callback;
+	event_mgr.warning_handler = j2k_warning_callback;
+	event_mgr.info_handler = j2k_info_callback;
+
+	/* set decoding parameters to default values */
+	opj_set_default_decoder_parameters(&parameters);
+
+	/* prepare parameters */
+	strncpy(parameters.infile, "", sizeof(parameters.infile)-1);
+	strncpy(parameters.outfile, "", sizeof(parameters.outfile)-1);
+	parameters.decod_format = J2K_CFMT;
+	parameters.cod_format = BMP_DFMT;
+	if (m_reducefactor)
+		parameters.cp_reduce = m_reducefactor;
+	if (m_qualitylayers)
+		parameters.cp_layer = m_qualitylayers;
+
+	/* JPWL only */
+#ifdef USE_JPWL
+	parameters.jpwl_exp_comps = m_expcomps;
+	parameters.jpwl_max_tiles = m_maxtiles;
+	parameters.jpwl_correct = m_enablejpwl;
+#endif /* USE_JPWL */
+
+	/* get a decoder handle */
+	dinfo = opj_create_decompress(CODEC_J2K);
+
+	/* find length of the stream */
+	stream.SeekI(0, wxFromEnd);
+	file_length = (int) stream.TellI();
+
+	/* get data */
+	stream.SeekI(0, wxFromStart);
+    src = (unsigned char *) malloc(file_length);
+	stream.Read(src, file_length);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+	/* setup the decoder decoding parameters using user parameters */
+	opj_setup_decoder(dinfo, &parameters);
+
+	/* open a byte stream */
+	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+	/* decode the stream and fill the image structure */
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+	if (!opjimage) {
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+		wxLogError(wxT("J2K: failed to decode image!"));
+#ifndef __WXGTK__ 
+		wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+		opj_destroy_decompress(dinfo);
+		opj_cio_close(cio);
+		opj_image_destroy(opjimage);
+		free(src);
+		return false;
+	}
+
+	/* close the byte stream */
+	opj_cio_close(cio);
+
+	/* common rendering method */
+#include "imagjpeg2000.cpp"
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+    wxLogMessage(wxT("J2K: image loaded."));
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+	/* close openjpeg structs */
+	opj_destroy_decompress(dinfo);
+	opj_image_destroy(opjimage);
+	free(src);
+
+	if (!image->Ok())
+		return false;
+	else
+		return true;
+
+}
+
+#define CINEMA_24_CS 1302083	/* Codestream length for 24fps */
+#define CINEMA_48_CS 651041		/* Codestream length for 48fps */
+#define COMP_24_CS 1041666		/* Maximum size per color component for 2K & 4K @ 24fps */
+#define COMP_48_CS 520833		/* Maximum size per color component for 2K @ 48fps */
+
+// save the j2k codestream
+bool wxJ2KHandler::SaveFile( wxImage *wimage, wxOutputStream& stream, bool verbose )
+{
+	opj_cparameters_t parameters;	/* compression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *oimage = NULL;
+	opj_image_cmptparm_t *cmptparm;	
+	opj_cio_t *cio = NULL;
+	opj_codestream_info_t cstr_info;
+	int codestream_length;
+	bool bSuccess;
+	int i;
+	char indexfilename[OPJ_PATH_LEN] = "";	/* index file name */
+
+	/*
+	configure the event callbacks (not required)
+	setting of each callback is optionnal
+	*/
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = j2k_error_callback;
+	event_mgr.warning_handler = j2k_warning_callback;
+	event_mgr.info_handler = j2k_info_callback;
+
+	/* set encoding parameters to default values */
+	opj_set_default_encoder_parameters(&parameters);
+
+	/* load parameters */
+	parameters.cp_cinema = OFF;
+
+	/* subsampling */
+	if (sscanf(m_subsampling.ToAscii(), "%d,%d", &(parameters.subsampling_dx), &(parameters.subsampling_dy)) != 2) {
+		wxLogError(wxT("Wrong sub-sampling encoder setting: dx,dy"));
+		return false;
+	}
+
+	/* compression rates */
+	if ((m_rates != wxT("")) && (!m_enablequality)) {
+		const char *s1 = m_rates.ToAscii();
+		wxLogMessage(wxT("rates %s"), s1);
+		while (sscanf(s1, "%f", &(parameters.tcp_rates[parameters.tcp_numlayers])) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s1 && *s1 != ',') {
+				s1++;
+			}
+			if (!*s1)
+				break;
+			s1++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* image quality, dB */
+	if ((m_quality != wxT("")) && (m_enablequality)) {
+		const char *s2 = m_quality.ToAscii();
+		wxLogMessage(wxT("qualities %s"), s2);
+		while (sscanf(s2, "%f", &parameters.tcp_distoratio[parameters.tcp_numlayers]) == 1) {
+			parameters.tcp_numlayers++;
+			while (*s2 && *s2 != ',') {
+				s2++;
+			}
+			if (!*s2)
+				break;
+			s2++;
+		}
+		wxLogMessage(wxT("%d layers"), parameters.tcp_numlayers);
+		parameters.cp_fixed_quality = 1;
+	}
+
+	/* image origin */
+	if (sscanf(m_origin.ToAscii(), "%d,%d", &parameters.image_offset_x0, &parameters.image_offset_y0) != 2) {
+		wxLogError(wxT("bad coordinate of the image origin: x0,y0"));
+		return false;
+	}
+				
+	/* Create comment for codestream */
+	if(m_enablecomm) {
+		parameters.cp_comment = (char *) malloc(strlen(m_comment.ToAscii()) + 1);
+		if(parameters.cp_comment) {
+			strcpy(parameters.cp_comment, m_comment.ToAscii());
+		}
+	} else {
+		parameters.cp_comment = NULL;
+	}
+
+	/* indexing file */
+	if (m_enableidx) {
+		strncpy(indexfilename, m_index.ToAscii(), OPJ_PATH_LEN);
+		wxLogMessage(wxT("index file is %s"), indexfilename);
+	}
+
+	/* if no rate entered, lossless by default */
+	if (parameters.tcp_numlayers == 0) {
+		parameters.tcp_rates[0] = 0;	/* MOD antonin : losslessbug */
+		parameters.tcp_numlayers++;
+		parameters.cp_disto_alloc = 1;
+	}
+
+	/* irreversible transform */
+	parameters.irreversible = (m_irreversible == true) ? 1 : 0;
+
+	/* resolutions */
+	parameters.numresolution = m_resolutions;
+
+	/* codeblocks size */
+	if (m_cbsize != wxT("")) {
+		int cblockw_init = 0, cblockh_init = 0;
+		sscanf(m_cbsize.ToAscii(), "%d,%d", &cblockw_init, &cblockh_init);
+		if (cblockw_init * cblockh_init > 4096 || cblockw_init > 1024 || cblockw_init < 4 || cblockh_init > 1024 || cblockh_init < 4) {
+			wxLogError(wxT("!! Size of code_block error !! Restrictions:\n  width*height<=4096\n  4<=width,height<= 1024"));
+			return false;
+		}
+		parameters.cblockw_init = cblockw_init;
+		parameters.cblockh_init = cblockh_init;
+	}
+
+	/* precincts size */
+	if (m_prsize != wxT("")) {
+		char sep;
+		int res_spec = 0;
+		char *s = (char *) m_prsize.c_str();
+		do {
+			sep = 0;
+			sscanf(s, "[%d,%d]%c", &parameters.prcw_init[res_spec], &parameters.prch_init[res_spec], &sep);
+			parameters.csty |= 0x01;
+			res_spec++;
+			s = strpbrk(s, "]") + 2;
+		} while (sep == ',');
+		parameters.res_spec = res_spec;
+	}
+
+	/* tiles */
+	if (m_tsize != wxT("")) {
+		sscanf(m_tsize.ToAscii(), "%d,%d", &parameters.cp_tdx, &parameters.cp_tdy);
+		parameters.tile_size_on = true;
+	}
+
+	/* tile origin */
+	if (sscanf(m_torigin.ToAscii(), "%d,%d", &parameters.cp_tx0, &parameters.cp_ty0) != 2) {
+		wxLogError(wxT("tile offset setting error: X0,Y0"));
+		return false;
+	}
+
+	/* use SOP */
+	if (m_enablesop)
+		parameters.csty |= 0x02;
+
+	/* use EPH */
+	if (m_enableeph)
+		parameters.csty |= 0x04;
+
+	/* multiple component transform */
+	if (m_multicomp)
+		parameters.tcp_mct = 1;
+	else
+		parameters.tcp_mct = 0;
+
+	/* mode switch */
+	parameters.mode = (m_enablebypass ? 1 : 0) + (m_enablereset ? 2 : 0)
+		+ (m_enablerestart ? 4 : 0) + (m_enablevsc ? 8 : 0)
+		+ (m_enableerterm ? 16 : 0) + (m_enablesegmark ? 32 : 0);
+
+	/* progression order */
+	switch (m_progression) {
+
+		/* LRCP */
+	case 0:
+		parameters.prog_order = LRCP;
+		break;
+
+		/* RLCP */
+	case 1:
+		parameters.prog_order = RLCP;
+		break;
+
+		/* RPCL */
+	case 2:
+		parameters.prog_order = RPCL;
+		break;
+
+		/* PCRL */
+	case 3:
+		parameters.prog_order = PCRL;
+		break;
+
+		/* CPRL */
+	case 4:
+		parameters.prog_order = CPRL;
+		break;
+
+		/* DCI2K24 */
+	case 5:
+		parameters.cp_cinema = CINEMA2K_24;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI2K48 */
+	case 6:
+		parameters.cp_cinema = CINEMA2K_48;
+		parameters.cp_rsiz = CINEMA2K;
+		break;
+
+		/* DCI4K */
+	case 7:
+		parameters.cp_cinema = CINEMA4K_24;
+		parameters.cp_rsiz = CINEMA4K;
+		break;
+
+	default:
+		break;
+	}
+
+	/* check cinema */
+	if (parameters.cp_cinema) {
+
+		/* set up */
+		parameters.tile_size_on = false;
+		parameters.cp_tdx=1;
+		parameters.cp_tdy=1;
+		
+		/*Tile part*/
+		parameters.tp_flag = 'C';
+		parameters.tp_on = 1;
+
+		/*Tile and Image shall be at (0,0)*/
+		parameters.cp_tx0 = 0;
+		parameters.cp_ty0 = 0;
+		parameters.image_offset_x0 = 0;
+		parameters.image_offset_y0 = 0;
+
+		/*Codeblock size= 32*32*/
+		parameters.cblockw_init = 32;	
+		parameters.cblockh_init = 32;
+		parameters.csty |= 0x01;
+
+		/*The progression order shall be CPRL*/
+		parameters.prog_order = CPRL;
+
+		/* No ROI */
+		parameters.roi_compno = -1;
+
+		parameters.subsampling_dx = 1;
+		parameters.subsampling_dy = 1;
+
+		/* 9-7 transform */
+		parameters.irreversible = 1;
+
+	}				
+
+	/* convert wx image into opj image */
+	cmptparm = (opj_image_cmptparm_t*) malloc(3 * sizeof(opj_image_cmptparm_t));
+
+	/* initialize opj image components */	
+	memset(&cmptparm[0], 0, 3 * sizeof(opj_image_cmptparm_t));
+	for(i = 0; i < 3; i++) {		
+		cmptparm[i].prec = 8;
+		cmptparm[i].bpp = 8;
+		cmptparm[i].sgnd = false;
+		cmptparm[i].dx = parameters.subsampling_dx;
+		cmptparm[i].dy = parameters.subsampling_dy;
+		cmptparm[i].w = wimage->GetWidth();
+		cmptparm[i].h = wimage->GetHeight();
+	}
+
+	/* create the image */
+	oimage = opj_image_create(3, &cmptparm[0], CLRSPC_SRGB);
+	if(!oimage) {
+		if (cmptparm)
+			free(cmptparm);
+		return false;
+	}
+
+	/* set image offset and reference grid */
+	oimage->x0 = parameters.image_offset_x0;
+	oimage->y0 = parameters.image_offset_y0;
+	oimage->x1 = parameters.image_offset_x0 + (wimage->GetWidth() - 1) * 1 + 1;
+	oimage->y1 = parameters.image_offset_y0 + (wimage->GetHeight() - 1) * 1 + 1;
+
+	/* load image data */
+	unsigned char *value = wimage->GetData(); 
+	int area = wimage->GetWidth() * wimage->GetHeight();
+	for (i = 0; i < area; i++) {
+			oimage->comps[0].data[i] = *(value++);
+			oimage->comps[1].data[i] = *(value++);
+			oimage->comps[2].data[i] = *(value++);
+	}
+
+	/* check cinema again */
+	if (parameters.cp_cinema) {
+		int i;
+		float temp_rate;
+		opj_poc_t *POC = NULL;
+
+		switch (parameters.cp_cinema) {
+
+		case CINEMA2K_24:
+		case CINEMA2K_48:
+			if (parameters.numresolution > 6) {
+				parameters.numresolution = 6;
+			}
+			if (!((oimage->comps[0].w == 2048) | (oimage->comps[0].h == 1080))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 2K compliant. JPEG Digital Cinema Profile-3 "
+					"(2K profile) compliance requires that at least one of coordinates match 2048 x 1080"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+		break;
+		
+		case CINEMA4K_24:
+			if (parameters.numresolution < 1) {
+					parameters.numresolution = 1;
+			} else if (parameters.numresolution > 7) {
+					parameters.numresolution = 7;
+			}
+			if (!((oimage->comps[0].w == 4096) | (oimage->comps[0].h == 2160))) {
+				wxLogWarning(wxT("Image coordinates %d x %d is not 4K compliant. JPEG Digital Cinema Profile-4" 
+					"(4K profile) compliance requires that at least one of coordinates match 4096 x 2160"),
+					oimage->comps[0].w, oimage->comps[0].h);
+				parameters.cp_rsiz = STD_RSIZ;
+			}
+			parameters.POC[0].tile  = 1; 
+			parameters.POC[0].resno0  = 0; 
+			parameters.POC[0].compno0 = 0;
+			parameters.POC[0].layno1  = 1;
+			parameters.POC[0].resno1  = parameters.numresolution - 1;
+			parameters.POC[0].compno1 = 3;
+			parameters.POC[0].prg1 = CPRL;
+			parameters.POC[1].tile  = 1;
+			parameters.POC[1].resno0  = parameters.numresolution - 1; 
+			parameters.POC[1].compno0 = 0;
+			parameters.POC[1].layno1  = 1;
+			parameters.POC[1].resno1  = parameters.numresolution;
+			parameters.POC[1].compno1 = 3;
+			parameters.POC[1].prg1 = CPRL;
+			parameters.numpocs = 2;
+			break;
+		}
+
+		switch (parameters.cp_cinema) {
+		case CINEMA2K_24:
+		case CINEMA4K_24:
+			for (i = 0 ; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_24_CS ) {
+						parameters.tcp_rates[i]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_24_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					} else {
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_24_CS;
+			break;
+			
+		case CINEMA2K_48:
+			for (i = 0; i < parameters.tcp_numlayers; i++) {
+				temp_rate = 0 ;
+				if (parameters.tcp_rates[i] == 0) {
+					parameters.tcp_rates[0] = ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+					(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+				}else{
+					temp_rate =((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(parameters.tcp_rates[i] * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					if (temp_rate > CINEMA_48_CS ){
+						parameters.tcp_rates[0]= ((float) (oimage->numcomps * oimage->comps[0].w * oimage->comps[0].h * oimage->comps[0].prec)) / 
+						(CINEMA_48_CS * 8 * oimage->comps[0].dx * oimage->comps[0].dy);
+					}else{
+						/* do nothing */
+					}
+				}
+			}
+			parameters.max_comp_size = COMP_48_CS;
+			break;
+		}
+
+		parameters.cp_disto_alloc = 1;
+	}
+	
+	/* get a J2K compressor handle */
+	opj_cinfo_t* cinfo = opj_create_compress(CODEC_J2K);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)cinfo, &event_mgr, stderr);
+
+	/* setup the encoder parameters using the current image and user parameters */
+	opj_setup_encoder(cinfo, &parameters, oimage);
+
+	/* open a byte stream for writing */
+	/* allocate memory for all tiles */
+	cio = opj_cio_open((opj_common_ptr)cinfo, NULL, 0);
+
+	/* encode the image */
+	bSuccess = opj_encode_with_info(cinfo, cio, oimage, &cstr_info);
+	if (!bSuccess) {
+
+		opj_cio_close(cio);
+		opj_destroy_compress(cinfo);
+		opj_image_destroy(oimage);
+		if (cmptparm)
+			free(cmptparm);
+		if(parameters.cp_comment)
+			free(parameters.cp_comment);
+		if(parameters.cp_matrice)
+			free(parameters.cp_matrice);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+
+		wxLogError(wxT("failed to encode image"));
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+		return false;
+	}
+	codestream_length = cio_tell(cio);
+	wxLogMessage(wxT("Codestream: %d bytes"), codestream_length);
+
+	/* write the buffer to stream */
+	stream.Write(cio->buffer, codestream_length);
+
+	/* close and free the byte stream */
+	opj_cio_close(cio);
+
+	/* Write the index to disk */
+	if (*indexfilename) {
+		bSuccess = write_index_file(&cstr_info, indexfilename);
+		if (!bSuccess) {
+			wxLogError(wxT("Failed to output index file"));
+		}
+	}
+
+	/* free remaining compression structures */
+	opj_destroy_compress(cinfo);
+
+	/* free image data */
+	opj_image_destroy(oimage);
+
+	if (cmptparm)
+		free(cmptparm);
+	if(parameters.cp_comment)
+		free(parameters.cp_comment);
+	if(parameters.cp_matrice)
+		free(parameters.cp_matrice);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+
+    wxLogMessage(wxT("J2K: Image encoded!"));
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+    return true;
+}
+
+#ifdef __VISUALC__
+    #pragma warning(default:4611)
+#endif /* VC++ */
+
+// recognize the 0xFF4F JPEG 2000 SOC marker
+bool wxJ2KHandler::DoCanRead( wxInputStream& stream )
+{
+    unsigned char hdr[2];
+
+    if ( !stream.Read(hdr, WXSIZEOF(hdr)) )
+        return false;
+
+    return hdr[0] == 0xFF && hdr[1] == 0x4F;
+}
+
+// write the index file
+bool wxJ2KHandler::write_index_file(opj_codestream_info_t *cstr_info, char *index) {
+	int tileno, compno, layno, resno, precno, pack_nb, x, y;
+	FILE *stream = NULL;
+	double total_disto = 0;
+	int tilepartno;
+
+#ifdef USE_JPWL
+	if (!strcmp(index, JPWL_PRIVATEINDEX_NAME))
+		return true;
+#endif // USE_JPWL
+
+	if (!cstr_info)		
+		return 1;
+
+	stream = fopen(index, "w");
+	if (!stream) {
+		fprintf(stderr, "failed to open index file [%s] for writing\n", index);
+		return false;
+	}
+	
+	fprintf(stream, "%d %d\n", cstr_info->image_w, cstr_info->image_h);
+	fprintf(stream, "%d\n", cstr_info->prog);
+	fprintf(stream, "%d %d\n", cstr_info->tile_x, cstr_info->tile_y);
+	fprintf(stream, "%d %d\n", cstr_info->tw, cstr_info->th);
+	fprintf(stream, "%d\n", cstr_info->numcomps);
+	fprintf(stream, "%d\n", cstr_info->numlayers);
+	fprintf(stream, "%d\n", cstr_info->numdecompos);
+
+	for (resno = cstr_info->numdecompos[0]; resno >= 0; resno--) {
+		fprintf(stream, "[%d,%d] ", 
+			(1 << cstr_info->tile[0].pdx[resno]), (1 << cstr_info->tile[0].pdx[resno]));	/* based on tile 0 and component 0 */
+	}
+
+	fprintf(stream, "\n");
+	fprintf(stream, "%d\n", cstr_info->main_head_start);
+	fprintf(stream, "%d\n", cstr_info->main_head_end);
+	fprintf(stream, "%d\n", cstr_info->codestream_size);
+	
+	fprintf(stream, "\nINFO ON TILES\n");
+	fprintf(stream, "tileno start_pos  end_hd  end_tile   nbparts         disto     nbpix   disto/nbpix\n");
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		fprintf(stream, "%4d %9d %9d %9d %9d %9e %9d %9e\n",
+			cstr_info->tile[tileno].tileno,
+			cstr_info->tile[tileno].start_pos,
+			cstr_info->tile[tileno].end_header,
+			cstr_info->tile[tileno].end_pos,
+			cstr_info->tile[tileno].num_tps,
+			cstr_info->tile[tileno].distotile, cstr_info->tile[tileno].numpix,
+			cstr_info->tile[tileno].distotile / cstr_info->tile[tileno].numpix);
+	}
+		
+	for (tileno = 0; tileno < cstr_info->tw * cstr_info->th; tileno++) {
+		int start_pos, end_ph_pos, end_pos;
+		double disto = 0;
+		int max_numdecompos = 0;
+		pack_nb = 0;
+
+		for (compno = 0; compno < cstr_info->numcomps; compno++) {
+			if (max_numdecompos < cstr_info->numdecompos[compno])
+				max_numdecompos = cstr_info->numdecompos[compno];
+		}	
+
+		fprintf(stream, "\nTILE %d DETAILS\n", tileno);	
+		fprintf(stream, "part_nb tileno  start_pack num_packs  start_pos end_tph_pos   end_pos\n");
+		for (tilepartno = 0; tilepartno < cstr_info->tile[tileno].num_tps; tilepartno++)
+			fprintf(stream, "%4d %9d   %9d %9d  %9d %11d %9d\n",
+				tilepartno, tileno,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pack,
+				cstr_info->tile[tileno].tp[tilepartno].tp_numpacks,
+				cstr_info->tile[tileno].tp[tilepartno].tp_start_pos,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_header,
+				cstr_info->tile[tileno].tp[tilepartno].tp_end_pos
+				);
+		if (cstr_info->prog == LRCP) {	/* LRCP */
+			fprintf(stream, "LRCP\npack_nb tileno layno resno compno precno start_pos end_ph_pos end_pos disto\n");
+
+			for (layno = 0; layno < cstr_info->numlayers; layno++) {
+				for (resno = 0; resno < max_numdecompos + 1; resno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max;
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %7d %5d %6d  %6d    %6d     %6d %7d %8e\n",
+								pack_nb, tileno, layno, resno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* LRCP */
+		else if (cstr_info->prog == RLCP) {	/* RLCP */
+
+			fprintf(stream, "RLCP\npack_nb tileno resno layno compno precno start_pos end_ph_pos end_pos disto\n");
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				for (layno = 0; layno < cstr_info->numlayers; layno++) {
+					for (compno = 0; compno < cstr_info->numcomps; compno++) {
+						int prec_max; 
+						if (resno > cstr_info->numdecompos[compno])
+							break;
+						prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+						for (precno = 0; precno < prec_max; precno++) {
+							start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+							end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+							end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+							disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+							fprintf(stream, "%4d %6d %5d %7d %6d %6d %9d   %9d %7d %8e\n",
+								pack_nb, tileno, resno, layno, compno, precno, start_pos, end_ph_pos, end_pos, disto);
+							total_disto += disto;
+							pack_nb++;
+						}
+					}
+				}
+			}
+		} /* RLCP */
+		else if (cstr_info->prog == RPCL) {	/* RPCL */
+
+			fprintf(stream, "RPCL\npack_nb tileno resno precno compno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (resno = 0; resno < max_numdecompos + 1; resno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor((float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+				for (compno = 0; compno < cstr_info->numcomps; compno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					if (resno > cstr_info->numdecompos[compno])
+							break;
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %5d %6d %6d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, resno, precno, compno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* compno */
+			} /* resno */
+		} /* RPCL */
+		else if (cstr_info->prog == PCRL) {	/* PCRL */
+			/* I suppose components have same XRsiz, YRsiz */
+			int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+			int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+			int x1 = x0 + cstr_info->tile_x;
+			int y1 = y0 + cstr_info->tile_y;
+
+			fprintf(stream, "PCRL\npack_nb tileno precno compno resno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {							
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {									
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, precno, compno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							} 
+						}  /* y = y0..y1 */
+					} /* precno */
+				} /* resno */
+			} /* compno */
+		} /* PCRL */
+		else {	/* CPRL */
+
+			fprintf(stream, "CPRL\npack_nb tileno compno precno resno layno start_pos end_ph_pos end_pos disto\n"); 
+
+			for (compno = 0; compno < cstr_info->numcomps; compno++) {
+				/* I suppose components have same XRsiz, YRsiz */
+				int x0 = cstr_info->tile_Ox + tileno - (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tw * cstr_info->tile_x;
+				int y0 = cstr_info->tile_Ox + (int)floor( (float)tileno/(float)cstr_info->tw ) * cstr_info->tile_y;
+				int x1 = x0 + cstr_info->tile_x;
+				int y1 = y0 + cstr_info->tile_y;
+				
+				for (resno = 0; resno < cstr_info->numdecompos[compno] + 1; resno++) {
+					int prec_max = cstr_info->tile[tileno].pw[resno] * cstr_info->tile[tileno].ph[resno];
+					for (precno = 0; precno < prec_max; precno++) {
+						int pcnx = cstr_info->tile[tileno].pw[resno];
+						int pcx = (int) pow( 2, cstr_info->tile[tileno].pdx[resno] + cstr_info->numdecompos[compno] - resno );
+						int pcy = (int) pow( 2, cstr_info->tile[tileno].pdy[resno] + cstr_info->numdecompos[compno] - resno );
+						int precno_x = precno - (int) floor( (float)precno/(float)pcnx ) * pcnx;
+						int precno_y = (int) floor( (float)precno/(float)pcnx );
+						for(y = y0; y < y1; y++) {
+							if (precno_y*pcy == y ) {
+								for (x = x0; x < x1; x++) {
+									if (precno_x*pcx == x ) {
+										for (layno = 0; layno < cstr_info->numlayers; layno++) {
+											start_pos = cstr_info->tile[tileno].packet[pack_nb].start_pos;
+											end_ph_pos = cstr_info->tile[tileno].packet[pack_nb].end_ph_pos;
+											end_pos = cstr_info->tile[tileno].packet[pack_nb].end_pos;
+											disto = cstr_info->tile[tileno].packet[pack_nb].disto;
+											fprintf(stream, "%4d %6d %6d %6d %5d %7d %9d   %9d %7d %8e\n",
+												pack_nb, tileno, compno, precno, resno, layno, start_pos, end_ph_pos, end_pos, disto); 
+											total_disto += disto;
+											pack_nb++; 
+										}
+									}
+								}/* x = x0..x1 */
+							}
+						} /* y = y0..y1 */
+					} /* precno */
+				} /* resno */
+			} /* compno */
+		} /* CPRL */   
+	} /* tileno */
+	
+	fprintf(stream, "%8e\n", cstr_info->D_max); /* SE max */
+	fprintf(stream, "%.8e\n", total_disto);	/* SE totale */
+	fprintf(stream, "\nMARKER LIST\n");
+	fprintf(stream, "%d\n", cstr_info->marknum);
+	fprintf(stream, "type\tstart_pos    length\n");
+	for (x = 0; x < cstr_info->marknum; x++)
+		fprintf(stream, "%X\t%9d %9d\n", cstr_info->marker[x].type, cstr_info->marker[x].pos, cstr_info->marker[x].len);
+	fclose(stream);
+
+	fprintf(stderr,"Generated index file %s\n", index);
+
+	return true;
+}
+
+#endif   // wxUSE_STREAMS
+
+#endif   // wxUSE_LIBOPENJPEG
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagj2k.h.svn-base ./OPJViewer/source/.svn/text-base/imagj2k.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagj2k.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagj2k.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,182 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagj2k.h
+// Purpose:     wxImage JPEG 2000 raw codestream handler
+// Author:      G. Baruffa - based on imagjpeg.h, Vaclav Slavik
+// RCS-ID:      $Id: imagj2k.h,v 0.0 2007/02/08 23:45:00 VZ Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_IMAGJ2K_H_
+#define _WX_IMAGJ2K_H_
+
+#include "wx/defs.h"
+
+//-----------------------------------------------------------------------------
+// wxJ2KHandler
+//-----------------------------------------------------------------------------
+
+#if wxUSE_LIBOPENJPEG
+
+#include "wx/image.h"
+#include "libopenjpeg/openjpeg.h"
+
+#define wxBITMAP_TYPE_J2K	47
+
+#define wxIMAGE_OPTION_REDUCEFACTOR  wxString(_T("reducefactor"))
+#define wxIMAGE_OPTION_QUALITYLAYERS  wxString(_T("qualitylayers"))
+#define wxIMAGE_OPTION_MAXCOMPS  wxString(_T("maxcomps"))
+#ifdef USE_JPWL
+#define wxIMAGE_OPTION_ENABLEJPWL  wxString(_T("enablejpwl"))
+#define wxIMAGE_OPTION_EXPCOMPS  wxString(_T("expcomps"))
+#define wxIMAGE_OPTION_MAXTILES  wxString(_T("maxtiles"))
+#endif // USE_JPWL
+
+class WXDLLEXPORT wxJ2KHandler: public wxImageHandler
+{
+public:
+    inline wxJ2KHandler()
+    {
+        m_name = wxT("JPEG 2000 codestream file");
+        m_extension = wxT("j2k");
+        m_type = wxBITMAP_TYPE_J2K;
+        m_mime = wxT("image/j2k");
+
+		/* decoding */
+		m_reducefactor = 0;
+		m_qualitylayers = 0;
+		m_components = 0;
+#ifdef USE_JPWL
+		m_enablejpwl = true;
+		m_expcomps = JPWL_EXPECTED_COMPONENTS;
+		m_maxtiles = JPWL_MAXIMUM_TILES;
+#endif // USE_JPWL
+
+		/* encoding */
+		m_subsampling = wxT("1,1");
+		m_origin = wxT("0,0");
+		m_rates = wxT("20,10,5");
+		m_quality = wxT("30,35,40");
+		m_enablequality = false;
+		m_multicomp = false;
+		m_irreversible = false;
+		m_resolutions = 6;
+		m_progression = 0;
+		m_cbsize = wxT("32,32");
+		m_prsize = wxT("[128,128],[128,128]");
+		m_tsize = wxT("");
+		m_torigin = wxT("0,0");
+		/*m_progression
+		m_resilience*/
+		m_enablesop = false;
+		m_enableeph = false;
+		m_enablereset = false;
+		m_enablesegmark = false;
+		m_enablevsc = false;
+		m_enablerestart = false;
+		m_enableerterm = false;
+		m_enablebypass = false;
+		/*m_roicompo
+		m_roiup
+		m_indexfname*/
+		m_enableidx = false;
+		m_index = wxT("index.txt");
+		m_enablecomm = true;
+
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+
+    }
+
+	// decoding engine parameters
+	int m_reducefactor, m_qualitylayers, m_components;
+#ifdef USE_JPWL
+	bool m_enablejpwl;
+	int m_expcomps, m_maxtiles;
+#endif // USE_JPWL
+
+	// encoding engine parameters
+	wxString m_subsampling;
+	wxString m_origin;
+	wxString m_rates;
+	wxString m_quality;
+	bool m_enablequality;
+	bool m_multicomp;
+	bool m_irreversible;
+	int m_resolutions;
+	int m_progression;
+	wxString m_cbsize;
+	wxString m_prsize;
+	wxString m_tsize;
+	wxString m_torigin;
+	/*m_progression
+	m_resilience*/
+	bool m_enablesop;
+	bool m_enableeph;
+	bool m_enablebypass;
+	bool m_enableerterm;
+	bool m_enablerestart;
+	bool m_enablereset;
+	bool m_enablesegmark;
+	bool m_enablevsc;
+	/*m_roicompo
+	m_roiup
+	m_indexfname*/
+	bool m_enableidx;
+	wxString m_index;
+	bool m_enablecomm;
+	wxString m_comment;
+
+	bool write_index_file(opj_codestream_info_t *cstr_info, char *index);
+
+#if wxUSE_STREAMS
+    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
+    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
+protected:
+    virtual bool DoCanRead( wxInputStream& stream );
+#endif
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxJ2KHandler)
+};
+
+#endif // wxUSE_LIBOPENJPEG
+
+#endif // _WX_IMAGJ2K_H_
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjp2.cpp.svn-base ./OPJViewer/source/.svn/text-base/imagjp2.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjp2.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagjp2.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,279 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagjp2.cpp
+// Purpose:     wxImage JPEG 2000 file format handler
+// Author:      Giuseppe Baruffa - based on imagjpeg.cpp, Vaclav Slavik
+// RCS-ID:      $Id: imagjp2.cpp,v 0.00 2007/02/08 23:59:00 MW Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_IMAGE && wxUSE_LIBOPENJPEG
+
+#include "imagjp2.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+    #include "wx/app.h"
+    #include "wx/intl.h"
+    #include "wx/bitmap.h"
+    #include "wx/module.h"
+#endif
+
+
+#include "libopenjpeg/openjpeg.h"
+
+
+#include "wx/filefn.h"
+#include "wx/wfstream.h"
+
+// ----------------------------------------------------------------------------
+// types
+// ----------------------------------------------------------------------------
+
+
+//-----------------------------------------------------------------------------
+// wxJP2Handler
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxJP2Handler,wxImageHandler)
+
+#if wxUSE_STREAMS
+
+//------------- JPEG 2000 Data Source Manager
+
+#define J2K_CFMT 0
+#define JP2_CFMT 1
+#define JPT_CFMT 2
+#define MJ2_CFMT 3
+#define PXM_DFMT 0
+#define PGX_DFMT 1
+#define BMP_DFMT 2
+#define YUV_DFMT 3
+
+#define MAX_MESSAGE_LEN 200
+
+/* sample error callback expecting a FILE* client object */
+void jp2_error_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[ERROR] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample warning callback expecting a FILE* client object */
+void jp2_warning_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[WARNING] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample debug callback expecting no client object */
+void jp2_info_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[INFO] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+// load the jp2 file format
+bool wxJP2Handler::LoadFile(wxImage *image, wxInputStream& stream, bool verbose, int index)
+{
+	opj_dparameters_t parameters;	/* decompression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *opjimage = NULL;
+	unsigned char *src = NULL;
+    unsigned char *ptr;
+	int file_length;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+
+	// destroy the image
+    image->Destroy();
+
+	/* handle to a decompressor */
+	opj_dinfo_t* dinfo = NULL;	
+	opj_cio_t *cio = NULL;
+
+	/* configure the event callbacks (not required) */
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = jp2_error_callback;
+	event_mgr.warning_handler = jp2_warning_callback;
+	event_mgr.info_handler = jp2_info_callback;
+
+	/* set decoding parameters to default values */
+	opj_set_default_decoder_parameters(&parameters);
+
+	/* prepare parameters */
+	strncpy(parameters.infile, "", sizeof(parameters.infile)-1);
+	strncpy(parameters.outfile, "", sizeof(parameters.outfile)-1);
+	parameters.decod_format = JP2_CFMT;
+	parameters.cod_format = BMP_DFMT;
+	if (m_reducefactor)
+		parameters.cp_reduce = m_reducefactor;
+	if (m_qualitylayers)
+		parameters.cp_layer = m_qualitylayers;
+	/*if (n_components)
+		parameters. = n_components;*/
+
+	/* JPWL only */
+#ifdef USE_JPWL
+	parameters.jpwl_exp_comps = m_expcomps;
+	parameters.jpwl_max_tiles = m_maxtiles;
+	parameters.jpwl_correct = m_enablejpwl;
+#endif /* USE_JPWL */
+
+	/* get a decoder handle */
+	dinfo = opj_create_decompress(CODEC_JP2);
+
+	/* find length of the stream */
+	stream.SeekI(0, wxFromEnd);
+	file_length = (int) stream.TellI();
+
+	/* get data */
+	stream.SeekI(0, wxFromStart);
+    src = (unsigned char *) malloc(file_length);
+	stream.Read(src, file_length);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+	/* setup the decoder decoding parameters using user parameters */
+	opj_setup_decoder(dinfo, &parameters);
+
+	/* open a byte stream */
+	cio = opj_cio_open((opj_common_ptr)dinfo, src, file_length);
+
+	/* decode the stream and fill the image structure */
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+	if (!opjimage) {
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+		wxLogError(wxT("JP2: failed to decode image!"));
+#ifndef __WXGTK__ 
+		wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+		opj_destroy_decompress(dinfo);
+		opj_cio_close(cio);
+		free(src);
+		return false;
+	}
+
+	/* close the byte stream */
+	opj_cio_close(cio);
+
+	/* common rendering method */
+#include "imagjpeg2000.cpp"
+
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+    wxLogMessage(wxT("JP2: image loaded."));
+#ifndef __WXGTK__ 
+		wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+	/* close openjpeg structs */
+	opj_destroy_decompress(dinfo);
+	opj_image_destroy(opjimage);
+	free(src);
+
+	if (!image->Ok())
+		return false;
+	else
+		return true;
+
+}
+
+// save the jp2 file format
+bool wxJP2Handler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )
+{
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+    wxLogError(wxT("JP2: Couldn't save image -> not implemented."));
+#ifndef __WXGTK__ 
+		wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+
+    return false;
+}
+
+#ifdef __VISUALC__
+    #pragma warning(default:4611)
+#endif /* VC++ */
+
+// recognize the JPEG 2000 starting box
+bool wxJP2Handler::DoCanRead( wxInputStream& stream )
+{
+    unsigned char hdr[23];
+
+    if ( !stream.Read(hdr, WXSIZEOF(hdr)) )
+        return false;
+
+    return (hdr[0] == 0x00 &&
+			hdr[1] == 0x00 &&
+			hdr[2] == 0x00 &&
+			hdr[3] == 0x0C &&
+			hdr[4] == 0x6A &&
+			hdr[5] == 0x50 &&
+			hdr[6] == 0x20 &&
+			hdr[7] == 0x20 &&
+			hdr[20] == 0x6A &&
+			hdr[21] == 0x70 &&
+			hdr[22] == 0x32);
+}
+
+#endif   // wxUSE_STREAMS
+
+#endif   // wxUSE_LIBOPENJPEG
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjp2.h.svn-base ./OPJViewer/source/.svn/text-base/imagjp2.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjp2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagjp2.h.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagjp2.h
+// Purpose:     wxImage JPEG 2000 file format handler
+// Author:      G. Baruffa - based on imagjpeg.h, Vaclav Slavik
+// RCS-ID:      $Id: imagjp2.h,v 0.0 2007/02/08 23:45:00 VZ Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_IMAGJP2_H_
+#define _WX_IMAGJP2_H_
+
+#include "wx/defs.h"
+
+//-----------------------------------------------------------------------------
+// wxJP2Handler
+//-----------------------------------------------------------------------------
+
+#if wxUSE_LIBOPENJPEG
+
+#include "wx/image.h"
+#include "libopenjpeg/openjpeg.h"
+
+#define wxBITMAP_TYPE_JP2	48
+
+class WXDLLEXPORT wxJP2Handler: public wxImageHandler
+{
+public:
+    inline wxJP2Handler()
+    {
+        m_name = wxT("JPEG 2000 file format");
+        m_extension = wxT("jp2");
+        m_type = wxBITMAP_TYPE_JP2;
+        m_mime = wxT("image/jp2");
+
+		m_reducefactor = 0;
+		m_qualitylayers = 0;
+		m_components = 0;
+#ifdef USE_JPWL
+		m_enablejpwl = true;
+		m_expcomps = JPWL_EXPECTED_COMPONENTS;
+		m_maxtiles = JPWL_MAXIMUM_TILES;
+#endif // USE_JPWL
+    }
+
+		// decoding engine parameters
+		int m_reducefactor, m_qualitylayers, m_components;
+#ifdef USE_JPWL
+		bool m_enablejpwl;
+		int m_expcomps, m_maxtiles;
+#endif // USE_JPWL
+
+#if wxUSE_STREAMS
+    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
+    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
+protected:
+    virtual bool DoCanRead( wxInputStream& stream );
+#endif
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxJP2Handler)
+};
+
+#endif // wxUSE_LIBOPENJPEG
+
+#endif // _WX_IMAGJP2_H_
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjpeg2000.cpp.svn-base ./OPJViewer/source/.svn/text-base/imagjpeg2000.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagjpeg2000.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagjpeg2000.cpp.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,186 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagjpeg2000.cpp
+// Purpose:     wxImage JPEG 2000 imagage rendering common functions
+// Author:      Giuseppe Baruffa
+// RCS-ID:      $Id: imagjpeg2000.cpp,v 0.00 2007/04/27 22:11:00 MW Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+/*
+
+- At this point, we have the structure "opjimage" that is filled with decompressed
+  data, as processed by the OpenJPEG decompression engine
+
+- We need to fill the class "image" with the proper pixel sample values
+
+*/
+{
+	int shiftbpp;
+	int c, tempcomps;
+
+	// check components number
+	if (m_components > opjimage->numcomps)
+		m_components = opjimage->numcomps;
+
+	// check image depth (only on the first one, for now)
+	if (m_components)
+		shiftbpp = opjimage->comps[m_components - 1].prec - 8;
+	else
+		shiftbpp = opjimage->comps[0].prec - 8;
+
+	// prepare image size
+	if (m_components)
+		image->Create(opjimage->comps[m_components - 1].w, opjimage->comps[m_components - 1].h, true);
+	else
+		image->Create(opjimage->comps[0].w, opjimage->comps[0].h, true);
+
+	// access image raw data
+    image->SetMask(false);
+    ptr = image->GetData();
+
+	// workaround for components different from 1 or 3
+	if ((opjimage->numcomps != 1) && (opjimage->numcomps != 3)) {
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+		wxLogMessage(wxT("JPEG2000: weird number of components"));
+#ifndef __WXGTK__ 
+		wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+		tempcomps = 1;
+	} else
+		tempcomps = opjimage->numcomps;
+
+	// workaround for subsampled components
+	for (c = 1; c < tempcomps; c++) {
+		if ((opjimage->comps[c].w != opjimage->comps[c - 1].w) || (opjimage->comps[c].h != opjimage->comps[c - 1].h)) {
+			tempcomps = 1;
+			break;
+		}
+	}
+
+	// workaround for different precision components
+	for (c = 1; c < tempcomps; c++) {
+		if (opjimage->comps[c].bpp != opjimage->comps[c - 1].bpp) {
+			tempcomps = 1;
+			break;
+		}
+	}
+
+	// only one component selected
+	if (m_components)
+		tempcomps = 1;
+
+	// RGB color picture
+	if (tempcomps == 3) {
+		int row, col;
+		int *r = opjimage->comps[0].data;
+		int *g = opjimage->comps[1].data;
+		int *b = opjimage->comps[2].data;
+		if (shiftbpp > 0) {
+			for (row = 0; row < opjimage->comps[0].h; row++) {
+				for (col = 0; col < opjimage->comps[0].w; col++) {
+					
+					*(ptr++) = (*(r++)) >> shiftbpp;
+					*(ptr++) = (*(g++)) >> shiftbpp;
+					*(ptr++) = (*(b++)) >> shiftbpp;
+
+				}
+			}
+
+		} else if (shiftbpp < 0) {
+			for (row = 0; row < opjimage->comps[0].h; row++) {
+				for (col = 0; col < opjimage->comps[0].w; col++) {
+					
+					*(ptr++) = (*(r++)) << -shiftbpp;
+					*(ptr++) = (*(g++)) << -shiftbpp;
+					*(ptr++) = (*(b++)) << -shiftbpp;
+
+				}
+			}
+			
+		} else {
+			for (row = 0; row < opjimage->comps[0].h; row++) {
+				for (col = 0; col < opjimage->comps[0].w; col++) {
+
+					*(ptr++) = *(r++);
+					*(ptr++) = *(g++);
+					*(ptr++) = *(b++);
+				
+				}
+			}
+		}
+	}
+
+	// B/W picture
+	if (tempcomps == 1) {
+		int row, col;
+		int selcomp;
+
+		if (m_components)
+			selcomp = m_components - 1;
+		else
+			selcomp = 0;
+
+		int *y = opjimage->comps[selcomp].data;
+		if (shiftbpp > 0) {
+			for (row = 0; row < opjimage->comps[selcomp].h; row++) {
+				for (col = 0; col < opjimage->comps[selcomp].w; col++) {
+					
+					*(ptr++) = (*(y)) >> shiftbpp;
+					*(ptr++) = (*(y)) >> shiftbpp;
+					*(ptr++) = (*(y++)) >> shiftbpp;
+
+				}
+			}
+		} else if (shiftbpp < 0) {
+			for (row = 0; row < opjimage->comps[selcomp].h; row++) {
+				for (col = 0; col < opjimage->comps[selcomp].w; col++) {
+					
+					*(ptr++) = (*(y)) << -shiftbpp;
+					*(ptr++) = (*(y)) << -shiftbpp;
+					*(ptr++) = (*(y++)) << -shiftbpp;
+
+				}
+			}
+		} else {
+			for (row = 0; row < opjimage->comps[selcomp].h; row++) {
+				for (col = 0; col < opjimage->comps[selcomp].w; col++) {
+					
+					*(ptr++) = *(y);
+					*(ptr++) = *(y);
+					*(ptr++) = *(y++);
+
+				}
+			}
+		}
+	}
+
+
+}
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagmj2.cpp.svn-base ./OPJViewer/source/.svn/text-base/imagmj2.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagmj2.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagmj2.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,771 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagmj2.cpp
+// Purpose:     wxImage Motion JPEG 2000 file format handler
+// Author:      Giuseppe Baruffa - based on imagjpeg.cpp, Vaclav Slavik
+// RCS-ID:      $Id: imagmj2.cpp,v 0.00 2007/02/18 23:59:00 MW Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+// For compilers that support precompilation, includes "wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+    #pragma hdrstop
+#endif
+
+#if wxUSE_IMAGE && wxUSE_LIBOPENJPEG
+
+#include "imagmj2.h"
+
+#ifndef WX_PRECOMP
+    #include "wx/log.h"
+    #include "wx/app.h"
+    #include "wx/intl.h"
+    #include "wx/bitmap.h"
+    #include "wx/module.h"
+#endif
+
+
+#include "libopenjpeg/openjpeg.h"
+
+
+#include "wx/filefn.h"
+#include "wx/wfstream.h"
+
+// ----------------------------------------------------------------------------
+// types
+// ----------------------------------------------------------------------------
+
+
+//-----------------------------------------------------------------------------
+// wxMJ2Handler
+//-----------------------------------------------------------------------------
+
+IMPLEMENT_DYNAMIC_CLASS(wxMJ2Handler,wxImageHandler)
+
+#if wxUSE_STREAMS
+
+//------------- JPEG 2000 Data Source Manager
+
+#define J2K_CFMT 0
+#define JP2_CFMT 1
+#define JPT_CFMT 2
+#define MJ2_CFMT 3
+#define PXM_DFMT 0
+#define PGX_DFMT 1
+#define BMP_DFMT 2
+#define YUV_DFMT 3
+
+#define MAX_MESSAGE_LEN 200
+
+/* sample error callback expecting a FILE* client object */
+void mj2_error_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[ERROR] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample warning callback expecting a FILE* client object */
+void mj2_warning_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[WARNING] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* sample debug callback expecting no client object */
+void mj2_info_callback(const char *msg, void *client_data) {
+	int message_len = strlen(msg) - 1;
+	if (msg[message_len] != '\n')
+		message_len = MAX_MESSAGE_LEN;
+#ifndef __WXGTK__ 
+		wxMutexGuiEnter();
+#endif /* __WXGTK__ */
+	wxLogMessage(wxT("[INFO] %.*s"), message_len, msg);
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif /* __WXGTK__ */
+}
+
+/* macro functions */
+/* From little endian to big endian, 2 and 4 bytes */
+#define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
+#define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
+                        ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
+						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
+						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
+
+/* From codestream to int values */
+#define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
+								((unsigned long int) (C)[(P) + 1] << 16) + \
+								((unsigned long int) (C)[(P) + 2] << 8) + \
+								((unsigned long int) (C)[(P) + 3] << 0))
+
+#define STREAM_TO_UINT16(C, P)	(((unsigned long int) (C)[(P) + 0] << 8) + \
+								((unsigned long int) (C)[(P) + 1] << 0))
+
+/* defines */
+#define SHORT_DESCR_LEN        32
+#define LONG_DESCR_LEN         256
+
+/* enumeration for file formats */
+#define J2FILENUM              4
+typedef enum {
+
+        JP2_FILE,
+        J2K_FILE,
+		MJ2_FILE,
+		UNK_FILE
+
+} my_j2filetype;
+
+/* enumeration for the box types */
+#define J2BOXNUM                23
+typedef enum {
+
+			FILE_BOX,
+			JP_BOX,
+			FTYP_BOX,
+			JP2H_BOX,
+			IHDR_BOX,
+			COLR_BOX,
+			JP2C_BOX,
+			JP2I_BOX,
+			XML_BOX,
+			UUID_BOX,
+			UINF_BOX,
+			MOOV_BOX,
+			MVHD_BOX,
+			TRAK_BOX,
+			TKHD_BOX,
+			MDIA_BOX,
+			MINF_BOX,
+			STBL_BOX,
+			STSD_BOX,
+			MJP2_BOX,
+			MDAT_BOX,
+			ANY_BOX,
+			UNK_BOX
+
+} my_j2boxtype;
+
+/* jp2 family box signatures */
+#define FILE_SIGN           ""
+#define JP_SIGN             "jP\040\040"
+#define FTYP_SIGN           "ftyp"
+#define JP2H_SIGN           "jp2h"
+#define IHDR_SIGN           "ihdr"
+#define COLR_SIGN           "colr"
+#define JP2C_SIGN           "jp2c"
+#define JP2I_SIGN           "jp2i"
+#define XML_SIGN            "xml\040"
+#define UUID_SIGN           "uuid"
+#define UINF_SIGN           "uinf"
+#define MOOV_SIGN           "moov"
+#define MVHD_SIGN           "mvhd"
+#define TRAK_SIGN           "trak"
+#define TKHD_SIGN           "tkhd"
+#define MDIA_SIGN           "mdia"
+#define MINF_SIGN           "minf"
+#define VMHD_SIGN           "vmhd"
+#define STBL_SIGN           "stbl"
+#define STSD_SIGN           "stsd"
+#define MJP2_SIGN           "mjp2"
+#define MDAT_SIGN           "mdat"
+#define ANY_SIGN 			""
+#define UNK_SIGN            ""
+
+/* the box structure itself */
+struct my_boxdef {
+
+        char                  value[5];                 /* hexadecimal value/string*/
+		char                  name[SHORT_DESCR_LEN];    /* short description       */
+		char                  descr[LONG_DESCR_LEN];    /* long  description       */
+		int                   sbox;                     /* is it a superbox?       */
+		int                   req[J2FILENUM];           /* mandatory box           */
+		my_j2boxtype             ins;                      /* contained in box...     */
+
+};
+
+/* the possible boxes */
+struct my_boxdef j2box[] =
+{
+/* sign */	{FILE_SIGN,
+/* short */	"placeholder for nothing",
+/* long */	"Nothing to say",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP_SIGN,
+/* short */	"JPEG 2000 Signature box",
+/* long */	"This box uniquely identifies the file as being part of the JPEG 2000 family of files",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{FTYP_SIGN,
+/* short */	"File Type box",
+/* long */	"This box specifies file type, version and compatibility information, including specifying if this file "
+			"is a conforming JP2 file or if it can be read by a conforming JP2 reader",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP2H_SIGN,
+/* short */	"JP2 Header box",
+/* long */	"This box contains a series of boxes that contain header-type information about the file",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{IHDR_SIGN,
+/* short */	"Image Header box",
+/* long */	"This box specifies the size of the image and other related fields",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	JP2H_BOX},
+
+/* sign */	{COLR_SIGN,
+/* short */	"Colour Specification box",
+/* long */	"This box specifies the colourspace of the image",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	JP2H_BOX},
+
+/* sign */	{JP2C_SIGN,
+/* short */	"Contiguous Codestream box",
+/* long */	"This box contains the codestream as defined by Annex A",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP2I_SIGN,
+/* short */	"Intellectual Property box",
+/* long */	"This box contains intellectual property information about the image",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{XML_SIGN,
+/* short */	"XML box",
+/* long */	"This box provides a tool by which vendors can add XML formatted information to a JP2 file",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UUID_SIGN,
+/* short */	"UUID box",
+/* long */	"This box provides a tool by which vendors can add additional information to a file "
+			"without risking conflict with other vendors",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UINF_SIGN,
+/* short */	"UUID Info box",
+/* long */	"This box provides a tool by which a vendor may provide access to additional information associated with a UUID",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{MOOV_SIGN,
+/* short */	"Movie box",
+/* long */	"This box contains the media data. In video tracks, this box would contain JPEG2000 video frames",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{MVHD_SIGN,
+/* short */	"Movie Header box",
+/* long */	"This box defines overall information which is media-independent, and relevant to the entire presentation "
+			"considered as a whole",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MOOV_BOX},
+
+/* sign */	{TRAK_SIGN,
+/* short */	"Track box",
+/* long */	"This is a container box for a single track of a presentation. A presentation may consist of one or more tracks",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MOOV_BOX},
+
+/* sign */	{TKHD_SIGN,
+/* short */	"Track Header box",
+/* long */	"This box specifies the characteristics of a single track. Exactly one Track Header Box is contained in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	TRAK_BOX},
+
+/* sign */	{MDIA_SIGN,
+/* short */	"Media box",
+/* long */	"The media declaration container contains all the objects which declare information about the media data "
+			"within a track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	TRAK_BOX},
+
+/* sign */	{MINF_SIGN,
+/* short */	"Media Information box",
+/* long */	"This box contains all the objects which declare characteristic information of the media in the track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{STBL_SIGN,
+/* short */	"Sample Table box",
+/* long */	"The sample table contains all the time and data indexing of the media samples in a track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{STSD_SIGN,
+/* short */	"Sample Description box",
+/* long */	"The sample description table gives detailed information about the coding type used, and any initialization "
+			"information needed for that coding",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{MJP2_SIGN,
+/* short */	"MJP2 Sample Description box",
+/* long */	"The MJP2 sample description table gives detailed information about the coding type used, and any initialization "
+			"information needed for that coding",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{MDAT_SIGN,
+/* short */	"Media Data box",
+/* long */	"The meta-data for a presentation is stored in the single Movie Box which occurs at the top-level of a file",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{ANY_SIGN,
+/* short */	"Any box",
+/* long */	"All the existing boxes",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UNK_SIGN,
+/* short */	"Unknown Type box",
+/* long */	"The signature is not recognised to be that of an existing box",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	ANY_BOX}
+
+};
+
+/* declaration */
+int
+my_box_handler_function(my_j2boxtype boxtype, wxInputStream& stream, unsigned long int filepoint, unsigned long int filelimit, int level,
+					 char *scansign, unsigned long int *scanpoint);
+
+#ifdef __WXMSW__
+typedef unsigned __int64 int8byte;
+#endif // __WXMSW__
+
+#ifdef __WXGTK__
+typedef unsigned long long int8byte;
+#endif // __WXGTK__
+
+/* internal mini-search for a box signature */
+int
+my_jpeg2000parse(wxInputStream& stream, unsigned long int filepoint, unsigned long int filelimit, int level,
+			  char *scansign, unsigned long int *scanpoint)
+{
+	unsigned long int       LBox = 0x00000000;
+	//int                     LBox_read;
+	char                    TBox[5] = "\0\0\0\0";
+	//int                     TBox_read;
+	int8byte                 XLBox = 0x0000000000000000;
+	//int                     XLBox_read;
+	unsigned long int       box_length = 0;
+	int                     last_box = 0, box_num = 0;
+	int                     box_type = ANY_BOX;
+	unsigned char           /*onebyte[1], twobytes[2],*/ fourbytes[4];
+	int                     box_number = 0;
+
+	/* cycle all over the file */
+	box_num = 0;
+	last_box = 0;
+	while (!last_box) {
+
+		/* do not exceed file limit */
+		if (filepoint >= filelimit)
+			return (0);
+
+		/* seek on file */
+		if (stream.SeekI(filepoint, wxFromStart) == wxInvalidOffset)
+			return (-1);
+
+		/* read the mandatory LBox, 4 bytes */
+		if (!stream.Read(fourbytes, 4)) {
+			(wxT("Problem reading LBox from the file (file ended?)"));
+			return -1;
+		};
+		LBox = STREAM_TO_UINT32(fourbytes, 0);
+
+		/* read the mandatory TBox, 4 bytes */
+		if (!stream.Read(TBox, 4)) {
+			wxLogError(wxT("Problem reading TBox from the file (file ended?)"));
+			return -1;
+		};
+
+		/* look if scansign is got */
+		if ((scansign != NULL) && (memcmp(TBox, scansign, 4) == 0)) {
+			/* hack/exploit */
+			// stop as soon as you find the level-th codebox
+			if (box_number == level) {
+				memcpy(scansign, "    ", 4);
+				*scanpoint = filepoint;
+				return (0);
+			} else
+				box_number++;
+
+		};
+
+
+		/* determine the box type */
+		for (box_type = JP_BOX; box_type < UNK_BOX; box_type++)
+			if (memcmp(TBox, j2box[box_type].value, 4) == 0)
+				break;	
+
+		/* read the optional XLBox, 8 bytes */
+		if (LBox == 1) {
+
+			if (!stream.Read(&XLBox, 8)) {
+				wxLogError(wxT("Problem reading XLBox from the file (file ended?)"));
+				return -1;
+			};
+			box_length = (unsigned long int) BYTE_SWAP8(XLBox);
+
+		} else if (LBox == 0x00000000) {
+
+			/* last box in file */
+			last_box = 1; 
+			box_length = filelimit - filepoint;
+
+		} else
+
+			box_length = LBox;
+
+
+		/* go deep in the box */
+		my_box_handler_function((my_j2boxtype) box_type, stream, (LBox == 1) ? (filepoint + 16) : (filepoint + 8), filepoint + box_length, level,
+			scansign, scanpoint);
+
+		/* if it's a superbox go inside it */
+		if (j2box[box_type].sbox)
+			my_jpeg2000parse(stream, (LBox == 1) ? (filepoint + 16) : (filepoint + 8), filepoint + box_length,
+				level, scansign, scanpoint);
+
+		/* increment box number and filepoint*/
+		box_num++;
+		filepoint += box_length;
+
+	};
+
+	/* all good */
+	return (0);
+}
+
+// search first contiguos codestream box in an mj2 file
+unsigned long int
+searchjp2c(wxInputStream& stream, unsigned long int fsize, int number)
+{
+	char scansign[] = "jp2c";
+	unsigned long int scanpoint = 0L;
+
+	wxLogMessage(wxT("MJ2: searching jp2c box... "));
+
+	/* do the parsing */
+	if (my_jpeg2000parse(stream, 0, fsize, number, scansign, &scanpoint) < 0)		
+		wxLogMessage(wxT("MJ2: Unrecoverable error during file parsing: stopping"));
+
+	if (strcmp(scansign, "    "))
+		wxLogMessage(wxT("MJ2: not found"));
+	else {
+
+		wxLogMessage(wxString::Format(wxT("MJ2: found at byte %d"), scanpoint));
+
+	};
+
+
+	return (scanpoint);
+}
+
+// search the jp2h box in the file
+unsigned long int
+searchjpegheaderbox(wxInputStream& stream, unsigned long int fsize)
+{
+	char scansign[] = "jp2h";
+	unsigned long int scanpoint = 0L;
+
+	wxLogMessage(wxT("MJ2: searching jp2h box... "));
+
+	/* do the parsing */
+	if (my_jpeg2000parse(stream, 0, fsize, 0, scansign, &scanpoint) < 0)		
+		wxLogMessage(wxT("Unrecoverable error during file parsing: stopping"));
+
+	if (strcmp(scansign, "    "))
+		wxLogMessage(wxT("MJ2: not found"));
+	else
+		wxLogMessage(wxString::Format(wxT("MJ2: found at byte %d"), scanpoint));
+
+	return (scanpoint);
+}
+
+/* handling functions */
+#define ITEM_PER_ROW	10
+
+/* Box handler function */
+int
+my_box_handler_function(my_j2boxtype boxtype, wxInputStream& stream, unsigned long int filepoint, unsigned long int filelimit, int level,
+					 char *scansign, unsigned long int *scanpoint)
+{
+	switch (boxtype) {
+
+			/* Sample Description box */
+	case (STSD_BOX):
+		my_jpeg2000parse(stream, filepoint + 8, filelimit, level, scansign, scanpoint);
+		break;
+
+			/* MJP2 Sample Description box */
+	case (MJP2_BOX):
+		my_jpeg2000parse(stream, filepoint + 78, filelimit, level, scansign, scanpoint);
+		break;
+		
+	/* not yet implemented */
+	default:
+		break;
+
+	};
+
+	return (0);
+}
+
+// the jP and ftyp parts of the header
+#define my_jPheadSIZE	32
+unsigned char my_jPhead[my_jPheadSIZE] = {
+		0x00, 0x00, 0x00, 0x0C,  'j',  'P',  ' ',  ' ',
+		0x0D, 0x0A, 0x87, 0x0A, 0x00, 0x00, 0x00, 0x14,
+		 'f',  't',  'y',  'p',  'j',  'p',  '2',  ' ',
+		0x00, 0x00, 0x00, 0x00,  'j',  'p',  '2',  ' '			
+};
+
+/////////////////////////////////////////////////
+/////////////////////////////////////////////////
+
+// load the mj2 file format
+bool wxMJ2Handler::LoadFile(wxImage *image, wxInputStream& stream, bool verbose, int index)
+{
+	opj_dparameters_t parameters;	/* decompression parameters */
+	opj_event_mgr_t event_mgr;		/* event manager */
+	opj_image_t *opjimage = NULL;
+	unsigned char *src = NULL;
+    unsigned char *ptr;
+	int file_length, jp2c_point, jp2h_point;
+	unsigned long int jp2hboxlen, jp2cboxlen;
+	opj_codestream_info_t cstr_info;  /* Codestream information structure */
+
+	// destroy the image
+    image->Destroy();
+
+	/* handle to a decompressor */
+	opj_dinfo_t* dinfo = NULL;	
+	opj_cio_t *cio = NULL;
+
+	/* configure the event callbacks (not required) */
+	memset(&event_mgr, 0, sizeof(opj_event_mgr_t));
+	event_mgr.error_handler = mj2_error_callback;
+	event_mgr.warning_handler = mj2_warning_callback;
+	event_mgr.info_handler = mj2_info_callback;
+
+	/* set decoding parameters to default values */
+	opj_set_default_decoder_parameters(&parameters);
+
+	/* prepare parameters */
+	strncpy(parameters.infile, "", sizeof(parameters.infile)-1);
+	strncpy(parameters.outfile, "", sizeof(parameters.outfile)-1);
+	parameters.decod_format = JP2_CFMT;
+	parameters.cod_format = BMP_DFMT;
+	if (m_reducefactor)
+		parameters.cp_reduce = m_reducefactor;
+	if (m_qualitylayers)
+		parameters.cp_layer = m_qualitylayers;
+	/*if (n_components)
+		parameters. = n_components;*/
+
+	/* JPWL only */
+#ifdef USE_JPWL
+	parameters.jpwl_exp_comps = m_expcomps;
+	parameters.jpwl_max_tiles = m_maxtiles;
+	parameters.jpwl_correct = m_enablejpwl;
+#endif /* USE_JPWL */
+
+	/* get a decoder handle */
+	dinfo = opj_create_decompress(CODEC_JP2);
+
+	/* find length of the stream */
+	stream.SeekI(0, wxFromEnd);
+	file_length = (int) stream.TellI();
+
+	/* search for the first codestream box and the movie header box  */
+	jp2c_point = searchjp2c(stream, file_length, m_framenum);
+	jp2h_point = searchjpegheaderbox(stream, file_length);
+
+	// read the jp2h box and store it
+	stream.SeekI(jp2h_point, wxFromStart);
+	stream.Read(&jp2hboxlen, sizeof(unsigned long int));
+	jp2hboxlen = BYTE_SWAP4(jp2hboxlen);
+
+	// read the jp2c box and store it
+	stream.SeekI(jp2c_point, wxFromStart);
+	stream.Read(&jp2cboxlen, sizeof(unsigned long int));
+	jp2cboxlen = BYTE_SWAP4(jp2cboxlen);
+
+	// malloc memory source
+    src = (unsigned char *) malloc(my_jPheadSIZE + jp2hboxlen + jp2cboxlen);
+
+	// copy the jP and ftyp
+	memcpy(src, my_jPhead, my_jPheadSIZE);
+
+	// copy the jp2h
+	stream.SeekI(jp2h_point, wxFromStart);
+	stream.Read(&src[my_jPheadSIZE], jp2hboxlen);
+
+	// copy the jp2c
+	stream.SeekI(jp2c_point, wxFromStart);
+	stream.Read(&src[my_jPheadSIZE + jp2hboxlen], jp2cboxlen);
+
+	/* catch events using our callbacks and give a local context */
+	opj_set_event_mgr((opj_common_ptr)dinfo, &event_mgr, stderr);
+
+	/* setup the decoder decoding parameters using user parameters */
+	opj_setup_decoder(dinfo, &parameters);
+
+	/* open a byte stream */
+	cio = opj_cio_open((opj_common_ptr)dinfo, src, my_jPheadSIZE + jp2hboxlen + jp2cboxlen);
+
+	/* decode the stream and fill the image structure */
+	opjimage = opj_decode_with_info(dinfo, cio, &cstr_info);
+	if (!opjimage) {
+		wxMutexGuiEnter();
+		wxLogError(wxT("MJ2: failed to decode image!"));
+		wxMutexGuiLeave();
+		opj_destroy_decompress(dinfo);
+		opj_cio_close(cio);
+		free(src);
+		return false;
+	}
+
+	/* close the byte stream */
+	opj_cio_close(cio);
+
+	/* common rendering method */
+#include "imagjpeg2000.cpp"
+
+    wxMutexGuiEnter();
+    wxLogMessage(wxT("MJ2: image loaded."));
+    wxMutexGuiLeave();
+
+	/* close openjpeg structs */
+	opj_destroy_decompress(dinfo);
+	opj_image_destroy(opjimage);
+	free(src);
+
+	if (!image->Ok())
+		return false;
+	else
+		return true;
+
+}
+
+// save the mj2 file format
+bool wxMJ2Handler::SaveFile( wxImage *image, wxOutputStream& stream, bool verbose )
+{
+    wxLogError(wxT("MJ2: Couldn't save movie -> not implemented."));
+    return false;
+}
+
+#ifdef __VISUALC__
+    #pragma warning(default:4611)
+#endif /* VC++ */
+
+// recognize the Motion JPEG 2000 starting box
+bool wxMJ2Handler::DoCanRead( wxInputStream& stream )
+{
+    unsigned char hdr[24];
+
+    if ( !stream.Read(hdr, WXSIZEOF(hdr)) )
+        return false;
+
+    return (hdr[0] == 0x00 &&
+			hdr[1] == 0x00 &&
+			hdr[2] == 0x00 &&
+			hdr[3] == 0x0C &&
+			hdr[4] == 0x6A &&
+			hdr[5] == 0x50 &&
+			hdr[6] == 0x20 &&
+			hdr[7] == 0x20 &&
+			hdr[20] == 0x6D &&
+			hdr[21] == 0x6A &&
+			hdr[22] == 0x70 &&
+			hdr[23] == 0x32);
+}
+
+#endif   // wxUSE_STREAMS
+
+#endif   // wxUSE_LIBOPENJPEG
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagmj2.h.svn-base ./OPJViewer/source/.svn/text-base/imagmj2.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/imagmj2.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/imagmj2.h.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,92 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        imagmj2.h
+// Purpose:     wxImage Motion JPEG 2000 file format handler
+// Author:      G. Baruffa - based on imagjpeg.h, Vaclav Slavik
+// RCS-ID:      $Id: imagmj2.h,v 0.0 2007/02/18 23:45:00 VZ Exp $
+// Copyright:   (c) Giuseppe Baruffa
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef _WX_IMAGMJ2_H_
+#define _WX_IMAGMJ2_H_
+
+#include "wx/defs.h"
+
+//-----------------------------------------------------------------------------
+// wxMJ2Handler
+//-----------------------------------------------------------------------------
+
+#if wxUSE_LIBOPENJPEG
+
+#include "wx/image.h"
+#include "libopenjpeg/openjpeg.h"
+
+#define wxBITMAP_TYPE_MJ2	49
+
+class WXDLLEXPORT wxMJ2Handler: public wxImageHandler
+{
+public:
+    inline wxMJ2Handler()
+    {
+        m_name = wxT("Motion JPEG 2000 file format");
+        m_extension = wxT("mj2");
+        m_type = wxBITMAP_TYPE_MJ2;
+        m_mime = wxT("image/mj2");
+
+		m_reducefactor = 0;
+		m_qualitylayers = 0;
+		m_components = 0;
+#ifdef USE_JPWL
+		m_enablejpwl = true;
+		m_expcomps = JPWL_EXPECTED_COMPONENTS;
+		m_maxtiles = JPWL_MAXIMUM_TILES;
+#endif // USE_JPWL
+    }
+
+		// decoding engine parameters
+		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
+#ifdef USE_JPWL
+		bool m_enablejpwl;
+		int m_expcomps, m_maxtiles;
+#endif // USE_JPWL
+
+#if wxUSE_STREAMS
+    virtual bool LoadFile( wxImage *image, wxInputStream& stream, bool verbose=true, int index=-1 );
+    virtual bool SaveFile( wxImage *image, wxOutputStream& stream, bool verbose=true );
+protected:
+    virtual bool DoCanRead( wxInputStream& stream );
+#endif
+
+private:
+    DECLARE_DYNAMIC_CLASS(wxMJ2Handler)
+};
+
+#endif // wxUSE_LIBOPENJPEG
+
+#endif // _WX_IMAGMJ2_H_
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/license.txt.svn-base ./OPJViewer/source/.svn/text-base/license.txt.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/license.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/license.txt.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,14 @@
+Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium
+Copyright (c) 2002-2007, Professor Benoit Macq
+Copyright (c) 2001-2003, David Janssens
+Copyright (c) 2002-2003, Yannick Verschueren
+Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe
+Copyright (c) 2005, Herve Drolon, FreeImage Team
+Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+All rights reserved.
+
+Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditionsare met:
+1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
+2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
+
+THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJChild16.xpm.svn-base ./OPJViewer/source/.svn/text-base/OPJChild16.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJChild16.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJChild16.xpm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,28 @@
+/* XPM */
+static char *OPJChild16[] = {
+/* columns rows colors chars-per-pixel */
+"16 16 6 1",
+"  c black",
+". c #008000",
+"X c red",
+"o c #800080",
+"O c gray100",
+"+ c None",
+/* pixels */
+"++++++++++++++++",
+"+OOOOOOOOOOOOOO+",
+"+OooooooooooooO+",
+"+OooooooooooooO+",
+"+OooOOOOOOOOOoO+",
+"+OooO.......OoO+",
+"+OooO.......OoO+",
+"+OooO..OOO..OoO+",
+"+OooO..OXO..OoO+",
+"+OooO..OOO..OoO+",
+"+OooO.......OoO+",
+"+OooO.......OoO+",
+"+OooOOOOOOOOOoO+",
+"+OooooooooooooO+",
+"+OOOOOOOOOOOOOO+",
+"++++++++++++++++"
+};
Binary files /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJChild.ico.svn-base and ./OPJViewer/source/.svn/text-base/OPJChild.ico.svn-base differ
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJDialogs.cpp.svn-base ./OPJViewer/source/.svn/text-base/OPJDialogs.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJDialogs.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJDialogs.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1082 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita'  degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "OPJViewer.h"
+
+// ----------------------------------------------------------------------------
+// OPJDecoderDialog
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(OPJDecoderDialog, wxPropertySheetDialog)
+
+BEGIN_EVENT_TABLE(OPJDecoderDialog, wxPropertySheetDialog)
+#ifdef USE_JPWL
+	EVT_CHECKBOX(OPJDECO_ENABLEDECO, OPJDecoderDialog::OnEnableDeco)
+	EVT_CHECKBOX(OPJDECO_ENABLEJPWL, OPJDecoderDialog::OnEnableJPWL)
+#endif // USE_JPWL
+END_EVENT_TABLE()
+
+OPJDecoderDialog::OPJDecoderDialog(wxWindow* win, int dialogType)
+{
+	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+
+	Create(win, wxID_ANY, wxT("Decoder settings"),
+		wxDefaultPosition, wxDefaultSize,
+		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+		);
+
+	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+
+	m_settingsNotebook = GetBookCtrl();
+
+	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+	wxPanel* jpeg2000Settings = CreatePart1SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		jpeg2000Settings->Enable(false);
+	wxPanel* mjpeg2000Settings = CreatePart3SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		mjpeg2000Settings->Enable(false);
+#ifdef USE_JPWL
+	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+	if (!wxGetApp().m_enabledeco)
+		jpwlSettings->Enable(false);
+#endif // USE_JPWL
+
+	m_settingsNotebook->AddPage(mainSettings, wxT("Display"), false);
+	m_settingsNotebook->AddPage(jpeg2000Settings, wxT("JPEG 2000"), false);
+	m_settingsNotebook->AddPage(mjpeg2000Settings, wxT("MJPEG 2000"), false);
+#ifdef USE_JPWL
+	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+#endif // USE_JPWL
+
+	LayoutDialog();
+}
+
+OPJDecoderDialog::~OPJDecoderDialog()
+{
+}
+
+wxPanel* OPJDecoderDialog::CreateMainSettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+		// add decoding enabling check box
+		subtopSizer->Add(
+			m_enabledecoCheck = new wxCheckBox(panel, OPJDECO_ENABLEDECO, wxT("Enable decoding"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enabledecoCheck->SetValue(wxGetApp().m_enabledeco);
+
+		// add parsing enabling check box
+		subtopSizer->Add(
+			m_enableparseCheck = new wxCheckBox(panel, OPJDECO_ENABLEPARSE, wxT("Enable parsing"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enableparseCheck->SetValue(wxGetApp().m_enableparse);
+
+			// resize settings, column
+			wxString choices[] = {wxT("Don't resize"), wxT("Low quality"), wxT("High quality")};
+			m_resizeBox = new wxRadioBox(panel, OPJDECO_RESMETHOD,
+				wxT("Resize method"),
+				wxDefaultPosition, wxDefaultSize,
+				WXSIZEOF(choices),
+				choices,
+				1,
+				wxRA_SPECIFY_ROWS);
+			m_resizeBox->SetSelection(wxGetApp().m_resizemethod + 1);
+
+		subtopSizer->Add(m_resizeBox, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJDecoderDialog::CreatePart3SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+			// frame settings, column
+			wxStaticBox* frameBox = new wxStaticBox(panel, wxID_ANY, wxT("Frame"));
+			wxBoxSizer* frameSizer = new wxStaticBoxSizer(frameBox, wxVERTICAL);
+
+				// selected frame number, row
+				wxBoxSizer* framenumSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				framenumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Displayed frame:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				framenumSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				framenumSizer->Add(
+					m_framenumCtrl = new wxSpinCtrl(panel, OPJDECO_FRAMENUM,
+								wxString::Format(wxT("%d"), wxGetApp().m_framenum),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_framenum),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			frameSizer->Add(framenumSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(frameSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJDecoderDialog::CreatePart1SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+			// resolutions settings, column
+			wxStaticBox* resolutionBox = new wxStaticBox(panel, wxID_ANY, wxT("Resolutions"));
+			wxBoxSizer* resolutionSizer = new wxStaticBoxSizer(resolutionBox, wxVERTICAL);
+
+				// reduce factor sizer, row
+				wxBoxSizer* reduceSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				reduceSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Reduce factor:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				reduceSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				reduceSizer->Add(
+					m_reduceCtrl = new wxSpinCtrl(panel, OPJDECO_REDUCEFACTOR,
+					wxString::Format(wxT("%d"), wxGetApp().m_reducefactor),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 10000, wxGetApp().m_reducefactor),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			resolutionSizer->Add(reduceSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(resolutionSizer, 0, wxGROW | wxALL, 5);
+
+			// quality layer settings, column
+			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers"));
+			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+
+				// quality layers sizer, row
+				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality layers:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				qualitySizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				qualitySizer->Add(
+					m_layerCtrl = new wxSpinCtrl(panel, OPJDECO_QUALITYLAYERS,
+								wxString::Format(wxT("%d"), wxGetApp().m_qualitylayers),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 100000, wxGetApp().m_qualitylayers),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+
+			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 5);
+
+			// component settings, column
+			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+
+				// quality layers sizer, row
+				wxBoxSizer* numcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				numcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component displayed:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				numcompsSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				numcompsSizer->Add(
+					m_numcompsCtrl = new wxSpinCtrl(panel, OPJDECO_NUMCOMPS,
+								wxString::Format(wxT("%d"), wxGetApp().m_components),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 100000, wxGetApp().m_components),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_numcompsCtrl->Enable(true);
+
+			compoSizer->Add(numcompsSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+#ifdef USE_JPWL
+wxPanel* OPJDecoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+		// add JPWL enabling check box
+		subtopSizer->Add(
+			m_enablejpwlCheck = new wxCheckBox(panel, OPJDECO_ENABLEJPWL, wxT("Enable JPWL"), wxDefaultPosition, wxDefaultSize),
+			0, wxGROW | wxALL, 5);
+		m_enablejpwlCheck->SetValue(wxGetApp().m_enablejpwl);
+
+			// component settings, column
+			wxStaticBox* compoBox = new wxStaticBox(panel, wxID_ANY, wxT("Components"));
+			wxBoxSizer* compoSizer = new wxStaticBoxSizer(compoBox, wxVERTICAL);
+
+				// expected components sizer, row
+				wxBoxSizer* expcompsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				expcompsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Expected comps.:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				expcompsSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				expcompsSizer->Add(
+					m_expcompsCtrl = new wxSpinCtrl(panel, OPJDECO_EXPCOMPS,
+								wxString::Format(wxT("%d"), wxGetApp().m_expcomps),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_expcomps),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_expcompsCtrl->Enable(wxGetApp().m_enablejpwl);
+
+			compoSizer->Add(expcompsSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(compoSizer, 0, wxGROW | wxALL, 5);
+
+			// tiles settings, column
+			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+
+				// maximum tiles sizer, row
+				wxBoxSizer* maxtileSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				maxtileSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Max. no. of tiles:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 5);
+
+				// add some horizontal space
+				maxtileSizer->Add(5, 5, 1, wxALL, 0);
+
+				// add the value control
+				maxtileSizer->Add(
+					m_maxtilesCtrl = new wxSpinCtrl(panel, OPJDECO_MAXTILES,
+								wxString::Format(wxT("%d"), wxGetApp().m_maxtiles),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								1, 100000, wxGetApp().m_maxtiles),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 5);
+				m_maxtilesCtrl->Enable(wxGetApp().m_enablejpwl);
+
+			tileSizer->Add(maxtileSizer, 0, wxGROW | wxALL, 5);
+
+		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 5);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+void OPJDecoderDialog::OnEnableDeco(wxCommandEvent& event)
+{
+	size_t pp;
+
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Decoding enabled"));
+		m_resizeBox->Enable(true);
+		// enable all tabs except ourselves
+		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+				m_settingsNotebook->GetPage(pp)->Enable(true);
+		}
+	} else {
+		wxLogMessage(wxT("Decoding disabled"));
+		m_resizeBox->Enable(false);
+		// disable all tabs except ourselves
+		for (pp = 0; pp < m_settingsNotebook->GetPageCount(); pp++) {
+			if (m_settingsNotebook->GetPageText(pp) != wxT("Display"))
+				m_settingsNotebook->GetPage(pp)->Enable(false);
+		}
+	}
+
+}
+
+void OPJDecoderDialog::OnEnableJPWL(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("JPWL enabled"));
+		m_expcompsCtrl->Enable(true);
+		m_maxtilesCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("JPWL disabled"));
+		m_expcompsCtrl->Enable(false);
+		m_maxtilesCtrl->Enable(false);
+	}
+
+}
+
+#endif // USE_JPWL
+
+bool OPJDnDFile::OnDropFiles(wxCoord, wxCoord, const wxArrayString& filenames)
+{
+    /*size_t nFiles = filenames.GetCount();
+    wxString str;
+    str.Printf( _T("%d files dropped\n"), (int)nFiles);
+    for ( size_t n = 0; n < nFiles; n++ ) {
+        str << filenames[n] << wxT("\n");
+    }
+    wxLogMessage(str);*/
+	m_pOwner->OpenFiles(filenames, filenames);
+
+    return true;
+}
+
+
+
+
+
+// ----------------------------------------------------------------------------
+// OPJEncoderDialog
+// ----------------------------------------------------------------------------
+
+IMPLEMENT_CLASS(OPJEncoderDialog, wxPropertySheetDialog)
+
+BEGIN_EVENT_TABLE(OPJEncoderDialog, wxPropertySheetDialog)
+#ifdef USE_JPWL
+	EVT_CHECKBOX(OPJENCO_ENABLEJPWL, OPJEncoderDialog::OnEnableJPWL)
+	EVT_CHECKBOX(OPJENCO_ENABLECOMM, OPJEncoderDialog::OnEnableComm)
+	EVT_CHECKBOX(OPJENCO_ENABLEINDEX, OPJEncoderDialog::OnEnableIdx)
+	EVT_RADIOBUTTON(OPJENCO_RATERADIO, OPJEncoderDialog::OnRadioQualityRate)
+	EVT_RADIOBUTTON(OPJENCO_QUALITYRADIO, OPJEncoderDialog::OnRadioQualityRate)
+#endif // USE_JPWL
+END_EVENT_TABLE()
+
+OPJEncoderDialog::OPJEncoderDialog(wxWindow* win, int dialogType)
+{
+	SetExtraStyle(wxDIALOG_EX_CONTEXTHELP|wxWS_EX_VALIDATE_RECURSIVELY);
+
+	Create(win, wxID_ANY, wxT("Encoder settings"),
+		wxDefaultPosition, wxDefaultSize,
+		wxDEFAULT_DIALOG_STYLE| (int) wxPlatform::IfNot(wxOS_WINDOWS_CE, wxRESIZE_BORDER)
+		);
+
+	CreateButtons(wxOK | wxCANCEL | (int)wxPlatform::IfNot(wxOS_WINDOWS_CE, wxHELP));
+
+	m_settingsNotebook = GetBookCtrl();
+
+	wxPanel* jpeg2000_1Settings = CreatePart1_1SettingsPage(m_settingsNotebook);
+	wxPanel* jpeg2000_2Settings = CreatePart1_2SettingsPage(m_settingsNotebook);
+	wxPanel* mainSettings = CreateMainSettingsPage(m_settingsNotebook);
+#ifdef USE_JPWL
+	wxPanel* jpwlSettings = CreatePart11SettingsPage(m_settingsNotebook);
+#endif // USE_JPWL
+
+	m_settingsNotebook->AddPage(jpeg2000_1Settings, wxT("JPEG 2000 - 1"), false);
+	m_settingsNotebook->AddPage(jpeg2000_2Settings, wxT("JPEG 2000 - 2"), false);
+	m_settingsNotebook->AddPage(mainSettings, wxT("General"), false);
+#ifdef USE_JPWL
+	m_settingsNotebook->AddPage(jpwlSettings, wxT("JPWL"), false);
+#endif // USE_JPWL
+
+	LayoutDialog();
+}
+
+OPJEncoderDialog::~OPJEncoderDialog()
+{
+}
+
+wxPanel* OPJEncoderDialog::CreateMainSettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+#ifdef USE_JPWL
+wxPanel* OPJEncoderDialog::CreatePart11SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+		// sub top sizer
+		wxBoxSizer *subtopSizer = new wxBoxSizer(wxVERTICAL);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+#endif // USE_JPWL
+
+wxPanel* OPJEncoderDialog::CreatePart1_1SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+
+			// image settings, column
+			wxStaticBox* imageBox = new wxStaticBox(panel, wxID_ANY, wxT("Image"));
+			wxBoxSizer* imageSizer = new wxStaticBoxSizer(imageBox, wxVERTICAL);
+
+				// subsampling factor sizer, row
+				wxBoxSizer* subsSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				subsSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Subsampling:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				subsSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				subsSizer->Add(
+					m_subsamplingCtrl = new wxTextCtrl(panel, OPJENCO_SUBSAMPLING,
+								wxGetApp().m_subsampling,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			imageSizer->Add(subsSizer, 0, wxGROW | wxALL, 3);
+
+				// origin sizer, row
+				wxBoxSizer* imorigSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				imorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				imorigSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				imorigSizer->Add(
+					m_originCtrl = new wxTextCtrl(panel, OPJENCO_IMORIG,
+								wxGetApp().m_origin,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			imageSizer->Add(imorigSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(imageSizer, 0, wxGROW | wxALL, 3);
+
+			// layer settings, column
+			wxStaticBox* layerBox = new wxStaticBox(panel, wxID_ANY, wxT("Layers/compression"));
+			wxBoxSizer* layerSizer = new wxStaticBoxSizer(layerBox, wxVERTICAL);
+
+				// rate factor sizer, row
+				wxBoxSizer* rateSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				/*rateSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Rate values:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
+
+				// add the radio button
+				rateSizer->Add(
+					m_rateRadio = new wxRadioButton(panel, OPJENCO_RATERADIO, wxT("&Rate values"),
+								wxDefaultPosition, wxDefaultSize,
+								wxRB_GROUP),
+								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
+								);
+				m_rateRadio->SetValue(!(wxGetApp().m_enablequality));
+
+				// add some horizontal space
+				rateSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				rateSizer->Add(
+					m_rateCtrl = new wxTextCtrl(panel, OPJENCO_RATEFACTOR,
+								wxGetApp().m_rates,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				if (wxGetApp().m_enablequality == true)
+					m_rateCtrl->Enable(false);
+
+			layerSizer->Add(rateSizer, 0, wxGROW | wxALL, 3);
+
+				// quality factor sizer, row
+				wxBoxSizer* qualitySizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				/*qualitySizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Quality values:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);*/
+
+				// add the radio button
+				qualitySizer->Add(
+					m_qualityRadio = new wxRadioButton(panel, OPJENCO_QUALITYRADIO, wxT("&Quality values"),
+								wxDefaultPosition, wxDefaultSize),
+								0, wxALL | wxALIGN_LEFT | wxALIGN_CENTER_VERTICAL
+								);
+				m_qualityRadio->SetValue(wxGetApp().m_enablequality);
+
+				// add some horizontal space
+				qualitySizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				qualitySizer->Add(
+					m_qualityCtrl = new wxTextCtrl(panel, OPJENCO_QUALITYFACTOR,
+								wxGetApp().m_quality,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				if (wxGetApp().m_enablequality == false)
+					m_qualityCtrl->Enable(false);
+
+			layerSizer->Add(qualitySizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(layerSizer, 0, wxGROW | wxALL, 3);
+
+			// wavelet settings, column
+			wxStaticBox* transformBox = new wxStaticBox(panel, wxID_ANY, wxT("Transforms"));
+			wxBoxSizer* transformSizer = new wxStaticBoxSizer(transformBox, wxVERTICAL);
+
+			// multiple component check box
+			transformSizer->Add(
+				m_mctCheck = new wxCheckBox(panel, OPJENCO_ENABLEMCT, wxT("Multiple component"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_mctCheck->SetValue(wxGetApp().m_multicomp);
+
+			// irreversible wavelet check box
+			transformSizer->Add(
+				m_irrevCheck = new wxCheckBox(panel, OPJENCO_ENABLEIRREV, wxT("Irreversible wavelet"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_irrevCheck->SetValue(wxGetApp().m_irreversible);
+
+				// resolution number sizer, row
+				wxBoxSizer* resnumSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				resnumSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Resolutions:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				resnumSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				resnumSizer->Add(
+					m_resolutionsCtrl = new wxSpinCtrl(panel, OPJENCO_RESNUMBER,
+								wxString::Format(wxT("%d"), wxGetApp().m_resolutions),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 256, 6),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			transformSizer->Add(resnumSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(transformSizer, 0, wxGROW | wxALL, 3);
+
+			// codestream settings, column
+			wxStaticBox* codestreamBox = new wxStaticBox(panel, wxID_ANY, wxT("Codestream"));
+			wxBoxSizer* codestreamSizer = new wxStaticBoxSizer(codestreamBox, wxVERTICAL);
+
+				// codeblock sizer, row
+				wxBoxSizer* codeblockSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				codeblockSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Codeblocks size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				codeblockSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				codeblockSizer->Add(
+					m_cbsizeCtrl = new wxTextCtrl(panel, OPJENCO_CODEBLOCKSIZE,
+								wxGetApp().m_cbsize,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			codestreamSizer->Add(codeblockSizer, 0, wxGROW | wxALL, 3);
+
+				// precinct sizer, row
+				wxBoxSizer* precinctSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				precinctSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Precincts size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				precinctSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				precinctSizer->Add(
+					m_prsizeCtrl = new wxTextCtrl(panel, OPJENCO_PRECINCTSIZE,
+								wxGetApp().m_prsize,
+								wxDefaultPosition, wxSize(100, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			codestreamSizer->Add(precinctSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(codestreamSizer, 0, wxGROW | wxALL, 3);
+
+			// tile settings, column
+			wxStaticBox* tileBox = new wxStaticBox(panel, wxID_ANY, wxT("Tiles"));
+			wxBoxSizer* tileSizer = new wxStaticBoxSizer(tileBox, wxVERTICAL);
+
+				// tile size sizer, row
+				wxBoxSizer* tilesizeSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				tilesizeSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Size:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				tilesizeSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				tilesizeSizer->Add(
+					m_tsizeCtrl = new wxTextCtrl(panel, OPJENCO_TILESIZE,
+								wxGetApp().m_tsize,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			tileSizer->Add(tilesizeSizer, 0, wxGROW | wxALL, 3);
+
+				// tile origin sizer, row
+				wxBoxSizer* tilorigSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				tilorigSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Origin:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				tilorigSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				tilorigSizer->Add(
+					m_toriginCtrl = new wxTextCtrl(panel, OPJENCO_TILORIG,
+								wxGetApp().m_torigin,
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			tileSizer->Add(tilorigSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(tileSizer, 0, wxGROW | wxALL, 3);
+
+			// progression and profile settings, column
+			wxString choices[] = {wxT("LRCP"), wxT("RLCP"), wxT("RPCL"), wxT("PCRL"), wxT("CPRL"),
+				wxT("DCI2K24"), wxT("DCI2K48"), wxT("DCI4K")};
+			progressionBox = new wxRadioBox(panel, OPJENCO_PROGRESSION,
+				wxT("Progression order/profile"),
+				wxDefaultPosition, wxDefaultSize,
+				WXSIZEOF(choices),
+				choices,
+				3,
+				wxRA_SPECIFY_COLS);
+			progressionBox->SetSelection(wxGetApp().m_progression);
+
+		subtopSizer->Add(progressionBox, 0, wxGROW | wxALL, 3);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+wxPanel* OPJEncoderDialog::CreatePart1_2SettingsPage(wxWindow* parent)
+{
+    wxPanel* panel = new wxPanel(parent, wxID_ANY);
+
+	// top sizer
+    wxBoxSizer *topSizer = new wxBoxSizer(wxVERTICAL);
+
+	// add some space
+	//topSizer->AddSpacer(5);
+
+		// sub top sizer
+		wxFlexGridSizer *subtopSizer = new wxFlexGridSizer(2, 3, 3);
+			
+			// resilience settings, column
+			wxStaticBox* resilBox = new wxStaticBox(panel, wxID_ANY, wxT("Error resilience"));
+			wxBoxSizer* resilSizer = new wxStaticBoxSizer(resilBox, wxVERTICAL);
+
+				// resil2 sizer, row
+				wxBoxSizer* resil2Sizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// SOP check box
+				resil2Sizer->Add(
+					m_sopCheck = new wxCheckBox(panel, OPJENCO_ENABLESOP, wxT("SOP"),
+						wxDefaultPosition, wxDefaultSize),
+						0, wxGROW | wxALL, 3);
+				m_sopCheck->SetValue(wxGetApp().m_enablesop);
+
+				// EPH check box
+				resil2Sizer->Add(
+					m_ephCheck = new wxCheckBox(panel, OPJENCO_ENABLEEPH, wxT("EPH"),
+						wxDefaultPosition, wxDefaultSize),
+						0, wxGROW | wxALL, 3);
+				m_ephCheck->SetValue(wxGetApp().m_enableeph);
+
+			resilSizer->Add(resil2Sizer, 0, wxGROW | wxALL, 3);
+
+			// separation
+			resilSizer->Add(new wxStaticLine(panel, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 3);
+
+				// resil3 sizer, row
+				wxFlexGridSizer* resil3Sizer = new wxFlexGridSizer(3, 3, 3);
+
+				// BYPASS check box
+				resil3Sizer->Add(
+					m_enablebypassCheck = new wxCheckBox(panel, OPJENCO_ENABLEBYPASS, wxT("BYPASS"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablebypassCheck->SetValue(wxGetApp().m_enablebypass);
+
+				// RESET check box
+				resil3Sizer->Add(
+					m_enableresetCheck = new wxCheckBox(panel, OPJENCO_ENABLERESET, wxT("RESET"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enableresetCheck->SetValue(wxGetApp().m_enablereset);
+
+				// RESTART check box
+				resil3Sizer->Add(
+					m_enablerestartCheck = new wxCheckBox(panel, OPJENCO_ENABLERESTART, wxT("RESTART"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablerestartCheck->SetValue(wxGetApp().m_enablerestart);
+
+				// VSC check box
+				resil3Sizer->Add(
+					m_enablevscCheck = new wxCheckBox(panel, OPJENCO_ENABLEVSC, wxT("VSC"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablevscCheck->SetValue(wxGetApp().m_enablevsc);
+
+				// ERTERM check box
+				resil3Sizer->Add(
+					m_enableertermCheck = new wxCheckBox(panel, OPJENCO_ENABLEERTERM, wxT("ERTERM"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enableertermCheck->SetValue(wxGetApp().m_enableerterm);
+
+				// SEGMARK check box
+				resil3Sizer->Add(
+					m_enablesegmarkCheck = new wxCheckBox(panel, OPJENCO_ENABLESEGMARK, wxT("SEGMARK"),
+					wxDefaultPosition, wxDefaultSize),
+					0, wxGROW | wxALL, 3);
+				m_enablesegmarkCheck->SetValue(wxGetApp().m_enablesegmark);
+
+			resilSizer->Add(resil3Sizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(resilSizer, 0, wxGROW | wxALL, 3);
+
+			// ROI settings, column
+			wxStaticBox* roiBox = new wxStaticBox(panel, wxID_ANY, wxT("Region Of Interest"));
+			wxBoxSizer* roiSizer = new wxStaticBoxSizer(roiBox, wxVERTICAL);
+
+				// component number sizer, row
+				wxBoxSizer* roicompSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				roicompSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Component:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				roicompSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				roicompSizer->Add(
+					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROICOMP,
+								wxT("0"),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 256, 0),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			roiSizer->Add(roicompSizer, 0, wxGROW | wxALL, 3);
+
+				// upshift sizer, row
+				wxBoxSizer* roishiftSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				roishiftSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Upshift:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				roishiftSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				roishiftSizer->Add(
+					/*m_layerCtrl =*/ new wxSpinCtrl(panel, OPJENCO_ROISHIFT,
+								wxT("0"),
+								wxDefaultPosition, wxSize(80, wxDefaultCoord),
+								wxSP_ARROW_KEYS,
+								0, 37, 0),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+
+			roiSizer->Add(roishiftSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(roiSizer, 0, wxGROW | wxALL, 3);
+
+			// Index file settings, column
+			wxStaticBox* indexBox = new wxStaticBox(panel, wxID_ANY, wxT("Indexing"));
+			wxBoxSizer* indexSizer = new wxStaticBoxSizer(indexBox, wxVERTICAL);
+
+			// indexing check box
+			indexSizer->Add(
+				m_enableidxCheck = new wxCheckBox(panel, OPJENCO_ENABLEINDEX, wxT("Enabled"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enableidxCheck->SetValue(wxGetApp().m_enableidx);
+
+				// index file sizer, row
+				wxBoxSizer* indexnameSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				indexnameSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&File name:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				indexnameSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				indexnameSizer->Add(
+					m_indexCtrl = new wxTextCtrl(panel, OPJENCO_INDEXNAME,
+								wxGetApp().m_index,
+								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				m_indexCtrl->Enable(wxGetApp().m_enableidx);
+
+			indexSizer->Add(indexnameSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(indexSizer, 0, wxGROW | wxALL, 3);
+
+			// Comment settings, column
+			wxStaticBox* commentBox = new wxStaticBox(panel, wxID_ANY, wxT("Comment"));
+			wxBoxSizer* commentSizer = new wxStaticBoxSizer(commentBox, wxVERTICAL);
+
+			// commenting check box
+			commentSizer->Add(
+				m_enablecommCheck = new wxCheckBox(panel, OPJENCO_ENABLECOMM, wxT("Enabled (empty to reset)"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enablecommCheck->SetValue(wxGetApp().m_enablecomm);
+
+			// add some horizontal space
+			commentSizer->Add(3, 3, 1, wxALL, 0);
+
+			// add the value control
+			commentSizer->Add(
+				m_commentCtrl = new wxTextCtrl(panel, OPJENCO_COMMENTTEXT,
+							wxGetApp().m_comment,
+							wxDefaultPosition, wxSize(wxDefaultCoord, 60),
+							wxTE_LEFT | wxTE_MULTILINE),
+				0, wxGROW | wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+			m_commentCtrl->Enable(wxGetApp().m_enablecomm);
+
+		subtopSizer->Add(commentSizer, 0, wxGROW | wxALL, 3);
+
+			// POC settings, column
+			wxStaticBox* pocBox = new wxStaticBox(panel, wxID_ANY, wxT("POC"));
+			wxBoxSizer* pocSizer = new wxStaticBoxSizer(pocBox, wxVERTICAL);
+
+			// POC check box
+			pocSizer->Add(
+				m_enablepocCheck = new wxCheckBox(panel, OPJENCO_ENABLEPOC, wxT("Enabled"),
+				wxDefaultPosition, wxDefaultSize),
+				0, wxGROW | wxALL, 3);
+			m_enablepocCheck->SetValue(/*wxGetApp().m_enableidx*/true);
+
+				// POC sizer, row
+				wxBoxSizer* pocspecSizer = new wxBoxSizer(wxHORIZONTAL);
+
+				// add some text
+				pocspecSizer->Add(new wxStaticText(panel, wxID_ANY, wxT("&Changes:")),
+								0, wxALL | wxALIGN_CENTER_VERTICAL, 3);
+
+				// add some horizontal space
+				pocspecSizer->Add(3, 3, 1, wxALL, 0);
+
+				// add the value control
+				pocspecSizer->Add(
+					m_pocCtrl = new wxTextCtrl(panel, OPJENCO_POCSPEC,
+								/*wxGetApp().m_index*/wxT("RRRR"),
+								wxDefaultPosition, wxSize(120, wxDefaultCoord),
+								wxTE_LEFT),
+					0, wxALL | wxALIGN_CENTER_HORIZONTAL | wxALIGN_CENTER_VERTICAL, 3);
+				m_pocCtrl->Enable(/*wxGetApp().m_enableidx*/true);
+
+			pocSizer->Add(pocspecSizer, 0, wxGROW | wxALL, 3);
+
+		subtopSizer->Add(pocSizer, 0, wxGROW | wxALL, 3);
+
+	topSizer->Add(subtopSizer, 1, wxGROW | wxALIGN_CENTRE | wxALL, 5);
+
+	// assign top and fit it
+    panel->SetSizer(topSizer);
+    topSizer->Fit(panel);
+
+    return panel;
+}
+
+void OPJEncoderDialog::OnEnableComm(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Comment enabled"));
+		m_commentCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Comment disabled"));
+		m_commentCtrl->Enable(false);
+	}
+
+}
+
+void OPJEncoderDialog::OnEnableIdx(wxCommandEvent& event)
+{
+	if (event.IsChecked()) {
+		wxLogMessage(wxT("Index enabled"));
+		m_indexCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Index disabled"));
+		m_indexCtrl->Enable(false);
+	}
+
+}
+
+void OPJEncoderDialog::OnRadioQualityRate(wxCommandEvent& event)
+{
+	if (event.GetId() == OPJENCO_QUALITYRADIO) {
+		wxLogMessage(wxT("Quality selected"));
+		m_rateCtrl->Enable(false);
+		m_qualityCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("Rate selected"));
+		m_rateCtrl->Enable(true);
+		m_qualityCtrl->Enable(false);
+	}
+}
+
+#ifdef USE_JPWL
+void OPJEncoderDialog::OnEnableJPWL(wxCommandEvent& event)
+{
+	/*if (event.IsChecked()) {
+		wxLogMessage(wxT("JPWL enabled"));
+		m_expcompsCtrl->Enable(true);
+		m_maxtilesCtrl->Enable(true);
+	} else {
+		wxLogMessage(wxT("JPWL disabled"));
+		m_expcompsCtrl->Enable(false);
+		m_maxtilesCtrl->Enable(false);
+	}*/
+
+}
+#endif // USE_JPWL
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/opj_logo.xpm.svn-base ./OPJViewer/source/.svn/text-base/opj_logo.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/opj_logo.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/opj_logo.xpm.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,285 @@
+/* XPM */
+static char *opj_logo[] = {
+/* columns rows colors chars-per-pixel */
+"90 61 218 2",
+"   c #BE3D12",
+".  c #BF461D",
+"X  c #AD5435",
+"o  c #B64925",
+"O  c #B54E2B",
+"+  c #BC4620",
+"@  c #BB4B25",
+"#  c #BC4E29",
+"$  c #B5502F",
+"%  c #BD512C",
+"&  c #B45334",
+"*  c #B35638",
+"=  c #B45B3D",
+"-  c #BB5533",
+";  c #BE5937",
+":  c #BC5C3D",
+">  c #9C766A",
+",  c #AD5D42",
+"<  c #B55F41",
+"1  c #BA5E40",
+"2  c #A7634D",
+"3  c #A76C57",
+"4  c #AA6750",
+"5  c #AC6B56",
+"6  c #AA6E5A",
+"7  c #A4705E",
+"8  c #B46045",
+"9  c #B1644B",
+"0  c #BD6244",
+"q  c #B96448",
+"w  c #BC694D",
+"e  c #B36B53",
+"r  c #B26E58",
+"t  c #BB6C52",
+"y  c #B2725D",
+"u  c #BD7056",
+"i  c #BB745C",
+"p  c #A67566",
+"a  c #A57B6D",
+"s  c #AE7562",
+"d  c #AB7867",
+"f  c #AA7C6C",
+"g  c #A07E73",
+"h  c #AA7F71",
+"j  c #B37661",
+"k  c #B47863",
+"l  c #B27D6B",
+"z  c #BB7863",
+"x  c #BA7E69",
+"c  c #C73605",
+"v  c #C63A0B",
+"b  c #CB3300",
+"n  c #CA3807",
+"m  c #C93A0A",
+"M  c #C43E11",
+"N  c #C93E10",
+"B  c #C44115",
+"V  c #C3441A",
+"C  c #C4481E",
+"Z  c #CA4113",
+"A  c #C94519",
+"S  c #CB481C",
+"D  c #C24A23",
+"F  c #C24F28",
+"G  c #CD4D23",
+"H  c #C4522D",
+"J  c #CB532B",
+"K  c #C25632",
+"L  c #C35936",
+"P  c #C25C3B",
+"I  c #C85630",
+"U  c #CB5933",
+"Y  c #CB5E3A",
+"T  c #D05026",
+"R  c #CC613D",
+"E  c #C26343",
+"W  c #C46748",
+"Q  c #C1694C",
+"!  c #CD6744",
+"~  c #CA6C4D",
+"^  c #C37155",
+"/  c #C4755B",
+"(  c #CB7356",
+")  c #C8765B",
+"_  c #D06D4C",
+"`  c #D07253",
+"'  c #D47B5E",
+"]  c #C37B63",
+"[  c #C27E68",
+"{  c #C97F68",
+"}  c #A68175",
+"|  c #A48479",
+" . c #AD8172",
+".. c #AD8578",
+"X. c #AB897D",
+"o. c #B1806F",
+"O. c #BA816F",
+"+. c #B38373",
+"@. c #B58778",
+"#. c #B3897B",
+"$. c #BA8472",
+"%. c #BB8C7C",
+"&. c #C2816B",
+"*. c #CD846C",
+"=. c #C38470",
+"-. c #C38976",
+";. c #C38D7B",
+":. c #CC8973",
+">. c #CF8F7A",
+",. c #CB907D",
+"<. c #D1937F",
+"1. c #948E8C",
+"2. c #9D8C86",
+"3. c #9D8F89",
+"4. c #96908E",
+"5. c #9C918D",
+"6. c #949392",
+"7. c #9B9492",
+"8. c #9D9997",
+"9. c #9D9C9C",
+"0. c #A38B83",
+"q. c #AA8D83",
+"w. c #A4918B",
+"e. c #AC9087",
+"r. c #AB938C",
+"t. c #A49590",
+"y. c #A29996",
+"u. c #A19D9C",
+"i. c #AA9790",
+"p. c #AC9994",
+"a. c #AC9E99",
+"s. c #B18D81",
+"d. c #B59084",
+"f. c #B49389",
+"g. c #BA9184",
+"h. c #B89589",
+"j. c #BA988D",
+"k. c #B29B93",
+"l. c #BC9C92",
+"z. c #ACA19D",
+"x. c #B1A19D",
+"c. c #BCA39B",
+"v. c #A3A3A3",
+"b. c #ABA5A3",
+"n. c #AEA9A7",
+"m. c #ABABAA",
+"M. c #B3A5A1",
+"N. c #B3A9A6",
+"B. c #B3ADAA",
+"V. c #B9A6A0",
+"C. c #B9AAA5",
+"Z. c #BAADA9",
+"A. c #B4B0AF",
+"S. c #BAB0AD",
+"D. c #B4B3B3",
+"F. c #BAB5B3",
+"G. c #BDB8B6",
+"H. c #BBBBBB",
+"J. c #C39384",
+"K. c #C0978A",
+"L. c #C2998B",
+"P. c #CA9483",
+"I. c #CD9A8A",
+"U. c #C19D92",
+"Y. c #D69B89",
+"T. c #DB9680",
+"R. c #C2A095",
+"E. c #C4A69C",
+"W. c #CCA193",
+"Q. c #C8A599",
+"!. c #CBA99D",
+"~. c #C6AEA6",
+"^. c #CCACA2",
+"/. c #CBB2AB",
+"(. c #C3B8B5",
+"). c #C2BDBC",
+"_. c #C9B9B3",
+"`. c #D3ADA0",
+"'. c #D3B4A9",
+"]. c #DCB2A4",
+"[. c #DEB6A8",
+"{. c #D1BFB9",
+"}. c #D9BEB5",
+"|. c #C5C0BE",
+" X c #CDC0BC",
+".X c #D2C1BB",
+"XX c #DDC3BB",
+"oX c #E0C5BC",
+"OX c #E0C8BF",
+"+X c #C2C2C2",
+"@X c #CBC4C2",
+"#X c #CDC8C6",
+"$X c #CCCBCB",
+"%X c #D2C6C2",
+"&X c #D1CECD",
+"*X c #DDC8C1",
+"=X c #DECFCA",
+"-X c #D9D1CE",
+";X c #D3D3D3",
+":X c #D9D5D4",
+">X c #DED9D7",
+",X c #DBDBDB",
+"<X c #E1CAC3",
+"1X c #E2CFC8",
+"2X c #E1D3CE",
+"3X c #E2D5D0",
+"4X c #E5D8D3",
+"5X c #E4DDDB",
+"6X c #E8DBD6",
+"7X c #EADEDA",
+"8X c #E6E0DE",
+"9X c #EBE0DC",
+"0X c #E4E4E4",
+"qX c #E8E2E0",
+"wX c #EBEBEB",
+"eX c #F0EAE8",
+"rX c #F3F3F3",
+"tX c #FEFEFE",
+/* pixels */
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXrXrXtXrXrXrXrXrXrXrXtXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXrXtXrXrXrXwXwXrXwXrXrXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXrXrXrXwXwX0X0XqX0X0X0X0XwXwXwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXrXtXrXwXwX2X[.[.].].].].].1XwXrXwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXrXrXrXwX0X0XL.J b b b b b b b J '.0X0XwXwXrXrXrXrXrXrXrXrXrXrXtXrXrXrXtXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXtXtXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXrXrXwX0XXXt m b m B V N b b v >.;X0XwXwXwXwXrXwXwXrXrXrXrXtXrXtXrXrXrXwXrXrXrXrXrXrXrXrXrXrXrXwXrXrXwXrXrXrXtXtXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXrXrXrX0X,X'.S b b P l.z.M.k.w n b b g.;X,X,X,X0X0X0X0X0XwXwXwXwXwXwXwXwXwX0X0X0XwX0X0XwXwXwXwX0X0X0X0X0X0XwXwXwXwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXrXrXwX0X:XT.m b A ] G.D.D.m.$.m b b $.$X&X.X}.XX>XOX}.oXXX<X0X0XwXwXwX0X2XXXoXXXoXOX5X0XwX0X1XoXXX5X*X}.}.oX<XqXrXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXrXwX0X,XL.b b D M.H.D.D.D.D.m.L b b W H.Z.# b Y / m b b b Z P.:X:X:X$X:.Z b b b b n :.;X;X;XR b A &.Z b b b b *.wXwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXrXwX0X:X$.b b E B.H.H.D.D.D.D.P b b E H.V.. b U L v v n b b ( #X;X$X~.Y b m N m b b ! {.&X#XI b C R v v n b b ! 0XwXrXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXwX0X:X!.A b Z F.H.H.H.H.H.D.m.L b b e b.+.b b V k i.r.t n b b s.H.x v b L q.b.p.D b b t F.$.n b M l a.M.y b b A :X0XwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXwX0X:XL.m b D H.).H.+XH.H.H.D.H b b 6 v.j b b - a.A.m.@.m b b h D.< b b w z.b.b.P b b q B.z b b @ B.D.m...v b G :X,XwXwXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwX0X,X&X/ b b , D.H.+X+X+X+XH.f.B b b 5.8.M b M w.v.v.v.r.D b b h l v b b M     V v b b q u.X b n @.v.m.v.j b b Q &X,X0XwXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwX0X,X$X^ b b , H.H.+X+XH.H.H.s.N b n 7.7.v b B 8.v.v.v.w.M b b g r b b b n n n b b b b e y.O b n X.m.v.n.e b b u &X,X0XrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrX0X,X$X/ b b + F.H.H.H.+XH.d.b b M | 8.> c b @ 9.v.9.u., b b - 3.& b b 7 1.1.4.4.4.6.7.9.w.m b + t.v.m.p.D b b K.;X,X0XwXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwX0X,X$X-.b b b i D.H.G.H.J.N b b = 9.9.5 c b B 7.9.v.y.b b m f 4.O b b 3 6.6.6.g 9 4 h u.h b b - b.m.m.s.b b N ~.;X,X0XwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwX0X,X;XE.G b b I z ] ] ] W n b H l 9.8.9 b b m e 6 r e b b # 0.y.< b b O 6 p 6 < # ; q.v.t b b 0 n.A.A.+.b b H _.;X,XwXwXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwXwX,X;X#Xf.b b b b b b b b b - a.v.v.w.@ b b v b b b b b @ b.m.v.w.M b b b b b b v ..m.n.A b n g.H.H.H.4 b b [ &X,X0XwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXwXwX0X:X$XZ.Q H v n b m B H E x n.m.m.q.B b v < . v N + E z m.m.m.b.e - M m v M - t k.D.m.; # - V.H.+XH.s # # K.:X,X0XwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXwXwX,X,X$X+XG.Z.Z.B.C.S.F.H.H.H.D.D.j b b q v.b.a.n.B.H.H.+X+X+XH.H.D.Z.C.Z.Z.F.H.H.+X+XH.).H.$X&X&X;X$X#X#X:X,X0XwXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXrXwX0X,X;X#X+X+X+XH.H.+X+X+XH.H.H.D.e b n i n.m.D.H.H.+X#X$X$X+X+X+X+XH.H.H.H.+X+X+X$X&X&X&X$X;X;X;X:X;X:X,X,X0XwXwXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXrXrXwXwX,X,X;X;X$X$X$X;X;X&X;X$X#X+XF b v s.H.H.+X$X&X;X;X,X,X,X;X:X;X;X;X;X;X;X:X,X,X,X0X,X0X,X0X0X0X0X0X0X0XwXwXrXtXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXrXtXrXwXwX0X,X:X;X;X;X;X;X:X;X;X;X$X+XC b B k.+X+X$X$X;X,X,X0X0X0X0X0X;X,X,X,X,X,X,X,X,X0X0X0X0X0X0XwX0X0X0XwXwXrXrXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXrXrXrXrXwXwXwX0X0X0X0X0X0X0X,X,X:X^.^.!.$X$X;X,X,X0XwXwXwXwXwXwXwXwX0X0X0X0XwXwXwXwXwXwXrXrXwXrXrXrXrXrXrXrXrXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXrXrXrXrXwXwXwXwX0XwXwXwX0X0X,X:X;X$X&X&X;X,X,X0XwXwXwXrXrXrXrXrXwXwXwXwXwXwXwXrXrXrXwXrXrXrXrXrXrXrXrXrXrXtXrXtXtXrXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXrXrXrXrXrXrXrXrXrXwXwXwXwX0X,X0X0X0XwXwXrXrXrXrXrXrXrXrXrXrXrXrXrXrXwXrXrXrXrXrXtXrXrXrXtXrXrXrXrXrXrXrXrXrXtXtXtXrXrXtXtXtXtXrXrXtXrXrXtXrXtXrXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXrXtXtXrXtXrXrXrXrXrXrXwXwXwX0XwX0XwXwXwXrXrXrXtXtXrXrXrXrXrXrXrXrXwXrXwXrXwXwXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXrXtXrXrXtXtXrXrXrXrXrXrXrXrXrXrXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXwXrXrXrXrXrXrXtXrXtXrXrXrXrXrXwXwXwXwXwX0X0XwX0XwXwXwXwXwXwXwXrXwXwXwX0X0X0X0XwX0XwXwXrXrXrXwXrXwXwXwX0XwX0XwXwXwXrXrXrXrXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrXrXrXrXrXtXtXrXrXtXrXrXeX7X7X9XwXwXwX5X3X3X3X2X2X2X5X0XwXwXwXwXwX8X3X3X2X2X2X2X2X3X6X6X7XwXwXwXwXwXwX7X1XXXOXOX1X8XwXwXrXrXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXtXtXrXrXrXwXT.T T :.,X,X-X` G G G G G G U _ J.-X,X,X,X[ G G G G G G G G G G _ >XwX0X,X&XI.R N b b b m ! `.5XwXrXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXtXtXrXtXrXrXrXwX0X' b b ] >X,X%XJ b b b b b b b b Q {.:X;X:Xq b b b b b b b b b b Y >X0X,X-X'.^ n b b b b b m *.1XwXwXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrX0X0X%XL b b L.@X+X-.b b M L L L D b b b M V.+X(.N b b D H H H H H U U W.;X&X^.H b b n W -.-.W n b b J &XwXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXwXwX0X XF b b U.+X+X[ b b D z z j P v b b N U.H.S.m b m E Q t ^ ) / ) ) /.$X$X;.m b n A %.H.H.J.N b b N .XwXwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXwXwX,X:X!.m b L N.D.m.* b b y v.v.v.v.p.n b M f.m.w b b D u.v.m.m.D.G.H.H.+X).g.b b B j.F.D.D.D.D.l.; F I /.0XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXwX,X:XU.n b E B.A.n.$ b b s v.9.v.v.r.n n M r.b.1 b b D u.v.m.m.D.D.H.H.).H.k b b # M.G.D.D.D.D.Z.t w u _.0XwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXwXwX,X;X$XJ b m h b.v.i.m b M a 5.5.2.p M b c < 8.2.+ b b M o o o o # % j G.H.g.m b A M.D.D.D.B.M.M.M.M.Z.(.:X0XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrXrXwX,X,X&X(.n b M 0.v.v.s b b b b b n b b c b M u.v.g M b b b b b b b b b i G.D.0 b b 8 D.D.H.G.P n b b n b U :X,XwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrXwX0X,X;X$XV.n b M w.v.9.< b b b b b b b b c H r 9.v.a n b   * < < w w Q Q g.D.B.: b b r D.D.D.m.C b b b b b ) ;X0XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrX6XP.=.K.;X#X+Xx n b D v.u.7.. b b M D . D & 2 q.b.b.v.v.< b b X 6.9.9.b.m.D.D.D.D.n.# b b f D.D.D.b.= 1 * N b n !.;X,XwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXrXrXwX<X~ P x $X+XH.z b b - v.v.3.M b b < r r r k 0.a.m.m.m.v.# b b , 6.9.v.m.D.D.D.H.D.z.O b b s D.D.D.N.f l 9 v b M ~.;X,XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXrXwX0XY.n b e H.H.V.F b b p b.v.h v b v v.m.A.D.H.+X+X+XH.D.p.b b m p 9.v.m.D.D.H.H.H.D.N.- b b - m.A.D.A.m.a.B b b - (.:X0XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXwXwX0XY.n b ; Z.C.$.A b v 0.m.m.l n b M m.D.D.H.+X#X+X+XH.H.r.b b m < d l l l $.;.J.V.H.B.w b b C @.s.a.k.#.j n b b : ).:X,XwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXwXwX0X'.N b b A B n b n z m.D.B.0 b b 9 H.H.+X$X;X:X;X$X$X+Xl b b b b b b b b b b b s.H.H.B.H b b b n Z Z b b V n b ] $X:X0XwXrXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXwX0X,X.XR b b b b b A P d.D.D.C.H b b j H.$X$X;X:X,X,X;X;X+X/ b b b b b b b b b b b a.H.H.D.u G b b b b b B H : v m ;.$X,XwXwXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXwXwX,X:X Xg.j 5 y s.C.H.H.+X+X|.E.Q.Q. X;X;X,X0XwXwX0X0X,X;X/.U.j.h.g.f.h.j.U.U.U.!.$X$X+X+XH.Z.g.y 4 6 l x.D.A.l.~.#X,X0XwXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXwX0X:X$XG.k.e.f.B.H.H.+X$X$X$X#X$X$X;X;X,X0XwXwXwXwX0X0X;X$X+XH.D.D.D.F.H.+X+X#X&X$X;X$X$X+X+XA.r.X.e.a.H.H.H.+X+X;X,X0XwXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXwX,X,X$X&X$X$X$X$X;X;X,X,X,X,X,X,X0XwXwXwXrXtXrXrXwXwX0X,X;X$X$X+X$X$X$X;X;X:X,X,X,X,X,X;X$X&X#X#X$X$X$X$X$X;X,X,X0XwXrXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXwXwX0X,X:X;X;X$X;X;X:X,X,X0X0X,X0X0X0XwXwXwXrXrXtXrXrXwXwX0X;X;X$X&X$X$X&X:X,X,X,X,X0X,X,X:X;X;X$X$X$X$X$X;X:X,X,X0XwXwXrXrXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXrXwXwXwX0X0X0X0X0X0XwXwXwXwXwXwXwXwXrXwXrXtXtXrXtXtXrXrXrXwX0X0X0X0X,X,X0X0X0X0XwXwXwXwXwXwX0X0X0X,X,X,X,X0X0XwXwXwXrXtXrXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrXwXwX0X0X0X0X0XwXwXwXrXwXrXrXrXrXrXtXrXtXtXtXtXrXrXrXwXwXwX0X0X0X0X0X0X0XwXwXwXwXwXwXwXwXwX0X0X0X0XwXwXwXwXwXrXrXrXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXrXrXrXrXrXrXrXrXrXrXtXtXrXtXtXrXtXtXtXtXtXtXtXrXtXrXtXrXrXrXrXwXwXrXrXrXrXrXrXrXtXrXrXrXrXrXrXrXwXrXrXrXrXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXrXtXrXrXrXrXrXrXtXtXrXtXrXtXrXrXtXtXtXtXtXtXtXtXtXtXtXrXrXrXrXrXrXrXrXrXrXrXtXtXrXtXrXrXtXrXrXrXrXrXrXrXrXtXrXrXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX",
+"tXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtXtX"
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer16.xpm.svn-base ./OPJViewer/source/.svn/text-base/OPJViewer16.xpm.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer16.xpm.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJViewer16.xpm.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,26 @@
+/* XPM */
+static char *OPJViewer16[] = {
+/* columns rows colors chars-per-pixel */
+"16 16 4 1",
+"  c black",
+". c #800000",
+"X c red",
+"o c None",
+/* pixels */
+"oooooooooooooooo",
+"ooo.XXXXoooooooo",
+"ooXXoo .Xooooooo",
+"o..oooo .ooooooo",
+"oX.oooo  ooooooo",
+"oX.oooo .ooooooo",
+"oXXoooo .ooooooo",
+"o.XXoo .oooooooo",
+"oo.XXXXooooooooo",
+"ooooooooo.Xo .oo",
+"ooooooooo X. ooo",
+"oooooooooo...ooo",
+"oooooooooo XXooo",
+"oooooooooo .Xooo",
+"oooooooooooooooo",
+"oooooooooooooooo"
+};
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.cpp.svn-base ./OPJViewer/source/.svn/text-base/OPJViewer.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJViewer.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,2770 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Universita' degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        sashtest.cpp
+// Purpose:     Layout/sash sample
+// Author:      Julian Smart
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: sashtest.cpp,v 1.18 2005/08/23 15:54:35 ABX Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        treetest.cpp
+// Purpose:     wxTreeCtrl sample
+// Author:      Julian Smart
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: treetest.cpp,v 1.110 2006/11/04 11:26:51 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dialogs.cpp
+// Purpose:     Common dialogs demo
+// Author:      Julian Smart
+// Modified by: ABX (2004) - adjustements for conditional building + new menu
+// Created:     04/01/98
+// RCS-ID:      $Id: dialogs.cpp,v 1.163 2006/11/04 10:57:24 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        thread.cpp
+// Purpose:     wxWidgets thread sample
+// Author:      Guilhem Lavaux, Vadim Zeitlin
+// Modified by:
+// Created:     06/16/98
+// RCS-ID:      $Id: thread.cpp,v 1.26 2006/10/02 05:36:28 PC Exp $
+// Copyright:   (c) 1998-2002 wxWidgets team
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+///////////////////////////////////////////////////////////////////////////////
+// Name:        samples/image/image.cpp
+// Purpose:     sample showing operations with wxImage
+// Author:      Robert Roebling
+// Modified by:
+// Created:     1998
+// RCS-ID:      $Id: image.cpp,v 1.120 2006/12/06 17:13:11 VZ Exp $
+// Copyright:   (c) 1998-2005 Robert Roebling
+// License:     wxWindows licence
+///////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/console/console.cpp
+// Purpose:     A sample console (as opposed to GUI) program using wxWidgets
+// Author:      Vadim Zeitlin
+// Modified by:
+// Created:     04.10.99
+// RCS-ID:      $Id: console.cpp,v 1.206 2006/11/12 19:55:19 VZ Exp $
+// Copyright:   (c) 1999 Vadim Zeitlin <zeitlin@dptmaths.ens-cachan.fr>
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        samples/notebook/notebook.cpp
+// Purpose:     a sample demonstrating notebook usage
+// Author:      Julian Smart
+// Modified by: Dimitri Schoolwerth
+// Created:     26/10/98
+// RCS-ID:      $Id: notebook.cpp,v 1.49 2006/11/04 18:24:07 RR Exp $
+// Copyright:   (c) 1998-2002 wxWidgets team
+// License:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dialogs.cpp
+// Purpose:     Common dialogs demo
+// Author:      Julian Smart
+// Modified by: ABX (2004) - adjustements for conditional building + new menu
+// Created:     04/01/98
+// RCS-ID:      $Id: dialogs.cpp,v 1.163 2006/11/04 10:57:24 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dnd.cpp
+// Purpose:     Drag and drop sample
+// Author:      Vadim Zeitlin
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: dnd.cpp,v 1.107 2006/10/30 20:23:41 VZ Exp $
+// Copyright:
+// Licence:     wxWindows licence
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        test.cpp
+// Purpose:     wxHtml testing example
+/////////////////////////////////////////////////////////////////////////////
+
+
+#include "OPJViewer.h"
+
+IMPLEMENT_APP(OPJViewerApp)
+
+// For drawing lines in a canvas
+long xpos = -1;
+long ypos = -1;
+
+int winNumber = 1;
+
+// Initialise this in OnInit, not statically
+bool OPJViewerApp::OnInit(void)
+{
+#if wxUSE_UNICODE
+
+    wxChar **wxArgv = new wxChar *[argc + 1];
+
+	int n;
+    for (n = 0; n < argc; n++ ) {
+        wxMB2WXbuf warg = wxConvertMB2WX((char *) argv[n]);
+        wxArgv[n] = wxStrdup(warg);
+    }
+
+    wxArgv[n] = NULL;
+
+#else // !wxUSE_UNICODE
+
+    #define wxArgv argv
+
+#endif // wxUSE_UNICODE/!wxUSE_UNICODE
+
+#if wxUSE_CMDLINE_PARSER
+
+    static const wxCmdLineEntryDesc cmdLineDesc[] =
+    {
+        { wxCMD_LINE_SWITCH, _T("h"), _T("help"), _T("show this help message"),
+            wxCMD_LINE_VAL_NONE, wxCMD_LINE_OPTION_HELP },
+
+        { wxCMD_LINE_PARAM,  NULL, NULL, _T("input file"),
+            wxCMD_LINE_VAL_STRING, wxCMD_LINE_PARAM_OPTIONAL | wxCMD_LINE_PARAM_MULTIPLE },
+
+        { wxCMD_LINE_NONE }
+    };
+
+    wxCmdLineParser parser(cmdLineDesc, argc, wxArgv);
+
+    /*parser.AddOption(_T("project_name"), _T(""), _T("full path to project file"),
+                     wxCMD_LINE_VAL_STRING,
+                     wxCMD_LINE_OPTION_MANDATORY | wxCMD_LINE_NEEDS_SEPARATOR);*/
+
+    switch (parser.Parse()) {
+    case -1:
+        wxLogMessage(wxT("Help was given, terminating."));
+        break;
+
+    case 0:
+        ShowCmdLine(parser);
+        break;
+
+    default:
+        wxLogMessage(wxT("Syntax error detected."));
+        break;
+    }
+
+#endif // wxUSE_CMDLINE_PARSER
+
+    //wxInitAllImageHandlers();
+#if wxUSE_LIBJPEG
+  wxImage::AddHandler( new wxJPEGHandler );
+#endif
+#if wxUSE_LIBOPENJPEG
+  wxImage::AddHandler( new wxJ2KHandler );
+  wxImage::AddHandler( new wxJP2Handler );
+  wxImage::AddHandler( new wxMJ2Handler );
+#endif
+#if OPJ_MANYFORMATS
+  wxImage::AddHandler( new wxBMPHandler );
+  wxImage::AddHandler( new wxPNGHandler );
+  wxImage::AddHandler( new wxGIFHandler );
+  wxImage::AddHandler( new wxPNMHandler );
+  wxImage::AddHandler( new wxTIFFHandler );
+#endif
+    // we use a XPM image in our HTML page
+    wxImage::AddHandler(new wxXPMHandler);
+
+	// memory file system
+    wxFileSystem::AddHandler(new wxMemoryFSHandler);
+
+#ifdef OPJ_INICONFIG
+	//load decoding engine parameters
+	OPJconfig = new wxConfig(OPJ_APPLICATION, OPJ_APPLICATION_VENDOR);
+
+	OPJconfig->Read(wxT("enabledeco"), &m_enabledeco, (bool) true);
+	OPJconfig->Read(wxT("enableparse"), &m_enableparse, (bool) true);
+	OPJconfig->Read(wxT("resizemethod"), &m_resizemethod, (long) 0);
+	OPJconfig->Read(wxT("xxxreducefactor"), &m_reducefactor, (long) 0);
+	OPJconfig->Read(wxT("xxxqualitylayers"), &m_qualitylayers, (long) 0);
+	OPJconfig->Read(wxT("xxxcomponents"), &m_components, (long) 0);
+	OPJconfig->Read(wxT("xxxframenum"), &m_framenum, (long) 0);
+#ifdef USE_JPWL
+	OPJconfig->Read(wxT("enablejpwl"), &m_enablejpwl, (bool) true);
+	OPJconfig->Read(wxT("expcomps"), &m_expcomps, (long) JPWL_EXPECTED_COMPONENTS);
+	OPJconfig->Read(wxT("maxtiles"), &m_maxtiles, (long) JPWL_MAXIMUM_TILES);
+#endif // USE_JPWL
+
+	OPJconfig->Write(wxT("teststring"), wxT("This is a test value"));
+	OPJconfig->Write(wxT("testbool"), (bool) true);
+	OPJconfig->Write(wxT("testlong"), (long) 245);
+
+	OPJconfig->Read(wxT("showtoolbar"), &m_showtoolbar, (bool) true);
+	OPJconfig->Read(wxT("showbrowser"), &m_showbrowser, (bool) true);
+	OPJconfig->Read(wxT("showpeeker"), &m_showpeeker, (bool) true);
+	OPJconfig->Read(wxT("browserwidth"), &m_browserwidth, (long) OPJ_BROWSER_WIDTH);
+	OPJconfig->Read(wxT("peekerheight"), &m_peekerheight, (long) OPJ_PEEKER_HEIGHT);
+	OPJconfig->Read(wxT("framewidth"), &m_framewidth, (long) OPJ_FRAME_WIDTH);
+	OPJconfig->Read(wxT("frameheight"), &m_frameheight, (long) OPJ_FRAME_HEIGHT);
+
+	// load encoding engine parameters
+	OPJconfig->Read(wxT("subsampling"), &m_subsampling, (wxString) wxT("1,1"));
+	OPJconfig->Read(wxT("origin"), &m_origin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("rates"), &m_rates, (wxString) wxT("20,10,5"));
+	OPJconfig->Read(wxT("quality"), &m_quality, (wxString) wxT("30,35,40"));
+	OPJconfig->Read(wxT("enablequality"), &m_enablequality, (bool) false);
+	OPJconfig->Read(wxT("multicomp"), &m_multicomp, (bool) false);	
+	OPJconfig->Read(wxT("irreversible"), &m_irreversible, (bool) false);	
+	OPJconfig->Read(wxT("resolutions"), &m_resolutions, (int) 6);	
+	OPJconfig->Read(wxT("progression"), &m_progression, (int) 0);	
+	OPJconfig->Read(wxT("cbsize"), &m_cbsize, (wxString) wxT("32,32"));
+	OPJconfig->Read(wxT("prsize"), &m_prsize, (wxString) wxT("[128,128],[128,128]"));
+	OPJconfig->Read(wxT("tsize"), &m_tsize, (wxString) wxT(""));
+	OPJconfig->Read(wxT("torigin"), &m_torigin, (wxString) wxT("0,0"));
+	OPJconfig->Read(wxT("enablesop"), &m_enablesop, (bool) false);	
+	OPJconfig->Read(wxT("enableeph"), &m_enableeph, (bool) false);	
+	OPJconfig->Read(wxT("enablebypass"), &m_enablebypass, (bool) false);	
+	OPJconfig->Read(wxT("enablereset"), &m_enablereset, (bool) false);	
+	OPJconfig->Read(wxT("enablerestart"), &m_enablerestart, (bool) false);	
+	OPJconfig->Read(wxT("enablevsc"), &m_enablevsc, (bool) false);	
+	OPJconfig->Read(wxT("enableerterm"), &m_enableerterm, (bool) false);	
+	OPJconfig->Read(wxT("enablesegmark"), &m_enablesegmark, (bool) false);	
+	OPJconfig->Read(wxT("enablecomm"), &m_enablecomm, (bool) true);	
+	OPJconfig->Read(wxT("comment"), &m_comment, (wxString) wxT(""));
+	OPJconfig->Read(wxT("enableidx"), &m_enableidx, (bool) false);	
+	OPJconfig->Read(wxT("index"), &m_index, (wxString) wxT("index.txt"));
+
+#else
+	// set decoding engine parameters
+	m_enabledeco = true;
+	m_enableparse = true;
+	m_resizemethod = 0;
+	m_reducefactor = 0;
+	m_qualitylayers = 0;
+	m_components = 0;
+	m_framenum = 0;
+#ifdef USE_JPWL
+	m_enablejpwl = true;
+	m_expcomps = JPWL_EXPECTED_COMPONENTS;
+	m_maxtiles = JPWL_MAXIMUM_TILES;
+#endif // USE_JPWL
+	m_showtoolbar = true;
+	m_showbrowser = true;
+	m_showpeeker = true;
+	m_browserwidth = OPJ_BROWSER_WIDTH;
+	m_peekerheight = OPJ_PEEKER_HEIGHT;
+	m_framewidth = OPJ_FRAME_WIDTH;
+	m_frameheight = OPJ_FRAME_HEIGHT;
+
+	// set encoding engine parameters
+	m_subsampling = wxT("1,1");
+	m_origin = wxT("0,0");
+	m_rates = wxT("20,10,5");
+	m_quality = wxT("30,35,40");
+	m_enablequality = false;
+	m_multicomp = false;
+	m_irreversible = false;
+	m_resolutions = 6;
+	m_progression = 0;
+	m_cbsize= wxT("32,32");
+	m_prsize= wxT("[128,128],[128,128]");
+	m_tsize = wxT("");
+	m_torigin = wxT("0,0");
+	m_enablesop = false;
+	m_enableeph = false;
+	m_enablebypass = false;
+	m_enablereset = false;
+	m_enablerestart = false;
+	m_enablevsc = false;
+	m_enableerterm = false;
+	m_enablesegmark = false;
+	m_enableidx = false;
+	m_index = wxT("index.txt");
+	m_enablecomm = true;
+	m_comment = wxT("");
+
+#endif // OPJ_INICONFIG
+
+	if (m_comment == wxT("")) {
+#if defined __WXMSW__
+		m_comment = wxT("Created by OPJViewer Win32 - OpenJPEG  version ");
+#elif defined __WXGTK__
+		m_comment = wxT("Created by OPJViewer Lin32 - OpenJPEG version ");
+#else
+		m_comment = wxT("Created by OPJViewer - OpenJPEG version ");
+#endif
+
+#ifdef USE_JPWL
+		m_comment += wxString::Format(wxT("%s with JPWL"), (char *) opj_version());
+#else
+		m_comment += wxString::Format(wxT("%s"), (char *) opj_version());
+#endif
+	}
+
+	// Create the main frame window
+  OPJFrame *frame = new OPJFrame(NULL, wxID_ANY, OPJ_APPLICATION_TITLEBAR,
+					  wxDefaultPosition, wxSize(wxGetApp().m_framewidth, wxGetApp().m_frameheight),
+                      wxDEFAULT_FRAME_STYLE | wxNO_FULL_REPAINT_ON_RESIZE |
+                      wxHSCROLL | wxVSCROLL);
+
+  // Give it an icon (this is ignored in MDI mode: uses resources)
+#ifdef __WXMSW__
+  frame->SetIcon(wxIcon(wxT("OPJViewer16")));
+#endif
+
+  frame->Show(true);
+
+  SetTopWindow(frame);
+
+	// if there are files on the command line, open them
+	if (!(m_filelist.IsEmpty())) {
+		//wxLogMessage(wxT("Habemus files!!!"));
+		wxArrayString paths, filenames;
+		for (unsigned int f = 0; f < wxGetApp().m_filelist.GetCount(); f++) {
+			paths.Add(wxFileName(wxGetApp().m_filelist[f]).GetFullPath());
+			filenames.Add(wxFileName(wxGetApp().m_filelist[f]).GetFullName());
+		}
+		//wxLogMessage(paths[0]);
+		frame->OpenFiles(paths, filenames);
+	}
+
+  return true;
+}
+
+int OPJViewerApp::OnExit()
+{
+#ifdef OPJ_INICONFIG
+	OPJconfig->Write(wxT("enabledeco"), m_enabledeco);
+	OPJconfig->Write(wxT("enableparse"), m_enableparse);
+	OPJconfig->Write(wxT("resizemethod"), m_resizemethod);
+	OPJconfig->Write(wxT("reducefactor"), m_reducefactor);
+	OPJconfig->Write(wxT("qualitylayers"), m_qualitylayers);
+	OPJconfig->Write(wxT("components"), m_components);
+	OPJconfig->Write(wxT("framenum"), m_framenum);
+#ifdef USE_JPWL
+	OPJconfig->Write(wxT("enablejpwl"), m_enablejpwl);
+	OPJconfig->Write(wxT("expcomps"), m_expcomps);
+	OPJconfig->Write(wxT("maxtiles"), m_maxtiles);
+#endif // USE_JPWL
+	OPJconfig->Write(wxT("showtoolbar"), m_showtoolbar);
+	OPJconfig->Write(wxT("showbrowser"), m_showbrowser);
+	OPJconfig->Write(wxT("showpeeker"), m_showpeeker);
+	OPJconfig->Write(wxT("browserwidth"), m_browserwidth);
+	OPJconfig->Write(wxT("peekerheight"), m_peekerheight);
+	OPJconfig->Write(wxT("framewidth"), m_framewidth);
+	OPJconfig->Write(wxT("frameheight"), m_frameheight);
+
+	OPJconfig->Write(wxT("subsampling"), m_subsampling);
+	OPJconfig->Write(wxT("origin"), m_origin);
+	OPJconfig->Write(wxT("rates"), m_rates);
+	OPJconfig->Write(wxT("quality"), m_quality);
+	OPJconfig->Write(wxT("enablequality"), m_enablequality);
+	OPJconfig->Write(wxT("multicomp"), m_multicomp);
+	OPJconfig->Write(wxT("irreversible"), m_irreversible);
+	OPJconfig->Write(wxT("resolutions"), m_resolutions);
+	OPJconfig->Write(wxT("progression"), m_progression);
+	OPJconfig->Write(wxT("cbsize"), m_cbsize);
+	OPJconfig->Write(wxT("prsize"), m_prsize);
+	OPJconfig->Write(wxT("tiles"), m_tsize);
+	OPJconfig->Write(wxT("torigin"), m_torigin);
+	OPJconfig->Write(wxT("enablesop"), m_enablesop);
+	OPJconfig->Write(wxT("enableeph"), m_enableeph);
+	OPJconfig->Write(wxT("enablebypass"), m_enablebypass);
+	OPJconfig->Write(wxT("enablereset"), m_enablereset);
+	OPJconfig->Write(wxT("enablerestart"), m_enablerestart);
+	OPJconfig->Write(wxT("enablevsc"), m_enablevsc);
+	OPJconfig->Write(wxT("enableerterm"), m_enableerterm);
+	OPJconfig->Write(wxT("enablesegmark"), m_enablesegmark);
+	OPJconfig->Write(wxT("enableidx"), m_enableidx);
+	OPJconfig->Write(wxT("index"), m_index);
+	OPJconfig->Write(wxT("enablecomm"), m_enablecomm);
+	OPJconfig->Write(wxT("comment"), m_comment);
+
+#endif // OPJ_INICONFIG
+
+	return 1;
+}
+
+void OPJViewerApp::ShowCmdLine(const wxCmdLineParser& parser)
+{
+    wxString s = wxT("Command line parsed successfully:\nInput files: ");
+
+    size_t count = parser.GetParamCount();
+    for (size_t param = 0; param < count; param++) {
+        s << parser.GetParam(param) << ';';
+		m_filelist.Add(parser.GetParam(param));
+    }
+
+    //wxLogMessage(s);
+}
+
+// OPJFrame events
+BEGIN_EVENT_TABLE(OPJFrame, wxMDIParentFrame)
+    EVT_MENU(OPJFRAME_HELPABOUT, OPJFrame::OnAbout)
+    EVT_MENU(OPJFRAME_FILEOPEN, OPJFrame::OnFileOpen)
+    EVT_MENU(OPJFRAME_FILESAVEAS, OPJFrame::OnFileSaveAs)
+    EVT_MENU(OPJFRAME_MEMORYOPEN, OPJFrame::OnMemoryOpen)
+    EVT_SIZE(OPJFrame::OnSize)
+    EVT_MENU(OPJFRAME_FILEEXIT, OPJFrame::OnQuit)
+    EVT_MENU(OPJFRAME_FILECLOSE, OPJFrame::OnClose)
+    EVT_MENU(OPJFRAME_VIEWZOOM, OPJFrame::OnZoom)
+    EVT_MENU(OPJFRAME_VIEWFIT, OPJFrame::OnFit)
+    EVT_MENU(OPJFRAME_VIEWRELOAD, OPJFrame::OnReload)
+    EVT_MENU(OPJFRAME_VIEWPREVFRAME, OPJFrame::OnPrevFrame)
+    EVT_MENU(OPJFRAME_VIEWHOMEFRAME, OPJFrame::OnHomeFrame)
+    EVT_MENU(OPJFRAME_VIEWNEXTFRAME, OPJFrame::OnNextFrame)
+    EVT_MENU(OPJFRAME_VIEWLESSLAYERS, OPJFrame::OnLessLayers)
+    EVT_MENU(OPJFRAME_VIEWALLLAYERS, OPJFrame::OnAllLayers)
+    EVT_MENU(OPJFRAME_VIEWMORELAYERS, OPJFrame::OnMoreLayers)
+    EVT_MENU(OPJFRAME_VIEWLESSRES, OPJFrame::OnLessRes)
+    EVT_MENU(OPJFRAME_VIEWFULLRES, OPJFrame::OnFullRes)
+    EVT_MENU(OPJFRAME_VIEWMORERES, OPJFrame::OnMoreRes)
+    EVT_MENU(OPJFRAME_VIEWPREVCOMP, OPJFrame::OnPrevComp)
+    EVT_MENU(OPJFRAME_VIEWALLCOMPS, OPJFrame::OnAllComps)
+    EVT_MENU(OPJFRAME_VIEWNEXTCOMP, OPJFrame::OnNextComp)
+    EVT_MENU(OPJFRAME_FILETOGGLEB, OPJFrame::OnToggleBrowser)
+    EVT_MENU(OPJFRAME_FILETOGGLEP, OPJFrame::OnTogglePeeker)
+    EVT_MENU(OPJFRAME_FILETOGGLET, OPJFrame::OnToggleToolbar)
+    EVT_MENU(OPJFRAME_SETSENCO, OPJFrame::OnSetsEnco)
+    EVT_MENU(OPJFRAME_SETSDECO, OPJFrame::OnSetsDeco)
+    EVT_SASH_DRAGGED_RANGE(OPJFRAME_BROWSEWIN, OPJFRAME_LOGWIN, OPJFrame::OnSashDrag)
+    EVT_NOTEBOOK_PAGE_CHANGED(LEFT_NOTEBOOK_ID, OPJFrame::OnNotebook)
+END_EVENT_TABLE()
+
+// this is the frame constructor
+OPJFrame::OPJFrame(wxWindow *parent, const wxWindowID id, const wxString& title,
+				   const wxPoint& pos, const wxSize& size, const long style)
+		: wxMDIParentFrame(parent, id, title, pos, size, style)
+{
+	// file menu and its items
+	wxMenu *file_menu = new wxMenu;
+
+	file_menu->Append(OPJFRAME_FILEOPEN, wxT("&Open\tCtrl+O"));
+	file_menu->SetHelpString(OPJFRAME_FILEOPEN, wxT("Open one or more files"));
+
+	file_menu->Append(OPJFRAME_MEMORYOPEN, wxT("&Memory\tCtrl+M"));
+	file_menu->SetHelpString(OPJFRAME_MEMORYOPEN, wxT("Open a memory buffer"));
+
+	file_menu->Append(OPJFRAME_FILECLOSE, wxT("&Close\tCtrl+C"));
+	file_menu->SetHelpString(OPJFRAME_FILECLOSE, wxT("Close current image"));
+
+	file_menu->AppendSeparator();
+
+	file_menu->Append(OPJFRAME_FILESAVEAS, wxT("&Save as\tCtrl+S"));
+	file_menu->SetHelpString(OPJFRAME_FILESAVEAS, wxT("Save the current image"));
+	//file_menu->Enable(OPJFRAME_FILESAVEAS, false);
+
+	file_menu->AppendSeparator();
+
+	file_menu->Append(OPJFRAME_FILETOGGLEB, wxT("Toggle &browser\tCtrl+B"));
+	file_menu->SetHelpString(OPJFRAME_FILETOGGLEB, wxT("Toggle the left browsing pane"));
+
+	file_menu->Append(OPJFRAME_FILETOGGLEP, wxT("Toggle &peeker\tCtrl+P"));
+	file_menu->SetHelpString(OPJFRAME_FILETOGGLEP, wxT("Toggle the bottom peeking pane"));
+
+	file_menu->Append(OPJFRAME_FILETOGGLET, wxT("Toggle &toolbar\tCtrl+T"));
+	file_menu->SetHelpString(OPJFRAME_FILETOGGLET, wxT("Toggle the toolbar"));
+
+	file_menu->AppendSeparator();
+
+	file_menu->Append(OPJFRAME_FILEEXIT, wxT("&Exit\tCtrl+Q"));
+	file_menu->SetHelpString(OPJFRAME_FILEEXIT, wxT("Quit this program"));
+
+	// view menu and its items
+	wxMenu *view_menu = new wxMenu;
+
+	view_menu->Append(OPJFRAME_VIEWZOOM, wxT("&Zoom\tCtrl+Z"));
+	view_menu->SetHelpString(OPJFRAME_VIEWZOOM, wxT("Rescale the image"));
+
+	view_menu->Append(OPJFRAME_VIEWFIT, wxT("Zoom to &fit\tCtrl+F"));
+	view_menu->SetHelpString(OPJFRAME_VIEWFIT, wxT("Fit the image in canvas"));
+
+	view_menu->Append(OPJFRAME_VIEWRELOAD, wxT("&Reload image\tCtrl+R"));
+	view_menu->SetHelpString(OPJFRAME_VIEWRELOAD, wxT("Reload the current image"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVFRAME, wxT("&Prev frame\tLeft"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVFRAME, wxT("View previous frame"));
+
+	view_menu->Append(OPJFRAME_VIEWHOMEFRAME, wxT("&Start frame\tHome"));
+	view_menu->SetHelpString(OPJFRAME_VIEWHOMEFRAME, wxT("View starting frame"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTFRAME, wxT("&Next frame\tRight"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTFRAME, wxT("View next frame"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSLAYERS, wxT("&Less layers\t-"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSLAYERS, wxT("Remove a layer"));
+
+	view_menu->Append(OPJFRAME_VIEWALLLAYERS, wxT("&All layers\t0"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLLAYERS, wxT("Show all layers"));
+
+	view_menu->Append(OPJFRAME_VIEWMORELAYERS, wxT("&More layers\t+"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORELAYERS, wxT("Add a layer"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWLESSRES, wxT("&Less resolution\t<"));
+	view_menu->SetHelpString(OPJFRAME_VIEWLESSRES, wxT("Reduce the resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWFULLRES, wxT("&Full resolution\tf"));
+	view_menu->SetHelpString(OPJFRAME_VIEWFULLRES, wxT("Full resolution"));
+
+	view_menu->Append(OPJFRAME_VIEWMORERES, wxT("&More resolution\t>"));
+	view_menu->SetHelpString(OPJFRAME_VIEWMORERES, wxT("Increase the resolution"));
+
+	view_menu->AppendSeparator();
+
+	view_menu->Append(OPJFRAME_VIEWPREVCOMP, wxT("&Prev component\tDown"));
+	view_menu->SetHelpString(OPJFRAME_VIEWPREVCOMP, wxT("View previous component"));
+
+	view_menu->Append(OPJFRAME_VIEWALLCOMPS, wxT("&All components\ta"));
+	view_menu->SetHelpString(OPJFRAME_VIEWALLCOMPS, wxT("View all components"));
+
+	view_menu->Append(OPJFRAME_VIEWNEXTCOMP, wxT("&Next component\tUp"));
+	view_menu->SetHelpString(OPJFRAME_VIEWNEXTCOMP, wxT("View next component"));
+
+
+	// settings menu and its items
+	wxMenu *sets_menu = new wxMenu;
+
+	sets_menu->Append(OPJFRAME_SETSENCO, wxT("&Encoder\tCtrl+E"));
+	sets_menu->SetHelpString(OPJFRAME_SETSENCO, wxT("Encoder settings"));
+
+	sets_menu->Append(OPJFRAME_SETSDECO, wxT("&Decoder\tCtrl+D"));
+	sets_menu->SetHelpString(OPJFRAME_SETSDECO, wxT("Decoder settings"));
+
+	// help menu and its items
+	wxMenu *help_menu = new wxMenu;
+
+	help_menu->Append(OPJFRAME_HELPABOUT, wxT("&About\tF1"));
+	help_menu->SetHelpString(OPJFRAME_HELPABOUT, wxT("Basic info on the program"));
+
+	// the whole menubar
+	wxMenuBar *menu_bar = new wxMenuBar;
+	menu_bar->Append(file_menu, wxT("&File"));
+	menu_bar->Append(view_menu, wxT("&View"));
+	menu_bar->Append(sets_menu, wxT("&Settings"));
+	menu_bar->Append(help_menu, wxT("&Help"));
+
+	// Associate the menu bar with the frame
+	SetMenuBar(menu_bar);
+
+	// the status bar
+	CreateStatusBar();
+
+	// the toolbar
+	tool_bar = new wxToolBar(this, OPJFRAME_TOOLBAR,
+								wxDefaultPosition, wxDefaultSize,
+								wxTB_HORIZONTAL | wxNO_BORDER);
+	wxBitmap bmpOpen = wxArtProvider::GetBitmap(wxART_FILE_OPEN, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpSaveAs = wxArtProvider::GetBitmap(wxART_FILE_SAVE_AS, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpZoom = wxArtProvider::GetBitmap(wxART_FIND, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpFit = wxArtProvider::GetBitmap(wxART_FIND_AND_REPLACE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpReload = wxArtProvider::GetBitmap(wxART_EXECUTABLE_FILE, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpDecosettings = wxArtProvider::GetBitmap(wxART_REPORT_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpEncosettings = wxArtProvider::GetBitmap(wxART_LIST_VIEW, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpPrevframe = wxArtProvider::GetBitmap(wxART_GO_BACK, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpHomeframe = wxArtProvider::GetBitmap(wxART_GO_HOME, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextframe = wxArtProvider::GetBitmap(wxART_GO_FORWARD, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpLesslayers = bmpPrevframe;
+	wxBitmap bmpAlllayers = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMorelayers = bmpNextframe;
+	wxBitmap bmpLessres = bmpPrevframe;
+	wxBitmap bmpFullres = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpMoreres = bmpNextframe;
+	wxBitmap bmpPrevcomp = bmpPrevframe;
+	wxBitmap bmpAllcomps = wxArtProvider::GetBitmap(wxART_GO_TO_PARENT, wxART_TOOLBAR,
+												wxDefaultSize);
+	wxBitmap bmpNextcomp = bmpNextframe;
+
+	tool_bar->AddTool(OPJFRAME_FILEOPEN, bmpOpen, wxT("Open"));
+	tool_bar->AddTool(OPJFRAME_FILESAVEAS, bmpSaveAs, wxT("Save as "));
+	//tool_bar->EnableTool(OPJFRAME_FILESAVEAS, false);
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWZOOM, bmpZoom, wxT("Zoom"));
+	tool_bar->AddTool(OPJFRAME_VIEWFIT, bmpFit, wxT("Zoom to fit"));
+	tool_bar->AddTool(OPJFRAME_VIEWRELOAD, bmpReload, wxT("Reload"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_SETSDECO, bmpDecosettings, wxT("Decoder settings"));
+	tool_bar->AddTool(OPJFRAME_SETSENCO, bmpEncosettings, wxT("Encoder settings"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVFRAME, bmpPrevframe, wxT("Previous frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWHOMEFRAME, bmpHomeframe, wxT("Starting frame"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTFRAME, bmpNextframe, wxT("Next frame"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSLAYERS, bmpLesslayers, wxT("Remove a layer"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLLAYERS, bmpAlllayers, wxT("Show all layers"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORELAYERS, bmpMorelayers, wxT("Add a layer"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWLESSRES, bmpLessres, wxT("Reduce the resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWFULLRES, bmpFullres, wxT("Full resolution"));
+	tool_bar->AddTool(OPJFRAME_VIEWMORERES, bmpMoreres, wxT("Increase the resolution"));
+	tool_bar->AddSeparator();
+	tool_bar->AddTool(OPJFRAME_VIEWPREVCOMP, bmpPrevcomp, wxT("Previous component"));
+	tool_bar->AddTool(OPJFRAME_VIEWALLCOMPS, bmpAllcomps, wxT("All components"));
+	tool_bar->AddTool(OPJFRAME_VIEWNEXTCOMP, bmpNextcomp, wxT("Next component"));
+	tool_bar->Realize();
+	
+	// associate the toolbar with the frame
+	SetToolBar(tool_bar);
+
+	// show the toolbar?
+	if (!wxGetApp().m_showtoolbar)
+		tool_bar->Show(false);
+	else
+		tool_bar->Show(true);
+
+	// the logging window
+	loggingWindow = new wxSashLayoutWindow(this, OPJFRAME_LOGWIN,
+											wxDefaultPosition, wxSize(400, wxGetApp().m_peekerheight),
+											wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
+											);
+	loggingWindow->SetDefaultSize(wxSize(1000, wxGetApp().m_peekerheight));
+	loggingWindow->SetOrientation(wxLAYOUT_HORIZONTAL);
+	loggingWindow->SetAlignment(wxLAYOUT_BOTTOM);
+	//loggingWindow->SetBackgroundColour(wxColour(0, 0, 255));
+	loggingWindow->SetSashVisible(wxSASH_TOP, true);
+
+	// show the logging?
+	if (!wxGetApp().m_showpeeker)
+		loggingWindow->Show(false);
+	else
+		loggingWindow->Show(true);
+
+	// create the bottom notebook
+	m_bookCtrlbottom = new wxNotebook(loggingWindow, BOTTOM_NOTEBOOK_ID,
+								wxDefaultPosition, wxDefaultSize,
+								wxBK_LEFT);
+
+	// create the text control of the logger
+	m_textCtrl = new wxTextCtrl(m_bookCtrlbottom, wxID_ANY, wxT(""),
+								wxDefaultPosition, wxDefaultSize,
+								wxTE_MULTILINE | wxSUNKEN_BORDER | wxTE_READONLY
+								);
+	m_textCtrl->SetValue(_T("Logging window\n"));
+
+	// add it to the notebook
+	m_bookCtrlbottom->AddPage(m_textCtrl, wxT("Log"));
+
+	// create the text control of the browser
+	m_textCtrlbrowse = new wxTextCtrl(m_bookCtrlbottom, wxID_ANY, wxT(""),
+								wxDefaultPosition, wxDefaultSize,
+								wxTE_MULTILINE | wxSUNKEN_BORDER | wxTE_READONLY | wxTE_RICH
+								);
+	wxFont *browsefont = new wxFont(wxNORMAL_FONT->GetPointSize(),
+		wxFONTFAMILY_TELETYPE, wxFONTSTYLE_NORMAL, wxFONTWEIGHT_NORMAL);
+    m_textCtrlbrowse->SetDefaultStyle(wxTextAttr(wxNullColour, wxNullColour, *browsefont));
+	m_textCtrlbrowse->AppendText(wxT("Browsing window\n"));
+
+	// add it the notebook
+	m_bookCtrlbottom->AddPage(m_textCtrlbrowse, wxT("Peek"), false);
+
+	// the browser window
+	markerTreeWindow = new wxSashLayoutWindow(this, OPJFRAME_BROWSEWIN,
+											  wxDefaultPosition, wxSize(wxGetApp().m_browserwidth, 30),
+											  wxNO_BORDER | wxSW_3D | wxCLIP_CHILDREN
+											  );
+	markerTreeWindow->SetDefaultSize(wxSize(wxGetApp().m_browserwidth, 1000));
+	markerTreeWindow->SetOrientation(wxLAYOUT_VERTICAL);
+	markerTreeWindow->SetAlignment(wxLAYOUT_LEFT);
+	//markerTreeWindow->SetBackgroundColour(wxColour(0, 255, 0));
+	markerTreeWindow->SetSashVisible(wxSASH_RIGHT, true);
+	markerTreeWindow->SetExtraBorderSize(0);
+
+	// create the browser notebook
+	m_bookCtrl = new wxNotebook(markerTreeWindow, LEFT_NOTEBOOK_ID,
+								wxDefaultPosition, wxDefaultSize,
+								wxBK_TOP);
+
+	// show the browser?
+	if (!wxGetApp().m_showbrowser)
+		markerTreeWindow->Show(false);
+	else
+		markerTreeWindow->Show(true);
+
+#ifdef __WXMOTIF__
+	// For some reason, we get a memcpy crash in wxLogStream::DoLogStream
+	// on gcc/wxMotif, if we use wxLogTextCtl. Maybe it's just gcc?
+	delete wxLog::SetActiveTarget(new wxLogStderr);
+#else
+	// set our text control as the log target
+	wxLogTextCtrl *logWindow = new wxLogTextCtrl(m_textCtrl);
+	delete wxLog::SetActiveTarget(logWindow);
+#endif
+
+	// associate drop targets with the controls
+	SetDropTarget(new OPJDnDFile(this));
+
+}
+
+// this is the frame destructor
+OPJFrame::~OPJFrame(void)
+{
+	// save size settings
+	GetSize(&(wxGetApp().m_framewidth), &(wxGetApp().m_frameheight));
+
+	// delete all possible things
+	delete m_bookCtrl;
+	m_bookCtrl = NULL;
+
+	delete markerTreeWindow;
+	markerTreeWindow = NULL;
+
+	delete m_textCtrl;
+	m_textCtrl = NULL;
+
+	delete m_bookCtrlbottom;
+	m_bookCtrlbottom = NULL;
+
+	delete loggingWindow;
+	loggingWindow = NULL;
+}
+
+void OPJFrame::OnNotebook(wxNotebookEvent& event)
+{
+	int sel = event.GetSelection();
+	long childnum;
+
+	m_bookCtrl->GetPageText(sel).ToLong(&childnum);
+
+	if (m_childhash[childnum])
+		m_childhash[childnum]->Activate();
+
+	//wxLogMessage(wxT("Selection changed (now %d --> %d)"), childnum, m_childhash[childnum]->m_winnumber);
+
+}
+
+
+void OPJFrame::Resize(int number)
+{
+	wxSize size = GetClientSize();
+}
+
+void OPJFrame::OnSetsEnco(wxCommandEvent& event)
+{
+    OPJEncoderDialog dialog(this, event.GetId());
+
+    if (dialog.ShowModal() == wxID_OK) {
+
+		// load settings
+		wxGetApp().m_subsampling = dialog.m_subsamplingCtrl->GetValue();
+		wxGetApp().m_origin = dialog.m_originCtrl->GetValue();
+		wxGetApp().m_rates = dialog.m_rateCtrl->GetValue();
+		wxGetApp().m_quality = dialog.m_qualityCtrl->GetValue();
+		wxGetApp().m_enablequality = dialog.m_qualityRadio->GetValue();
+		wxGetApp().m_multicomp = dialog.m_mctCheck->GetValue();
+		wxGetApp().m_irreversible = dialog.m_irrevCheck->GetValue();
+		wxGetApp().m_resolutions = dialog.m_resolutionsCtrl->GetValue();
+		wxGetApp().m_cbsize = dialog.m_cbsizeCtrl->GetValue();
+		wxGetApp().m_prsize = dialog.m_prsizeCtrl->GetValue();
+		wxGetApp().m_tsize = dialog.m_tsizeCtrl->GetValue();
+		wxGetApp().m_torigin = dialog.m_toriginCtrl->GetValue();
+		wxGetApp().m_progression = dialog.progressionBox->GetSelection();
+		wxGetApp().m_enablesop = dialog.m_sopCheck->GetValue();
+		wxGetApp().m_enableeph = dialog.m_ephCheck->GetValue();
+		wxGetApp().m_enablebypass = dialog.m_enablebypassCheck->GetValue();
+		wxGetApp().m_enablereset = dialog.m_enableresetCheck->GetValue();
+		wxGetApp().m_enablerestart = dialog.m_enablerestartCheck->GetValue();
+		wxGetApp().m_enablevsc = dialog.m_enablevscCheck->GetValue();
+		wxGetApp().m_enableerterm = dialog.m_enableertermCheck->GetValue();
+		wxGetApp().m_enablesegmark = dialog.m_enablesegmarkCheck->GetValue();
+		wxGetApp().m_enableidx = dialog.m_enableidxCheck->GetValue();
+		wxGetApp().m_index = dialog.m_indexCtrl->GetValue();
+		wxGetApp().m_enablecomm = dialog.m_enablecommCheck->GetValue();
+		wxGetApp().m_comment = dialog.m_commentCtrl->GetValue();
+	};
+}
+
+void OPJFrame::OnSetsDeco(wxCommandEvent& event)
+{
+    OPJDecoderDialog dialog(this, event.GetId());
+
+    if (dialog.ShowModal() == wxID_OK) {
+
+		// load settings
+		wxGetApp().m_enabledeco = dialog.m_enabledecoCheck->GetValue();
+		wxGetApp().m_enableparse = dialog.m_enableparseCheck->GetValue();
+		wxGetApp().m_resizemethod = dialog.m_resizeBox->GetSelection() - 1;
+		wxGetApp().m_reducefactor = dialog.m_reduceCtrl->GetValue();
+		wxGetApp().m_qualitylayers = dialog.m_layerCtrl->GetValue();
+		wxGetApp().m_components = dialog.m_numcompsCtrl->GetValue();
+		wxGetApp().m_framenum = dialog.m_framenumCtrl->GetValue();
+#ifdef USE_JPWL
+		wxGetApp().m_enablejpwl = dialog.m_enablejpwlCheck->GetValue();
+		wxGetApp().m_expcomps = dialog.m_expcompsCtrl->GetValue();
+		wxGetApp().m_maxtiles = dialog.m_maxtilesCtrl->GetValue();
+#endif // USE_JPWL
+
+	};
+}
+
+void OPJFrame::OnQuit(wxCommandEvent& WXUNUSED(event))
+{
+	Close(true);
+}
+
+void OPJFrame::OnClose(wxCommandEvent& WXUNUSED(event))
+{
+	// current frame
+	OPJChildFrame *currframe = (OPJChildFrame *) GetActiveChild();
+
+	if (!currframe)
+		return;
+
+	wxCloseEvent e;
+	currframe->OnClose(e);
+}
+
+void OPJFrame::OnFit(wxCommandEvent& WXUNUSED(event))
+{
+	// current child
+	OPJChildFrame *currchild = (OPJChildFrame *) GetActiveChild();
+	if (!currchild)
+		return;
+
+	// current canvas
+	OPJCanvas *currcanvas = currchild->m_canvas;
+
+	// find a fit-to-width zoom
+	int zooml, wzooml, hzooml;
+	wxSize clientsize = currcanvas->GetClientSize();
+	wzooml = (int) ceil(100.0 * (double) (clientsize.GetWidth() - 2 * OPJ_CANVAS_BORDER) / (double) (currcanvas->m_image100.GetWidth()));
+	hzooml = (int) ceil(100.0 * (double) (clientsize.GetHeight() - 2 * OPJ_CANVAS_BORDER) / (double) (currcanvas->m_image100.GetHeight()));
+	zooml = wxMin(100, wxMin(wzooml, hzooml));
+
+	// fit to width
+	Rescale(zooml, currchild);
+}
+
+void OPJFrame::OnZoom(wxCommandEvent& WXUNUSED(event))
+{
+	// current frame
+	OPJChildFrame *currframe = (OPJChildFrame *) GetActiveChild();
+
+	if (!currframe)
+		return;
+
+	// get the preferred zoom
+	long zooml = wxGetNumberFromUser(wxT("Choose a scale between 5% and 300%"),
+		wxT("Zoom (%)"),
+		wxT("Image scale"),
+		currframe->m_canvas->m_zooml, 5, 300, NULL, wxDefaultPosition);
+
+	// rescale current frame image if necessary
+	if (zooml >= 5) {
+		Rescale(zooml, currframe);
+		wxLogMessage(wxT("zoom to %d%%"), zooml);
+	}
+}
+
+void OPJFrame::Rescale(int zooml, OPJChildFrame *currframe)
+{
+	wxImage new_image = currframe->m_canvas->m_image100.ConvertToImage();
+
+	// resizing enabled?
+	if (wxGetApp().m_resizemethod == -1) {
+		zooml = 100;
+	}
+
+	if (zooml != 100)
+		new_image.Rescale((int) ((double) zooml * (double) new_image.GetWidth() / 100.0),
+			(int) ((double) zooml * (double) new_image.GetHeight() / 100.0),
+			wxGetApp().m_resizemethod ? wxIMAGE_QUALITY_HIGH : wxIMAGE_QUALITY_NORMAL);
+	currframe->m_canvas->m_image = wxBitmap(new_image);
+	currframe->m_canvas->SetScrollbars(20,
+										20,
+										(int)(0.5 + (double) new_image.GetWidth() / 20.0),
+										(int)(0.5 + (double) new_image.GetHeight() / 20.0)
+										);
+
+	currframe->m_canvas->Refresh();
+
+	// update zoom
+	currframe->m_canvas->m_zooml = zooml;
+}
+
+
+void OPJFrame::OnReload(wxCommandEvent& event)
+{
+	OPJChildFrame *currframe = (OPJChildFrame *) GetActiveChild();
+
+	if (currframe) {
+		OPJDecoThread *dthread = currframe->m_canvas->CreateDecoThread();
+
+		if (dthread->Run() != wxTHREAD_NO_ERROR)
+			wxLogMessage(wxT("Can't start deco thread!"));
+		else
+			wxLogMessage(wxT("New deco thread started."));
+
+		currframe->m_canvas->Refresh();
+
+		// update zoom
+		//currframe->m_canvas->m_zooml = zooml;
+	}
+}
+
+void OPJFrame::OnPrevFrame(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_framenum < 0)
+		wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnHomeFrame(wxCommandEvent& event)
+{
+	wxGetApp().m_framenum = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnNextFrame(wxCommandEvent& event)
+{
+	++wxGetApp().m_framenum;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnLessLayers(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_qualitylayers < 1)
+		wxGetApp().m_qualitylayers = 1;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnAllLayers(wxCommandEvent& event)
+{
+	wxGetApp().m_qualitylayers = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnMoreLayers(wxCommandEvent& event)
+{
+	++wxGetApp().m_qualitylayers;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnLessRes(wxCommandEvent& event)
+{
+	++wxGetApp().m_reducefactor;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnFullRes(wxCommandEvent& event)
+{
+	wxGetApp().m_reducefactor = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnMoreRes(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_reducefactor < 0)
+		wxGetApp().m_reducefactor = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnPrevComp(wxCommandEvent& event)
+{
+	if (--wxGetApp().m_components < 1)
+		wxGetApp().m_components = 1;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnAllComps(wxCommandEvent& event)
+{
+	wxGetApp().m_components = 0;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+void OPJFrame::OnNextComp(wxCommandEvent& event)
+{
+	++wxGetApp().m_components;
+
+	wxCommandEvent e;
+	OnReload(e);
+}
+
+// about window for the frame
+void OPJFrame::OnAbout(wxCommandEvent& WXUNUSED(event))
+{
+#ifdef OPJ_HTMLABOUT
+#include "about_htm.h"
+#include "opj_logo.xpm"
+
+    wxBoxSizer *topsizer;
+    wxHtmlWindow *html;
+    wxDialog dlg(this, wxID_ANY, wxString(_("About")));
+
+    wxMemoryFSHandler::AddFile(wxT("opj_logo.xpm"), wxBitmap(opj_logo), wxBITMAP_TYPE_XPM);
+
+    topsizer = new wxBoxSizer(wxVERTICAL);
+
+    html = new wxHtmlWindow(&dlg, wxID_ANY, wxDefaultPosition, wxSize(320, 250), wxHW_SCROLLBAR_NEVER);
+    html->SetBorders(0);
+    //html->LoadPage(wxT("about/about.htm"));
+	//html->SetPage("<html><body>Hello, world!</body></html>");
+	html->SetPage(htmlaboutpage);
+    html->SetSize(html->GetInternalRepresentation()->GetWidth(),
+                    html->GetInternalRepresentation()->GetHeight());
+
+    topsizer->Add(html, 1, wxALL, 10);
+
+    topsizer->Add(new wxStaticLine(&dlg, wxID_ANY), 0, wxEXPAND | wxLEFT | wxRIGHT, 10);
+
+    wxButton *bu1 = new wxButton(&dlg, wxID_OK, wxT("OK"));
+    bu1->SetDefault();
+
+    topsizer->Add(bu1, 0, wxALL | wxALIGN_RIGHT, 15);
+
+    dlg.SetSizer(topsizer);
+    topsizer->Fit(&dlg);
+
+    dlg.ShowModal();
+
+#else
+
+	wxMessageBox(wxString::Format(OPJ_APPLICATION_TITLEBAR
+								  wxT("\n\n")
+								  wxT("Built with %s and OpenJPEG ")
+								  wxT(OPENJPEG_VERSION)
+								  wxT("\non ") wxT(__DATE__) wxT(", ") wxT(__TIME__)
+								  wxT("\nRunning under %s\n\n")
+								  OPJ_APPLICATION_COPYRIGHT,
+								  wxVERSION_STRING,
+								  wxGetOsDescription().c_str()),
+				 wxT("About ") OPJ_APPLICATION_NAME,
+				 wxOK | wxICON_INFORMATION,
+				 this
+				 );
+
+#endif
+
+}
+
+void OPJFrame::OnToggleBrowser(wxCommandEvent& WXUNUSED(event))
+{
+    if (markerTreeWindow->IsShown())
+        markerTreeWindow->Show(false);
+    else
+        markerTreeWindow->Show(true);
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showbrowser = markerTreeWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+}
+
+void OPJFrame::OnTogglePeeker(wxCommandEvent& WXUNUSED(event))
+{
+    if (loggingWindow->IsShown())
+        loggingWindow->Show(false);
+    else
+        loggingWindow->Show(true);
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showpeeker = loggingWindow->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+}
+
+void OPJFrame::OnToggleToolbar(wxCommandEvent& WXUNUSED(event))
+{
+    if (tool_bar->IsShown())
+        tool_bar->Show(false);
+    else
+        tool_bar->Show(true);
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+	wxGetApp().m_showtoolbar = tool_bar->IsShown();
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+}
+
+void OPJFrame::OnSashDrag(wxSashEvent& event)
+{
+	int wid, hei;
+
+    if (event.GetDragStatus() == wxSASH_STATUS_OUT_OF_RANGE)
+        return;
+
+    switch (event.GetId()) {
+		case OPJFRAME_BROWSEWIN:
+		{
+			markerTreeWindow->SetDefaultSize(wxSize(event.GetDragRect().width, 1000));
+			break;
+		}
+		case OPJFRAME_LOGWIN:
+		{
+			loggingWindow->SetDefaultSize(wxSize(1000, event.GetDragRect().height));
+			break;
+		}
+    }
+
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+
+    // Leaves bits of itself behind sometimes
+    GetClientWindow()->Refresh();
+
+	// update dimensions
+	markerTreeWindow->GetSize(&wid, &hei);
+	wxGetApp().m_browserwidth = wid;
+
+	loggingWindow->GetSize(&wid, &hei);
+	wxGetApp().m_peekerheight = hei;
+
+}
+
+// physically save the file
+void OPJFrame::SaveFile(wxArrayString paths, wxArrayString filenames)
+{
+	size_t count = paths.GetCount();
+	wxString msg, s;
+
+	if (wxFile::Exists(paths[0].c_str())) {
+
+		s.Printf(wxT("File %s already exists. Do you want to overwrite it?\n"), filenames[0].c_str());
+		wxMessageDialog dialog3(this, s, _T("File exists"), wxYES_NO);
+		if (dialog3.ShowModal() == wxID_NO)
+			return;
+	}
+
+	/*s.Printf(_T("File %d: %s (%s)\n"), (int)0, paths[0].c_str(), filenames[0].c_str());
+	msg += s;
+
+	wxMessageDialog dialog2(this, msg, _T("Selected files"));
+	dialog2.ShowModal();*/
+
+	if (!GetActiveChild())
+		return;
+
+	((OPJChildFrame *) GetActiveChild())->m_canvas->m_savename = paths[0];
+
+	OPJEncoThread *ethread = ((OPJChildFrame *) GetActiveChild())->m_canvas->CreateEncoThread();
+
+    if (ethread->Run() != wxTHREAD_NO_ERROR)
+        wxLogMessage(wxT("Can't start enco thread!"));
+    else
+		wxLogMessage(wxT("New enco thread started."));
+
+
+}
+
+// physically open the files
+void OPJFrame::OpenFiles(wxArrayString paths, wxArrayString filenames)
+{
+
+	size_t count = paths.GetCount();
+	for (size_t n = 0; n < count; n++) {
+
+		wxString msg, s;
+		s.Printf(_T("File %d: %s (%s)\n"), (int)n, paths[n].c_str(), filenames[n].c_str());
+
+		msg += s;
+
+		/*wxMessageDialog dialog2(this, msg, _T("Selected files"));
+		dialog2.ShowModal();*/
+
+		// Make another frame, containing a canvas
+		OPJChildFrame *subframe = new OPJChildFrame(this,
+													paths[n],
+													winNumber,
+													wxT("Canvas Frame"),
+													wxDefaultPosition, wxSize(300, 300),
+													wxDEFAULT_FRAME_STYLE | wxNO_FULL_REPAINT_ON_RESIZE
+													);
+		m_childhash[winNumber] = subframe;
+
+		// create own marker tree
+		m_treehash[winNumber] = new OPJMarkerTree(m_bookCtrl, subframe, paths[n], wxT("Parsing..."), TreeTest_Ctrl,
+												  wxDefaultPosition, wxDefaultSize,
+												  wxTR_DEFAULT_STYLE | wxSUNKEN_BORDER
+												  );
+
+		m_bookCtrl->AddPage(m_treehash[winNumber], wxString::Format(wxT("%u"), winNumber), false);
+
+		for (unsigned int p = 0; p < m_bookCtrl->GetPageCount(); p++) {
+			if (m_bookCtrl->GetPageText(p) == wxString::Format(wxT("%u"), winNumber)) {
+				m_bookCtrl->ChangeSelection(p);
+				break;
+			}
+		}
+
+		winNumber++;
+	}
+}
+
+void OPJFrame::OnFileOpen(wxCommandEvent& WXUNUSED(event))
+{
+    wxString wildcards =
+#ifdef __WXMOTIF__
+	wxT("JPEG 2000 files (*.jp2,*.j2k,*.j2c,*.mj2)|*.*j*2*");
+#else
+#if wxUSE_LIBOPENJPEG
+	wxT("JPEG 2000 files (*.jp2,*.j2k,*.j2c,*.mj2)|*.jp2;*.j2k;*.j2c;*.mj2")
+#endif
+#if wxUSE_LIBJPEG
+		wxT("|JPEG files (*.jpg)|*.jpg")
+#endif
+#if OPJ_MANYFORMATS
+		wxT("|BMP files (*.bmp)|*.bmp")
+		wxT("|PNG files (*.png)|*.png")
+		wxT("|GIF files (*.gif)|*.gif")
+		wxT("|PNM files (*.pnm)|*.pnm")
+		wxT("|TIFF files (*.tif,*.tiff)|*.tif*")
+#endif
+		wxT("|All files|*");
+#endif
+    wxFileDialog dialog(this, _T("Open image file(s)"),
+                        wxEmptyString, wxEmptyString, wildcards,
+                        wxFD_OPEN|wxFD_MULTIPLE);
+
+    if (dialog.ShowModal() == wxID_OK) {
+        wxArrayString paths, filenames;
+
+        dialog.GetPaths(paths);
+        dialog.GetFilenames(filenames);
+
+		OpenFiles(paths, filenames);
+    }
+
+}
+
+void OPJFrame::OnFileSaveAs(wxCommandEvent& WXUNUSED(event))
+{
+    wxString wildcards =
+#ifdef wxUSE_LIBOPENJPEG
+#ifdef __WXMOTIF__
+	wxT("JPEG 2000 codestream (*.j2k)|*.*j*2*");
+#else
+	wxT("JPEG 2000 codestream (*.j2k)|*.j2k")
+	wxT("|JPEG 2000 file format (*.jp2)|*.jp2");
+#endif
+#endif
+
+    wxFileDialog dialog(this, _T("Save image file"),
+                        wxEmptyString, wxEmptyString, wildcards,
+                        wxFD_SAVE);
+
+    if (dialog.ShowModal() == wxID_OK) {
+        wxArrayString paths, filenames;
+
+        dialog.GetPaths(paths);
+        dialog.GetFilenames(filenames);
+
+		SaveFile(paths, filenames);
+    }
+
+
+}
+
+void OPJFrame::OnMemoryOpen(wxCommandEvent& WXUNUSED(event))
+{
+	wxTextEntryDialog dialog(this, wxT("Memory HEX address range: start_address-stop_address"),
+							wxT("Decode a memory buffer"),
+							wxT("0x-0x"),
+							wxOK | wxCANCEL | wxCENTRE,
+							wxDefaultPosition);
+
+	if (dialog.ShowModal() == wxID_OK) {
+
+	}
+
+}
+
+BEGIN_EVENT_TABLE(OPJCanvas, wxScrolledWindow)
+    EVT_MOUSE_EVENTS(OPJCanvas::OnEvent)
+END_EVENT_TABLE()
+
+// Define a constructor for my canvas
+OPJCanvas::OPJCanvas(wxFileName fname, wxWindow *parent, const wxPoint& pos, const wxSize& size)
+        : wxScrolledWindow(parent, wxID_ANY, pos, size,
+                           wxSUNKEN_BORDER | wxNO_FULL_REPAINT_ON_RESIZE)
+{
+    SetBackgroundColour(OPJ_CANVAS_COLOUR);
+
+	m_fname = fname;
+	m_childframe = (OPJChildFrame *) parent;
+	// 100% zoom
+	m_zooml = 100;
+
+
+    OPJDecoThread *dthread = CreateDecoThread();
+
+    if (dthread->Run() != wxTHREAD_NO_ERROR)
+        wxLogMessage(wxT("Can't start deco thread!"));
+    else
+		wxLogMessage(wxT("New deco thread started."));
+
+	// 100% zoom
+	//m_zooml = 100;
+
+}
+
+OPJDecoThread *OPJCanvas::CreateDecoThread(void)
+{
+    OPJDecoThread *dthread = new OPJDecoThread(this);
+
+    if (dthread->Create() != wxTHREAD_NO_ERROR)
+		wxLogError(wxT("Can't create deco thread!"));
+
+    wxCriticalSectionLocker enter(wxGetApp().m_deco_critsect);
+    wxGetApp().m_deco_threads.Add(dthread);
+
+    return dthread;
+}
+
+OPJEncoThread *OPJCanvas::CreateEncoThread(void)
+{
+    OPJEncoThread *ethread = new OPJEncoThread(this);
+
+    if (ethread->Create() != wxTHREAD_NO_ERROR)
+		wxLogError(wxT("Can't create enco thread!"));
+
+    wxCriticalSectionLocker enter(wxGetApp().m_enco_critsect);
+    wxGetApp().m_enco_threads.Add(ethread);
+
+    return ethread;
+}
+
+#define activeoverlay 0
+// Define the repainting behaviour
+void OPJCanvas::OnDraw(wxDC& dc)
+{
+	if (m_image.Ok()) {
+		dc.DrawBitmap(m_image, OPJ_CANVAS_BORDER, OPJ_CANVAS_BORDER);
+
+		if (activeoverlay) {
+			dc.SetPen(*wxRED_PEN);
+			dc.SetBrush(*wxTRANSPARENT_BRUSH);
+			//int tw, th;
+			dc.DrawRectangle(OPJ_CANVAS_BORDER, OPJ_CANVAS_BORDER,
+				(unsigned long int) (0.5 + (double) m_zooml * (double) m_childframe->m_twidth / 100.0),
+				(unsigned long int) (0.5 + (double) m_zooml * (double) m_childframe->m_theight / 100.0));
+		}
+
+	} else {
+		dc.SetFont(*wxSWISS_FONT);
+		dc.SetPen(*wxBLACK_PEN);
+#ifdef __WXGTK__
+		dc.DrawText(_T("Decoding image, please wait... (press \"Zoom to Fit\" to show the image)"), 40, 50);
+#else
+		dc.DrawText(_T("Decoding image, please wait..."), 40, 50);
+#endif
+	}
+}
+
+// This implements a tiny doodling program! Drag the mouse using
+// the left button.
+void OPJCanvas::OnEvent(wxMouseEvent& event)
+{
+#if USE_PENCIL_ON_CANVAS
+  wxClientDC dc(this);
+  PrepareDC(dc);
+
+  wxPoint pt(event.GetLogicalPosition(dc));
+
+  if ((xpos > -1) && (ypos > -1) && event.Dragging()) {
+    dc.SetPen(*wxRED_PEN);
+    dc.DrawLine(xpos, ypos, pt.x, pt.y);
+  }
+  xpos = pt.x;
+  ypos = pt.y;
+#endif
+}
+
+void OPJFrame::OnSize(wxSizeEvent& WXUNUSED(event))
+{
+    wxLayoutAlgorithm layout;
+    layout.LayoutMDIFrame(this);
+}
+
+// Note that OPJFRAME_FILEOPEN and OPJFRAME_HELPABOUT commands get passed
+// to the parent window for processing, so no need to
+// duplicate event handlers here.
+
+BEGIN_EVENT_TABLE(OPJChildFrame, wxMDIChildFrame)
+  /*EVT_MENU(SASHTEST_CHILD_QUIT, OPJChildFrame::OnQuit)*/
+  EVT_CLOSE(OPJChildFrame::OnClose)
+  EVT_SET_FOCUS(OPJChildFrame::OnGotFocus)
+  EVT_KILL_FOCUS(OPJChildFrame::OnLostFocus)
+END_EVENT_TABLE()
+
+OPJChildFrame::OPJChildFrame(OPJFrame *parent, wxFileName fname, int winnumber, const wxString& title, const wxPoint& pos, const wxSize& size,
+const long style):
+  wxMDIChildFrame(parent, wxID_ANY, title, pos, size, style)
+{
+	m_frame = (OPJFrame  *) parent;
+	m_canvas = NULL;
+	//my_children.Append(this);
+	m_fname = fname;
+	m_winnumber = winnumber;
+	SetTitle(wxString::Format(_T("%d: "), m_winnumber) + m_fname.GetFullName());
+
+	  // Give it an icon (this is ignored in MDI mode: uses resources)
+#ifdef __WXMSW__
+	SetIcon(wxIcon(wxT("OPJChild16")));
+#endif
+
+	// Give it a status line
+	/*CreateStatusBar();*/
+
+	int width, height;
+	GetClientSize(&width, &height);
+
+	OPJCanvas *canvas = new OPJCanvas(fname, this, wxPoint(0, 0), wxSize(width, height));
+#if USE_PENCIL_ON_CANVAS
+	canvas->SetCursor(wxCursor(wxCURSOR_PENCIL));
+#endif
+	m_canvas = canvas;
+
+	// Give it scrollbars
+	canvas->SetScrollbars(20, 20, 5, 5);
+
+	Show(true);
+	Maximize(true);
+
+	/*wxLogError(wxString::Format(wxT("Created tree %d (0x%x)"), m_winnumber, m_frame->m_treehash[m_winnumber]));*/
+
+}
+
+OPJChildFrame::~OPJChildFrame(void)
+{
+  //my_children.DeleteObject(this);
+}
+
+
+void OPJChildFrame::OnClose(wxCloseEvent& event)
+{
+	for (unsigned int p = 0; p < m_frame->m_bookCtrl->GetPageCount(); p++) {
+		if (m_frame->m_bookCtrl->GetPageText(p) == wxString::Format(wxT("%u"), m_winnumber)) {
+			m_frame->m_bookCtrl->DeletePage(p);
+			break;
+		}
+	}
+	Destroy();
+
+	wxLogMessage(wxT("Closed: %d"), m_winnumber);
+}
+
+void OPJChildFrame::OnActivate(wxActivateEvent& event)
+{
+  /*if (event.GetActive() && m_canvas)
+    m_canvas->SetFocus();*/
+}
+
+void OPJChildFrame::OnGotFocus(wxFocusEvent& event)
+{
+	// we need to check if the notebook is being destroyed or not
+	if (!m_frame->m_bookCtrl)
+		return;
+
+	for (unsigned int p = 0; p < m_frame->m_bookCtrl->GetPageCount(); p++) {
+
+		if (m_frame->m_bookCtrl->GetPageText(p) == wxString::Format(wxT("%u"), m_winnumber)) {
+			m_frame->m_bookCtrl->ChangeSelection(p);
+			break;
+		}
+
+	}
+
+	//wxLogMessage(wxT("Got focus: %d (%x)"), m_winnumber, event.GetWindow());
+}
+
+void OPJChildFrame::OnLostFocus(wxFocusEvent& event)
+{
+	//wxLogMessage(wxT("Lost focus: %d (%x)"), m_winnumber, event.GetWindow());
+}
+
+#if USE_GENERIC_TREECTRL
+BEGIN_EVENT_TABLE(OPJMarkerTree, wxGenericTreeCtrl)
+#else
+BEGIN_EVENT_TABLE(OPJMarkerTree, wxTreeCtrl)
+#endif
+    /*EVT_TREE_BEGIN_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginDrag)
+    EVT_TREE_BEGIN_RDRAG(TreeTest_Ctrl, OPJMarkerTree::OnBeginRDrag)
+    EVT_TREE_END_DRAG(TreeTest_Ctrl, OPJMarkerTree::OnEndDrag)*/
+    /*EVT_TREE_BEGIN_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnBeginLabelEdit)
+    EVT_TREE_END_LABEL_EDIT(TreeTest_Ctrl, OPJMarkerTree::OnEndLabelEdit)*/
+    /*EVT_TREE_DELETE_ITEM(TreeTest_Ctrl, OPJMarkerTree::OnDeleteItem)*/
+#if 0       // there are so many of those that logging them causes flicker
+    /*EVT_TREE_GET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnGetInfo)*/
+#endif
+    /*EVT_TREE_SET_INFO(TreeTest_Ctrl, OPJMarkerTree::OnSetInfo)
+    EVT_TREE_ITEM_EXPANDED(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanded)*/
+    EVT_TREE_ITEM_EXPANDING(TreeTest_Ctrl, OPJMarkerTree::OnItemExpanding)
+    /*EVT_TREE_ITEM_COLLAPSED(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsed)
+    EVT_TREE_ITEM_COLLAPSING(TreeTest_Ctrl, OPJMarkerTree::OnItemCollapsing)*/
+
+    EVT_TREE_SEL_CHANGED(TreeTest_Ctrl, OPJMarkerTree::OnSelChanged)
+    /*EVT_TREE_SEL_CHANGING(TreeTest_Ctrl, OPJMarkerTree::OnSelChanging)*/
+    /*EVT_TREE_KEY_DOWN(TreeTest_Ctrl, OPJMarkerTree::OnTreeKeyDown)*/
+    /*EVT_TREE_ITEM_ACTIVATED(TreeTest_Ctrl, OPJMarkerTree::OnItemActivated)*/
+
+    // so many differents ways to handle right mouse button clicks...
+    /*EVT_CONTEXT_MENU(OPJMarkerTree::OnContextMenu)*/
+    // EVT_TREE_ITEM_MENU is the preferred event for creating context menus
+    // on a tree control, because it includes the point of the click or item,
+    // meaning that no additional placement calculations are required.
+    EVT_TREE_ITEM_MENU(TreeTest_Ctrl, OPJMarkerTree::OnItemMenu)
+    /*EVT_TREE_ITEM_RIGHT_CLICK(TreeTest_Ctrl, OPJMarkerTree::OnItemRClick)*/
+
+    /*EVT_RIGHT_DOWN(OPJMarkerTree::OnRMouseDown)
+    EVT_RIGHT_UP(OPJMarkerTree::OnRMouseUp)
+    EVT_RIGHT_DCLICK(OPJMarkerTree::OnRMouseDClick)*/
+END_EVENT_TABLE()
+
+// OPJMarkerTree implementation
+#if USE_GENERIC_TREECTRL
+IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxGenericTreeCtrl)
+#else
+IMPLEMENT_DYNAMIC_CLASS(OPJMarkerTree, wxTreeCtrl)
+#endif
+
+OPJMarkerTree::OPJMarkerTree(wxWindow *parent, OPJChildFrame *subframe, wxFileName fname, wxString name, const wxWindowID id,
+           const wxPoint& pos, const wxSize& size, long style)
+          : wxTreeCtrl(parent, id, pos, size, style)
+{
+    m_reverseSort = false;
+	m_fname = fname;
+
+	m_peektextCtrl = ((OPJFrame *) (parent->GetParent()->GetParent()))->m_textCtrlbrowse;
+    CreateImageList();
+
+    // Add some items to the tree
+    //AddTestItemsToTree(5, 5);
+    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
+    wxTreeItemId rootId = AddRoot(name,
+                                  image, image,
+                                  new OPJMarkerData(name));
+
+    OPJParseThread *pthread = CreateParseThread(0x00, subframe);
+    if (pthread->Run() != wxTHREAD_NO_ERROR)
+        wxLogMessage(wxT("Can't start parse thread!"));
+    else
+		wxLogMessage(wxT("New parse thread started."));
+
+	m_childframe = subframe;
+}
+
+void OPJMarkerTree::CreateImageList(int size)
+{
+    if (size == -1) {
+        SetImageList(NULL);
+        return;
+    }
+    if (size == 0)
+        size = m_imageSize;
+    else
+        m_imageSize = size;
+
+    // Make an image list containing small icons
+    wxImageList *images = new wxImageList(size, size, true);
+
+    // should correspond to TreeCtrlIcon_xxx enum
+    wxBusyCursor wait;
+    wxIcon icons[5];
+    icons[0] = wxIcon(icon1_xpm);
+    icons[1] = wxIcon(icon2_xpm);
+    icons[2] = wxIcon(icon3_xpm);
+    icons[3] = wxIcon(icon4_xpm);
+    icons[4] = wxIcon(icon5_xpm);
+
+    int sizeOrig = icons[0].GetWidth();
+    for (size_t i = 0; i < WXSIZEOF(icons); i++) {
+        if (size == sizeOrig) {
+            images->Add(icons[i]);
+        } else {
+            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
+        }
+    }
+
+    AssignImageList(images);
+}
+
+#if USE_GENERIC_TREECTRL || !defined(__WXMSW__)
+void OPJMarkerTree::CreateButtonsImageList(int size)
+{
+    if ( size == -1 ) {
+        SetButtonsImageList(NULL);
+        return;
+    }
+
+    // Make an image list containing small icons
+    wxImageList *images = new wxImageList(size, size, true);
+
+    // should correspond to TreeCtrlIcon_xxx enum
+    wxBusyCursor wait;
+    wxIcon icons[4];
+    icons[0] = wxIcon(icon3_xpm);   // closed
+    icons[1] = wxIcon(icon3_xpm);   // closed, selected
+    icons[2] = wxIcon(icon5_xpm);   // open
+    icons[3] = wxIcon(icon5_xpm);   // open, selected
+
+    for ( size_t i = 0; i < WXSIZEOF(icons); i++ ) {
+        int sizeOrig = icons[i].GetWidth();
+        if ( size == sizeOrig ) {
+            images->Add(icons[i]);
+        } else {
+            images->Add(wxBitmap(wxBitmap(icons[i]).ConvertToImage().Rescale(size, size)));
+        }
+    }
+
+    AssignButtonsImageList(images);
+#else
+void OPJMarkerTree::CreateButtonsImageList(int WXUNUSED(size))
+{
+#endif
+}
+
+void OPJParseThread::LoadFile(wxFileName fname)
+{
+	wxTreeItemId rootid;
+
+	// this is the root node
+	int image = wxGetApp().ShowImages() ? m_tree->TreeCtrlIcon_Folder : -1;
+
+	if (this->m_parentid) {
+		// leaf of a tree
+		rootid = m_parentid;
+		m_tree->SetItemText(rootid, wxT("Parsing..."));
+
+	} else {
+
+		// delete the existing tree hierarchy
+		m_tree->DeleteAllItems();
+
+		// new tree
+		rootid = m_tree->AddRoot(wxT("Parsing..."),
+			image,
+			image,
+			new OPJMarkerData(fname.GetFullPath())
+			);
+		//m_tree->SetItemFont(rootid, *wxITALIC_FONT);
+		m_tree->SetItemBold(rootid);
+	}
+
+	// open the file
+	wxFile m_file(fname.GetFullPath().c_str(), wxFile::read);
+
+	// parsing enabled?
+	if (wxGetApp().m_enableparse) {
+
+		// what is the extension?
+		if ((fname.GetExt() == wxT("j2k")) || (fname.GetExt() == wxT("j2c"))) {
+
+			// parse the file
+			ParseJ2KFile(&m_file, 0, m_file.Length(), rootid);
+
+		} else if ((fname.GetExt() == wxT("jp2")) || (fname.GetExt() == wxT("mj2"))) {
+
+			// parse the file
+			if (this->m_parentid) {
+				//WriteText(wxT("Only a subsection of jp2"));
+				OPJMarkerData *data = (OPJMarkerData *) m_tree->GetItemData(rootid);
+				ParseJ2KFile(&m_file, data->m_start, data->m_length, rootid);
+				m_tree->Expand(rootid);
+
+			} else {
+				// as usual
+				ParseJP2File(&m_file, 0, m_file.Length(), rootid);
+			}
+
+		} else {
+
+			// unknown extension
+			WriteText(wxT("Unknown file format!"));
+
+		}
+
+	}
+
+
+	// this is the root node
+	if (this->m_parentid)
+		m_tree->SetItemText(rootid, wxT("Codestream"));
+	else
+		//m_tree->SetItemText(rootid, wxString::Format(wxT("%s (%d B)"), fname.GetFullName(), m_file.Length()));
+		m_tree->SetItemText(rootid, fname.GetFullName());
+
+	// close the file
+	m_file.Close();
+
+	WriteText(wxT("Parsing finished!"));
+}
+
+/*int OPJMarkerTree::OnCompareItems(const wxTreeItemId& item1,
+                               const wxTreeItemId& item2)
+{
+    if ( m_reverseSort )
+    {
+        // just exchange 1st and 2nd items
+        return wxTreeCtrl::OnCompareItems(item2, item1);
+    }
+    else
+    {
+        return wxTreeCtrl::OnCompareItems(item1, item2);
+    }
+}*/
+
+/*void OPJMarkerTree::AddItemsRecursively(const wxTreeItemId& idParent,
+                                     size_t numChildren,
+                                     size_t depth,
+                                     size_t folder)
+{
+    if ( depth > 0 )
+    {
+        bool hasChildren = depth > 1;
+
+        wxString str;
+        for ( size_t n = 0; n < numChildren; n++ )
+        {
+            // at depth 1 elements won't have any more children
+            if ( hasChildren )
+                str.Printf(wxT("%s child %u"), wxT("Folder"), unsigned(n + 1));
+            else
+                str.Printf(wxT("%s child %u.%u"), wxT("File"), unsigned(folder), unsigned(n + 1));
+
+            // here we pass to AppendItem() normal and selected item images (we
+            // suppose that selected image follows the normal one in the enum)
+            int image, imageSel;
+            if ( wxGetApp().ShowImages() )
+            {
+                image = depth == 1 ? TreeCtrlIcon_File : TreeCtrlIcon_Folder;
+                imageSel = image + 1;
+            }
+            else
+            {
+                image = imageSel = -1;
+            }
+            wxTreeItemId id = AppendItem(idParent, str, image, imageSel,
+                                         new OPJMarkerData(str));
+
+            // and now we also set the expanded one (only for the folders)
+            if ( hasChildren && wxGetApp().ShowImages() )
+            {
+                SetItemImage(id, TreeCtrlIcon_FolderOpened,
+                             wxTreeItemIcon_Expanded);
+            }
+
+            // remember the last child for OnEnsureVisible()
+            if ( !hasChildren && n == numChildren - 1 )
+            {
+                m_lastItem = id;
+            }
+
+            AddItemsRecursively(id, numChildren, depth - 1, n + 1);
+        }
+    }
+    //else: done!
+}*/
+
+/*void OPJMarkerTree::AddTestItemsToTree(size_t numChildren,
+                                    size_t depth)
+{
+    int image = wxGetApp().ShowImages() ? OPJMarkerTree::TreeCtrlIcon_Folder : -1;
+    wxTreeItemId rootId = AddRoot(wxT("Root"),
+                                  image, image,
+                                  new OPJMarkerData(wxT("Root item")));
+    if ( image != -1 )
+    {
+        SetItemImage(rootId, TreeCtrlIcon_FolderOpened, wxTreeItemIcon_Expanded);
+    }
+
+    AddItemsRecursively(rootId, numChildren, depth, 0);
+
+    // set some colours/fonts for testing
+    SetItemFont(rootId, *wxITALIC_FONT);
+
+    wxTreeItemIdValue cookie;
+    wxTreeItemId id = GetFirstChild(rootId, cookie);
+    SetItemTextColour(id, *wxBLUE);
+
+    id = GetNextChild(rootId, cookie);
+    id = GetNextChild(rootId, cookie);
+    SetItemTextColour(id, *wxRED);
+    SetItemBackgroundColour(id, *wxLIGHT_GREY);
+}*/
+
+/*void OPJMarkerTree::GetItemsRecursively(const wxTreeItemId& idParent,
+                                     wxTreeItemIdValue cookie)
+{
+    wxTreeItemId id;
+
+    if ( !cookie )
+        id = GetFirstChild(idParent, cookie);
+    else
+        id = GetNextChild(idParent, cookie);
+
+    if ( !id.IsOk() )
+        return;
+
+    wxString text = GetItemText(id);
+    wxLogMessage(text);
+
+    if (ItemHasChildren(id))
+        GetItemsRecursively(id);
+
+    GetItemsRecursively(idParent, cookie);
+}*/
+
+/*void OPJMarkerTree::DoToggleIcon(const wxTreeItemId& item)
+{
+    int image = (GetItemImage(item) == TreeCtrlIcon_Folder)
+                    ? TreeCtrlIcon_File
+                    : TreeCtrlIcon_Folder;
+    SetItemImage(item, image, wxTreeItemIcon_Normal);
+
+    image = (GetItemImage(item) == TreeCtrlIcon_FolderSelected)
+                    ? TreeCtrlIcon_FileSelected
+                    : TreeCtrlIcon_FolderSelected;
+    SetItemImage(item, image, wxTreeItemIcon_Selected);
+}*/
+
+void OPJMarkerTree::LogEvent(const wxChar *name, const wxTreeEvent& event)
+{
+    wxTreeItemId item = event.GetItem();
+    wxString text;
+    if ( item.IsOk() )
+        text << wxT('"') << GetItemText(item).c_str() << wxT('"');
+    else
+        text = wxT("invalid item");
+    wxLogMessage(wxT("%s(%s)"), name, text.c_str());
+}
+
+OPJParseThread *OPJMarkerTree::CreateParseThread(wxTreeItemId parentid, OPJChildFrame *subframe)
+{
+    OPJParseThread *pthread = new OPJParseThread(this, parentid);
+
+    if (pthread->Create() != wxTHREAD_NO_ERROR)
+		wxLogError(wxT("Can't create parse thread!"));
+
+    wxCriticalSectionLocker enter(wxGetApp().m_parse_critsect);
+    wxGetApp().m_parse_threads.Add(pthread);
+
+    return pthread;
+}
+
+
+/*// avoid repetition
+#define TREE_EVENT_HANDLER(name)                                 \
+void OPJMarkerTree::name(wxTreeEvent& event)                        \
+{                                                                \
+    LogEvent(_T(#name), event);                                  \
+    SetLastItem(wxTreeItemId());                                 \
+    event.Skip();                                                \
+}*/
+
+/*TREE_EVENT_HANDLER(OnBeginRDrag)*/
+/*TREE_EVENT_HANDLER(OnDeleteItem)*/
+/*TREE_EVENT_HANDLER(OnGetInfo)
+TREE_EVENT_HANDLER(OnSetInfo)*/
+/*TREE_EVENT_HANDLER(OnItemExpanded)
+TREE_EVENT_HANDLER(OnItemExpanding)*/
+/*TREE_EVENT_HANDLER(OnItemCollapsed)*/
+/*TREE_EVENT_HANDLER(OnSelChanged)
+TREE_EVENT_HANDLER(OnSelChanging)*/
+
+/*#undef TREE_EVENT_HANDLER*/
+
+void OPJMarkerTree::OnItemExpanding(wxTreeEvent& event)
+{
+	wxTreeItemId item = event.GetItem();
+	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
+	wxString text;
+
+	if (item.IsOk())
+		text << wxT('"') << GetItemText(item).c_str() << wxT('"');
+	else
+		text = wxT("invalid item");
+
+	if (wxStrcmp(data->GetDesc1(), wxT("INFO-CSTREAM")))
+		return;
+
+	wxLogMessage(wxT("Expanding... (%s -> %s, %s, %d, %d)"),
+		text.c_str(), data->GetDesc1(), data->GetDesc2(),
+		data->m_start, data->m_length);
+
+	// the codestream box is being asked for expansion
+	wxTreeItemIdValue cookie;
+	if (!GetFirstChild(item, cookie).IsOk()) {
+		OPJParseThread *pthread = CreateParseThread(item);
+		if (pthread->Run() != wxTHREAD_NO_ERROR)
+			wxLogMessage(wxT("Can't start parse thread!"));
+		else
+			wxLogMessage(wxT("New parse thread started."));
+	}
+}
+
+void OPJMarkerTree::OnSelChanged(wxTreeEvent& event)
+{
+	int bunch_linesize = 16;
+	int bunch_numlines = 7;
+
+	wxTreeItemId item = event.GetItem();
+	OPJMarkerData* data = (OPJMarkerData *) GetItemData(item);
+	wxString text;
+	int l, c, pos = 0, pre_pos;
+
+	m_peektextCtrl->Clear();
+
+	/*text << wxString::Format(wxT("Selected... (%s -> %s, %s, %d, %d)"),
+		text.c_str(), data->GetDesc1(), data->GetDesc2(),
+		data->m_start, data->m_length) << wxT("\n");*/
+
+	// open the file and browse a little
+	wxFile *fp = new wxFile(m_fname.GetFullPath().c_str(), wxFile::read);
+
+	// go to position claimed
+	fp->Seek(data->m_start, wxFromStart);
+
+	// read a bunch
+	int max_read = wxMin(wxFileOffset(bunch_linesize * bunch_numlines), data->m_length - data->m_start + 1);
+	if (data->m_desc == wxT("MARK (65380)")) {
+		/*wxLogMessage(data->m_desc);*/
+		max_read = data->m_length - data->m_start + 1;
+		bunch_numlines = (int) ceil((float) max_read / (float) bunch_linesize);
+	}
+	unsigned char *buffer = new unsigned char[bunch_linesize * bunch_numlines];
+	fp->Read(buffer, max_read);
+
+	// write the file data between start and stop
+	pos = 0;
+	for (l = 0; l < bunch_numlines; l++) {
+
+		text << wxString::Format(wxT("%010d:"), data->m_start + pos);
+
+		pre_pos = pos;
+
+		// add hex browsing text
+		for (c = 0; c < bunch_linesize; c++) {
+
+			if (!(c % 8))
+				text << wxT(" ");
+
+			if (pos < max_read) {
+				text << wxString::Format(wxT("%02X "), buffer[pos]);
+			} else
+				text << wxT("   ");
+			pos++;
+		}
+
+		text << wxT("    ");
+
+		// add char browsing text
+		for (c = 0; c < bunch_linesize; c++) {
+
+			if (pre_pos < max_read) {
+				if ((buffer[pre_pos] == '\n') ||
+					(buffer[pre_pos] == '\t') ||
+					(buffer[pre_pos] == '\0') ||
+					(buffer[pre_pos] == 0x0D) ||
+					(buffer[pre_pos] == 0x0B))
+					buffer[pre_pos] = ' ';
+				text << wxString::FromAscii((char) buffer[pre_pos]) << wxT(".");
+			} else
+				text << wxT("  ");
+			pre_pos++;
+		}
+
+		text << wxT("\n");
+
+	}
+
+	// close the file
+	fp->Close();
+
+	m_peektextCtrl->WriteText(text);
+
+	delete buffer;
+}
+
+/*void LogKeyEvent(const wxChar *name, const wxKeyEvent& event)
+{
+    wxString key;
+    long keycode = event.GetKeyCode();
+    {
+        switch ( keycode )
+        {
+            case WXK_BACK: key = wxT("BACK"); break;
+            case WXK_TAB: key = wxT("TAB"); break;
+            case WXK_RETURN: key = wxT("RETURN"); break;
+            case WXK_ESCAPE: key = wxT("ESCAPE"); break;
+            case WXK_SPACE: key = wxT("SPACE"); break;
+            case WXK_DELETE: key = wxT("DELETE"); break;
+            case WXK_START: key = wxT("START"); break;
+            case WXK_LBUTTON: key = wxT("LBUTTON"); break;
+            case WXK_RBUTTON: key = wxT("RBUTTON"); break;
+            case WXK_CANCEL: key = wxT("CANCEL"); break;
+            case WXK_MBUTTON: key = wxT("MBUTTON"); break;
+            case WXK_CLEAR: key = wxT("CLEAR"); break;
+            case WXK_SHIFT: key = wxT("SHIFT"); break;
+            case WXK_ALT: key = wxT("ALT"); break;
+            case WXK_CONTROL: key = wxT("CONTROL"); break;
+            case WXK_MENU: key = wxT("MENU"); break;
+            case WXK_PAUSE: key = wxT("PAUSE"); break;
+            case WXK_CAPITAL: key = wxT("CAPITAL"); break;
+            case WXK_END: key = wxT("END"); break;
+            case WXK_HOME: key = wxT("HOME"); break;
+            case WXK_LEFT: key = wxT("LEFT"); break;
+            case WXK_UP: key = wxT("UP"); break;
+            case WXK_RIGHT: key = wxT("RIGHT"); break;
+            case WXK_DOWN: key = wxT("DOWN"); break;
+            case WXK_SELECT: key = wxT("SELECT"); break;
+            case WXK_PRINT: key = wxT("PRINT"); break;
+            case WXK_EXECUTE: key = wxT("EXECUTE"); break;
+            case WXK_SNAPSHOT: key = wxT("SNAPSHOT"); break;
+            case WXK_INSERT: key = wxT("INSERT"); break;
+            case WXK_HELP: key = wxT("HELP"); break;
+            case WXK_NUMPAD0: key = wxT("NUMPAD0"); break;
+            case WXK_NUMPAD1: key = wxT("NUMPAD1"); break;
+            case WXK_NUMPAD2: key = wxT("NUMPAD2"); break;
+            case WXK_NUMPAD3: key = wxT("NUMPAD3"); break;
+            case WXK_NUMPAD4: key = wxT("NUMPAD4"); break;
+            case WXK_NUMPAD5: key = wxT("NUMPAD5"); break;
+            case WXK_NUMPAD6: key = wxT("NUMPAD6"); break;
+            case WXK_NUMPAD7: key = wxT("NUMPAD7"); break;
+            case WXK_NUMPAD8: key = wxT("NUMPAD8"); break;
+            case WXK_NUMPAD9: key = wxT("NUMPAD9"); break;
+            case WXK_MULTIPLY: key = wxT("MULTIPLY"); break;
+            case WXK_ADD: key = wxT("ADD"); break;
+            case WXK_SEPARATOR: key = wxT("SEPARATOR"); break;
+            case WXK_SUBTRACT: key = wxT("SUBTRACT"); break;
+            case WXK_DECIMAL: key = wxT("DECIMAL"); break;
+            case WXK_DIVIDE: key = wxT("DIVIDE"); break;
+            case WXK_F1: key = wxT("F1"); break;
+            case WXK_F2: key = wxT("F2"); break;
+            case WXK_F3: key = wxT("F3"); break;
+            case WXK_F4: key = wxT("F4"); break;
+            case WXK_F5: key = wxT("F5"); break;
+            case WXK_F6: key = wxT("F6"); break;
+            case WXK_F7: key = wxT("F7"); break;
+            case WXK_F8: key = wxT("F8"); break;
+            case WXK_F9: key = wxT("F9"); break;
+            case WXK_F10: key = wxT("F10"); break;
+            case WXK_F11: key = wxT("F11"); break;
+            case WXK_F12: key = wxT("F12"); break;
+            case WXK_F13: key = wxT("F13"); break;
+            case WXK_F14: key = wxT("F14"); break;
+            case WXK_F15: key = wxT("F15"); break;
+            case WXK_F16: key = wxT("F16"); break;
+            case WXK_F17: key = wxT("F17"); break;
+            case WXK_F18: key = wxT("F18"); break;
+            case WXK_F19: key = wxT("F19"); break;
+            case WXK_F20: key = wxT("F20"); break;
+            case WXK_F21: key = wxT("F21"); break;
+            case WXK_F22: key = wxT("F22"); break;
+            case WXK_F23: key = wxT("F23"); break;
+            case WXK_F24: key = wxT("F24"); break;
+            case WXK_NUMLOCK: key = wxT("NUMLOCK"); break;
+            case WXK_SCROLL: key = wxT("SCROLL"); break;
+            case WXK_PAGEUP: key = wxT("PAGEUP"); break;
+            case WXK_PAGEDOWN: key = wxT("PAGEDOWN"); break;
+            case WXK_NUMPAD_SPACE: key = wxT("NUMPAD_SPACE"); break;
+            case WXK_NUMPAD_TAB: key = wxT("NUMPAD_TAB"); break;
+            case WXK_NUMPAD_ENTER: key = wxT("NUMPAD_ENTER"); break;
+            case WXK_NUMPAD_F1: key = wxT("NUMPAD_F1"); break;
+            case WXK_NUMPAD_F2: key = wxT("NUMPAD_F2"); break;
+            case WXK_NUMPAD_F3: key = wxT("NUMPAD_F3"); break;
+            case WXK_NUMPAD_F4: key = wxT("NUMPAD_F4"); break;
+            case WXK_NUMPAD_HOME: key = wxT("NUMPAD_HOME"); break;
+            case WXK_NUMPAD_LEFT: key = wxT("NUMPAD_LEFT"); break;
+            case WXK_NUMPAD_UP: key = wxT("NUMPAD_UP"); break;
+            case WXK_NUMPAD_RIGHT: key = wxT("NUMPAD_RIGHT"); break;
+            case WXK_NUMPAD_DOWN: key = wxT("NUMPAD_DOWN"); break;
+            case WXK_NUMPAD_PAGEUP: key = wxT("NUMPAD_PAGEUP"); break;
+            case WXK_NUMPAD_PAGEDOWN: key = wxT("NUMPAD_PAGEDOWN"); break;
+            case WXK_NUMPAD_END: key = wxT("NUMPAD_END"); break;
+            case WXK_NUMPAD_BEGIN: key = wxT("NUMPAD_BEGIN"); break;
+            case WXK_NUMPAD_INSERT: key = wxT("NUMPAD_INSERT"); break;
+            case WXK_NUMPAD_DELETE: key = wxT("NUMPAD_DELETE"); break;
+            case WXK_NUMPAD_EQUAL: key = wxT("NUMPAD_EQUAL"); break;
+            case WXK_NUMPAD_MULTIPLY: key = wxT("NUMPAD_MULTIPLY"); break;
+            case WXK_NUMPAD_ADD: key = wxT("NUMPAD_ADD"); break;
+            case WXK_NUMPAD_SEPARATOR: key = wxT("NUMPAD_SEPARATOR"); break;
+            case WXK_NUMPAD_SUBTRACT: key = wxT("NUMPAD_SUBTRACT"); break;
+            case WXK_NUMPAD_DECIMAL: key = wxT("NUMPAD_DECIMAL"); break;
+
+            default:
+            {
+               if ( keycode < 128 && wxIsprint((int)keycode) )
+                   key.Printf(wxT("'%c'"), (char)keycode);
+               else if ( keycode > 0 && keycode < 27 )
+                   key.Printf(_("Ctrl-%c"), wxT('A') + keycode - 1);
+               else
+                   key.Printf(wxT("unknown (%ld)"), keycode);
+            }
+        }
+    }
+
+    wxLogMessage(wxT("%s event: %s (flags = %c%c%c%c)"),
+                  name,
+                  key.c_str(),
+                  event.ControlDown() ? wxT('C') : wxT('-'),
+                  event.AltDown() ? wxT('A') : wxT('-'),
+                  event.ShiftDown() ? wxT('S') : wxT('-'),
+                  event.MetaDown() ? wxT('M') : wxT('-'));
+}
+
+void OPJMarkerTree::OnTreeKeyDown(wxTreeEvent& event)
+{
+    LogKeyEvent(wxT("Tree key down "), event.GetKeyEvent());
+
+    event.Skip();
+}*/
+
+/*void OPJMarkerTree::OnBeginDrag(wxTreeEvent& event)
+{
+    // need to explicitly allow drag
+    if ( event.GetItem() != GetRootItem() )
+    {
+        m_draggedItem = event.GetItem();
+
+        wxLogMessage(wxT("OnBeginDrag: started dragging %s"),
+                     GetItemText(m_draggedItem).c_str());
+
+        event.Allow();
+    }
+    else
+    {
+        wxLogMessage(wxT("OnBeginDrag: this item can't be dragged."));
+    }
+}
+
+void OPJMarkerTree::OnEndDrag(wxTreeEvent& event)
+{
+    wxTreeItemId itemSrc = m_draggedItem,
+                 itemDst = event.GetItem();
+    m_draggedItem = (wxTreeItemId)0l;
+
+    // where to copy the item?
+    if ( itemDst.IsOk() && !ItemHasChildren(itemDst) )
+    {
+        // copy to the parent then
+        itemDst = GetItemParent(itemDst);
+    }
+
+    if ( !itemDst.IsOk() )
+    {
+        wxLogMessage(wxT("OnEndDrag: can't drop here."));
+
+        return;
+    }
+
+    wxString text = GetItemText(itemSrc);
+    wxLogMessage(wxT("OnEndDrag: '%s' copied to '%s'."),
+                 text.c_str(), GetItemText(itemDst).c_str());
+
+    // just do append here - we could also insert it just before/after the item
+    // on which it was dropped, but this requires slightly more work... we also
+    // completely ignore the client data and icon of the old item but could
+    // copy them as well.
+    //
+    // Finally, we only copy one item here but we might copy the entire tree if
+    // we were dragging a folder.
+    int image = wxGetApp().ShowImages() ? TreeCtrlIcon_File : -1;
+    AppendItem(itemDst, text, image);
+}*/
+
+/*void OPJMarkerTree::OnBeginLabelEdit(wxTreeEvent& event)
+{
+    wxLogMessage(wxT("OnBeginLabelEdit"));
+
+    // for testing, prevent this item's label editing
+    wxTreeItemId itemId = event.GetItem();
+    if ( IsTestItem(itemId) )
+    {
+        wxMessageBox(wxT("You can't edit this item."));
+
+        event.Veto();
+    }
+    else if ( itemId == GetRootItem() )
+    {
+        // test that it is possible to change the text of the item being edited
+        SetItemText(itemId, _T("Editing root item"));
+    }
+}
+
+void OPJMarkerTree::OnEndLabelEdit(wxTreeEvent& event)
+{
+    wxLogMessage(wxT("OnEndLabelEdit"));
+
+    // don't allow anything except letters in the labels
+    if ( !event.GetLabel().IsWord() )
+    {
+        wxMessageBox(wxT("The new label should be a single word."));
+
+        event.Veto();
+    }
+}*/
+
+/*void OPJMarkerTree::OnItemCollapsing(wxTreeEvent& event)
+{
+    wxLogMessage(wxT("OnItemCollapsing"));
+
+    // for testing, prevent the user from collapsing the first child folder
+    wxTreeItemId itemId = event.GetItem();
+    if ( IsTestItem(itemId) )
+    {
+        wxMessageBox(wxT("You can't collapse this item."));
+
+        event.Veto();
+    }
+}*/
+
+/*void OPJMarkerTree::OnItemActivated(wxTreeEvent& event)
+{
+    // show some info about this item
+    wxTreeItemId itemId = event.GetItem();
+    OPJMarkerData *item = (OPJMarkerData *)GetItemData(itemId);
+
+    if ( item != NULL )
+    {
+        item->ShowInfo(this);
+    }
+
+    wxLogMessage(wxT("OnItemActivated"));
+}*/
+
+void OPJMarkerTree::OnItemMenu(wxTreeEvent& event)
+{
+    /*wxTreeItemId itemId = event.GetItem();
+    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
+                                         : NULL;
+
+    wxLogMessage(wxT("OnItemMenu for item \"%s\""), item ? item->GetDesc()
+                                                         : _T(""));*/
+
+	//wxLogMessage(wxT("EEEEEEEEEE"));
+
+    //event.Skip();
+}
+
+/*void OPJMarkerTree::OnContextMenu(wxContextMenuEvent& event)
+{
+    wxPoint pt = event.GetPosition();
+    wxTreeItemId item;
+    wxLogMessage(wxT("OnContextMenu at screen coords (%i, %i)"), pt.x, pt.y);
+
+    // check if event was generated by keyboard (MSW-specific?)
+    if ( pt.x == -1 && pt.y == -1 ) //(this is how MSW indicates it)
+    {
+        if ( !HasFlag(wxTR_MULTIPLE) )
+            item = GetSelection();
+
+        // attempt to guess where to show the menu
+        if ( item.IsOk() )
+        {
+            // if an item was clicked, show menu to the right of it
+            wxRect rect;
+            GetBoundingRect(item, rect, true );// only the label
+            pt = wxPoint(rect.GetRight(), rect.GetTop());
+        }
+        else
+        {
+            pt = wxPoint(0, 0);
+        }
+    }
+    else // event was generated by mouse, use supplied coords
+    {
+        pt = ScreenToClient(pt);
+        item = HitTest(pt);
+    }
+
+    ShowMenu(item, pt);
+}*/
+
+/*void OPJMarkerTree::ShowMenu(wxTreeItemId id, const wxPoint& pt)
+{
+    wxString title;
+    if ( id.IsOk() )
+    {
+        title << wxT("Menu for ") << GetItemText(id);
+    }
+    else
+    {
+        title = wxT("Menu for no particular item");
+    }
+
+#if wxUSE_MENUS
+    wxMenu menu(title);
+    menu.Append(TreeTest_About, wxT("&About..."));
+    menu.AppendSeparator();
+    menu.Append(TreeTest_Highlight, wxT("&Highlight item"));
+    menu.Append(TreeTest_Dump, wxT("&Dump"));
+
+    PopupMenu(&menu, pt);
+#endif // wxUSE_MENUS
+}*/
+
+/*void OPJMarkerTree::OnItemRClick(wxTreeEvent& event)
+{
+    wxTreeItemId itemId = event.GetItem();
+    OPJMarkerData *item = itemId.IsOk() ? (OPJMarkerData *)GetItemData(itemId)
+                                         : NULL;
+
+    wxLogMessage(wxT("Item \"%s\" right clicked"), item ? item->GetDesc()
+                                                        : _T(""));
+
+    event.Skip();
+}*/
+
+/*
+void OPJMarkerTree::OnRMouseDown(wxMouseEvent& event)
+{
+    wxLogMessage(wxT("Right mouse button down"));
+
+    event.Skip();
+}
+
+void OPJMarkerTree::OnRMouseUp(wxMouseEvent& event)
+{
+    wxLogMessage(wxT("Right mouse button up"));
+
+    event.Skip();
+}
+
+void OPJMarkerTree::OnRMouseDClick(wxMouseEvent& event)
+{
+    wxTreeItemId id = HitTest(event.GetPosition());
+    if ( !id )
+        wxLogMessage(wxT("No item under mouse"));
+    else
+    {
+        OPJMarkerData *item = (OPJMarkerData *)GetItemData(id);
+        if ( item )
+            wxLogMessage(wxT("Item '%s' under mouse"), item->GetDesc());
+    }
+
+    event.Skip();
+}
+*/
+
+static inline const wxChar *Bool2String(bool b)
+{
+    return b ? wxT("") : wxT("not ");
+}
+
+void OPJMarkerData::ShowInfo(wxTreeCtrl *tree)
+{
+    wxLogMessage(wxT("Item '%s': %sselected, %sexpanded, %sbold,\n")
+                 wxT("%u children (%u immediately under this item)."),
+                 m_desc.c_str(),
+                 Bool2String(tree->IsSelected(GetId())),
+                 Bool2String(tree->IsExpanded(GetId())),
+                 Bool2String(tree->IsBold(GetId())),
+                 unsigned(tree->GetChildrenCount(GetId())),
+                 unsigned(tree->GetChildrenCount(GetId(), false)));
+}
+
+/////////////////////////////////////////////////////////////////////
+// Encoding thread class
+/////////////////////////////////////////////////////////////////////
+
+OPJEncoThread::OPJEncoThread(OPJCanvas *canvas)
+        : wxThread()
+{
+    m_count = 0;
+    m_canvas = canvas;
+}
+
+void OPJEncoThread::WriteText(const wxString& text)
+{
+    wxString msg;
+
+    // before doing any GUI calls we must ensure that this thread is the only
+    // one doing it!
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif // __WXGTK__
+
+    msg << text;
+    m_canvas->WriteText(msg);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif // __WXGTK__
+}
+
+void OPJEncoThread::OnExit()
+{
+    wxCriticalSectionLocker locker(wxGetApp().m_enco_critsect);
+
+    wxArrayThread& ethreads = wxGetApp().m_enco_threads;
+    ethreads.Remove(this);
+
+    if (ethreads.IsEmpty() )
+    {
+        // signal the main thread that there are no more threads left if it is
+        // waiting for us
+        if (wxGetApp().m_enco_waitingUntilAllDone) {
+            wxGetApp().m_enco_waitingUntilAllDone = false;
+            wxGetApp().m_enco_semAllDone.Post();
+        }
+    }
+}
+
+void *OPJEncoThread::Entry()
+{
+    wxString text;
+
+	srand(GetId());
+	//int m_countnum = rand() % 9;
+    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
+    //            GetId(), GetPriority(), m_countnum);
+    text.Printf(wxT("Enco thread %d started"), m_canvas->m_childframe->m_winnumber);
+    WriteText(text);
+
+	// set handler properties
+	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
+	j2kkkhandler->m_subsampling = wxGetApp().m_subsampling;
+	j2kkkhandler->m_origin = wxGetApp().m_origin;
+	j2kkkhandler->m_rates = wxGetApp().m_rates;
+	j2kkkhandler->m_quality = wxGetApp().m_quality;
+	j2kkkhandler->m_enablequality = wxGetApp().m_enablequality;
+	j2kkkhandler->m_multicomp = wxGetApp().m_multicomp;
+	j2kkkhandler->m_irreversible = wxGetApp().m_irreversible;
+	j2kkkhandler->m_resolutions = wxGetApp().m_resolutions;
+	j2kkkhandler->m_progression = wxGetApp().m_progression;
+	j2kkkhandler->m_cbsize = wxGetApp().m_cbsize;
+	j2kkkhandler->m_prsize = wxGetApp().m_prsize;
+	j2kkkhandler->m_tsize = wxGetApp().m_tsize;
+	j2kkkhandler->m_torigin = wxGetApp().m_torigin;
+	j2kkkhandler->m_enablesop = wxGetApp().m_enablesop;
+	j2kkkhandler->m_enableeph = wxGetApp().m_enableeph;
+	j2kkkhandler->m_enablebypass = wxGetApp().m_enablebypass;
+	j2kkkhandler->m_enablerestart = wxGetApp().m_enablerestart;
+	j2kkkhandler->m_enablereset = wxGetApp().m_enablereset;
+	j2kkkhandler->m_enablesegmark = wxGetApp().m_enablesegmark;
+	j2kkkhandler->m_enableerterm = wxGetApp().m_enableerterm;
+	j2kkkhandler->m_enablevsc = wxGetApp().m_enablevsc;
+	j2kkkhandler->m_enableidx = wxGetApp().m_enableidx;
+	j2kkkhandler->m_index = m_canvas->m_savename.GetPath(wxPATH_GET_VOLUME | wxPATH_GET_SEPARATOR) + wxGetApp().m_index;
+	j2kkkhandler->m_enablecomm = wxGetApp().m_enablecomm;
+	j2kkkhandler->m_comment = wxGetApp().m_comment;
+
+	// save the file
+	if (!m_canvas->m_image100.SaveFile(m_canvas->m_savename.GetFullPath(), (wxBitmapType) wxBITMAP_TYPE_J2K)) {
+		WriteText(wxT("Can't save image"));
+		return NULL;
+	}
+
+    text.Printf(wxT("Enco thread %d finished"), m_canvas->m_childframe->m_winnumber);
+    WriteText(text);
+    return NULL;
+}
+
+/////////////////////////////////////////////////////////////////////
+// Decoding thread class
+/////////////////////////////////////////////////////////////////////
+
+OPJDecoThread::OPJDecoThread(OPJCanvas *canvas)
+        : wxThread()
+{
+    m_count = 0;
+    m_canvas = canvas;
+}
+
+void OPJDecoThread::WriteText(const wxString& text)
+{
+    wxString msg;
+
+    // before doing any GUI calls we must ensure that this thread is the only
+    // one doing it!
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif // __WXGTK__
+
+    msg << text;
+    m_canvas->WriteText(msg);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif // __WXGTK__
+}
+
+void OPJDecoThread::OnExit()
+{
+    wxCriticalSectionLocker locker(wxGetApp().m_deco_critsect);
+
+    wxArrayThread& dthreads = wxGetApp().m_deco_threads;
+    dthreads.Remove(this);
+
+    if (dthreads.IsEmpty() )
+    {
+        // signal the main thread that there are no more threads left if it is
+        // waiting for us
+        if (wxGetApp().m_deco_waitingUntilAllDone) {
+            wxGetApp().m_deco_waitingUntilAllDone = false;
+            wxGetApp().m_deco_semAllDone.Post();
+        }
+    }
+}
+
+void *OPJDecoThread::Entry()
+{
+
+    wxString text;
+
+	srand(GetId());
+	//int m_countnum = rand() % 9;
+    //text.Printf(wxT("Deco thread 0x%lx started (priority = %u, time = %d)."),
+    //            GetId(), GetPriority(), m_countnum);
+    text.Printf(wxT("Deco thread %d started"), m_canvas->m_childframe->m_winnumber);
+
+    WriteText(text);
+
+    wxBitmap bitmap(100, 100);
+    wxImage image(100, 100, true); //= bitmap.ConvertToImage();
+    image.Destroy();
+
+	WriteText(m_canvas->m_fname.GetFullPath());
+
+
+	// set handler properties
+	wxJ2KHandler *j2kkkhandler = (wxJ2KHandler *) wxImage::FindHandler( wxBITMAP_TYPE_J2K);
+	j2kkkhandler->m_reducefactor = wxGetApp().m_reducefactor;
+	j2kkkhandler->m_qualitylayers = wxGetApp().m_qualitylayers;
+	j2kkkhandler->m_components = wxGetApp().m_components;
+#ifdef USE_JPWL
+	j2kkkhandler->m_enablejpwl = wxGetApp().m_enablejpwl;
+	j2kkkhandler->m_expcomps = wxGetApp().m_expcomps;
+	j2kkkhandler->m_maxtiles = wxGetApp().m_maxtiles;
+#endif // USE_JPWL
+
+	wxJP2Handler *jp222handler = (wxJP2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_JP2);
+	jp222handler->m_reducefactor = wxGetApp().m_reducefactor;
+	jp222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
+	jp222handler->m_components = wxGetApp().m_components;
+#ifdef USE_JPWL
+	jp222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
+	jp222handler->m_expcomps = wxGetApp().m_expcomps;
+	jp222handler->m_maxtiles = wxGetApp().m_maxtiles;
+#endif // USE_JPWL
+
+	wxMJ2Handler *mj222handler = (wxMJ2Handler *) wxImage::FindHandler( wxBITMAP_TYPE_MJ2);
+	mj222handler->m_reducefactor = wxGetApp().m_reducefactor;
+	mj222handler->m_qualitylayers = wxGetApp().m_qualitylayers;
+	mj222handler->m_components = wxGetApp().m_components;
+	mj222handler->m_framenum = wxGetApp().m_framenum;
+#ifdef USE_JPWL
+	mj222handler->m_enablejpwl = wxGetApp().m_enablejpwl;
+	mj222handler->m_expcomps = wxGetApp().m_expcomps;
+	mj222handler->m_maxtiles = wxGetApp().m_maxtiles;
+#endif // USE_JPWL
+
+	if (wxGetApp().m_enabledeco) {
+
+		// load the file
+		if (!image.LoadFile(m_canvas->m_fname.GetFullPath(), wxBITMAP_TYPE_ANY, 0)) {
+			WriteText(wxT("Can't load image"));
+			return NULL;
+		}
+
+	} else {
+
+		// display a macaron
+		if (!image.Create(300, 5, false)) {
+			WriteText(wxT("Can't create image"));
+			return NULL;
+		}
+
+	}
+
+	// assign 100% image
+    m_canvas->m_image100 = wxBitmap(image);
+
+	// find a fit-to-width zoom
+	int zooml, wzooml, hzooml;
+	wxSize clientsize = m_canvas->GetClientSize();
+	wzooml = (int) floor(100.0 * (double) clientsize.GetWidth() / (double) (2 * OPJ_CANVAS_BORDER + image.GetWidth()));
+	hzooml = (int) floor(100.0 * (double) clientsize.GetHeight() / (double) (2 * OPJ_CANVAS_BORDER + image.GetHeight()));
+	zooml = wxMin(100, wxMin(wzooml, hzooml));
+
+	// fit to width
+#ifndef __WXGTK__
+	m_canvas->m_childframe->m_frame->Rescale(zooml, m_canvas->m_childframe);
+#endif // __WXGTK__
+
+	//m_canvas->m_image = m_canvas->m_image100;
+	//m_canvas->Refresh();
+	//m_canvas->SetScrollbars(20, 20, (int)(0.5 + (double) image.GetWidth() / 20.0), (int)(0.5 + (double) image.GetHeight() / 20.0));
+
+    //text.Printf(wxT("Deco thread 0x%lx finished."), GetId());
+    text.Printf(wxT("Deco thread %d finished"), m_canvas->m_childframe->m_winnumber);
+    WriteText(text);
+    return NULL;
+
+}
+
+/////////////////////////////////////////////////////////////////////
+// Parsing thread class
+/////////////////////////////////////////////////////////////////////
+
+OPJParseThread::OPJParseThread(OPJMarkerTree *tree, wxTreeItemId parentid)
+        : wxThread()
+{
+    m_count = 0;
+    m_tree = tree;
+	m_parentid = parentid;
+}
+
+void OPJParseThread::WriteText(const wxString& text)
+{
+    wxString msg;
+
+    // before doing any GUI calls we must ensure that this thread is the only
+    // one doing it!
+
+#ifndef __WXGTK__ 
+    wxMutexGuiEnter();
+#endif // __WXGTK
+
+    msg << text;
+    m_tree->WriteText(msg);
+
+#ifndef __WXGTK__ 
+    wxMutexGuiLeave();
+#endif // __WXGTK
+}
+
+void OPJParseThread::OnExit()
+{
+    wxCriticalSectionLocker locker(wxGetApp().m_parse_critsect);
+
+    wxArrayThread& threads = wxGetApp().m_parse_threads;
+    threads.Remove(this);
+
+    if (threads.IsEmpty()) {
+        // signal the main thread that there are no more threads left if it is
+        // waiting for us
+        if (wxGetApp().m_parse_waitingUntilAllDone) {
+            wxGetApp().m_parse_waitingUntilAllDone = false;
+            wxGetApp().m_parse_semAllDone.Post();
+        }
+    }
+}
+
+void *OPJParseThread::Entry()
+{
+
+	printf("Entering\n\n");
+
+    wxString text;
+
+	srand(GetId());
+	int m_countnum = rand() % 9;
+    text.Printf(wxT("Parse thread 0x%lx started (priority = %u, time = %d)."),
+            GetId(), GetPriority(), m_countnum);
+    WriteText(text);
+    LoadFile(m_tree->m_fname);
+    text.Printf(wxT("Parse thread 0x%lx finished."), GetId());
+    WriteText(text);
+
+
+    //wxLogMessage(wxT("Entering\n")); //test wxLog thread safeness
+
+	//wxBusyCursor wait;
+	//wxBusyInfo wait(wxT("Decoding image ..."));
+
+
+    /*for ( m_count = 0; m_count < m_countnum; m_count++ )
+    {
+        // check if we were asked to exit
+        if ( TestDestroy() )
+            break;
+
+        text.Printf(wxT("[%u] Parse thread 0x%lx here."), m_count, GetId());
+        WriteText(text);
+
+        // wxSleep() can't be called from non-GUI thread!
+        wxThread::Sleep(10);
+    }*/
+
+    // wxLogMessage(text); -- test wxLog thread safeness
+
+	printf("Exiting\n\n");
+
+    return NULL;
+}
+
+
+
+
+
+
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.h.svn-base ./OPJViewer/source/.svn/text-base/OPJViewer.h.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.h.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJViewer.h.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,764 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+/////////////////////////////////////////////////////////////////////////////
+// Name:        sashtest.h
+// Purpose:     Layout window/sash sample
+// Author:      Julian Smart
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: sashtest.h,v 1.5 2005/06/02 12:04:24 JS Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        treectrl.h
+// Purpose:     wxTreeCtrl sample
+// Author:      Julian Smart
+// Modified by:
+// Created:     04/01/98
+// RCS-ID:      $Id: treetest.h,v 1.50 2006/11/04 11:26:51 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+/////////////////////////////////////////////////////////////////////////////
+// Name:        dialogs.h
+// Purpose:     Common dialogs demo
+// Author:      Julian Smart
+// Modified by: ABX (2004) - adjustementd for conditional building
+// Created:     04/01/98
+// RCS-ID:      $Id: dialogs.h,v 1.50 2006/10/08 14:12:59 VZ Exp $
+// Copyright:   (c) Julian Smart
+// Licence:     wxWindows license
+/////////////////////////////////////////////////////////////////////////////
+
+#ifndef __OPJ_VIEWER_H__
+#define __OPJ_VIEWER_H__
+
+// For compilers that support precompilation, includes "wx/wx.h".
+#include "wx/wxprec.h"
+
+#ifdef __BORLANDC__
+#pragma hdrstop
+#endif
+
+#ifndef WX_PRECOMP
+#include "wx/wx.h"
+#include "wx/mdi.h"
+#endif
+
+#include "wx/toolbar.h"
+#include "wx/laywin.h"
+#include "wx/treectrl.h"
+
+#include "icon1.xpm"
+#include "icon2.xpm"
+#include "icon3.xpm"
+#include "icon4.xpm"
+#include "icon5.xpm"
+
+#include "wx/filedlg.h"
+#include "wx/toolbar.h"
+#include <wx/filename.h>
+#include <wx/busyinfo.h>
+#include <wx/cmdline.h>
+#include <wx/file.h>
+#include "wx/notebook.h"
+#include <wx/numdlg.h>
+
+#include "wx/propdlg.h"
+#include "wx/spinctrl.h"
+
+#include <wx/dnd.h>
+#include "wx/wxhtml.h"
+#include "wx/statline.h"
+#include <wx/fs_mem.h>
+
+#include <wx/imaglist.h>
+
+#include "wx/toolbar.h"
+#include "wx/artprov.h"
+
+#include "libopenjpeg/openjpeg.h"
+
+#include "imagj2k.h"
+#include "imagjp2.h"
+#include "imagmj2.h"
+
+#ifdef __WXMSW__
+typedef unsigned __int64 int8byte;
+#endif // __WXMSW__
+
+#ifdef __WXGTK__
+typedef unsigned long long int8byte;
+#endif // __WXGTK__
+
+#define USE_GENERIC_TREECTRL 0
+#define USE_PENCIL_ON_CANVAS 0
+
+#if USE_GENERIC_TREECTRL
+#include "wx/generic/treectlg.h"
+#ifndef wxTreeCtrl
+#define wxTreeCtrl wxGenericTreeCtrl
+#define sm_classwxTreeCtrl sm_classwxGenericTreeCtrl
+#endif
+#endif
+
+#define OPJ_APPLICATION             wxT("OPJViewer")
+#define OPJ_APPLICATION_NAME		wxT("OpenJPEG Viewer")
+#define OPJ_APPLICATION_VERSION		wxT("0.3 alpha")
+#define OPJ_APPLICATION_TITLEBAR	OPJ_APPLICATION_NAME wxT(" ") OPJ_APPLICATION_VERSION
+#define OPJ_APPLICATION_COPYRIGHT	wxT("(C) 2007, Giuseppe Baruffa")
+#define OPJ_APPLICATION_VENDOR      wxT("OpenJPEG")
+
+#ifdef __WXMSW__
+#define OPJ_APPLICATION_PLATFORM    wxT("Windows")
+#endif
+
+#ifdef __WXGTK__
+#define OPJ_APPLICATION_PLATFORM    wxT("Linux")
+#endif
+
+#define OPJ_FRAME_WIDTH   800
+#define OPJ_FRAME_HEIGHT  600
+
+#define OPJ_BROWSER_WIDTH 300
+#define OPJ_PEEKER_HEIGHT 130
+
+#define OPJ_CANVAS_BORDER 10
+#define OPJ_CANVAS_COLOUR *wxWHITE
+
+class OPJDecoThread;
+class OPJEncoThread;
+class OPJParseThread;
+WX_DEFINE_ARRAY_PTR(wxThread *, wxArrayThread);
+class OPJChildFrame;
+
+//////////////////////////////////
+// this is our main application //
+//////////////////////////////////
+class OPJViewerApp: public wxApp
+{
+	// public methods and variables
+	public:
+
+		// class constructor
+		OPJViewerApp() { m_showImages = true; m_showButtons = false; }
+
+		// other methods
+		bool OnInit(void);
+		int OnExit(void);
+		void SetShowImages(bool show) { m_showImages = show; }
+		bool ShowImages() const { return m_showImages; }
+		void ShowCmdLine(const wxCmdLineParser& parser);
+
+		// all the threads currently alive - as soon as the thread terminates, it's
+		// removed from the array
+		wxArrayThread m_deco_threads, m_parse_threads, m_enco_threads;
+
+		// crit section protects access to all of the arrays below
+		wxCriticalSection m_deco_critsect, m_parse_critsect, m_enco_critsect;
+
+		// semaphore used to wait for the threads to exit, see OPJFrame::OnQuit()
+		wxSemaphore m_deco_semAllDone, m_parse_semAllDone, m_enco_semAllDone;
+
+		// the last exiting thread should post to m_semAllDone if this is true
+		// (protected by the same m_critsect)
+		bool m_deco_waitingUntilAllDone, m_parse_waitingUntilAllDone, m_enco_waitingUntilAllDone;
+
+		// the list of all filenames written in the command line
+		wxArrayString m_filelist;
+
+		// displaying engine parameters
+		int m_resizemethod;
+
+		// decoding engine parameters
+		bool m_enabledeco, m_enableparse;
+		int m_reducefactor, m_qualitylayers, m_components, m_framenum;
+#ifdef USE_JPWL
+		bool m_enablejpwl;
+		int m_expcomps, m_maxtiles;
+		int m_framewidth, m_frameheight;
+#endif // USE_JPWL
+
+		// encoding engine parameters
+		wxString m_subsampling, m_origin, m_rates, m_comment, m_index, m_quality;
+		wxString m_cbsize, m_prsize, m_tsize, m_torigin;
+		bool m_enablecomm, m_enableidx, m_multicomp, m_irreversible, m_enablesop, m_enableeph;
+		bool m_enablebypass, m_enablereset, m_enablerestart, m_enablevsc, m_enableerterm;
+		bool m_enablesegmark;
+		bool m_enablequality;
+		int m_resolutions, m_progression;
+
+		// some layout settings
+		bool m_showtoolbar, m_showbrowser, m_showpeeker;
+		int m_browserwidth, m_peekerheight;
+
+		// application configuration
+		wxConfig *OPJconfig; 
+
+	// private methods and variables
+	private:
+		bool m_showImages, m_showButtons;
+
+};
+
+DECLARE_APP(OPJViewerApp)
+
+///////////////////////////////////////////
+// this canvas is used to draw the image //
+///////////////////////////////////////////
+class OPJCanvas: public wxScrolledWindow
+{
+	// public methods and variables
+	public:
+
+		// class constructor
+		OPJCanvas(wxFileName fname, wxWindow *parent, const wxPoint& pos, const wxSize& size);
+
+		virtual void OnDraw(wxDC& dc);
+		void OnEvent(wxMouseEvent& event);
+		void WriteText(const wxString& text) {
+#ifndef __WXGTK__ 
+			wxMutexGuiEnter();
+#endif //__WXGTK__
+			wxLogMessage(text);
+#ifndef __WXGTK__ 
+			wxMutexGuiLeave();
+#endif //__WXGTK__
+		}
+		OPJDecoThread *CreateDecoThread(void);
+		OPJEncoThread *CreateEncoThread(void);
+		OPJChildFrame *m_childframe;
+
+		wxBitmap  m_image, m_image100;
+		wxFileName m_fname, m_savename;
+		long m_zooml;
+
+	DECLARE_EVENT_TABLE()
+};
+
+///////////////////////////////////////////////////
+// the data associated to each tree leaf or node //
+///////////////////////////////////////////////////
+class OPJMarkerData : public wxTreeItemData
+{
+	// public methods and variables
+	public:
+
+		// class constructor
+		OPJMarkerData(const wxString& desc, const wxString& fname = wxT(""), wxFileOffset start = 0, wxFileOffset length = 0) : m_desc(desc), m_filestring(fname) { m_start = start; m_length = length; }
+
+		void ShowInfo(wxTreeCtrl *tree);
+		const wxChar *GetDesc1() const { return m_desc.c_str(); }
+		const wxChar *GetDesc2() const { return m_filestring.c_str(); }
+		wxFileOffset m_start, m_length;
+		wxString m_desc;
+
+	// private methods and variables
+	private:
+		wxString m_filestring;
+};
+
+
+class OPJMarkerTree : public wxTreeCtrl
+{
+public:
+    enum
+    {
+        TreeCtrlIcon_File,
+        TreeCtrlIcon_FileSelected,
+        TreeCtrlIcon_Folder,
+        TreeCtrlIcon_FolderSelected,
+        TreeCtrlIcon_FolderOpened
+    };
+
+    OPJMarkerTree() { };
+    OPJMarkerTree(wxWindow *parent, OPJChildFrame *subframe, wxFileName fname, wxString name, const wxWindowID id,
+               const wxPoint& pos, const wxSize& size,
+               long style);
+    virtual ~OPJMarkerTree(){};
+	OPJParseThread *CreateParseThread(wxTreeItemId parentid = 0x00, OPJChildFrame *subframe = NULL);
+    void WriteText(const wxString& text) { wxMutexGuiEnter(); wxLogMessage(text); wxMutexGuiLeave(); }
+
+	wxFileName m_fname;
+	wxTextCtrl *m_peektextCtrl;
+	OPJChildFrame *m_childframe;
+
+    /*void OnBeginDrag(wxTreeEvent& event);
+    void OnBeginRDrag(wxTreeEvent& event);
+    void OnEndDrag(wxTreeEvent& event);*/
+    /*void OnBeginLabelEdit(wxTreeEvent& event);
+    void OnEndLabelEdit(wxTreeEvent& event);*/
+    /*void OnDeleteItem(wxTreeEvent& event);*/
+    /*void OnContextMenu(wxContextMenuEvent& event);*/
+    void OnItemMenu(wxTreeEvent& event);
+    /*void OnGetInfo(wxTreeEvent& event);
+    void OnSetInfo(wxTreeEvent& event);*/
+    /*void OnItemExpanded(wxTreeEvent& event);*/
+    void OnItemExpanding(wxTreeEvent& event);
+    /*void OnItemCollapsed(wxTreeEvent& event);
+    void OnItemCollapsing(wxTreeEvent& event);*/
+    void OnSelChanged(wxTreeEvent& event);
+    /*void OnSelChanging(wxTreeEvent& event);*/
+    /*void OnTreeKeyDown(wxTreeEvent& event);*/
+    /*void OnItemActivated(wxTreeEvent& event);*/
+    /*void OnItemRClick(wxTreeEvent& event);*/
+    /*void OnRMouseDown(wxMouseEvent& event);
+    void OnRMouseUp(wxMouseEvent& event);
+    void OnRMouseDClick(wxMouseEvent& event);*/
+    /*void GetItemsRecursively(const wxTreeItemId& idParent,
+                             wxTreeItemIdValue cookie = 0);*/
+
+    void CreateImageList(int size = 16);
+    void CreateButtonsImageList(int size = 11);
+
+    /*void AddTestItemsToTree(size_t numChildren, size_t depth);*/
+    /*void DoSortChildren(const wxTreeItemId& item, bool reverse = false)
+        { m_reverseSort = reverse; wxTreeCtrl::SortChildren(item); }*/
+    /*void DoEnsureVisible() { if (m_lastItem.IsOk()) EnsureVisible(m_lastItem); }*/
+    /*void DoToggleIcon(const wxTreeItemId& item);*/
+    /*void ShowMenu(wxTreeItemId id, const wxPoint& pt);*/
+
+    int ImageSize(void) const { return m_imageSize; }
+
+    void SetLastItem(wxTreeItemId id) { m_lastItem = id; }
+
+protected:
+    /*virtual int OnCompareItems(const wxTreeItemId& i1, const wxTreeItemId& i2);*/
+
+    // is this the test item which we use in several event handlers?
+    /*bool IsTestItem(const wxTreeItemId& item)
+    {
+        // the test item is the first child folder
+        return GetItemParent(item) == GetRootItem() && !GetPrevSibling(item);
+    }*/
+
+private:
+    /*void AddItemsRecursively(const wxTreeItemId& idParent,
+                             size_t nChildren,
+                             size_t depth,
+                             size_t folder);*/
+
+    void LogEvent(const wxChar *name, const wxTreeEvent& event);
+
+    int          m_imageSize;               // current size of images
+    bool         m_reverseSort;             // flag for OnCompareItems
+    wxTreeItemId m_lastItem,                // for OnEnsureVisible()
+                 m_draggedItem;             // item being dragged right now
+
+    // NB: due to an ugly wxMSW hack you _must_ use DECLARE_DYNAMIC_CLASS()
+    //     if you want your overloaded OnCompareItems() to be called.
+    //     OTOH, if you don't want it you may omit the next line - this will
+    //     make default (alphabetical) sorting much faster under wxMSW.
+    DECLARE_DYNAMIC_CLASS(OPJMarkerTree)
+    DECLARE_EVENT_TABLE()
+};
+
+// this hash map stores all the trees of currently opened images, with an integer key
+WX_DECLARE_HASH_MAP(int, OPJMarkerTree*, wxIntegerHash, wxIntegerEqual, OPJMarkerTreeHash);
+
+// this hash map stores all the children of currently opened images, with an integer key
+WX_DECLARE_HASH_MAP(int, OPJChildFrame*, wxIntegerHash, wxIntegerEqual, OPJChildFrameHash);
+
+// Define a new frame
+class OPJFrame: public wxMDIParentFrame
+{
+  public:
+
+    OPJFrame(wxWindow *parent, const wxWindowID id, const wxString& title, const wxPoint& pos, const wxSize& size, const long style);
+
+    ~OPJFrame(void);
+	void OnSize(wxSizeEvent& WXUNUSED(event));
+    void OnAbout(wxCommandEvent& WXUNUSED(event));
+    void OnFileOpen(wxCommandEvent& WXUNUSED(event));
+    void OnFileSaveAs(wxCommandEvent& WXUNUSED(event));
+    void OnMemoryOpen(wxCommandEvent& WXUNUSED(event));
+    void OnQuit(wxCommandEvent& WXUNUSED(event));
+    void OnClose(wxCommandEvent& WXUNUSED(event));
+    void OnZoom(wxCommandEvent& WXUNUSED(event));
+	void OnFit(wxCommandEvent& WXUNUSED(event));
+	void OnToggleBrowser(wxCommandEvent& WXUNUSED(event));
+	void OnTogglePeeker(wxCommandEvent& WXUNUSED(event));
+	void OnToggleToolbar(wxCommandEvent& WXUNUSED(event));
+	void OnReload(wxCommandEvent& event);
+	void OnPrevFrame(wxCommandEvent& event);
+	void OnHomeFrame(wxCommandEvent& event);
+	void OnNextFrame(wxCommandEvent& event);
+	void OnLessLayers(wxCommandEvent& event);
+	void OnAllLayers(wxCommandEvent& event);
+	void OnMoreLayers(wxCommandEvent& event);
+	void OnLessRes(wxCommandEvent& event);
+	void OnFullRes(wxCommandEvent& event);
+	void OnMoreRes(wxCommandEvent& event);
+	void OnPrevComp(wxCommandEvent& event);
+	void OnAllComps(wxCommandEvent& event);
+	void OnNextComp(wxCommandEvent& event);
+	void OnSetsEnco(wxCommandEvent& event);
+	void OnSetsDeco(wxCommandEvent& event);
+	void OnSashDrag(wxSashEvent& event);
+	void OpenFiles(wxArrayString paths, wxArrayString filenames);
+	void SaveFile(wxArrayString paths, wxArrayString filenames);
+	void OnNotebook(wxNotebookEvent& event);
+	void Rescale(int scale, OPJChildFrame *child);
+
+	OPJMarkerTreeHash m_treehash;
+	OPJChildFrameHash m_childhash;
+    wxSashLayoutWindow* markerTreeWindow;
+    wxSashLayoutWindow* loggingWindow;
+	wxToolBar* tool_bar;
+    void Resize(int number);
+	wxNotebook *m_bookCtrl;
+	wxNotebook *m_bookCtrlbottom;
+    wxTextCtrl *m_textCtrlbrowse;
+
+  private:
+    void TogStyle(int id, long flag);
+
+    void DoSort(bool reverse = false);
+
+    wxPanel *m_panel;
+    wxTextCtrl *m_textCtrl;
+
+    void DoSetBold(bool bold = true);
+
+protected:
+    wxSashLayoutWindow* m_topWindow;
+    wxSashLayoutWindow* m_leftWindow2;
+
+DECLARE_EVENT_TABLE()
+};
+
+class OPJChildFrame: public wxMDIChildFrame
+{
+  public:
+    OPJCanvas *m_canvas;
+    OPJChildFrame(OPJFrame *parent, wxFileName fname, int winnumber, const wxString& title, const wxPoint& pos, const wxSize& size, const long style);
+    ~OPJChildFrame(void);
+    void OnActivate(wxActivateEvent& event);
+	/*void OnQuit(wxCommandEvent& WXUNUSED(event));*/
+	void OnClose(wxCloseEvent& event);
+	void OnGotFocus(wxFocusEvent& event);
+	void OnLostFocus(wxFocusEvent& event);
+    OPJFrame *m_frame;
+	wxFileName m_fname;
+	int m_winnumber;
+
+	unsigned long  m_twidth, m_theight, m_tx, m_ty;
+
+	DECLARE_EVENT_TABLE()
+};
+
+// frame and main menu ids
+enum {
+	OPJFRAME_FILEEXIT = wxID_EXIT,
+	OPJFRAME_HELPABOUT = wxID_ABOUT,
+	OPJFRAME_FILEOPEN,
+	OPJFRAME_MEMORYOPEN,
+	OPJFRAME_FILESAVEAS,
+	OPJFRAME_FILETOGGLEB,
+	OPJFRAME_FILETOGGLEP,
+	OPJFRAME_FILETOGGLET,
+	OPJFRAME_VIEWZOOM,
+	OPJFRAME_VIEWFIT,
+	OPJFRAME_VIEWRELOAD,
+	OPJFRAME_VIEWPREVFRAME,
+	OPJFRAME_VIEWHOMEFRAME,
+	OPJFRAME_VIEWNEXTFRAME,
+	OPJFRAME_VIEWLESSLAYERS,
+	OPJFRAME_VIEWALLLAYERS,
+	OPJFRAME_VIEWMORELAYERS,
+	OPJFRAME_VIEWLESSRES,
+	OPJFRAME_VIEWFULLRES,
+	OPJFRAME_VIEWMORERES,
+	OPJFRAME_VIEWPREVCOMP,
+	OPJFRAME_VIEWALLCOMPS,
+	OPJFRAME_VIEWNEXTCOMP,
+	OPJFRAME_FILECLOSE,
+	OPJFRAME_SETSENCO,
+	OPJFRAME_SETSDECO,
+
+	OPJFRAME_BROWSEWIN = 10000,
+	OPJFRAME_LOGWIN,
+	OPJFRAME_TOOLBAR
+};
+
+
+// menu and control ids
+enum
+{
+    TreeTest_Quit = wxID_EXIT,
+    TreeTest_About = wxID_ABOUT,
+    TreeTest_TogButtons = wxID_HIGHEST,
+    TreeTest_TogTwist,
+    TreeTest_TogLines,
+    TreeTest_TogEdit,
+    TreeTest_TogHideRoot,
+    TreeTest_TogRootLines,
+    TreeTest_TogBorder,
+    TreeTest_TogFullHighlight,
+    TreeTest_SetFgColour,
+    TreeTest_SetBgColour,
+    TreeTest_ResetStyle,
+    TreeTest_Highlight,
+    TreeTest_Dump,
+    TreeTest_DumpSelected,
+    TreeTest_Count,
+    TreeTest_CountRec,
+    TreeTest_Sort,
+    TreeTest_SortRev,
+    TreeTest_SetBold,
+    TreeTest_ClearBold,
+    TreeTest_Rename,
+    TreeTest_Delete,
+    TreeTest_DeleteChildren,
+    TreeTest_DeleteAll,
+    TreeTest_Recreate,
+    TreeTest_ToggleImages,
+    TreeTest_ToggleButtons,
+    TreeTest_SetImageSize,
+    TreeTest_ToggleSel,
+    TreeTest_CollapseAndReset,
+    TreeTest_EnsureVisible,
+    TreeTest_AddItem,
+    TreeTest_InsertItem,
+    TreeTest_IncIndent,
+    TreeTest_DecIndent,
+    TreeTest_IncSpacing,
+    TreeTest_DecSpacing,
+    TreeTest_ToggleIcon,
+    TreeTest_Select,
+    TreeTest_Unselect,
+    TreeTest_SelectRoot,
+    TreeTest_Ctrl = 1000,
+	BOTTOM_NOTEBOOK_ID,
+	LEFT_NOTEBOOK_ID
+};
+
+class OPJEncoThread : public wxThread
+{
+public:
+    OPJEncoThread(OPJCanvas *canvas);
+
+    // thread execution starts here
+    virtual void *Entry();
+
+    // called when the thread exits - whether it terminates normally or is
+    // stopped with Delete() (but not when it is Kill()ed!)
+    virtual void OnExit();
+
+    // write something to the text control
+    void WriteText(const wxString& text);
+
+public:
+    unsigned m_count;
+    OPJCanvas *m_canvas;
+};
+
+class OPJDecoThread : public wxThread
+{
+public:
+    OPJDecoThread(OPJCanvas *canvas);
+
+    // thread execution starts here
+    virtual void *Entry();
+
+    // called when the thread exits - whether it terminates normally or is
+    // stopped with Delete() (but not when it is Kill()ed!)
+    virtual void OnExit();
+
+    // write something to the text control
+    void WriteText(const wxString& text);
+
+public:
+    unsigned m_count;
+    OPJCanvas *m_canvas;
+};
+
+class OPJParseThread : public wxThread
+{
+public:
+    OPJParseThread(OPJMarkerTree *tree, wxTreeItemId parentid = 0x00);
+
+    // thread execution starts here
+    virtual void *Entry();
+
+    // called when the thread exits - whether it terminates normally or is
+    // stopped with Delete() (but not when it is Kill()ed!)
+    virtual void OnExit();
+
+    // write something to the text control
+    void WriteText(const wxString& text);
+	void LoadFile(wxFileName fname);
+	void ParseJ2KFile(wxFile *m_file, wxFileOffset offset, wxFileOffset length, wxTreeItemId parentid);
+	void ParseJP2File(wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit, wxTreeItemId parentid);
+
+    unsigned m_count;
+    OPJMarkerTree *m_tree;
+	wxTreeItemId m_parentid;
+
+private:
+	int jpeg2000parse(wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit,
+			wxTreeItemId parentid, int level, char *scansign, unsigned long int *scanpoint);
+	int box_handler_function(int boxtype, wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit,
+			wxTreeItemId parentid, int level, char *scansign, unsigned long int *scanpoint);
+
+};
+
+
+// Drag and drop files target
+class OPJDnDFile: public wxFileDropTarget
+{
+public:
+    OPJDnDFile(OPJFrame *pOwner) { m_pOwner = pOwner; }
+    virtual bool OnDropFiles(wxCoord x, wxCoord y, const wxArrayString& filenames);
+
+private:
+    OPJFrame *m_pOwner;
+};
+
+
+
+// Property sheet dialog: encoder
+class OPJEncoderDialog: public wxPropertySheetDialog
+{
+DECLARE_CLASS(OPJEncoderDialog)
+public:
+    OPJEncoderDialog(wxWindow* parent, int dialogType);
+    ~OPJEncoderDialog();
+
+	wxBookCtrlBase* m_settingsNotebook;
+
+    wxPanel* CreateMainSettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1_2SettingsPage(wxWindow* parent);
+/*    wxPanel* CreatePart3SettingsPage(wxWindow* parent);*/
+#ifdef USE_JPWL
+	void OnEnableJPWL(wxCommandEvent& event);
+	void OnEnableComm(wxCommandEvent& event);
+	void OnEnableIdx(wxCommandEvent& event);
+	void OnRadioQualityRate(wxCommandEvent& event);
+	wxPanel* CreatePart11SettingsPage(wxWindow* parent);
+	/*wxCheckBox *m_enablejpwlCheck;*/
+#endif // USE_JPWL
+
+	wxTextCtrl *m_subsamplingCtrl, *m_originCtrl, *m_rateCtrl, *m_commentCtrl;
+	wxRadioButton *m_rateRadio, *m_qualityRadio;
+	wxTextCtrl *m_indexCtrl, *m_qualityCtrl, *m_cbsizeCtrl, *m_prsizeCtrl, *m_pocCtrl;
+	wxTextCtrl *m_tsizeCtrl, *m_toriginCtrl;
+	wxRadioBox *progressionBox;
+	wxCheckBox *m_enablecommCheck, *m_enableidxCheck, *m_mctCheck, *m_irrevCheck;
+	wxCheckBox *m_sopCheck, *m_ephCheck, *m_enablebypassCheck, *m_enableresetCheck,
+		*m_enablerestartCheck, *m_enablevscCheck, *m_enableertermCheck, *m_enablesegmarkCheck;
+	wxCheckBox *m_enablepocCheck;
+	wxSpinCtrl *m_resolutionsCtrl;
+
+protected:
+
+    enum {
+		OPJENCO_ENABLEJPWL = 100,
+		OPJENCO_RATEFACTOR,
+		OPJENCO_RATERADIO,
+		OPJENCO_QUALITYFACTOR,
+		OPJENCO_QUALITYRADIO,
+		OPJENCO_RESNUMBER,
+		OPJENCO_CODEBLOCKSIZE,
+		OPJENCO_PRECINCTSIZE,
+		OPJENCO_TILESIZE,
+		OPJENCO_PROGRESSION,
+		OPJENCO_SUBSAMPLING,
+		OPJENCO_ENABLESOP,
+		OPJENCO_ENABLEEPH,
+		OPJENCO_ENABLEBYPASS,
+		OPJENCO_ENABLERESET,
+		OPJENCO_ENABLERESTART,
+		OPJENCO_ENABLEVSC,
+		OPJENCO_ENABLEERTERM,
+		OPJENCO_ENABLESEGMARK,
+		OPJENCO_ENABLEPOC,
+		OPJENCO_ROICOMP,
+		OPJENCO_ROISHIFT,
+		OPJENCO_IMORIG,
+		OPJENCO_TILORIG,
+		OPJENCO_ENABLEMCT,
+		OPJENCO_ENABLEIRREV,
+		OPJENCO_ENABLEINDEX,
+		OPJENCO_INDEXNAME,
+		OPJENCO_POCSPEC,
+		OPJENCO_ENABLECOMM,
+		OPJENCO_COMMENTTEXT
+    };
+
+DECLARE_EVENT_TABLE()
+};
+
+// Property sheet dialog: decoder
+class OPJDecoderDialog: public wxPropertySheetDialog
+{
+DECLARE_CLASS(OPJDecoderDialog)
+public:
+    OPJDecoderDialog(wxWindow* parent, int dialogType);
+    ~OPJDecoderDialog();
+
+	wxBookCtrlBase* m_settingsNotebook;
+	wxCheckBox *m_enabledecoCheck, *m_enableparseCheck;
+	wxSpinCtrl *m_reduceCtrl, *m_layerCtrl, *m_numcompsCtrl;
+	wxRadioBox* m_resizeBox;
+
+	void OnEnableDeco(wxCommandEvent& event);
+
+    wxPanel* CreateMainSettingsPage(wxWindow* parent);
+    wxPanel* CreatePart1SettingsPage(wxWindow* parent);
+    wxPanel* CreatePart3SettingsPage(wxWindow* parent);
+#ifdef USE_JPWL
+	void OnEnableJPWL(wxCommandEvent& event);
+    wxPanel* CreatePart11SettingsPage(wxWindow* parent);
+	wxSpinCtrl *m_expcompsCtrl, *m_framenumCtrl, *m_maxtilesCtrl;
+	wxCheckBox *m_enablejpwlCheck;
+#endif // USE_JPWL
+
+
+protected:
+
+    enum {
+		OPJDECO_RESMETHOD = 100,
+		OPJDECO_REDUCEFACTOR,
+		OPJDECO_QUALITYLAYERS,
+		OPJDECO_NUMCOMPS,
+		OPJDECO_ENABLEDECO,
+		OPJDECO_ENABLEPARSE,
+		OPJDECO_ENABLEJPWL,
+		OPJDECO_EXPCOMPS,
+		OPJDECO_MAXTILES,
+		OPJDECO_FRAMENUM
+    };
+
+DECLARE_EVENT_TABLE()
+};
+
+#endif //__OPJ_VIEWER_H__
+
+
+
Binary files /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.ico.svn-base and ./OPJViewer/source/.svn/text-base/OPJViewer.ico.svn-base differ
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.rc.svn-base ./OPJViewer/source/.svn/text-base/OPJViewer.rc.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/OPJViewer.rc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/OPJViewer.rc.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,3 @@
+OPJChild16 ICON OPJChild.ico
+OPJViewer16 ICON OPJViewer.ico
+#include "wx/msw/wx.rc"
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/readmeafter.txt.svn-base ./OPJViewer/source/.svn/text-base/readmeafter.txt.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/readmeafter.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/readmeafter.txt.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,34 @@
+This viewer is conceived to open and display information and image content of J2K, JP2,
+and MJ2 files.
+The viewer application interface is divided into three main panels:
+- a browsing pane;
+- a viewing pane;
+- a log/peek pane.
+
+The browsing pane will present the markers or boxes hierarchy, with position (byte number where marker/box starts and stops) and length information (i.e., inner length as signalled by marker/box and total length, with marker/box sign included), in the following form:
+
+filename
+|
+|_ #000: Marker/Box short name (Hex code)
+|  |
+|  |_ *** Marker/Box long name ***
+|  |_ startbyte > stopbyte, inner_length + marker/box sign length (total length)
+|  |_ Additional info, depending on the marker/box type
+|  |_ ...
+|
+|_ #001: Marker/Box short name (Hex code)
+|  |
+|  |_ ...
+|
+...
+
+
+The viewing pane will display the decoded image contained in the JPEG 2000 file.
+It should display correctly images as large as 4000x2000, provided that a couple of GB of RAM are available. Nothing is known about the display of larger sizes: let us know if you manage to get it working.
+
+
+The log/peek pane is shared among two different subpanels:
+
+- the log panel will report a lot of debugging info coming out from the wx GUI as well as from the openjpeg library
+- the peek pane tries to give a peek on the codestream/file portion which is currently selected in the browsing pane. It shows both hex and ascii values corresponding to the marker/box section. 
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/readmebefore.txt.svn-base ./OPJViewer/source/.svn/text-base/readmebefore.txt.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/readmebefore.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/readmebefore.txt.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,11 @@
+What is OpenJPEG ?
+==================
+The OpenJPEG library is an open-source JPEG 2000 codec written in C language. It has been developed in order to promote the use of JPEG 2000, the new still-image compression standard from the Joint Photographic Experts Group (JPEG). In addition to the basic codec, various other features are under development, among them the JP2 and MJ2 (Motion JPEG 2000) file formats, an indexing tool useful for the JPIP protocol, JPWL-tools for error-resilience, a Java-viewer for j2k-images, ... 
+
+Who can use the library ?
+=========================
+Anybody. As the OpenJPEG library is released under the BSD license, anybody can use or modify the library, even for commercial applications. The only restriction is to retain the copyright in the sources or the binaries documentation.
+
+Who is developing the library ?
+===============================
+The library is developed by the Communications and Remote Sensing Lab (TELE), in the Université Catholique de Louvain (UCL). The JPWL module is developped and maintained by the Digital Signal Processing Lab (DSPLab) of the University of Perugia, Italy (UNIPG). As our purpose is to make OpenJPEG really useful for those interested in the image compression field, any feedback/advices are obviously welcome ! We will do our best to handle them quickly. 
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/wxj2kparser.cpp.svn-base ./OPJViewer/source/.svn/text-base/wxj2kparser.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/wxj2kparser.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/wxj2kparser.cpp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,1465 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "OPJViewer.h"
+
+/* From little endian to big endian, 2 bytes */
+#define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
+#define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
+
+/* From codestream to int values */
+#define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
+								((unsigned long int) (C)[(P) + 1] << 16) + \
+								((unsigned long int) (C)[(P) + 2] << 8) + \
+								((unsigned long int) (C)[(P) + 3] << 0))
+
+#define STREAM_TO_UINT16(C, P)	(((unsigned long int) (C)[(P) + 0] << 8) + \
+								((unsigned long int) (C)[(P) + 1] << 0))
+
+
+/* Markers values */
+#define J2KMARK_NUM 24
+enum {
+	SOC_VAL = 0xFF4F,
+	SOT_VAL	= 0xFF90,
+	SOD_VAL = 0xFF93,
+	EOC_VAL	= 0xFFD9,
+	SIZ_VAL	= 0xFF51,
+	COD_VAL	= 0xFF52,
+	COC_VAL = 0xFF53,
+	RGN_VAL = 0xFF5E,
+	QCD_VAL	= 0xFF5C,
+	QCC_VAL	= 0xFF5D,
+	POD_VAL	= 0xFF5F,
+	TLM_VAL	= 0xFF55,
+	PLM_VAL	= 0xFF57,
+	PLT_VAL	= 0xFF58,
+	PPM_VAL	= 0xFF60,
+	PPT_VAL	= 0xFF61,
+	SOP_VAL	= 0xFF91,
+	EPH_VAL	= 0xFF92,
+	COM_VAL	= 0xFF64
+#ifdef USE_JPWL
+	, EPB_VAL	= 0xFF66,
+	ESD_VAL	= 0xFF67,
+	EPC_VAL	= 0xFF68,
+	RED_VAL	= 0xFF69
+	/*, EPB_VAL = 0xFF96,
+	ESD_VAL	= 0xFF98,
+	EPC_VAL	= 0xFF97,
+	RED_VAL	= 0xFF99*/
+#endif // USE_JPWL
+#ifdef USE_JPSEC
+	, SEC_VAL = 0xFF65
+#endif // USE_JPSEC
+};
+
+// All the markers in one vector
+unsigned short int marker_val[] = {
+	SOC_VAL, SOT_VAL, SOD_VAL, EOC_VAL,
+	SIZ_VAL,
+	COD_VAL, COC_VAL, RGN_VAL, QCD_VAL, QCC_VAL, POD_VAL,
+	TLM_VAL, PLM_VAL, PLT_VAL, PPM_VAL, PPT_VAL,
+	SOP_VAL, EPH_VAL,
+	COM_VAL
+#ifdef USE_JPWL
+	, EPB_VAL, ESD_VAL, EPC_VAL, RED_VAL
+#endif // USE_JPWL
+#ifdef USE_JPSEC
+	, SEC_VAL
+#endif // USE_JPSEC
+};
+
+// Marker names
+char *marker_name[] = {
+	"SOC", "SOT", "SOD", "EOC",
+	"SIZ",
+	"COD", "COC", "RGN", "QCD", "QCC", "POD",
+	"TLM", "PLM", "PLT", "PPM", "PPT",
+	"SOP", "EPH",
+	"COM"
+#ifdef USE_JPWL
+	, "EPB", "ESD", "EPC", "RED"
+#endif // USE_JPWL
+#ifdef USE_JPSEC
+	, "SEC"
+#endif // USE_JPSEC
+};
+
+// Marker descriptions
+char *marker_descr[] = {
+	"Start of codestream", "Start of tile-part", "Start of data", "End of codestream",
+	"Image and tile size",
+	"Coding style default", "Coding style component", "Region-of-interest", "Quantization default",
+	"Quantization component", "Progression order change, default",
+	"Tile-part lengths, main header", "Packet length, main header", "Packets length, tile-part header",
+	"Packed packet headers, main header", "Packed packet headers, tile-part header",
+	"Start of packet", "End of packet header",
+	"Comment and extension"
+#ifdef USE_JPWL
+	, "Error Protection Block", "Error Sensitivity Descriptor", "Error Protection Capability",
+	"Residual Errors Descriptor"
+#endif // USE_JPWL
+#ifdef USE_JPSEC
+	, "Main security marker"
+#endif // USE_JPSEC
+};
+
+void OPJParseThread::ParseJ2KFile(wxFile *m_file, wxFileOffset offset, wxFileOffset length, wxTreeItemId parentid)
+{
+	unsigned short int csiz = 0;
+
+	// check if the file is opened
+	if (m_file->IsOpened())
+		WriteText(wxT("File OK"));
+	else
+		return;
+
+	// position at the beginning
+	m_file->Seek(offset, wxFromStart);
+
+	// navigate the file
+	int m, inside_sod = 0, inside_sop = 0;
+	int nmarks = 0, maxmarks = 10000;
+	unsigned char onebyte[1];
+	unsigned char twobytes[2], firstbyte, secondbyte;
+	unsigned char fourbytes[4];
+	unsigned short int currmark;
+	unsigned short int currlen;
+	int lastPsot = 0, lastsotpos = 0;
+
+	WriteText(wxT("Start search..."));
+
+// advancing macro
+#define OPJ_ADVANCE(A) {offset += A; if (offset < length) m_file->Seek(offset, wxFromStart); else return;}
+
+	// begin search
+	while ((offset < length) && (!m_file->Eof())) {
+
+		// read one byte
+		if (m_file->Read(&firstbyte, 1) != 1)
+			break;
+
+		// look for 0xFF
+		if (firstbyte == 0xFF) {
+
+			// it is a possible marker
+			if (m_file->Read(&secondbyte, 1) != 1)
+				break;
+			else
+				currmark = (((unsigned short int) firstbyte) << 8) + (unsigned short int) secondbyte;
+
+		} else {
+
+			// nope, advance by one and search again
+			OPJ_ADVANCE(1);
+			continue;
+		}
+		
+		// search the marker
+		for (m = 0; m < J2KMARK_NUM; m++) {
+			if (currmark == marker_val[m])
+				break;
+		}
+
+		// marker not found
+		if (m == J2KMARK_NUM) {
+			// nope, advance by one and search again
+			OPJ_ADVANCE(1);
+			continue;
+		}
+
+		// if we are inside SOD, only some markers are allowed
+		if (inside_sod) {
+
+			// we are inside SOP
+			if (inside_sop) {
+
+			}
+
+			// randomly marker coincident data
+			if ((currmark != SOT_VAL) &&
+				(currmark != EOC_VAL) &&
+				(currmark != SOP_VAL) &&
+				(currmark != EPH_VAL)) {
+				OPJ_ADVANCE(1);
+				continue;
+			}
+
+			// possible SOT?
+			if ((currmark == SOT_VAL)) {
+				// too early SOT
+				if (offset < (lastsotpos + lastPsot)) {
+					OPJ_ADVANCE(1);
+					continue;
+				}
+				// we were not in the last tile
+				/*if (lastPsot != 0) {
+					OPJ_ADVANCE(1);
+					break;
+				}*/
+			}
+		}
+
+		// beyond this point, the marker MUST BE real
+
+		// length of current marker segment
+		if ((currmark == SOD_VAL) ||
+			(currmark == SOC_VAL) ||
+			(currmark == EOC_VAL) ||
+			(currmark == EPH_VAL))
+
+			// zero length markers
+			currlen = 0;
+
+		else {
+
+			// read length field
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+
+			currlen = (((unsigned short int) twobytes[0]) << 8) + (unsigned short int) twobytes[1];
+		}
+
+		// here we pass to AppendItem() normal and selected item images (we
+		// suppose that selected image follows the normal one in the enum)
+		int image, imageSel;
+		image = m_tree->TreeCtrlIcon_Folder;
+		imageSel = image + 1;
+
+		// append the marker
+		wxTreeItemId currid = m_tree->AppendItem(parentid,
+			wxString::Format(wxT("%03d: "), nmarks) +
+			wxString::FromAscii(marker_name[m]) + 
+			wxString::Format(wxT(" (0x%04X)"), marker_val[m]),
+			image, imageSel,
+			new OPJMarkerData(wxT("MARK") + wxString::Format(wxT(" (%d)"), marker_val[m]),
+				m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
+			);
+
+		// append some info
+		image = m_tree->TreeCtrlIcon_File;
+		imageSel = image + 1;
+
+		// marker name
+		wxTreeItemId subcurrid1 = m_tree->AppendItem(currid,
+			wxT("*** ") + wxString::FromAscii(marker_descr[m]) + wxT(" ***"),
+			image, imageSel,
+			new OPJMarkerData(wxT("INFO"))
+			);
+		m_tree->SetItemFont(subcurrid1, *wxITALIC_FONT);
+
+		// position and length
+		wxTreeItemId subcurrid2 = m_tree->AppendItem(currid,
+			wxLongLong(offset).ToString() + wxT(" > ") + wxLongLong(offset + currlen + 1).ToString() + 
+			wxT(", ") + wxString::Format(wxT("%d + 2 (%d)"), currlen, currlen + 2),
+			image, imageSel,
+			new OPJMarkerData(wxT("INFO"))
+			);
+
+		// give additional info on markers
+		switch (currmark) {
+
+		/////////
+		// SOP //
+		/////////
+		case SOP_VAL:
+			{
+			// read packet number
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			int packnum = STREAM_TO_UINT16(twobytes, 0);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Pack. no. %d"), packnum),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			inside_sop = 1;
+			};
+			break;
+
+#ifdef USE_JPWL
+		/////////
+		// RED //
+		/////////
+		case RED_VAL:
+			{
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char pred = onebyte[0];
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxString address[] = {
+				wxT("Packet addressing"),
+				wxT("Byte-range addressing"),
+				wxT("Packet-range addressing"),
+				wxT("Reserved")
+			};
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				address[(pred & 0xC0) >> 6],
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d bytes range"), (((pred & 0x02) >> 1) + 1) * 2),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				pred & 0x01 ? wxT("Errors/erasures in codestream") : wxT("Error free codestream"),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Residual corruption level: %d"), (pred & 0x38) >> 3),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			}
+			break;
+
+		/////////
+		// ESD //
+		/////////
+		case ESD_VAL:
+			{
+			unsigned short int cesd;
+			if (csiz < 257) {
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				cesd = onebyte[0];
+			} else {
+				if (m_file->Read(twobytes, 2) != 2)
+					break;
+				cesd = STREAM_TO_UINT16(twobytes, 0);
+			}
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char pesd = onebyte[0];
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				pesd & 0x01 ? wxT("Comp. average") : wxString::Format(wxT("Comp. no. %d"), cesd),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			wxString meth[] = {
+				wxT("Relative error sensitivity"),
+				wxT("MSE"),
+				wxT("MSE reduction"),
+				wxT("PSNR"),
+				wxT("PSNR increase"),
+				wxT("MAXERR (absolute peak error)"),
+				wxT("TSE (total squared error)"),
+				wxT("Reserved")
+			};
+
+			subcurrid = m_tree->AppendItem(currid,
+				meth[(pesd & 0x38) >> 3],
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			wxString address[] = {
+				wxT("Packet addressing"),
+				wxT("Byte-range addressing"),
+				wxT("Packet-range addressing"),
+				wxT("Reserved")
+			};
+
+			subcurrid = m_tree->AppendItem(currid,
+				address[(pesd & 0xC0) >> 6],
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d bytes/value, %d bytes range"), ((pesd & 0x04) >> 2) + 1, (((pesd & 0x02) >> 1) + 1) * 2),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			}
+			break;
+
+		/////////
+		// EPC //
+		/////////
+		case EPC_VAL:
+			{
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			unsigned short int pcrc = STREAM_TO_UINT16(twobytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int dl = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char pepc = onebyte[0];
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("CRC-16 = 0x%x"), pcrc),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Tot. length = %d"), dl),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%s%s%s%s"),
+					pepc & 0x10 ? wxT("ESD, ") : wxT(""),
+					pepc & 0x20 ? wxT("RED, ") : wxT(""),
+					pepc & 0x40 ? wxT("EPB, ") : wxT(""),
+					pepc & 0x80 ? wxT("Info") : wxT("")
+					),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			}
+			break;
+
+		/////////
+		// EPB //
+		/////////
+		case EPB_VAL:
+			{
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char depb = onebyte[0];
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int ldpepb = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int pepb = STREAM_TO_UINT32(fourbytes, 0);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("No. %d, %slatest, %spacked"),
+					depb & 0x3F,
+					depb & 0x40 ? wxT("") : wxT("not "),
+					depb & 0x80 ? wxT("") : wxT("un")),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d bytes protected"), ldpepb),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (pepb == 0x00000000)
+
+				subcurrid = m_tree->AppendItem(currid,
+					wxT("Predefined codes"),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			else if ((pepb >= 0x10000000) && (pepb <= 0x1FFFFFFF)) {
+
+				wxString text = wxT("CRC code");
+				if (pepb == 0x10000000)
+					text << wxT(", CCITT (X25) 16 bits");
+				else if (pepb == 0x10000001)
+					text << wxT(", Ethernet 32 bits");
+				else
+					text << wxT(", JPWL RA");
+				subcurrid = m_tree->AppendItem(currid,
+					text,
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			} else if ((pepb >= 0x20000000) && (pepb <= 0x2FFFFFFF)) {
+
+				wxString text;
+				subcurrid = m_tree->AppendItem(currid,
+					wxString::Format(wxT("RS code, RS(%d, %d)"),
+						(pepb & 0x0000FF00) >> 8,
+						(pepb & 0x000000FF)),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			} else if ((pepb >= 0x30000000) && (pepb <= 0x3FFFFFFE))
+
+				subcurrid = m_tree->AppendItem(currid,
+					wxT("JPWL RA"),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			else if (pepb == 0xFFFFFFFF)
+
+				subcurrid = m_tree->AppendItem(currid,
+					wxT("No method"),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			}
+			break;
+#endif // USE_JPWL
+
+#ifdef USE_JPSEC
+		case SEC_VAL:
+			{
+
+			}
+			break;
+#endif // USE_JPSEC
+
+		/////////
+		// SIZ //
+		/////////
+		case SIZ_VAL:
+			{
+			int c;
+			
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			unsigned short int rsiz = STREAM_TO_UINT16(twobytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int xsiz = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int ysiz = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int xosiz = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int yosiz = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int xtsiz = STREAM_TO_UINT32(fourbytes, 0);
+			this->m_tree->m_childframe->m_twidth = xtsiz;
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int ytsiz = STREAM_TO_UINT32(fourbytes, 0);
+			this->m_tree->m_childframe->m_theight = ytsiz;
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int xtosiz = STREAM_TO_UINT32(fourbytes, 0);
+			this->m_tree->m_childframe->m_tx = xtosiz;
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int ytosiz = STREAM_TO_UINT32(fourbytes, 0);
+			this->m_tree->m_childframe->m_ty = ytosiz;
+
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			csiz = STREAM_TO_UINT16(twobytes, 0);
+
+			bool equaldepth = true, equalsize = true;
+			unsigned char *ssiz  = new unsigned char(csiz);
+			unsigned char *xrsiz = new unsigned char(csiz);
+			unsigned char *yrsiz = new unsigned char(csiz);
+
+			for (c = 0; c < csiz; c++) {
+
+				if (m_file->Read(&ssiz[c], 1) != 1)
+					break;
+
+				if (c > 0)
+					equaldepth = equaldepth && (ssiz[c] == ssiz[c - 1]);
+
+				if (m_file->Read(&xrsiz[c], 1) != 1)
+					break;
+
+				if (m_file->Read(&yrsiz[c], 1) != 1)
+					break;
+
+				if (c > 0)
+					equalsize = equalsize && (xrsiz[c] == xrsiz[c - 1]) && (yrsiz[c] == yrsiz[c - 1]) ;
+
+			}
+
+			if (equaldepth && equalsize)
+				wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+					wxString::Format(wxT("I: %dx%d (%d, %d), %d c., %d%s bpp"),
+					xsiz, ysiz,
+					xosiz, yosiz,
+					csiz, ((ssiz[0] & 0x7F) + 1),
+					(ssiz[0] & 0x80) ? wxT("s") : wxT("u")),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			else
+				wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+					wxString::Format(wxT("I: %dx%d (%d, %d), %d c."),
+					xsiz, ysiz,
+					xosiz, yosiz,
+					csiz),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("T: %dx%d (%d, %d)"),
+				xtsiz, ytsiz,
+				xtosiz, ytosiz),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_Folder;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid4 = m_tree->AppendItem(currid,
+				wxT("Components"),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			for (c = 0; c < csiz; c++) {
+
+				wxTreeItemId subcurrid5 = m_tree->AppendItem(subcurrid4,
+					wxString::Format(wxT("#%d: %dx%d, %d%s bpp"),
+					c,
+					xsiz/xrsiz[c], ysiz/yrsiz[c],
+					((ssiz[c] & 0x7F) + 1),
+					(ssiz[c] & 0x80) ? wxT("s") : wxT("u")),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			}
+
+			};
+			break;
+
+		/////////
+		// SOT //
+		/////////
+		case SOT_VAL:
+			{
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			unsigned short int isot = STREAM_TO_UINT16(twobytes, 0);
+
+			if (m_file->Read(fourbytes, 4) != 4)
+				break;
+			unsigned long int psot = STREAM_TO_UINT32(fourbytes, 0);
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char tpsot = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char tnsot = onebyte[0];
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("tile %d, psot = %d, part %d of %d"), isot, psot, tpsot, tnsot),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			lastPsot = psot;
+			lastsotpos = offset;
+			inside_sod = 0;
+			};
+			break;
+
+		/////////
+		// COC //
+		/////////
+		case COC_VAL:
+			{
+			unsigned short int ccoc;
+			if (csiz < 257) {
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				ccoc = onebyte[0];
+			} else {
+				if (m_file->Read(twobytes, 2) != 2)
+					break;
+				ccoc = STREAM_TO_UINT16(twobytes, 0);
+			}
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char scoc = onebyte[0];
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Comp. no. %d"), ccoc),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			
+			wxString text;
+			if (scoc & 0x01)
+				text << wxT("Partitioned entropy coder");
+			else
+				text << wxT("Unpartitioned entropy coder");
+
+			subcurrid = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char decomplevs = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbswidth = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbsheight = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbstyle = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char transform = onebyte[0];
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d levels (%d resolutions)"), decomplevs, decomplevs + 1),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (transform & 0x01)
+				text = wxT("5-3 reversible wavelet");
+			else
+				text = wxT("9-7 irreversible wavelet");
+			subcurrid = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Code-blocks: %dx%d"), 1 << ((cbswidth & 0x0F) + 2), 1 << ((cbsheight & 0x0F) + 2)),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_Folder;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				wxT("Coding styles"),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			if (cbstyle & 0x01)
+				text = wxT("Selective arithmetic coding bypass");
+			else
+				text = wxT("No selective arithmetic coding bypass");
+			wxTreeItemId subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x02)
+				text = wxT("Reset context probabilities on coding pass boundaries");
+			else
+				text = wxT("No reset of context probabilities on coding pass boundaries");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x04)
+				text = wxT("Termination on each coding passs");
+			else
+				text = wxT("No termination on each coding pass");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x08)
+				text = wxT("Vertically stripe causal context");
+			else
+				text = wxT("No vertically stripe causal context");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x10)
+				text = wxT("Predictable termination");
+			else
+				text = wxT("No predictable termination");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x20)
+				text = wxT("Segmentation symbols are used");
+			else
+				text = wxT("No segmentation symbols are used");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			}
+			break;
+
+		/////////
+		// COD //
+		/////////
+		case COD_VAL:
+			{
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char scod = onebyte[0];
+
+			wxString text;
+
+			if (scod & 0x01)
+				text << wxT("Partitioned entropy coder");
+			else
+				text << wxT("Unpartitioned entropy coder");
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			text = wxT("");
+			if (scod & 0x02)
+				text << wxT("Possible SOPs");
+			else
+				text << wxT("No SOPs");
+
+			if (scod & 0x04)
+				text << wxT(", possible EPHs");
+			else
+				text << wxT(", no EPHs");
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char progord = onebyte[0];
+
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			unsigned short int numlayers = STREAM_TO_UINT16(twobytes, 0);
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char mctransform = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char decomplevs = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbswidth = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbsheight = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char cbstyle = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char transform = onebyte[0];
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d levels (%d resolutions)"), decomplevs, decomplevs + 1),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			text = wxT("");
+			switch (progord) {
+			case (0):
+				text << wxT("LRCP");
+				break;
+			case (1):
+				text << wxT("RLCP");
+				break;
+			case (2):
+				text << wxT("LRCP");
+				break;
+			case (3):
+				text << wxT("RPCL");
+				break;
+			case (4):
+				text << wxT("CPRL");
+				break;
+			default:
+				text << wxT("unknown progression");
+				break;
+			}
+			text << wxString::Format(wxT(", %d layers"), numlayers);
+			if (transform & 0x01)
+				text << wxT(", 5-3 rev.");
+			else
+				text << wxT(", 9-7 irr.");
+			subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Code-blocks: %dx%d"), 1 << ((cbswidth & 0x0F) + 2), 1 << ((cbsheight & 0x0F) + 2)),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			switch (mctransform) {
+			case (0):
+				{
+				text = wxT("No MCT");
+				}
+				break;
+			case (1):
+				{
+				text = wxT("Reversible MCT on 0, 1, 2");
+				}
+				break;
+			case (2):
+				{
+				text = wxT("Irreversible MCT on 0, 1, 2");
+				}
+				break;
+			default:
+				{
+				text = wxT("Unknown");
+				}
+				break;
+			};
+			subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+
+			image = m_tree->TreeCtrlIcon_Folder;
+			imageSel = image + 1;
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				wxT("Coding styles"),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			if (cbstyle & 0x01)
+				text = wxT("Selective arithmetic coding bypass");
+			else
+				text = wxT("No selective arithmetic coding bypass");
+			wxTreeItemId subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x02)
+				text = wxT("Reset context probabilities on coding pass boundaries");
+			else
+				text = wxT("No reset of context probabilities on coding pass boundaries");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x04)
+				text = wxT("Termination on each coding passs");
+			else
+				text = wxT("No termination on each coding pass");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x08)
+				text = wxT("Vertically stripe causal context");
+			else
+				text = wxT("No vertically stripe causal context");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x10)
+				text = wxT("Predictable termination");
+			else
+				text = wxT("No predictable termination");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (cbstyle & 0x20)
+				text = wxT("Segmentation symbols are used");
+			else
+				text = wxT("No segmentation symbols are used");
+			subcurrid4 = m_tree->AppendItem(subcurrid3,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			};
+			break;
+
+		/////////
+		// QCC //
+		/////////
+		case QCC_VAL:
+			{
+			unsigned short int cqcc;
+			if (csiz < 257) {
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				cqcc = onebyte[0];
+			} else {
+				if (m_file->Read(twobytes, 2) != 2)
+					break;
+				cqcc = STREAM_TO_UINT16(twobytes, 0);
+			}
+
+			wxTreeItemId subcurrid = m_tree->AppendItem(currid,
+				wxString::Format(wxT("Comp. no. %d"), cqcc),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char sqcc = onebyte[0];
+
+			wxString text;
+			switch (sqcc & 0x1F) {
+			case (0):
+				text = wxT("No quantization");
+				break;
+			case (1):
+				text = wxT("Scalar implicit");
+				break;
+			case (2):
+				text = wxT("Scalar explicit");
+				break;
+			default:
+				text = wxT("Unknown");
+				break;
+			}
+			text << wxString::Format(wxT(", %d guard bits"), (sqcc & 0xE0) >> 5);
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			}
+			break;
+
+		/////////
+		// QCD //
+		/////////
+		case QCD_VAL:
+			{
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char sqcd = onebyte[0];
+
+			wxString text;
+			switch (sqcd & 0x1F) {
+			case (0):
+				text = wxT("No quantization");
+				break;
+			case (1):
+				text = wxT("Scalar implicit");
+				break;
+			case (2):
+				text = wxT("Scalar explicit");
+				break;
+			default:
+				text = wxT("Unknown");
+				break;
+			}
+			text << wxString::Format(wxT(", %d guard bits"), (sqcd & 0xE0) >> 5);
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			};
+			break;
+
+		/////////
+		// COM //
+		/////////
+		case COM_VAL:
+			{
+			#define showlen 25
+			char comment[showlen];
+			wxString comments;
+
+			if (m_file->Read(twobytes, 2) != 2)
+				break;
+			unsigned short int rcom = STREAM_TO_UINT16(twobytes, 0);
+
+			wxString text;
+			if (rcom == 0)
+				text = wxT("Binary values");
+			else if (rcom == 1)
+				text = wxT("ISO 8859-1 (latin-1) values");
+			else if (rcom < 65535)
+				text = wxT("Reserved for registration");
+			else
+				text = wxT("Reserved for extension");
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				text,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (m_file->Read(comment, showlen) != showlen)
+				break;
+			comments = wxString::FromAscii(comment).Truncate(wxMin(showlen, currlen - 4));
+			if ((currlen - 4) > showlen)
+				comments << wxT("...");
+			subcurrid3 = m_tree->AppendItem(currid,
+				comments,
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			};
+			break;
+
+		/////////
+		// TLM //
+		/////////
+		case TLM_VAL:
+			{
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char ztlm = onebyte[0];
+
+			if (m_file->Read(onebyte, 1) != 1)
+				break;
+			unsigned char stlm = onebyte[0];
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("TLM #%d"), ztlm),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				wxString::Format(wxT("%d bits/index, %d bits/length"),
+				8 * ((stlm & 0x30) >> 4), 16 + 16 * ((stlm & 0x40) >> 6)),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			int n, numparts;
+
+			numparts = (currlen - 2) / ( ((stlm & 0x30) >> 4) + 2 + 2 * ((stlm & 0x40) >> 6));
+
+			image = m_tree->TreeCtrlIcon_Folder;
+			imageSel = image + 1;
+
+			subcurrid3 = m_tree->AppendItem(currid,
+				wxT("Tile parts"),
+				image, imageSel,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			image = m_tree->TreeCtrlIcon_File;
+			imageSel = image + 1;
+
+			for (n = 0; n < numparts; n++) {
+
+				unsigned short int ttlm;
+				unsigned long int ptlm;
+
+				switch (((stlm & 0x30) >> 4)) {
+
+				case 0:
+					ttlm = 0;
+					break;
+
+				case 1:
+					if (m_file->Read(onebyte, 1) != 1)
+						break;
+					ttlm = onebyte[0];
+					break;
+
+				case 2:
+					if (m_file->Read(twobytes, 2) != 2)
+						break;
+					ttlm = STREAM_TO_UINT16(twobytes, 0);
+					break;
+
+				}
+
+				switch (((stlm & 0x40) >> 6)) {
+
+				case 0:
+					if (m_file->Read(twobytes, 2) != 2)
+						break;
+					ptlm = STREAM_TO_UINT16(twobytes, 0);
+					break;
+
+				case 1:
+					if (m_file->Read(fourbytes, 4) != 4)
+						break;
+					ptlm = STREAM_TO_UINT32(fourbytes, 0);
+					break;
+
+				}
+
+				wxTreeItemId subcurrid4 = m_tree->AppendItem(subcurrid3,
+					wxString::Format(wxT("Tile %d: %d bytes"), ttlm, ptlm),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			}
+
+			}
+			break;
+
+		/////////
+		// POD //
+		/////////
+		case POD_VAL:
+			{
+			int n, numchanges;
+
+			if (csiz < 257)
+				numchanges = (currlen - 2) / 7;
+			else
+				numchanges = (currlen - 2) / 9;
+
+			for (n = 0; n < numchanges; n++) {
+
+				image = m_tree->TreeCtrlIcon_Folder;
+				imageSel = image + 1;
+
+				wxTreeItemId subcurrid3 = m_tree->AppendItem(currid,
+					wxString::Format(wxT("Change #%d"), n),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				unsigned char rspod = onebyte[0];
+
+				unsigned short int cspod;
+				if (csiz < 257) {
+					if (m_file->Read(onebyte, 1) != 1)
+						break;
+					cspod = onebyte[0];
+				} else {
+					if (m_file->Read(twobytes, 2) != 2)
+						break;
+					cspod = STREAM_TO_UINT16(twobytes, 0);
+				}
+
+				if (m_file->Read(twobytes, 2) != 2)
+					break;
+				unsigned short int lyepod = STREAM_TO_UINT16(twobytes, 0);
+
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				unsigned char repod = onebyte[0];
+
+				unsigned short int cepod;
+				if (csiz < 257) {
+					if (m_file->Read(onebyte, 1) != 1)
+						break;
+					cepod = onebyte[0];
+				} else {
+					if (m_file->Read(twobytes, 2) != 2)
+						break;
+					cepod = STREAM_TO_UINT16(twobytes, 0);
+				}
+
+				if (m_file->Read(onebyte, 1) != 1)
+					break;
+				unsigned char ppod = onebyte[0];
+
+				image = m_tree->TreeCtrlIcon_File;
+				imageSel = image + 1;
+
+				wxTreeItemId subcurrid4 = m_tree->AppendItem(subcurrid3,
+					wxString::Format(wxT("%d <= Resolution < %d"), rspod, repod),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+				subcurrid4 = m_tree->AppendItem(subcurrid3,
+					wxString::Format(wxT("%d <= Component < %d"), cspod, cepod),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+				subcurrid4 = m_tree->AppendItem(subcurrid3,
+					wxString::Format(wxT("0 <= Layer < %d"), lyepod),
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+				wxString text = wxT("");
+				switch (ppod) {
+				case (0):
+					text << wxT("LRCP");
+					break;
+				case (1):
+					text << wxT("RLCP");
+					break;
+				case (2):
+					text << wxT("LRCP");
+					break;
+				case (3):
+					text << wxT("RPCL");
+					break;
+				case (4):
+					text << wxT("CPRL");
+					break;
+				default:
+					text << wxT("unknown progression");
+					break;
+				}
+				subcurrid4 = m_tree->AppendItem(subcurrid3,
+					text,
+					image, imageSel,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			}
+
+			}
+			break;
+
+		/////////
+		// SOD //
+		/////////
+		case SOD_VAL:
+			{
+			inside_sod = 1;
+			};
+			break;
+
+		default:
+			break;
+			
+		}
+								
+		// increment number of markers
+		if (nmarks++ >= maxmarks) {
+			WriteText(wxT("Maximum amount of markers exceeded"));
+			break;
+		}
+
+		// advance position
+		OPJ_ADVANCE(currlen + 2);
+	}	
+
+	WriteText(wxT("Search finished"));
+}
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/wxjp2parser.cpp.svn-base ./OPJViewer/source/.svn/text-base/wxjp2parser.cpp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/source/.svn/text-base/wxjp2parser.cpp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/source/.svn/text-base/wxjp2parser.cpp.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,1116 @@
+/*
+ * Copyright (c) 2007, Digital Signal Processing Laboratory, Università degli studi di Perugia (UPG), Italy
+ * All rights reserved.
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions
+ * are met:
+ * 1. Redistributions of source code must retain the above copyright
+ *    notice, this list of conditions and the following disclaimer.
+ * 2. Redistributions in binary form must reproduce the above copyright
+ *    notice, this list of conditions and the following disclaimer in the
+ *    documentation and/or other materials provided with the distribution.
+ *
+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS'
+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
+ * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ */
+#include "OPJViewer.h"
+
+/* defines */
+#define SHORT_DESCR_LEN        32
+#define LONG_DESCR_LEN         256
+
+/* enumeration for file formats */
+#define J2FILENUM              4
+typedef enum {
+
+        JP2_FILE,
+        J2K_FILE,
+		MJ2_FILE,
+		UNK_FILE
+
+} j2filetype;
+
+/* enumeration for the box types */
+#define j22boxNUM                23
+typedef enum {
+
+			FILE_BOX,
+			JP_BOX,
+			FTYP_BOX,
+			JP2H_BOX,
+			IHDR_BOX,
+			COLR_BOX,
+			JP2C_BOX,
+			JP2I_BOX,
+			XML_BOX,
+			UUID_BOX,
+			UINF_BOX,
+			MOOV_BOX,
+			MVHD_BOX,
+			TRAK_BOX,
+			TKHD_BOX,
+			MDIA_BOX,
+			MDHD_BOX,
+			HDLR_BOX,
+			MINF_BOX,
+			VMHD_BOX,
+			STBL_BOX,
+			STSD_BOX,
+			STSZ_BOX,
+			MJP2_BOX,
+			MDAT_BOX,
+			ANY_BOX,
+			UNK_BOX
+
+} j22boxtype;
+
+/* the box structure itself */
+struct boxdef {
+
+        char                  value[5];                 /* hexadecimal value/string*/
+		char                  name[SHORT_DESCR_LEN];    /* short description       */
+		char                  descr[LONG_DESCR_LEN];    /* long  description       */
+		int                   sbox;                     /* is it a superbox?       */
+		int                   req[J2FILENUM];           /* mandatory box           */
+		j22boxtype             ins;                      /* contained in box...     */
+
+};
+
+
+/* jp2 family box signatures */
+#define FILE_SIGN           ""
+#define JP_SIGN             "jP\040\040"
+#define FTYP_SIGN           "ftyp"
+#define JP2H_SIGN           "jp2h"
+#define IHDR_SIGN           "ihdr"
+#define COLR_SIGN           "colr"
+#define JP2C_SIGN           "jp2c"
+#define JP2I_SIGN           "jp2i"
+#define XML_SIGN            "xml\040"
+#define UUID_SIGN           "uuid"
+#define UINF_SIGN           "uinf"
+#define MOOV_SIGN           "moov"
+#define MVHD_SIGN           "mvhd"
+#define TRAK_SIGN           "trak"
+#define TKHD_SIGN           "tkhd"
+#define MDIA_SIGN           "mdia"
+#define MDHD_SIGN           "mdhd"
+#define HDLR_SIGN           "hdlr"
+#define MINF_SIGN           "minf"
+#define VMHD_SIGN           "vmhd"
+#define STBL_SIGN           "stbl"
+#define STSD_SIGN           "stsd"
+#define STSZ_SIGN           "stsz"
+#define MJP2_SIGN           "mjp2"
+#define MDAT_SIGN           "mdat"
+#define ANY_SIGN 			""
+#define UNK_SIGN            ""
+
+/* the possible boxes */
+struct boxdef j22box[] =
+{
+/* sign */	{FILE_SIGN,
+/* short */	"placeholder for nothing",
+/* long */	"Nothing to say",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP_SIGN,
+/* short */	"JPEG 2000 Signature box",
+/* long */	"This box uniquely identifies the file as being part of the JPEG 2000 family of files",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{FTYP_SIGN,
+/* short */	"File Type box",
+/* long */	"This box specifies file type, version and compatibility information, including specifying if this file "
+			"is a conforming JP2 file or if it can be read by a conforming JP2 reader",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP2H_SIGN,
+/* short */	"JP2 Header box",
+/* long */	"This box contains a series of boxes that contain header-type information about the file",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{IHDR_SIGN,
+/* short */	"Image Header box",
+/* long */	"This box specifies the size of the image and other related fields",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	JP2H_BOX},
+
+/* sign */	{COLR_SIGN,
+/* short */	"Colour Specification box",
+/* long */	"This box specifies the colourspace of the image",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	JP2H_BOX},
+
+/* sign */	{JP2C_SIGN,
+/* short */	"Contiguous Codestream box",
+/* long */	"This box contains the codestream as defined by Annex A",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{JP2I_SIGN,
+/* short */	"Intellectual Property box",
+/* long */	"This box contains intellectual property information about the image",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{XML_SIGN,
+/* short */	"XML box",
+/* long */	"This box provides a tool by which vendors can add XML formatted information to a JP2 file",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UUID_SIGN,
+/* short */	"UUID box",
+/* long */	"This box provides a tool by which vendors can add additional information to a file "
+			"without risking conflict with other vendors",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UINF_SIGN,
+/* short */	"UUID Info box",
+/* long */	"This box provides a tool by which a vendor may provide access to additional information associated with a UUID",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{MOOV_SIGN,
+/* short */	"Movie box",
+/* long */	"This box contains the media data. In video tracks, this box would contain JPEG2000 video frames",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{MVHD_SIGN,
+/* short */	"Movie Header box",
+/* long */	"This box defines overall information which is media-independent, and relevant to the entire presentation "
+			"considered as a whole",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MOOV_BOX},
+
+/* sign */	{TRAK_SIGN,
+/* short */	"Track box",
+/* long */	"This is a container box for a single track of a presentation. A presentation may consist of one or more tracks",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MOOV_BOX},
+
+/* sign */	{TKHD_SIGN,
+/* short */	"Track Header box",
+/* long */	"This box specifies the characteristics of a single track. Exactly one Track Header Box is contained in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	TRAK_BOX},
+
+/* sign */	{MDIA_SIGN,
+/* short */	"Media box",
+/* long */	"The media declaration container contains all the objects which declare information about the media data "
+			"within a track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	TRAK_BOX},
+
+/* sign */	{MDHD_SIGN,
+/* short */	"Media Header box",
+/* long */	"The media header declares overall information which is media-independent, and relevant to characteristics "
+			"of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{HDLR_SIGN,
+/* short */	"Handler Reference box",
+/* long */	"This box within a Media Box declares the process by which the media-data in the track may be presented, "
+			"and thus, the nature of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{MINF_SIGN,
+/* short */	"Media Information box",
+/* long */	"This box contains all the objects which declare characteristic information of the media in the track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{VMHD_SIGN,
+/* short */	"Video Media Header box",
+/* long */	"The video media header contains general presentation information, independent of the coding, for video media",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{STBL_SIGN,
+/* short */	"Sample Table box",
+/* long */	"The sample table contains all the time and data indexing of the media samples in a track",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{STSD_SIGN,
+/* short */	"STSD Sample Description box",
+/* long */	"The sample description table gives detailed information about the coding type used, and any initialization "
+			"information needed for that coding",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{STSZ_SIGN,
+/* short */	"Sample Size box",
+/* long */	"This box contains the sample count and a table giving the size of each sample",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	STBL_BOX},
+
+/* sign */	{MJP2_SIGN,
+/* short */	"MJP2 Sample Description box",
+/* long */	"The MJP2 sample description table gives detailed information about the coding type used, and any initialization "
+			"information needed for that coding",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MINF_BOX},
+
+/* sign */	{MDAT_SIGN,
+/* short */	"Media Data box",
+/* long */	"The meta-data for a presentation is stored in the single Movie Box which occurs at the top-level of a file",
+/* sbox */	1,
+/* req */	{1, 1, 1},
+/* ins */	FILE_BOX},
+
+/* sign */	{ANY_SIGN,
+/* short */	"Any box",
+/* long */	"All the existing boxes",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	FILE_BOX},
+
+/* sign */	{UNK_SIGN,
+/* short */	"Unknown Type box",
+/* long */	"The signature is not recognised to be that of an existing box",
+/* sbox */	0,
+/* req */	{0, 0, 0},
+/* ins */	ANY_BOX}
+
+};
+
+
+/* macro functions */
+/* From little endian to big endian, 2 and 4 bytes */
+#define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
+#define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
+                        ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
+						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
+						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
+
+/* From codestream to int values */
+#define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
+								((unsigned long int) (C)[(P) + 1] << 16) + \
+								((unsigned long int) (C)[(P) + 2] << 8) + \
+								((unsigned long int) (C)[(P) + 3] << 0))
+
+#define STREAM_TO_UINT16(C, P)	(((unsigned long int) (C)[(P) + 0] << 8) + \
+								((unsigned long int) (C)[(P) + 1] << 0))
+
+#define OPJREAD_LONG(F,L,N) { \
+							if (F->Read(fourbytes, 4) < 4) { \
+								wxLogMessage(wxT("Problem reading " N " from the file (file ended?)")); \
+								return -1; \
+							}; \
+							L = STREAM_TO_UINT32(fourbytes, 0); \
+							}
+
+/* handling functions */
+#define ITEM_PER_ROW	10
+
+//#define indprint	if (0) printf("%.*s", 2 * level + 9, indent), printf
+char    indent[] =  "                                                                   "
+					"                                                                   "
+					"                                                                   "
+					"                                                                   ";
+
+void indprint(wxString printout, int level)
+{
+	wxLogMessage(/*wxString::Format(wxT("%.*s"), 2 * level + 9, indent) + */printout);
+}
+
+/* Box handler function */
+int OPJParseThread::box_handler_function(int boxtype, wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit,
+						 wxTreeItemId parentid, int level, char *scansign, unsigned long int *scanpoint)
+{
+	switch ((j22boxtype) boxtype) {
+
+
+	/* JPEG 2000 Signature box */
+	case (JP_BOX): {
+
+			unsigned long int checkdata = 0;
+			fileid->Read(&checkdata, sizeof(unsigned long int));
+			checkdata = BYTE_SWAP4(checkdata);
+
+			// add info
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Check data: %X -> %s"), checkdata, (checkdata == 0x0D0A870A) ? wxT("OK") : wxT("KO")),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+		};
+		break;
+
+
+	/* JPEG 2000 codestream box */
+	case (JP2C_BOX): {
+
+			// add info
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString(wxT("Codestream")),
+				m_tree->TreeCtrlIcon_Folder, m_tree->TreeCtrlIcon_Folder + 1,
+				new OPJMarkerData(wxT("INFO-CSTREAM"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+				);
+
+			m_tree->SetItemHasChildren(currid);
+
+			// parse the file
+			//ParseJ2KFile(fileid, filepoint, filelimit, currid);
+
+		};
+		break;
+
+
+
+
+
+	/* File Type box */
+	case (FTYP_BOX): {
+
+			char BR[4], CL[4];
+			unsigned long int MinV, numCL, i;
+			fileid->Read(BR, sizeof(char) * 4);
+			fileid->Read(&MinV, sizeof(unsigned long int));
+			MinV = BYTE_SWAP4(MinV);
+			numCL = (filelimit - fileid->Tell()) / 4;				
+
+			// add info
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxT("Brand/Minor version: ") +
+				wxString::FromAscii(BR).Truncate(4) +
+				wxString::Format(wxT("/%d"), MinV),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Compatibility list")),
+				m_tree->TreeCtrlIcon_Folder, m_tree->TreeCtrlIcon_Folder + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			for (i = 0; i < numCL; i++) {
+				fileid->Read(CL, sizeof(char) * 4);
+				m_tree->AppendItem(currid,
+					wxString::FromAscii(CL).Truncate(4),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			};
+			
+		};
+		break;
+
+
+
+	/* JP2 Header box */
+	case (IHDR_BOX): {
+
+			unsigned long int height, width;
+			unsigned short int nc;
+			unsigned char bpc, C, UnkC, IPR;
+			fileid->Read(&height, sizeof(unsigned long int));
+			height = BYTE_SWAP4(height);
+			fileid->Read(&width, sizeof(unsigned long int));
+			width = BYTE_SWAP4(width);
+			fileid->Read(&nc, sizeof(unsigned short int));
+			nc = BYTE_SWAP2(nc);
+			fileid->Read(&bpc, sizeof(unsigned char));
+			fileid->Read(&C, sizeof(unsigned char));
+			fileid->Read(&UnkC, sizeof(unsigned char));
+			fileid->Read(&IPR, sizeof(unsigned char));
+			
+			// add info
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Dimensions: %d x %d x %d @ %d bpc"), width, height, nc, bpc + 1),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Compression type: %d"), C),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Colourspace unknown: %d"), UnkC),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Intellectual Property Rights: %d"), IPR),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			
+		};
+		break;
+
+
+
+	/* Colour Specification box */
+	case (COLR_BOX): {
+
+			unsigned char METH, PREC, APPROX;
+			char methdescr[80], enumcsdescr[80];
+			unsigned long int EnumCS;
+			fileid->Read(&METH, sizeof(unsigned char));
+			switch (METH) {
+			case 1:
+				strcpy(methdescr, "Enumerated Colourspace");
+				break;
+			case 2:
+				strcpy(methdescr, "Restricted ICC profile");
+				break;
+			default:
+				strcpy(methdescr, "Unknown");
+				break;
+			};
+			fileid->Read(&PREC, sizeof(unsigned char));
+			fileid->Read(&APPROX, sizeof(unsigned char));
+			if (METH != 2) {
+				fileid->Read(&EnumCS, sizeof(unsigned long int));
+				EnumCS = BYTE_SWAP4(EnumCS);
+				switch (EnumCS) {
+				case 16:
+					strcpy(enumcsdescr, "sRGB");
+					break;
+				case 17:
+					strcpy(enumcsdescr, "greyscale");
+					break;
+				case 18:
+					strcpy(enumcsdescr, "sYCC");
+					break;
+				default:
+					strcpy(enumcsdescr, "Unknown");
+					break;
+				};
+			};
+
+			// add info
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Specification method: %d ("), METH) +
+				wxString::FromAscii(methdescr) +
+				wxT(")"),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Precedence: %d"), PREC),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Colourspace approximation: %d"), APPROX),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+
+			if (METH != 2)
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Enumerated colourspace: %d ("), EnumCS) +
+					wxString::FromAscii(enumcsdescr) +
+					wxT(")"),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+			if (METH != 1)
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("ICC profile: there is one")),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+
+
+		};
+		break;
+
+
+
+
+		
+
+	/* Movie Header Box */
+	case (MVHD_BOX): {
+
+			unsigned long int version, rate, matrix[9], next_track_ID;
+			unsigned short int volume;
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			if (version == 0) {
+				unsigned long int creation_time, modification_time, timescale, duration;
+				fileid->Read(&creation_time, sizeof(unsigned long int));
+				creation_time = BYTE_SWAP4(creation_time);
+				fileid->Read(&modification_time, sizeof(unsigned long int));
+				modification_time = BYTE_SWAP4(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(unsigned long int));
+				duration = BYTE_SWAP4(duration);
+				const long unix_time = creation_time - 2082844800L;
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u (%.24s)"), creation_time, ctime(&unix_time)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				const long unix_time1 = modification_time - 2082844800L;
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u (%.24s)"), modification_time, ctime(&unix_time1)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u (%.6fs)"), timescale, 1.0 / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u (%.3fs)"), duration, (float) duration / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			} else {
+				int8byte creation_time, modification_time, duration;
+				unsigned long int timescale;
+				fileid->Read(&creation_time, sizeof(int8byte));
+				creation_time = BYTE_SWAP8(creation_time);
+				fileid->Read(&modification_time, sizeof(int8byte));
+				modification_time = BYTE_SWAP8(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(int8byte));
+				duration = BYTE_SWAP8(duration);
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u"), creation_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u"), modification_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u"), timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u"), duration),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			};
+			fileid->Read(&rate, sizeof(unsigned long int));
+			rate = BYTE_SWAP4(rate);
+			fileid->Read(&volume, sizeof(unsigned short int));
+			volume = BYTE_SWAP2(volume);
+			fileid->Seek(6, wxFromCurrent);
+			fileid->Read(&matrix, sizeof(unsigned char) * 9);
+			fileid->Seek(4, wxFromCurrent);
+			fileid->Read(&next_track_ID, sizeof(unsigned long int));
+			next_track_ID = BYTE_SWAP4(next_track_ID);
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Rate: %d (%d.%d)"), rate, rate >> 16, rate & 0x0000FFFF),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Volume: %d (%d.%d)"), volume, volume >> 8, volume & 0x00FF),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Next track ID: %d"), next_track_ID),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+		};
+		break;
+
+
+			/* Sample Description box */
+	case (STSD_BOX): {
+
+			unsigned long int version, entry_count;
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			fileid->Read(&entry_count, sizeof(unsigned long int));
+			entry_count = BYTE_SWAP4(entry_count);
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Entry count: %d"), entry_count),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+				);
+			jpeg2000parse(fileid, filepoint + 8, filelimit, parentid, level + 1, scansign, scanpoint);
+		};
+		break;
+
+
+			/* Sample Size box */
+	case (STSZ_BOX): {
+
+			unsigned long int version, sample_size, sample_count, entry_size;
+			
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			
+			fileid->Read(&sample_size, sizeof(unsigned long int));
+			sample_size = BYTE_SWAP4(sample_size);
+
+			if (sample_size == 0) {
+				fileid->Read(&sample_count, sizeof(unsigned long int));
+				sample_count = BYTE_SWAP4(sample_count);
+
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Sample count: %d"), sample_count),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+					);
+
+				currid = m_tree->AppendItem(parentid,
+					wxT("Entries size (bytes)"),
+					m_tree->TreeCtrlIcon_Folder, m_tree->TreeCtrlIcon_Folder + 1,
+					new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+					);
+
+				wxString text;
+				for (unsigned int s = 0; s < sample_count; s++) {
+					fileid->Read(&entry_size, sizeof(unsigned long int));
+					entry_size = BYTE_SWAP4(entry_size);
+					
+					text << wxString::Format(wxT("%d, "), entry_size);
+
+					if (((s % 10) == (ITEM_PER_ROW - 1)) || (s == (sample_count - 1))) {
+						m_tree->AppendItem(currid,
+							text,
+							m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+							new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+							);
+						text = wxT("");
+					}
+
+				}
+				
+			}
+
+		};
+		break;
+
+
+			/* Video Media Header box */
+	case (VMHD_BOX): {
+
+			unsigned long int version;
+			unsigned short int graphicsmode, opcolor[3];
+			char graphicsdescr[100];
+
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+
+			fileid->Read(&graphicsmode, sizeof(unsigned short int));
+			graphicsmode = BYTE_SWAP2(graphicsmode);
+			switch (graphicsmode) {
+			case (0x00):
+					strcpy(graphicsdescr, "copy");
+					break;
+			case (0x24):
+					strcpy(graphicsdescr, "transparent");
+					break;
+			case (0x0100):
+					strcpy(graphicsdescr, "alpha");
+					break;
+			case (0x0101):
+					strcpy(graphicsdescr, "whitealpha");
+					break;
+			case (0x0102):
+					strcpy(graphicsdescr, "blackalpha");
+					break;
+			default:
+					strcpy(graphicsdescr, "unknown");
+					break;
+			};
+
+			fileid->Read(opcolor, 3 * sizeof(unsigned short int));
+			opcolor[0] = BYTE_SWAP2(opcolor[0]);
+			opcolor[1] = BYTE_SWAP2(opcolor[1]);
+			opcolor[2] = BYTE_SWAP2(opcolor[2]);
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Composition mode: %d (")) + 
+				wxString::FromAscii(graphicsdescr) +
+				wxT(")"),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+				);
+
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("OP color: %d %d %d"), opcolor[0], opcolor[1], opcolor[2]),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+				);
+		};
+		break;
+
+
+
+			/* MJP2 Sample Description box */
+	case (MJP2_BOX): {
+
+			unsigned short int height, width, depth;
+			unsigned long int horizresolution, vertresolution;
+			char compressor_name[32];
+			fileid->Seek(24, wxFromCurrent);
+			fileid->Read(&width, sizeof(unsigned short int));
+			width = BYTE_SWAP2(width);
+			fileid->Read(&height, sizeof(unsigned short int));
+			height = BYTE_SWAP2(height);
+			fileid->Read(&horizresolution, sizeof(unsigned long int));
+			horizresolution = BYTE_SWAP4(horizresolution);
+			fileid->Read(&vertresolution, sizeof(unsigned long int));
+			vertresolution = BYTE_SWAP4(vertresolution);
+			fileid->Seek(6, wxFromCurrent);
+			fileid->Read(compressor_name, sizeof(char) * 32);
+			fileid->Read(&depth, sizeof(unsigned short int));
+			depth = BYTE_SWAP2(depth);
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Dimensions: %d x %d @ %d bpp"), width, height, depth),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"), m_tree->m_fname.GetFullPath(), filepoint, filelimit)
+				);
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Resolution: %d.%d x %d.%d"), horizresolution >> 16, horizresolution & 0x0000FFFF,
+				vertresolution >> 16, vertresolution & 0x0000FFFF),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Compressor: %.32s"), compressor_name),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+			jpeg2000parse(fileid, filepoint + 78, filelimit, parentid, level + 1, scansign, scanpoint);
+
+		};
+		break;
+
+		/* Media Header box */
+	case (MDHD_BOX): {
+			unsigned long int version;
+			unsigned short int language;
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			if (version == 0) {
+				unsigned long int creation_time, modification_time, timescale, duration;
+				fileid->Read(&creation_time, sizeof(unsigned long int));
+				creation_time = BYTE_SWAP4(creation_time);
+				fileid->Read(&modification_time, sizeof(unsigned long int));
+				modification_time = BYTE_SWAP4(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(unsigned long int));
+				duration = BYTE_SWAP4(duration);
+				const long unix_time = creation_time - 2082844800L;
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u (%.24s)"), creation_time, ctime(&unix_time)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				const long unix_time1 = modification_time - 2082844800L;
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u (%.24s)"), modification_time, ctime(&unix_time1)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u (%.6fs)"), timescale, 1.0 / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u (%.3fs)"), duration, (float) duration / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			} else {
+				int8byte creation_time, modification_time, duration;
+				unsigned long int timescale;
+				fileid->Read(&creation_time, sizeof(int8byte));
+				creation_time = BYTE_SWAP8(creation_time);
+				fileid->Read(&modification_time, sizeof(int8byte));
+				modification_time = BYTE_SWAP8(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(int8byte));
+				duration = BYTE_SWAP8(duration);
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u"), creation_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u"), modification_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u"), timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u"), duration),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			}
+			fileid->Read(&language, sizeof(unsigned short int));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Language: %d (%c%c%c)"), language & 0xEFFF,
+				0x60 + (char) ((language >> 10) & 0x001F), 0x60 + (char) ((language >> 5) & 0x001F), 0x60 + (char) ((language >> 0) & 0x001F)),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+		};
+		break;
+		
+		/* Media Handler box */
+	case (HDLR_BOX): {
+			unsigned long int version, predefined, temp[3];
+			char handler[4], name[256];
+			int namelen = wxMin(256, (filelimit - filepoint - 24));
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			fileid->Read(&predefined, sizeof(unsigned long int));
+			fileid->Read(handler, 4 * sizeof(char));
+			fileid->Read(&temp, 3 * sizeof(unsigned long int));
+			fileid->Read(name, namelen * sizeof(char));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Handler: %.4s"), handler),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Name: %.255s"), name),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 				 
+		}
+		break;
+
+	/* not yet implemented */
+	default:
+		break;
+
+	};
+
+	return (0);
+}
+
+
+void OPJParseThread::ParseJP2File(wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit, wxTreeItemId parentid)
+{
+	unsigned long int scanpoint;
+
+	jpeg2000parse(fileid, filepoint, filelimit, parentid, 0, NULL, &scanpoint);
+}
+
+/* the parsing function itself */
+/*
+  fileid    = fid of the file to scan (you should open it by yourself)
+  filepoint = first byte where to start to scan from (usually 0)
+  filelimit = first byte where to stop to scan from (usually the file size)
+  level     = set this to 0
+  scansign  = signature to scan for (NULL avoids search, returns "    " if successful)
+  scanpoint = point where the scan signature lies
+*/
+int OPJParseThread::jpeg2000parse(wxFile *fileid, wxFileOffset filepoint, wxFileOffset filelimit,
+								  wxTreeItemId parentid, int level, char *scansign, unsigned long int *scanpoint)
+{
+	unsigned long int       LBox = 0x00000000;
+	//int                     LBox_read;
+	char                    TBox[5] = "\0\0\0\0";
+	//int                     TBox_read;
+	int8byte				XLBox = 0x0000000000000000;
+	//int                     XLBox_read;
+	unsigned long int       box_length = 0;
+	int                     last_box = 0, box_num = 0;
+	int                     box_type = ANY_BOX;
+	unsigned char           /*onebyte[1], twobytes[2],*/ fourbytes[4];
+
+	/* cycle all over the file */
+	box_num = 0;
+	last_box = 0;
+	while (!last_box) {
+
+		/* do not exceed file limit */
+		if (filepoint >= filelimit)
+			return (0);
+
+		/* seek on file */
+		if (fileid->Seek(filepoint, wxFromStart) == wxInvalidOffset)
+			return (-1);
+
+		/* read the mandatory LBox, 4 bytes */
+		if (fileid->Read(fourbytes, 4) < 4) {
+			WriteText(wxT("Problem reading LBox from the file (file ended?)"));
+			return -1;
+		};
+		LBox = STREAM_TO_UINT32(fourbytes, 0);
+
+		/* read the mandatory TBox, 4 bytes */
+		if (fileid->Read(TBox, 4) < 4) {
+			WriteText(wxT("Problem reading TBox from the file (file ended?)"));
+			return -1;
+		};
+
+		/* look if scansign is got */
+		if ((scansign != NULL) && (memcmp(TBox, scansign, 4) == 0)) {
+			memcpy(scansign, "    ", 4);
+			*scanpoint = filepoint;
+
+			/* hack/exploit */
+			// stop as soon as you find the codebox
+			return (0);
+
+		};
+
+		/* determine the box type */
+		for (box_type = JP_BOX; box_type < UNK_BOX; box_type++)
+			if (memcmp(TBox, j22box[box_type].value, 4) == 0)
+				break;	
+
+		/* read the optional XLBox, 8 bytes */
+		if (LBox == 1) {
+
+			if (fileid->Read(&XLBox, 8) < 8) {
+				WriteText(wxT("Problem reading XLBox from the file (file ended?)"));
+				return -1;
+			};
+			box_length = (unsigned long int) BYTE_SWAP8(XLBox);
+
+		} else if (LBox == 0x00000000) {
+
+			/* last box in file */
+			last_box = 1; 
+			box_length = filelimit - filepoint;
+
+		} else
+
+			box_length = LBox;
+
+		/* show box info */
+
+		// append the marker
+		int image, imageSel;
+		image = m_tree->TreeCtrlIcon_Folder;
+		imageSel = image + 1;
+		wxTreeItemId currid = m_tree->AppendItem(parentid,
+			wxString::Format(wxT("%03d: "), box_num) +
+			wxString::FromAscii(TBox) +
+			wxString::Format(wxT(" (0x%04X)"),
+				((unsigned long int) TBox[3]) + ((unsigned long int) TBox[2] << 8) +
+				((unsigned long int) TBox[1] << 16) + ((unsigned long int) TBox[0] << 24)
+			),
+			image, imageSel,
+			new OPJMarkerData(wxT("BOX"), m_tree->m_fname.GetFullPath(), filepoint, filepoint + box_length)
+			);
+
+		// append some info
+		image = m_tree->TreeCtrlIcon_File;
+		imageSel = image + 1;
+
+		// box name
+		wxTreeItemId subcurrid1 = m_tree->AppendItem(currid,
+			wxT("*** ") + wxString::FromAscii(j22box[box_type].name) + wxT(" ***"),
+			image, imageSel,
+			new OPJMarkerData(wxT("INFO"))
+			);
+		m_tree->SetItemFont(subcurrid1, *wxITALIC_FONT);
+
+		// position and length
+		wxTreeItemId subcurrid2 = m_tree->AppendItem(currid,
+			wxLongLong(filepoint).ToString() + wxT(" > ") + wxLongLong(filepoint + box_length - 1).ToString() + 
+			wxT(", ") + wxString::Format(wxT("%d + 8 (%d)"), box_length, box_length + 8),
+			image, imageSel,
+			new OPJMarkerData(wxT("INFO"))
+			);
+
+		/* go deep in the box */
+		box_handler_function((int) box_type, fileid, (LBox == 1) ? (filepoint + 16) : (filepoint + 8), filepoint + box_length,
+			currid, level, scansign, scanpoint);
+
+		/* if it's a superbox go inside it */
+		if (j22box[box_type].sbox)
+			jpeg2000parse(fileid, (LBox == 1) ? (filepoint + 16) : (filepoint + 8), filepoint + box_length,
+				currid, level + 1, scansign, scanpoint);
+
+		/* increment box number and filepoint*/
+		box_num++;
+		filepoint += box_length;
+
+	};
+
+	/* all good */
+	return (0);
+}
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/wxj2kparser.cpp ./OPJViewer/source/wxj2kparser.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/wxj2kparser.cpp	2007-04-27 18:20:26.000000000 +0100
+++ ./OPJViewer/source/wxj2kparser.cpp	2007-11-27 22:39:50.000000000 +0000
@@ -255,7 +255,8 @@
 			wxString::FromAscii(marker_name[m]) + 
 			wxString::Format(wxT(" (0x%04X)"), marker_val[m]),
 			image, imageSel,
-			new OPJMarkerData(wxT("MARK"), m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
+			new OPJMarkerData(wxT("MARK") + wxString::Format(wxT(" (%d)"), marker_val[m]),
+				m_tree->m_fname.GetFullPath(), offset, offset + currlen + 1)
 			);
 
 		// append some info
@@ -303,6 +304,7 @@
 			};
 			break;
 
+#ifdef USE_JPWL
 		/////////
 		// RED //
 		/////////
@@ -550,6 +552,15 @@
 
 			}
 			break;
+#endif // USE_JPWL
+
+#ifdef USE_JPSEC
+		case SEC_VAL:
+			{
+
+			}
+			break;
+#endif // USE_JPSEC
 
 		/////////
 		// SIZ //
diff -urN /home/robin/sldeb/trunk/OPJViewer/source/wxjp2parser.cpp ./OPJViewer/source/wxjp2parser.cpp
--- /home/robin/sldeb/trunk/OPJViewer/source/wxjp2parser.cpp	2007-03-30 10:27:08.000000000 +0100
+++ ./OPJViewer/source/wxjp2parser.cpp	2007-09-28 11:33:50.000000000 +0100
@@ -60,6 +60,8 @@
 			TRAK_BOX,
 			TKHD_BOX,
 			MDIA_BOX,
+			MDHD_BOX,
+			HDLR_BOX,
 			MINF_BOX,
 			VMHD_BOX,
 			STBL_BOX,
@@ -102,6 +104,8 @@
 #define TRAK_SIGN           "trak"
 #define TKHD_SIGN           "tkhd"
 #define MDIA_SIGN           "mdia"
+#define MDHD_SIGN           "mdhd"
+#define HDLR_SIGN           "hdlr"
 #define MINF_SIGN           "minf"
 #define VMHD_SIGN           "vmhd"
 #define STBL_SIGN           "stbl"
@@ -231,6 +235,22 @@
 /* req */	{1, 1, 1},
 /* ins */	TRAK_BOX},
 
+/* sign */	{MDHD_SIGN,
+/* short */	"Media Header box",
+/* long */	"The media header declares overall information which is media-independent, and relevant to characteristics "
+			"of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
+/* sign */	{HDLR_SIGN,
+/* short */	"Handler Reference box",
+/* long */	"This box within a Media Box declares the process by which the media-data in the track may be presented, "
+			"and thus, the nature of the media in a track",
+/* sbox */	0,
+/* req */	{1, 1, 1},
+/* ins */	MDIA_BOX},
+
 /* sign */	{MINF_SIGN,
 /* short */	"Media Information box",
 /* long */	"This box contains all the objects which declare characteristic information of the media in the track",
@@ -303,10 +323,18 @@
 /* From little endian to big endian, 2 and 4 bytes */
 #define	BYTE_SWAP2(X)	((X & 0x00FF) << 8) | ((X & 0xFF00) >> 8)
 #define	BYTE_SWAP4(X)	((X & 0x000000FF) << 24) | ((X & 0x0000FF00) << 8) | ((X & 0x00FF0000) >> 8) | ((X & 0xFF000000) >> 24)
-#define	BYTE_SWAP8(X)	(((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
+
+#ifdef __WXGTK__
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FFULL) << 56) | ((X & 0x000000000000FF00ULL) << 40) | \
+                        ((X & 0x0000000000FF0000ULL) << 24) | ((X & 0x00000000FF000000ULL) << 8) | \
+						((X & 0x000000FF00000000ULL) >> 8)  | ((X & 0x0000FF0000000000ULL) >> 24) | \
+						((X & 0x00FF000000000000ULL) >> 40) | ((X & 0xFF00000000000000ULL) >> 56)
+#else
+#define	BYTE_SWAP8(X)	((X & 0x00000000000000FF) << 56) | ((X & 0x000000000000FF00) << 40) | \
                         ((X & 0x0000000000FF0000) << 24) | ((X & 0x00000000FF000000) << 8) | \
 						((X & 0x000000FF00000000) >> 8)  | ((X & 0x0000FF0000000000) >> 24) | \
-						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56))
+						((X & 0x00FF000000000000) >> 40) | ((X & 0xFF00000000000000) >> 56)
+#endif
 
 /* From codestream to int values */
 #define STREAM_TO_UINT32(C, P)	(((unsigned long int) (C)[(P) + 0] << 24) + \
@@ -821,7 +849,114 @@
 		};
 		break;
 
+		/* Media Header box */
+	case (MDHD_BOX): {
+			unsigned long int version;
+			unsigned short int language;
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			if (version == 0) {
+				unsigned long int creation_time, modification_time, timescale, duration;
+				fileid->Read(&creation_time, sizeof(unsigned long int));
+				creation_time = BYTE_SWAP4(creation_time);
+				fileid->Read(&modification_time, sizeof(unsigned long int));
+				modification_time = BYTE_SWAP4(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(unsigned long int));
+				duration = BYTE_SWAP4(duration);
+				const long unix_time = creation_time - 2082844800L;
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u (%.24s)"), creation_time, ctime(&unix_time)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				const long unix_time1 = modification_time - 2082844800L;
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u (%.24s)"), modification_time, ctime(&unix_time1)),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u (%.6fs)"), timescale, 1.0 / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u (%.3fs)"), duration, (float) duration / (float) timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			} else {
+				int8byte creation_time, modification_time, duration;
+				unsigned long int timescale;
+				fileid->Read(&creation_time, sizeof(int8byte));
+				creation_time = BYTE_SWAP8(creation_time);
+				fileid->Read(&modification_time, sizeof(int8byte));
+				modification_time = BYTE_SWAP8(modification_time);
+				fileid->Read(&timescale, sizeof(unsigned long int));
+				timescale = BYTE_SWAP4(timescale);
+				fileid->Read(&duration, sizeof(int8byte));
+				duration = BYTE_SWAP8(duration);
+				wxTreeItemId currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Creation time: %u"), creation_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Modification time: %u"), modification_time),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Timescale: %u"), timescale),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+				currid = m_tree->AppendItem(parentid,
+					wxString::Format(wxT("Duration: %u"), duration),
+					m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+					new OPJMarkerData(wxT("INFO"))
+					);
+			}
+			fileid->Read(&language, sizeof(unsigned short int));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Language: %d (%c%c%c)"), language & 0xEFFF,
+				0x60 + (char) ((language >> 10) & 0x001F), 0x60 + (char) ((language >> 5) & 0x001F), 0x60 + (char) ((language >> 0) & 0x001F)),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+		};
+		break;
 		
+		/* Media Handler box */
+	case (HDLR_BOX): {
+			unsigned long int version, predefined, temp[3];
+			char handler[4], name[256];
+			int namelen = wxMin(256, (filelimit - filepoint - 24));
+			fileid->Read(&version, sizeof(unsigned long int));
+			version = BYTE_SWAP4(version);
+			fileid->Read(&predefined, sizeof(unsigned long int));
+			fileid->Read(handler, 4 * sizeof(char));
+			fileid->Read(&temp, 3 * sizeof(unsigned long int));
+			fileid->Read(name, namelen * sizeof(char));
+
+			wxTreeItemId currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Handler: %.4s"), handler),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 
+			currid = m_tree->AppendItem(parentid,
+				wxString::Format(wxT("Name: %.255s"), name),
+				m_tree->TreeCtrlIcon_File, m_tree->TreeCtrlIcon_File + 1,
+				new OPJMarkerData(wxT("INFO"))
+				);
+					 				 
+		}
+		break;
+
 	/* not yet implemented */
 	default:
 		break;
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/all-wcprops ./OPJViewer/.svn/all-wcprops
--- /home/robin/sldeb/trunk/OPJViewer/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/all-wcprops	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,41 @@
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/469/trunk/OPJViewer
+END
+OPJViewer.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/469/trunk/OPJViewer/OPJViewer.dsp
+END
+OPJViewer.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/343/trunk/OPJViewer/OPJViewer.dsw
+END
+OPJViewer.iss
+K 25
+svn:wc:ra_dav:version-url
+V 47
+/svn/!svn/ver/397/trunk/OPJViewer/OPJViewer.iss
+END
+buildupdate.bat
+K 25
+svn:wc:ra_dav:version-url
+V 49
+/svn/!svn/ver/410/trunk/OPJViewer/buildupdate.bat
+END
+Readme.txt
+K 25
+svn:wc:ra_dav:version-url
+V 44
+/svn/!svn/ver/410/trunk/OPJViewer/Readme.txt
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/469/trunk/OPJViewer/Makefile
+END
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/entries ./OPJViewer/.svn/entries
--- /home/robin/sldeb/trunk/OPJViewer/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/entries	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,106 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk/OPJViewer
+http://www.openjpeg.org/svn
+
+
+
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+OPJViewer.dsp
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+da474533773397e4104a71a74f718e55
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
+source
+dir
+
+OPJViewer.dsw
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+2c5b7b225003a03e18127a8a40cc2c79
+2007-02-22T17:05:58.742476Z
+343
+devaux
+
+OPJViewer.iss
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+f169f36228df78551702c6be850fc118
+2007-06-16T17:28:47.212959Z
+397
+unipg
+
+buildupdate.bat
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+6c28ba34c2cf016363348c82545a497c
+2007-08-02T12:45:28.829464Z
+410
+unipg
+
+about
+dir
+
+Readme.txt
+file
+
+
+
+
+2007-09-28T10:33:50.000000Z
+343a28a4ec6ecc87a59314c1a9943b28
+2007-08-02T12:45:28.829464Z
+410
+unipg
+
+Makefile
+file
+
+
+
+
+2007-11-27T22:39:50.000000Z
+f1dccb2934446e9bc773d2e4b7302160
+2007-11-05T13:05:07.639602Z
+469
+unipg
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/format ./OPJViewer/.svn/format
--- /home/robin/sldeb/trunk/OPJViewer/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/format	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/buildupdate.bat.svn-base ./OPJViewer/.svn/text-base/buildupdate.bat.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/buildupdate.bat.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/buildupdate.bat.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,15 @@
+::== buildupdate.bat
+@echo off
+setLocal EnableDelayedExpansion
+
+for /f "tokens=2,* delims=^(^) " %%a in ('find /v "" ^< .\source\build.h') do (
+rem echo %%a
+set /A M = %%a + 1
+echo Build %%a done^!
+echo wxT^("!M!"^) > buildtemp283746825t347
+)
+
+if exist buildtemp283746825t347 move /Y buildtemp283746825t347 .\source\build.h
+if exist buildtemp283746825t347 del /F /Q buildtemp283746825t347
+
+::==
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/Makefile.svn-base ./OPJViewer/.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/Makefile.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,41 @@
+# Makefile for OPJViewer
+
+# General configuration variables:
+CC = $(shell wx-config-2.8 --cxx)
+AR = ar
+
+CFLAGS = -DUSE_JPWL -DwxUSE_LIBOPENJPEG -DwxUSE_GUI=1 -DOPJ_STATIC -DOPJ_HTMLABOUT $(shell wx-config-2.8 --cxxflags) # -g -p -pg -DUSE_JPWL
+
+OPJV_SRCS = source/imagj2k.cpp source/imagmj2.cpp source/wxj2kparser.cpp source/imagjp2.cpp source/OPJViewer.cpp source/wxjp2parser.cpp
+
+MODULES = $(OPJV_SRCS:.cpp=.o)
+
+all: opjviewer lib
+
+.cpp.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+lib:
+	cd ../jpwl; make
+
+opjviewer: $(OPJV_SRCS) lib
+        $(CC) $(CFLAGS) -I .. $(OPJV_SRCS) -o OPJViewer -L ../jpwl -lopenjpeg_JPWL -lm -lstdc++ -ltiff $(shell wx-config-2.8 --libs)
+
+
+clean:
+	rm -f OPJViewer *.o *.a
+	cd ../libopenjpeg; rm -f *.o
+
+
+
+
+#.cpp.o :
+#       $(CXX) -g -c `wx-config-2.8 --cxxflags` -I ../.. -D wxUSE_LIBOPENJPEG -D wxHACK_BOOLEAN -o $@ $<
+
+#all:    $(PROGRAM)
+
+#$(PROGRAM):     $(OBJECTS)
+#       $(CXX) -o $(PROGRAM) $(OBJECTS) -lopenjpeg -L ../.. `wx-config-2.8 --libs`
+
+#clean:
+#       rm -f *.o $(PROGRAM)
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.dsp.svn-base ./OPJViewer/.svn/text-base/OPJViewer.dsp.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/OPJViewer.dsp.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,295 @@
+# Microsoft Developer Studio Project File - Name="OPJViewer" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Console Application" 0x0103
+
+CFG=OPJVIEWER - WIN32 RELEASE
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "OPJViewer.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "OPJViewer.mak" CFG="OPJVIEWER - WIN32 RELEASE"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "OPJViewer - Win32 Release" (based on "Win32 (x86) Console Application")
+!MESSAGE "OPJViewer - Win32 Debug" (based on "Win32 (x86) Console Application")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "OPJViewer - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /c
+# ADD CPP /nologo /G6 /MD /W3 /GX /O2 /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "d:\programmi\wxWidgets-2.8.0\include" /I ".." /D "NDEBUG" /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "USE_JPSEC" /D "OPJ_HTMLABOUT" /D "OPJ_MANYFORMATS" /D "OPJ_INICONFIG" /FR /FD /c
+# ADD BASE RSC /l 0x410 /d "NDEBUG"
+# ADD RSC /l 0x409 /i "d:\programmi\wxWidgets-2.8.0\include" /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlib.lib wxregex.lib wxpng.lib wxjpeg.lib wxbase28.lib wxmsw28_core.lib wxmsw28_html.lib wxmsw28_adv.lib wxmsw28_core.lib wxbase28.lib wxtiff.lib wxjpeg.lib wxpng.lib wxzlib.lib wxregex.lib wxexpat.lib LibOpenJPEG_JPWL.lib /nologo /subsystem:windows /machine:I386 /nodefaultlib:"libcmt.lib" /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Release" /IGNORE:4089
+# SUBTRACT LINK32 /pdb:none
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Desc=Update build number
+PostBuild_Cmds=buildupdate.bat
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "OPJViewer___Win32_Debug"
+# PROP BASE Intermediate_Dir "OPJViewer___Win32_Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_CONSOLE" /D "_MBCS" /YX /FD /GZ /c
+# ADD CPP /nologo /MDd /W3 /Gm /GX /Zi /Od /I "d:\Programmi\wxWidgets-2.8.0\INCLUDE" /I "d:\programmi\wxWidgets-2.8.0\lib\vc_lib\msw" /I "c:\programmi\wxWidgets-2.8.0\include" /I ".." /D "_DEBUG" /D "__WXDEBUG__" /D WXDEBUG=1 /D "WIN32" /D "_CONSOLE" /D "_MBCS" /D "_WINDOWS" /D WINVER=0x400 /D "_MT" /D wxUSE_GUI=1 /D "wxUSE_LIBOPENJPEG" /D "OPJ_STATIC" /D "USE_JPWL" /D "OPJ_HTMLABOUT" /FR /FD /GZ /c
+# ADD BASE RSC /l 0x410 /d "_DEBUG"
+# ADD RSC /l 0x410 /i "d:\programmi\wxWidgets-2.8.0\include" /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /subsystem:console /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib comctl32.lib rpcrt4.lib wsock32.lib wxzlibd.lib wxregexd.lib wxpngd.lib wxjpegd.lib wxtiffd.lib wxbase28d.lib wxmsw28d_core.lib wxmsw28d_html.lib wxmsw28d_adv.lib LibOpenJPEG_JPWLd.lib /nologo /subsystem:windows /debug /machine:I386 /nodefaultlib:"libcmtd.lib" /pdbtype:sept /libpath:"d:\programmi\wxWidgets-2.8.0\lib\vc_lib" /libpath:"..\jpwl\Debug"
+# SUBTRACT LINK32 /pdb:none
+
+!ENDIF 
+
+# Begin Target
+
+# Name "OPJViewer - Win32 Release"
+# Name "OPJViewer - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\source\imagj2k.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagjp2.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagjpeg2000.cpp
+# PROP Exclude_From_Build 1
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagmj2.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJDialogs.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJViewer.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wxj2kparser.cpp
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wxjp2parser.cpp
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\source\about_htm.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\build.h
+
+!IF  "$(CFG)" == "OPJViewer - Win32 Release"
+
+# PROP Exclude_From_Build 1
+
+!ELSEIF  "$(CFG)" == "OPJViewer - Win32 Debug"
+
+!ENDIF 
+
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagj2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagjp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\imagmj2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJViewer.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\source\wx\msw\blank.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\bullseye.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cdrom.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\computer.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\cross.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\drive.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\file1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\floppy.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder1.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\folder2.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\hand.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\icon1.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\icon2.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\icon3.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\icon4.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\icon5.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\magnif1.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\opj_logo.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJChild.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJChild16.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJViewer.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJViewer.rc
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\OPJViewer16.xpm
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pbrush.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pencil.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntleft.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\pntright.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\removble.ico
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\rightarr.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\roller.cur
+# End Source File
+# Begin Source File
+
+SOURCE=.\source\wx\msw\std.ico
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.dsw.svn-base ./OPJViewer/.svn/text-base/OPJViewer.dsw.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/OPJViewer.dsw.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,44 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "LibOpenJPEG_JPWL"=..\jpwl\LibOpenJPEG_JPWL.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "OPJViewer"=.\OPJViewer.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+    Begin Project Dependency
+    Project_Dep_Name LibOpenJPEG_JPWL
+    End Project Dependency
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.iss.svn-base ./OPJViewer/.svn/text-base/OPJViewer.iss.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/OPJViewer.iss.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/OPJViewer.iss.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,48 @@
+; Script generated by the Inno Setup Script Wizard.
+; SEE THE DOCUMENTATION FOR DETAILS ON CREATING INNO SETUP SCRIPT FILES!
+
+[Setup]
+AppName=OPJViewer
+AppVerName=OPJViewer 0.3 alpha
+AppPublisher=OpenJPEG
+AppPublisherURL=http://www.openjpeg.org
+AppSupportURL=http://www.openjpeg.org
+AppUpdatesURL=http://www.openjpeg.org
+DefaultDirName={pf}\OPJViewer
+DefaultGroupName=OPJViewer
+OutputDir=setup
+OutputBaseFilename=OPJViewer03alpha_setup
+Compression=lzma
+SolidCompression=true
+InfoBeforeFile=source\readmebefore.txt
+InfoAfterFile=source\readmeafter.txt
+LicenseFile=source\license.txt
+VersionInfoVersion=0.3.0.0
+VersionInfoCompany=OpenJPEG
+VersionInfoDescription=JPEG 2000 viewer
+ShowLanguageDialog=yes
+SetupIconFile=source\OPJViewer.ico
+
+[Languages]
+Name: english; MessagesFile: compiler:Default.isl
+
+[Tasks]
+Name: desktopicon; Description: {cm:CreateDesktopIcon}; GroupDescription: {cm:AdditionalIcons}; Flags: unchecked
+
+[Files]
+Source: Release\OPJViewer.exe; DestDir: {app}; Flags: ignoreversion
+;Source: about\about.htm; DestDir: {app}/about; Flags: ignoreversion
+;Source: about\opj_logo.png; DestDir: {app}/about; Flags: ignoreversion
+; NOTE: Don't use "Flags: ignoreversion" on any shared system files
+
+[Icons]
+Name: {group}\OPJViewer; Filename: {app}\OPJViewer.exe; WorkingDir: {app}; IconIndex: 0
+Name: {group}\{cm:UninstallProgram,OPJViewer}; Filename: {uninstallexe}
+Name: {userdesktop}\OPJViewer; Filename: {app}\OPJViewer.exe; Tasks: desktopicon; WorkingDir: {app}; IconIndex: 0
+
+[Run]
+Filename: {app}\OPJViewer.exe; Description: {cm:LaunchProgram,OPJViewer}; Flags: nowait postinstall skipifsilent; WorkingDir: {app}
+
+[Registry]
+Root: HKCU; Subkey: Software\OpenJPEG; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
+Root: HKCU; Subkey: Software\OpenJPEG\OPJViewer; ValueType: none; ValueData: 1; Flags: uninsdeletekey; Tasks: ; Languages: 
diff -urN /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/Readme.txt.svn-base ./OPJViewer/.svn/text-base/Readme.txt.svn-base
--- /home/robin/sldeb/trunk/OPJViewer/.svn/text-base/Readme.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./OPJViewer/.svn/text-base/Readme.txt.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,95 @@
+===============================================================================
+	JPEG2000 Visualization Software - OPJViewer
+
+		Version 0.3 alpha
+===============================================================================
+
+
+1. Scope
+=============
+
+This document describes the installation and use of the OPJViewer in the framework of OpenJPEG library.
+
+This implementation has been developed using the OpenJPEG library as decoding engine and wxWidgets 2.8 as GUI engine.
+
+If you find some bugs or if you have problems using the viewer, please send an e-mail to jpwl@diei.unipg.it
+
+2. Installing the viewer
+==========================
+
+There are two options available, at the moment:
+
+a) compile from source code
+b) download a precompiled binary.
+
+In order to use option a), it is mandatory to have compiled and built the LibOpenJPEG_JPWL library and the wxWidgets 2.8 framework (you have to download it from http://www.wxwidgets.org/ and compile the wx* libraries).
+
+2.1. Compiling the source code in Windows
+-------------------------------------------
+
+The steps required to compile the viewer under windows are:
+
+a) Download at least the libopenjpeg, jpwl, and opjviewer folders from the SVN trunk.
+b) Open the OPJViewer.dsw workspace with Visual C++ 6 and activate the "OPJViewer - Win32 Release" configuration.
+c) In the configuration settings, go to the C++ tab and modify the wxWidgets paths in order to reflect your wx* install configuration (Preprocessor -> Additional include directories): simply update each instance of the two wx paths, do not remove or add them.
+d) In the configuration settings, go to the Link tab and modify the wxWidgets path in order to reflect your wx* install configuration (Input -> Additional library path): simply update the wx path.
+e) In the configuration settings, go to the Resources tab and modify the wxWidgets path in order to reflect your wx* install configuration (Additional resource include directories): simply update the wx path.
+f) Build!
+g) Run!
+h) (OPTIONAL) Prepare an installer by compiling the InnoSetup script OPJViewer.iss (you need to download InnoSetup from http://www.jrsoftware.org/isinfo.php).
+
+2.2. Compiling the source code in Unix-like systems
+-----------------------------------------------------
+
+The porting is possible and under way.
+
+
+3. General information on the viewer
+====================================
+
+This viewer is conceived to open and display information and image content of J2K, JP2, and MJ2 files.
+The viewer application interface is divided into three main panels:
+- a browsing pane;
+- a viewing pane;
+- a log/peek pane.
+
+The browsing pane will present the markers or boxes hierarchy, with position (byte number where marker/box starts and stops) and length information (i.e., inner length as signalled by marker/box and total length, with marker/box sign included), in the following form:
+
+filename
+|
+|_ #000: Marker/Box short name (Hex code)
+|  |
+|  |_ *** Marker/Box long name ***
+|  |_ startbyte > stopbyte, inner_length + marker/box sign length (total length)
+|  |_ Additional info, depending on the marker/box type
+|  |_ ...
+|
+|_ #001: Marker/Box short name (Hex code)
+|  |
+|  |_ ...
+|
+...
+
+
+The viewing pane will display the decoded image contained in the JPEG 2000 file.
+It should display correctly images as large as 4000x2000, provided that a couple of GB of RAM are available. Nothing is known about the display of larger sizes: let us know if you manage to get it working.
+
+
+The log/peek pane is shared among two different subpanels:
+
+- the log panel will report a lot of debugging info coming out from the wx GUI as well as from the openjpeg library
+- the peek pane tries to give a peek on the codestream/file portion which is currently selected in the browsing pane. It shows both hex and ascii values corresponding to the marker/box section. 
+
+
+4. Known bugs and limitations
+===============================
+
+4.1. Bugs
+-----------
+
+* 
+
+4.2. Limitations
+------------------
+
+* For mj2 files, rendering is only in B/W
diff -urN /home/robin/sldeb/trunk/README.cmake ./README.cmake
--- /home/robin/sldeb/trunk/README.cmake	2007-04-26 10:08:10.000000000 +0100
+++ ./README.cmake	2007-09-28 11:33:52.000000000 +0100
@@ -6,4 +6,4 @@
   cd bin
   cmake .. -DBUILD_EXAMPLES:BOOL=ON
   make
-  ./codec/j2k_to_image 
+  ./bin/j2k_to_image 
diff -urN /home/robin/sldeb/trunk/.svn/all-wcprops ./.svn/all-wcprops
--- /home/robin/sldeb/trunk/.svn/all-wcprops	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/all-wcprops	2007-11-27 22:41:28.000000000 +0000
@@ -0,0 +1,113 @@
+K 25
+svn:wc:ra_dav:version-url
+V 23
+/svn/!svn/ver/482/trunk
+END
+LibOpenJPEG.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/384/trunk/LibOpenJPEG.dsp
+END
+Makefile.osx
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/395/trunk/Makefile.osx
+END
+clean.bat
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/243/trunk/clean.bat
+END
+ChangeLog
+K 25
+svn:wc:ra_dav:version-url
+V 33
+/svn/!svn/ver/482/trunk/ChangeLog
+END
+DllOpenJPEG.dsp
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/317/trunk/DllOpenJPEG.dsp
+END
+LibOpenJPEG.sln
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/415/trunk/LibOpenJPEG.sln
+END
+LibOpenJPEG.dsw
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/317/trunk/LibOpenJPEG.dsw
+END
+README.linux
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/360/trunk/README.linux
+END
+DllOpenJPEG.sln
+K 25
+svn:wc:ra_dav:version-url
+V 39
+/svn/!svn/ver/415/trunk/DllOpenJPEG.sln
+END
+license.txt
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/452/trunk/license.txt
+END
+LibOpenJPEG.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/467/trunk/LibOpenJPEG.vcproj
+END
+README.msvc
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/248/trunk/README.msvc
+END
+README.osx
+K 25
+svn:wc:ra_dav:version-url
+V 34
+/svn/!svn/ver/363/trunk/README.osx
+END
+DllOpenJPEG.vcproj
+K 25
+svn:wc:ra_dav:version-url
+V 42
+/svn/!svn/ver/415/trunk/DllOpenJPEG.vcproj
+END
+OpenJPEG.rc
+K 25
+svn:wc:ra_dav:version-url
+V 35
+/svn/!svn/ver/441/trunk/OpenJPEG.rc
+END
+README.cmake
+K 25
+svn:wc:ra_dav:version-url
+V 36
+/svn/!svn/ver/440/trunk/README.cmake
+END
+Makefile
+K 25
+svn:wc:ra_dav:version-url
+V 32
+/svn/!svn/ver/471/trunk/Makefile
+END
+CMakeLists.txt
+K 25
+svn:wc:ra_dav:version-url
+V 38
+/svn/!svn/ver/475/trunk/CMakeLists.txt
+END
diff -urN /home/robin/sldeb/trunk/.svn/entries ./.svn/entries
--- /home/robin/sldeb/trunk/.svn/entries	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/entries	2007-11-27 22:41:39.000000000 +0000
@@ -0,0 +1,290 @@
+8
+
+dir
+482
+http://www.openjpeg.org/svn/trunk
+http://www.openjpeg.org/svn
+
+
+
+2007-11-27T14:00:45.535020Z
+482
+devaux
+
+
+svn:special svn:externals svn:needs-lock
+
+
+
+
+
+
+
+
+
+
+
+1c9c69ae-ce1e-0410-ad13-fa5f67c9e0d3
+
+indexer_JPIP
+dir
+
+LibOpenJPEG.dsp
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+9e46ab834e7a19dbaf900126c057f5c2
+2007-05-21T09:44:10.589421Z
+384
+devaux
+has-props
+
+Makefile.osx
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+3bc25e85728b9ea0859be974ff936f6e
+2007-06-05T09:00:34.681184Z
+395
+antonin
+has-props
+
+ChangeLog
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+8a451cbfe6c7e36c3df008363292965b
+2007-11-27T14:00:45.535020Z
+482
+devaux
+has-props
+
+clean.bat
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+7951e7495da8879668480b89fb0c9c7b
+2006-01-31T21:26:11.000000Z
+243
+freeimage
+has-props
+
+DllOpenJPEG.dsp
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+03d68083afb752554f7e129b48751b69
+2006-12-04T16:25:52.503753Z
+317
+devaux
+has-props
+
+mj2
+dir
+
+LibOpenJPEG.sln
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+6c27a14ef8ebe75bc567c467c0017f2e
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+libs
+dir
+
+LibOpenJPEG.dsw
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+ee29241f3f928249cdaabff000ce873f
+2006-12-04T16:25:52.503753Z
+317
+devaux
+has-props
+
+README.linux
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+042b9a61f37b44b9b29bb4373be7e5b0
+2007-03-14T07:35:54.630261Z
+360
+devaux
+has-props
+
+DllOpenJPEG.sln
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+cbd47ec60920b747c6e96429323cb415
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+libopenjpeg
+dir
+
+CVSROOT
+dir
+
+jp3d
+dir
+
+LibOpenJPEG.vcproj
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+4880e6aa8fbfb0a85d5c1155b8b518ec
+2007-10-18T12:26:11.065274Z
+467
+devaux
+
+license.txt
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+a57eb636ed9db19accce3d20c522609e
+2007-09-07T13:52:43.857868Z
+452
+gdcm
+has-props
+
+README.msvc
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+0be34e028c90a51f7c252bb984750bd7
+2006-02-02T13:15:21.000000Z
+248
+descampe
+has-props
+
+doc
+dir
+
+DllOpenJPEG.vcproj
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+639135bb828b8c745a627655d80c9024
+2007-08-21T10:17:35.752525Z
+415
+devaux
+
+README.osx
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+526830510931248d977eba3db094ceda
+2007-03-23T14:08:15.094431Z
+363
+antonin
+has-props
+
+j2kviewer
+dir
+
+OPJViewer
+dir
+
+OpenJPEG.rc
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+0ca2391b8c5a14ca93c919b018e7498c
+2007-09-06T14:46:24.695057Z
+441
+gdcm
+has-props
+
+jpwl
+dir
+
+README.cmake
+file
+
+
+
+
+2007-09-28T10:33:52.000000Z
+cff8e15c7ef19192a007a40455198860
+2007-09-06T11:01:10.478652Z
+440
+gdcm
+
+codec
+dir
+
+Makefile
+file
+
+
+
+
+2007-11-27T22:41:39.000000Z
+3bb43ea719390ab48f3669cf1133362f
+2007-11-08T14:26:03.882351Z
+471
+devaux
+has-props
+
+CMakeLists.txt
+file
+
+
+
+
+2007-11-27T22:39:51.000000Z
+cb4b7d1132cda97f66dd67abb8464944
+2007-11-08T14:52:45.806133Z
+475
+gdcm
+has-props
+
diff -urN /home/robin/sldeb/trunk/.svn/format ./.svn/format
--- /home/robin/sldeb/trunk/.svn/format	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/format	2007-09-28 11:33:39.000000000 +0100
@@ -0,0 +1 @@
+8
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/ChangeLog.svn-base ./.svn/prop-base/ChangeLog.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/ChangeLog.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/ChangeLog.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/clean.bat.svn-base ./.svn/prop-base/clean.bat.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/clean.bat.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/clean.bat.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/CMakeLists.txt.svn-base ./.svn/prop-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/CMakeLists.txt.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/DllOpenJPEG.dsp.svn-base ./.svn/prop-base/DllOpenJPEG.dsp.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/DllOpenJPEG.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/DllOpenJPEG.dsp.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/LibOpenJPEG.dsp.svn-base ./.svn/prop-base/LibOpenJPEG.dsp.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/LibOpenJPEG.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/LibOpenJPEG.dsp.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/LibOpenJPEG.dsw.svn-base ./.svn/prop-base/LibOpenJPEG.dsw.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/LibOpenJPEG.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/LibOpenJPEG.dsw.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/license.txt.svn-base ./.svn/prop-base/license.txt.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/license.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/license.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 9
+eol-style
+V 6
+native
+K 9
+mime-type
+V 10
+text/plain
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/Makefile.osx.svn-base ./.svn/prop-base/Makefile.osx.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/Makefile.osx.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/Makefile.osx.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/Makefile.svn-base ./.svn/prop-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/Makefile.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/OpenJPEG.rc.svn-base ./.svn/prop-base/OpenJPEG.rc.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/OpenJPEG.rc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/OpenJPEG.rc.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 4
+CRLF
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/README.linux.svn-base ./.svn/prop-base/README.linux.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/README.linux.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/README.linux.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/README.msvc.svn-base ./.svn/prop-base/README.msvc.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/README.msvc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/README.msvc.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/prop-base/README.osx.svn-base ./.svn/prop-base/README.osx.svn-base
--- /home/robin/sldeb/trunk/.svn/prop-base/README.osx.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/prop-base/README.osx.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,9 @@
+K 13
+svn:eol-style
+V 6
+native
+K 12
+svn:keywords
+V 23
+Author Date Id Revision
+END
diff -urN /home/robin/sldeb/trunk/.svn/text-base/ChangeLog.svn-base ./.svn/text-base/ChangeLog.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/ChangeLog.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/ChangeLog.svn-base	2007-11-27 22:39:49.000000000 +0000
@@ -0,0 +1,460 @@
+What's New for OpenJPEG
+
+* : fixed
+- : removed
+! : changed
++ : added
+
+November 14, 2007
++ [FOD] Created the file index.c in the codec directory. This file handles the creation of index files, 
+		at encoding and decoding. 
+* [FOD] Fixed bugs during the creation of the index (PCRL progression order)
+* [FOD] Fixed the maximum number of resolutions a user can discard while decoding.
+		Added an error state in J2K_STATE (j2k.c)
+
+November 14, 2007
+! [FOD] - First Patch by Callum Lerwick. Instead of reinventing realloc, j2k_read_sod now just uses opj_realloc in j2k.c
+		- Second Patch by Callum Lerwick. This patch rearranges the largest memory allocations so they're allocated as 
+		late as possible, and freed as soon as possible. This cuts memory usage by about half on two large test images.
+		- Third Patch by Callum Lerwick. The opj_tcd_cblk array is one of the largest allocations, because it
+		contains a bunch of static buffers. This also makes it a major source of cache thrashing. This patch allocates 
+		the buffers from the heap, and dynamically sizes them in the decoder. I have not yet managed to dynamically size 
+		them in the encoder, getting the decoder to do it was tricky enough... I also split opj_tcd_cblk_t into separate 
+		encode and decode versions. A lot of fields were not used by both, so this cuts its size even further.
+
+* [FOD] Avoided ABI breakage
+
+November 13, 2007
+! [FOD] Patch by Dzonatas and Callum Lerwick.
+        Fp/vectorization patch which basically converts most of the irreversible decode codepath to floating point,
+        eliminating a few rounds of int/fp conversion, resulting in a vast performance improvement,
+	and an increase in accuracy.
+
+November 8, 2007
+! [FOD] In t1.c, small change to avoid calling twice t1_getwmsedec()
+        Patches from Callum Lewick:
+		- Basic gcc optimization flags in cmake and makefile match.
+		- Fixed some spelling errors in dwt.c.
+
+November 5, 2007
+*+ [GB] Fixed a bug which prevented JPWL from working on multi-tiled images; added some more fields in the interface info structures 
+(keep a list of markers, save start packet number for each tile)
+
+October 23, 2007
+* [GB] Improved success for the linux build; OPJViewer shows all the COM contents
+ 
+October 18, 2007
+* [FOD] Changed the ROI parameter in the image_to_j2k codec to make it correspond to the documentation (i.e. -ROI c=0,U=25)
+* [FOD] Patch from Callum Lewick. Memset patch. 
+		The main idea of the patch is that currently opj_malloc clears all allocations, which unnecessarily
+		dirties up the cache and eats bandwidth. This patch makes it no longer do so, and I've painstakingly determined which allocations actually need
+		to be cleared and changed them to use opj_calloc() instead. I previously tried to just get rid of the opj_*alloc wrappers but that
+		idea was nixed, so this time I'm trying it with macros. I also put in a gcc pragma that helps enforce their use. Which got messy.  :)  It caught a
+		few places they weren't used but it also revealed that the mj2 tools are not very cleanly separated from the library. It includes all the
+		internal headers, but it wasn't using the malloc wrappers. I figured the binaries should be "external" and have minimal knowledge of the
+		internals of the library. I patched them to not include opj_includes.h, and include only the internal headers they actually need. However,
+		they're using the opj_clock() function, which is in with the malloc wrappers. So I decided to move the malloc wrappers to their own header. 
+		But mj2.c seems to want to be "internal", so I patched it to use the wrappers. Note that this patch changes the semantics of opj_malloc, it no longer
+		clears the memory it allocates. If you need it to be cleared, you must use opj_calloc instead, or memset it yourself. It is also somewhat
+		invasive, please test it extensively. I've been pounding on it all summer with my test suite, Second Life, and valgrind, and it checks out clean.
+
+October 12, 2007
+* [FOD] Changed the way the image structure is allocated when the decoding parameters include some resolutions to discard. 
+        This should have a significant impact for the decoding of huge images when some resolutions are discarder (-r parameter)
+        Warning: The output image size is now reduced when discarding resolutions !
+
+October 10, 2007
+* [FOD] Patch from Callum Lewick. Clean up of j2klib.h for the aligned malloc stuff. 
+        It makes it work right with mingw, as _mm_malloc() isn't a macro, attempts to pave the way to using cmake 
+        to check for this stuff and combines a patch from Dana Fagerstrom at Sun that makes it use memalign() on Solaris
+        convert.c: Changed some error comments for TIFF images
+
+September 27, 2007
+* [FOD] Patch from Callum Lewick. Fixed dwt.c where an alignment in buffer was problematic under x86_64.
+
+September 25, 2007
+* [Mathieu Malaterre] BUG: Fix previous patch from Callum Lerwick. I have no
+    clue what CMAKE_INSTALL_LIBDIR refers too. Bump up cmake 2.2 restriction to
+    cmake 2.4 because of previous patch (not backward compatible). Properly set the SOVERSION in a cross plateform way (yes WIN32 is a platform)
+
+September 19, 2007
+* [Parvatha] Fixed issues with generation of SOP marker. 
+
+September 18, 2007
+* [Parvatha] Fixed issues with Reading and Writing TIF images in convert.c to avoid segmentation fault. 
+* [Parvatha] Fixed issues relating to using user specified rates for CINEMA option for multiple images.
+
+September 17, 2007
+* [FOD] Fixed issues with cstr_info when codestream has components with different number of resolutions. 
+! [FOD] OpenJPEG library interface modified to retain compatibility with version 1.2 
+
+September 12, 2007
+* [FOD] Patch from Callum Lerwick.
+		Fixed the library linking so it links with the soversion properly set. 
+		Fixes up the install targets so that it interacts properly with RPM. 
+		Install target for MJ2. Sets some necessary and useful CFLAGS if gcc is in use.		
+* [FOD] Updated the MJ2 codec to be compatible with the recent changes in the OpenJPEG library
+
+September 11, 2007
+* [GB] JPWL encoding is finalized correctly into the JP2 file format; added an additional structure in opj_codestream_info, to keep a record of the written markers
+
+September 8, 2007
+* [GB] Adapted the JPWL and OPJViewer code to new interface; fixed a samll bug in JPWL which created large EPBs even when null protection was specified
+
+September 7, 2007
++ [FOD] Indexes can now be generated when decoding J2K codestreams.
+* [Mathieu Malaterre] Upon failure, properly return error code (!=0).
+* [Mathieu Malaterre] CMake: Add cmake code to do testing if user has properly setup a testimages directory
+
+September 6, 2007
++ [Mathieu Malaterre] CMake: start compiling mj2, jpwl and jp3d
++ [Mathieu Malaterre] CMake: output all executable/libs into one single directory
++ [Mathieu Malaterre] CMake: start compiling index_create
++ [Mathieu Malaterre] OpenJPEG.rc update copyright year
++ [Mathieu Malaterre] CMake: add Java j2kviewer but do not compile it using cmake since cmake has too poor support for Java. Should create a custom command running ant instead.
++ [Mathieu Malaterre] CMake: Add doxygen output
++ [GB] One more field in the codestream_info struct for recording the number of packets per tile part; JPWL now distributes the EPBs in all the tile part headers
++ [Mathieu Malaterre] CMake: Add very simple tests (simply run command line with no option)
+* [Mathieu Malaterre] Fix unitialized read in img_fol (we may need a smarter initialize than memset)
+
+September 4, 2007
++ [GB] Added some fields in the codestream_info structure: they are used to record the position of single tile parts. 
+		Changed also the write_index function in the codec, to reflect the presence of this new information.
+
+September 3, 2007
++ [GB] Added the knowledge of JPSEC SEC and INSEC markers (you have to compile the JPWL project). Management of these markers is limited to skipping them without crashing: 
+		no real security function at this stage. Deprecated USE_JPSEC will be removed next
+
+August 31, 2007
+* [GB] Fixed save capabilities in OPJViewer due to recent code upgrade
+
+August 30, 2007
+* [FOD] Changed the OpenJPEG library interface to enable users to access information regarding the codestream (also called codestream index).
+		This index is usefull for all applications requiring to have a scalable acces to the codestream (like JPIP applications, ...)
+        Currently, this information is only available when encoding an image.       
++ [FOD] Added the information regarding the end of packet position in the index        
+
+August 28, 2007
+* [FOD] Fixed wrong destructors called in openjpeg.c
+* [FOD] Fixed bug in j2k_decode_jpt_stream
+
+August 24, 2007
+* [Parvatha] The end of main header is calculated after TLM and POC marker for Dcinema.
+
+August 21, 2007
++ [FOD] Added support for Visual Studio 2005
+* [FOD] Robustified MJ2 codecs
+* [Parvatha] Solved problems with codec reading from image file directory when filename had more than one "." in name
+* [Callum Lerwick] Minor cleanup patch, that gets rid of a bunch of "old style declaration" warnings from Intel's compiler
+* [Callum Lerwick] Aligned malloc using Intel's _mm_malloc(). Cleanup on the t1 memory allocation, getting rid of some leftover debug code
+* [Callum Lerwick] Memory leaks fixed
+* [Callum Lerwick] Reworks of t1_updateflags to get rid of the shift operation
+* [Callum Lerwick] mqc_setcurctx moved to the header to allow it to be inlined into the t1.
+* [Callum Lerwick] Consolidated some calls to mqc_setcurctx.
+* [Callum Lerwick] Cleaned up t1_generate_luts to output the proper types.
+* [Callum Lerwick] Replaced the large ctxno_mag lookup table with a small bit of inline-able branchless code
+* [Callum Lerwick] Moved the orient flipping into the ctxno_zc table.
+
+August 20, 2007
++ [FOD] Added support for the TGA file format in the codec
+
+August 08, 2007
+* [Parvatha] Fixed the DCinema filesize allocation. It now includes the SOT marker size
+
+August 02, 2007
++ [GB] Added a basic saving capability to OPJViewer
+
+July 18, 2007
+! [FOD] Updated libtiff library version to 3.8.2 (for WIN32)
+* [FOD] Updated BMP and PxM truncation when decoding J2K files with more than 8 bits
+
+July 17, 2007
+* [FOD] Fixed raw option for images with more than three components
+
+July 17, 2007
++ [FOD] Added support for RAW images. This module has been developped by the University of Perugia team. Thanks to them ! [image_to_j2k.c j2k_to_image.c convert.c convert.h]
+
+July 13, 2007
+! [FOD] Modified the memory allocation for codestreams containing multiple tiles. The memory is now allocated for each tile indenpendently, 
+		leading to an important decrease of the virtual memory needed. [j2k.c tcd.h tcd.c]
+! [FOD] Modified old comments about the ability to decode mega-images and comments about the disk size necessary to do this. [image_to_j2k.c and frames_to_mj2.c]
+* [FOD] Added 2000 bytes for the memory allocation in cio.c for the minimum size of headers (useful in case of very small images) [cio.c]
+
+July 12, 2007
+* [GB] fixed a bug in JPWL module, which prevented to exploit the full error correction capability of RS codes (e.g. it gave up at 5 errors, 
+		even if 6 were correctable); defined a JPWL_MAXIMUM_EPB_ROOM for better customization of the maximum dimension of EPBs (the dimension 
+		is pre-calculated on an hypothesis, if it goes beyond 65535 there will be problems, thus we give a little less than the max, let's say 65450)
+
+July 8, 2007
+* [ANTONIN] fixed the size of the memory allocation in cio.c (confusion between bits and bytes)
+
+June 21, 2007
+* [FOD] Output image color space set when decoding a JP2 file in jp2.c
++ [GB] Previous, home, and next frame buttons for exploring MJ2 files in OPJViewer
+
+June 18, 2007
+* [GB] Reload image doesn't crash in OPJViewer; more settings saved to registry
+ 
+June 16, 2007
++ [GB] Possibility to disable parsing in OPJViewer; also, saves common settings to the registry
+
+June 15, 2007
+* [FOD] Fixed the generation of index files 
+
+
+----------------------
+MAY 4, 2007
+VERSION 1.2.0 RELEASED
+----------------------
+
+May 4, 2007
+* [FOD] Bugs corrected in decoding of command line (getopt.c), in the handling of 16 bit files (t1.c and tcd.c) and the calculation of elapsed time for multiple tiles parts (tcd.c and tdc.h).
+
+June 2, 2007
++ [GB] OPJViewer opens now BMP, PNG, GIF, PNM, TIFF (with wxWidgets internals); added an encoder settings tab, for future integration with "save file as..." in JPEG 2000 format
+
+May 31, 2007
+* [FOD] Fixed the handling of 16bit TIFF files for cinema compression. Modified "convert.c"
+* [FOD] Fixed the parameters used for cinema compression (9-7 transform used instead of 5-3). Modified "image_to_j2k.c"
+
+May 24, 2007
+* [FOD] Bug fixed by Sylvain Munaut. Change in the reading of the POC marker. Since COD/COC can be anywhere in the header, the decoder cannot always know while decoding the POC marker 
+		the value of numlayers and numresolution.
+
+May 23, 2007
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This makes the t1 data arrays dynamic, which greatly reduces cache thrashing. Also, some minor cleanup to prevent unnecessary casts"
+
+May 22, 2007
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "Some formatting cleanups, 
+		so that the long function definitions and calls fit on screen. Use of prefix increment which is theoretically faster, in practice any sane compiler can optimize a postfix 
+		increment but its best not to count on such things. Consolidation of some redundant calculations in the inner loops, which becomes very useful in the future autovectorize patch."
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This changes the flag code in t1 to use a flag_t type, which can then be changed to reduce RAM usage. It is now typedef to a short."
+! [FOD] Patch suggested by Callum Lerwick <seg@haxxed.com>: "This patch makes the t1 LUTs static. I actually intend this as a prelude to possibly eliminating some or all of the LUTs entirely."
+
+May 11, 2007
+- [FOD]	JP3D library Binaries removed from SVN.
+! [FOD] MJ2 codec updated from LibOpenJPEG version 0.97 to LibOpenJPEG version 1. Hence, the MJ2 codec will now take advantage of all the improvements and optimizations done on the LibOpenJPEG library.
+! [FOD] Possibility to choose to apply MCT (multiple component transform) enabled, and new decoding_limit: DECODE_ALL_BUT_PACKETS (openjpeg.h)
+
+April 26, 2007
++ [gdcm] Add basic steps on how to use CMake for building examples (README.cmake)
+
+April 25, 2007
++ [FOD] Modification of the openjpeg.h file to avoid and ABI break with v1.1, removed the dangerous #IFDEF JPWL and added tcp_mct in cparameters.
+
+April 23, 2007
++ [GB] Enable/disable image decoding in OPJViewer
+
+April 12,2007
+* [Parvatha] Fixed Error in tiftoimage(). Modification in convert.c.
+
+April 10,2007
++ [Parvatha] Accepting "j2c"  as format for Encoding and Decoding. Modification in image_to_j2k.c.
+* [Parvatha] Modified imagetotif() to read images with signed data. Modification in convert.c.
+
+April 5, 2007
+! [FOD] fix.h optimized. Thanks a lot to Dzonatas <dzonatas at dzonux.net> !
+! [FOD] dwt.c optimized. Thanks a lot to Dzonatas <dzonatas at dzonux.net> !
+! [FOD] t1.c optimized. Thanks a lot to Callum Lerwick <seg at haxxed.com>  !
+
+April 4,2007
++ [Parvatha] Digital cinema compliance for 4K chosen by "-cinema4K" option. Modification in image_to_j2k.c.
++ [Parvatha] Bit rate limitation for each color component. Modification in image_to_j2k.c, t2.c.
+* [Parvatha] Modified and tested Progression order change "-POC" option. Modification in image_to_j2k.c, j2k.c, pi.c.
++ [Parvatha] Function j2k_check_poc_val() to check for possible loss of packets in case of wrong POC declaration. Modification in j2k.c.
++ [Parvatha] Structure T2_MODE. This tells if the t2_encode_packets() is called during Threshold calculation or in Final pass. Modification in j2k.h, tcd.c
+
+March 30, 2007
+* [GB] OPJViewer should now work under Linux, at least with not big j2k files. Tested under Suse 10.1 64 bit.
+
+March 29, 2007
+* [Parvatha] Enable accepting file names with `-´ symbol .Modification getopt.c
+* [Parvatha] Rsiz profile name generation to be STD_RSIZ for profiles which are not DCI compliant.Modification in image_to_j2k.c
+! [Parvatha] renamed convert_progression_order to j2k_convert_progression_order. Modification j2k.c
+* [Parvatha] Calculation of number of tile part in each tile in j2k_calculate_tp. Modification j2k.c
+! [Parvatha] j2k_setup_encoder to set bit rate limitation for digital cinema compliance with quality option. Modification in j2k.c
+* [Parvatha] Equation to check multiple tile precincts. Modification pi.c
+! [Parvatha] array size generation of pi->include in pi_initialise_encode().Modification in pi.c
+* [Parvatha] modification in pi_create_encode for tile part generation.Modification in pi.c
++ [Parvatha] In tcd_rateallocate a variable stable_threshold which holds the valid threshold value. 
+			 This is used to avoid error in case of a wrong threshold value in the last iteration. Modification in tcd.c.
+
+March 28, 2007
+* [FOD] Fixed an historical bug in t1.c that leaded to the inclusion of useless 0xFF in the codestream. Thanks to Sylvain, Pascal and Parvatha !
+
+March 27, 2007
++ [GB] Improved parsing in OPJViewer, as well some minor aesthetic modifications; support for image rendering with bit depths lower than 8 bits; 
+		can display an arbitrary frame of an MJ2 file (only in B/W, though); can reload a file; better resizing capabilities
+* [GB] Following to Hervé's suggestions, all the exit() calls, added by JPWL strict checking in t2.c and j2k.c, 
+		have been substituted with (object free'ing + opj_evt_message(EVT_ERROR) + return)
++ [GB] Added linking to TIFF library in the JPWL VC6 workspaces
+
+March 23, 2007
+* [antonin] Fixed Makefile.osx and changed Readme.osx accordingly
+
+March 21, 2007
+* [Parvatha] Fixed j2k_prog_order_list[]. Modifications in j2k.c.
+* [Parvatha] Fixed t1_decode_cblks. Modifications in t1.c.
+
+March 20, 2007
++ [Parvatha] Added feature for generation of tile parts. Modifications in image_to_j2k.c, openjpeg.c, j2k.c, pi.c
++ [Parvatha] Added function j2k_write_tlm(),to generate TLM marker for a Digital cinema compliant codestream. Modifications in j2k.c.
+
+March 14, 2007
+* [FOD] Fixed linux makefile, with help from David Fries and Guido
+
+March 7, 2007
++ [Parvatha] Added option for Digital cinema profile compliant codestream. This can be chosen by "-cinema2K" or "-cinema4K" for a 2K and 4K compliance respectively. The feature for tileparts has not been implemented in this version. Modification in image_to_j2k.c
++ [Parvatha] Added the Digital Cinema profiles (CINEMA2K and CINEMA4K) to the list of profiles recognized in the codestream SIZ marker segment. Modification in openjpeg.h,j2k.c
++ [Parvatha] Added feature for constant quality within bitrate defined in Digital cinema standards. Modification in tcd.c
+! [Parvatha] Modified the method of generation of buffer length. Modification in cio.c
+ 
+
+March 1, 2007
+* [FOD] Modified codec projects (*.dsp) and makefile to include the tiff library (modified codec/image_to_j2k.dsp codec/j2k_to_image.dsp and codec/makefile)
++ [GB] Zoom capability and decoder settings dialog in OPJViewer; modified JPWL library .dsp project in order to create a library with embedded JPWL functions
+
+February 28, 2007
++ [Parvatha] Enabled compression of TIF image format to j2k by tifftoimage() and decompression of codestream to TIF image format using imagetotif(). Modifications in image_to_j2k.c, j2k_to_image.c, convert.c, convert.h
+* [antonin] fixed a bug in context numerotation that prevented the RESET switch to work correctly : mqc_reset_enc in mqc.c
+* [Fod] Corrected codec Makefile by adding the compilation of "compat/getopt.c" 
+
+February 27, 2007
+* [Parvatha] Made get_file_format function more robust. Modifications in image_to_j2k.c, j2k_to_image.c, getopt.c, getopt.h
+
+February 26, 2007
++ [Parvatha] Option to read images from a Folder whose path is specified in the Input parameters by "-ImgDir" along with output decod format specified by "-OutFor" . Modifications in image_to_j2k.c, j2k_to_image.c, getopt.c, getopt.h
++ [Parvatha] Enabling use of multi character input parameters in the codec. Modifications in image_to_j2k.c, j2k_to_image.c, getopt.c, getopt.h
+
+----------------------
+February 23, 2007
+VERSION 1.1.1 RELEASED
+----------------------
+
+February 23, 2007
+* [GB] Fixed a copy-and-paste type assignment error (bool instead of int) in the JPWL section of decoder parameters structure in openjpeg.h; minor type-casting in jpwl_lib.c. 
+		As a result, now OPJViewer should run correctly when built against the most current SVN trunk of LibOpenJPEG.lib
++ [GB] Linux makefile for the JPWL module; newlines at end of JPWL files
+
+February 22, 2007
++ [FOD] Added the OPJViewer Module (/OPJViewer), developed by Giuseppe Baruffa of the university of Perugia
+
+February 21, 2007
++ [FOD] Algorithmic optimizations in t1.c, thanks to Guido J. !
+
+February 19, 2007
++ [FOD] Added OPJ_LIMIT_DECODING enabling us to limit the decoding to main header (modified openjpeg.c, openjpeg.h, j2k.c and j2k.h)
+
+February 13, 2007
+! [FOD] David Fries suggestions. In image_to_j2k and j2k_to_image, strncpy() functions: instead of specifying the path size macro, let the compiler read the length out of the array entry.
+! [FOD] David Fries suggestions. Makefile modified. -fPIC flag used for 64-bit compilation. Move operation (rather than copy) for the dist library creation, and -p flag added.
+
+January 31, 2007
+! [FOD] Extra tokens at the end of #endif directive corrected in openjpeg.c, j2k.c and image_to_j2k.c -> no more warnings in linux compilation
+! [FOD] Linux Makefile added for the codec
+
+January 30, 2007
+! [FOD] Use of OPJ_PATH_LEN (defined as 4096) to be the maximum allowed size for filenames instead of MAX_PATH which is not always defined. This caused some programs using OpenJPEG to crash. Modifications in openjpeg.h j2k_to_image.c and image_to_j2k.c
+! [FOD] Correction of the syntax usage in MJ2_codec/mj2_to_frames.c
+
+January 23, 2007
+! [FOD] Modification in the context numbers, to reflect what has been specified in standard, in libopenjpeg/t1.h
+
+December 07, 2006
++ [Giuseppe Baruffa] Antonin verified that the MacOS build suffered from a missing definition of the "min" macro; I've added this definition (properly #ifndef'ed) into both jpwl.h and rs.h
+
+December 05, 2006
+* [Giuseppe Baruffa] Better fix of the TPH EPBs bug in JPWL module
+* [GB] Fixed the UEP bug in JPWL module; now, during a UEP specification, RS protection or CRC check can be switched off for selected range of packets, and consequently reswitched on without confusing the decoder
++ [GB] Added some lines in the help of JPWL_image_to_j2k, specifying that when using error protection on data packets, this must be paired with header protection, i.e. there cannot be packet protection without header protection
+
+December 04, 2006
+
++ [Francois-Olivier Devaux] New tag: version1.0 (includes codec and libopenjpeg directories)
+Total update of JPWL module
+    - [FOD] removed directories jpwl/decoder, jpwl/encoder, jpwl/decoder_02, jpwl/encoder_02
+    + [FOD] added in JPWL directory crc.h, jpwl.h, rs.h, crc.c, jpwl.c, jpwl_lib.c, rs.c, JPWL_image_to_j2k.dsp, JPWL_j2k_to_image.dsp, LibOpenJPEG_JPWL.dsp, JPWL_image_to_j2k.dsw, JPWL_j2k_to_image.dsw
+    ! [FOD] Modifications of libopenjpeg to integrate JPWL module (in libopenjpeg directory): j2k.c, j2k.h, openjpeg.c, openjpeg.h, opj_includes.g, t2.c
+    ! [FOD] Modification of codec to integrate JPWL module (in codec directory): image_to_j2k.c, j2k_to_image.c
+* [FOD] Corrected incorrect fprintf() formatting in codec/convert.c
+* [FOD] Code optimization usinq vsprintf() command in libopenjpeg/event.c
+* [Giuseppe Baruffa] Fixed a bug in TPH EPBs parameters: now, "last in current header" information is correctly signaled
+
+October 31, 2006
+* [Antonin] fixed a bug in the computation of the mantissa (mu)
++ [Antonin] added the ability to specify the rate as "float" (before : integer)
+
+August 18, 2006
+* [Antonin] fixed a bug in j2k_to_image.c, that prevented the -l option to work correctly.
+
+August 4, 2006
+* [Antonin] fixed a bug in pi.c, line 473, that appeared when more than 100 precincts were generated in a resolution level.
+
+July 28, 2006
++ [Antonin Descampe] added a readme in /mj2 to warn people that it only works with opj0.97
+
+July 21, 2006
+* [Mathieu Malaterre] Install exe and lib and include correctly
+* [Mathieu Malaterre] Fixed mem leaks and greyscale bmp
+* [Mathieu Malaterre] Fix pgx name length + random memory access
+! [Mathieu Malaterre] API is now const
+
+March 19, 2006
+* [Antonin] fixed a bug in t1.c that prevented in some cases a true lossless compression (thanks to Don Mimlitch for reporting this bug)
+
+February 12, 2006
+- [Herve Drolon] removed unneeded working variables in opj_tcd_t
+
+February 04, 2006
+* [galt] fixed a bug in codec/convert.c::imagetobmp
+
+February 01, 2006
+! [Herve Drolon] changed function definitions of INT and FIX modules to 'inline'
++ [Herve Drolon] added a VERSION resource to the DLL version of OpenJPEG
+
+January 31, 2006
+* [Mathieu Malaterre] Fix compilation using default openjpeg.dsw
+* [Herve Drolon] fixed various minor warnings occuring under icc9 and bcc32
+- [Mathieu Malaterre] Remove all references to OPJ_EXPORT, no declspec in header file anymore
++ [Mathieu Malaterre] Add a def.in file which is a template for Module Definition
++ [Herve Drolon] added MSVC project and compiler directives to build a 'standard' WIN32 DLL
+! [Mathieu Malaterre] Update CMake to match the new shared lib system (no more def file)
+
+January 27, 2006
+* [Antonin Descampe] fixed a two initialization problems in t1.c and tcd.c
+
+January 26, 2006
+* [Herve Drolon] fixed various minor warnings occuring under gcc
+* [__david__] fixed a segfault in codec/image_to_j2k.c & codec/j2k_to_image.c
+* [__david__] fixed help option in codec/j2k_to_image & codec/image_to_j2k
+
+January 25, 2006
+! [Mathieu Malaterre] Sync with ITK repository, also add ref to doxygen
+! [Mathieu Malaterre] Add a lot of comments on the CMake build system
+! [Mathieu Malaterre] Fix MINGW32 and BORLAND compilation problems.
+
+January 25, 2006
+* [Antonin Descampe] fixed a problem in convert.c when multiple comments
++ [Antonin Descampe] added cmake files to the project
+! [Antonin Descampe] fix.c : replaced "WIN32" by "_MSC_VER" for int64
++ [Antonin Descampe] added "OPJ_EXPORT" in openjpeg.h to generate shared lib with win32
+! [Antonin Descampe] removed all CtrlM from files
+
+January 24, 2006
+! [Antonin Descampe] event.c : replaced "WIN32" by "_MSC_VER" for i2a
+
+January 20, 2006
+* [Antonin Descampe] fixed various minor warnings with gdcm patches
+
+January 19, 2006
+* [Herve Drolon] fixed a bug in jp2_read_ihdr (need to allocate jp2->comps)
+
+January 18, 2006
+* [Herve Drolon] changed the name of j2k_realloc to opj_realloc
+* [Herve Drolon] fixed a bug in opj_cio_open when saving 48-bit images (wrong buffer size calculation)
+
+December 8, 2005
+* [Antonin Descampe] fixed a bug when specifying a rate '-r' => no distortion info was available in the index
+* [Antonin Descampe] fixed a bug in t1_getwmsedec (stepsize was divided by 8192)
+
+December 5, 2005 - 1.1.0
diff -urN /home/robin/sldeb/trunk/.svn/text-base/clean.bat.svn-base ./.svn/text-base/clean.bat.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/clean.bat.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/clean.bat.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,25 @@
+rd Release /s /q
+rd Debug /s /q
+rd codec\Debug /s /q
+rd codec\Release /s /q
+rd dist /s /q
+del *.pch /s /q
+del *.ncb /s /q
+del *.opt /s /q
+del *.plg /s /q
+del *.obj /s /q
+del *.dll /s /q
+del *.exe /s /q
+del *.bsc /s /q
+del *.bak /s /q
+del *.pdb /s /q
+del *.sql /s /q
+del *.mdb /s /q
+del *.lib /s /q
+del *.exp /s /q
+del *.ilk /s /q
+del *.idb /s /q
+del *.aps /s /q
+del *.suo /s /q /a:h
+del *.o /s /q
+
diff -urN /home/robin/sldeb/trunk/.svn/text-base/CMakeLists.txt.svn-base ./.svn/text-base/CMakeLists.txt.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/CMakeLists.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/CMakeLists.txt.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,126 @@
+# Main CMakeLists.txt to build the OpenJPEG project using CMake (www.cmake.org)
+# Written by Mathieu Malaterre
+
+# This CMake project will by default create a library called openjpeg
+# But if you want to use this project within your own (CMake) project
+# you will eventually like to prefix the library to avoid linking confusion
+# For this purpose you can define a CMake var: OPENJPEG_NAMESPACE to whatever you like
+# e.g.:
+# SET(OPENJPEG_NAMESPACE "GDCMOPENJPEG")
+CMAKE_MINIMUM_REQUIRED(VERSION 2.4)
+
+IF(NOT OPENJPEG_NAMESPACE)
+  SET(OPENJPEG_NAMESPACE "OPENJPEG")
+  SET(OPENJPEG_STANDALONE 1)
+ENDIF(NOT OPENJPEG_NAMESPACE)
+# In all cases:
+STRING(TOLOWER ${OPENJPEG_NAMESPACE} OPENJPEG_LIBRARY_NAME)
+
+PROJECT(${OPENJPEG_NAMESPACE} C)
+
+# Do full dependency headers.
+INCLUDE_REGULAR_EXPRESSION("^.*$")
+
+#-----------------------------------------------------------------------------
+# OPENJPEG version number, useful for packaging and doxygen doc:
+SET(OPENJPEG_VERSION_MAJOR 1)
+SET(OPENJPEG_VERSION_MINOR 2)
+SET(OPENJPEG_VERSION_BUILD 0)
+SET(OPENJPEG_VERSION
+  "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}")
+
+# This setting of SOVERSION assumes that any API change
+# will increment either the minor or major version number of openjpeg
+SET(OPENJPEG_LIBRARY_PROPERTIES
+  VERSION   "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}.${OPENJPEG_VERSION_BUILD}"
+  SOVERSION "${OPENJPEG_VERSION_MAJOR}.${OPENJPEG_VERSION_MINOR}"
+)
+
+
+#-----------------------------------------------------------------------------
+# OpenJPEG build configuration options.
+OPTION(BUILD_SHARED_LIBS "Build OpenJPEG with shared libraries." OFF)
+
+#-----------------------------------------------------------------------------
+SET (EXECUTABLE_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all executables.")
+SET (LIBRARY_OUTPUT_PATH ${OPENJPEG_BINARY_DIR}/bin CACHE PATH "Single output directory for building all libraries.")
+MARK_AS_ADVANCED(LIBRARY_OUTPUT_PATH EXECUTABLE_OUTPUT_PATH)
+
+
+#-----------------------------------------------------------------------------
+# For the codec...
+OPTION(BUILD_EXAMPLES "Build the Examples (codec...)." OFF)
+
+
+# configure name mangling to allow multiple libraries to coexist
+# peacefully
+IF(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/openjpeg_mangle.h.in)
+SET(MANGLE_PREFIX ${OPENJPEG_LIBRARY_NAME})
+CONFIGURE_FILE(${CMAKE_CURRENT_SOURCE_DIR}/openjpeg_mangle.h.in
+               ${CMAKE_CURRENT_BINARY_DIR}/openjpeg_mangle.h
+               @ONLY IMMEDIATE)
+ENDIF(EXISTS ${CMAKE_CURRENT_SOURCE_DIR}/openjpeg_mangle.h.in)
+
+#-----------------------------------------------------------------------------
+# Always build the library
+INCLUDE_DIRECTORIES(BEFORE ${CMAKE_CURRENT_BINARY_DIR})
+SUBDIRS(
+  libopenjpeg
+  mj2
+  # cmake 2.4.5 has poor java support
+  #j2kviewer/src
+  )
+
+IF(NOT UNIX)
+SUBDIRS(
+  jpwl
+  jp3d
+  indexer_JPIP
+  )
+ENDIF(NOT UNIX)
+
+#-----------------------------------------------------------------------------
+# Build example only if requested
+IF(BUILD_EXAMPLES)
+  SUBDIRS(codec)
+ENDIF(BUILD_EXAMPLES)
+
+#-----------------------------------------------------------------------------
+# For the documentation
+OPTION(BUILD_DOCUMENTATION "Build the doxygen documentation" OFF)
+IF(BUILD_DOCUMENTATION)
+  SUBDIRS(doc)
+ENDIF(BUILD_DOCUMENTATION)
+
+#-----------------------------------------------------------------------------
+# For openjpeg team if they ever want Dart+CMake
+IF(OPENJPEG_STANDALONE)
+  INCLUDE(Dart)
+  MARK_AS_ADVANCED(BUILD_TESTING DART_ROOT TCL_TCLSH)
+  IF(BUILD_TESTING)
+    ENABLE_TESTING()
+    SET(BUILDNAME "OpenJPEG-${CMAKE_SYSTEM}-${CMAKE_C_COMPILER}" CACHE STRING "Name of build on the dashboard")
+    MARK_AS_ADVANCED(BUILDNAME)
+  ENDIF(BUILD_TESTING)
+ENDIF(OPENJPEG_STANDALONE)
+
+# Adding test with dataset from:
+# http://www.crc.ricoh.com/~gormish/jpeg2000conformance/
+# http://www.jpeg.org/jpeg2000guide/testimages/testimages.html
+
+#-----------------------------------------------------------------------------
+# Adding JPEG2000_CONFORMANCE_DATA_ROOT
+FIND_PATH(JPEG2000_CONFORMANCE_DATA_ROOT testimages.html
+  ${OPENJPEG_SOURCE_DIR}/../jpeg2000testimages
+  $ENV{JPEG2000_CONFORMANCE_DATA_ROOT}
+)
+
+#-----------------------------------------------------------------------------
+# Compiler specific flags:
+IF(CMAKE_COMPILER_IS_GNUCC)
+  # For all builds, make sure openjpeg is std99 compliant:
+  SET(CMAKE_C_FLAGS "-Wall -std=c99 ${CMAKE_C_FLAGS}")
+  # Do not use ffast-math for all build, it would produce incorrect results, only set for release:
+  SET(CMAKE_C_FLAGS_RELEASE "-ffast-math ${CMAKE_C_FLAGS_RELEASE}")
+ENDIF(CMAKE_COMPILER_IS_GNUCC)
+
diff -urN /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.dsp.svn-base ./.svn/text-base/DllOpenJPEG.dsp.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/DllOpenJPEG.dsp.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,273 @@
+# Microsoft Developer Studio Project File - Name="DllOpenJPEG" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Dynamic-Link Library" 0x0102
+
+CFG=DllOpenJPEG - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "DllOpenJPEG.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "DllOpenJPEG.mak" CFG="DllOpenJPEG - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "DllOpenJPEG - Win32 Release" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE "DllOpenJPEG - Win32 Debug" (based on "Win32 (x86) Dynamic-Link Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+MTL=midl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "DllOpenJPEG - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "DLLOPENJPEG_EXPORTS" /Yu"stdafx.h" /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "OPJ_EXPORTS" /FD /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "NDEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /machine:I386 /out:"Release/OpenJPEG.dll"
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy libopenjpeg\openjpeg.h dist	copy Release\OpenJPEG.dll dist	copy Release\OpenJPEG.lib dist
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "DllOpenJPEG - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Ignore_Export_Lib 0
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "DLLOPENJPEG_EXPORTS" /Yu"stdafx.h" /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_WINDOWS" /D "_MBCS" /D "_USRDLL" /D "OPJ_EXPORTS" /FD /GZ /c
+# SUBTRACT CPP /YX /Yc /Yu
+# ADD BASE MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD MTL /nologo /D "_DEBUG" /mktyplib203 /win32
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LINK32=link.exe
+# ADD BASE LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /pdbtype:sept
+# ADD LINK32 kernel32.lib user32.lib gdi32.lib winspool.lib comdlg32.lib advapi32.lib shell32.lib ole32.lib oleaut32.lib uuid.lib odbc32.lib odbccp32.lib /nologo /dll /debug /machine:I386 /out:"Debug/OpenJPEGd.dll" /pdbtype:sept
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy libopenjpeg\openjpeg.h dist	copy Debug\OpenJPEGd.dll dist	copy Debug\OpenJPEGd.lib dist
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "DllOpenJPEG - Win32 Release"
+# Name "DllOpenJPEG - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=.\libopenjpeg\bio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\cio.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\dwt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\event.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\image.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k_lib.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jp2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jpt.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mct.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mqc.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\openjpeg.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\pi.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\raw.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t1.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t2.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tcd.c
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tgt.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=.\libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\tgt.h
+# End Source File
+# End Group
+# Begin Group "Resource Files"
+
+# PROP Default_Filter "ico;cur;bmp;dlg;rc2;rct;bin;rgs;gif;jpg;jpeg;jpe"
+# Begin Source File
+
+SOURCE=.\OpenJPEG.rc
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.sln.svn-base ./.svn/text-base/DllOpenJPEG.sln.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/DllOpenJPEG.sln.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "DllOpenJPEG", "DllOpenJPEG.vcproj", "{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.ActiveCfg = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Debug|Win32.Build.0 = Debug|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.ActiveCfg = Release|Win32
+		{89AC992C-5E2C-4E6B-A453-61C1DF446216}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.vcproj.svn-base ./.svn/text-base/DllOpenJPEG.vcproj.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/DllOpenJPEG.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/DllOpenJPEG.vcproj.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,670 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="DllOpenJPEG"
+	ProjectGUID="{89AC992C-5E2C-4E6B-A453-61C1DF446216}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			WholeProgramOptimization="1"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="NDEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Release/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="1"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Release/OpenJPEG.dll"
+				LinkIncremental="1"
+				SuppressStartupBanner="true"
+				ProgramDatabaseFile=".\Release/OpenJPEG.pdb"
+				LinkTimeCodeGeneration="0"
+				ImportLibrary=".\Release/OpenJPEG.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Release\OpenJPEG.dll dist&#x0D;&#x0A;copy Release\OpenJPEG.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="2"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+				PreprocessorDefinitions="_DEBUG"
+				MkTypLibCompatible="true"
+				SuppressStartupBanner="true"
+				TargetEnvironment="1"
+				TypeLibraryName=".\Debug/DllOpenJPEG.tlb"
+				HeaderFileName=""
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				PreprocessorDefinitions="WIN32;_DEBUG;_WINDOWS;_USRDLL;OPJ_EXPORTS"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/DllOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLinkerTool"
+				OutputFile="Debug/OpenJPEGd.dll"
+				LinkIncremental="2"
+				SuppressStartupBanner="true"
+				GenerateDebugInformation="true"
+				ProgramDatabaseFile=".\Debug/OpenJPEGd.pdb"
+				ImportLibrary=".\Debug/OpenJPEGd.lib"
+				TargetMachine="1"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCManifestTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/DllOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCAppVerifierTool"
+			/>
+			<Tool
+				Name="VCWebDeploymentTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;copy Debug\OpenJPEGd.dll dist&#x0D;&#x0A;copy Debug\OpenJPEGd.lib dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.dsp.svn-base ./.svn/text-base/LibOpenJPEG.dsp.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.dsp.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/LibOpenJPEG.dsp.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,262 @@
+# Microsoft Developer Studio Project File - Name="LibOpenJPEG" - Package Owner=<4>
+# Microsoft Developer Studio Generated Build File, Format Version 6.00
+# ** DO NOT EDIT **
+
+# TARGTYPE "Win32 (x86) Static Library" 0x0104
+
+CFG=LibOpenJPEG - Win32 Debug
+!MESSAGE This is not a valid makefile. To build this project using NMAKE,
+!MESSAGE use the Export Makefile command and run
+!MESSAGE 
+!MESSAGE NMAKE /f "LibOpenJPEG.mak".
+!MESSAGE 
+!MESSAGE You can specify a configuration when running NMAKE
+!MESSAGE by defining the macro CFG on the command line. For example:
+!MESSAGE 
+!MESSAGE NMAKE /f "LibOpenJPEG.mak" CFG="LibOpenJPEG - Win32 Debug"
+!MESSAGE 
+!MESSAGE Possible choices for configuration are:
+!MESSAGE 
+!MESSAGE "LibOpenJPEG - Win32 Release" (based on "Win32 (x86) Static Library")
+!MESSAGE "LibOpenJPEG - Win32 Debug" (based on "Win32 (x86) Static Library")
+!MESSAGE 
+
+# Begin Project
+# PROP AllowPerConfigDependencies 0
+# PROP Scc_ProjName ""
+# PROP Scc_LocalPath ""
+CPP=cl.exe
+RSC=rc.exe
+
+!IF  "$(CFG)" == "LibOpenJPEG - Win32 Release"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 0
+# PROP BASE Output_Dir "Release"
+# PROP BASE Intermediate_Dir "Release"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 0
+# PROP Output_Dir "Release"
+# PROP Intermediate_Dir "Release"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /YX /FD /c
+# ADD CPP /nologo /MT /W3 /GX /O2 /D "WIN32" /D "NDEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /FD /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x40c /d "NDEBUG"
+# ADD RSC /l 0x40c /d "NDEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy Release\LibOpenJPEG.lib dist	copy libopenjpeg\openjpeg.h dist
+# End Special Build Tool
+
+!ELSEIF  "$(CFG)" == "LibOpenJPEG - Win32 Debug"
+
+# PROP BASE Use_MFC 0
+# PROP BASE Use_Debug_Libraries 1
+# PROP BASE Output_Dir "Debug"
+# PROP BASE Intermediate_Dir "Debug"
+# PROP BASE Target_Dir ""
+# PROP Use_MFC 0
+# PROP Use_Debug_Libraries 1
+# PROP Output_Dir "Debug"
+# PROP Intermediate_Dir "Debug"
+# PROP Target_Dir ""
+# ADD BASE CPP /nologo /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /YX /FD /GZ /c
+# ADD CPP /nologo /MTd /W3 /Gm /GX /ZI /Od /D "WIN32" /D "_DEBUG" /D "_MBCS" /D "_LIB" /D "OPJ_STATIC" /FD /GZ /c
+# SUBTRACT CPP /YX
+# ADD BASE RSC /l 0x40c /d "_DEBUG"
+# ADD RSC /l 0x40c /d "_DEBUG"
+BSC32=bscmake.exe
+# ADD BASE BSC32 /nologo
+# ADD BSC32 /nologo
+LIB32=link.exe -lib
+# ADD BASE LIB32 /nologo
+# ADD LIB32 /nologo /out:"Debug\LibOpenJPEGd.lib"
+# Begin Special Build Tool
+SOURCE="$(InputPath)"
+PostBuild_Cmds=if not exist dist mkdir dist	copy Debug\LibOpenJPEGd.lib dist	copy libopenjpeg\openjpeg.h dist
+# End Special Build Tool
+
+!ENDIF 
+
+# Begin Target
+
+# Name "LibOpenJPEG - Win32 Release"
+# Name "LibOpenJPEG - Win32 Debug"
+# Begin Group "Source Files"
+
+# PROP Default_Filter "cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+# Begin Source File
+
+SOURCE=libopenjpeg\bio.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\cio.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\dwt.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\event.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\image.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\j2k.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\j2k_lib.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\jp2.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\jpt.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\mct.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\mqc.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\openjpeg.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\pi.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\raw.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\t1.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\t2.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\tcd.c
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\tgt.c
+# End Source File
+# End Group
+# Begin Group "Header Files"
+
+# PROP Default_Filter "h;hpp;hxx;hm;inl"
+# Begin Source File
+
+SOURCE=libopenjpeg\bio.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\cio.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\dwt.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\event.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\fix.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\image.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\int.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\j2k.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\j2k_lib.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\jp2.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\jpt.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\mct.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\mqc.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\openjpeg.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\opj_includes.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\pi.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\raw.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\t1.h
+# End Source File
+# Begin Source File
+
+SOURCE=.\libopenjpeg\t1_luts.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\t2.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\tcd.h
+# End Source File
+# Begin Source File
+
+SOURCE=libopenjpeg\tgt.h
+# End Source File
+# End Group
+# End Target
+# End Project
diff -urN /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.dsw.svn-base ./.svn/text-base/LibOpenJPEG.dsw.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.dsw.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/LibOpenJPEG.dsw.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,41 @@
+Microsoft Developer Studio Workspace File, Format Version 6.00
+# WARNING: DO NOT EDIT OR DELETE THIS WORKSPACE FILE!
+
+###############################################################################
+
+Project: "DllOpenJPEG"=.\DllOpenJPEG.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Project: "LibOpenJPEG"=.\LibOpenJPEG.dsp - Package Owner=<4>
+
+Package=<5>
+{{{
+}}}
+
+Package=<4>
+{{{
+}}}
+
+###############################################################################
+
+Global:
+
+Package=<5>
+{{{
+}}}
+
+Package=<3>
+{{{
+}}}
+
+###############################################################################
+
diff -urN /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.sln.svn-base ./.svn/text-base/LibOpenJPEG.sln.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.sln.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/LibOpenJPEG.sln.svn-base	2007-09-28 11:33:42.000000000 +0100
@@ -0,0 +1,20 @@
+ï»¿
+Microsoft Visual Studio Solution File, Format Version 9.00
+# Visual Studio 2005
+Project("{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}") = "LibOpenJPEG", "LibOpenJPEG.vcproj", "{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}"
+EndProject
+Global
+	GlobalSection(SolutionConfigurationPlatforms) = preSolution
+		Debug|Win32 = Debug|Win32
+		Release|Win32 = Release|Win32
+	EndGlobalSection
+	GlobalSection(ProjectConfigurationPlatforms) = postSolution
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.ActiveCfg = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Debug|Win32.Build.0 = Debug|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.ActiveCfg = Release|Win32
+		{6A47DBE3-8F80-4ABE-8688-5F8DC620977C}.Release|Win32.Build.0 = Release|Win32
+	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
+EndGlobal
diff -urN /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.vcproj.svn-base ./.svn/text-base/LibOpenJPEG.vcproj.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/LibOpenJPEG.vcproj.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/LibOpenJPEG.vcproj.svn-base	2007-11-27 22:39:50.000000000 +0000
@@ -0,0 +1,642 @@
+<?xml version="1.0" encoding="Windows-1252"?>
+<VisualStudioProject
+	ProjectType="Visual C++"
+	Version="8,00"
+	Name="LibOpenJPEG"
+	ProjectGUID="{4F27AA53-4181-4A1A-8238-3931B0A41048}"
+	>
+	<Platforms>
+		<Platform
+			Name="Win32"
+		/>
+	</Platforms>
+	<ToolFiles>
+	</ToolFiles>
+	<Configurations>
+		<Configuration
+			Name="Release|Win32"
+			OutputDirectory=".\Release"
+			IntermediateDirectory=".\Release"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="2"
+				InlineFunctionExpansion="2"
+				EnableIntrinsicFunctions="true"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;NDEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				StringPooling="true"
+				RuntimeLibrary="0"
+				EnableFunctionLevelLinking="true"
+				PrecompiledHeaderFile=".\Release/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Release/"
+				ObjectFile=".\Release/"
+				ProgramDataBaseFileName=".\Release/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="NDEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile=".\Release\LibOpenJPEG.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Release/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Release\LibOpenJPEG.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+		<Configuration
+			Name="Debug|Win32"
+			OutputDirectory=".\Debug"
+			IntermediateDirectory=".\Debug"
+			ConfigurationType="4"
+			InheritedPropertySheets="$(VCInstallDir)VCProjectDefaults\UpgradeFromVC60.vsprops"
+			UseOfMFC="0"
+			ATLMinimizesCRunTimeLibraryUsage="false"
+			CharacterSet="2"
+			>
+			<Tool
+				Name="VCPreBuildEventTool"
+			/>
+			<Tool
+				Name="VCCustomBuildTool"
+			/>
+			<Tool
+				Name="VCXMLDataGeneratorTool"
+			/>
+			<Tool
+				Name="VCWebServiceProxyGeneratorTool"
+			/>
+			<Tool
+				Name="VCMIDLTool"
+			/>
+			<Tool
+				Name="VCCLCompilerTool"
+				Optimization="0"
+				InlineFunctionExpansion="0"
+				EnableIntrinsicFunctions="false"
+				FavorSizeOrSpeed="1"
+				WholeProgramOptimization="false"
+				PreprocessorDefinitions="WIN32;_DEBUG;_LIB;OPJ_STATIC;_CRT_SECURE_NO_DEPRECATE"
+				MinimalRebuild="true"
+				BasicRuntimeChecks="3"
+				RuntimeLibrary="1"
+				PrecompiledHeaderFile=".\Debug/LibOpenJPEG.pch"
+				AssemblerListingLocation=".\Debug/"
+				ObjectFile=".\Debug/"
+				ProgramDataBaseFileName=".\Debug/"
+				WarningLevel="3"
+				SuppressStartupBanner="true"
+				DebugInformationFormat="4"
+			/>
+			<Tool
+				Name="VCManagedResourceCompilerTool"
+			/>
+			<Tool
+				Name="VCResourceCompilerTool"
+				PreprocessorDefinitions="_DEBUG"
+				Culture="1036"
+			/>
+			<Tool
+				Name="VCPreLinkEventTool"
+			/>
+			<Tool
+				Name="VCLibrarianTool"
+				OutputFile="Debug\LibOpenJPEGd.lib"
+				SuppressStartupBanner="true"
+			/>
+			<Tool
+				Name="VCALinkTool"
+			/>
+			<Tool
+				Name="VCXDCMakeTool"
+			/>
+			<Tool
+				Name="VCBscMakeTool"
+				SuppressStartupBanner="true"
+				OutputFile=".\Debug/LibOpenJPEG.bsc"
+			/>
+			<Tool
+				Name="VCFxCopTool"
+			/>
+			<Tool
+				Name="VCPostBuildEventTool"
+				CommandLine="if not exist dist mkdir dist&#x0D;&#x0A;copy Debug\LibOpenJPEGd.lib dist&#x0D;&#x0A;copy libopenjpeg\openjpeg.h dist&#x0D;&#x0A;"
+			/>
+		</Configuration>
+	</Configurations>
+	<References>
+	</References>
+	<Files>
+		<Filter
+			Name="Source Files"
+			Filter="cpp;c;cxx;rc;def;r;odl;idl;hpj;bat"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.c"
+				>
+				<FileConfiguration
+					Name="Release|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+				<FileConfiguration
+					Name="Debug|Win32"
+					>
+					<Tool
+						Name="VCCLCompilerTool"
+						PreprocessorDefinitions=""
+					/>
+				</FileConfiguration>
+			</File>
+		</Filter>
+		<Filter
+			Name="Header Files"
+			Filter="h;hpp;hxx;hm;inl"
+			>
+			<File
+				RelativePath="libopenjpeg\bio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\cio.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\dwt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\event.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\fix.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\image.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\int.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\j2k_lib.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jp2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\jpt.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mct.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\mqc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\openjpeg.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\opj_includes.h"
+				>
+			</File>
+			<File
+				RelativePath=".\libopenjpeg\opj_malloc.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\pi.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\raw.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t1_luts.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\t2.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tcd.h"
+				>
+			</File>
+			<File
+				RelativePath="libopenjpeg\tgt.h"
+				>
+			</File>
+		</Filter>
+	</Files>
+	<Globals>
+	</Globals>
+</VisualStudioProject>
diff -urN /home/robin/sldeb/trunk/.svn/text-base/license.txt.svn-base ./.svn/text-base/license.txt.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/license.txt.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/license.txt.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1 @@
+/* * Copyright (c) 2002-2007, Communications and Remote Sensing Laboratory, Universite catholique de Louvain (UCL), Belgium * Copyright (c) 2002-2007, Professor Benoit Macq * Copyright (c) 2001-2003, David Janssens * Copyright (c) 2002-2003, Yannick Verschueren * Copyright (c) 2003-2007, Francois-Olivier Devaux and Antonin Descampe * Copyright (c) 2005, Herve Drolon, FreeImage Team * All rights reserved. * * Redistribution and use in source and binary forms, with or without * modification, are permitted provided that the following conditions * are met: * 1. Redistributions of source code must retain the above copyright *    notice, this list of conditions and the following disclaimer. * 2. Redistributions in binary form must reproduce the above copyright *    notice, this list of conditions and the following disclaimer in the *    documentation and/or other materials provided with the distribution. * * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS `AS IS' * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE * ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE * POSSIBILITY OF SUCH DAMAGE. */
\ No newline at end of file
diff -urN /home/robin/sldeb/trunk/.svn/text-base/Makefile.osx.svn-base ./.svn/text-base/Makefile.osx.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/Makefile.osx.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/Makefile.osx.svn-base	2007-09-28 11:33:40.000000000 +0100
@@ -0,0 +1,66 @@
+# MacOSX makefile for OpenJPEG
+
+VER_MAJOR = 2
+VER_MINOR = 1.2.0
+
+SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
+INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_includes.h
+INCLUDE = -Ilibopenjpeg
+
+# General configuration variables:
+CC = gcc
+LIBTOOLSTAT = libtool
+LIBTOOLDYN = gcc
+
+PREFIX = /usr
+INSTALL_LIBDIR = $(PREFIX)/lib
+INSTALL_INCLUDE = $(PREFIX)/include
+
+COMPILERFLAGS = -O3 -fPIC
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE)
+
+TARGET  = openjpeg
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).dylib
+LIBNAME = lib$(TARGET).dylib
+
+
+
+default: all
+
+all: OpenJPEG
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+dist: OpenJPEG
+	install -d dist
+	install -m 644 $(STATICLIB) dist
+	install -m 755 $(SHAREDLIB) dist
+	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
+	install libopenjpeg/openjpeg.h dist
+
+OpenJPEG: $(STATICLIB) $(SHAREDLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(LIBTOOLSTAT) -o $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(LIBTOOLDYN) -dynamiclib -o $@ $(MODULES)
+
+install:
+	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
+	install -m 644 -o root -g wheel $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
+	install -m 755 -o root -g wheel $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
+	install -m 644 -o root -g wheel ./libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
+
+clean:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+	
diff -urN /home/robin/sldeb/trunk/.svn/text-base/Makefile.svn-base ./.svn/text-base/Makefile.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/Makefile.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/Makefile.svn-base	2007-11-27 22:39:51.000000000 +0000
@@ -0,0 +1,78 @@
+# Linux makefile for OpenJPEG
+
+VER_MAJOR = 2
+VER_MINOR = 1.2.0
+
+SRCS = ./libopenjpeg/bio.c ./libopenjpeg/cio.c ./libopenjpeg/dwt.c ./libopenjpeg/event.c ./libopenjpeg/image.c ./libopenjpeg/j2k.c ./libopenjpeg/j2k_lib.c ./libopenjpeg/jp2.c ./libopenjpeg/jpt.c ./libopenjpeg/mct.c ./libopenjpeg/mqc.c ./libopenjpeg/openjpeg.c ./libopenjpeg/pi.c ./libopenjpeg/raw.c ./libopenjpeg/t1.c ./libopenjpeg/t2.c ./libopenjpeg/tcd.c ./libopenjpeg/tgt.c
+INCLS = ./libopenjpeg/bio.h ./libopenjpeg/cio.h ./libopenjpeg/dwt.h ./libopenjpeg/event.h ./libopenjpeg/fix.h ./libopenjpeg/image.h ./libopenjpeg/int.h ./libopenjpeg/j2k.h ./libopenjpeg/j2k_lib.h ./libopenjpeg/jp2.h ./libopenjpeg/jpt.h ./libopenjpeg/mct.h ./libopenjpeg/mqc.h ./libopenjpeg/openjpeg.h ./libopenjpeg/pi.h ./libopenjpeg/raw.h ./libopenjpeg/t1.h ./libopenjpeg/t2.h ./libopenjpeg/tcd.h ./libopenjpeg/tgt.h ./libopenjpeg/opj_malloc.h ./libopenjpeg/opj_includes.h 
+INCLUDE = -Ilibopenjpeg
+
+# General configuration variables:
+CC = gcc
+AR = ar
+
+PREFIX = /usr
+INSTALL_LIBDIR = $(PREFIX)/lib
+INSTALL_INCLUDE = $(PREFIX)/include
+
+# Converts cr/lf to just lf
+DOS2UNIX = dos2unix
+
+COMPILERFLAGS = -Wall -O3 -ffast-math -std=c99 -fPIC
+LIBRARIES = -lstdc++
+
+MODULES = $(SRCS:.c=.o)
+CFLAGS = $(COMPILERFLAGS) $(INCLUDE)
+
+TARGET  = openjpeg
+STATICLIB = lib$(TARGET).a
+SHAREDLIB = lib$(TARGET)-$(VER_MAJOR).$(VER_MINOR).so
+LIBNAME = lib$(TARGET).so.$(VER_MAJOR)
+
+
+
+default: all
+
+all: OpenJPEG
+
+dist: OpenJPEG
+	install -d dist
+	install -m 644 $(STATICLIB) dist
+	install -m 755 $(SHAREDLIB) dist
+	ln -sf $(SHAREDLIB) dist/$(LIBNAME)
+	install libopenjpeg/openjpeg.h dist
+
+dos2unix:
+	@$(DOS2UNIX) $(SRCS) $(INCLS)
+
+OpenJPEG: $(STATICLIB) $(SHAREDLIB)
+
+.c.o:
+	$(CC) $(CFLAGS) -c $< -o $@
+
+$(STATICLIB): $(MODULES)
+	$(AR) r $@ $(MODULES)
+
+$(SHAREDLIB): $(MODULES)
+	$(CC) -s -shared -Wl,-soname,$(LIBNAME) -o $@ $(MODULES) $(LIBRARIES)
+
+install: OpenJPEG
+	install -d '$(DESTDIR)$(INSTALL_LIBDIR)' '$(DESTDIR)$(INSTALL_INCLUDE)'
+	install -m 644 -o root -g root $(STATICLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ranlib '$(DESTDIR)$(INSTALL_LIBDIR)/$(STATICLIB)'
+	install -m 755 -o root -g root $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)'
+	ln -sf $(SHAREDLIB) '$(DESTDIR)$(INSTALL_LIBDIR)/$(LIBNAME)'
+	install -m 644 -o root -g root libopenjpeg/openjpeg.h '$(DESTDIR)$(INSTALL_INCLUDE)'
+	-ldconfig
+
+clean:
+	rm -rf core dist/ u2dtmp* $(MODULES) $(STATICLIB) $(SHAREDLIB) $(LIBNAME)
+
+osx:
+	make -f Makefile.osx
+
+osxinstall:
+	make -f Makefile.osx install
+
+osxclean:
+	make -f Makefile.osx clean
diff -urN /home/robin/sldeb/trunk/.svn/text-base/OpenJPEG.rc.svn-base ./.svn/text-base/OpenJPEG.rc.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/OpenJPEG.rc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/OpenJPEG.rc.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,109 @@
+//Microsoft Developer Studio generated resource script.
+//
+#include "resource.h"
+
+#define APSTUDIO_READONLY_SYMBOLS
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 2 resource.
+//
+#include "afxres.h"
+
+/////////////////////////////////////////////////////////////////////////////
+#undef APSTUDIO_READONLY_SYMBOLS
+
+/////////////////////////////////////////////////////////////////////////////
+// French (France) resources
+
+#if !defined(AFX_RESOURCE_DLL) || defined(AFX_TARG_FRA)
+#ifdef _WIN32
+LANGUAGE LANG_FRENCH, SUBLANG_FRENCH
+#pragma code_page(1252)
+#endif //_WIN32
+
+#ifndef _MAC
+/////////////////////////////////////////////////////////////////////////////
+//
+// Version
+//
+
+VS_VERSION_INFO VERSIONINFO
+ FILEVERSION 1,1,0,0
+ PRODUCTVERSION 1,1,0,0
+ FILEFLAGSMASK 0x3fL
+#ifdef _DEBUG
+ FILEFLAGS 0x1L
+#else
+ FILEFLAGS 0x0L
+#endif
+ FILEOS 0x40004L
+ FILETYPE 0x2L
+ FILESUBTYPE 0x0L
+BEGIN
+    BLOCK "StringFileInfo"
+    BEGIN
+        BLOCK "000004b0"
+        BEGIN
+            VALUE "Comments", "The OpenJPEG library is an open-source JPEG 2000 codec. \0"
+            VALUE "CompanyName", "OpenJPEG\0"
+            VALUE "FileDescription", "OpenJPEG\0"
+            VALUE "FileVersion", "1, 1, 0, 0\0"
+            VALUE "InternalName", "OpenJPEG\0"
+            VALUE "LegalCopyright", "Copyright © 2002-2007, Communications and remote sensing Laboratory, Universite catholique de Louvain, Belgium\0"
+            VALUE "LegalTrademarks", "See http://www.openjpeg.org for details\0"
+            VALUE "OriginalFilename", "OpenJPEG.dll\0"
+            VALUE "PrivateBuild", "\0"
+            VALUE "ProductName", "OpenJPEG\0"
+            VALUE "ProductVersion", "1, 1, 0, 0\0"
+            VALUE "SpecialBuild", "\0"
+        END
+    END
+    BLOCK "VarFileInfo"
+    BEGIN
+        VALUE "Translation", 0x0, 1200
+    END
+END
+
+#endif    // !_MAC
+
+
+#ifdef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// TEXTINCLUDE
+//
+
+1 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "resource.h\0"
+END
+
+2 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "#include ""afxres.h""\r\n"
+    "\0"
+END
+
+3 TEXTINCLUDE DISCARDABLE 
+BEGIN
+    "\r\n"
+    "\0"
+END
+
+#endif    // APSTUDIO_INVOKED
+
+#endif    // French (France) resources
+/////////////////////////////////////////////////////////////////////////////
+
+
+
+#ifndef APSTUDIO_INVOKED
+/////////////////////////////////////////////////////////////////////////////
+//
+// Generated from the TEXTINCLUDE 3 resource.
+//
+
+
+/////////////////////////////////////////////////////////////////////////////
+#endif    // not APSTUDIO_INVOKED
+
diff -urN /home/robin/sldeb/trunk/.svn/text-base/README.cmake.svn-base ./.svn/text-base/README.cmake.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/README.cmake.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/README.cmake.svn-base	2007-09-28 11:33:50.000000000 +0100
@@ -0,0 +1,9 @@
+Basic instructions on how to build using CMake (CMake 2.4.5 or newer is required)
+
+  svn co http://www.openjpeg.org/svn/trunk
+  cd trunk
+  mkdir bin
+  cd bin
+  cmake .. -DBUILD_EXAMPLES:BOOL=ON
+  make
+  ./bin/j2k_to_image 
diff -urN /home/robin/sldeb/trunk/.svn/text-base/README.linux.svn-base ./.svn/text-base/README.linux.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/README.linux.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/README.linux.svn-base	2007-09-28 11:33:43.000000000 +0100
@@ -0,0 +1,33 @@
+Release Notes
+--------------
+This version of the library has been tested under the following OS:
+- RedHat Linux 9.0
+
+You should be able to link progams with the -lopenjpeg option after the library is compiled and installed. 
+You can also statically link with libopenjpeg.a.
+If you use a really old version of gcc and it chokes on the CRs in the file, you can type 'make dos2unix'
+to run all of the files through dos2unix which converts CRLF to LF.  This no longer appears to be required
+for RedHat 7.3 or 9.
+
+Please let us know how this works for you under other Linux distributions or any other *nix.
+
+Installation
+------------
+Note: You will need to have root privileges in order to install the library in
+/usr/include and /usr/lib directories.
+The installation process is as simple as this : 
+1) Enter the OpenJPEG directory
+2) Build the distribution : 
+make
+make install
+3) Clean all files produced during the build process
+make clean
+
+Simple codec compilation
+------------------------
+Once you've built the library, you might want to test it with a basic codec. To do this, go to the codec directory and use one of the following commands to build an encoder and decoder respectively:
+
+gcc convert.c image_to_j2k.c -o image_to_j2k -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+gcc convert.c j2k_to_image.c -o j2k_to_image -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+
+You should add '-L..' to those lines if you did not use the 'install' target (and the 'clean' target neither...).
diff -urN /home/robin/sldeb/trunk/.svn/text-base/README.msvc.svn-base ./.svn/text-base/README.msvc.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/README.msvc.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/README.msvc.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,40 @@
+How to compile the library under MS VC++ 6.0
+--------------------------------------------
+
+The library comes in two versions : 
+- a static library that can be linked against any C/C++ program
+- a Dynamic Link Library (Windows DLL) that can be used in any C/C++ program and in most interpreted languages (e.g. VB, C#, ...). 
+
+In order to compile the library version *or* the DLL version, you will have to : 
+
+1) Open the MSVC workspace named LibOpenJPEG.dsw
+2) Set the choosen target as the active project, that means : 
+ a) Go to the Menu 'Build -> Set Active Configuration'
+ b) Choose one of the following configuration : 
+ - DllOpenJPEG - Win32 Release => creates a DLL in release mode named OpenJPEG.dll
+ - DllOpenJPEG - Win32 Debug => creates a DLL in debug mode named OpenJPEGd.dll 
+ - LibOpenJPEG - Win32 Release => creates a static library in release mode named LibOpenJPEG.lib
+ - LibOpenJPEG - Win32 Debug => creates a static library in debug mode named LibOpenJPEGd.lib
+3) Build the project : Menu -> Build -> Rebuild All
+
+The build process will create a directory named 'dist' that will contain all you need in order to use the library. 
+
+Simple codec compilation
+------------------------
+
+Once you've built the library, you might want to test it with a basic codec. To do this, go to the codec directory and use one of the following projects to build an encoder and decoder respectively:
+- image_to_j2k.dsw
+- j2k_to_image.dsw
+
+IMPORTANT NOTE : 
+----------------
+
+The encoder and decoder samples are configured to use the static version of the library. A link to the LibOpenJPEG static project is included in these projects so that you can build both a codec and the library in a single pass. 
+
+However, you MUST NOTE that in order to use LibOpenJPEG as a static library in your program, you NEED to add the following compiler directive to your project : OPJ_STATIC
+Look at the menu 'Project -> Settings -> C/C++ tab -> preprocessor definition' to see how this is configured. 
+When using OpenJPEG as a DLL, this compiler directive MUST NOT be used. 
+
+
+
+
diff -urN /home/robin/sldeb/trunk/.svn/text-base/README.osx.svn-base ./.svn/text-base/README.osx.svn-base
--- /home/robin/sldeb/trunk/.svn/text-base/README.osx.svn-base	1970-01-01 01:00:00.000000000 +0100
+++ ./.svn/text-base/README.osx.svn-base	2007-09-28 11:33:49.000000000 +0100
@@ -0,0 +1,26 @@
+Release Notes
+--------------
+This version of the library has been tested under OSX 10.3 using gcc 3.3.
+
+While the makefiles will make a .dylib and a .a, it is recommended to simply staticly link with the .a file.
+
+Installation
+------------
+Note: You will need to have root privileges in order to install the library in
+/usr/include and /usr/lib directories.
+The installation process is as simple as this : 
+1) Enter the OpenJPEG directory
+2) Build the distribution : 
+make osx
+make osxinstall
+3) Clean all files produced during the build process
+make osxclean
+
+Simple codec compilation
+------------------------
+Once you've built the library, you might want to test it with a basic codec. To do this, go to the codec directory and use one of the following commands to build an encoder and decoder respectively:
+
+gcc convert.c image_to_j2k.c -o image_to_j2k -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+gcc convert.c j2k_to_image.c -o j2k_to_image -lopenjpeg -I ../libopenjpeg/ -lm -ltiff
+
+You should add '-L..' and to those lines if you did not use the 'install' target (and the 'clean' target neither...).
